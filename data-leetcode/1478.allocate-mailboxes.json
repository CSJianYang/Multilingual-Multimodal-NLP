[
    {
        "title": "Numbers With Repeated Digits",
        "question_content": "Given an integer n, return the number of positive integers in the range [1, n] that have at least one repeated digit.\n&nbsp;\nExample 1:\n\nInput: n = 20\nOutput: 1\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\n\nExample 2:\n\nInput: n = 100\nOutput: 10\nExplanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\nExample 3:\n\nInput: n = 1000\nOutput: 262\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 109",
        "solutions": [
            {
                "id": 3544075,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits{};\\n        int temp = n + 1;\\n        while (temp > 0) {\\n            digits.emplace_back(temp % 10);\\n            temp /= 10;\\n        }\\n        int result = 0;\\n        int len = digits.size();\\n        int curr = 9;\\n        for (int i = 0; i < len - 1; i++) {\\n            result += curr;\\n            curr *= 9 - i;\\n        }\\n        curr /= 9;\\n        vector<bool> seen(10, false);\\n        for (int i = 0; i < len; i++) {\\n            int d = digits[len - i - 1];\\n\\n            for (int j = i == 0 ? 1 : 0; j < d; j++) if (!seen[j]) result += curr;\\n            curr /= 9 - i;\\n\\n            if (seen[d]) break;\\n            seen[d] = true;\\n        }\\n        return n - result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom math import perm\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        digits = list(map(int, str(n + 1)))\\n        nl = len(digits)\\n        res = sum(9 * perm(9, i) for i in range(nl - 1))\\n        s = set()\\n        for i, x in enumerate(digits):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, nl - i - 1)\\n            if x in s:\\n                break\\n            s.add(x)\\n        return n - res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits{};\\n        int temp = n + 1;\\n        while (temp > 0) {\\n            digits.emplace_back(temp % 10);\\n            temp /= 10;\\n        }\\n        int result = 0;\\n        int len = digits.size();\\n        int curr = 9;\\n        for (int i = 0; i < len - 1; i++) {\\n            result += curr;\\n            curr *= 9 - i;\\n        }\\n        curr /= 9;\\n        vector<bool> seen(10, false);\\n        for (int i = 0; i < len; i++) {\\n            int d = digits[len - i - 1];\\n\\n            for (int j = i == 0 ? 1 : 0; j < d; j++) if (!seen[j]) result += curr;\\n            curr /= 9 - i;\\n\\n            if (seen[d]) break;\\n            seen[d] = true;\\n        }\\n        return n - result;\\n    }\\n};\\n```\n```Python3 []\\nfrom math import perm\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        digits = list(map(int, str(n + 1)))\\n        nl = len(digits)\\n        res = sum(9 * perm(9, i) for i in range(nl - 1))\\n        s = set()\\n        for i, x in enumerate(digits):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, nl - i - 1)\\n            if x in s:\\n                break\\n            s.add(x)\\n        return n - res\\n```\n```Java []\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256725,
                "title": "java-python-count-the-number-without-repeated-digit",
                "content": "# **Intuition**\\nCount `res` the Number Without Repeated Digit\\nThen the number with repeated digits = N - res\\n\\nSimilar as\\n788. Rotated Digits\\n902. Numbers At Most N Given Digit Set\\n\\n\\n# **Explanation**:\\n\\n1. Transform `N + 1` to arrayList\\n2. Count the number with digits < n\\n3. Count the number with same prefix\\n\\nFor example,\\nif `N = 8765`, `L = [8,7,6,6]`,\\nthe number without repeated digit can the the following format:\\n`XXX`\\n`XX`\\n`X`\\n`1XXX ~ 7XXX`\\n`80XX ~ 86XX`\\n`870X ~ 875X`\\n`8760 ~ 8765`\\n\\n\\n# **Time Complexity**:\\nthe number of permutations `A(m,n)` is `O(1)`\\nWe count digit by digit, so it\\'s `O(logN)`\\n\\n<br>\\n\\n**Java:**\\n```java\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n```\\n**Python3**\\n```py\\n    def numDupDigitsAtMostN(self, N):\\n        L = list(map(int, str(N + 1)))\\n        n = len(L)\\n        res = sum(9 * perm(9, i) for i in range(n - 1))\\n        s = set()\\n        for i, x in enumerate(L):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: break\\n            s.add(x)\\n        return N - res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```java\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n```\n```py\\n    def numDupDigitsAtMostN(self, N):\\n        L = list(map(int, str(N + 1)))\\n        n = len(L)\\n        res = sum(9 * perm(9, i) for i in range(n - 1))\\n        s = set()\\n        for i, x in enumerate(L):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: break\\n            s.add(x)\\n        return N - res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 258212,
                "title": "share-my-o-logn-c-dp-solution-with-proof-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nGiven a positive integer ```N```, return the number of positive integers less than or equal to ```N``` that have at least 1 repeated digit.\\n\\n**Example 1:**\\n```\\nInput: 20\\nOutput: 1\\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\\n```\\n\\n**Example 2:**\\n```\\nInput: 100\\nOutput: 10\\nExplanation: The positive numbers (<= 100) with at least 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\\n```\\n\\n**Example 3:**\\n```\\nInput: 1000\\nOutput: 262\\n```\\n**Note:**\\n* 1 <= N <= 10^9\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Analysis\\n\\n---\\nThe problem is to return \\n\\n>#### T(N) = the number of positive integers less than or equal to N that have **at least 1 repeated digit**.\\n\\nSuppose\\n\\n>#### S(N) = the number of positive integers less than or equal to N that have **NO repeated digits**.\\n\\nThe answer can be expressed as\\n\\n>#### T(N) = N - S(N).\\n\\nLater, the calculation of S(N) will be focused on.\\n\\n---\\n#### 2.2 Find the rules\\n\\n---\\n\\n- From **1** to **9**, there are **9** positive integers that have **NO repeated digits**.\\n\\n- From **10** to **99**,\\n  - From **10** to **19**, there are **9** positive integers that have **NO repeated digits**. (Only **11** has repeated digits)\\n  - From **20** to **29**, there are **9** positive integers that have **NO repeated digits**. (Only **22** has repeated digits)\\n  - From **30** to **39**, there are **9** positive integers that have **NO repeated digits**. (Only **33** has repeated digits)\\n  - From **40** to **49**, there are **9** positive integers that have **NO repeated digits**. (Only **44** has repeated digits)\\n  - From **50** to **59**, there are **9** positive integers that have **NO repeated digits**. (Only **55** has repeated digits)\\n  - From **60** to **69**, there are **9** positive integers that have **NO repeated digits**. (Only **66** has repeated digits)\\n  - From **70** to **79**, there are **9** positive integers that have **NO repeated digits**. (Only **77** has repeated digits)\\n  - From **80** to **89**, there are **9** positive integers that have **NO repeated digits**. (Only **88** has repeated digits)\\n  - From **90** to **99**, there are **9** positive integers that have **NO repeated digits**. (Only **99** has repeated digits)\\n  there are **9 \\xD7 9 = 81** positive integers that have **NO repeated digits**.  \\n  \\n- From **100** to **999**,\\n  - From **100** to **199**,\\n    - From **100** to **109**, there are **8** positive integers that have **NO repeated digits**. (**100** and **101** have repeated digits)\\n    - From **110** to **119**, there are **0** positive integers that have **NO repeated digits**. (**ALL numbers** have repeated digits because of the prefix **11**)\\n    - From **120** to **129**, there are **8** positive integers that have **NO repeated digits**. (**121** and **122** have repeated digits)\\n    - From **130** to **139**, there are **8** positive integers that have **NO repeated digits**. (**131** and **133** have repeated digits)\\n    - From **140** to **149**, there are **8** positive integers that have **NO repeated digits**. (**141** and **144** have repeated digits)\\n    - From **150** to **159**, there are **8** positive integers that have **NO repeated digits**. (**151** and **155** have repeated digits)\\n    - From **160** to **169**, there are **8** positive integers that have **NO repeated digits**. (**161** and **166** have repeated digits)\\n    - From **170** to **179**, there are **8** positive integers that have **NO repeated digits**. (**171** and **177** have repeated digits)\\n    - From **180** to **189**, there are **8** positive integers that have **NO repeated digits**. (**181** and **188** have repeated digits)\\n    - From **190** to **199**, there are **8** positive integers that have **NO repeated digits**. (**191** and **199** have repeated digits)\\n    there are **9 \\xD7 8 = 72** positive integers that have **NO repeated digits**.\\n  - .....\\n\\nLet\\'s think about all positive integers **from 100 to 199**.\\n \\nThey can be generated by \\n\\n>#### adding a new digit from **0** to **9** to the end of all positive integers from **10** to **19**.\\nIn order to generate a new positive integer that has **NO** repeated digits,\\n- To **10**: **10 has NO repeated digits**. There are **8 choices (0 and 1 can NOT be chosen)**.\\n- To **11**: **11 has repeated digits**. There are **0 choices (0 to 9 can NOT be chosen)**.\\n- To **12**: **12 has NO repeated digits**. There are **8 choices (1 and 2 can NOT be chosen)**.\\n- To **13**: **13 has NO repeated digits**. There are **8 choices (1 and 3 can NOT be chosen)**.\\n- To **14**: **14 has NO repeated digits**. There are  **8 choices (1 and 4 can NOT be chosen)**.\\n- To **15**: **15 has NO repeated digits**. There are  **8 choices (1 and 5 can NOT be chosen)**.\\n- To **16**: **16 has NO repeated digits**. There are  **8 choices (1 and 6 can NOT be chosen)**.\\n- To **17**: **17 has NO repeated digits**. There are  **8 choices (1 and 7 can NOT be chosen)**.\\n- To **18**: **18 has NO repeated digits**. There are  **8 choices (1 and 8 can NOT be chosen)**.\\n- To **19**: **19 has NO repeated digits**. There are  **8 choices (1 and 9 can NOT be chosen)**.\\n\\nAre there rules?\\n\\n---\\n>#### **Rule A:** \\n>#### **A k-digit positive integer with NO repeated digits can ONLY be generated from (k - 1)-digit positive integers with NO repeated digits (k > 1).**\\n\\nProof:\\n\\nIf a (k - 1)-digit positive integer has repeated digits (e.g. **11**), \\nafter adding a digit (**0** to **9**) to its end, the generated k-digit integer (e.g. 110, 111, ..., 119) **STILL has repeated digits**.\\nThat\\'s to say, a k-digit positive integer with **NO** repeated digits can **ONLY** be generated from (k - 1)-digit positive integers with **NO** repeated digits.\\n\\n---\\n\\n>#### **Rule B:** \\n>#### **To generate a k-digit positive integer with NO repeated digits,** \\n>#### **there are (10 - k + 1) digits that can be added to (k - 1)-digit positive integers with NO repeated digits (k > 1).**\\n\\nProof:\\n\\nA (k - 1)-digit positive integer **with NO repeated digits** has **k - 1 distinct digits**.\\nWhen generating a k-digit positive integer **with NO repeated digits** from it, \\nsince **k - 1** digits in **0** to **9** have been **used**, there are **10 - k + 1** choices for the digit to be added.\\n\\n\\n---\\n#### 2.3 Recursion formula\\n\\n---\\nDefinition:\\n\\n>#### **f(i, j, k): The number of i-digit positive integers with NO repeated digits in the interval [j, k]. (i > 0, j \\u2264 k, j and k are i-digit positive integers).**\\n\\n\\nBased on the **Rule A and Rule B in Section 2.2**, the recursion formula is\\n\\n>#### **f(i, j, k) = k - j + 1. i = 1.**\\n>#### **f(i + 1, 10j, 10k + 9) = f(i, j, k) \\xD7 (10 - i). others.**\\n\\n---\\n#### 2.4 Normal case analysis\\n\\n\\n---\\n\\nIn order to illustrate the usage of the recursion formula in Section 2.3, we take a normal case for calculation.\\n\\nIf **N = 26334**,\\n\\nFrom **Section 2.3**,\\n \\n- From **1** to **9**, f(1, 1, 9) = 9.\\n- From **10** to **99**, f(2, 10, 99) = f(1, 1, 9) \\xD7 (10 - 1) = 9 \\xD7 9 = 81.\\n- From **100** to **999**, f(3, 100, 999) = f(2, 10, 99) \\xD7 (10 - 2) = 81 \\xD7 8 = 648.\\n- From **1000** to **9999**, f(4, 1000, 9999) = f(3, 100, 999) \\xD7 (10 - 3) = 648 \\xD7 7 = 4536.\\n\\nIf all values are added together, the sum is\\n\\n>#### **S(9999) = f(1, 1, 9) + f(2, 10, 99) + f(3, 100, 999) + f(4, 1000, 9999) = 9 + 81 + 648 + 4536 = 5274.**\\n\\nNow the number of positive integers **with NO repeated digits less than or equal to 9999** has been calculated, which is the **first part of the whole result**.\\n\\n\\n---\\nHow about the rest?\\n\\nThe rest part is the number of positive integers **with NO repeated digits in interval [10000, 26334]**, which is\\n\\n>#### **P = f(5, 10000, 26334)**.\\n\\nHow can the recursion formula be applied here?\\n\\n---\\nSince our target is to **calculate f(5, 10000, 26334)**, the **calculation series** is\\n\\n>#### **f(1, 1, 2), f(2, 10, 26), f(3, 100, 263), f(4, 1000, 2633), f(5, 10000, 26334).**\\n\\n\\n- From **1** to **2**, **f(1, 1, 2) = 2**.\\n\\n\\n- From **10** to **29**, by applying the recursion formula, **f(2, 10, 29) = f(1, 1, 2) \\xD7 (10 - 1) = 2 \\xD7 9 = 18**.\\n\\n  - From **27 to 29**, there are **3** positive integers **with NO repeated digits**, which means **f(2, 27, 29) = 3**.   \\n\\n  - **f(2, 10, 26) = f(2, 10, 29) - f(2, 27, 29) = 18 - 3 = 15**.\\n  \\n\\n- From **100** to **269**, by applying the recursion formula, **f(3, 100, 269) = f(2, 10, 26) \\xD7 (10 - 2) = 15 \\xD7 8 = 120**.\\n\\n  - From **264 to 269**, there are **5** positive integers **with NO repeated digits** (**except 266**), which means **f(3, 264, 269) = 5**.\\n  \\n  - **f(3, 100, 263) = f(3, 100, 269) - f(3, 264, 269) = 120 - 5 = 115**.\\n  \\n  \\n- From **1000** to **2639**, by applying the recursion formula, **f(4, 1000, 2639) = f(3, 100, 263) \\xD7 (10 - 3) = 115 \\xD7 7 = 805**.\\n\\n  - From **2634 to 2639**, there are **5** positive integers **with NO repeated digits** (**except 2636**), which means **f(4, 2634, 2639) = 5**.\\n  \\n  - **f(4, 1000, 2633) = f(4, 1000, 2639) - f(4, 2634, 2639) = 805 - 5 = 800**. \\n\\n  \\n- From **10000** to **26339**, by applying the recursion formula, **f(4, 10000, 26339) = f(4, 1000, 2633) \\xD7 (10 - 4) = 800 \\xD7 6 = 4800**.\\n\\n  - From **26335 to 26339**, there are **NO** positive integers **with NO repeated digits** (**due to the prefix \"2633\"**), which means **f(5, 26335, 26339) = 0**.\\n  \\n  - **f(5, 10000, 26334) = f(4, 10000, 26339) - f(5, 26335, 26339) = 4800 - 0 = 4800**.\\n\\nThis is the **second part of the whole result**.\\n\\n---\\nThen\\n\\n>#### **S(26334) = S(9999) + f(5, 10000, 26334) = 5274 + 4800 = 10074.**\\n\\n\\nThe final answer is\\n\\n>#### **T(26334) = 26334 - S(26334) = 26334 - 10074 = 16260.**\\n\\n---\\n#### 2.4 Algorithm\\n\\n\\n---\\n**Special case**:\\n- If N < 10, return 0.\\n\\n---\\n**Get digits**:\\n- Initialization:\\n\\n  - Set k = 0. i = N.\\n\\n- Loop: while i > 0, \\n  \\n  - Set k = k + 1. (Now, k is the digit length of N).\\n\\n  - Set i = i / 10. \\n  \\n- Initialization: \\n\\n  - Set j = N.\\n\\n  - Array digit with size = k. (saving all digits in N)\\n  \\n- Loop: iterate i from 0 to k - 1\\n\\n  - Set digit[k - 1 - i] = j mod 10.\\n  \\n  - Set j = j / 10.\\n\\n---\\n**Get first part**:\\n\\n- Initialization: \\n\\n  - Array noDupBase with size = k - 1. \\n  \\n  - Set noDupBaseSum = 0. (calculate first part)\\n\\n- Loop: iterate i from 0 to k - 2.\\n\\n  - If i = 0, noDupBase[i] = 9. Calculate f(1, 1, 9).\\n  \\n  - Else, noDupBase[i] = noDupBase[i - 1] \\xD7 (10 - i). Calculate f(i, 10^(i - 1), 10^i - 1).\\n  \\n  - Set noDupBaseSum = noDupBaseSum + noDupBase[i].\\n\\n---\\n**Get second part**:\\n\\n- Initialization: \\n\\n  - Set boolean value duplicate = false. (prefix duplicate) \\n  \\n  - Array count with size = 10.(record the digits\\' count in prefix). \\n  \\n  - Array noDupRes with size = k. (calculate second part)\\n  \\n- Loop: iterate i from 0 to k - 1.\\n\\n  - If i = 0, noDupBase[i] = 9. Calculate f(1, 1, 9).\\n  \\n  - Else, noDupBase[i] = noDupBase[i - 1] \\xD7 (10 - i).\\n  \\n  - If NOT duplicate\\n  \\n    - Set diff = 0.\\n\\t\\n\\t- Loop: iterate j from digit[i] + 1 to 9\\n\\t\\n\\t  - If count[j] = 0, Set diff = diff + 1.\\n\\t  \\n\\t- Set noDupRes[i] = noDupRes[i] - diff.\\n\\t\\n\\t- Set count[digit[i]] = count[digit[i]] + 1.\\n\\t\\n\\t- If count[digit[i]] > 1, Set duplicate = true.\\n\\n---\\n**Get final answer**:\\n\\t\\n- return N - (noDupBaseSum + noDupRes[k - 1]).\\n\\n\\n---\\n## 4. Complexity Analysis\\n\\n---\\n\\n#### 4.1 Time complexity\\n\\n---\\n\\n>#### The time complexity is **O(logN)**.\\n\\n---\\n\\n#### 4.2 Space complexity\\n\\n---\\n\\n>#### The space complexity is **O(logN)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N < 10) return 0;\\n        int k = 0;\\n        for(int i = N; i > 0; i /= 10) k++;\\n        int digit[k] = {0};\\n        for(int i = 0, j = N; i < k; i++, j /= 10) digit[k - 1 - i] = j % 10;\\n        \\n        int noDupBaseSum = 0;\\n        int noDupBase[k - 1] = {0};\\n        for(int i = 0; i < k - 1; i++)\\n        {\\n            noDupBase[i] = i == 0 ? 9 : noDupBase[i - 1] * (10 - i);\\n            noDupBaseSum += noDupBase[i];\\n        }\\n        \\n        int count[10] = {0};\\n        int noDupRes[k] = {0};\\n        bool duplicate = false;\\n        for(int i = 0; i < k; i++)\\n        {\\n            noDupRes[i] = i == 0 ? 9 : noDupRes[i - 1] * (10 - i);\\n            if(!duplicate)\\n            {\\n                int diff = 0;\\n                for(int j = digit[i] + 1; j < 10; j++) diff += count[j] == 0;\\n                noDupRes[i] -= diff;\\n                count[digit[i]]++;\\n                if(count[digit[i]] > 1) duplicate = true;\\n            }\\n        }\\n        return N - (noDupBaseSum + noDupRes[k - 1]);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```N```\n```N```\n```\\nInput: 20\\nOutput: 1\\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\\n```\n```\\nInput: 100\\nOutput: 10\\nExplanation: The positive numbers (<= 100) with at least 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\\n```\n```\\nInput: 1000\\nOutput: 262\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256866,
                "title": "python-o-logn-solution-with-clear-explanation",
                "content": "The number of non-repeated digits can be easily calculated with permutaiton. We only need to exclude all the non-repeated digits to get the answer.\\n\\nLet\\'s first consider about the cases where N=10^k\\n**N=10**\\nthe free digits are marked as `*`, so we only need to consider about `*` and `1*`\\n* `*`: obviously all 1-digit numbers are non-repeated, so non-repeated number = 9\\n* `1*`: we only need to consider about `1* <= 10`, so non-repeated number = 1\\n\\nThus, the result for N=10 is:\\n`N - #non_repeat(*) - #non_repeat(1*) = 10 - 9 - 1 = 0`\\n\\n**N=100**\\nthe free digits are marked as `*`, so we only need to consider about `*`, `**`, and `1**`\\n* `*`: obviously all 1-digit numbers are non-repeated, so non-repeated number = 9\\n* `**`: this can be calculated with permutation: leading digit has 9 options(1-9) and the last 1 digit has `10-1` options, thus the total permuation is `9 * permutation(9, 1)=81`. i.e: non-repeated number = 81\\n* `1**`: we only need to consider about `1**<=100`, so non-repeated number =0\\n\\nThus, the result for N=100 is:\\n`N - #non_repeat(*) - #non_repeat(**) - #non_repeat(1**) = 100 - 9 - 81 = 10`\\n\\n**N=1000**\\n`#non_repeat(***) = 9 * permutation(9, 2) = 9 * 9 * 8 = 648`\\nsimilarly, we can get:\\n`N - #non_repeat(*) - #non_repeat(**) - #non_repeat(***) - #non_repeat(1***) = 1000 - 9 - 81 - 648 = 282`\\n\\nNow, let\\'s consider a more general case:\\n**N=12345**\\nactually, we can get the count of non-repeated numbers  by counting all non-repeated numbers in following patterns:\\n\\n```\\n    *\\n   **\\n  ***\\n ****\\n10***\\n11*** (prefix repeated, skip)\\n120**\\n121** (prefix repeated, skip)\\n122** (prefix repeated, skip)\\n1230*\\n1231* (prefix repeated, skip)\\n1232* (prefix repeated, skip)\\n1233* (prefix repeated, skip)\\n12340\\n12341 (prefix repeated, skip)\\n12342\\n12343\\n12344 (prefix repeated, skip)\\n12345\\n```\\n\\nand use N to minus the count we will get the answer.\\n\\nReference implementation:\\n```\\n# given number n, see whether n has repeated number\\ndef has_repeated(n):\\n    str_n = str(n)\\n    return len(set(str_n)) != len(str_n)\\n\\ndef permutation(n, k):\\n    prod = 1\\n    for i in range(k):\\n        prod *= (n-i)\\n    return prod\\n\\n# calculate number of non-repeated n-digit numbers\\n# note: the n-digit number can\\'t start with 0\\n# i.e: n_digit_no_repeat(2) calculates the non-repeated\\n#   numbers in range [10, 99] (inclusive)\\ndef n_digit_no_repeat(n):\\n    if n == 1:\\n        return 9\\n    else:\\n        return  9 * permutation(9, n-1)\\n\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"        \\n        N_str = str(N)\\n        n_digit = len(N_str)\\n        digits = map(int, N_str)\\n        result = N - 1\\n        prefix = 0\\n        for i in range(1, n_digit):\\n            result -= n_digit_no_repeat(i)\\n        for i in range(n_digit):\\n            # when we fix the most significant digit, it \\n            # can\\'t be zero\\n            start = 0 if i else 1\\n            for j in range(start, digits[i]):\\n                if has_repeated(prefix * 10 + j):\\n                    continue\\n                if i != n_digit-1:\\n                    result -= permutation(10-i-1, n_digit-1-i)\\n                else:\\n                    # optmized from `result -= has_repeated(prefix*10+j)`\\n                    result -= 1\\n            prefix = prefix*10 + digits[i]\\n        return result + has_repeated(N)\\n```",
                "solutionTags": [],
                "code": "```\\n    *\\n   **\\n  ***\\n ****\\n10***\\n11*** (prefix repeated, skip)\\n120**\\n121** (prefix repeated, skip)\\n122** (prefix repeated, skip)\\n1230*\\n1231* (prefix repeated, skip)\\n1232* (prefix repeated, skip)\\n1233* (prefix repeated, skip)\\n12340\\n12341 (prefix repeated, skip)\\n12342\\n12343\\n12344 (prefix repeated, skip)\\n12345\\n```\n```\\n# given number n, see whether n has repeated number\\ndef has_repeated(n):\\n    str_n = str(n)\\n    return len(set(str_n)) != len(str_n)\\n\\ndef permutation(n, k):\\n    prod = 1\\n    for i in range(k):\\n        prod *= (n-i)\\n    return prod\\n\\n# calculate number of non-repeated n-digit numbers\\n# note: the n-digit number can\\'t start with 0\\n# i.e: n_digit_no_repeat(2) calculates the non-repeated\\n#   numbers in range [10, 99] (inclusive)\\ndef n_digit_no_repeat(n):\\n    if n == 1:\\n        return 9\\n    else:\\n        return  9 * permutation(9, n-1)\\n\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"        \\n        N_str = str(N)\\n        n_digit = len(N_str)\\n        digits = map(int, N_str)\\n        result = N - 1\\n        prefix = 0\\n        for i in range(1, n_digit):\\n            result -= n_digit_no_repeat(i)\\n        for i in range(n_digit):\\n            # when we fix the most significant digit, it \\n            # can\\'t be zero\\n            start = 0 if i else 1\\n            for j in range(start, digits[i]):\\n                if has_repeated(prefix * 10 + j):\\n                    continue\\n                if i != n_digit-1:\\n                    result -= permutation(10-i-1, n_digit-1-i)\\n                else:\\n                    # optmized from `result -= has_repeated(prefix*10+j)`\\n                    result -= 1\\n            prefix = prefix*10 + digits[i]\\n        return result + has_repeated(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256995,
                "title": "screencast-of-leetcode-weekly-contest-128",
                "content": "https://www.youtube.com/watch?v=yXKBREQbBOg\\n\\nenjoy :)",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=yXKBREQbBOg\\n\\nenjoy :)",
                "codeTag": "Unknown"
            },
            {
                "id": 540044,
                "title": "c-digit-dp-solution",
                "content": "\"\"\"\\n\\n    //dp[pos][tight][start][rep][mask];\\n    int dp[10][2][2][2][1<<10];\\n    vector<int>num;\\n    int solve(int pos,int tight,int start,int rep,int mask)\\n    {\\n        if(pos == num.size())\\n        {\\n            return rep;\\n        }\\n        int &ans= dp[pos][tight][start][rep][mask];\\n        if(ans!=-1)return ans;\\n        \\n        int k = num[pos];\\n        if(tight)k=9;\\n        int res=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            int ns = start||i>0;//number started yet or not\\n            int nt = tight||i<k;//tight for next number\\n            if(ns){\\n                res+=solve(pos+1,nt,ns,rep||(mask&(1<<i)),mask|1<<i);\\n            }\\n            else{\\n                res+=solve(pos+1,nt,0,rep,mask);\\n            }\\n        \\n        }\\n        ans= res;\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            num.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(num.begin(),num.end());\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0,0,0);\\n    }\\n}\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n    //dp[pos][tight][start][rep][mask];\\n    int dp[10][2][2][2][1<<10];\\n    vector<int>num;\\n    int solve(int pos,int tight,int start,int rep,int mask)\\n    {\\n        if(pos == num.size())\\n        {\\n            return rep;\\n        }\\n        int &ans= dp[pos][tight][start][rep][mask];\\n        if(ans!=-1)return ans;\\n        \\n        int k = num[pos];\\n        if(tight)k=9;\\n        int res=0;\\n        for(int i=0;i<=k;i++)\\n        {\\n            int ns = start||i>0;//number started yet or not\\n            int nt = tight||i<k;//tight for next number\\n            if(ns){\\n                res+=solve(pos+1,nt,ns,rep||(mask&(1<<i)),mask|1<<i);\\n            }\\n            else{\\n                res+=solve(pos+1,nt,0,rep,mask);\\n            }\\n        \\n        }\\n        ans= res;\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            num.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(num.begin(),num.end());\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,0,0,0);\\n    }\\n}\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1228724,
                "title": "java-clean-solution-with-detailed-explanation",
                "content": "The key to solve this problem is cleverly enumerate all numbers < n without repeated digits. One of the ways is as follow: \\n\\n**Step 1 : count numbers with length smaller than n:**\\n```\\n// return count of numbers with d digits and no repeated digits\\nprivate int totalNoRepeat(int d) {\\n\\tint res = 9;                         // 0-th digit has 9 choices (1, ..., 9)\\n\\t\\n\\t/* 1-st digit has 9 choices         <==>  (0, ..., 9) except 0-th digit\\n\\t   2-st digit has 8 choices         <==>  (0, ..., 9) except 0-th & 1-st digit\\n\\t                              ...\\n\\t   i-th digit has (10- i) choices   <==>  (0, ..., 9) except 0-th & ...&  (i-1)-th digit      */\\n\\t\\n\\tfor (int i = 1; i < d; i++) {\\n\\t\\tres *= (10 - i);                 \\n\\t} \\n\\treturn res;\\n}\\n```\\n**Step 2 : count numbers with length equals to n:**\\n```\\nCase 1 :  n = 3 4 6 5     \\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n    pivot index i = 1 should < 4  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 3 X X    ==>  1 * 3 * 8 * 7 \\n\\tpivot index i = 2 should < 6  and not take values of previous indices       <==> {0, 1, 2, 5} \\n\\t\\t\\t\\t\\t3 4 0 X - 3 4 5 X    ==>  1 * 1 * 4 * 7\\n    pivot index i = 3 should < 5  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 4 6 0 - 3 4 6 5    ==>  1 * 1 * 1 * 3\\n\\nCase 2 :  n = 3 3 5 3\\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n\\tpivot index i = 1 should < 3  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 2 X X    ==>  1 * 3 * 8 * 7\\n\\tpivot index i = 2  and after should not be consider\\n\\t\\t\\t\\t\\t3 3 X X              ==>  0  the number will contain repeated digits\\n```\\nFrom these two examples, we can see the pattern of choosing digits: \\n```\\n// i := pivot index       \\n// d := i-th digit in the original number n\\n\\ni = 0     <==>  choose from {1, 2, ..., d-1};  After the pivot index i = 0: \\n\\t// 1-st digit has 9 choices         <==>  (0, ..., 9) except  {0-th digit}\\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t//                 ...\\n\\ni = 1     <==>  choose from {0, 1, ... , d-1} - {0-th digit};  After the pivot index i = 1: \\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t// 3-rd digit has 7 choices         <==>  (0, ..., 9) except  {0-th, 1-st, 2-nd digit}\\n\\t//                 ...\\n\\nThus for j-th digit after the pivot index i,  \\n\\t// j-th digit has (10- j) choices   <==>  (0, ..., 9) except 0-th & ...&  (j-1)-th digit      \\n```\\n\\n**Final solution:** \\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```\\n\\nThe main function can also be written as following. Here we consider the count of numbers strictly less than (n+1):\\n\\n```\\npublic int numDupDigitsAtMostN(int n) {\\n\\tString str = String.valueOf(n+1);\\n\\tint len = str.length();\\n\\t\\n\\tint unique = 0;\\n\\tfor (int i = 1; i < len; i++) {\\n\\t\\tunique += totalNoRepeat(i);\\n\\t}\\n\\n\\tSet<Integer> set = new HashSet<>();\\n\\tint i = 0;\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint d = str.charAt(i) - \\'0\\';\\n\\n\\t\\tint temp = pivotChoice(set, d, i == 0);\\n\\t\\tfor (int j = i+1; j < len; j++) {\\n\\t\\t\\ttemp *= (10 - j);\\n\\t\\t}\\n\\n\\t\\tunique += temp;\\n\\t\\tif (!set.add(d)) break;      \\n\\t}\\n\\treturn n - unique;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// return count of numbers with d digits and no repeated digits\\nprivate int totalNoRepeat(int d) {\\n\\tint res = 9;                         // 0-th digit has 9 choices (1, ..., 9)\\n\\t\\n\\t/* 1-st digit has 9 choices         <==>  (0, ..., 9) except 0-th digit\\n\\t   2-st digit has 8 choices         <==>  (0, ..., 9) except 0-th & 1-st digit\\n\\t                              ...\\n\\t   i-th digit has (10- i) choices   <==>  (0, ..., 9) except 0-th & ...&  (i-1)-th digit      */\\n\\t\\n\\tfor (int i = 1; i < d; i++) {\\n\\t\\tres *= (10 - i);                 \\n\\t} \\n\\treturn res;\\n}\\n```\n```\\nCase 1 :  n = 3 4 6 5     \\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n    pivot index i = 1 should < 4  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 3 X X    ==>  1 * 3 * 8 * 7 \\n\\tpivot index i = 2 should < 6  and not take values of previous indices       <==> {0, 1, 2, 5} \\n\\t\\t\\t\\t\\t3 4 0 X - 3 4 5 X    ==>  1 * 1 * 4 * 7\\n    pivot index i = 3 should < 5  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 4 6 0 - 3 4 6 5    ==>  1 * 1 * 1 * 3\\n\\nCase 2 :  n = 3 3 5 3\\n\\tpivot index i = 0 should < 3                                                <==> {1, 2} \\n\\t\\t\\t\\t\\t1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n\\tpivot index i = 1 should < 3  and not take values of previous indices       <==> {0, 1, 2} \\n\\t\\t\\t\\t\\t3 0 X X - 3 2 X X    ==>  1 * 3 * 8 * 7\\n\\tpivot index i = 2  and after should not be consider\\n\\t\\t\\t\\t\\t3 3 X X              ==>  0  the number will contain repeated digits\\n```\n```\\n// i := pivot index       \\n// d := i-th digit in the original number n\\n\\ni = 0     <==>  choose from {1, 2, ..., d-1};  After the pivot index i = 0: \\n\\t// 1-st digit has 9 choices         <==>  (0, ..., 9) except  {0-th digit}\\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t//                 ...\\n\\ni = 1     <==>  choose from {0, 1, ... , d-1} - {0-th digit};  After the pivot index i = 1: \\n\\t// 2-nd digit has 8 choices         <==>  (0, ..., 9) except  {0-th, 1-st digit}\\n\\t// 3-rd digit has 7 choices         <==>  (0, ..., 9) except  {0-th, 1-st, 2-nd digit}\\n\\t//                 ...\\n\\nThus for j-th digit after the pivot index i,  \\n\\t// j-th digit has (10- j) choices   <==>  (0, ..., 9) except 0-th & ...&  (j-1)-th digit      \\n```\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```\n```\\npublic int numDupDigitsAtMostN(int n) {\\n\\tString str = String.valueOf(n+1);\\n\\tint len = str.length();\\n\\t\\n\\tint unique = 0;\\n\\tfor (int i = 1; i < len; i++) {\\n\\t\\tunique += totalNoRepeat(i);\\n\\t}\\n\\n\\tSet<Integer> set = new HashSet<>();\\n\\tint i = 0;\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tint d = str.charAt(i) - \\'0\\';\\n\\n\\t\\tint temp = pivotChoice(set, d, i == 0);\\n\\t\\tfor (int j = i+1; j < len; j++) {\\n\\t\\t\\ttemp *= (10 - j);\\n\\t\\t}\\n\\n\\t\\tunique += temp;\\n\\t\\tif (!set.add(d)) break;      \\n\\t}\\n\\treturn n - unique;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263000,
                "title": "backtracking-with-c-in-a-few-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniqueDigits = 0;\\n    int numDupDigitsAtMostN(int N) {\\n        backtrack(0,0, N);\\n        return N - uniqueDigits + 1; // +1 as 0 is counted\\n    }\\n    \\n    void backtrack(long cur, int bitmask, int& N){\\n        if(cur > N) return;\\n        else uniqueDigits++;\\n        \\n        for(int digit=0; digit<10; digit++){\\n            if(bitmask == 0 && digit == 0) continue;\\n            if((bitmask & (1<<digit)) > 0) continue; // has repeat digits\\n            backtrack(cur*10 + digit, bitmask | (1<<digit), N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniqueDigits = 0;\\n    int numDupDigitsAtMostN(int N) {\\n        backtrack(0,0, N);\\n        return N - uniqueDigits + 1; // +1 as 0 is counted\\n    }\\n    \\n    void backtrack(long cur, int bitmask, int& N){\\n        if(cur > N) return;\\n        else uniqueDigits++;\\n        \\n        for(int digit=0; digit<10; digit++){\\n            if(bitmask == 0 && digit == 0) continue;\\n            if((bitmask & (1<<digit)) > 0) continue; // has repeat digits\\n            backtrack(cur*10 + digit, bitmask | (1<<digit), N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139778,
                "title": "c-digit-dp-with-bitmask-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n\\n\\tint dp[11][2][2][(1 << 10)];\\n\\n\\n\\tint solve(int pos, bool bound, bool hasRepeated, int mask, string &s) {\\n\\n\\t\\tif (pos == s.length()) {\\n\\t\\t\\treturn hasRepeated ? 1 : 0;\\n\\t\\t}\\n\\n\\t\\tif (dp[pos][bound][hasRepeated][mask] != -1) return dp[pos][bound][hasRepeated][mask];\\n\\n\\t\\tint maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n\\n\\t\\tfor (int digit = 0; digit <= maxDigit; digit++) {\\n\\n\\t\\t\\t/* if this is a leading zero, then hasRepeated for the the current guy (position) will obviously be false  */\\n\\t\\t\\tif (digit == 0 && mask == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), false, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this particular has already come earlier in this digit, and it is not a leading zero, then clearly, there is a repitition\\n\\t\\t\\t\\tand we have to pass true in hasRepeated\\n\\t\\t\\t*/\\n\\t\\t\\telse if ((mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), true, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this guy is coming for the first time, then hasRepeated will be whatever was for the previous guy\\n\\t\\t\\t\\tand don\\'t forget to switch on the bit corresponding to this digit in the mask\\n\\t\\t\\t*/\\n\\t\\t\\telse ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasRepeated, (mask | (1 << digit)), s);\\n\\n\\t\\t}\\n\\n\\t\\treturn dp[pos][bound][hasRepeated][mask] = ans;\\n\\n\\t}\\n\\n\\tint numDupDigitsAtMostN(int n) {\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tstring R = to_string(n);\\n\\t\\t// return solve(0, true, false, false, 0, R);\\n\\t\\treturn solve(0, true, false, 0, s);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\tint dp[11][2][2][(1 << 10)];\\n\\n\\n\\tint solve(int pos, bool bound, bool hasRepeated, int mask, string &s) {\\n\\n\\t\\tif (pos == s.length()) {\\n\\t\\t\\treturn hasRepeated ? 1 : 0;\\n\\t\\t}\\n\\n\\t\\tif (dp[pos][bound][hasRepeated][mask] != -1) return dp[pos][bound][hasRepeated][mask];\\n\\n\\t\\tint maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n\\n\\t\\tfor (int digit = 0; digit <= maxDigit; digit++) {\\n\\n\\t\\t\\t/* if this is a leading zero, then hasRepeated for the the current guy (position) will obviously be false  */\\n\\t\\t\\tif (digit == 0 && mask == 0) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), false, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this particular has already come earlier in this digit, and it is not a leading zero, then clearly, there is a repitition\\n\\t\\t\\t\\tand we have to pass true in hasRepeated\\n\\t\\t\\t*/\\n\\t\\t\\telse if ((mask & (1 << digit))) ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), true, mask, s);\\n\\n\\t\\t\\t/*\\n\\t\\t\\t\\tif this guy is coming for the first time, then hasRepeated will be whatever was for the previous guy\\n\\t\\t\\t\\tand don\\'t forget to switch on the bit corresponding to this digit in the mask\\n\\t\\t\\t*/\\n\\t\\t\\telse ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasRepeated, (mask | (1 << digit)), s);\\n\\n\\t\\t}\\n\\n\\t\\treturn dp[pos][bound][hasRepeated][mask] = ans;\\n\\n\\t}\\n\\n\\tint numDupDigitsAtMostN(int n) {\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\tstring R = to_string(n);\\n\\t\\t// return solve(0, true, false, false, 0, R);\\n\\t\\treturn solve(0, true, false, 0, s);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257241,
                "title": "c-with-alternative-explanation",
                "content": "Really enjoyed working through this problem and pushing myself to better understand permutations because of it, and figured I\\'d post my explanation of this problem here. The basic idea behind this problem is to instead determine how many **invalid** numbers exist from **1-N**, rather than trying to find the valid numbers.\\n\\nTo do this, we can make heavy use of the permutations formula (see [here](https://www.mathplanet.com/education/algebra-2/discrete-mathematics-and-probability/permutations-and-combinations) for a great explination on it) since it gives us the number permutations of unique numbers. We can start by figure out how many digits are in our number, and varying all of the digits in L-1 (L being the number of digits).\\n\\nFor example, with the number 350, we have 3 digits, meaning we can start by finding all **invalid** numbers from 0 to 99 (e.g. the first two digits). To start, let\\'s assuming we only have 1 digit available. In this case, we can\\'t vary any other digits in the number since there are none, and because there is only 1 digit they are all invalid. Thus, since there are 9 total numbers with 1 digit, we have 9 invalid permutations for this digit. Similarly, for 2 digits, we have 1 digit we can vary (e.g. 1x has x that can be varied, 2y has y that can be varied, so on and so forth). Plugging that into our our formula, we have perm(9, 1) which results in 9. Because there are 9 possible digits for the first digit, we can multiply the result by 9 (perm(9, 1) * 9) which gives us 81 invalid digits. Adding that onto our first result of 9, and we get 90 invalid digits for a number range of 1-99 (meaning we have 9 valid digits in that range).\\n\\nAt this point, for the number 350, we know that thare are at least 90 invalid digits from 1-100 as a result (since 100 is valid). Now however we need to count the number of invalid digits from 100-350. This can be done by varying each of the digits in 351 (e.g. N+1), and finding the valid permutations of that as a result. For example:\\n```\\n3XX -> perm(9-0, 3-0-1) -> perm(9, 2)\\nX5X -> perm(9-1, 3-1-1) -> perm(8, 1)\\nXX1 -> perm(9-2, 3-2-1) -> perm(7, 0)\\n```\\nWe then add this number of invalid permutations to our count based on the number we have. However, if we\\'ve previously seen a number in that range, we ignore it. For example, when we get to the 5 in 351, we will only add perm(8, 1)\\'s result 4 times, since the third time has already been accounted for when we went over the 3 in 351. Once we\\'ve done all of this, we can simply subtract our number of invalid numbers from our original number N to get our result.\\n\\nHere is what this process looks like in action:\\n```\\n350 -> 351\\ninvalid digits -> 0\\n\\n1 digit -> X -> perm(9, 0) * 9 -> 9 invalid digits\\n2 digits -> YX -> perm(9, 1) * 9 -> 81 invalid digits\\ninvalid digits -> 90\\n\\n0XX -> invalid so don\\'t count the invalid digits.\\n1XX -> perm(9, 2) -> 72 invalid digits\\n2XX -> perm(9, 2) -> 72 invalid digits\\n3XX -> stop counting invalid numbers for the first digit.\\nX0X -> perm(8, 1) -> 8 invalid digits\\nX1X -> perm(8, 1) -> 8 invalid digits\\nX2X -> perm(8, 1) -> 8 invalid digits\\nX3X -> perm(8, 1) -> 8 invalid digits -> but because we\\'ve already looked at the digit 3 previously we can skip this.\\nX4X -> perm(8, 1) -> 8 invalid digits\\nX5X -> stop counting invalid numbers for the second digit.\\nXX0 -> perm(7, 0) -> 1 invalid digit\\nXX1 -> stop counting invalid numbers for the third and final digit.\\ninvalid digits -> 267\\n\\nresult -> 350 - 267 = 83\\n```\\nAnd the full code looks like this:\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        int invalid = 0;\\n        \\n        // Begin by calculating all of the invalid numbers up to 10^(L-1), where L is the length of our number (e.g. For 350, we would find all invalid numbers between 1 and 99)\\n        int c = floor(log10(N+1))+1;\\n        for (int i = 0;i < c-1;i++) {\\n            invalid += 9 * perm(9, i);\\n        }\\n\\n        // For each digit, calculate the possible invalid permutations that are available up until that digit.\\n        int digits = 0;\\n        for (int i = 0;i < c;i++) {\\n            // Get the left most digit.\\n            int digit = ((N+1) / (int)pow(10, c-i-1)) % 10;\\n            // Count up to the digit. Note that if it\\'s the first digit, we start at 1 to avoid finding permutations when the first digit is a 1 since there are none.\\n            for (int j = (i > 0 ? 0 : 1);j < digit;j++) {\\n                // If we\\'ve had the same digit to the left of it previously, then we don\\'t need to count it again.\\n                // E.g. If our number is 350, when get to 330-339 we\\'ve already considered all possible invalid permutations for that number range and can skip it.\\n                if (((digits >> j) & 1) == 0) {\\n                    invalid += perm(9 - i, c - i - 1);\\n                }\\n            }\\n            // If we end up finding a digit we\\'ve already searched, we can finish here.\\n            if ((digits >> digit) & 1)\\n                break;\\n            digits |= 1 << digit;\\n        }\\n\\n        return N - invalid;\\n    }\\n    \\n    int perm(int m, int n) {\\n        int out = 1;\\n        while (m > 1 && n > 0) {\\n            out *= m;\\n            m--;\\n            n--;\\n        }\\n        return out;\\n    }\\n};\\n```\\nSome trickery I used: **log10(N+1) + 1** counts the number of digits we have for us so we don\\'t have to do another loop over them. We can then also abuse some other mathematics to quickly iterate over this without any additional memory, resulting in a **O(c) memory usage, where c is a constant value (e.g. O(1))**. The runtime of this is going to be **O(L\\xB2) where L is the number of digits** from what I can tell, because our second for loop will iterate over every digital (with a max of 9 being possible), and for each digit will iterate over the range of numbers from 0 to D (D being the digit we are on) which also has a mximum possible value of 9. **My math on the runtime may be off, so please correct me if that\\'s the case, as I would like to know the correct runtime.**\\n\\nAs far as further optimizations on the runtime, I\\'m not sure how possible this is since we ultimately need to make sure we don\\'t double count any of the previously checked digits. Feedback on this explination would be greatly appreciated as well!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n3XX -> perm(9-0, 3-0-1) -> perm(9, 2)\\nX5X -> perm(9-1, 3-1-1) -> perm(8, 1)\\nXX1 -> perm(9-2, 3-2-1) -> perm(7, 0)\\n```\n```\\n350 -> 351\\ninvalid digits -> 0\\n\\n1 digit -> X -> perm(9, 0) * 9 -> 9 invalid digits\\n2 digits -> YX -> perm(9, 1) * 9 -> 81 invalid digits\\ninvalid digits -> 90\\n\\n0XX -> invalid so don\\'t count the invalid digits.\\n1XX -> perm(9, 2) -> 72 invalid digits\\n2XX -> perm(9, 2) -> 72 invalid digits\\n3XX -> stop counting invalid numbers for the first digit.\\nX0X -> perm(8, 1) -> 8 invalid digits\\nX1X -> perm(8, 1) -> 8 invalid digits\\nX2X -> perm(8, 1) -> 8 invalid digits\\nX3X -> perm(8, 1) -> 8 invalid digits -> but because we\\'ve already looked at the digit 3 previously we can skip this.\\nX4X -> perm(8, 1) -> 8 invalid digits\\nX5X -> stop counting invalid numbers for the second digit.\\nXX0 -> perm(7, 0) -> 1 invalid digit\\nXX1 -> stop counting invalid numbers for the third and final digit.\\ninvalid digits -> 267\\n\\nresult -> 350 - 267 = 83\\n```\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        int invalid = 0;\\n        \\n        // Begin by calculating all of the invalid numbers up to 10^(L-1), where L is the length of our number (e.g. For 350, we would find all invalid numbers between 1 and 99)\\n        int c = floor(log10(N+1))+1;\\n        for (int i = 0;i < c-1;i++) {\\n            invalid += 9 * perm(9, i);\\n        }\\n\\n        // For each digit, calculate the possible invalid permutations that are available up until that digit.\\n        int digits = 0;\\n        for (int i = 0;i < c;i++) {\\n            // Get the left most digit.\\n            int digit = ((N+1) / (int)pow(10, c-i-1)) % 10;\\n            // Count up to the digit. Note that if it\\'s the first digit, we start at 1 to avoid finding permutations when the first digit is a 1 since there are none.\\n            for (int j = (i > 0 ? 0 : 1);j < digit;j++) {\\n                // If we\\'ve had the same digit to the left of it previously, then we don\\'t need to count it again.\\n                // E.g. If our number is 350, when get to 330-339 we\\'ve already considered all possible invalid permutations for that number range and can skip it.\\n                if (((digits >> j) & 1) == 0) {\\n                    invalid += perm(9 - i, c - i - 1);\\n                }\\n            }\\n            // If we end up finding a digit we\\'ve already searched, we can finish here.\\n            if ((digits >> digit) & 1)\\n                break;\\n            digits |= 1 << digit;\\n        }\\n\\n        return N - invalid;\\n    }\\n    \\n    int perm(int m, int n) {\\n        int out = 1;\\n        while (m > 1 && n > 0) {\\n            out *= m;\\n            m--;\\n            n--;\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521900,
                "title": "c-digit-dp-with-bismasking-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[11][2][1024][2]; //dp[pos][strictly][s][repeated]\\n    //s value can go upto 1024.\\n    //logic:- if we set all bit from (9...0) it gives approx. 1023 \\n    int solve(string& str, int pos, bool strictly, int s, bool repeated){\\n        if(pos==str.size()){\\n            if(repeated) return 1;\\n            else return 0;\\n        }\\n        if(dp[pos][strictly][s][repeated]!=-1) return dp[pos][strictly][s][repeated];\\n        int cur=0, n=str[pos]-\\'0\\';\\n        if(strictly){\\n            for(int i=0;i<=n;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else if(i==n){\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,true,s,true);\\n                    else cur+=solve(str,pos+1,true,s^(1<<i),repeated);\\n                }else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }else{\\n            for(int i=0;i<=9;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }\\n        return dp[pos][strictly][s][repeated] = cur;\\n    }\\n    \\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(str,0,true,0,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[11][2][1024][2]; //dp[pos][strictly][s][repeated]\\n    //s value can go upto 1024.\\n    //logic:- if we set all bit from (9...0) it gives approx. 1023 \\n    int solve(string& str, int pos, bool strictly, int s, bool repeated){\\n        if(pos==str.size()){\\n            if(repeated) return 1;\\n            else return 0;\\n        }\\n        if(dp[pos][strictly][s][repeated]!=-1) return dp[pos][strictly][s][repeated];\\n        int cur=0, n=str[pos]-\\'0\\';\\n        if(strictly){\\n            for(int i=0;i<=n;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else if(i==n){\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,true,s,true);\\n                    else cur+=solve(str,pos+1,true,s^(1<<i),repeated);\\n                }else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }else{\\n            for(int i=0;i<=9;++i){\\n                if(i==0 and s==0) cur+=solve(str,pos+1,false,s,repeated); //leading zero\\n                else{\\n                    if(s&(1<<i)) cur+=solve(str,pos+1,false,s,true);\\n                    else cur+=solve(str,pos+1,false,s^(1<<i),repeated);\\n                }\\n            }\\n        }\\n        return dp[pos][strictly][s][repeated] = cur;\\n    }\\n    \\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(str,0,true,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257281,
                "title": "java-o-1-0ms-beats-all",
                "content": "This is to count the numbers with all distinct digits.\\nWe can separate into two parts... say for N = 6,543,210,\\n\\nwe\\'ll count the distinct one from 1 to 999,999, which would be \\n\\t1-9: 9\\n\\tplus 10-99: 9 * 9 \\n\\tplus 100-999: 9 * 9 * 8\\n\\tplus 1,000 - 9,999: 9 * 9 * 8 * 7\\n\\t...\\n\\t100,000 - 999,999: 9 * 9 * 8 * 7 * 6 * 5.\\n\\t\\nThe above part can be done in one for loop with at most 9 iterations : O (1)\\t\\n\\nThen we add the remaining distinct ones (from 1,000,000 to 6,543,210)\\n\\nFrom 1,000,000 to 5,999,999 : 5 * 9 * 8 * 7 * 6 * 5 * 4\\nthen 6,000,000 to 6,499,999: 5 * 9 * 8 * 7 * 6 * 5\\nthen 6,500,000 to 6,539,999 and so on... 4 * 9 * 8 * 7 * 6 ...\\n\\nThe above part takes at most 81 iterations which is also O(1)\\n\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        if (N<=10)\\n            return 0;\\n        int[] digits = new int[9];\\n        int cursor = 0;\\n        int v = N;\\n        while (v>0){\\n            digits[cursor++] = v%10;\\n            v= v/10;\\n        }\\n        //cursor is digit cnt\\n        return N - countDistinctUpToMsb1(cursor) - countDistinctFromMsb1(digits, cursor);\\n    }\\n    \\n    private int countDistinctUpToMsb1(int digitCnts){\\n        int total = 9;\\n        int last = 9;\\n        int remainingCnt = 9;\\n        for (int i=1;i<digitCnts-1;i++){\\n            last = last * remainingCnt;\\n            total += last;\\n            remainingCnt--;\\n        }\\n        return total;\\n    }\\n    \\n    private int countDistinctFromMsb1(int[] digits, int length){\\n        //eg 1000 - 2345\\n        boolean[] digitUsed = new boolean[10];\\n        int count = 0;\\n        for (int i=0;i<length;i++){\\n            int digit = digits[length-i-1];\\n            count += countDistinct(digitUsed, i, digit, i==0?false:true,length-i-1);\\n            if (digitUsed[digit])\\n                break;\\n            if (i==length-1)\\n                count++;\\n            digitUsed[digit] = true;\\n        }\\n        return count;\\n    }\\n    private int countDistinct(boolean[] digitUsed,int digitUsedCnt, int nextDigit, boolean nextFromZero, int tailingZeros){\\n        int cnt=0;\\n        for (int i=nextFromZero?0:1;i<nextDigit;i++){\\n            if (!digitUsed[i])\\n                cnt++;\\n        }\\n        digitUsedCnt++;\\n        for (int i=0;i<tailingZeros;i++){\\n            cnt *= (10 - digitUsedCnt++);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        if (N<=10)\\n            return 0;\\n        int[] digits = new int[9];\\n        int cursor = 0;\\n        int v = N;\\n        while (v>0){\\n            digits[cursor++] = v%10;\\n            v= v/10;\\n        }\\n        //cursor is digit cnt\\n        return N - countDistinctUpToMsb1(cursor) - countDistinctFromMsb1(digits, cursor);\\n    }\\n    \\n    private int countDistinctUpToMsb1(int digitCnts){\\n        int total = 9;\\n        int last = 9;\\n        int remainingCnt = 9;\\n        for (int i=1;i<digitCnts-1;i++){\\n            last = last * remainingCnt;\\n            total += last;\\n            remainingCnt--;\\n        }\\n        return total;\\n    }\\n    \\n    private int countDistinctFromMsb1(int[] digits, int length){\\n        //eg 1000 - 2345\\n        boolean[] digitUsed = new boolean[10];\\n        int count = 0;\\n        for (int i=0;i<length;i++){\\n            int digit = digits[length-i-1];\\n            count += countDistinct(digitUsed, i, digit, i==0?false:true,length-i-1);\\n            if (digitUsed[digit])\\n                break;\\n            if (i==length-1)\\n                count++;\\n            digitUsed[digit] = true;\\n        }\\n        return count;\\n    }\\n    private int countDistinct(boolean[] digitUsed,int digitUsedCnt, int nextDigit, boolean nextFromZero, int tailingZeros){\\n        int cnt=0;\\n        for (int i=nextFromZero?0:1;i<nextDigit;i++){\\n            if (!digitUsed[i])\\n                cnt++;\\n        }\\n        digitUsedCnt++;\\n        for (int i=0;i<tailingZeros;i++){\\n            cnt *= (10 - digitUsedCnt++);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205659,
                "title": "c-digit-dp-bit-masking",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\nclass Solution\\n{\\n    int dp[1<<10][10][2][2];\\n    int helper(string &s,int i,int mask,int lz,int bound)\\n    {\\n        if(i==s.length())return 1;\\n        \\n        if(dp[mask][i][lz][bound]!=-1)\\n            return dp[mask][i][lz][bound];\\n        \\n        int maxx=bound?s[i]-\\'0\\':9;\\n        \\n        int tot=0;\\n        \\n        for(int j=0;j<=maxx;j++)\\n        {\\n            if((mask&(1<<j))&&lz==0)continue;\\n            mask|=(1<<j);\\n            tot+=helper(s,i+1,mask,lz&(j==0),bound&(j==maxx));\\n            mask^=(1<<j);\\n        }\\n        \\n        return dp[mask][i][lz][bound]=tot;\\n    }\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string s=to_string(n);\\n            memset(dp,-1,sizeof(dp));\\n            int mask=0;\\n            int res=(n+1)-helper(s,0,mask,1,1);\\n            return res;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution\\n{\\n    int dp[1<<10][10][2][2];\\n    int helper(string &s,int i,int mask,int lz,int bound)\\n    {\\n        if(i==s.length())return 1;\\n        \\n        if(dp[mask][i][lz][bound]!=-1)\\n            return dp[mask][i][lz][bound];\\n        \\n        int maxx=bound?s[i]-\\'0\\':9;\\n        \\n        int tot=0;\\n        \\n        for(int j=0;j<=maxx;j++)\\n        {\\n            if((mask&(1<<j))&&lz==0)continue;\\n            mask|=(1<<j);\\n            tot+=helper(s,i+1,mask,lz&(j==0),bound&(j==maxx));\\n            mask^=(1<<j);\\n        }\\n        \\n        return dp[mask][i][lz][bound]=tot;\\n    }\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string s=to_string(n);\\n            memset(dp,-1,sizeof(dp));\\n            int mask=0;\\n            int res=(n+1)-helper(s,0,mask,1,1);\\n            return res;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259667,
                "title": "c-study-code-from-ranking-no-1-in-weekly-contest-128",
                "content": "March 21, 2019\\nIt is one of weekly contest 128 algorithms. What I like to do is to learn ranking No. 1\\'s code, and then I add some comment to explain the idea to make it easy to follow. The player finished the algorithm using 7 minutes 5 seconds. \\n\\n![image](https://assets.leetcode.com/users/jianminchen/image_1553206027.png)\\n\\n\\nHere are a few tips:\\n1. using one binary number to store all unique digits in the number; mapping is described in the comment\\n2. using & operator to avoid any duplicated digit\\n3. using or to include current digit into the binary number\\n\\n**More detail**\\nEvery number from 0 to 9 can be represented using one bit in a binary number. So all digits in any  integer number can be recorded using one binary number including 10 bits at most. \\n\\n0 is expressed in 0, in binary format, 1 << 0\\n1 is expressed in 10, in binary format, 1 << 1\\n2 is expressed in 100\\n3 is expressed in 1000\\n4 is expressed in 10000\\n5 is expressed in 100000\\n6 is expressed in 1000000\\n7 is expressed in 10000000\\n8 is expressed in 100000000\\n9 is expressed in 1000000000, in binary format, 1 << 9\\n\\n**How to determine current digit is not duplicated**\\n\\nUsing one binary number to express all unique digits in the number, and then using **and &** operator to check uniqueness, and **or | operator** to include current digits. \\n\\nLet us work on one example in the following. \\nChoose a number with unique digits, for example, 123 or 321 or 213. All digits in the number can be expressed using one binary number 1110, so next digit should avoid duplication of those three digits. \\n\\nIf current digit is 4, the exiting digits include {1, 2, 3}, then 1110 & (1 << 4) = 1110 & 10000 = 0, \\nsince there is no duplication of digits. However, any digit from {1, 2, 3}, its binary format number & 1110 > 0.\\n\\nIt is the excellent practice to warm up bit manipulation and learn how to write a solution in less than 10 minutes. Othewise, it is better to use standard depth first search, and use an array instead of a binary number to mark the digit used. I also posted the solution on that: https://leetcode.com/problems/numbers-with-repeated-digits/discuss/259737/C-standard-depth-first-search-with-back-tracking\\n\\nHere is my C# code based on code study. \\n\\t\\t\\t\\t\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_1\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = NumDupDigitsAtMostN(20);\\n        }\\n\\n        public static int n;\\n        public static int uniqueDigitis;\\n\\n        /// <summary>\\n        /// study code on weekly contest 128 rank No. 1 waakaaka\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {\\n            uniqueDigitis = 0;\\n            n = N;\\n            runDepthFirstSearchLeftToRight(0,0);\\n            return N + 1 - uniqueDigitis; \\n        }\\n\\n        /// <summary>\\n        /// code review March 21, 2019\\n        /// Here are a few tips:\\n        /// 1. using one binary number to store all unique digits in the number; mapping is described in the comment\\n        /// 2. using & operator to avoid any duplicated digit\\n        /// 3. using or to include current digit into the binary number\\n        /// </summary>\\n        /// <param name=\"value\"></param>\\n        /// <param name=\"binaryShift\"></param>\\n        private static void runDepthFirstSearchLeftToRight(long value, int binaryShift)\\n        {\\n            if (value <= n)\\n            {\\n                uniqueDigitis++;\\n            }\\n\\n            if (value * 10 > n)\\n            {\\n                return;\\n            }\\n\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                // no 0 for first digit\\n                if (binaryShift == 0 && digit == 0)\\n                {\\n                    continue;\\n                }\\n\\n                // every number from 0 to 9 is represented using binary number\\n                // 0 is expressed in 0\\n                // 1 is expressed in 10\\n                // 2 is expressed in 100\\n                // 3 is expressed in 1000\\n                // 4 is expressed in 10000\\n                // 5 is expressed in 100000\\n                // 6 is expressed in 1000000\\n                // 7 is expressed in 10000000\\n                // 8 is expressed in 100000000\\n                // 9 is expressed in 1000000000\\n                var currentDigitExpression = 1 << digit; \\n               \\n                // number with unique digits, for example, 123 or 321 or 213. \\n                // all digits in the number can be expressed using one binary number 1110\\n                // so next digit should avoid duplication of those three digits\\n                // if current digit is 4, the exiting digits include {1, 2, 3}, then 1110 & (1 << 4) = 1110 & 10000 = 0, \\n                // since there is no duplication of digits                \\n                // any digit from {1, 2, 3} & 1110 > 0 \\n                if ((binaryShift & currentDigitExpression) > 0)\\n                {\\n                    continue; \\n                }\\n\\n                // using | to include current digit\\n                var nextBinary = binaryShift | currentDigitExpression;\\n                runDepthFirstSearchLeftToRight(value * 10 + digit, nextBinary); \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_1\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = NumDupDigitsAtMostN(20);\\n        }\\n\\n        public static int n;\\n        public static int uniqueDigitis;\\n\\n        /// <summary>\\n        /// study code on weekly contest 128 rank No. 1 waakaaka\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {\\n            uniqueDigitis = 0;\\n            n = N;\\n            runDepthFirstSearchLeftToRight(0,0);\\n            return N + 1 - uniqueDigitis; \\n        }\\n\\n        /// <summary>\\n        /// code review March 21, 2019\\n        /// Here are a few tips:\\n        /// 1. using one binary number to store all unique digits in the number; mapping is described in the comment\\n        /// 2. using & operator to avoid any duplicated digit\\n        /// 3. using or to include current digit into the binary number\\n        /// </summary>\\n        /// <param name=\"value\"></param>\\n        /// <param name=\"binaryShift\"></param>\\n        private static void runDepthFirstSearchLeftToRight(long value, int binaryShift)\\n        {\\n            if (value <= n)\\n            {\\n                uniqueDigitis++;\\n            }\\n\\n            if (value * 10 > n)\\n            {\\n                return;\\n            }\\n\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                // no 0 for first digit\\n                if (binaryShift == 0 && digit == 0)\\n                {\\n                    continue;\\n                }\\n\\n                // every number from 0 to 9 is represented using binary number\\n                // 0 is expressed in 0\\n                // 1 is expressed in 10\\n                // 2 is expressed in 100\\n                // 3 is expressed in 1000\\n                // 4 is expressed in 10000\\n                // 5 is expressed in 100000\\n                // 6 is expressed in 1000000\\n                // 7 is expressed in 10000000\\n                // 8 is expressed in 100000000\\n                // 9 is expressed in 1000000000\\n                var currentDigitExpression = 1 << digit; \\n               \\n                // number with unique digits, for example, 123 or 321 or 213. \\n                // all digits in the number can be expressed using one binary number 1110\\n                // so next digit should avoid duplication of those three digits\\n                // if current digit is 4, the exiting digits include {1, 2, 3}, then 1110 & (1 << 4) = 1110 & 10000 = 0, \\n                // since there is no duplication of digits                \\n                // any digit from {1, 2, 3} & 1110 > 0 \\n                if ((binaryShift & currentDigitExpression) > 0)\\n                {\\n                    continue; \\n                }\\n\\n                // using | to include current digit\\n                var nextBinary = binaryShift | currentDigitExpression;\\n                runDepthFirstSearchLeftToRight(value * 10 + digit, nextBinary); \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027402,
                "title": "c-digit-dp-with-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int anotherdp[15][2];\\n    \\n    int total(string x,int n,bool tight,set<int> &s){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(anotherdp[n][tight]!=-1){\\n            return anotherdp[n][tight];\\n        }\\n        int ub = (tight==1) ? x[x.length()-n]-\\'0\\' : 9;\\n        int res=0;\\n        for(int i=0;i<=ub;i++){\\n            if(s.empty() && i==0) continue;\\n            else if(s.find(i)==s.end()){\\n                s.insert(i);\\n                res+=total(x,n-1,(tight & (i==ub)),s);\\n                s.erase(s.find(i));\\n            }\\n        }\\n        return (anotherdp[n][tight]=res);\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        if(N<=10){\\n            return 0;\\n        }\\n        int n = log10(N);\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[1] = 9;\\n        int x=9;\\n        int y=9;\\n        for(int i=2;i<=n;i++){\\n            x*=y;\\n            y--;\\n            dp[i] = x;\\n            dp[i]+=dp[i-1];\\n        }\\n        set<int> s;\\n        s.clear(); \\n        string xx = to_string(N);\\n        memset(anotherdp,-1,sizeof(anotherdp));\\n        int temp = total(xx,xx.length(),1,s);\\n        return N-(dp[n]+temp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int anotherdp[15][2];\\n    \\n    int total(string x,int n,bool tight,set<int> &s){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(anotherdp[n][tight]!=-1){\\n            return anotherdp[n][tight];\\n        }\\n        int ub = (tight==1) ? x[x.length()-n]-\\'0\\' : 9;\\n        int res=0;\\n        for(int i=0;i<=ub;i++){\\n            if(s.empty() && i==0) continue;\\n            else if(s.find(i)==s.end()){\\n                s.insert(i);\\n                res+=total(x,n-1,(tight & (i==ub)),s);\\n                s.erase(s.find(i));\\n            }\\n        }\\n        return (anotherdp[n][tight]=res);\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        if(N<=10){\\n            return 0;\\n        }\\n        int n = log10(N);\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        dp[1] = 9;\\n        int x=9;\\n        int y=9;\\n        for(int i=2;i<=n;i++){\\n            x*=y;\\n            y--;\\n            dp[i] = x;\\n            dp[i]+=dp[i-1];\\n        }\\n        set<int> s;\\n        s.clear(); \\n        string xx = to_string(N);\\n        memset(anotherdp,-1,sizeof(anotherdp));\\n        int temp = total(xx,xx.length(),1,s);\\n        return N-(dp[n]+temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937922,
                "title": "c-digit-dp-simplest-solution-clean-code",
                "content": "# Intuition & Approach\\nRather than finding numbers having repetitions, we can find: `Total numbers - Numbers with all digits unique`.\\nMaintain a bitmask to make sure that we don\\'t re-select a digit which has already been included.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[11][2][1025]; // 1025 -> (1 << 10)\\n    int dfs(int i, int mask, bool tight, string &digits) {\\n        if(i == digits.size()) {\\n            return mask == 0 ? 0 : 1;\\n        }\\n\\n        if(dp[i][tight][mask] != -1) return dp[i][tight][mask];\\n\\n        int limit = 9, res = 0;\\n        if(tight) limit = (digits[i] - \\'0\\');\\n\\n        for(int dig = 0; dig <= limit; dig++) {\\n            // mask = 0 -> No number has been formed yet &\\n            // dig = 0 -> We can\\'t select first digit as 0 \\n            if(mask == 0 && dig == 0) {\\n                res += dfs(i + 1, mask, (tight & (limit == dig)), digits);\\n                continue;\\n            }\\n            // Check if the current digit has already been included\\n            int repeated = mask & (1 << dig);\\n            // If it hasn\\'t, include it and furthur proceed\\n            if(repeated == 0) {\\n                res += dfs(i + 1, mask | (1 << dig), (tight & (limit == dig)), digits);\\n            }\\n        }\\n\\n        return dp[i][tight][mask] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        string x = to_string(n);\\n        return n - dfs(0, 0, true, x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1025]; // 1025 -> (1 << 10)\\n    int dfs(int i, int mask, bool tight, string &digits) {\\n        if(i == digits.size()) {\\n            return mask == 0 ? 0 : 1;\\n        }\\n\\n        if(dp[i][tight][mask] != -1) return dp[i][tight][mask];\\n\\n        int limit = 9, res = 0;\\n        if(tight) limit = (digits[i] - \\'0\\');\\n\\n        for(int dig = 0; dig <= limit; dig++) {\\n            // mask = 0 -> No number has been formed yet &\\n            // dig = 0 -> We can\\'t select first digit as 0 \\n            if(mask == 0 && dig == 0) {\\n                res += dfs(i + 1, mask, (tight & (limit == dig)), digits);\\n                continue;\\n            }\\n            // Check if the current digit has already been included\\n            int repeated = mask & (1 << dig);\\n            // If it hasn\\'t, include it and furthur proceed\\n            if(repeated == 0) {\\n                res += dfs(i + 1, mask | (1 << dig), (tight & (limit == dig)), digits);\\n            }\\n        }\\n\\n        return dp[i][tight][mask] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        string x = to_string(n);\\n        return n - dfs(0, 0, true, x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226388,
                "title": "digit-dp",
                "content": "I didn\\'t get any soln in discuss that contains digit dp in python so I did this In this soln, to see whether any digit repeated or not, i take a memo , i guess you have used it before if not then see following problem it just contain 1 for integer if it\\'s already taken otherwise 0 and put it in binary form . Ya it\\'s 5 order dp so don\\'t be confused i just used it for memoization. if you don\\'t know more about digit dp, I will highly recommend you to see kartik arora\\'s digit dp video on youtube.\\n[https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/submissions/](http://)\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        dp=[[[[[-1 for tight in range(2)] for i in range(2)] for i in range(2)] for i in range(2**10)] for i in range(10)]\\n        len1 = len(str(n))\\n        def fun(i,check,tight,memo,leading_zero):\\n            if i==len1:\\n                if check==1:\\n                    return 1\\n                return 0\\n            end = 9\\n            if dp[i][memo][check][leading_zero][tight]!=-1:\\n                return dp[i][memo][check][leading_zero][tight]\\n            if tight==1:\\n                end = int(str(n)[i])\\n            res = 0\\n            for j in range(end+1):\\n                if j==0 and leading_zero==1:\\n                    res+=fun(i+1,0,tight&(j==end),memo,1)\\n                    continue\\n                if check==1:\\n                    res+=fun(i+1,1,tight&(j==end),memo|(1<<j),0)\\n                    continue\\n                if memo&(1<<j):\\n                    res+=fun(i+1,1,tight&(j==end),memo,0)\\n                else:\\n                    res+=fun(i+1,0,tight&(j==end),memo|(1<<j),0)\\n            dp[i][memo][check][leading_zero][tight] = res\\n            return res\\n        return fun(0,0,1,0,1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "I didn\\'t get any soln in discuss that contains digit dp in python so I did this In this soln, to see whether any digit repeated or not, i take a memo , i guess you have used it before if not then see following problem it just contain 1 for integer if it\\'s already taken otherwise 0 and put it in binary form . Ya it\\'s 5 order dp so don\\'t be confused i just used it for memoization. if you don\\'t know more about digit dp, I will highly recommend you to see kartik arora\\'s digit dp video on youtube.\\n[https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/submissions/](http://)\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        dp=[[[[[-1 for tight in range(2)] for i in range(2)] for i in range(2)] for i in range(2**10)] for i in range(10)]\\n        len1 = len(str(n))\\n        def fun(i,check,tight,memo,leading_zero):\\n            if i==len1:\\n                if check==1:\\n                    return 1\\n                return 0\\n            end = 9\\n            if dp[i][memo][check][leading_zero][tight]!=-1:\\n                return dp[i][memo][check][leading_zero][tight]\\n            if tight==1:\\n                end = int(str(n)[i])\\n            res = 0\\n            for j in range(end+1):\\n                if j==0 and leading_zero==1:\\n                    res+=fun(i+1,0,tight&(j==end),memo,1)\\n                    continue\\n                if check==1:\\n                    res+=fun(i+1,1,tight&(j==end),memo|(1<<j),0)\\n                    continue\\n                if memo&(1<<j):\\n                    res+=fun(i+1,1,tight&(j==end),memo,0)\\n                else:\\n                    res+=fun(i+1,0,tight&(j==end),memo|(1<<j),0)\\n            dp[i][memo][check][leading_zero][tight] = res\\n            return res\\n        return fun(0,0,1,0,1)",
                "codeTag": "Java"
            },
            {
                "id": 592922,
                "title": "python-well-commented-solution-with-easy-to-follow-recursion",
                "content": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        def f(digits_of_N, i, digits_used, any_digit):\\n            if i == k:\\n                return 1\\n            \\n            key = (i, digits_used, any_digit)\\n            if key in memo:\\n                return memo[key]\\n            \\n            # For each digit position, we iterate through all possible choices\\n            cnt = 0\\n            # If it\\'s the leading digit, at position 0, we cannot pick 0 as a choice\\n            min_digit = 1 if i == 0 else 0\\n            # We can pick up to and including the digit at the i-th position of N so\\n            # the number stays <= N. However if we\\'ve picked some previous digit less\\n            # than that in N at the same position, then we can pick any digit we want.\\n            # Why? Because if the more significant digit has a smaller number, it doesn\\'t\\n            # matter what number we pick for less sigificant digit positions.\\n            max_digit = 9 if any_digit else digits_of_N[i]\\n            for d in range(min_digit, max_digit + 1):\\n                # Use a bitmask to record if we\\'ve already used a digit. Since we only want\\n                # integers with unique digits, once a digit is used, it cannot be picked again.\\n                if digits_used & (1 << d) != 0:\\n                    continue\\n                # If we picked some digit less than the i-th digit of N, then for the\\n                # digit positions after i we can pick whatever we want, as long as\\n                # the digit picked is unique, and it will be less than N. \\n                cnt += f(digits_of_N, i + 1, digits_used | (1 << d), any_digit or (d < digits_of_N[i]))\\n            \\n            memo[key] = cnt\\n            return cnt\\n        \\n        # Life is easier without having to deal with the single-digit case.\\n        # It\\'s only interesting when we have at least 2 digits.\\n        if N <= 9:\\n            return 0\\n        \\n        # Let k be the number of digits in N\\n        k = len(str(N))\\n        # We break the set of positive integers <= N with at least one duplicate digit into \\n        # two disjoint sets A and B, where:\\n        #   - A is the set of positive integers with k - 1 or less number of digits, with at least 1\\n\\t\\t#       duplicate digit\\n        #   - B is the set of positive integers <= N with exactly k number of digits, with at least 1\\n\\t\\t#      duplicate digit\\n        \\n        # Let\\'s first count the size A.\\n        # Given i in [1.. k - 1], the set of positive integers with i digits and at least 1 duplicate digit\\n\\t\\t# must be:\\n        #    The set of positive integers with i digits - positive integers with only unique digits.\\n        # Well positive integers with i digits is just 9 * 10^(i - 1) -- we have {1, 2 .. 9} as \\n        # possible choices for the leading digit and then {0..9} as possible choices for each of the \\n        # remaining digits. \\n        # And positive integers with i digits and only unique digits must be:\\n        #    9 * 9 * 8 * 7 ... up to i terms\\n        # We have {1..9} as possible choices for the leading digit and then 10 - 1 possible choices\\n        # for the second digit -- whatever leading digit we picked we cannot select that again.\\n        # And having made a choice for the second digit, we\\'d then only have 8 possible choices \\n        # for the 3rd digit and so on, until we have only 1 possible digit choice left.\\n        cnt = 0\\n        for i in range(1, k):\\n            all_possible_ints = 9 * 10**(i-1)\\n            ints_with_unique_digits = 9\\n            nb_choices = 9\\n            for j in range(1, i):\\n                ints_with_unique_digits *= nb_choices\\n                nb_choices -= 1\\n            cnt += all_possible_ints - ints_with_unique_digits\\n            \\n        # Let\\'s then count the size of B. Again it\\'s similar to A.\\n        # For positive integers with exactly k digits <= N. e.g. if N = 12483, then \\n        # we have 12483 - 9999 possible integers with 5 digits. (9999 or below are all\\n        # numbers with less than 5 digits)\\n        all_ints_with_k_digits = N - int(\\'9\\'*(k-1))\\n        # To count the number of positive integers <= N with exactly k unique digits,\\n        # we\\'ll need a bit of recursion. See comments in f()\\n        digits_of_N = [int(d) for d in str(N)]\\n        ints_with_unique_k_digits = f(digits_of_N, 0, 0, False)\\n        cnt += all_ints_with_k_digits - ints_with_unique_k_digits\\n        \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        def f(digits_of_N, i, digits_used, any_digit):\\n            if i == k:\\n                return 1\\n            \\n            key = (i, digits_used, any_digit)\\n            if key in memo:\\n                return memo[key]\\n            \\n            # For each digit position, we iterate through all possible choices\\n            cnt = 0\\n            # If it\\'s the leading digit, at position 0, we cannot pick 0 as a choice\\n            min_digit = 1 if i == 0 else 0\\n            # We can pick up to and including the digit at the i-th position of N so\\n            # the number stays <= N. However if we\\'ve picked some previous digit less\\n            # than that in N at the same position, then we can pick any digit we want.\\n            # Why? Because if the more significant digit has a smaller number, it doesn\\'t\\n            # matter what number we pick for less sigificant digit positions.\\n            max_digit = 9 if any_digit else digits_of_N[i]\\n            for d in range(min_digit, max_digit + 1):\\n                # Use a bitmask to record if we\\'ve already used a digit. Since we only want\\n                # integers with unique digits, once a digit is used, it cannot be picked again.\\n                if digits_used & (1 << d) != 0:\\n                    continue\\n                # If we picked some digit less than the i-th digit of N, then for the\\n                # digit positions after i we can pick whatever we want, as long as\\n                # the digit picked is unique, and it will be less than N. \\n                cnt += f(digits_of_N, i + 1, digits_used | (1 << d), any_digit or (d < digits_of_N[i]))\\n            \\n            memo[key] = cnt\\n            return cnt\\n        \\n        # Life is easier without having to deal with the single-digit case.\\n        # It\\'s only interesting when we have at least 2 digits.\\n        if N <= 9:\\n            return 0\\n        \\n        # Let k be the number of digits in N\\n        k = len(str(N))\\n        # We break the set of positive integers <= N with at least one duplicate digit into \\n        # two disjoint sets A and B, where:\\n        #   - A is the set of positive integers with k - 1 or less number of digits, with at least 1\\n\\t\\t#       duplicate digit\\n        #   - B is the set of positive integers <= N with exactly k number of digits, with at least 1\\n\\t\\t#      duplicate digit\\n        \\n        # Let\\'s first count the size A.\\n        # Given i in [1.. k - 1], the set of positive integers with i digits and at least 1 duplicate digit\\n\\t\\t# must be:\\n        #    The set of positive integers with i digits - positive integers with only unique digits.\\n        # Well positive integers with i digits is just 9 * 10^(i - 1) -- we have {1, 2 .. 9} as \\n        # possible choices for the leading digit and then {0..9} as possible choices for each of the \\n        # remaining digits. \\n        # And positive integers with i digits and only unique digits must be:\\n        #    9 * 9 * 8 * 7 ... up to i terms\\n        # We have {1..9} as possible choices for the leading digit and then 10 - 1 possible choices\\n        # for the second digit -- whatever leading digit we picked we cannot select that again.\\n        # And having made a choice for the second digit, we\\'d then only have 8 possible choices \\n        # for the 3rd digit and so on, until we have only 1 possible digit choice left.\\n        cnt = 0\\n        for i in range(1, k):\\n            all_possible_ints = 9 * 10**(i-1)\\n            ints_with_unique_digits = 9\\n            nb_choices = 9\\n            for j in range(1, i):\\n                ints_with_unique_digits *= nb_choices\\n                nb_choices -= 1\\n            cnt += all_possible_ints - ints_with_unique_digits\\n            \\n        # Let\\'s then count the size of B. Again it\\'s similar to A.\\n        # For positive integers with exactly k digits <= N. e.g. if N = 12483, then \\n        # we have 12483 - 9999 possible integers with 5 digits. (9999 or below are all\\n        # numbers with less than 5 digits)\\n        all_ints_with_k_digits = N - int(\\'9\\'*(k-1))\\n        # To count the number of positive integers <= N with exactly k unique digits,\\n        # we\\'ll need a bit of recursion. See comments in f()\\n        digits_of_N = [int(d) for d in str(N)]\\n        ints_with_unique_k_digits = f(digits_of_N, 0, 0, False)\\n        cnt += all_ints_with_k_digits - ints_with_unique_k_digits\\n        \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459348,
                "title": "correct-solution-but-exceeded-time-limit",
                "content": "This solution will give correct answer but will exceed time limit:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        countRepeat = 0\\n        for x in range(1, N+1):\\n            intList = [char for char in str(x)]\\n            if len(str(x)) != len(list(set(intList))):\\n                countRepeat += 1\\n        return countRepeat",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "This solution will give correct answer but will exceed time limit:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        countRepeat = 0\\n        for x in range(1, N+1):\\n            intList = [char for char in str(x)]\\n            if len(str(x)) != len(list(set(intList))):\\n                countRepeat += 1\\n        return countRepeat",
                "codeTag": "Java"
            },
            {
                "id": 3600079,
                "title": "c-solution-digit-dp-clean-and-concise-bitmask",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[10][2][1025][2]; //2^10 = 1024 for bitmask\\n\\n    int count(int idx,bool tight,int bitmask,bool isrepeated,string& num){\\n        if(idx==num.size()){\\n            return (isrepeated&&bitmask)?1:0;\\n        }\\n        if(dp[idx][tight][bitmask][isrepeated]!=-1) return dp[idx][tight][bitmask][isrepeated];\\n        int lo = 0;\\n        int hi = tight?(num[idx]-\\'0\\'):9;\\n        int cnt = 0;\\n        if(!bitmask){\\n            cnt += count(idx+1,false,bitmask,isrepeated,num);\\n        }\\n        for(int i = lo;i<=hi;i++){\\n            if(!bitmask && i==0) continue;\\n            int repeated = bitmask & (1<<i);\\n            if(repeated){\\n                cnt += count(idx+1,tight&&(i==hi),bitmask,true,num);\\n            }\\n            else{\\n                cnt += count(idx+1,tight&&(i==hi),bitmask|(1<<i),isrepeated,num);\\n            }\\n        }\\n        return dp[idx][tight][bitmask][isrepeated] = cnt;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string num = to_string(n);\\n        return count(0,true,0,false,num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10][2][1025][2]; //2^10 = 1024 for bitmask\\n\\n    int count(int idx,bool tight,int bitmask,bool isrepeated,string& num){\\n        if(idx==num.size()){\\n            return (isrepeated&&bitmask)?1:0;\\n        }\\n        if(dp[idx][tight][bitmask][isrepeated]!=-1) return dp[idx][tight][bitmask][isrepeated];\\n        int lo = 0;\\n        int hi = tight?(num[idx]-\\'0\\'):9;\\n        int cnt = 0;\\n        if(!bitmask){\\n            cnt += count(idx+1,false,bitmask,isrepeated,num);\\n        }\\n        for(int i = lo;i<=hi;i++){\\n            if(!bitmask && i==0) continue;\\n            int repeated = bitmask & (1<<i);\\n            if(repeated){\\n                cnt += count(idx+1,tight&&(i==hi),bitmask,true,num);\\n            }\\n            else{\\n                cnt += count(idx+1,tight&&(i==hi),bitmask|(1<<i),isrepeated,num);\\n            }\\n        }\\n        return dp[idx][tight][bitmask][isrepeated] = cnt;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string num = to_string(n);\\n        return count(0,true,0,false,num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218805,
                "title": "i-spent-4-hours-on-this-shit-i-hate-my-life",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts basically just math, Im gonna die \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlet n be a K digit integer\\nWe will count the total number of non-duplicated integers\\nWe split them up in 2 cases by counting <K digits and K digits\\n\\nFor < K digits\\nI did abit of trial and error for this but the general form that you would get would be for each k number of digits\\n$$9\\\\bullet\\\\sum^{K-3}_{i=0}\\\\Pi^9_{j=9-i}j + 9$$\\n\\nSo how i visualised it was for e.g. we wamt let K = 5 so we want to find all possible non-duplicated integers <10 000 i.e. [1,9 999]\\n\\nFrom 1000 to 9999 we have 10000 - 1000 = 9000 integers \\nwe fix the 1st digit so we have 1XXX then for the 2nd digit we have 9 remaining unique digits so on and so forth. Resulting in 9x8x7 integers\\nNow we permutate the first digit to be between 1 to 9\\nHence from 1000 - 9999 we have 9x9x8x7 non-duplicated integers\\n\\nSimilarly, from 100 - 999 we have 9x9x8\\nfrom 10 - 99 we have 9x9\\nfrom 1 - 9 we have 9\\n\\nNow if we take the sum we get \\n9x9x8x7 9x9x8 + 9x9 + 9\\n\\n\\nFor a fixed length of K digits\\nWe store each leading digit in seen\\nThen we build the integer up by iterating from 0 (if not first digit) and 1(if first digit) up to the leading digit. If any of the digit was seen before then we skip it. We then permutate the remaining digits left. If the leading digit was already seen we can stop as we know it will no longer give us any non-duplicated integers.\\n\\nE.g. if we let n = 13579\\nWe will calculate this in parts as well specifically from \\n1XXXX - 1XXXX\\n10XXX - 12XXX\\n130XX - 134XX\\n1350X - 1356X\\n1357X - 13578\\n(remember last number not inclusive, pretty sure you can tweak the code to include)\\n\\nAt the start we have 10 000, since the leading digit is the first digit and is 1 we skip it. We then store 1 inside seen. Now we have fixed the first digit.\\n\\nFor the second digit, we start building from 0 to 2 so we have 10XXX, 11XXX and 12XXX but since 11XXX is already a duplicate we will skip it. Giving us 2x8x7x6 non-duplicated integers. Now we fix the second digit to be 3\\n\\nFor the third digit we will consider 130XX, 131XX, 132XX, 133XX, 134XX, w can see that 131XX and 133XX already contains duplicates and hence we will skip them. Giving us 3x7x6. Then we fix the third digit to be 5\\n\\nSo on and so forth, resulting in a total of 2x8x7x6 + 3x7x6 + 4x6 + 5\\n\\nNow we take the sum \\n9x9x8x7 9x9x8 + 9x9 + 9 + \\n2x8x7x6 + 3x7x6 + 4x6 + 5 + 1 (to include n=13579) = 6102\\nWe return 13579 - 6102 = 7477 which is the ans\\n  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI believe it is $$O(log_{10}n)$$ as we are counting the number of digits\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI think it is $$O(log_{10}n)$$ as well? as we only store the number of digits in both seen and numList\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        temp = n\\n        numList = []\\n        while temp > 0:\\n            numList.insert(0, temp%10)\\n            temp //=10\\n        digits = len(numList)\\n        totalNum = 0\\n        res = 0\\n        # less than K digits\\n        for j in range(digits-1, 0, -1):\\n            res = 9\\n            for k in range(9, 9-j+1,-1):\\n                res *= k\\n            totalNum += res\\n        #K digits\\n        seen = {}\\n        for i in range(0,digits):\\n            leadingDigit = numList[i]\\n            remainingDigits = len(numList) - i - 1\\n            for j in range(1 if i==0 else 0, leadingDigit):\\n                if j in seen:\\n                    continue\\n                res = 1\\n                for k in range(9-i, 9-i-remainingDigits,-1):\\n                    res *= k\\n                totalNum += res\\n            if leadingDigit in seen:\\n                break\\n            seen[leadingDigit] = 1\\n        seen = {}\\n        for num in numList:\\n            if num in seen:\\n                return n-totalNum\\n            seen[num] = 1\\n        return n-totalNum - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        temp = n\\n        numList = []\\n        while temp > 0:\\n            numList.insert(0, temp%10)\\n            temp //=10\\n        digits = len(numList)\\n        totalNum = 0\\n        res = 0\\n        # less than K digits\\n        for j in range(digits-1, 0, -1):\\n            res = 9\\n            for k in range(9, 9-j+1,-1):\\n                res *= k\\n            totalNum += res\\n        #K digits\\n        seen = {}\\n        for i in range(0,digits):\\n            leadingDigit = numList[i]\\n            remainingDigits = len(numList) - i - 1\\n            for j in range(1 if i==0 else 0, leadingDigit):\\n                if j in seen:\\n                    continue\\n                res = 1\\n                for k in range(9-i, 9-i-remainingDigits,-1):\\n                    res *= k\\n                totalNum += res\\n            if leadingDigit in seen:\\n                break\\n            seen[leadingDigit] = 1\\n        seen = {}\\n        for num in numList:\\n            if num in seen:\\n                return n-totalNum\\n            seen[num] = 1\\n        return n-totalNum - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507269,
                "title": "c-standard-digit-dp",
                "content": "This is a standard digit DP problem.\\n\\nA few words on digit DP for those who are not so familiar with the concept. The basic idea here is to group the sequences into subsets or sub-problems, then apply regular top-down DP on each sub-problem. Here by \"sequences\" I just mean any integer within the range `[1,n]` , so there are `n` such sequences. They all have length (in terms of number of digits) equal to number of digits in `n`, b/c we will be including leading zeros.\\n\\nObviously in brute-force we can enumerate each sequence and check if it meets the condition, but this will explode in time complexity since `n` is very large. Instead we divide them into subsets. How? A very natural way is to group sequences sharing the same prefix into the same set. For instance, the two sequences `1123` and `1145` can be thought of as belonging to the same subset, since they both starts w/t the prefix `11`. Now the prefix can have different lengths, so we start with the left-most bit i.e. the most significant bit, we use a parameter `pos` to represent the current bit we are at, so `pos` equals to the length of the prefix that we have built so far. In the previous example, we can say the prefix `11` is at position `pos=2`.\\n\\nAn additional variable `tight`, which is boolean, is used to make it more convenient to expand the prefix; when `tight=1` it means the prefix so far exactly matchs the prefix part in `n`, therefore at `pos+1` the digit we can choose are limited to the corresponding digit in `n`. For instance if `n=12345` and we are currently at `pos=3` with `tight=1`, this would indicate the prefix we have built so far is `123`, for the next position, we cannot choose any digit larger than `4`, because if we choose say `1235` then it would have already be out-of-bounds. When `tight=0` we can choose any digit from 0 to 9. \\n\\nThese two variables `pos` and `tight` are standard for any digit DP solution, please refer to better tutorials e.g. [this one](https://codeforces.com/blog/entry/53960) for more detailed explanations. With `pos` and `tight` we are able to build the complete search tree from left to right in a very standard DFS framework e.g.:\\n\\n```\\nint dfs (int pos, int tight, ...) {\\n\\t// return leaf node\\n\\t// memoization\\n\\t\\n\\tint res = 0;\\n\\tint limit = tight==1 ? nums[pos] : 9;\\n\\tfor (int i = 0; i <= limit; ++i) {\\n\\t\\t// do sth.\\n\\t\\tres += dfs(pos+1, newTight, ...);\\n\\t}\\n\\t\\n\\treturn dp[pos][tight][...] = res;\\n}\\n```\\n\\nHere for each node at position = `pos`, we just enumerate all possible digits from 0~9 or from 0 ~ `limit` depending on the `tight` condition. The digit `i` is put into position `pos+1` to expand the prefix and it is hence a child node of the current node. To return the solution of the sub-problem associated with the current node, we just accumulate from the solutions over all of its child sub-trees. This is therefore very standard top-down DP approach.\\n\\nA node in the tree is therefore identifiable by its prefix sequence. But in this way each node is distinct, and there are way too many nodes for memoization to work properly. Therefore we need to apply a further grouping on the prefixes. We define a mapping function `f(p)->state` where `p` is a prefix and `state` is an integer value of limited range. For instance, for LC#233 counting the digit 1 in integers, we can let `state` = number of 1\\'s in the prefix.\\n\\nHere for this problem, notice that if we have two prefixes e.g. `22345***` and `23524***`, they are similar in the sense that they both contain two 2\\'s i.e. they both have repeated digits; moreover, they both have used the same digits `2,3,4,5`, although in different ordering. So these two prefixes (and all the descendant full sequences containing these prefixes) should be grouped into the same sub-problem.\\n\\nConcretely, we actually need to use a 2d state variable, `(rep, mask)`. Here `rep` is a boolean value indicating whether there has already been at least one repeated digit in the prefix built so far, and `mask` is a bit-mask indicating which digits have been used in the prefix. For the previous example the state for the two prefixes should be `rep=1` and `mask=0000111100` indicating the usage of digits `2,3,4,5`. Thefore, the mapping function from prefixes to states are many-to-one, each state now identifies a sub-problem containing many sequences which share similar prefixes. It should be noted that the mapping must be chosen in such a way as to ensure the sub-problems won\\'t overlap. Now we apply memoization on these sub-problems, since the number of these states will be limited, and these values will be shared and re-used throughout the DFS on the search tree.\\n\\nIn summary, the sub-problem (i.e. a specific subset of sequences grouped together) in digit DP is indexed by a set of variables `(pos, tight, state)`. The `dp[pos][tight][state]` value function therefore stores the solution to the corresponding sub-problem, i.e. the original problem but on the sub-set of sequences. When considering the state transitions, since `pos` and `tight` are used just for building the search tree, their transitions are always the same for different problems; in particular:\\n```\\nint new_pos = pos+1;\\nint new_tight = (tight == 1 && i == limit ) ? 1 : 0;\\n```\\nHere we always transition into the child nodes by `pos+1` and compute the correct `tight` variable. The problem-specific aspect lies with the `state` variable and its transitions. Here in this problem, using `(rep, mask)` as the state, the digit DP solution is as follows in C++:\\n\\n```\\nclass Solution {\\n    vector<int> nums;\\n    int s;\\n    // dp[pos][tight][rep][mask]\\n\\t// if rep=1 means the prefix sequence contains at least one repeated digit\\n    int dp[10][2][2][1024];\\npublic:\\n    int dfs(int pos, int tight, int rep, int mask) {\\n\\t\\t// at leaf node exclude the cases where mask==0 i.e. leading zeros\\n\\t\\t// if rep=1 means a sequence with at least one repeated digit has been found, so return 1;\\n        if (pos == s)\\n            return ( mask != 0 && rep ) ? 1 : 0;\\n        \\n\\t\\t// memoization\\n        if (dp[pos][tight][rep][mask] != -1)\\n            return dp[pos][tight][rep][mask];\\n        \\n        int limit = tight == 1 ? nums[pos] : 9;\\n        int res = 0;\\n        for (int i = 0; i <= limit; ++i) {\\n            int newTight = (tight == 1 && i == limit) ? 1 : 0;\\n\\t\\t\\t\\n\\t\\t\\t// if mask==0 means it\\'s all leading zeros, so when i=0 it\\'s still leading zero, not counted;\\n\\t\\t\\t// otherwise set the corresponding bit of i to 1 in newMask\\n            int newMask = (mask == 0 && i == 0) ? mask : mask | 1 << i;\\n\\t\\t\\t\\n\\t\\t\\t// exclude cases of leading zero here as well\\n\\t\\t\\t// for other cases, if rep==1 means there has already been repeated digits, so newRep = 1 also\\n\\t\\t\\t// otherwise, check if i has been set in `mask` by the bitwise AND operation; if so, newRep = 1;\\n            int newRep = (mask == 0 && i == 0) ? 0 : rep | bool(mask & 1 << i);\\n            \\n            res += dfs(pos+1, newTight, newRep, newMask);\\n        }\\n        \\n        return dp[pos][tight][rep][mask] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        while (n > 0) {\\n            nums.push_back(n % 10);\\n            n = n / 10;\\n        }\\n        s = nums.size();\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\t// the original full problem is represented by an empty prefix\\n\\t\\t// so pos=0\\n\\t\\t// tight=1 b/c the first digit we place in the prefix must be bounded by nums[0] i.e. the msb in n, so it\\'s tight condition is set.\\n\\t\\t// rep=0 and mask=0 b/c in empty prefix there is no repetion, no digit used\\n        return dfs(0, 1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dfs (int pos, int tight, ...) {\\n\\t// return leaf node\\n\\t// memoization\\n\\t\\n\\tint res = 0;\\n\\tint limit = tight==1 ? nums[pos] : 9;\\n\\tfor (int i = 0; i <= limit; ++i) {\\n\\t\\t// do sth.\\n\\t\\tres += dfs(pos+1, newTight, ...);\\n\\t}\\n\\t\\n\\treturn dp[pos][tight][...] = res;\\n}\\n```\n```\\nint new_pos = pos+1;\\nint new_tight = (tight == 1 && i == limit ) ? 1 : 0;\\n```\n```\\nclass Solution {\\n    vector<int> nums;\\n    int s;\\n    // dp[pos][tight][rep][mask]\\n\\t// if rep=1 means the prefix sequence contains at least one repeated digit\\n    int dp[10][2][2][1024];\\npublic:\\n    int dfs(int pos, int tight, int rep, int mask) {\\n\\t\\t// at leaf node exclude the cases where mask==0 i.e. leading zeros\\n\\t\\t// if rep=1 means a sequence with at least one repeated digit has been found, so return 1;\\n        if (pos == s)\\n            return ( mask != 0 && rep ) ? 1 : 0;\\n        \\n\\t\\t// memoization\\n        if (dp[pos][tight][rep][mask] != -1)\\n            return dp[pos][tight][rep][mask];\\n        \\n        int limit = tight == 1 ? nums[pos] : 9;\\n        int res = 0;\\n        for (int i = 0; i <= limit; ++i) {\\n            int newTight = (tight == 1 && i == limit) ? 1 : 0;\\n\\t\\t\\t\\n\\t\\t\\t// if mask==0 means it\\'s all leading zeros, so when i=0 it\\'s still leading zero, not counted;\\n\\t\\t\\t// otherwise set the corresponding bit of i to 1 in newMask\\n            int newMask = (mask == 0 && i == 0) ? mask : mask | 1 << i;\\n\\t\\t\\t\\n\\t\\t\\t// exclude cases of leading zero here as well\\n\\t\\t\\t// for other cases, if rep==1 means there has already been repeated digits, so newRep = 1 also\\n\\t\\t\\t// otherwise, check if i has been set in `mask` by the bitwise AND operation; if so, newRep = 1;\\n            int newRep = (mask == 0 && i == 0) ? 0 : rep | bool(mask & 1 << i);\\n            \\n            res += dfs(pos+1, newTight, newRep, newMask);\\n        }\\n        \\n        return dp[pos][tight][rep][mask] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        while (n > 0) {\\n            nums.push_back(n % 10);\\n            n = n / 10;\\n        }\\n        s = nums.size();\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\t// the original full problem is represented by an empty prefix\\n\\t\\t// so pos=0\\n\\t\\t// tight=1 b/c the first digit we place in the prefix must be bounded by nums[0] i.e. the msb in n, so it\\'s tight condition is set.\\n\\t\\t// rep=0 and mask=0 b/c in empty prefix there is no repetion, no digit used\\n        return dfs(0, 1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481034,
                "title": "c-digit-dp-total-nonrepeating",
                "content": "* `bound` variable ensures that we dont overshoot the given `n` value at any time.\\n\\n* `mask` check which digits are taken and which are yet to be taken.\\n\\n* `pos` tracks the length of orignal number.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[11][1025][2] ;\\n    string ref ;\\n    int solve(int pos, int mask , int bound){\\n        if(pos >= ref.size()) return (mask != 0) ;\\n        if(dp[pos][mask][bound] != -1) return dp[pos][mask][bound] ;\\n        \\n        int res = 0 , maxi = bound ? (ref[pos]-\\'0\\') : 9 ;\\n        for(int i = 0 ; i <= maxi ; ++i ){\\n            if(mask & (1 << i)) continue ;\\n            int newMask = (!i and !mask) ? mask : mask | (1 << i) ; // dont put leading zeros\\n            \\n            if(bound) res += solve(pos + 1 , newMask , (ref[pos]-\\'0\\') == i) ;\\n            else res += solve(pos + 1 , newMask , 0) ;\\n        }\\n        \\n        return dp[pos][mask][bound] = res ;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        //answer will be total  positive integers - the ones where no repetition is allowed \\n        ref = to_string(n);\\n        int nonRepeating = solve(0,0,1) ;\\n        return n - nonRepeating ;\\n    }\\n};\\n```\\n\\n\\n* [Refer This Video For Digit Dp Intro](https://www.youtube.com/watch?v=wWfGCIL0AfU)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][1025][2] ;\\n    string ref ;\\n    int solve(int pos, int mask , int bound){\\n        if(pos >= ref.size()) return (mask != 0) ;\\n        if(dp[pos][mask][bound] != -1) return dp[pos][mask][bound] ;\\n        \\n        int res = 0 , maxi = bound ? (ref[pos]-\\'0\\') : 9 ;\\n        for(int i = 0 ; i <= maxi ; ++i ){\\n            if(mask & (1 << i)) continue ;\\n            int newMask = (!i and !mask) ? mask : mask | (1 << i) ; // dont put leading zeros\\n            \\n            if(bound) res += solve(pos + 1 , newMask , (ref[pos]-\\'0\\') == i) ;\\n            else res += solve(pos + 1 , newMask , 0) ;\\n        }\\n        \\n        return dp[pos][mask][bound] = res ;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        //answer will be total  positive integers - the ones where no repetition is allowed \\n        ref = to_string(n);\\n        int nonRepeating = solve(0,0,1) ;\\n        return n - nonRepeating ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428792,
                "title": "c-let-backtracking-do-it-s-work-clean-and-crisp-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(long curr, int mask, int n) {\\n        if(curr > n) return 0;\\n        int ans=1; //since n < 123456789 and all its permutations therefore 1 number always exists\\n        for(int i=0; i<10; i++) {\\n            if(!mask and !i) continue; //leading 0 not allowed\\n            if(mask & (1<<i)) continue; //repetition not allowed\\n            ans+=dfs(curr*10+i,mask+(1<<i),n);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        return n+1-dfs(0,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(long curr, int mask, int n) {\\n        if(curr > n) return 0;\\n        int ans=1; //since n < 123456789 and all its permutations therefore 1 number always exists\\n        for(int i=0; i<10; i++) {\\n            if(!mask and !i) continue; //leading 0 not allowed\\n            if(mask & (1<<i)) continue; //repetition not allowed\\n            ans+=dfs(curr*10+i,mask+(1<<i),n);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        return n+1-dfs(0,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014132,
                "title": "c-permutation-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int permutation(int m, int n) {\\n        // m number with len n\\n        // m * (m - 1) * (m - 2) .. * (m - n + 1) \\n        int res = 1;\\n        while (n) {\\n            res *= m;\\n            m--;\\n            n--;\\n        }\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits; // to store each digit\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        // make it from high to low\\n        // e.g., n=137 => [7, 1, 3] => [1, 3, 7]\\n        reverse(digits.begin(), digits.end());\\n        \\n        // get the # of digits\\n        int size = digits.size();\\n        \\n        // to count the number without duplicates\\n        int res = 0;\\n        \\n        // one digit to (size - 1) digits\\n        // e.g, n=8759 (4 digits), ignore leading 8 here\\n        // so the last 3 digits have 9 * (9 * 8) permutations\\n        // the last 2 digits have 9 * (9) permutations\\n        // the last 1 digits have 9 permutations\\n        for (int i = 1; i < size; i++) {\\n            res += 9 * permutation(9, i - 1);\\n        }\\n        \\n        // consider the leading digit\\n        unordered_set<int> st; // to store the leading fixed one\\n        // for each digit\\n        for (int i = 0; i < size; i++) {\\n            // i = 0 (first digit) e.g., n=8759 | the free will be\\n            // 1xxx, 2xxx, ..., 7xxx\\n            // i > 0 e.g., n=8759 | the free will be\\n            // 80xx, 81xx, ...86xx\\n            for (int j = i > 0 ? 0 : 1; j < digits[i];j++) {\\n                // the current digit should not duplicated with the fixed one\\n                if (st.find(j) != st.end()) continue;\\n                res += permutation(9 - i, size - i - 1);\\n            }\\n            // if the current leading digit duplicate with previous ones => break\\n            if (st.find(digits[i]) != st.end()) break;\\n            // insert the current leading digit to the hash table\\n            st.insert(digits[i]);\\n        }\\n        return n - res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int permutation(int m, int n) {\\n        // m number with len n\\n        // m * (m - 1) * (m - 2) .. * (m - n + 1) \\n        int res = 1;\\n        while (n) {\\n            res *= m;\\n            m--;\\n            n--;\\n        }\\n        return res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits; // to store each digit\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        // make it from high to low\\n        // e.g., n=137 => [7, 1, 3] => [1, 3, 7]\\n        reverse(digits.begin(), digits.end());\\n        \\n        // get the # of digits\\n        int size = digits.size();\\n        \\n        // to count the number without duplicates\\n        int res = 0;\\n        \\n        // one digit to (size - 1) digits\\n        // e.g, n=8759 (4 digits), ignore leading 8 here\\n        // so the last 3 digits have 9 * (9 * 8) permutations\\n        // the last 2 digits have 9 * (9) permutations\\n        // the last 1 digits have 9 permutations\\n        for (int i = 1; i < size; i++) {\\n            res += 9 * permutation(9, i - 1);\\n        }\\n        \\n        // consider the leading digit\\n        unordered_set<int> st; // to store the leading fixed one\\n        // for each digit\\n        for (int i = 0; i < size; i++) {\\n            // i = 0 (first digit) e.g., n=8759 | the free will be\\n            // 1xxx, 2xxx, ..., 7xxx\\n            // i > 0 e.g., n=8759 | the free will be\\n            // 80xx, 81xx, ...86xx\\n            for (int j = i > 0 ? 0 : 1; j < digits[i];j++) {\\n                // the current digit should not duplicated with the fixed one\\n                if (st.find(j) != st.end()) continue;\\n                res += permutation(9 - i, size - i - 1);\\n            }\\n            // if the current leading digit duplicate with previous ones => break\\n            if (st.find(digits[i]) != st.end()) break;\\n            // insert the current leading digit to the hash table\\n            st.insert(digits[i]);\\n        }\\n        return n - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630556,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string num;\\n    int len;\\n    int setKthBit(int n, int k)\\n    {\\n        return ((1 << (k)) | n);\\n    }\\n    bool isKthBitSet(int n, int k)\\n    {\\n        return ( n & (1 << k) );\\n    }\\n\\n    // mask reprsents the set of numbers already in the number //\\n    // like for 1,2,4  maks = 00000001011 // \\n    // we can also use an explicit set but that will be difficult to cache and as we can have only 10 numbers that are 0-9 therefore only 2^11 will be used 2048   \\n    int memo[12][2][5000][2];\\n    // to find the count of numbers with unique digits //\\n    int dp(int n, bool tight, int mask, bool leadingzero){\\n        \\n        // base case //\\n        if(n==0){\\n            int base = 0;\\n            int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n            for(int i=0; i<=ub; ++i){\\n                if(!isKthBitSet(mask, i))\\n                base += 1;\\n            }   \\n            return base;\\n        }\\n        \\n        if(memo[n][tight][mask][leadingzero]!=-1)\\n            return memo[n][tight][mask][leadingzero];\\n        \\n        // recc //\\n        int res = 0;\\n        int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n       \\n        \\n        for(int i=0; i<=ub; ++i){\\n            if(i==0){// for leading zero we wont set it in the mask // eg 00035 is actually unique but as there are 3 zeros leading it wont be unique therfore to handle these type of cases//\\n                if(leadingzero)\\n                res += dp(n-1, tight && i==ub, mask, leadingzero);\\n                else{\\n                    if(!isKthBitSet(mask, i))\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), leadingzero);\\n                }   \\n                \\n            }\\n            else{\\n                if(!isKthBitSet(mask, i)){\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), false);\\n                } \\n            }\\n        }\\n        return memo[n][tight][mask][leadingzero] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        \\n        num = to_string(n);\\n        len = num.length();\\n        \\n        int ans = dp(len-1, true, 0, true);\\n        \\n        ans = n+1 - ans ; \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string num;\\n    int len;\\n    int setKthBit(int n, int k)\\n    {\\n        return ((1 << (k)) | n);\\n    }\\n    bool isKthBitSet(int n, int k)\\n    {\\n        return ( n & (1 << k) );\\n    }\\n\\n    // mask reprsents the set of numbers already in the number //\\n    // like for 1,2,4  maks = 00000001011 // \\n    // we can also use an explicit set but that will be difficult to cache and as we can have only 10 numbers that are 0-9 therefore only 2^11 will be used 2048   \\n    int memo[12][2][5000][2];\\n    // to find the count of numbers with unique digits //\\n    int dp(int n, bool tight, int mask, bool leadingzero){\\n        \\n        // base case //\\n        if(n==0){\\n            int base = 0;\\n            int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n            for(int i=0; i<=ub; ++i){\\n                if(!isKthBitSet(mask, i))\\n                base += 1;\\n            }   \\n            return base;\\n        }\\n        \\n        if(memo[n][tight][mask][leadingzero]!=-1)\\n            return memo[n][tight][mask][leadingzero];\\n        \\n        // recc //\\n        int res = 0;\\n        int ub = tight ? num[len-1-n]-\\'0\\' : 9;\\n       \\n        \\n        for(int i=0; i<=ub; ++i){\\n            if(i==0){// for leading zero we wont set it in the mask // eg 00035 is actually unique but as there are 3 zeros leading it wont be unique therfore to handle these type of cases//\\n                if(leadingzero)\\n                res += dp(n-1, tight && i==ub, mask, leadingzero);\\n                else{\\n                    if(!isKthBitSet(mask, i))\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), leadingzero);\\n                }   \\n                \\n            }\\n            else{\\n                if(!isKthBitSet(mask, i)){\\n                    res += dp(n-1, tight && i==ub, setKthBit(mask, i), false);\\n                } \\n            }\\n        }\\n        return memo[n][tight][mask][leadingzero] = res;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        \\n        num = to_string(n);\\n        len = num.length();\\n        \\n        int ans = dp(len-1, true, 0, true);\\n        \\n        ans = n+1 - ans ; \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018557,
                "title": "python-easy-follow",
                "content": "the basic idea here is computing the non-repeat numbers first and then use N minus the non-repeat numbers.\\nsuppose N is abcde, compute non- repeat numbers smaller than a0000. then compute non-repeat number between a0000 and ab000, and so on.\\n\\n\\'\\'\\'\\n\\n\\tdef numDupDigitsAtMostN(self, N: int) -> int:\\n        def helper(s):\\n            non_repeat = 0\\n            carry = set()\\n            for i in range(len(s)-1):\\n                if s[i] in carry:\\n                    return non_repeat\\n                carry.add(s[i])\\n                tem = int(s[i+1])\\n                for _ in range(int(s[i+1])):\\n                    if str(_) in carry:\\n                          tem -= 1\\n                tem = max(tem, 0)\\n                for j in range(i+2, len(s)):\\n                    tem *= (10-j)\\n                non_repeat += tem\\n            return non_repeat + (s[-1] not in carry)\\n        num = str(N)\\n        non_repeat = 0\\n\\t\\t# compute non- repeat numbers smaller than a0000\\n        for l in range(1, len(num) + 1):\\n            if l == len(num):\\n                 pre, i = int(num[0]) -1, 1\\n            else:\\n                pre, i = 9, 1\\n            while i < l:\\n                pre *= (10 - i)\\n                i += 1\\n            non_repeat += pre        \\n        return N - non_repeat - helper(num)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "the basic idea here is computing the non-repeat numbers first and then use N minus the non-repeat numbers.\\nsuppose N is abcde, compute non- repeat numbers smaller than a0000. then compute non-repeat number between a0000 and ab000, and so on.\\n\\n\\'\\'\\'\\n\\n\\tdef numDupDigitsAtMostN(self, N: int) -> int:\\n        def helper(s):\\n            non_repeat = 0\\n            carry = set()\\n            for i in range(len(s)-1):\\n                if s[i] in carry:\\n                    return non_repeat\\n                carry.add(s[i])\\n                tem = int(s[i+1])\\n                for _ in range(int(s[i+1])):\\n                    if str(_) in carry:\\n                          tem -= 1\\n                tem = max(tem, 0)\\n                for j in range(i+2, len(s)):\\n                    tem *= (10-j)\\n                non_repeat += tem\\n            return non_repeat + (s[-1] not in carry)\\n        num = str(N)\\n        non_repeat = 0\\n\\t\\t# compute non- repeat numbers smaller than a0000\\n        for l in range(1, len(num) + 1):\\n            if l == len(num):\\n                 pre, i = int(num[0]) -1, 1\\n            else:\\n                pre, i = 9, 1\\n            while i < l:\\n                pre *= (10 - i)\\n                i += 1\\n            non_repeat += pre        \\n        return N - non_repeat - helper(num)\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 560346,
                "title": "python-digit-dp-pattern-for-similar-questions",
                "content": "Theory: https://codeforces.com/blog/entry/53960\\n\\nMore of the same approach:\\n[902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/discuss/559624/python-digit-dp)\\n[788. Rotated Digits](https://leetcode.com/problems/rotated-digits/discuss/560601/python-digit-dp)\\n[1397. Find All Good Strings](https://leetcode.com/problems/find-all-good-strings/discuss/560841/Python-Digit-DP)\\n[233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/560876/Python-Digit-DP)\\n[357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/560898/Python-Digit-DP)\\n[600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/584350/Python-Digit-DP-(Pattern-For-Similar-Questions))\\n\\nAt each recursive call (adding digit to less significant position) compute:\\n- isPrefix - if the new number is the prefix of N\\n- isBigger - if the new number will be bigger than N when we reach final position\\n- digits - current digits of the new number\\n- repeated - if there is already a repeated digit\\nOptimization - if there is already a repeated number and the current number cannot be bigger than N when we reach the last position we can add 10 (for 10 digits) to the result and every subresult gets multiplied by 10.\\n```\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        N = list(map(int, str(N)))\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, digits, repeated):\\n            if pos == len(N):\\n                return 0\\n            if repeated and not isPrefix and not isBigger:\\n                return 10 + 10 * dp(pos + 1, False, False, digits, True)\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n                _repeated = repeated\\n                if (digits >> i) & 1 == 1:\\n                    _repeated = True\\n                if _repeated and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                _digits = digits | (1 << i)\\n                result += dp(pos + 1, _isPrefix, _isBigger, _digits, _repeated)\\n            return result\\n        return dp(0, True, False, 0, False)\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        N = list(map(int, str(N)))\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, digits, repeated):\\n            if pos == len(N):\\n                return 0\\n            if repeated and not isPrefix and not isBigger:\\n                return 10 + 10 * dp(pos + 1, False, False, digits, True)\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n                _repeated = repeated\\n                if (digits >> i) & 1 == 1:\\n                    _repeated = True\\n                if _repeated and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                _digits = digits | (1 << i)\\n                result += dp(pos + 1, _isPrefix, _isBigger, _digits, _repeated)\\n            return result\\n        return dp(0, True, False, 0, False)\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 332462,
                "title": "solution-in-python-3-beats-99",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1:\\n    \\t\\t\\tcontinue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]:\\n    \\t\\t\\t\\tk += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1:\\n    \\t\\t\\tcontinue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]:\\n    \\t\\t\\t\\tk += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 281376,
                "title": "c-share-my-dp-solution-count-the-numbers-without-repeated-digits",
                "content": "```\\n// DP State is current digit index, visited bitmask,\\n// comparison of current number to N, left digits.\\nint dp[11][2048][3][11];\\n\\nint sgn(int val) {\\n    return (0 < val) - (val < 0);\\n}\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> N;\\n    \\n    int genAll(int curDigitIndex, int vis, int cmpN, int len) {\\n       if (len == 0) {\\n          return cmpN <= 0;\\n       }\\n       int &res = dp[curDigitIndex][vis][cmpN + 1][len];\\n       if (res != -1) return res;\\n       res = 0;\\n       for (int i = 0; i <= 9; ++i) {\\n          if (curDigitIndex == 0 && i == 0) continue;\\n          if (vis & (1 << i)) continue;\\n           \\n          int nCmpN = cmpN \\n              ? cmpN \\n              : sgn(i - N[curDigitIndex]);\\n           \\n          res += genAll(\\n              curDigitIndex + 1,\\n              vis | (1 << i),\\n              nCmpN,\\n              len - 1);\\n       }\\n       return res;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n      memset(dp, -1, sizeof(dp));\\n      int nn = n;\\n      while (nn) {\\n          N.push_back(nn % 10);\\n          nn /= 10;\\n      }\\n      reverse(N.begin(), N.end());\\n\\n      int allNonRep = 0;\\n      for (int i = 1; i <= N.size(); ++i) {\\n          int cmpN = i < N.size() ? -1 : 0;\\n\\t\\t  // generate all numbers with non repeating\\n\\t\\t  // digits with \\'i\\' length\\n          allNonRep += genAll(0, 0, cmpN, i);\\n      }\\n      return n - allNonRep;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// DP State is current digit index, visited bitmask,\\n// comparison of current number to N, left digits.\\nint dp[11][2048][3][11];\\n\\nint sgn(int val) {\\n    return (0 < val) - (val < 0);\\n}\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> N;\\n    \\n    int genAll(int curDigitIndex, int vis, int cmpN, int len) {\\n       if (len == 0) {\\n          return cmpN <= 0;\\n       }\\n       int &res = dp[curDigitIndex][vis][cmpN + 1][len];\\n       if (res != -1) return res;\\n       res = 0;\\n       for (int i = 0; i <= 9; ++i) {\\n          if (curDigitIndex == 0 && i == 0) continue;\\n          if (vis & (1 << i)) continue;\\n           \\n          int nCmpN = cmpN \\n              ? cmpN \\n              : sgn(i - N[curDigitIndex]);\\n           \\n          res += genAll(\\n              curDigitIndex + 1,\\n              vis | (1 << i),\\n              nCmpN,\\n              len - 1);\\n       }\\n       return res;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n      memset(dp, -1, sizeof(dp));\\n      int nn = n;\\n      while (nn) {\\n          N.push_back(nn % 10);\\n          nn /= 10;\\n      }\\n      reverse(N.begin(), N.end());\\n\\n      int allNonRep = 0;\\n      for (int i = 1; i <= N.size(); ++i) {\\n          int cmpN = i < N.size() ? -1 : 0;\\n\\t\\t  // generate all numbers with non repeating\\n\\t\\t  // digits with \\'i\\' length\\n          allNonRep += genAll(0, 0, cmpN, i);\\n      }\\n      return n - allNonRep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257332,
                "title": "java-0ms-solution-with-explanations",
                "content": "The idea is simple. Count all numbers that do not have repeating digits and less than or equal to `N`. Substract the count from `N` and return. My initial idea was to permutate 10 digits  in [1..`digsCount`] slots (`digsCount` is a number of digits in `N`) and take into account those results of permutation that are <= `N` only. And this worked, but the submition time was  ~1400ms.\\n\\nAn alternative approach uses similar idea but instead of generating permutations we can count them using \\'number of permutations of n objects taken r at a time\\' formula *P(n,r)=n!/(n\\u2212r)!*. \\nBecause digit 0 cannot be a highest digit (number \\'010\\' does not make sence, there is number \\'10\\' instead), we need to adjust the formula *P\\'(n,r) = (n-1) * P(n - 1,r - 1)=(n-1)(n-1)!/(n\\u2212r)!* In this case *n*  equals to 10, *r* is in [1..`digsCount`). *P\\'(r)=9  9! / (10 \\u2212 r)!*\\n\\nLet\\'s consider number 112.\\n`digsCount` = `getDigits(N, digits)` = 3\\n`digits` = [2, 1, 1]\\n`uniq` = `initPermCount(digsCount)` = *P\\'(1) + P\\'(2)* = 9 * 9! / (10 - 1)! + 9 * 9! / (10 - 2)! = 9 + 9 * 9 = 90\\n\\nNow, for every `i` in (`digsCount`..0] we get all the digits `j` smaller than `digits[i]` and that are not used in the higher digits of `N`. We calculate P(10 - `digsCount` + `i`, `i`). Zero cannot be highest digit, so we skip it (`j = (i == digsCount - 1) ? 1 : 0`). If `digits[i]` was used before  it means the original number `N` is not composed of unique digits only, and at this point we stop calculations.\\n\\n`i` = 2, `digits[i]` = 1, `j` = 1, `used` = [] (skip since `j` is not < `digits[i]`)\\n\\n`i` = 1, `digits[i]` = 1, `j` = 0, `used` = [1]\\nSince two digits are used (0 and 1) we calculate permutation using 10 - 2 digits:\\n`uniq` = `uniq` + P(10 - `digsCount` + `i`, `i`) = 90 + P(10-3+1, 1) = 90 + 8 = 98\\n\\n`i` = 1, `digits[i]` = 1, `j` = 1, `used` = [1] (skip since `j` is not < `digits[i]`)\\n\\nFinish calculations since `digits[i]` is in `used`. Since `digits` contains duplicates we do not increment `uniq`;\\n\\nReturn `N` - `uniq` = 112 - 98 = 14\\n\\n```java\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int digsCount = getDigits(N, digits);\\n\\n        boolean[] used = new boolean[10];\\n        boolean numUniq = true;\\n        int uniq = initPermCount(digsCount);\\n        for (int i = digsCount - 1; i >= 0; i--) {\\n            for (int j = (i == digsCount - 1) ? 1 : 0; j < digits[i]; j++) {\\n                if (!used[j]) {\\n                    uniq += permCount(digsCount, digsCount - i);\\n                }\\n            }\\n            if (used[digits[i]]) {\\n                numUniq = false;\\n                break;\\n            }\\n            used[digits[i]] = true;\\n        }\\n        if (numUniq) {\\n            uniq++;\\n        }\\n        return N - uniq;\\n    }\\n\\n    private int getDigits(int num, int[] digits) {\\n        int i = 0;\\n        while (num > 0) {\\n            digits[i] = num % 10;\\n            num /= 10;\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    private int initPermCount(int digsCount) {\\n        int sum = 0;\\n        for (int i = 1; i < digsCount; i++) {\\n            sum += 9 * permCount(i, 1);\\n        }\\n        return sum;\\n    }\\n\\n    private int permCount(int n, int reserved) {\\n        int hi = 10 - reserved, lo = hi - (n - reserved);\\n        int res = 1;\\n        while (hi > lo) {\\n            res *= hi--;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int digsCount = getDigits(N, digits);\\n\\n        boolean[] used = new boolean[10];\\n        boolean numUniq = true;\\n        int uniq = initPermCount(digsCount);\\n        for (int i = digsCount - 1; i >= 0; i--) {\\n            for (int j = (i == digsCount - 1) ? 1 : 0; j < digits[i]; j++) {\\n                if (!used[j]) {\\n                    uniq += permCount(digsCount, digsCount - i);\\n                }\\n            }\\n            if (used[digits[i]]) {\\n                numUniq = false;\\n                break;\\n            }\\n            used[digits[i]] = true;\\n        }\\n        if (numUniq) {\\n            uniq++;\\n        }\\n        return N - uniq;\\n    }\\n\\n    private int getDigits(int num, int[] digits) {\\n        int i = 0;\\n        while (num > 0) {\\n            digits[i] = num % 10;\\n            num /= 10;\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    private int initPermCount(int digsCount) {\\n        int sum = 0;\\n        for (int i = 1; i < digsCount; i++) {\\n            sum += 9 * permCount(i, 1);\\n        }\\n        return sum;\\n    }\\n\\n    private int permCount(int n, int reserved) {\\n        int hi = 10 - reserved, lo = hi - (n - reserved);\\n        int res = 1;\\n        while (hi > lo) {\\n            res *= hi--;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603261,
                "title": "java-easy-to-understand-digit-dp-bit-manipulation",
                "content": "```\\nclass Solution {\\n    Integer[][][][] dp;\\n    private int solve(char[] num, int curDig, boolean isStrict, int bit, boolean repeated) {\\n        if(curDig == num.length) return repeated ? 1 : 0;\\n        if(dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] != null) return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0];\\n        int end = isStrict ? num[curDig] - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            if(bit == 0 && i == 0) \\n                res += solve(num, curDig + 1, isStrict && i == end, bit, repeated);\\n            else\\n                res += solve(num, curDig + 1, isStrict && i == end, bit | (1 << i), repeated | (bit & (1 << i)) != 0);\\n        }\\n        return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] = res;\\n    }\\n    public int numDupDigitsAtMostN(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        dp = new Integer[10][2][1025][2];\\n        return solve(num, 0, true, 0, false);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][][][] dp;\\n    private int solve(char[] num, int curDig, boolean isStrict, int bit, boolean repeated) {\\n        if(curDig == num.length) return repeated ? 1 : 0;\\n        if(dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] != null) return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0];\\n        int end = isStrict ? num[curDig] - \\'0\\' : 9;\\n        int res = 0;\\n        for(int i = 0; i <= end; i++) {\\n            if(bit == 0 && i == 0) \\n                res += solve(num, curDig + 1, isStrict && i == end, bit, repeated);\\n            else\\n                res += solve(num, curDig + 1, isStrict && i == end, bit | (1 << i), repeated | (bit & (1 << i)) != 0);\\n        }\\n        return dp[curDig][isStrict ? 1 : 0][bit][repeated ? 1 : 0] = res;\\n    }\\n    public int numDupDigitsAtMostN(int n) {\\n        char[] num = String.valueOf(n).toCharArray();\\n        dp = new Integer[10][2][1025][2];\\n        return solve(num, 0, true, 0, false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196829,
                "title": "easy-bitmask-dp-solution",
                "content": "\\n\\n# Code\\n```\\nint dp[10][1<<10][2][10];//index digit_set flag length\\n\\nstring s;\\n\\nint solve(int ind,int mask,bool f,int len)\\n{\\n    if(ind>=len)\\n        return 1;\\n    \\n    auto &p=dp[ind][mask][f][len];\\n\\n    if(p!=-1)\\n        return p;\\n    \\n    p=0;\\n\\n    int maxi=9;\\n\\n    if(f&&len==s.size())\\n        maxi=s[ind]-\\'0\\';\\n    \\n    for(int i=0;i<=maxi;++i)\\n    {\\n        if((mask&(1<<i)))\\n            continue;\\n        if(f)\\n        {\\n            bool c=(i==maxi);\\n            p+=solve(ind+1,mask^(1<<i),c,len);\\n            continue;\\n        }\\n        p+=solve(ind+1,mask^(1<<i),false,len);\\n    }\\n    return p;\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n\\n        for(int len=1;len<=s.size();++len)\\n        {\\n            int maxi=9;\\n            if(len==s.size())\\n            {\\n                maxi=s[0]-\\'0\\';\\n                for(int i=1;i<=maxi;++i)\\n                {\\n                    bool f=(i==maxi);\\n                    ans+=solve(1,1<<i,f,len);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=1;i<10;++i)\\n                {\\n                    ans+=solve(1,1<<i,false,len);\\n                }\\n            }\\n        }\\n        ans=n-ans;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nint dp[10][1<<10][2][10];//index digit_set flag length\\n\\nstring s;\\n\\nint solve(int ind,int mask,bool f,int len)\\n{\\n    if(ind>=len)\\n        return 1;\\n    \\n    auto &p=dp[ind][mask][f][len];\\n\\n    if(p!=-1)\\n        return p;\\n    \\n    p=0;\\n\\n    int maxi=9;\\n\\n    if(f&&len==s.size())\\n        maxi=s[ind]-\\'0\\';\\n    \\n    for(int i=0;i<=maxi;++i)\\n    {\\n        if((mask&(1<<i)))\\n            continue;\\n        if(f)\\n        {\\n            bool c=(i==maxi);\\n            p+=solve(ind+1,mask^(1<<i),c,len);\\n            continue;\\n        }\\n        p+=solve(ind+1,mask^(1<<i),false,len);\\n    }\\n    return p;\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n\\n        for(int len=1;len<=s.size();++len)\\n        {\\n            int maxi=9;\\n            if(len==s.size())\\n            {\\n                maxi=s[0]-\\'0\\';\\n                for(int i=1;i<=maxi;++i)\\n                {\\n                    bool f=(i==maxi);\\n                    ans+=solve(1,1<<i,f,len);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=1;i<10;++i)\\n                {\\n                    ans+=solve(1,1<<i,false,len);\\n                }\\n            }\\n        }\\n        ans=n-ans;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066444,
                "title": "0ms-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea of this solution is to count the number of integers with unique digits from 0 to N, which can be done by considering the different cases for each digit. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start by looping through the digits of N, starting from the least significant digit. For each digit, we first calculate the number of integers with unique digits that are smaller than N and have the same number of digits as N. For this, we use a helper function `A(m, n)` which calculates the number of numbers with digits 1, 2, ..., m, where each digit can appear at most once and the total number of digits is n. \\n\\nThen, for the current digit, we loop through all possible digits (skipping 0 if the current digit is the most significant digit) and check if it has already been seen. If yes, we break, as it means that all the remaining digits should be the same as the current digit. Otherwise, we increment the count by the number of integers with unique digits that are smaller than N and have the same number of digits as N. \\n\\nFinally, we subtract the count from N to get the result.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits;\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        int ans = 0, k = digits.size();\\n        for (int i = 1; i < k; ++i) {\\n            ans += 9 * A(9, i - 1);\\n        }\\n        set<int> seen;\\n        for (int i = 0; i < k; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < digits[i]; ++j) {\\n                if (!seen.count(j)) {\\n                    ans += A(9 - i, k - i - 1);\\n                }\\n            }\\n            if (seen.count(digits[i])) {\\n                break;\\n            }\\n            seen.insert(digits[i]);\\n        }\\n        return n - ans;\\n    }\\n    int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> digits;\\n        for (int x = n + 1; x > 0; x /= 10) {\\n            digits.push_back(x % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        int ans = 0, k = digits.size();\\n        for (int i = 1; i < k; ++i) {\\n            ans += 9 * A(9, i - 1);\\n        }\\n        set<int> seen;\\n        for (int i = 0; i < k; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < digits[i]; ++j) {\\n                if (!seen.count(j)) {\\n                    ans += A(9 - i, k - i - 1);\\n                }\\n            }\\n            if (seen.count(digits[i])) {\\n                break;\\n            }\\n            seen.insert(digits[i]);\\n        }\\n        return n - ans;\\n    }\\n    int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760545,
                "title": "100-faster-solution-using-math-and-recursion-tc-o-1-c-explained",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass Solution {\\npublic:\\n    // to return factorial starting at st and multiplying till t no of times\\n    int fac(int st,int t){\\n        int ans = 1;\\n        while(t){\\n            ans *= st;\\n            st--;\\n            t--;\\n        }\\n        return ans;\\n    }\\n    // mask will create mask over digits fixed\\n    vector<bool> mask;\\n    // we are counting numbers with 0 duplicate digits\\n    int solve(vector<int> &dig, int ind, int st){\\n        if(ind == dig.size()) return 1;\\n        int ans = 0;\\n        if(ind == 0){\\n            // 0 cannot be used\\n            for(int i=1;i<dig[ind];i++){\\n                if(i < dig[ind]){\\n                    ans += fac(st,dig.size()-1);\\n                }\\n            }\\n            // here we are fixing digit equal to dig[ind] and masking it to use in future\\n            mask[dig[ind]] = 1;\\n            // now calling solve for next index\\n            ans += solve(dig,ind + 1, st);\\n            return ans;\\n        }\\n        // if we are not at first index means we can use 0 now\\n        for(int i=0;i<dig[ind];i++){\\n            if(mask[i]) continue; // see if we have used this digit before than we cannot indclude its contribution\\n            if(i < dig[ind]){\\n                ans += fac(st-1,dig.size()-ind-1);\\n            }\\n        }\\n        // if we have used dig[ind] before than return ans no need to solve for next index \\n        if(mask[dig[ind]]) return ans;\\n        mask[dig[ind]] = 1;\\n        ans += solve(dig,ind + 1,st-1);\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        // here we can use 10 digits including 0 but must not start with zero\\n        if(n<=10) return 0;\\n        int nc = n;\\n        vector<int> dig;\\n        while(nc){\\n            dig.push_back(nc%10);\\n            nc /= 10;\\n        }\\n        reverse(dig.begin(), dig.end());\\n        // now we have digits\\n        mask.resize(10,0);\\n        // till number of n digits\\n        vector<int> v(10,0); // this contains numbers that have unique digits in ith digit number\\n        long int a = 9;\\n        for(int i=1;i<10;i++){\\n            v[i] = a;\\n            a = a*(10-i);\\n        }\\n        // Now till we try n digits number \\n        int ans = 0;\\n        for(int i=1;i<dig.size();i++){\\n            ans += v[i];\\n        }\\n        // Now for dig.size digit number we can\\n        ans += solve(dig,0,9);\\n        return n-ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/036658bb-d5e8-4718-aea0-26590569bf1a_1667148845.2003994.png)\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // to return factorial starting at st and multiplying till t no of times\\n    int fac(int st,int t){\\n        int ans = 1;\\n        while(t){\\n            ans *= st;\\n            st--;\\n            t--;\\n        }\\n        return ans;\\n    }\\n    // mask will create mask over digits fixed\\n    vector<bool> mask;\\n    // we are counting numbers with 0 duplicate digits\\n    int solve(vector<int> &dig, int ind, int st){\\n        if(ind == dig.size()) return 1;\\n        int ans = 0;\\n        if(ind == 0){\\n            // 0 cannot be used\\n            for(int i=1;i<dig[ind];i++){\\n                if(i < dig[ind]){\\n                    ans += fac(st,dig.size()-1);\\n                }\\n            }\\n            // here we are fixing digit equal to dig[ind] and masking it to use in future\\n            mask[dig[ind]] = 1;\\n            // now calling solve for next index\\n            ans += solve(dig,ind + 1, st);\\n            return ans;\\n        }\\n        // if we are not at first index means we can use 0 now\\n        for(int i=0;i<dig[ind];i++){\\n            if(mask[i]) continue; // see if we have used this digit before than we cannot indclude its contribution\\n            if(i < dig[ind]){\\n                ans += fac(st-1,dig.size()-ind-1);\\n            }\\n        }\\n        // if we have used dig[ind] before than return ans no need to solve for next index \\n        if(mask[dig[ind]]) return ans;\\n        mask[dig[ind]] = 1;\\n        ans += solve(dig,ind + 1,st-1);\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        // here we can use 10 digits including 0 but must not start with zero\\n        if(n<=10) return 0;\\n        int nc = n;\\n        vector<int> dig;\\n        while(nc){\\n            dig.push_back(nc%10);\\n            nc /= 10;\\n        }\\n        reverse(dig.begin(), dig.end());\\n        // now we have digits\\n        mask.resize(10,0);\\n        // till number of n digits\\n        vector<int> v(10,0); // this contains numbers that have unique digits in ith digit number\\n        long int a = 9;\\n        for(int i=1;i<10;i++){\\n            v[i] = a;\\n            a = a*(10-i);\\n        }\\n        // Now till we try n digits number \\n        int ans = 0;\\n        for(int i=1;i<dig.size();i++){\\n            ans += v[i];\\n        }\\n        // Now for dig.size digit number we can\\n        ans += solve(dig,0,9);\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449053,
                "title": "c-solution-digit-dp-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int solve(string &nums,int i=0,int mask=0,bool rep=0,int tight=1){\\n        if(i>=nums.size())\\n            return rep and mask!=0;\\n        if(dp[i][mask][rep][tight]!=-1)\\n            return dp[i][mask][rep][tight];\\n        int ub=tight?(nums[i]-\\'0\\'):9;\\n        int ans=0;\\n        for(int j=0;j<=ub;j++){\\n            if(mask==0 and j==0 )\\n                ans+=solve(nums,i+1,mask,rep,tight&(j==ub));\\n            else if(mask&(1<<j))\\n                ans+=solve(nums,i+1,mask,true,tight&(j==ub));\\n            else\\n                ans+=solve(nums,i+1,mask|(1<<j),rep,tight&(j==ub));\\n        }\\n        return dp[i][mask][rep][tight]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string nums=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int solve(string &nums,int i=0,int mask=0,bool rep=0,int tight=1){\\n        if(i>=nums.size())\\n            return rep and mask!=0;\\n        if(dp[i][mask][rep][tight]!=-1)\\n            return dp[i][mask][rep][tight];\\n        int ub=tight?(nums[i]-\\'0\\'):9;\\n        int ans=0;\\n        for(int j=0;j<=ub;j++){\\n            if(mask==0 and j==0 )\\n                ans+=solve(nums,i+1,mask,rep,tight&(j==ub));\\n            else if(mask&(1<<j))\\n                ans+=solve(nums,i+1,mask,true,tight&(j==ub));\\n            else\\n                ans+=solve(nums,i+1,mask|(1<<j),rep,tight&(j==ub));\\n        }\\n        return dp[i][mask][rep][tight]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string nums=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422861,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310889,
                "title": "am-i-the-only-one-who-misunderstand-the-question",
                "content": "I spent over 1 hr debugging couldn\\'t figure out why my answer is wrong for some large numbers. \\n\\nThe question states that have at least one repeated digit. I took that to mean \"101\" is NOT OK because both \"1\" are not glued together, and \"11\" is OK because they are together.\\n\\nI eventually gave up and checked the solution and realized \"101\" is actually OK because \"1\" appears twice. Am I the only person who didn\\'t understand the question? \\n\\nIt is really frustrating.\\n\\n```Java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        // 983582\\n        // 108318\\n        int ttl = n++;\\n        int ans = 0;\\n        List<Integer> list = new ArrayList<>();\\n        while(n>0){\\n            list.add(n%10);\\n            n/=10;\\n        }\\n        for (int i = 1; i < list.size(); i++){\\n            ans+=9*find(i-1, 9);\\n        }\\n        boolean[] seen = new boolean[10];\\n        for (int i = list.size(), d = 9; i > 0; --i, d--){\\n            int count = i == list.size()? list.get(i-1)-1: list.get(i-1);\\n            for (int j = 0; j < list.get(i-1); j++){\\n                if (seen[j]){\\n                    count--;\\n                }\\n            }\\n            ans += count*find(i-1, d);\\n            if (seen[list.get(i-1)]){\\n                break;\\n            }\\n            seen[list.get(i-1)]=true;\\n        }\\n        return ttl-ans;\\n    }\\n\\n    private int find(int n, int d){\\n        // dCn*n!\\n        // d!/(d-n)/(d-n).../1\\n        int ans = 1;\\n        for (int i = 1; i <= d; i++){\\n            ans *= i;\\n        }\\n        for (int i = n+1; i <= d; i++){\\n            ans /= (i-n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        // 983582\\n        // 108318\\n        int ttl = n++;\\n        int ans = 0;\\n        List<Integer> list = new ArrayList<>();\\n        while(n>0){\\n            list.add(n%10);\\n            n/=10;\\n        }\\n        for (int i = 1; i < list.size(); i++){\\n            ans+=9*find(i-1, 9);\\n        }\\n        boolean[] seen = new boolean[10];\\n        for (int i = list.size(), d = 9; i > 0; --i, d--){\\n            int count = i == list.size()? list.get(i-1)-1: list.get(i-1);\\n            for (int j = 0; j < list.get(i-1); j++){\\n                if (seen[j]){\\n                    count--;\\n                }\\n            }\\n            ans += count*find(i-1, d);\\n            if (seen[list.get(i-1)]){\\n                break;\\n            }\\n            seen[list.get(i-1)]=true;\\n        }\\n        return ttl-ans;\\n    }\\n\\n    private int find(int n, int d){\\n        // dCn*n!\\n        // d!/(d-n)/(d-n).../1\\n        int ans = 1;\\n        for (int i = 1; i <= d; i++){\\n            ans *= i;\\n        }\\n        for (int i = n+1; i <= d; i++){\\n            ans /= (i-n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277652,
                "title": "python-permutation-rule-find-the-numbers-without-repeted-digits",
                "content": "\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        nums = [int(i) for i in str(n+1)] # digits in n+1\\n        d = len(nums) # number of digits in n+1\\n        res = 0 # number of no duplicates\\n        \\n        # count no duplicates for numbers with <d digits\\n        for i in range(1,d):\\n            res += 9 * math.perm(9,i-1)\\n        \\n\\t\\t# count no duplicates for numbers with d digits and smaller than n\\n        for i, x in enumerate(nums):\\n            if i == 0:\\n                digit_range = range(1,x) # first digit can not be 0\\n            else:\\n                digit_range = range(x)\\n                \\n            for y in digit_range:\\n                if y not in nums[:i]:\\n                    res += math.perm(9-i,d-1-i)\\n            if x in nums[:i]: break\\n                \\n        return n - res\\n```\\n        \\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        nums = [int(i) for i in str(n+1)] # digits in n+1\\n        d = len(nums) # number of digits in n+1\\n        res = 0 # number of no duplicates\\n        \\n        # count no duplicates for numbers with <d digits\\n        for i in range(1,d):\\n            res += 9 * math.perm(9,i-1)\\n        \\n\\t\\t# count no duplicates for numbers with d digits and smaller than n\\n        for i, x in enumerate(nums):\\n            if i == 0:\\n                digit_range = range(1,x) # first digit can not be 0\\n            else:\\n                digit_range = range(x)\\n                \\n            for y in digit_range:\\n                if y not in nums[:i]:\\n                    res += math.perm(9-i,d-1-i)\\n            if x in nums[:i]: break\\n                \\n        return n - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555833,
                "title": "java-for-if-else-lovers",
                "content": "**Strategy**\\nWe\\'re taking the problem, slice it into smaller bites, solve for the smaller bites, and\\nadd up what we calculate in each slice. \\n\\n**Solution**\\nImagine we have three digits, x, y, and z. There are multiple ways to have a permutation\\nof these digits such that at least one of the digits is repeated. Let\\'s not solve for that.\\nInstead we solve for permutations w/o repeated digits. The idea is for index 0 we have\\nthree digits to choose from, x, y, and z. For index 1 we only have two choices left since\\none choice has already been exhausted when we picked a digit for index 0. It doesn\\'t\\nmatter which digit we choose at what index. What matters is the number of choices we\\nhave at each index.\\n\\n**Example 1**\\nLet\\'s say we\\'re calculating the number of permutations w/o repeated digits and lower\\nthan 1000. Let\\'s slice our problem into smaller problems. We don\\'t care about the\\nvalue of 1000 at this point. We say 1000 is consisting of four digits. We solve the\\noriginal problem for numbers lower than 9 (one 9), lower than 99 (two 9\\'s), and lower\\nthan 999 (three 9\\'s). We know that not all four digit numbers are lower than 1000 so\\nwe won\\'t solve for numbers lower than 9999 (four 9\\'s). We\\'ll take care of four digits\\nnumbers later. Solving for numbers consisting of 9\\'s is easy. Let\\'s explain what happens\\nnext in Example 2.\\n\\n**Example 2**\\nLet\\'s say we\\'re solving for 1,534,634. Plan is to slice it into smaller problems. Let\\'s\\nsay we already solved for numbers up to 999,999 like what we explained in Example 1.\\nFor 1,000,000 to 1,534,634 our smaller problems are solving for 1,499,999 plus solving\\nfor 1,500,000 all the way to 1,534,634. The latter piece will be sliced into smaller \\nproblems as well. Smaller problems from 1,500,000 to 1,534,634 are solving for the \\nfollowings,\\nsolving for 1,529,999 plus\\nsolving for 1,533,999 plus\\nsolving for 1,534,599 plus\\nsolving for 1,534,629 plus\\nsolving for 1,534,634.\\nIn each iteration we keep track of a pointer which is a pivot pointer. All digits \\nbefore pivot represent themselves, so the possibilities for each is always one.\\nThe pivot digit can take any digit up to the value of the pivot digit minus all \\npossibilities that we\\'ve already exhausted.\\nLet\\'s say we\\'re dealing w/ 1,529,999 and pivot is at index 2 meaning starting from\\nleft first digit is 1 and represents itself b/c it\\'s before pivot. Second digit is\\n5 and represents itself for the same reason. Now digit 2 is our pivot digit. We say\\nour possibilities are 0, 1, and 2 so three possibilities but we have already exhausted\\none of our possibilities which is 1 at index 0. So we\\'re left w/ only two possibilities\\nand again 1 and 5 represent themselves and 2 is lower than 5 so the only exhausted\\npossibility is 1. For all those 9\\'s after pivot we say possibilities are 0 to 9 which\\nis 10 possibilities minus the count of exhausted possibilities, so in this case for\\nthe first 9 we have 10-3=7 possibilities, for the second 9 we have 6 possibilities and \\nso on.\\nAdd up all counts from each iteration and we have all permutations w/o repeated digits.\\nSubtract the total count from the original input number and we have all permutations\\nw/ at least one repeated digit.\\n```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n\\tint noRepeatCount = 0;\\n\\n\\tpublic int numDupDigitsAtMostN(int n) {\\n\\t\\tint nStrLength = String.valueOf(n).length();\\n\\t\\tint allNineLength = 0;\\n\\n\\t\\t// Edge cases out of the way.\\n\\t\\tif (n < 0 || nStrLength < 2)\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\t// If n is all 9\\'s like 99999.\\n\\t\\telse if (Math.pow(10, nStrLength) - 1 == n)\\n\\t\\t\\tallNineLength = nStrLength;\\n\\t\\t\\n\\t\\t// If n is not all 9\\'s we calculate the largest number lower than n consisting of all 9\\'s.\\n\\t\\telse\\n\\t\\t\\tallNineLength = nStrLength - 1;\\n\\n\\t\\t// Calculating all 9\\'s e.g. for 10^6 we calculate for six 9\\'s which is 999,999.\\n\\t\\tfor (int numberOfDigits = 1; numberOfDigits <= allNineLength; numberOfDigits++) {\\n\\t\\t\\tnoRepeatCount += calcNumberOfNoRepeat(numberOfDigits);\\n\\t\\t}\\n\\n\\t\\t// Calculating from all 9\\'s to n e.g. for 10^6 we already calculated up to 999,999 and\\n\\t\\t// we just need to calculate for the rest.\\n\\t\\tif (Math.pow(10, nStrLength) - 1 > n) {\\n\\t\\t\\t\\n\\t\\t\\t// Count of all possible values 0 to 9.\\n\\t\\t\\tint mutations = 10;\\n\\t\\t\\t\\n\\t\\t\\t// HashSet is used only in part of the code. Worst case size() is the number of\\n\\t\\t\\t// mutations. contains() is called nStrLength times worst case in each iteration\\n\\t\\t\\t// w/ no more than nStrLength iterations.\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\t\\t\\t\\n\\t\\t\\t// We have two pointers each nStrLength hops to travel.\\n\\t\\t\\t// index1 is the pivot index and index2 keeps track of the current digit in n.\\n\\t\\t\\t// Based on index1 we decide what to do w/ digit at index2.\\n\\t\\t\\tfor (int index1 = 0; index1 < nStrLength; index1++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In each iteration we count noRepeat numbers. At the end of the iteration\\n\\t\\t\\t\\t// we add local noRepeat count to the total noRepeat count.\\n\\t\\t\\t\\tint noRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Digits visited in each iteration have nothing to do w/ other iterations\\n\\t\\t\\t\\t// so we clear the HashSet before start of each inner iteration.\\n\\t\\t\\t\\ths.clear();\\n\\t\\t\\t\\tfor (int index2 = 0; index2 < nStrLength; index2++) {\\n\\t\\t\\t\\t\\t// Extracting digit at index2.\\n\\t\\t\\t\\t\\tint index2Digit = (int) (n / Math.pow(10, String.valueOf(n).length() - (index2 + 1)) % 10);\\n\\t\\t\\t\\t\\t// index1 is the pivot. Anything before index1 is already taken care of.\\n\\t\\t\\t\\t\\t// This means digits before index1 can only represent themselves, which\\n\\t\\t\\t\\t\\t// means if we see duplicate digits before index1 noRepeatCountLocal\\n\\t\\t\\t\\t\\t// for that entire iteration becomes zero. Remember we\\'re counting numbers\\n\\t\\t\\t\\t\\t// w/o repeated digits.\\n\\t\\t\\t\\t\\tif (index2 < index1) {\\n\\t\\t\\t\\t\\t\\t// This is where we use HashSet. If digit at index2 is already in the\\n\\t\\t\\t\\t\\t\\t// HashSet that means we\\'re dealing w/ a duplicate so noRepeatCountLocal\\n\\t\\t\\t\\t\\t\\t// is set to zero and we\\'re done w/ the iteration.\\n\\t\\t\\t\\t\\t\\tif (hs.contains(index2Digit)) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\t\\t// If digit at index2 is not part of the HashSet add it to the HashSet.\\n\\t\\t\\t\\t\\t\\t\\ths.add(index2Digit);\\n\\t\\t\\t\\t\\t// index2 is meeting the pivot digit. The idea is to subtract 1 from the pivot\\n\\t\\t\\t\\t\\t// digit and make a possible big jump depending on the position of index1.\\n\\t\\t\\t\\t\\t// Imagine we\\'re dealing w/ 15,564,465. The idea is to count for 14,xxx,xxx. \\n\\t\\t\\t\\t\\t// We\\'ll replace those x\\'s w/ 9\\'s later in the code. So basically we skip over\\n\\t\\t\\t\\t\\t// 10^7-1 to 1.5*10^7-1.\\n\\t\\t\\t\\t\\t} else if (index2 == index1) {\\n\\t\\t\\t\\t\\t\\t// Special case when both pointers are at index 0 meaning we\\'re dealing w/\\n\\t\\t\\t\\t\\t\\t// the first digit of n, which can\\'t be 0.\\n\\t\\t\\t\\t\\t\\tif (index2 == 0) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - 1;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tint inIndex2Range = 0;\\n\\t\\t\\t\\t\\t\\t\\t// Any digit before digit at index2 and larger than digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// has no effect on digit at index2. Imagine digit at index2 is 5 \\n\\t\\t\\t\\t\\t\\t\\t// and digits before that are 8 and 9. Plan is to subtract 1 from 5 and\\n\\t\\t\\t\\t\\t\\t\\t// pad w/ 9\\'s, which gives us 8949999... Knowing that pivot is at 4 and\\n\\t\\t\\t\\t\\t\\t\\t// 8 and 9 represent themselves, digit at index2 can potentially be any\\n\\t\\t\\t\\t\\t\\t\\t// value from 0 to 4, which are all less than 8 and 9. As a result 8 \\n\\t\\t\\t\\t\\t\\t\\t// and 9 have no effect on possible digits at index2. Now if we had 1 \\n\\t\\t\\t\\t\\t\\t\\t// and 2 instead of 8 and 9 then the possible values for digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// would be 0, 3, and 4 since 1 and 2 are already used before index2.\\n\\t\\t\\t\\t\\t\\t\\t// There\\'s a special case though when index2 points to the last digit,\\n\\t\\t\\t\\t\\t\\t\\t// in which we don\\'t subtract 1 and we don\\'t pad with 9\\'s.\\n\\t\\t\\t\\t\\t\\t\\t// After the first if statement we have a count of all exhausted possible\\n\\t\\t\\t\\t\\t\\t\\t// values to subtract from all possible values for digit at index2.\\n\\t\\t\\t\\t\\t\\t\\tfor (int j : hs) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ((index2 < nStrLength - 1 && j <= index2Digit - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|| (index2 == nStrLength - 1 && j <= index2Digit))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tinIndex2Range++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif (index2 == nStrLength - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit + 1 - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Working on 9\\'s like in 123,999,999. Possible values for each 9 is 10\\n\\t\\t\\t\\t\\t// for 0 to 9. Actual possible values however are possible values at each\\n\\t\\t\\t\\t\\t// index minus exhausted possible values at that index.\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnoRepeatCountLocal *= mutations - index2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Inner for is done. Adding whatever we\\'ve calculated to the total count.\\n\\t\\t\\t\\tif (noRepeatCountLocal > 0)\\n\\t\\t\\t\\t\\tnoRepeatCount += noRepeatCountLocal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Now we have count of permutations w/o repeated digits. Subtracting from n gives\\n\\t\\t// count of permutations <= n w/ at least one repeated digit.\\n\\t\\treturn n - noRepeatCount;\\n\\t}\\n\\n\\t// Helper function to calculate count of permutations w/o repeated digits. Input is the\\n\\t// number of 9\\'s to be accounted for. \\n\\tpublic int calcNumberOfNoRepeat(int numberOfDigits) {\\n\\t\\tint noRepeatCount = 0;\\n\\t\\tint mutations = 9;\\n\\t\\tfor (int i = 0; i < numberOfDigits; i++) {\\n\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\tnoRepeatCount = mutations;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tnoRepeatCount *= mutations--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn noRepeatCount;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n\\tint noRepeatCount = 0;\\n\\n\\tpublic int numDupDigitsAtMostN(int n) {\\n\\t\\tint nStrLength = String.valueOf(n).length();\\n\\t\\tint allNineLength = 0;\\n\\n\\t\\t// Edge cases out of the way.\\n\\t\\tif (n < 0 || nStrLength < 2)\\n\\t\\t\\treturn 0;\\n\\t\\t\\n\\t\\t// If n is all 9\\'s like 99999.\\n\\t\\telse if (Math.pow(10, nStrLength) - 1 == n)\\n\\t\\t\\tallNineLength = nStrLength;\\n\\t\\t\\n\\t\\t// If n is not all 9\\'s we calculate the largest number lower than n consisting of all 9\\'s.\\n\\t\\telse\\n\\t\\t\\tallNineLength = nStrLength - 1;\\n\\n\\t\\t// Calculating all 9\\'s e.g. for 10^6 we calculate for six 9\\'s which is 999,999.\\n\\t\\tfor (int numberOfDigits = 1; numberOfDigits <= allNineLength; numberOfDigits++) {\\n\\t\\t\\tnoRepeatCount += calcNumberOfNoRepeat(numberOfDigits);\\n\\t\\t}\\n\\n\\t\\t// Calculating from all 9\\'s to n e.g. for 10^6 we already calculated up to 999,999 and\\n\\t\\t// we just need to calculate for the rest.\\n\\t\\tif (Math.pow(10, nStrLength) - 1 > n) {\\n\\t\\t\\t\\n\\t\\t\\t// Count of all possible values 0 to 9.\\n\\t\\t\\tint mutations = 10;\\n\\t\\t\\t\\n\\t\\t\\t// HashSet is used only in part of the code. Worst case size() is the number of\\n\\t\\t\\t// mutations. contains() is called nStrLength times worst case in each iteration\\n\\t\\t\\t// w/ no more than nStrLength iterations.\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\t\\t\\t\\n\\t\\t\\t// We have two pointers each nStrLength hops to travel.\\n\\t\\t\\t// index1 is the pivot index and index2 keeps track of the current digit in n.\\n\\t\\t\\t// Based on index1 we decide what to do w/ digit at index2.\\n\\t\\t\\tfor (int index1 = 0; index1 < nStrLength; index1++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// In each iteration we count noRepeat numbers. At the end of the iteration\\n\\t\\t\\t\\t// we add local noRepeat count to the total noRepeat count.\\n\\t\\t\\t\\tint noRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Digits visited in each iteration have nothing to do w/ other iterations\\n\\t\\t\\t\\t// so we clear the HashSet before start of each inner iteration.\\n\\t\\t\\t\\ths.clear();\\n\\t\\t\\t\\tfor (int index2 = 0; index2 < nStrLength; index2++) {\\n\\t\\t\\t\\t\\t// Extracting digit at index2.\\n\\t\\t\\t\\t\\tint index2Digit = (int) (n / Math.pow(10, String.valueOf(n).length() - (index2 + 1)) % 10);\\n\\t\\t\\t\\t\\t// index1 is the pivot. Anything before index1 is already taken care of.\\n\\t\\t\\t\\t\\t// This means digits before index1 can only represent themselves, which\\n\\t\\t\\t\\t\\t// means if we see duplicate digits before index1 noRepeatCountLocal\\n\\t\\t\\t\\t\\t// for that entire iteration becomes zero. Remember we\\'re counting numbers\\n\\t\\t\\t\\t\\t// w/o repeated digits.\\n\\t\\t\\t\\t\\tif (index2 < index1) {\\n\\t\\t\\t\\t\\t\\t// This is where we use HashSet. If digit at index2 is already in the\\n\\t\\t\\t\\t\\t\\t// HashSet that means we\\'re dealing w/ a duplicate so noRepeatCountLocal\\n\\t\\t\\t\\t\\t\\t// is set to zero and we\\'re done w/ the iteration.\\n\\t\\t\\t\\t\\t\\tif (hs.contains(index2Digit)) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t\\t\\t// If digit at index2 is not part of the HashSet add it to the HashSet.\\n\\t\\t\\t\\t\\t\\t\\ths.add(index2Digit);\\n\\t\\t\\t\\t\\t// index2 is meeting the pivot digit. The idea is to subtract 1 from the pivot\\n\\t\\t\\t\\t\\t// digit and make a possible big jump depending on the position of index1.\\n\\t\\t\\t\\t\\t// Imagine we\\'re dealing w/ 15,564,465. The idea is to count for 14,xxx,xxx. \\n\\t\\t\\t\\t\\t// We\\'ll replace those x\\'s w/ 9\\'s later in the code. So basically we skip over\\n\\t\\t\\t\\t\\t// 10^7-1 to 1.5*10^7-1.\\n\\t\\t\\t\\t\\t} else if (index2 == index1) {\\n\\t\\t\\t\\t\\t\\t// Special case when both pointers are at index 0 meaning we\\'re dealing w/\\n\\t\\t\\t\\t\\t\\t// the first digit of n, which can\\'t be 0.\\n\\t\\t\\t\\t\\t\\tif (index2 == 0) {\\n\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - 1;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tint inIndex2Range = 0;\\n\\t\\t\\t\\t\\t\\t\\t// Any digit before digit at index2 and larger than digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// has no effect on digit at index2. Imagine digit at index2 is 5 \\n\\t\\t\\t\\t\\t\\t\\t// and digits before that are 8 and 9. Plan is to subtract 1 from 5 and\\n\\t\\t\\t\\t\\t\\t\\t// pad w/ 9\\'s, which gives us 8949999... Knowing that pivot is at 4 and\\n\\t\\t\\t\\t\\t\\t\\t// 8 and 9 represent themselves, digit at index2 can potentially be any\\n\\t\\t\\t\\t\\t\\t\\t// value from 0 to 4, which are all less than 8 and 9. As a result 8 \\n\\t\\t\\t\\t\\t\\t\\t// and 9 have no effect on possible digits at index2. Now if we had 1 \\n\\t\\t\\t\\t\\t\\t\\t// and 2 instead of 8 and 9 then the possible values for digit at index2\\n\\t\\t\\t\\t\\t\\t\\t// would be 0, 3, and 4 since 1 and 2 are already used before index2.\\n\\t\\t\\t\\t\\t\\t\\t// There\\'s a special case though when index2 points to the last digit,\\n\\t\\t\\t\\t\\t\\t\\t// in which we don\\'t subtract 1 and we don\\'t pad with 9\\'s.\\n\\t\\t\\t\\t\\t\\t\\t// After the first if statement we have a count of all exhausted possible\\n\\t\\t\\t\\t\\t\\t\\t// values to subtract from all possible values for digit at index2.\\n\\t\\t\\t\\t\\t\\t\\tfor (int j : hs) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ((index2 < nStrLength - 1 && j <= index2Digit - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t|| (index2 == nStrLength - 1 && j <= index2Digit))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tinIndex2Range++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif (index2 == nStrLength - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit + 1 - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tnoRepeatCountLocal = index2Digit - inIndex2Range;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Working on 9\\'s like in 123,999,999. Possible values for each 9 is 10\\n\\t\\t\\t\\t\\t// for 0 to 9. Actual possible values however are possible values at each\\n\\t\\t\\t\\t\\t// index minus exhausted possible values at that index.\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnoRepeatCountLocal *= mutations - index2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Inner for is done. Adding whatever we\\'ve calculated to the total count.\\n\\t\\t\\t\\tif (noRepeatCountLocal > 0)\\n\\t\\t\\t\\t\\tnoRepeatCount += noRepeatCountLocal;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Now we have count of permutations w/o repeated digits. Subtracting from n gives\\n\\t\\t// count of permutations <= n w/ at least one repeated digit.\\n\\t\\treturn n - noRepeatCount;\\n\\t}\\n\\n\\t// Helper function to calculate count of permutations w/o repeated digits. Input is the\\n\\t// number of 9\\'s to be accounted for. \\n\\tpublic int calcNumberOfNoRepeat(int numberOfDigits) {\\n\\t\\tint noRepeatCount = 0;\\n\\t\\tint mutations = 9;\\n\\t\\tfor (int i = 0; i < numberOfDigits; i++) {\\n\\t\\t\\tif (i == 0)\\n\\t\\t\\t\\tnoRepeatCount = mutations;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tnoRepeatCount *= mutations--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn noRepeatCount;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406381,
                "title": "python-o-1-time",
                "content": "The idea is to first count the numbers that have distinct digits. There are two cases. (1) Without the limitation of being at most `n`, there are `9*9*8*...(9-k+2)` such numbers with `k` digits. (2) With the limitation `n`, we can count such numbers in ranges. For example, for `n = 3579`, we count the numbers with distinct digits as follows:\\n[1, 10): 1 digit without limitation\\n[10, 100): 2 digits without limitation\\n[100, 1000): 3 digits without limitation\\n[1000, 3000): 4 digits of the form {1,2}???\\n[3000, 3500): 4 digits of the form 3{0,1,2,4}??\\n[3500, 3570): 4 digits of the form 35{0,1,2,4,6}?\\n[3570, 3579): 4 digits of the form 357{0,1,2,3,4,6,8}\\n{3579}: 4 digits of the form 3579\\n\\nSince the complexity is linear in the number of digits of `n`, it is O(1).\\n\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        print = lambda *args: None\\n        \\n        n2 = min(n, 10**10-1)\\n        m = len(str(n2))\\n        print(f\\'up to {n2} ({m} digits)\\')\\n        \\n        @lru_cache\\n        def num_perms(start:int, count:int) -> int:\\n            if count <= 0:\\n                return 1\\n            elif count == 1:\\n                return start\\n            return start * num_perms(start-1, count-1)\\n        \\n        no_repeats = 0\\n        for k in range(1, m):\\n            no_repeats += 9 * num_perms(9, k-1)\\n        print(f\\'up to length {m-1} no repeat: {no_repeats}\\')\\n            \\n        digits = []\\n        n3 = n2\\n        while n3 > 0:\\n            digits.append(n3 % 10)\\n            n3 //= 10\\n        digits = digits[::-1]\\n        nd = len(digits)\\n        print(digits, nd)\\n        fixed_digits = set()\\n        for i, d in enumerate(digits):\\n            below = range(1,d) if i==0 else range(d)\\n            cand = set(below) - fixed_digits\\n            nc = len(cand)\\n            if i == 0:\\n                no_repeats_i = nc * num_perms(9, nd-i-1)\\n            else:\\n                no_repeats_i = nc * num_perms(10-i-1, nd-i-1)\\n            print(f\\'no repeats fixing {digits[:i]}: {no_repeats_i}, cand={cand}\\')\\n            no_repeats += no_repeats_i\\n            \\n            if d in fixed_digits:\\n                break\\n            fixed_digits.add(d)\\n        if len(fixed_digits) == nd:\\n            no_repeats += 1\\n        print(f\\'total no repeat: {no_repeats}\\')\\n        return n - no_repeats\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        print = lambda *args: None\\n        \\n        n2 = min(n, 10**10-1)\\n        m = len(str(n2))\\n        print(f\\'up to {n2} ({m} digits)\\')\\n        \\n        @lru_cache\\n        def num_perms(start:int, count:int) -> int:\\n            if count <= 0:\\n                return 1\\n            elif count == 1:\\n                return start\\n            return start * num_perms(start-1, count-1)\\n        \\n        no_repeats = 0\\n        for k in range(1, m):\\n            no_repeats += 9 * num_perms(9, k-1)\\n        print(f\\'up to length {m-1} no repeat: {no_repeats}\\')\\n            \\n        digits = []\\n        n3 = n2\\n        while n3 > 0:\\n            digits.append(n3 % 10)\\n            n3 //= 10\\n        digits = digits[::-1]\\n        nd = len(digits)\\n        print(digits, nd)\\n        fixed_digits = set()\\n        for i, d in enumerate(digits):\\n            below = range(1,d) if i==0 else range(d)\\n            cand = set(below) - fixed_digits\\n            nc = len(cand)\\n            if i == 0:\\n                no_repeats_i = nc * num_perms(9, nd-i-1)\\n            else:\\n                no_repeats_i = nc * num_perms(10-i-1, nd-i-1)\\n            print(f\\'no repeats fixing {digits[:i]}: {no_repeats_i}, cand={cand}\\')\\n            no_repeats += no_repeats_i\\n            \\n            if d in fixed_digits:\\n                break\\n            fixed_digits.add(d)\\n        if len(fixed_digits) == nd:\\n            no_repeats += 1\\n        print(f\\'total no repeat: {no_repeats}\\')\\n        return n - no_repeats\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837204,
                "title": "java-dfs-memo-bit",
                "content": "```\\nclass Solution {\\n    int dp[][][];\\n    public int numDupDigitsAtMostN(int N) {\\n        //at least 1 repeat digit\\n        if(N<=10)return 0;\\n        String s=N+\"\";\\n        int cnt=0;\\n        int first=s.charAt(0)-\\'0\\';\\n        dp=new int[s.length()][1<<10][2];\\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        \\n        for(int i=1;i<=first;i++){\\n            if(i==first){\\n                cnt+=dfs(s,1,1<<i,1);\\n            }else{\\n                cnt+=dfs(s,1,1<<i,0);\\n            }\\n        }\\n        cnt+=dfs(s,1,0,0);//0 \\n        return N-cnt;\\n    }\\n    \\n    public int dfs(String s,int index,int bit,int state){\\n        if(index>=s.length())return 1;\\n        if(dp[index][bit][state]!=-1)return dp[index][bit][state];\\n        int digit=s.charAt(index)-\\'0\\';\\n        int res=0;\\n        if(state==1){//smae prefix\\n            for(int i=0;i<=digit;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==digit){\\n                    res+=dfs(s,index+1,(bit|(1<<i)),1);\\n                }else{\\n                    res+=dfs(s,index+1,(bit|(1<<i)),0);\\n                }\\n            }\\n            \\n        }else{\\n            for(int i=0;i<10;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==0&&bit==0&&index==s.length()-1)continue;\\n                if(i==0&&bit==0)res+=dfs(s,index+1,0,0);\\n                else res+=dfs(s,index+1,(bit|(1<<i)),0);\\n            }\\n            \\n        }\\n        dp[index][bit][state]=res;\\n        return res;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][][];\\n    public int numDupDigitsAtMostN(int N) {\\n        //at least 1 repeat digit\\n        if(N<=10)return 0;\\n        String s=N+\"\";\\n        int cnt=0;\\n        int first=s.charAt(0)-\\'0\\';\\n        dp=new int[s.length()][1<<10][2];\\n        \\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<dp[0].length;j++){\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        \\n        for(int i=1;i<=first;i++){\\n            if(i==first){\\n                cnt+=dfs(s,1,1<<i,1);\\n            }else{\\n                cnt+=dfs(s,1,1<<i,0);\\n            }\\n        }\\n        cnt+=dfs(s,1,0,0);//0 \\n        return N-cnt;\\n    }\\n    \\n    public int dfs(String s,int index,int bit,int state){\\n        if(index>=s.length())return 1;\\n        if(dp[index][bit][state]!=-1)return dp[index][bit][state];\\n        int digit=s.charAt(index)-\\'0\\';\\n        int res=0;\\n        if(state==1){//smae prefix\\n            for(int i=0;i<=digit;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==digit){\\n                    res+=dfs(s,index+1,(bit|(1<<i)),1);\\n                }else{\\n                    res+=dfs(s,index+1,(bit|(1<<i)),0);\\n                }\\n            }\\n            \\n        }else{\\n            for(int i=0;i<10;i++){\\n                if((bit&(1<<i))!=0)continue;\\n                if(i==0&&bit==0&&index==s.length()-1)continue;\\n                if(i==0&&bit==0)res+=dfs(s,index+1,0,0);\\n                else res+=dfs(s,index+1,(bit|(1<<i)),0);\\n            }\\n            \\n        }\\n        dp[index][bit][state]=res;\\n        return res;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488526,
                "title": "simple-efficient-c-digit-dp-solution-with-comments",
                "content": "**Top Down multi-dimensional DP approach**\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[10][2][2][2][1<<10];\\n\\n    ll ff(int pos, bool tight, bool st, bool cnt, int mask) {\\n        // If index reaches the length of the string return whether\\n        // any repetition till now has been found or not?\\n        if (pos == s.size()) return cnt ? 1 : 0;\\n        \\n        // Look in the DP table\\n        if (dp[pos][tight][st][cnt][mask] != -1)\\n            return dp[pos][tight][st][cnt][mask];\\n\\n        ll res = 0;\\n        ll en = tight ? s[pos]-\\'0\\':9;\\n\\n        if (!st) {\\n            // Place 0s, go to the rightmost\\n            res = ff(pos+1, tight&s[pos]==\\'0\\', st, cnt, mask);\\n            for (ll i=1; i<=en; i++) {\\n                // Start the number, st = true\\n                res += ff(pos+1, tight&(i==en), st|(i > 0), cnt, mask|1<<i);\\n            }\\n        }else {\\n            // Number has started\\n            for (ll i=0; i<=en; i++) {\\n                // If number is found repeated, check using bitmask (mask & (1 << i))\\n                // Make the cnt = true, i.e. cnt | mask&(1<<i)\\n                res += ff(pos+1, tight&(i==en), st, cnt|(mask&(1<<i)), mask|1<<i);\\n            }\\n        }\\n\\n        return dp[pos][tight][st][cnt][mask] = res;\\n    }\\n\\n    int numDupDigitsAtMostN(int N) {\\n        s = to_string(N);\\n        memset(dp, -1, sizeof dp);\\n        return ff(0, true, false, false, 0);\\n    }\\n};\\n```\\n\\nRead more about **Digit DP:**\\nhttps://codeforces.com/blog/entry/53960",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[10][2][2][2][1<<10];\\n\\n    ll ff(int pos, bool tight, bool st, bool cnt, int mask) {\\n        // If index reaches the length of the string return whether\\n        // any repetition till now has been found or not?\\n        if (pos == s.size()) return cnt ? 1 : 0;\\n        \\n        // Look in the DP table\\n        if (dp[pos][tight][st][cnt][mask] != -1)\\n            return dp[pos][tight][st][cnt][mask];\\n\\n        ll res = 0;\\n        ll en = tight ? s[pos]-\\'0\\':9;\\n\\n        if (!st) {\\n            // Place 0s, go to the rightmost\\n            res = ff(pos+1, tight&s[pos]==\\'0\\', st, cnt, mask);\\n            for (ll i=1; i<=en; i++) {\\n                // Start the number, st = true\\n                res += ff(pos+1, tight&(i==en), st|(i > 0), cnt, mask|1<<i);\\n            }\\n        }else {\\n            // Number has started\\n            for (ll i=0; i<=en; i++) {\\n                // If number is found repeated, check using bitmask (mask & (1 << i))\\n                // Make the cnt = true, i.e. cnt | mask&(1<<i)\\n                res += ff(pos+1, tight&(i==en), st, cnt|(mask&(1<<i)), mask|1<<i);\\n            }\\n        }\\n\\n        return dp[pos][tight][st][cnt][mask] = res;\\n    }\\n\\n    int numDupDigitsAtMostN(int N) {\\n        s = to_string(N);\\n        memset(dp, -1, sizeof dp);\\n        return ff(0, true, false, false, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393486,
                "title": "constant-time-combinatorial-counting",
                "content": "(A similar problem: https://leetcode.com/problems/ones-and-zeroes/)\\n\\nIf you studied probability, it is well known that considering the complement problem: \\'the count of number WITHOUT repeating digit that\\'s less than N\\' is easier to solve. And then we get the answer by subtracting this cnt from N.\\n\\nSo numbers M without repeating digits that\\'s less than N has three types:\\n1. M has the same prefix as N.\\n2. M has the same length but the leading digit is non-zero and strictly less than leaading digit as N.\\n3. M has strictly less digits than N.\\n\\nWe can count type (1)-(2) together, and (3) later.\\ntype 1 and 2 requires us to remember the number of digit that\\'s not used in the prefix but strictly less than the current digit. Let\\'s see an example.\\nSuppose N = 453232\\n\\ntype (1) are of the form 3xxxxx, 2xxxxx, 1xxxxx, the leading digit has 4-1 = 3 choices. Then the xxx part we can use whatever number, but not the choice of our leading digit, so that\\'s 9\\\\*8\\\\*7\\\\*6\\\\*5, which we call perm(9,5).\\ntype (2) are of the form 4yxxxx, 45yxxx, 453yxx, 4532yx, but we can\\'t consider 45323x(?) because we see a repeating digit. so starting from the MSD we\\'ll just count up to the first time we see a repeating digit in N.  Notices that I put \\'y\\' instead of \\'x\\' for the first digit after the prefix. For 4yxxxx, since N = 453232, we can\\'t use y to be greater than 5. so we use 3, 2, or 1, or 0. Notice that we can\\'t use 4, because 4 has appeaered in the prefix. Anyhow, we use an array to store the number of digits available at i-th index that\\'s strictly less than the ith-indes of N and hasn\\'t been used in the prefix so far.\\n\\nFor type (3), we always have 9 choice for MSD, 9 choice for 2nd digit, 8 choice for 3rd digit. Using N=543232 as same exmaple, type (3) would cover 1000-9999, 100-999, 10-99, 0-9. Simple counting problem.\\n\\nNow subtract type (1) +(2)+(3) from N, that\\'s the answer we have. \\n\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int ans = 0;\\n\\n        String num = Integer.toString(N);\\n        //Convert N to an array of digits for easy proccessing. A[0] stores the most sigifinicant digit.\\n        int[] A = new int[num.length()];\\n        for(int i = 0;i<A.length; i++){\\n            A[i] = num.charAt(i)-\\'0\\';\\n        }\\n        //cnt array stores the number of digit strictly smaller than A[i] and hasn\\'t been used in the prefix. \\n        int[] cnt = new int[A.length];\\n        boolean[] used = new boolean[10];\\n        used[A[0]] = true;\\n        //we require the most significant digit to be non-zero.\\n        cnt[0] = A[0]-1;\\n        //rpt: The first repeating idx, after this idx, no number with the same prefix as N and is smaller than N has no repeating digit. So stop counting.\\n        int rpt = A.length;\\n        \\n        for(int i=1;i<A.length; i++){\\n            for(int j = 0;j<A[i];j++){\\n                if(!used[j]) cnt[i]++;\\n            }\\n            if(used[A[i]]){\\n                rpt=i;\\n                break;\\n            }\\n            used[A[i]] = true;\\n        }\\n        \\n        //count from most significant digit, the number of no repeating number with same prefix and has same length with N. \\n        \\n        for(int i = 0;i<rpt; i++){\\n            int c = cnt[i];\\n            c*=perm(9-i,A.length-i-1);\\n            ans+=c;\\n        }\\n        //if there\\'s repeating idx, count that in.\\n        if(rpt!=A.length) ans+= cnt[rpt]*perm(9-rpt, A.length-rpt-1);\\n        \\n        //Now count the numbers which has length strictly less than N.\\n        for(int i = 1;i<A.length;i++){\\n            ans+= 9*perm(9,A.length-i-1);\\n        }\\n        if(rpt==A.length) ans++;\\n        return N-ans;\\n    }\\n    \\n    public int perm(int n, int k){\\n        int a= 1;\\n        for(int i = 0;i<k;i++){\\n            a*=(n-i);\\n        }\\n        return a;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int ans = 0;\\n\\n        String num = Integer.toString(N);\\n        //Convert N to an array of digits for easy proccessing. A[0] stores the most sigifinicant digit.\\n        int[] A = new int[num.length()];\\n        for(int i = 0;i<A.length; i++){\\n            A[i] = num.charAt(i)-\\'0\\';\\n        }\\n        //cnt array stores the number of digit strictly smaller than A[i] and hasn\\'t been used in the prefix. \\n        int[] cnt = new int[A.length];\\n        boolean[] used = new boolean[10];\\n        used[A[0]] = true;\\n        //we require the most significant digit to be non-zero.\\n        cnt[0] = A[0]-1;\\n        //rpt: The first repeating idx, after this idx, no number with the same prefix as N and is smaller than N has no repeating digit. So stop counting.\\n        int rpt = A.length;\\n        \\n        for(int i=1;i<A.length; i++){\\n            for(int j = 0;j<A[i];j++){\\n                if(!used[j]) cnt[i]++;\\n            }\\n            if(used[A[i]]){\\n                rpt=i;\\n                break;\\n            }\\n            used[A[i]] = true;\\n        }\\n        \\n        //count from most significant digit, the number of no repeating number with same prefix and has same length with N. \\n        \\n        for(int i = 0;i<rpt; i++){\\n            int c = cnt[i];\\n            c*=perm(9-i,A.length-i-1);\\n            ans+=c;\\n        }\\n        //if there\\'s repeating idx, count that in.\\n        if(rpt!=A.length) ans+= cnt[rpt]*perm(9-rpt, A.length-rpt-1);\\n        \\n        //Now count the numbers which has length strictly less than N.\\n        for(int i = 1;i<A.length;i++){\\n            ans+= 9*perm(9,A.length-i-1);\\n        }\\n        if(rpt==A.length) ans++;\\n        return N-ans;\\n    }\\n    \\n    public int perm(int n, int k){\\n        int a= 1;\\n        for(int i = 0;i<k;i++){\\n            a*=(n-i);\\n        }\\n        return a;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386806,
                "title": "java-digital-dp",
                "content": "```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int pos = 0, temp = N;\\n        while (N > 0) {\\n            digits[pos++] = N % 10;\\n            N /= 10;\\n        }\\n        return temp - dfs(digits, pos - 1, 0, new int[10][1 << 10], true) + 1;\\n    }\\n    \\n    public int dfs(int[] digits, int pos, int pre, int[][] dp, boolean limit) {\\n        if (pos == -1) return 1;\\n        if (!limit && dp[pos][pre] != 0) return dp[pos][pre];\\n        int up = limit ? digits[pos] : 9;\\n        int ans = 0;\\n        for (int i = 0; i <= up; i++) {\\n            if ((pre & (1 << i)) != 0 && (pre != 0 || i != 0)) continue;\\n            if (pre == 0 && i == 0) {\\n                ans += dfs(digits, pos - 1, pre, dp, limit && i == up);\\n            } else {\\n                ans += dfs(digits, pos - 1, pre ^ (1 << i), dp, limit && i == up);\\n            }\\n        }\\n        if (!limit) dp[pos][pre] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int[] digits = new int[10];\\n        int pos = 0, temp = N;\\n        while (N > 0) {\\n            digits[pos++] = N % 10;\\n            N /= 10;\\n        }\\n        return temp - dfs(digits, pos - 1, 0, new int[10][1 << 10], true) + 1;\\n    }\\n    \\n    public int dfs(int[] digits, int pos, int pre, int[][] dp, boolean limit) {\\n        if (pos == -1) return 1;\\n        if (!limit && dp[pos][pre] != 0) return dp[pos][pre];\\n        int up = limit ? digits[pos] : 9;\\n        int ans = 0;\\n        for (int i = 0; i <= up; i++) {\\n            if ((pre & (1 << i)) != 0 && (pre != 0 || i != 0)) continue;\\n            if (pre == 0 && i == 0) {\\n                ans += dfs(digits, pos - 1, pre, dp, limit && i == up);\\n            } else {\\n                ans += dfs(digits, pos - 1, pre ^ (1 << i), dp, limit && i == up);\\n            }\\n        }\\n        if (!limit) dp[pos][pre] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314745,
                "title": "c-divide-and-conquer",
                "content": "I guess no one want to read this long solution. So I am lazy to add comment\\n```\\nclass Solution {\\npublic:\\n   int numDupDigitsAtMostN(int N) {\\n      vector<int> v = toVec(N);\\n      int n1 = numNoRepeat1(v, {}, 0);\\n      int n2 = numNoRepeat2(v.size() - 1);\\n      cout << N << \" \" << n1 << \" \" << n2 << endl;\\n      return N - n1 - n2;\\n   }\\n\\n   // from 10^pow to N \\n   int numNoRepeat1(vector<int> & v, set<int> used, int i) {\\n      if (i == v.size()) return 1;\\n      int res = 0;\\n      int nCanbeUse = v[i];  // 0,1,2,3,4,...v[0]-1\\n      if (i == 0) nCanbeUse--; //leading digit cannot be 0\\n      for (auto x : used) if (x < v[i]) nCanbeUse--;\\n      res += nCanbeUse * permutation(10 - used.size() - 1, v.size() - i - 1);\\n\\n      //repeated, early return\\n      if(used.count(v[i])) return res;\\n\\n      used.insert(v[i]);\\n      res += numNoRepeat1(v, used, i + 1);\\n      return res;\\n   }\\n\\n   int permutation(int num, int k) {\\n      int prod = 1;\\n      while (k--) prod *= num--;\\n      return prod;\\n   }\\n\\n   // from 0 to 10^pow10 \\n   int numNoRepeat2(int pow10) {\\n      int sum = 0;\\n      while (pow10) {\\n         sum += 9 * permutation(9, pow10 - 1);\\n         pow10--;\\n      }\\n      return sum;\\n   }\\n\\n   vector<int> toVec(int N) {\\n      auto s = to_string(N);\\n      vector<int> v;\\n      for (auto c : s) v.push_back(c - \\'0\\');\\n      return v;\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int numDupDigitsAtMostN(int N) {\\n      vector<int> v = toVec(N);\\n      int n1 = numNoRepeat1(v, {}",
                "codeTag": "Java"
            },
            {
                "id": 259737,
                "title": "c-standard-depth-first-search-with-back-tracking",
                "content": "March 21, 2019\\nIt is the hard level algorithm. I like to share the standard depth first search using back tracking technique to solve the problem. What I did is to study weekly contest 128 ranking 13 player\\'s code, and then I wrote one based on my understanding. \\n\\nHere are steps to follow:\\n1. Brute force solution, from rightmost digit, enumerate all the possible digit; \\n2. Go to next digit by moving to left side, skip those used digits. Use one array with size 10 to record used digit from 0 to 9. \\n3. Combine step 1 and step2, the brute force solution time complexity O(10!)\\n4. Do not forget to back tracking\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_13\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            NumDupDigitsAtMostN(872427638);\\n            Debug.Assert(value == 10); \\n        }\\n\\n        public static int    value = 0; \\n        public static bool[] taken = new bool[10];\\n\\n        /// <summary>\\n        /// March 20, 2019\\n        /// study code based on ranking No. 13, VladaMG98\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking/\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {            \\n            return N - getAllDifferent(N) + 1; \\n        }\\n\\n        private static int getAllDifferent(int N)\\n        {\\n            value = 0;\\n            for (int i = 0; i < taken.Length; i++)\\n            {\\n                taken[i] = false; \\n            }\\n\\n            recursive(0, 0, N);\\n            return value; \\n        }\\n\\n        /// <summary>\\n        /// Brute force solution\\n        /// Make sure that all numbers in the integer are distinct, less than and equal N.\\n        /// Problem statement:\\n        /// Given a positive integer N, return the number of positive integers less than or \\n        /// equal to N that have at least 1 repeated digit.\\n        /// Start from rightmost digit. \\n        /// </summary>\\n        /// <param name=\"number\"></param>\\n        /// <param name=\"digit\"></param>\\n        /// <param name=\"N\"></param>\\n        private static void recursive(double number, int digit, int N)\\n        {\\n            if (number > N)\\n            {\\n                return; \\n            }\\n\\n            // current number with value number is the one. \\n            value += 1;\\n\\n            // Fix timeout bug\\n            if (number * 10 > N)\\n            {\\n                return;\\n            }\\n\\n            for (int x = 0; x < 10; x++)\\n            {\\n                if (taken[x])\\n                {\\n                    continue; \\n                }\\n\\n                // make sure that the number is positive number\\n                var numberIsZero = digit == 0 && x == 0;\\n                if (numberIsZero)\\n                {\\n                    continue;\\n                }\\n\\n                taken[x] = true;\\n                recursive(number * 10 + x, digit + 1, N);\\n                \\n                // backtracking\\n                taken[x] = false; \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1015_number_with_repeated_digits_13\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            NumDupDigitsAtMostN(872427638);\\n            Debug.Assert(value == 10); \\n        }\\n\\n        public static int    value = 0; \\n        public static bool[] taken = new bool[10];\\n\\n        /// <summary>\\n        /// March 20, 2019\\n        /// study code based on ranking No. 13, VladaMG98\\n        /// https://leetcode.com/contest/weekly-contest-128/ranking/\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n        public static int NumDupDigitsAtMostN(int N)\\n        {            \\n            return N - getAllDifferent(N) + 1; \\n        }\\n\\n        private static int getAllDifferent(int N)\\n        {\\n            value = 0;\\n            for (int i = 0; i < taken.Length; i++)\\n            {\\n                taken[i] = false; \\n            }\\n\\n            recursive(0, 0, N);\\n            return value; \\n        }\\n\\n        /// <summary>\\n        /// Brute force solution\\n        /// Make sure that all numbers in the integer are distinct, less than and equal N.\\n        /// Problem statement:\\n        /// Given a positive integer N, return the number of positive integers less than or \\n        /// equal to N that have at least 1 repeated digit.\\n        /// Start from rightmost digit. \\n        /// </summary>\\n        /// <param name=\"number\"></param>\\n        /// <param name=\"digit\"></param>\\n        /// <param name=\"N\"></param>\\n        private static void recursive(double number, int digit, int N)\\n        {\\n            if (number > N)\\n            {\\n                return; \\n            }\\n\\n            // current number with value number is the one. \\n            value += 1;\\n\\n            // Fix timeout bug\\n            if (number * 10 > N)\\n            {\\n                return;\\n            }\\n\\n            for (int x = 0; x < 10; x++)\\n            {\\n                if (taken[x])\\n                {\\n                    continue; \\n                }\\n\\n                // make sure that the number is positive number\\n                var numberIsZero = digit == 0 && x == 0;\\n                if (numberIsZero)\\n                {\\n                    continue;\\n                }\\n\\n                taken[x] = true;\\n                recursive(number * 10 + x, digit + 1, N);\\n                \\n                // backtracking\\n                taken[x] = false; \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257561,
                "title": "c-method-using-permutation",
                "content": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        //\\u65E2\\u7136\\u8BA1\\u7B97\\u7684\\u662F\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\u6211\\u4EEC\\u53EF\\u4EE5\\u8BA1\\u7B97\\u4E0D\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\uFF0C\\u8FD9\\u5C31\\u662F\\u4E2A\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u95EE\\u9898\\n        //\\u5BF9\\u4E8E\\u8FD9\\u4E2A\\u95EE\\u9898\\u6211\\u4EEC\\u8981\\u5148\\u5199\\u51FA\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u7B97\\u6CD5\\u3002\\n        // second we must define our method upper  boader.\\n        // such that 8999-->(9,0,0,0) \\n        // \\n        int retv  = 0;\\n        vector<int> remain;\\n        for(int n = N+1;n>0;n/=10)\\n        {\\n            remain.insert(remain.begin(),n%10);\\n        }\\n        for(int i =1;i<remain.size();i++)\\n        {\\n            retv+=9*A(9,i-1);\\n        }\\n        // condition ,if this \\u548C\\u524D\\u9762\\u7684\\u4E00\\u6837\\u5219\\u8DF3\\u8FC7\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u80FD\\u6709\\u91CD\\u590D\\u7684\\uFF0C\\u5982\\u679C\\u5B58\\u5728\\u4E24\\u4E2A\\u4E0A\\u754C\\u4E00\\u6837beak \\u6389\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u53EF\\u80FD\\u5728\\u4ECE\\u8FD9\\u91CC\\u51FA\\u73B0\\u4E24\\u4E2A\\u5B8C\\u5168\\u4E0D\\u4E00\\u6837\\u7684\\n        unordered_set<int> sets;\\n        for(int i = 0;i<remain.size();i++)\\n        {\\n            for(int j = i==0?1:0;j<remain[i];j++)\\n            {\\n                if(!sets.count(j))\\n                {\\n                    retv += A(9-i,remain.size()-1-i);\\n                }\\n            }\\n            if(sets.count(remain[i]))\\n                break;\\n            else\\n            {\\n                sets.insert(remain[i]);\\n            }\\n        }\\n        return N-retv;\\n        \\n    }\\n    int A(int n,int m)\\n    {\\n        //means C{n,m}\\n        //How can we deal with this problem, Can you give me a method to do ?\\n        //in this time, wo di it, such that.\\n        //A(n,m) = n*n-1*n-2*..n-m+1 = (n-m+1)*A(n,m-1)\\n        return m == 0?1:(n-m+1)*A(n,m-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __ =[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return nullptr;\\n}();\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        //\\u65E2\\u7136\\u8BA1\\u7B97\\u7684\\u662F\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\u6211\\u4EEC\\u53EF\\u4EE5\\u8BA1\\u7B97\\u4E0D\\u91CD\\u590D\\u7684\\u4E2A\\u6570\\uFF0C\\u8FD9\\u5C31\\u662F\\u4E2A\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u95EE\\u9898\\n        //\\u5BF9\\u4E8E\\u8FD9\\u4E2A\\u95EE\\u9898\\u6211\\u4EEC\\u8981\\u5148\\u5199\\u51FA\\u6392\\u5217\\u7EC4\\u5408\\u7684\\u7B97\\u6CD5\\u3002\\n        // second we must define our method upper  boader.\\n        // such that 8999-->(9,0,0,0) \\n        // \\n        int retv  = 0;\\n        vector<int> remain;\\n        for(int n = N+1;n>0;n/=10)\\n        {\\n            remain.insert(remain.begin(),n%10);\\n        }\\n        for(int i =1;i<remain.size();i++)\\n        {\\n            retv+=9*A(9,i-1);\\n        }\\n        // condition ,if this \\u548C\\u524D\\u9762\\u7684\\u4E00\\u6837\\u5219\\u8DF3\\u8FC7\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u80FD\\u6709\\u91CD\\u590D\\u7684\\uFF0C\\u5982\\u679C\\u5B58\\u5728\\u4E24\\u4E2A\\u4E0A\\u754C\\u4E00\\u6837beak \\u6389\\uFF0C\\u56E0\\u4E3A\\u4E0D\\u53EF\\u80FD\\u5728\\u4ECE\\u8FD9\\u91CC\\u51FA\\u73B0\\u4E24\\u4E2A\\u5B8C\\u5168\\u4E0D\\u4E00\\u6837\\u7684\\n        unordered_set<int> sets;\\n        for(int i = 0;i<remain.size();i++)\\n        {\\n            for(int j = i==0?1:0;j<remain[i];j++)\\n            {\\n                if(!sets.count(j))\\n                {\\n                    retv += A(9-i,remain.size()-1-i);\\n                }\\n            }\\n            if(sets.count(remain[i]))\\n                break;\\n            else\\n            {\\n                sets.insert(remain[i]);\\n            }\\n        }\\n        return N-retv;\\n        \\n    }\\n    int A(int n,int m)\\n    {\\n        //means C{n,m}\\n        //How can we deal with this problem, Can you give me a method to do ?\\n        //in this time, wo di it, such that.\\n        //A(n,m) = n*n-1*n-2*..n-m+1 = (n-m+1)*A(n,m-1)\\n        return m == 0?1:(n-m+1)*A(n,m-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257004,
                "title": "math-o-logn",
                "content": "Count the number without repeated digit.\\nwe start with the highest bit of N, if N is 1000,  the highest bit must less than 1, so we start with 0,\\nthe biggest number without repeated dight is 999, the leghth is 3.\\nthe highest bit can be 1~9 ( we count numbers start with 0 later) ,  the second bit can be 0~9, excluding that is the same with the previous bits... and so on.\\nthe total number is 9*(10-1)*(10-2)+count(2,9) ( if the second bit is 0, we consider it as a new number whose lenght is 2)\\n\\n```\\npublic int numDupDigitsAtMostN(int N) {\\n        int n=N;\\n        int count=0;\\n        int[] arr=new int[11];\\n        while (n>0) {\\n            arr[++count]=n%10;\\n            n/=10;\\n        }\\n        int res=count(count, arr[count]-1);\\n        Set<Integer> set=new HashSet<>(10);\\n        set.add(arr[count]);\\n        for (int i = count-1; i >0; i--) {\\n            int maxcur=arr[i], rems=0;\\n            while (maxcur>=0 && set.contains(maxcur))\\n                maxcur--;\\n            if(maxcur<0) break;\\n            set.add(maxcur);\\n            int bit=maxcur-1;\\n            while (bit>=0){\\n                if(!set.contains(bit)) rems++;\\n                bit--;\\n            }\\n            if(maxcur<arr[i]) rems++;\\n            int cnt=rems;\\n            for (int j = 1; j < i; j++) {\\n                cnt*=(10-(count-i)-j);\\n            }\\n            res+=cnt;\\n            if(maxcur<arr[i]) {\\n                set.remove(maxcur);\\n                break;\\n            }\\n            arr[i]=maxcur;\\n        }\\n        if(set.size()==count) res+=1;\\n        return N-res;\\n    }\\n\\t//count the number  without repeated digit and the highest less than num, the lenght is n\\n    public int count(int n, int num){\\n        if(n<1) return 0;\\n        if(n==1) return num;\\n        int count=0, N=n;\\n\\t\\t//the highest bit isn\\'t 0\\n        if(num>0) {\\n            count=num;\\n            while (--n > 0) {\\n                count *= (10 - n);\\n            }\\n        }\\n\\t\\t//if the highest bit is 0\\n        count+=count(N-1, 9);\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numDupDigitsAtMostN(int N) {\\n        int n=N;\\n        int count=0;\\n        int[] arr=new int[11];\\n        while (n>0) {\\n            arr[++count]=n%10;\\n            n/=10;\\n        }\\n        int res=count(count, arr[count]-1);\\n        Set<Integer> set=new HashSet<>(10);\\n        set.add(arr[count]);\\n        for (int i = count-1; i >0; i--) {\\n            int maxcur=arr[i], rems=0;\\n            while (maxcur>=0 && set.contains(maxcur))\\n                maxcur--;\\n            if(maxcur<0) break;\\n            set.add(maxcur);\\n            int bit=maxcur-1;\\n            while (bit>=0){\\n                if(!set.contains(bit)) rems++;\\n                bit--;\\n            }\\n            if(maxcur<arr[i]) rems++;\\n            int cnt=rems;\\n            for (int j = 1; j < i; j++) {\\n                cnt*=(10-(count-i)-j);\\n            }\\n            res+=cnt;\\n            if(maxcur<arr[i]) {\\n                set.remove(maxcur);\\n                break;\\n            }\\n            arr[i]=maxcur;\\n        }\\n        if(set.size()==count) res+=1;\\n        return N-res;\\n    }\\n\\t//count the number  without repeated digit and the highest less than num, the lenght is n\\n    public int count(int n, int num){\\n        if(n<1) return 0;\\n        if(n==1) return num;\\n        int count=0, N=n;\\n\\t\\t//the highest bit isn\\'t 0\\n        if(num>0) {\\n            count=num;\\n            while (--n > 0) {\\n                count *= (10 - n);\\n            }\\n        }\\n\\t\\t//if the highest bit is 0\\n        count+=count(N-1, 9);\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256894,
                "title": "golang-dp",
                "content": "\\ncount(0, dn...d1) = count(0, 9...9) + count(10...0, dn...d1)\\ncount(10...0, dn...d1) = count(10...0, dn0...0-1) + count(dn0...0, dn...d1)\\n\\ndefine dp(s, n), the count for numbers who has n-digits not determined yet and s is its 0-9 indicator for its known digits. (do not care whether its known digits are all 0s)\\ndp(s, n) = sum(s&(1<<i)? 10...0: dp(s|1<<i, n-1) for i in 0...9 )\\n\\nhence:\\ncount(0, 9...9) = sum(countd(n) for n in {1..dn}) and countd(n) = sum(dfs(1<<i, n-1) for i in {1..9})\\ncount(dn0...0, dn...d1) = sum(count(dni0...0, dn(i+1)0...0-1)  for i in {0...d(n-1)-1})\\nkeep track of the 0-9 mask for the processed digits, and if 0-9 mask already 1, then count all the possibles , otherwise solve sub problem.\\n\\nMaybe this is way too unnecessarily complex...... sadly this is how my brain wired....\\n```\\nvar dp map[int]int\\nvar cs = []int{1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000}\\n/* s is a 10-bit map indicating whether 0-9 digits already exist\\ndp[s][n] yield a count for numbers which have at least  n digits number, and some prefix map s\\n*/\\nfunc dfs(s, n int) int {\\n    if n<=0 { return 0; }\\n    k := (s<<4)|n;\\n    if v, ok := dp[k]; ok {\\n        return v\\n    }\\n    c := 0\\n    var i uint\\n    for i=0; i<10; i++ {\\n        if (s&(1<<i)) != 0 {\\n            c += cs[n-1]\\n        } else {\\n            c += dfs(s|(1<<i), n-1)\\n        }\\n    }\\n    dp[k] = c\\n    return c\\n}\\n\\n/* count n digit numbers, between 10...0 to 99...9 */\\nfunc count(n int) int {\\n    if n<=1 { return 0 }\\n    c := 0\\n    var i uint\\n    for i=1; i<10; i++ {\\n        c += dfs(1<<i, n-1)\\n    }\\n    return c\\n}\\n\\nfunc numDupDigitsAtMostN(N int) int {\\n    if dp==nil { dp = make(map[int]int) }\\n    rem := make([]int, 10)\\n    for i:=0; i<10; i++ { rem[i] = N % cs[i] }\\n    d, ds := 0, make([]uint, 16)\\n    for {\\n        ds[d] = uint(N % 10)\\n        d += 1\\n        N /= 10\\n        if N==0 { break }\\n    }\\n    c, s := 0, 0\\n    /* accumulate counts from 0 to 9...9, where 9...9 < N */\\n    for i:=1; i<d; i++ { c += count(i) }\\n    /* from higher digit down, accumulate d(i+1)0..0 to d(i+1)d(i)0..0-1 */\\n    for i:=d-1; i>=0; i-- {\\n        var j uint\\n        if i==d-1 {j=1}\\n        for ; j<ds[i]; j++ {\\n            if ((s&(1<<j)) != 0) {\\n                c += cs[i]\\n            } else {\\n                c += dfs(s|(1<<j), i);\\n            }\\n        }\\n        if (s&(1<<ds[i])) != 0 {\\n            /* all the remaining numbers should be counted */\\n            c += (rem[i]+1)\\n            break\\n        }\\n        s |= (1<<ds[i])\\n    }\\n    return c\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar dp map[int]int\\nvar cs = []int{1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000}\\n/* s is a 10-bit map indicating whether 0-9 digits already exist\\ndp[s][n] yield a count for numbers which have at least  n digits number, and some prefix map s\\n*/\\nfunc dfs(s, n int) int {\\n    if n<=0 { return 0; }\\n    k := (s<<4)|n;\\n    if v, ok := dp[k]; ok {\\n        return v\\n    }\\n    c := 0\\n    var i uint\\n    for i=0; i<10; i++ {\\n        if (s&(1<<i)) != 0 {\\n            c += cs[n-1]\\n        } else {\\n            c += dfs(s|(1<<i), n-1)\\n        }\\n    }\\n    dp[k] = c\\n    return c\\n}\\n\\n/* count n digit numbers, between 10...0 to 99...9 */\\nfunc count(n int) int {\\n    if n<=1 { return 0 }\\n    c := 0\\n    var i uint\\n    for i=1; i<10; i++ {\\n        c += dfs(1<<i, n-1)\\n    }\\n    return c\\n}\\n\\nfunc numDupDigitsAtMostN(N int) int {\\n    if dp==nil { dp = make(map[int]int) }\\n    rem := make([]int, 10)\\n    for i:=0; i<10; i++ { rem[i] = N % cs[i] }\\n    d, ds := 0, make([]uint, 16)\\n    for {\\n        ds[d] = uint(N % 10)\\n        d += 1\\n        N /= 10\\n        if N==0 { break }\\n    }\\n    c, s := 0, 0\\n    /* accumulate counts from 0 to 9...9, where 9...9 < N */\\n    for i:=1; i<d; i++ { c += count(i) }\\n    /* from higher digit down, accumulate d(i+1)0..0 to d(i+1)d(i)0..0-1 */\\n    for i:=d-1; i>=0; i-- {\\n        var j uint\\n        if i==d-1 {j=1}\\n        for ; j<ds[i]; j++ {\\n            if ((s&(1<<j)) != 0) {\\n                c += cs[i]\\n            } else {\\n                c += dfs(s|(1<<j), i);\\n            }\\n        }\\n        if (s&(1<<ds[i])) != 0 {\\n            /* all the remaining numbers should be counted */\\n            c += (rem[i]+1)\\n            break\\n        }\\n        s |= (1<<ds[i])\\n    }\\n    return c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256880,
                "title": "digit-dp-soln",
                "content": "class Solution {\\npublic:\\n    string num;\\n    int l ;\\n    int dp[11][2][2][1030];\\n    \\n    int d(int N)\\n    {\\n        int c = 0;\\n        while(N)\\n        {\\n            c++;\\n            N /= 10;\\n        }\\n        return c;\\n    }\\n    \\n    int solve(int bit, int tight, int nonz, int mask)\\n    {\\n        if(dp[bit][tight][nonz][mask] != -1)\\n            return dp[bit][tight][nonz][mask];\\n        \\n        if(bit == l)\\n        {\\n            if(nonz)\\n                return dp[bit][tight][nonz][mask] = 1;\\n            else\\n                return dp[bit][tight][nonz][mask] = 0;\\n        }\\n        \\n        int v = num[bit] - \\'0\\';\\n        //cout << v << \\'\\\\n\\';\\n        int cans = 0;\\n        if(tight)\\n        {\\n            for(int i = 0; i <= v; i++)\\n            {\\n                int new_mask = mask;\\n                int new_tight = 0;\\n                int c_bit = ((mask >> i) & 1);\\n                if(nonz || (i != 0))\\n                    new_mask |= (1 << i);\\n                if(i == v)\\n                    new_tight = 1;\\n                if(c_bit == 0)\\n                    cans += solve(bit + 1, new_tight, nonz || (i != 0),new_mask);\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i <= 9; i++)\\n            {\\n                int new_mask = mask;\\n                int c_bit = ((mask >> i) & 1);\\n                if(nonz || (i != 0))\\n                    new_mask |= (1 << i);\\n                if(c_bit == 0)\\n                    cans += solve(bit + 1, 0, nonz || (i != 0), new_mask);\\n            }\\n        }\\n        return dp[bit][tight][nonz][mask] = cans;\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        int dig = d(N);\\n        num = to_string(N);\\n        l = num.size();\\n        memset(dp, -1, sizeof dp);\\n        return (N - solve(0,1,0,0));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string num;\\n    int l ;\\n    int dp[11][2][2][1030];\\n    \\n    int d(int N)\\n    {\\n        int c = 0;\\n        while(N)\\n        {\\n            c++;\\n            N /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4076746,
                "title": "c-simple-digit-dp-solution",
                "content": "# Approach\\nWe find the count of numbers having only distinct digits between 1 to n with the help of digit dp, and simply subtract it from n to get the answer.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(log(n)*len(mask))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[11][2][1024][2];\\n\\n    int f(string s, int n, bool tight, int mask, bool leadingZero){\\n        if(n == 0){\\n            return !leadingZero;\\n        }\\n        if(dp[n][tight][mask][leadingZero] != -1){\\n            return dp[n][tight][mask][leadingZero];\\n        }\\n        int answer = 0;\\n        int ub = tight ? s[s.size() - n] - \\'0\\': 9;\\n        for(int i = 0; i <= ub; i++){\\n            if(leadingZero and i == 0) answer += f(s, n - 1, 0, mask, 1);\\n            else{\\n                if((mask & (1 << i)) == 0){\\n                    answer += f(s, n - 1, tight && (i == ub), mask + (1 << i), 0);\\n                }\\n            }\\n        }\\n        return dp[n][tight][mask][leadingZero] = answer;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        return n - f(s, s.size(), 1, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[11][2][1024][2];\\n\\n    int f(string s, int n, bool tight, int mask, bool leadingZero){\\n        if(n == 0){\\n            return !leadingZero;\\n        }\\n        if(dp[n][tight][mask][leadingZero] != -1){\\n            return dp[n][tight][mask][leadingZero];\\n        }\\n        int answer = 0;\\n        int ub = tight ? s[s.size() - n] - \\'0\\': 9;\\n        for(int i = 0; i <= ub; i++){\\n            if(leadingZero and i == 0) answer += f(s, n - 1, 0, mask, 1);\\n            else{\\n                if((mask & (1 << i)) == 0){\\n                    answer += f(s, n - 1, tight && (i == ub), mask + (1 << i), 0);\\n                }\\n            }\\n        }\\n        return dp[n][tight][mask][leadingZero] = answer;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof dp);\\n        return n - f(s, s.size(), 1, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050150,
                "title": "my-0ms-c-solution-very-difficult-to-understand-understand-if-you-can",
                "content": "# Intuition\\nIf you are willing to understand how my code works, pleaes comment below. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int G(vector<int>& number, int i, bool flag){ // i=1,2...n, flag is if previous all digits were 0\\n        int n = number.size();\\n        if (i > n) return 0;\\n        int dig = number[i-1];\\n        if (flag){\\n            int ct = 9;\\n            int rem = 9;\\n            for(int j=i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n        else if (i == 1){\\n            //options are 1..dig-1\\n            int op = dig-1;\\n            int ct = op;\\n            int rem = 9;\\n            for(int j = i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            if (i == n) ct++;\\n            else ct += G(number, i+1,false);\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n\\n\\n\\n\\n\\n        bool available[10]; memset(available, true, sizeof(available));\\n\\n        for(int j=1;j<i;j++){\\n            int tmpDig = number[j-1];\\n            available[tmpDig] = false;\\n        }\\n        int rem = 0;\\n        int ct = 0;\\n        for(int d = 0; d<10;d++){\\n            if (available[d]) rem++;\\n            if (d<dig && available[d]) ct++;\\n        }\\n        for(int j=i+1;j<=n;j++){\\n            ct *= (--rem);\\n        }\\n        if (available[dig] && i == n) ct++;\\n        else if (available[dig]){\\n            ct += G(number, i+1, false);\\n        }\\n        return ct;\\n\\n\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string num = to_string(n);\\n        vector<int> number;\\n        for(char c : num){\\n            number.push_back(c-\\'0\\');\\n        }\\n        int res = G(number, 1, false);\\n        cout << res << endl;\\n        cout << n-res << endl;\\n       return n-res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int G(vector<int>& number, int i, bool flag){ // i=1,2...n, flag is if previous all digits were 0\\n        int n = number.size();\\n        if (i > n) return 0;\\n        int dig = number[i-1];\\n        if (flag){\\n            int ct = 9;\\n            int rem = 9;\\n            for(int j=i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n        else if (i == 1){\\n            //options are 1..dig-1\\n            int op = dig-1;\\n            int ct = op;\\n            int rem = 9;\\n            for(int j = i+1;j<=n;j++){\\n                ct *= rem;\\n                rem--;\\n            }\\n            if (i == n) ct++;\\n            else ct += G(number, i+1,false);\\n            ct += G(number, i+1, true);\\n            return ct;\\n        }\\n\\n\\n\\n\\n\\n        bool available[10]; memset(available, true, sizeof(available));\\n\\n        for(int j=1;j<i;j++){\\n            int tmpDig = number[j-1];\\n            available[tmpDig] = false;\\n        }\\n        int rem = 0;\\n        int ct = 0;\\n        for(int d = 0; d<10;d++){\\n            if (available[d]) rem++;\\n            if (d<dig && available[d]) ct++;\\n        }\\n        for(int j=i+1;j<=n;j++){\\n            ct *= (--rem);\\n        }\\n        if (available[dig] && i == n) ct++;\\n        else if (available[dig]){\\n            ct += G(number, i+1, false);\\n        }\\n        return ct;\\n\\n\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string num = to_string(n);\\n        vector<int> number;\\n        for(char c : num){\\n            number.push_back(c-\\'0\\');\\n        }\\n        int res = G(number, 1, false);\\n        cout << res << endl;\\n        cout << n-res << endl;\\n       return n-res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4031069,
                "title": "digit-dp-bitmask-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][2][1 << 10];\\n\\t//lead variable handles cases where leading values are zero in a number\\n\\t//solve function calculates the total numbers less than equal to n, not having repeating digits\\n    int solve(int ind, int tight, int lead, vector<int> &nums, int mask) {\\n        if(ind == nums.size()) {\\n            return 1;\\n        }\\n        \\n        if(dp[ind][tight][lead][mask] != -1) return dp[ind][tight][lead][mask];\\n        int ub = 9;\\n        if(tight) ub = nums[ind];\\n        int ans = 0;\\n        for(int i = 0;i <= ub;i++) {\\n            if(i == 0 && lead) {\\n                ans += solve(ind+1, 0, 1, nums, mask);\\n            }\\n            else {\\n                if(mask&(1 << i)) {\\n                    ans += solve(ind+1, tight&(i==ub), 0, nums, mask^(1<<i));\\n                }\\n            }\\n        }\\n        return dp[ind][tight][lead][mask]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        int num = n;\\n        int mask = (1 << 10)-1;\\n        vector<int> nums;\\n        while(n) {\\n            int d = n%10;\\n            n /= 10;\\n            nums.push_back(d);\\n        }\\n        vector<int> digs(10, 0);\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof dp);\\n\\t\\t//we subtract 1 to eliminate the all 0\\'s case\\n        int ans = solve(0, 1, 1, nums, mask)-1;\\n        return num-ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][2][1 << 10];\\n\\t//lead variable handles cases where leading values are zero in a number\\n\\t//solve function calculates the total numbers less than equal to n, not having repeating digits\\n    int solve(int ind, int tight, int lead, vector<int> &nums, int mask) {\\n        if(ind == nums.size()) {\\n            return 1;\\n        }\\n        \\n        if(dp[ind][tight][lead][mask] != -1) return dp[ind][tight][lead][mask];\\n        int ub = 9;\\n        if(tight) ub = nums[ind];\\n        int ans = 0;\\n        for(int i = 0;i <= ub;i++) {\\n            if(i == 0 && lead) {\\n                ans += solve(ind+1, 0, 1, nums, mask);\\n            }\\n            else {\\n                if(mask&(1 << i)) {\\n                    ans += solve(ind+1, tight&(i==ub), 0, nums, mask^(1<<i));\\n                }\\n            }\\n        }\\n        return dp[ind][tight][lead][mask]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        int num = n;\\n        int mask = (1 << 10)-1;\\n        vector<int> nums;\\n        while(n) {\\n            int d = n%10;\\n            n /= 10;\\n            nums.push_back(d);\\n        }\\n        vector<int> digs(10, 0);\\n        reverse(nums.begin(), nums.end());\\n        memset(dp, -1, sizeof dp);\\n\\t\\t//we subtract 1 to eliminate the all 0\\'s case\\n        int ans = solve(0, 1, 1, nums, mask)-1;\\n        return num-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009695,
                "title": "one-of-the-best-digit-dp-bitmask-question-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[70][2][1025][2][2];\\n    int f(int i,int t,int flag,int flag2,int flag3,string &s){\\n\\n        if(i == s.size() && flag2 == true)return 1;\\n        else if(i == s.size())return 0;\\n        \\n        if(dp[i][t][flag][flag2][flag3]!=-1)return dp[i][t][flag][flag2][flag3];\\n\\n        int ans = 0;\\n        int high = t ? s[i]-\\'0\\' : 9;\\n        int low = 0;\\n        for(int k=low;k<=high;k++){\\n            if(flag3 == false){//we have not yet started \\n                if(k == 0)ans+=f(i+1,t && high == k,flag,flag2,0,s);\\n                else ans+= f(i+1,t && high == k,flag|(1<<k),0,1,s);\\n            }\\n            else if((flag&(1<<k))){//this digit is already taken previously\\n                ans+= f(i+1,t && high == k,flag|(1<<k),1,1,s);//i have taken repeated digit\\n            }\\n            else ans+=f(i+1,t && high == k,flag|(1<<k),flag2,1,s);\\n        }\\n        return dp[i][t][flag][flag2][flag3] = ans;\\n    }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        \\n        string res = \"\";\\n        while(n>0){\\n            res.push_back(n%10+\\'0\\');\\n            n = n/10;\\n        }\\n        reverse(res.begin(),res.end());\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,1,0,0,0,res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[70][2][1025][2][2];\\n    int f(int i,int t,int flag,int flag2,int flag3,string &s){\\n\\n        if(i == s.size() && flag2 == true)return 1;\\n        else if(i == s.size())return 0;\\n        \\n        if(dp[i][t][flag][flag2][flag3]!=-1)return dp[i][t][flag][flag2][flag3];\\n\\n        int ans = 0;\\n        int high = t ? s[i]-\\'0\\' : 9;\\n        int low = 0;\\n        for(int k=low;k<=high;k++){\\n            if(flag3 == false){//we have not yet started \\n                if(k == 0)ans+=f(i+1,t && high == k,flag,flag2,0,s);\\n                else ans+= f(i+1,t && high == k,flag|(1<<k),0,1,s);\\n            }\\n            else if((flag&(1<<k))){//this digit is already taken previously\\n                ans+= f(i+1,t && high == k,flag|(1<<k),1,1,s);//i have taken repeated digit\\n            }\\n            else ans+=f(i+1,t && high == k,flag|(1<<k),flag2,1,s);\\n        }\\n        return dp[i][t][flag][flag2][flag3] = ans;\\n    }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        \\n        string res = \"\";\\n        while(n>0){\\n            res.push_back(n%10+\\'0\\');\\n            n = n/10;\\n        }\\n        reverse(res.begin(),res.end());\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,1,0,0,0,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989118,
                "title": "digit-dp-bitmask-java-solution",
                "content": "# Intuition\\nDigit DP and Bitmask\\n\\n# Approach\\n1. **Dynamic Programming (DP):** Your approach uses dynamic programming to break down the problem into smaller subproblems and avoid redundant computations.\\n\\n2. **Memoization:** You employ memoization to store intermediate results in a 4D array named `dp`. The four dimensions of `dp` are:\\n   - `idx`: The current index in the string representation of `n`.\\n   - `mask`: A bitmask to track which digits have been used so far.\\n   - `flag`: A boolean flag indicating whether a repeated digit has been encountered.\\n   - `tight`: A flag to control whether the current digit should be constrained to be less than or equal to the corresponding digit in `n`.\\n\\n3. **Recursive Helper Function:** The core of your solution is the `helper` function, which recursively explores different digit possibilities at each index of the number.\\n\\n4. **Base Case:** The base case of the recursion is when `idx` reaches the length of the string representation of `n`. In this case, you return the `flag` value, which indicates whether you\\'ve encountered a repeated digit during the recursive exploration.\\n\\n5. **Exploring Digits:** For each digit from 0 to 9, you check if it can be used in the current position based on the following conditions:\\n   - If `i == 0` and `mask == 0`, it means this digit is leading, and you recursively call the `helper` function with `flag` set to 0, indicating no repeated digits.\\n   - If `(mask & (1 << i)) == 0`, it means this digit hasn\\'t been used before, and you recursively call the `helper` function with the `mask` updated to mark this digit as used. You also update `flag` if necessary based on whether it\\'s the last digit (`tight`).\\n   - Otherwise, if this digit has been used before, you update `flag` and continue exploring other digits.\\n\\n6. **Dynamic Programming Memoization:** You store the count of valid combinations at the current state `(idx, mask, flag, tight)` in the `dp` array. Before making a recursive call, you check if the result for that state is already computed and stored in `dp`. If it is, you directly return the memoized result, which avoids redundant computation.\\n\\n7. **Return Result:** Finally, you return the count of valid combinations from the initial state `(0, 0, 0, 1)` where `idx` is 0 (start of the string representation of `n`), `mask` is 0 (no digits used initially), `flag` is 0 (no repeated digits initially), and `tight` is 1 (the current digit is not constrained).\\n\\n# Time Complexity\\n The code explores all possibilities for each digit from 0 to 9 for each position in the string representation of n. Therefore, the time complexity is O(10 * len(num)), where len(num) is the length of the string representation of n. In other words, it\\'s linear in the number of digits in n.\\n\\n# Space Complexity \\nThe space complexity is O(10 * len(num) * 2 * 2) for the dp array, which simplifies to O(len(num)) since the other constants are relatively small.\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[][][][] dp = new Integer[10][1 << 10][2][2];\\n    public int numDupDigitsAtMostN(int n) {\\n        String num = Integer.toString(n);\\n        return helper(num,0,0,0,1);\\n    }\\n    private int helper(String num,int idx,int mask,int flag,int tight){\\n        if(idx == num.length()) return flag;\\n        if(dp[idx][mask][flag][tight] != null) return dp[idx][mask][flag][tight];\\n        int max = tight == 1? num.charAt(idx) - \\'0\\' : 9;\\n        int count = 0;\\n        for (int i = 0; i <= max; i++) {\\n                if(i == 0 && mask == 0) count += helper(num,idx+1,0,0,0);\\n                else if((mask & (1 << i)) == 0) count += helper(num,idx+1,mask | (1<<i),flag,tight == 1 && i == max ? 1:0);\\n                else count += helper(num,idx+1,mask,1,tight==1 && i==max?1:0);\\n            }\\n        return dp[idx][mask][flag][tight] = count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][][][] dp = new Integer[10][1 << 10][2][2];\\n    public int numDupDigitsAtMostN(int n) {\\n        String num = Integer.toString(n);\\n        return helper(num,0,0,0,1);\\n    }\\n    private int helper(String num,int idx,int mask,int flag,int tight){\\n        if(idx == num.length()) return flag;\\n        if(dp[idx][mask][flag][tight] != null) return dp[idx][mask][flag][tight];\\n        int max = tight == 1? num.charAt(idx) - \\'0\\' : 9;\\n        int count = 0;\\n        for (int i = 0; i <= max; i++) {\\n                if(i == 0 && mask == 0) count += helper(num,idx+1,0,0,0);\\n                else if((mask & (1 << i)) == 0) count += helper(num,idx+1,mask | (1<<i),flag,tight == 1 && i == max ? 1:0);\\n                else count += helper(num,idx+1,mask,1,tight==1 && i==max?1:0);\\n            }\\n        return dp[idx][mask][flag][tight] = count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985965,
                "title": "math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        num_list = []\\n        original_n = n\\n        while n > 0:\\n            num_list.append(n % 10)\\n            n = n // 10\\n        num_list.reverse()\\n\\n        digit_num = len(num_list)\\n        # str_n = str(n)\\n        o = len(num_list) - 1\\n        \\n        ans_o = 0\\n        while o > 0:\\n            o_a = 9\\n            for i in range(o-1):\\n                o_a *= (9-i)\\n            ans_o += o_a\\n            o -= 1\\n            \\n        ans = 0\\n        should_break = 0\\n\\n        for i in range(digit_num):\\n            print(i)\\n            # if num_list[i] != 0:\\n            minus_num = 0\\n\\n            for j in range(i):\\n                if num_list[j] < num_list[i]:\\n                    minus_num += 1\\n                elif num_list[j] == num_list[i]:\\n                    should_break = 1\\n\\n            p = 1\\n            for q in range(10-i-1, 10 - digit_num, -1):\\n                p *= q\\n            \\n            if i == 0:\\n                ans += (num_list[i] - 1) * p + ans_o\\n                print(\\'ti\\', ans)\\n\\n            elif i != 0:\\n                ans += (num_list[i] - minus_num) * p\\n                print(\\'to\\', ans)\\n\\n            if should_break:\\n                break\\n\\n        print(ans)\\n\\n        # last_digit + 1 & first_digit zero cases\\n        return original_n - ans - 1 if len(set(num_list))==digit_num else original_n - ans\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        num_list = []\\n        original_n = n\\n        while n > 0:\\n            num_list.append(n % 10)\\n            n = n // 10\\n        num_list.reverse()\\n\\n        digit_num = len(num_list)\\n        # str_n = str(n)\\n        o = len(num_list) - 1\\n        \\n        ans_o = 0\\n        while o > 0:\\n            o_a = 9\\n            for i in range(o-1):\\n                o_a *= (9-i)\\n            ans_o += o_a\\n            o -= 1\\n            \\n        ans = 0\\n        should_break = 0\\n\\n        for i in range(digit_num):\\n            print(i)\\n            # if num_list[i] != 0:\\n            minus_num = 0\\n\\n            for j in range(i):\\n                if num_list[j] < num_list[i]:\\n                    minus_num += 1\\n                elif num_list[j] == num_list[i]:\\n                    should_break = 1\\n\\n            p = 1\\n            for q in range(10-i-1, 10 - digit_num, -1):\\n                p *= q\\n            \\n            if i == 0:\\n                ans += (num_list[i] - 1) * p + ans_o\\n                print(\\'ti\\', ans)\\n\\n            elif i != 0:\\n                ans += (num_list[i] - minus_num) * p\\n                print(\\'to\\', ans)\\n\\n            if should_break:\\n                break\\n\\n        print(ans)\\n\\n        # last_digit + 1 & first_digit zero cases\\n        return original_n - ans - 1 if len(set(num_list))==digit_num else original_n - ans\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975032,
                "title": "c-digit-dp-with-bitmask-beat-90-solution",
                "content": "```\\nclass Solution {\\npublic: \\n    vector<int> val{1,10,100,1000,10000,100000,1000000,10000000,100000000};\\n    int dp[11][4096][2][2];\\n    int solve(int i,int x,int tight,int chk,string &s)\\n    {\\n        if(i==s.size())\\n            return 0;\\n        if(dp[i][x][tight][chk]!=-1)\\n            return dp[i][x][tight][chk];\\n        \\n        int tem=0;\\n        if(chk==1)\\n        {\\n             if(tight==1)\\n            {\\n            int p=s[i]-\\'0\\';\\n                 \\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,1,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                       {\\n                          \\n                        if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                    }\\n                }\\n                else\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n            else\\n            {\\n            for(int k=0;k<=9;k++)\\n            {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                     int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n            }\\n          }\\n        }\\n        else\\n        {\\n           if(tight==1)\\n          {\\n            int p=s[i]-\\'0\\';\\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                      {\\n                           if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                }\\n                else\\n                {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int k=0;k<=9;k++)\\n            {\\n                int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n            }\\n          }\\n        }\\n        return dp[i][x][tight][chk]=tem;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,1,1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    vector<int> val{1,10,100,1000,10000,100000,1000000,10000000,100000000};\\n    int dp[11][4096][2][2];\\n    int solve(int i,int x,int tight,int chk,string &s)\\n    {\\n        if(i==s.size())\\n            return 0;\\n        if(dp[i][x][tight][chk]!=-1)\\n            return dp[i][x][tight][chk];\\n        \\n        int tem=0;\\n        if(chk==1)\\n        {\\n             if(tight==1)\\n            {\\n            int p=s[i]-\\'0\\';\\n                 \\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,1,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                       {\\n                          \\n                        if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                    }\\n                }\\n                else\\n                {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n                }\\n            }\\n        }\\n            else\\n            {\\n            for(int k=0;k<=9;k++)\\n            {\\n                    if(k==0)\\n                    {\\n                        tem+=solve(i+1,x,0,1,s);\\n                    }\\n                    else\\n                    {\\n                     int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                    }\\n            }\\n          }\\n        }\\n        else\\n        {\\n           if(tight==1)\\n          {\\n            int p=s[i]-\\'0\\';\\n            for(int k=0;k<=p;k++)\\n            {\\n                if(k==p)\\n                {\\n                    int y=1<<k;\\n                    if((x & y)==0)\\n                      tem+=solve(i+1,x | y,1,0,s);\\n                    else\\n                      {\\n                           if(i+1==s.size())\\n                            tem+=1;\\n                        else\\n                        {\\n                        string st=s.substr(i+1);\\n                            int a=stoi(st);\\n                            a++;\\n                        tem+=a;\\n                        }\\n                       }\\n                }\\n                else\\n                {\\n                    int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int k=0;k<=9;k++)\\n            {\\n                int y=1<<k;\\n                    \\n                    if((x & y)==0)\\n                    tem+=solve(i+1,x | y,0,0,s);\\n                    else\\n                        {\\n                          int a=(int)(s.size())-1-i;\\n                        tem+=val[a];\\n                       }\\n            }\\n          }\\n        }\\n        return dp[i][x][tight][chk]=tem;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,1,1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957371,
                "title": "c-digit-dp-bitmasking-clean-and-concise-code",
                "content": "# Approach\\nWe can find count of numbers which have all digits unique using digit dp and bitmasking, hence we will subtract that count from total numbers to get numbers with atleast 1 duplicate digit.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[11][1024][2];\\n    int solve(int pos,int mask,bool tight,string& s)\\n    {\\n        if(pos==s.size())\\n        return (mask!=0)?1:0;\\n        if(dp[pos][mask][tight]!=-1)\\n        return dp[pos][mask][tight];\\n\\n        int up = tight?(s[pos]-\\'0\\'):9;\\n        int ans = 0;\\n        for(int i=0;i<=up;i++)\\n        {\\n            if(mask&(1<<i))\\n            continue;\\n            int newT = tight & (i==up);\\n            int newM = (mask==0 && i==0)?mask:mask|(1<<i);\\n            ans+=solve(pos+1,newM,newT,s);\\n        }\\n        return dp[pos][mask][tight] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        long long tot = n;\\n        return tot-solve(0,0,1,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][1024][2];\\n    int solve(int pos,int mask,bool tight,string& s)\\n    {\\n        if(pos==s.size())\\n        return (mask!=0)?1:0;\\n        if(dp[pos][mask][tight]!=-1)\\n        return dp[pos][mask][tight];\\n\\n        int up = tight?(s[pos]-\\'0\\'):9;\\n        int ans = 0;\\n        for(int i=0;i<=up;i++)\\n        {\\n            if(mask&(1<<i))\\n            continue;\\n            int newT = tight & (i==up);\\n            int newM = (mask==0 && i==0)?mask:mask|(1<<i);\\n            ans+=solve(pos+1,newM,newT,s);\\n        }\\n        return dp[pos][mask][tight] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        long long tot = n;\\n        return tot-solve(0,0,1,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947545,
                "title": "kotlin-dp-digit-and-bit-masking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private fun solve(i: Int, mask: Int, isRepeat: Int, isLast: Int, str: String, dp: Array<Array<Array<Array<Int>>>>): Int{\\n        if(i==str.length){\\n            return isRepeat;\\n        }\\n        if(dp[i][mask][isRepeat][isLast]!=-1){\\n            return dp[i][mask][isRepeat][isLast]\\n        }\\n        val till = if(isLast==1) str[i]-\\'0\\' else 9\\n        var ans= 0\\n        for(j in 0..till){\\n            val newIsLast = if(isLast==1 && j==till) 1 else 0\\n            if(mask==0 && j==0){\\n                ans += solve(i+1, mask, isRepeat, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j )) > 0){\\n                ans += solve(i+1, mask, 1, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j ))==0){\\n                ans += solve(i+1, mask or (1 shl j), isRepeat, newIsLast, str, dp)\\n            }\\n        }\\n        dp[i][mask][isRepeat][isLast] = ans\\n        return ans\\n    }\\n\\n    fun numDupDigitsAtMostN(n: Int): Int {\\n        val dp = Array(10) { Array(1 shl 10) { Array(2) { Array(2) { -1 } } } }\\n        val str = n.toString();\\n        return solve(0,0,0,1,str,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    private fun solve(i: Int, mask: Int, isRepeat: Int, isLast: Int, str: String, dp: Array<Array<Array<Array<Int>>>>): Int{\\n        if(i==str.length){\\n            return isRepeat;\\n        }\\n        if(dp[i][mask][isRepeat][isLast]!=-1){\\n            return dp[i][mask][isRepeat][isLast]\\n        }\\n        val till = if(isLast==1) str[i]-\\'0\\' else 9\\n        var ans= 0\\n        for(j in 0..till){\\n            val newIsLast = if(isLast==1 && j==till) 1 else 0\\n            if(mask==0 && j==0){\\n                ans += solve(i+1, mask, isRepeat, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j )) > 0){\\n                ans += solve(i+1, mask, 1, newIsLast, str, dp);\\n            }\\n            else if((mask and (1 shl j ))==0){\\n                ans += solve(i+1, mask or (1 shl j), isRepeat, newIsLast, str, dp)\\n            }\\n        }\\n        dp[i][mask][isRepeat][isLast] = ans\\n        return ans\\n    }\\n\\n    fun numDupDigitsAtMostN(n: Int): Int {\\n        val dp = Array(10) { Array(1 shl 10) { Array(2) { Array(2) { -1 } } } }\\n        val str = n.toString();\\n        return solve(0,0,0,1,str,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947392,
                "title": "explained-how-to-approach-digit-dp-and-bitmask-problem-well-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**For Digit DP:** Whenever there is range given and we have to no of integers base on some conditions in the range, you can think of Digit DP as one of the possible solution.\\n\\n**For Bitmasking:** Here we have to take in account of the digit used and the no of unique digits is 10 only that is less than 31, so we can use bitmask(for int, as int has a upper limit of 2^31 - 1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(12 * 2 * 2 * 10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(10 * 2 * 2 * (2^10))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947389,
                "title": "explained-how-to-approach-digit-dp-and-bitmask-problem-well-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**For Digit DP:** Whenever there is range given and we have to no of integers base on some conditions in the range, you can think of Digit DP as one of the possible solution.\\n\\n**For Bitmasking:** Here we have to take in account of the digit used and the no of unique digits is 10 only that is less than 31, so we can use bitmask(for int, as int has a upper limit of 2^31 - 1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(12 * 2 * 2 * 10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(10 * 2 * 2 * (2^10))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // withoutRepeated: [pos][tight][start][mask]\\n    // tight tells if we the so far constructed num has same digits as the given num\\n    // start tells if the num is of zero length or not\\n    // mask is like a bitmap of the digit used so far in the num\\n    int dp[12][2][2][1 << 10];\\n    //  possibleNumbers: [pos][tight][start]\\n    int dp2[12][2][2];\\n    int withoutRepeated(int pos, bool tight, bool st, int mask, string &s){\\n        if(pos == 0)\\n            return 1;\\n        if(dp[pos][tight][st][mask] != -1)\\n            return dp[pos][tight][st][mask];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        if(st) // if the num is not yet started then we have the option to skip this digit also\\n            res += withoutRepeated(pos-1, 0, 1, mask, s);\\n        for(int j = 0; j <= 9; j++){\\n            if(st && j == 0) // is the num is of zero length then we will not take 0\\n                continue;\\n            else if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break; \\n            else if((mask & (1 << j)) == 0) // checking if the digit is being used or not\\n                res += withoutRepeated(pos-1, tight && (j == limit), 0, mask | (1 << j), s);\\n        }\\n        return dp[pos][tight][st][mask] = res;\\n    }\\n    int possibleNumbers(int pos, bool tight, bool st, string t, string &s){\\n        if(pos == 0) // if the t.size() == s.size()\\n            return 1;\\n\\n        if(dp2[pos][tight][st] != -1)\\n            return dp2[pos][tight][st];\\n        int limit = tight ? (s[s.size() - pos] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int j = 0; j <= 9; j++)\\n            if(tight && j > limit) // if tight then we cannot take digit more than limit \\n                break;\\n            else\\n                res += possibleNumbers(pos-1, tight && (j == limit), 0, t + to_string(j), s);\\n        return dp2[pos][tight][st] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        int m = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        memset(dp2, -1, sizeof(dp2));\\n        int res = possibleNumbers(m, 1, 1, \"\", s) - withoutRepeated(m, 1, 1, 0, s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940328,
                "title": "c-python-digit-dp-solution-with-explanation",
                "content": "### find how many number without repeated digits\\nfill a number digit by digit.\\ni means we are filling i-th digit.\\nmask is number we used in the number, it is a bitmask, means which number we have used in [0,9].\\nis_limit means the current number is on the upper bound, e.g., n = 234, and digit is 23, we are filling last number -> 23[4].\\nhas_leading0s means digits are all 0s, e.g., 000, and we can fill a valid digit or skip it (fill a 0).\\n\\nfor i-th digit,\\nif has_leading0s is true, we can skip i-th digit, keep has_leading0s\\nor fill a digit in [1,9],\\nif has_leading0s  is true, digit can not be 0\\nif is_limit is true, digit is at most int(s[i]).\\n\\neumerate digit from low to high,\\nif this digit is not repeated, we can fill next digit.\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, has_leading0s):\\n            if i == len(s): return int(not has_leading0s)\\n            sub = 0\\n            if has_leading0s:\\n                sub = dfs(i+1, mask, False, True)\\n            low = 1 if has_leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                if mask >> d & 1 == 0:\\n                    sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False)\\n            return sub\\n        \\n        return n - dfs(0, 0, True, True)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<int>> dp (s.size(), vector<int>(1<<10, -1));\\n        function<int(int, int, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s) {\\n            if (i == s.size()) return (int)!leading0s;\\n            if (!is_limit && !leading0s && dp[i][mask] != -1) return dp[i][mask];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true);\\n            int low = leading0s? 1:0, high = is_limit? s[i]-\\'0\\': 9;\\n            for (int d = low; d <= high; d+=1) {\\n                if ((mask >> d & 1) == 0) {\\n                    sub += dfs(i+1, mask | (1<<d), is_limit && d == high, false);\\n                }\\n            }\\n            if (!is_limit && !leading0s) dp[i][mask] = sub;\\n            return sub;\\n        };\\n        return n - dfs(0, 0, true, true);\\n    }\\n};\\n```\\n\\n### find how many number at least one repeated digit\\n\\nfill a number digit by digit.\\n\\nhas_repeated means digits we filled has at least one repeated digit.\\n\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, leading0s, has_repeated):\\n            if i == len(s): return int(has_repeated)\\n            sub = 0\\n            if leading0s: sub = dfs(i+1, mask, False, True, False)\\n            low = 1 if leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False, has_repeated or mask >> d & 1 == 1)\\n            return sub\\n        return dfs(0, 0, True, True, False)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp (s.size(), vector<vector<int>>(1<<10, vector<int>(2, -1)));\\n        function<int(int, int, bool, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s, bool has_repeated) {\\n            if (i == s.size()) return (int) has_repeated;\\n            if (!is_limit && !leading0s && dp[i][mask][(int) has_repeated] != -1) return dp[i][mask][(int) has_repeated];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true, false);\\n            int low = leading0s? 1:0, high = is_limit? s[i] - \\'0\\': 9;\\n            for (int d = low; d <= high; d+=1)\\n                sub += dfs(i+1, mask | (1 << d), is_limit && d == high, false, has_repeated || mask >> d & 1);\\n            if (!is_limit && !leading0s) dp[i][mask][(int) has_repeated] = sub;\\n            return sub;\\n        };\\n        return dfs(0, 0, true, true, false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, has_leading0s):\\n            if i == len(s): return int(not has_leading0s)\\n            sub = 0\\n            if has_leading0s:\\n                sub = dfs(i+1, mask, False, True)\\n            low = 1 if has_leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                if mask >> d & 1 == 0:\\n                    sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False)\\n            return sub\\n        \\n        return n - dfs(0, 0, True, True)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<int>> dp (s.size(), vector<int>(1<<10, -1));\\n        function<int(int, int, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s) {\\n            if (i == s.size()) return (int)!leading0s;\\n            if (!is_limit && !leading0s && dp[i][mask] != -1) return dp[i][mask];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true);\\n            int low = leading0s? 1:0, high = is_limit? s[i]-\\'0\\': 9;\\n            for (int d = low; d <= high; d+=1) {\\n                if ((mask >> d & 1) == 0) {\\n                    sub += dfs(i+1, mask | (1<<d), is_limit && d == high, false);\\n                }\\n            }\\n            if (!is_limit && !leading0s) dp[i][mask] = sub;\\n            return sub;\\n        };\\n        return n - dfs(0, 0, true, true);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s = str(n)\\n        @cache\\n        def dfs(i, mask, is_limit, leading0s, has_repeated):\\n            if i == len(s): return int(has_repeated)\\n            sub = 0\\n            if leading0s: sub = dfs(i+1, mask, False, True, False)\\n            low = 1 if leading0s else 0\\n            high = int(s[i]) if is_limit else 9\\n            for d in range(low, high+1):\\n                sub += dfs(i+1, mask | (1 << d), is_limit and d == high, False, has_repeated or mask >> d & 1 == 1)\\n            return sub\\n        return dfs(0, 0, True, True, False)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp (s.size(), vector<vector<int>>(1<<10, vector<int>(2, -1)));\\n        function<int(int, int, bool, bool, bool)> dfs = [&] (int i, int mask, bool is_limit, bool leading0s, bool has_repeated) {\\n            if (i == s.size()) return (int) has_repeated;\\n            if (!is_limit && !leading0s && dp[i][mask][(int) has_repeated] != -1) return dp[i][mask][(int) has_repeated];\\n            int sub = 0;\\n            if (leading0s) sub = dfs(i+1, mask, false, true, false);\\n            int low = leading0s? 1:0, high = is_limit? s[i] - \\'0\\': 9;\\n            for (int d = low; d <= high; d+=1)\\n                sub += dfs(i+1, mask | (1 << d), is_limit && d == high, false, has_repeated || mask >> d & 1);\\n            if (!is_limit && !leading0s) dp[i][mask][(int) has_repeated] = sub;\\n            return sub;\\n        };\\n        return dfs(0, 0, true, true, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859569,
                "title": "easy-dp-bitmasking-solution-including-edge-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[10][2][(1<<11)][2];\\n    int solve(int idx, int edge, int bitmask, int repeated, string num){\\n        if(idx == num.size()){\\n            if(bitmask != 0 && repeated)return 1;\\n            return 0;\\n        }  \\n        if(dp[idx][edge][bitmask][repeated] != -1) return dp[idx][edge][bitmask][repeated];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        int ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            // missed case - when there are leading zeros we can still take zero\\n            if(i == 0){\\n                if(bitmask > 0){\\n                    if((bitmask & 1) == 1){\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num);\\n                    }\\n                    else{\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                    }\\n                }\\n                else{\\n                    ans += solve(idx+1, edge && (i == num[idx] - \\'0\\'), 0, repeated, num);\\n                }\\n            }\\n            else {\\n                if((bitmask & (1<<i)) == 0){\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                }\\n                else{\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num); \\n                }\\n            }\\n        }   \\n        return dp[idx][edge][bitmask][repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        string num = to_string(n);\\n        return solve(0, 1, 0, 0, num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[10][2][(1<<11)][2];\\n    int solve(int idx, int edge, int bitmask, int repeated, string num){\\n        if(idx == num.size()){\\n            if(bitmask != 0 && repeated)return 1;\\n            return 0;\\n        }  \\n        if(dp[idx][edge][bitmask][repeated] != -1) return dp[idx][edge][bitmask][repeated];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        int ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            // missed case - when there are leading zeros we can still take zero\\n            if(i == 0){\\n                if(bitmask > 0){\\n                    if((bitmask & 1) == 1){\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num);\\n                    }\\n                    else{\\n                        ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                    }\\n                }\\n                else{\\n                    ans += solve(idx+1, edge && (i == num[idx] - \\'0\\'), 0, repeated, num);\\n                }\\n            }\\n            else {\\n                if((bitmask & (1<<i)) == 0){\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), repeated, num);\\n                }\\n                else{\\n                    ans += solve(idx + 1, edge && (i == num[idx] - \\'0\\'), bitmask|(1<<i), 1, num); \\n                }\\n            }\\n        }   \\n        return dp[idx][edge][bitmask][repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        string num = to_string(n);\\n        return solve(0, 1, 0, 0, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856516,
                "title": "1012-numbers-with-repeated-digits",
                "content": "class Solution {\\n public:\\n  int numDupDigitsAtMostN(int n) {\\n    return n - countSpecialNumbers(n);\\n  }\\n\\n private:\\n  // Same as 2376. Count Special Integers\\n  int countSpecialNumbers(int n) {\\n    const int digitSize = log10(n) + 1;\\n    // dp[i][j][k] := # of special integers with current digit i and `usedMask`\\n    // j, where k is 0/1 tight constraint\\n    dp.resize(digitSize + 1, vector<vector<int>>(1 << 10, vector<int>(2, -1)));\\n    return count(to_string(n), 0, 0, true) - 1;  // - 0;\\n  }\\n\\n private:\\n  vector<vector<vector<int>>> dp;\\n\\n  int count(const string& s, int i, int usedMask, bool isTight) {\\n    if (i == s.length())\\n      return 1;\\n    if (dp[i][usedMask][isTight] != -1)\\n      return dp[i][usedMask][isTight];\\n\\n    int res = 0;\\n\\n    const int maxDigit = isTight ? s[i] - \\'0\\' : 9;\\n    for (int d = 0; d <= maxDigit; ++d) {\\n      // `d` is used.\\n      if (usedMask >> d & 1)\\n        continue;\\n      // Use `d` now.\\n      const bool nextIsTight = isTight && (d == maxDigit);\\n      if (usedMask == 0 && d == 0)  // Don\\'t count leading 0s as used.\\n        res += count(s, i + 1, usedMask, nextIsTight);\\n      else\\n        res += count(s, i + 1, usedMask | 1 << d, nextIsTight);\\n    }\\n\\n    return dp[i][usedMask][isTight] = res;\\n  }\\n};\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n public:\\n  int numDupDigitsAtMostN(int n) {\\n    return n - countSpecialNumbers(n);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 3844878,
                "title": "using-bitmask-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint dp[11][1<<11][2];\\n\\nint fun(int i,int mask,int strict,string&s){\\n    if(i>=s.size()){\\n        if(mask>0) return 1;\\n        return 0;\\n    }\\n\\nif(dp[i][mask][strict]!=-1) return dp[i][mask][strict];\\n    long long ans=0;\\n    if(mask==0){\\n\\n\\n        if(strict==1){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else if(j==s[i]-\\'0\\'){\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,1,s));\\n                }\\n                else{\\n                     int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n        else{\\n            for(int j=0;j<=9;j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else{\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n    }\\n\\n    else{\\n           if(strict==1){\\n               for(int j=0;j<=s[i]-\\'0\\';j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n                   if(j==s[i]-\\'0\\'){\\n            ans=(ans+fun(i+1,mask|(1<<j),1,s));         \\n                    }\\n\\n                    else{\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                    }\\n\\n\\n                   }\\n               }\\n           }\\n\\n\\n\\n           else{\\n               for(int j=0;j<=9;j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                  \\n                   }\\n               }\\n           }\\n\\n    }\\n\\n             return dp[i][mask][strict]=ans;\\n\\n\\n\\n}\\n\\n\\n\\n    \\n    \\n\\n\\n\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n       memset(dp,-1,sizeof(dp));\\n        string s=\"\";\\n        int val=n;\\n        while(val){\\n            s+=(\\'0\\'+(val%10));\\n            val/=10;\\n        }\\n        reverse(s.begin(),s.end());\\n\\n        val=fun(0,0,1,s);\\n        return n-val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dp[11][1<<11][2];\\n\\nint fun(int i,int mask,int strict,string&s){\\n    if(i>=s.size()){\\n        if(mask>0) return 1;\\n        return 0;\\n    }\\n\\nif(dp[i][mask][strict]!=-1) return dp[i][mask][strict];\\n    long long ans=0;\\n    if(mask==0){\\n\\n\\n        if(strict==1){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else if(j==s[i]-\\'0\\'){\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,1,s));\\n                }\\n                else{\\n                     int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n        else{\\n            for(int j=0;j<=9;j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else{\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n    }\\n\\n    else{\\n           if(strict==1){\\n               for(int j=0;j<=s[i]-\\'0\\';j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n                   if(j==s[i]-\\'0\\'){\\n            ans=(ans+fun(i+1,mask|(1<<j),1,s));         \\n                    }\\n\\n                    else{\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                    }\\n\\n\\n                   }\\n               }\\n           }\\n\\n\\n\\n           else{\\n               for(int j=0;j<=9;j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                  \\n                   }\\n               }\\n           }\\n\\n    }\\n\\n             return dp[i][mask][strict]=ans;\\n\\n\\n\\n}\\n\\n\\n\\n    \\n    \\n\\n\\n\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n       memset(dp,-1,sizeof(dp));\\n        string s=\"\";\\n        int val=n;\\n        while(val){\\n            s+=(\\'0\\'+(val%10));\\n            val/=10;\\n        }\\n        reverse(s.begin(),s.end());\\n\\n        val=fun(0,0,1,s);\\n        return n-val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788034,
                "title": "a-clean-solution-digit-dp-with-bitmask",
                "content": "This is a classic digit dp problem with a few more constraints. To achieve desired result we can apply following steps:\\n* Count the numbers which don\\'t have repeated digits, This is can be achieved  using a bitmask to check whether we have seen a digit previously or not.\\n* Subtract it from total(n).\\n**Note**\\n*There can be as many Leading zeroes as the number of digits in our number and hence they won\\'t be treated as repeated.*\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[10][1024][2][2];\\n    int solve(string &num, int pos, int mask, bool leading, bool e)\\n    {\\n        if(pos == num.length())\\n            return 1;\\n        \\n        if(dp[pos][mask][leading][e] != -1)\\n            return dp[pos][mask][leading][e];\\n        \\n        int res = 0;\\n        \\n        if(leading)\\n            res += solve(num, pos + 1, mask, true, false);\\n            \\n        \\n        int limit = e ? num[pos] - \\'0\\' : 9;\\n       \\n        for(int digit = leading ? 1 : 0 ; digit <= limit ; digit++)\\n        {\\n            if(mask & (1 << digit))\\n                continue;\\n            \\n            if(e && digit == limit)\\n                res += solve(num, pos + 1, mask | (1 << digit), false, true);\\n            else\\n                res += solve(num, pos + 1, mask | (1 << digit), false, false);\\n        }\\n        \\n        return dp[pos][mask][leading][e] = res;\\n        \\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        string num = to_string(n);\\n        // plus 1 is done because of leading zeroes.\\n        return n - solve(num, 0, 0, true, true) + 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][1024][2][2];\\n    int solve(string &num, int pos, int mask, bool leading, bool e)\\n    {\\n        if(pos == num.length())\\n            return 1;\\n        \\n        if(dp[pos][mask][leading][e] != -1)\\n            return dp[pos][mask][leading][e];\\n        \\n        int res = 0;\\n        \\n        if(leading)\\n            res += solve(num, pos + 1, mask, true, false);\\n            \\n        \\n        int limit = e ? num[pos] - \\'0\\' : 9;\\n       \\n        for(int digit = leading ? 1 : 0 ; digit <= limit ; digit++)\\n        {\\n            if(mask & (1 << digit))\\n                continue;\\n            \\n            if(e && digit == limit)\\n                res += solve(num, pos + 1, mask | (1 << digit), false, true);\\n            else\\n                res += solve(num, pos + 1, mask | (1 << digit), false, false);\\n        }\\n        \\n        return dp[pos][mask][leading][e] = res;\\n        \\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp, -1, sizeof dp);\\n        \\n        string num = to_string(n);\\n        // plus 1 is done because of leading zeroes.\\n        return n - solve(num, 0, 0, true, true) + 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656650,
                "title": "digitdp-clean-best-c-code",
                "content": "# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int dp[11][1 << 10][2][2];\\n    int helper(int ind,int mask,string s,bool is_smaller,bool is_repeated){\\n        if(ind == s.size())\\n            return is_repeated ? 1 : 0;\\n        if(dp[ind][mask][is_smaller][is_repeated] != -1)\\n            return dp[ind][mask][is_smaller][is_repeated];\\n        int ans = 0,end = is_smaller ? 9 : s[ind] - \\'0\\';\\n        for(int i=0;i<=end;i++){\\n           int bitMask = mask;\\n           bool repeat = is_repeated;\\n            if(!is_repeated){\\n                repeat = (mask & (1 << i)) ? true : false;\\n                if(!repeat)\\n                    bitMask = mask | (1 << i);\\n                if(i == 0 && mask == 0)\\n                    bitMask = 0;\\n            }\\n            bool chk = is_smaller ? true : (i != end);\\n            ans += helper(ind+1,bitMask,s,chk,repeat);\\n        }\\n        return dp[ind][mask][is_smaller][is_repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,s,false,false);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][1 << 10][2][2];\\n    int helper(int ind,int mask,string s,bool is_smaller,bool is_repeated){\\n        if(ind == s.size())\\n            return is_repeated ? 1 : 0;\\n        if(dp[ind][mask][is_smaller][is_repeated] != -1)\\n            return dp[ind][mask][is_smaller][is_repeated];\\n        int ans = 0,end = is_smaller ? 9 : s[ind] - \\'0\\';\\n        for(int i=0;i<=end;i++){\\n           int bitMask = mask;\\n           bool repeat = is_repeated;\\n            if(!is_repeated){\\n                repeat = (mask & (1 << i)) ? true : false;\\n                if(!repeat)\\n                    bitMask = mask | (1 << i);\\n                if(i == 0 && mask == 0)\\n                    bitMask = 0;\\n            }\\n            bool chk = is_smaller ? true : (i != end);\\n            ans += helper(ind+1,bitMask,s,chk,repeat);\\n        }\\n        return dp[ind][mask][is_smaller][is_repeated] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return helper(0,0,s,false,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617057,
                "title": "c-bitmask-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nResult = n - (numbers with no repeated digit)\\nhere n is given in question\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1024*10*10*2)$$ = $$O(2*10^5)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1024*10*10*2)$$ = $$O(2*10^5)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    // digit + bitmask dp\\n    int dp[1024][2][10];\\n    int solve(string & n,int i,bool small,int mask)\\n    {\\n        if(i == n.length()) return 1;\\n        if(dp[mask][small][i]!=-1)return dp[mask][small][i];\\n        vector<int>dig = {0,1,2,3,4,5,6,7,8,9};\\n        \\n        int end = small==0 ? 9 : (n[i] - \\'0\\');\\n        int res = 0;\\n        // mask == 0, we have to calculate numbers with length 1 to len(n) - 1\\n        if(!mask)\\n        {\\n            res+=solve(n,i+1,0,mask);\\n        }\\n        for(int & d : dig)\\n        {\\n            if(d==0 && !mask) continue;\\n            bool smaller = (small) && (d == end);\\n            int shift = (1<<d);\\n            if(d <= end && !(mask&shift))\\n            {\\n                res+=solve(n,i+1,smaller,mask|shift);\\n            }\\n        }\\n        return dp[mask][small][i] = res;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string num = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return n + 1 - solve(num,0,1,0);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    // digit + bitmask dp\\n    int dp[1024][2][10];\\n    int solve(string & n,int i,bool small,int mask)\\n    {\\n        if(i == n.length()) return 1;\\n        if(dp[mask][small][i]!=-1)return dp[mask][small][i];\\n        vector<int>dig = {0,1,2,3,4,5,6,7,8,9}",
                "codeTag": "Java"
            },
            {
                "id": 3614562,
                "title": "hashmap-solution-recursion-backtracking-bitmask-digit-dp-accepetd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n1. HashMap solution --- O(n) //gives TLE.\\n2. Bitmask Dp ----- log(base 10) n.\\n\\n- Space complexity:\\n1. Hash Map  ----- nearly O(1), exact theeta(10).\\n2. Bitmask ------ O(1)\\n\\n# Code\\n```\\n// Hash map solution it gives TLE.. ofcourse it will because it is O(n) approach.\\n// it might be usefull for someone , thinking how to implement the recursion in this problem..\\n// Recursion + backTracking..\\n    int solve(string& num, int n, unordered_map<int, int>&mp, bool leadingZero, bool tight){\\n        if(n == 0){\\n            if(leadingZero) return 0;\\n            else{\\n                for(auto it : mp){\\n                    if(it.second >= 2){ \\n                     return 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(dig == 0 && leadingZero == 0)mp[0]++;\\n            else if(dig != 0) mp[dig]++;\\n\\n            ans = ans + solve(num, n-1, mp, leadingZero && (dig == 0), tight && (dig == ub));\\n\\n            if(dig == 0 && leadingZero == 0) mp[0]--;\\n            else if(dig != 0) mp[dig]--;\\n        }\\n\\n        return ans;\\n    }\\n\\n-----------------------------------------------------------------------------------------------------------------------------------\\n// Accepetd solution... Bitmask Dp\\nclass Solution {\\n    int dp[11][1025][2][2];\\n    int solve(string& num, int n, int mask, bool tight, bool rep){\\n        if(n == 0){\\n            if(rep && mask){\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n        if(dp[n][mask][tight][rep] != -1) return dp[n][mask][tight][rep];\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        if(mask == 0){\\n            ans = ans + solve(num, n-1, mask, 0, rep);\\n        }\\n\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(mask == 0 && dig == 0) continue;\\n            int repeated = mask & (1 << dig); // checking for any repeated digit\\n            if(repeated){\\n                ans = ans + solve(num, n-1, mask, tight && (dig == ub), 1);// if any digit is repeated no need to change the mask ,\\n                                                                           //you can, but mask will be unaffected.\\n            }else{\\n                ans = ans + solve(num, n-1, mask|(1<<dig), tight&&(dig == ub), rep);// if any of digit is not repeated\\n                                                                                        // then you have to set the incoming digits\\'s bit in mask,\\n                                                                                        // so that you can track the digit in future..\\n            } \\n        }\\n\\n        return dp[n][mask][tight][rep] = ans;\\n\\n    }\\n\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string r = to_string(n);\\n        int sz = r.size();\\n        memset(dp, -1, sizeof dp);\\n\\n        int ans = solve(r, sz, 0, 1, 0);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Hash map solution it gives TLE.. ofcourse it will because it is O(n) approach.\\n// it might be usefull for someone , thinking how to implement the recursion in this problem..\\n// Recursion + backTracking..\\n    int solve(string& num, int n, unordered_map<int, int>&mp, bool leadingZero, bool tight){\\n        if(n == 0){\\n            if(leadingZero) return 0;\\n            else{\\n                for(auto it : mp){\\n                    if(it.second >= 2){ \\n                     return 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(dig == 0 && leadingZero == 0)mp[0]++;\\n            else if(dig != 0) mp[dig]++;\\n\\n            ans = ans + solve(num, n-1, mp, leadingZero && (dig == 0), tight && (dig == ub));\\n\\n            if(dig == 0 && leadingZero == 0) mp[0]--;\\n            else if(dig != 0) mp[dig]--;\\n        }\\n\\n        return ans;\\n    }\\n\\n-----------------------------------------------------------------------------------------------------------------------------------\\n// Accepetd solution... Bitmask Dp\\nclass Solution {\\n    int dp[11][1025][2][2];\\n    int solve(string& num, int n, int mask, bool tight, bool rep){\\n        if(n == 0){\\n            if(rep && mask){\\n                return 1;\\n            }\\n\\n            return 0;\\n        }\\n        if(dp[n][mask][tight][rep] != -1) return dp[n][mask][tight][rep];\\n\\n        int ub = tight ? (num[num.size() - n] - \\'0\\') : 9;\\n        int ans = 0;\\n        if(mask == 0){\\n            ans = ans + solve(num, n-1, mask, 0, rep);\\n        }\\n\\n        for(int dig = 0; dig <= ub; dig++){\\n            if(mask == 0 && dig == 0) continue;\\n            int repeated = mask & (1 << dig); // checking for any repeated digit\\n            if(repeated){\\n                ans = ans + solve(num, n-1, mask, tight && (dig == ub), 1);// if any digit is repeated no need to change the mask ,\\n                                                                           //you can, but mask will be unaffected.\\n            }else{\\n                ans = ans + solve(num, n-1, mask|(1<<dig), tight&&(dig == ub), rep);// if any of digit is not repeated\\n                                                                                        // then you have to set the incoming digits\\'s bit in mask,\\n                                                                                        // so that you can track the digit in future..\\n            } \\n        }\\n\\n        return dp[n][mask][tight][rep] = ans;\\n\\n    }\\n\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string r = to_string(n);\\n        int sz = r.size();\\n        memset(dp, -1, sizeof dp);\\n\\n        int ans = solve(r, sz, 0, 1, 0);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605711,
                "title": "easy-dp-python-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s=str(n)\\n        @cache\\n        def rec(ind,done,h,exists,z):\\n            nonlocal s\\n            if ind==len(s):\\n                if done:\\n                    return 1\\n                return 0\\n            top=int(s[ind]) if h else 9\\n            ans=0\\n            for i in range(top+1):\\n                hh=h and (i==int(s[ind]))\\n                existsnew=exists\\n                donenew=done\\n                if not( i==0 and z) and (exists & 1<<i)!=0:\\n                    donenew=True\\n                elif not (i==0 and z):\\n                    existsnew =exists | 1<<i\\n                zz=z and i==0\\n                ans+=rec(ind+1,donenew,hh,existsnew,zz)\\n            return ans\\n        return rec(0,False,True,0,True)\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        s=str(n)\\n        @cache\\n        def rec(ind,done,h,exists,z):\\n            nonlocal s\\n            if ind==len(s):\\n                if done:\\n                    return 1\\n                return 0\\n            top=int(s[ind]) if h else 9\\n            ans=0\\n            for i in range(top+1):\\n                hh=h and (i==int(s[ind]))\\n                existsnew=exists\\n                donenew=done\\n                if not( i==0 and z) and (exists & 1<<i)!=0:\\n                    donenew=True\\n                elif not (i==0 and z):\\n                    existsnew =exists | 1<<i\\n                zz=z and i==0\\n                ans+=rec(ind+1,donenew,hh,existsnew,zz)\\n            return ans\\n        return rec(0,False,True,0,True)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603530,
                "title": "exactly-similar-to-leetcode-2376-count-special-integers",
                "content": "# Approach\\nDo refer my solution for the explaination.\\n\\n*https://leetcode.com/problems/count-special-integers/solutions/3603502/digit-dp-solution-bitmasking-e/*\\n> This question is exactly similar to above given problem. You just have to subtract the answer from n.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    String s; // String representation of the input number\\n    Integer[][][] dp; // Dynamic programming array for memoization\\n\\n    public int numDupDigitsAtMostN(int n) {\\n        s = Integer.toString(n); // Convert the input number to a string\\n        dp = new Integer[s.length()][2][1024]; // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    public int f(int i, boolean bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != null) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s.charAt(i) - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s.charAt(i) - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == s.charAt(i) - \\'0\\', newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string s; // String representation of the input number\\n    vector<vector<vector<int>>> dp; // Dynamic programming array for memoization\\n\\n    int countSpecialNumbers(int n) {\\n        s = to_string(n); // Convert the input number to a string\\n        dp.resize(s.length(), vector<vector<int>>(2, vector<int>(1024, -1))); // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    int f(int i, bool bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != -1) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s[i] - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s[i] - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == (s[i] - \\'0\\'), newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```Java []\\nclass Solution {\\n    String s; // String representation of the input number\\n    Integer[][][] dp; // Dynamic programming array for memoization\\n\\n    public int numDupDigitsAtMostN(int n) {\\n        s = Integer.toString(n); // Convert the input number to a string\\n        dp = new Integer[s.length()][2][1024]; // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    public int f(int i, boolean bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != null) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s.charAt(i) - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s.charAt(i) - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == s.charAt(i) - \\'0\\', newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string s; // String representation of the input number\\n    vector<vector<vector<int>>> dp; // Dynamic programming array for memoization\\n\\n    int countSpecialNumbers(int n) {\\n        s = to_string(n); // Convert the input number to a string\\n        dp.resize(s.length(), vector<vector<int>>(2, vector<int>(1024, -1))); // Initialize the dp array\\n        int uniqueNos = f(0, true, 0); // Call the recursive function to count special numbers\\n        return n - uniqueNos;\\n    }\\n\\n    int f(int i, bool bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != -1) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s[i] - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s[i] - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == (s[i] - \\'0\\'), newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601938,
                "title": "combinactorics",
                "content": "# Intuition\\nThink of the the situation just opposite to the one asked in the problem statement : count the number of numbers in [1,n] that have all distinct digits in the decimal representation.\\n\\n# Approach\\nsuppose i use an array cnt, where cnt[i] = number of numbers in [1,n] that have i digits and all distinct, then ans to the reverse problem would be cnt[1] + cnt[2] + ... + cnt[d-1] + number of numbers with d digits all distinct that are less than or equal to n. So we solve it in two parts part 1 : calculate cnt[i] \\u2200 i and then the second part in the above statement. All the further details are there in the code in the comments along with the implementation.\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int Cr[11][11];\\n        for(int n=0; n<11; n++)\\n            for(int r=0; r<11; r++)\\n                Cr[n][r] = 0;\\n\\n        Cr[0][0]=1;\\n\\n        for(int n=1; n<11; n++){\\n            Cr[n][0] = 1; Cr[n][n] = 1;\\n            for(int r=1; r<n; r++) \\n                Cr[n][r] = Cr[n-1][r] + Cr[n-1][r-1];\\n        }\\n\\n        int Fact[11];\\n        Fact[0] = 1;\\n        for(int i=1; i<11; i++) \\n            Fact[i] = Fact[i-1] * i;\\n\\n        string s = to_string(n);\\n        int number_of_digits = s.size();\\n\\n        vector<int> cnt(11, 0);\\n        // cnt[i] = number of numbers in [1,n] that have i digits and all distinct\\n        for(int i=1; i<=10; i++)\\n            cnt[i] = Cr[9][i] * Fact[i] + (i-1) * Cr[9][i-1] * Fact[i-1];\\n            // how did i write this equation : \\n            // we place place any digit from [1,9] freely :\\n            // option 1 : we dont place a zero : choose any i digits in [1,9] and then permute them in any order\\n            // option 2 : we put a 0 : (i - 1) places to put the zero , then for the remaining i - 1 digits\\n            // choose any (i - 1) digits from [1,9] then permute them in any order\\n        \\n        int ans = 0;\\n        for(int d=1; d<number_of_digits; d++) \\n            ans += cnt[d];\\n\\n        // cout << ans << endl;\\n        \\n        // now we have to count the number of numbers with \\'number_of_digit\\' digits all distinct that are less than or equal to n\\n\\n        // lets iterate over the first point of difference of the number we make and n\\n\\n        vector<int> freq(10, 0); // it keeps the frequency of all the digits that we have seen untill now\\n        bool flag = true; \\n        for(int pos=0; pos<number_of_digits; pos++){\\n            if(!flag) break;\\n            // [0,pos-1] are the same digits are in n\\n            // at pos we will put a smaller digit than in n \\n            int d = s[pos] - \\'0\\';\\n            // we check for all digits in [start,d] if we can put it at postion pos\\n            // if pos is not zero then start can be zero, because we can place a zero in middle\\n            // if pos is zero then we start checking from 1\\n            int curr = 0;\\n            int start = 0;\\n            if(!pos) start ++;\\n            for(int i=start; i<d; i++) \\n                if(!freq[i]) curr++; // we can only put digits that are have not yet been used\\n            curr *= Cr[10 - pos -1][number_of_digits - pos -1] * Fact[number_of_digits - pos -1];\\n            ans += curr;\\n            freq[d] ++;\\n            if(freq[d] > 1) flag = false;\\n            // cout << curr << endl;\\n        }\\n        if(flag) ans ++;\\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int Cr[11][11];\\n        for(int n=0; n<11; n++)\\n            for(int r=0; r<11; r++)\\n                Cr[n][r] = 0;\\n\\n        Cr[0][0]=1;\\n\\n        for(int n=1; n<11; n++){\\n            Cr[n][0] = 1; Cr[n][n] = 1;\\n            for(int r=1; r<n; r++) \\n                Cr[n][r] = Cr[n-1][r] + Cr[n-1][r-1];\\n        }\\n\\n        int Fact[11];\\n        Fact[0] = 1;\\n        for(int i=1; i<11; i++) \\n            Fact[i] = Fact[i-1] * i;\\n\\n        string s = to_string(n);\\n        int number_of_digits = s.size();\\n\\n        vector<int> cnt(11, 0);\\n        // cnt[i] = number of numbers in [1,n] that have i digits and all distinct\\n        for(int i=1; i<=10; i++)\\n            cnt[i] = Cr[9][i] * Fact[i] + (i-1) * Cr[9][i-1] * Fact[i-1];\\n            // how did i write this equation : \\n            // we place place any digit from [1,9] freely :\\n            // option 1 : we dont place a zero : choose any i digits in [1,9] and then permute them in any order\\n            // option 2 : we put a 0 : (i - 1) places to put the zero , then for the remaining i - 1 digits\\n            // choose any (i - 1) digits from [1,9] then permute them in any order\\n        \\n        int ans = 0;\\n        for(int d=1; d<number_of_digits; d++) \\n            ans += cnt[d];\\n\\n        // cout << ans << endl;\\n        \\n        // now we have to count the number of numbers with \\'number_of_digit\\' digits all distinct that are less than or equal to n\\n\\n        // lets iterate over the first point of difference of the number we make and n\\n\\n        vector<int> freq(10, 0); // it keeps the frequency of all the digits that we have seen untill now\\n        bool flag = true; \\n        for(int pos=0; pos<number_of_digits; pos++){\\n            if(!flag) break;\\n            // [0,pos-1] are the same digits are in n\\n            // at pos we will put a smaller digit than in n \\n            int d = s[pos] - \\'0\\';\\n            // we check for all digits in [start,d] if we can put it at postion pos\\n            // if pos is not zero then start can be zero, because we can place a zero in middle\\n            // if pos is zero then we start checking from 1\\n            int curr = 0;\\n            int start = 0;\\n            if(!pos) start ++;\\n            for(int i=start; i<d; i++) \\n                if(!freq[i]) curr++; // we can only put digits that are have not yet been used\\n            curr *= Cr[10 - pos -1][number_of_digits - pos -1] * Fact[number_of_digits - pos -1];\\n            ans += curr;\\n            freq[d] ++;\\n            if(freq[d] > 1) flag = false;\\n            // cout << curr << endl;\\n        }\\n        if(flag) ans ++;\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3599155,
                "title": "beginner-friendly-easy-solution-using-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[12][2][1100][2];\\n\\n    void num_to_digi(int n , vector<int> &digit){\\n        while(n>0){\\n            digit.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(digit.begin() , digit.end());\\n    }\\n\\n\\n    int f(int idx , bool smaller , int mask , bool repeated , vector<int> &digit){\\n\\n        if(idx==digit.size()){\\n            if(repeated)return 1;\\n            else return 0;\\n        }\\n\\n        if(dp[idx][smaller][mask][repeated]!=-1)return dp[idx][smaller][mask][repeated];\\n        \\n        int cnt = 0;\\n\\n        if(smaller){\\n            for(int i=0 ; i<=digit[idx] ; i++){\\n                //the number has not started yet\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else if(i==digit[idx]){\\n                    // whether ith digit is present in the number or not\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n                else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }else{\\n            for(int i=0 ; i<=9 ; i++){\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[idx][smaller][mask][repeated] = cnt;\\n\\n    }\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n\\n        vector<int>digit;\\n        num_to_digi(n , digit);\\n        int ans = 0;\\n\\n        for(int i=0 ; i<12 ; i++){\\n            for(int j=0 ; j<2 ; j++){\\n                for(int k=0 ; k<1100 ; k++){\\n                    for(int m=0 ; m<2 ; m++){\\n                        dp[i][j][k][m] = -1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0 ; i<=digit[0] ; i++){\\n           if(i==0){\\n               ans += f(1 , false , 0 , false , digit);\\n           }else{\\n            if(i==digit[0]){\\n                ans += f(1 , true , (0|(1 << i)) , false , digit);\\n            }else{\\n                ans += f(1 , false , (0|(1 << i)) , false , digit);\\n            }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[12][2][1100][2];\\n\\n    void num_to_digi(int n , vector<int> &digit){\\n        while(n>0){\\n            digit.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(digit.begin() , digit.end());\\n    }\\n\\n\\n    int f(int idx , bool smaller , int mask , bool repeated , vector<int> &digit){\\n\\n        if(idx==digit.size()){\\n            if(repeated)return 1;\\n            else return 0;\\n        }\\n\\n        if(dp[idx][smaller][mask][repeated]!=-1)return dp[idx][smaller][mask][repeated];\\n        \\n        int cnt = 0;\\n\\n        if(smaller){\\n            for(int i=0 ; i<=digit[idx] ; i++){\\n                //the number has not started yet\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else if(i==digit[idx]){\\n                    // whether ith digit is present in the number or not\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , true , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n                else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }else{\\n            for(int i=0 ; i<=9 ; i++){\\n                if(i==0 && mask==0){\\n                    cnt += f(idx + 1 , false , 0 , false , digit);\\n                }else{\\n                    bool present = (mask&(1 << i));\\n                    if(present){\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , true , digit);\\n                    }else{\\n                        cnt += f(idx + 1 , false , (mask|(1 << i)) , repeated , digit);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[idx][smaller][mask][repeated] = cnt;\\n\\n    }\\n\\n\\n    int numDupDigitsAtMostN(int n) {\\n\\n        vector<int>digit;\\n        num_to_digi(n , digit);\\n        int ans = 0;\\n\\n        for(int i=0 ; i<12 ; i++){\\n            for(int j=0 ; j<2 ; j++){\\n                for(int k=0 ; k<1100 ; k++){\\n                    for(int m=0 ; m<2 ; m++){\\n                        dp[i][j][k][m] = -1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0 ; i<=digit[0] ; i++){\\n           if(i==0){\\n               ans += f(1 , false , 0 , false , digit);\\n           }else{\\n            if(i==digit[0]){\\n                ans += f(1 , true , (0|(1 << i)) , false , digit);\\n            }else{\\n                ans += f(1 , false , (0|(1 << i)) , false , digit);\\n            }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596525,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_digits)\\n * Space Complexity: O(n_digits)\\n * where `n_digits` is the number of the digits of the integer `n`\\n */\\nclass Solution {\\n private:\\n  static constexpr int digits = 10;\\n  static constexpr char zero = \\'0\\';\\n  static constexpr int n_masks = 1 << digits;\\n  static constexpr int unmemorized = -1;\\n  \\n public:\\n  int numDupDigitsAtMostN(const int n) {\\n    return n - no_duplicates(n);\\n  }\\n  \\n private:\\n  int no_duplicates(const int num) {\\n    const string number(to_string(num));\\n    const int n_digits = static_cast<int>(number.size());\\n    vector<vector<int>> memo(n_digits, vector<int>(n_masks, unmemorized));\\n    return dfs(number, 0, 0, true, false, memo);\\n  }\\n  \\n  /**\\n   * return the number of the integers which don\\'t contain any duplicate digits,\\n   *        starting from the `index`\\'th digit\\n   *\\n   * @param index: the index of the current digit\\n   * @param mask: the bit mask indicating the previous digits before the `index`\\'th digits\\n   * @param has_constraints: if it\\'s true, the current digit (`index`\\'th digit) cannot exceed `number[index]`\\n   *                         if not, the current digit can reach `9`\\n   * @param started: if it\\'s true, the current number is greater than `0`\\n   *                 if not, the current number is `0`\\n   */\\n  int dfs(const string &number,\\n          const int index,\\n          const int mask,\\n          const bool has_constraints,\\n          const bool started,\\n          vector<vector<int>> &memo) {\\n    const int n_digits = static_cast<int>(number.size());\\n    if (index == n_digits) {\\n      return started ? 1 : 0;\\n    }\\n    \\n    int ret = !has_constraints && started ? memo[index][mask] : unmemorized;\\n    if (ret != unmemorized) {\\n      return ret;\\n    }\\n    \\n    ret = 0;\\n    const int digit = number[index] - zero;\\n    const int end_digit = has_constraints ? digit + 1 : digits;\\n    for (int d = 0; d < end_digit; ++d) {\\n      if (((mask >> d) & 0b1) == 0b0) {\\n        const int next_started = started || d != 0;\\n        const int next_mask = next_started ? (mask | (1 << d)) : 0;\\n        ret += dfs(number, index + 1, next_mask, (has_constraints && d == digit), next_started, memo);\\n      }\\n    }\\n    \\n    if (!has_constraints && started) {\\n      memo[index][mask] = ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_digits)\\n * Space Complexity: O(n_digits)\\n * where `n_digits` is the number of the digits of the integer `n`\\n */\\nclass Solution {\\n private:\\n  static constexpr int digits = 10;\\n  static constexpr char zero = \\'0\\';\\n  static constexpr int n_masks = 1 << digits;\\n  static constexpr int unmemorized = -1;\\n  \\n public:\\n  int numDupDigitsAtMostN(const int n) {\\n    return n - no_duplicates(n);\\n  }\\n  \\n private:\\n  int no_duplicates(const int num) {\\n    const string number(to_string(num));\\n    const int n_digits = static_cast<int>(number.size());\\n    vector<vector<int>> memo(n_digits, vector<int>(n_masks, unmemorized));\\n    return dfs(number, 0, 0, true, false, memo);\\n  }\\n  \\n  /**\\n   * return the number of the integers which don\\'t contain any duplicate digits,\\n   *        starting from the `index`\\'th digit\\n   *\\n   * @param index: the index of the current digit\\n   * @param mask: the bit mask indicating the previous digits before the `index`\\'th digits\\n   * @param has_constraints: if it\\'s true, the current digit (`index`\\'th digit) cannot exceed `number[index]`\\n   *                         if not, the current digit can reach `9`\\n   * @param started: if it\\'s true, the current number is greater than `0`\\n   *                 if not, the current number is `0`\\n   */\\n  int dfs(const string &number,\\n          const int index,\\n          const int mask,\\n          const bool has_constraints,\\n          const bool started,\\n          vector<vector<int>> &memo) {\\n    const int n_digits = static_cast<int>(number.size());\\n    if (index == n_digits) {\\n      return started ? 1 : 0;\\n    }\\n    \\n    int ret = !has_constraints && started ? memo[index][mask] : unmemorized;\\n    if (ret != unmemorized) {\\n      return ret;\\n    }\\n    \\n    ret = 0;\\n    const int digit = number[index] - zero;\\n    const int end_digit = has_constraints ? digit + 1 : digits;\\n    for (int d = 0; d < end_digit; ++d) {\\n      if (((mask >> d) & 0b1) == 0b0) {\\n        const int next_started = started || d != 0;\\n        const int next_mask = next_started ? (mask | (1 << d)) : 0;\\n        ret += dfs(number, index + 1, next_mask, (has_constraints && d == digit), next_started, memo);\\n      }\\n    }\\n    \\n    if (!has_constraints && started) {\\n      memo[index][mask] = ret;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582582,
                "title": "my-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        String str = String.valueOf(n);\\n        int len = str.length();\\n        \\n        // all number with no repeat and length < len\\n        int unique = 0;\\n        for (int i = 1; i < len; i++) {\\n            unique += totalNoRepeat(i);\\n        }\\n        \\n\\t\\t// all number with no repeat and length == len\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        for (i = 0; i < len; i++) {\\n            int d = str.charAt(i) - \\'0\\';\\n            \\n            int temp = pivotChoice(set, d, i == 0);\\n            for (int j = i+1; j < len; j++) {\\n                temp *= (10 - j);\\n            }\\n            \\n            unique += temp;\\n            if (!set.add(d)) break;       // no need to continue after seeing repeated digits\\n        }\\n        \\n        if (i == len) unique++;      // the number n itself\\n        \\n        return n - unique;\\n    }\\n    \\n    private int totalNoRepeat(int d) {\\n        int res = 9;\\n        for (int i = 1; i < d; i++) {\\n            res *= (10 - i);\\n        }\\n        return res;\\n    }\\n    \\n    private int pivotChoice(Set<Integer> set, int d, boolean first) {\\n        int res = 0;\\n        int i = (first ? 1 : 0);\\n        \\n        while (i < d) {\\n            if (!set.contains(i++)) res++;\\n        }\\n        \\n        return res;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485031,
                "title": "c-3d-digit-dp-using-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fn(vector<vector<vector<int>>> &dp, string &s, int i,int bound,int bit)\\n    {\\n        if(i==s.size())\\n        {\\n            if(bit!=0)\\n             return 1;\\n             return 0;\\n        }\\n\\n        if( dp[i][bound][bit]!=-1)\\n        return dp[i][bound][bit];\\n        int maxdigit;\\n        if(bound)\\n        maxdigit = s[i]-\\'0\\';\\n        else\\n        maxdigit = 9;\\n        int ans = 0;\\n        for(int j=0;j<=maxdigit;j++)\\n        {\\n             \\n            if((bit&(1<<j))!=0){\\n              continue;\\n            }\\n            else if(bit==0 && j==0)\\n            {\\n                ans+=fn(dp,s,i+1,bound&&(maxdigit==j),0);\\n            }\\n            else\\n            ans+=fn(dp,s,i+1,bound&&(maxdigit==j),(bit|(1<<j)));\\n        }\\n     \\n        return dp[i][bound][bit] = ans;\\n        \\n\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp(s.size()+1,vector<vector<int>>(3,vector<int>(pow(2,10)+1,-1)));\\n        return n-fn(dp,s,0,1,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fn(vector<vector<vector<int>>> &dp, string &s, int i,int bound,int bit)\\n    {\\n        if(i==s.size())\\n        {\\n            if(bit!=0)\\n             return 1;\\n             return 0;\\n        }\\n\\n        if( dp[i][bound][bit]!=-1)\\n        return dp[i][bound][bit];\\n        int maxdigit;\\n        if(bound)\\n        maxdigit = s[i]-\\'0\\';\\n        else\\n        maxdigit = 9;\\n        int ans = 0;\\n        for(int j=0;j<=maxdigit;j++)\\n        {\\n             \\n            if((bit&(1<<j))!=0){\\n              continue;\\n            }\\n            else if(bit==0 && j==0)\\n            {\\n                ans+=fn(dp,s,i+1,bound&&(maxdigit==j),0);\\n            }\\n            else\\n            ans+=fn(dp,s,i+1,bound&&(maxdigit==j),(bit|(1<<j)));\\n        }\\n     \\n        return dp[i][bound][bit] = ans;\\n        \\n\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        vector<vector<vector<int>>> dp(s.size()+1,vector<vector<int>>(3,vector<int>(pow(2,10)+1,-1)));\\n        return n-fn(dp,s,0,1,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398749,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n) ;\\n        int len = s.size() ;\\n        int specialNum = 0 ;\\n        for(int i = 1 ; i <= len-1; i++)\\n            specialNum += 9 * permu(9, i-1) ;\\n        \\n        vector<bool>used(10) ;\\n        dfs(s, 0, used, specialNum) ;\\n        return specialNum ;\\n    }\\n    void dfs(const string& s, int cur, vector<bool>& used, int& specialNum ){\\n        if(cur == s.size()){\\n            specialNum++ ;\\n            return ;\\n        }\\n        \\n        for(int d = 0; d <= 9; d++){\\n            if(cur == 0 && d == 0)\\n                continue ;\\n            if(used[d])\\n                continue ;\\n            if(d < s[cur] - \\'0\\'){\\n                specialNum += permu(10-(cur+1), s.size()-(cur+1)) ;\\n            }\\n            else if(d == s[cur] -\\'0\\'){\\n                used[d] = true ;\\n                dfs(s, cur+1, used, specialNum) ;\\n                used[d] = false ;\\n            }\\n            else\\n                break ;\\n        }\\n    }\\n                \\n    int permu(int m, int n){\\n        if(n == 0)\\n            return 1 ;\\n        int ret = 1 ;\\n        for(int i = 0; i < n; i++)\\n            ret *= (m-i) ;\\n        return ret ;\\n    }    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        return n - countSpecialNumbers(n) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n) ;\\n        int len = s.size() ;\\n        int specialNum = 0 ;\\n        for(int i = 1 ; i <= len-1; i++)\\n            specialNum += 9 * permu(9, i-1) ;\\n        \\n        vector<bool>used(10) ;\\n        dfs(s, 0, used, specialNum) ;\\n        return specialNum ;\\n    }\\n    void dfs(const string& s, int cur, vector<bool>& used, int& specialNum ){\\n        if(cur == s.size()){\\n            specialNum++ ;\\n            return ;\\n        }\\n        \\n        for(int d = 0; d <= 9; d++){\\n            if(cur == 0 && d == 0)\\n                continue ;\\n            if(used[d])\\n                continue ;\\n            if(d < s[cur] - \\'0\\'){\\n                specialNum += permu(10-(cur+1), s.size()-(cur+1)) ;\\n            }\\n            else if(d == s[cur] -\\'0\\'){\\n                used[d] = true ;\\n                dfs(s, cur+1, used, specialNum) ;\\n                used[d] = false ;\\n            }\\n            else\\n                break ;\\n        }\\n    }\\n                \\n    int permu(int m, int n){\\n        if(n == 0)\\n            return 1 ;\\n        int ret = 1 ;\\n        for(int i = 0; i < n; i++)\\n            ret *= (m-i) ;\\n        return ret ;\\n    }    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        return n - countSpecialNumbers(n) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339775,
                "title": "recursion-counting-digits-until-decimal-digit-then-fixing-digit-and-starting-over",
                "content": "# Intuition\\n\\nDisclaimer: I just added comments to Lee\\'s solution, if you like the code please consider upvoting him: https://leetcode.com/problems/numbers-with-repeated-digits/solutions/256725/java-python-count-the-number-without-repeated-digit/\\n\\n# Approach\\n- Mathematics\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/52092e6f-ca6a-4c52-85fd-7708f263bf9d_1679748770.4206126.png)\\n\\n```java\\nclass Solution {\\n\\n  public int numDupDigitsAtMostN(int N) {\\n      // Example: N = 1000\\n      // Transform N + 1 to arrayList\\n      ArrayList<Integer> L = new ArrayList<Integer>();\\n      for (int x = N + 1; x > 0; x /= 10)\\n          L.add(0, x % 10); // Convert N+1 to a list of digits, L = [1, 0, 0, 1]\\n\\n      // Count the number of non-duplicate digits numbers < N\\n      int res = 0, n = L.size();\\n      for (int i = 1; i < n; ++i)\\n          res += 9 * A(9, i - 1); // Calculate permutations with non-duplicate digits, res = 738 //(9 + 9*9 + 9*9*8)\\n                                  // the usual permutation is 10+10*9+10*9*8.. but we use 9 on the left to exclude\\n                                  // leading zeros\\n\\n      // Count the number of non-duplicate digits numbers with the same prefix\\n      HashSet<Integer> seen = new HashSet<>();\\n      for (int i = 0; i < n; ++i) {\\n          for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j) {  // j=i>0?0:1 is because the leftmost digit cannot\\n                                                            // start with 0, otherwise there would be numbers with\\n                                                            // leading zeroes.\\n              // We must avoid ranges that have digits equal to the ones we fixed to the left.\\n              if (!seen.contains(j)) {\\n                  // Add permutations for this prefix\\n                  res += A(9 - i, n - i - 1); // As j=1=L.get(0) on the for, we neve enter the if in the example\\n              }\\n          }\\n          // if N=ABCD.. after processing (1~A-1)XXX, then we will process A(1~B-1)XXX and so on, but if at some\\n          // point a X is equal to any of the numbers precossed to the left we must stop as ALL NUMBERS will have\\n          // at least 2 duplicated numbers\\n          if (seen.contains(L.get(i))) break;\\n          // after processing 0 (or 1) to A-1 (or B-1 or so on) we are fixxing A (or B or..) to the left, so we\\n          // add it also to seen.\\n          seen.add(L.get(i));\\n      }\\n      // Return N - number of non-duplicate digits numbers to get the count of numbers with duplicate digits\\n      // N - res = 1000 - 738 = 262 (262 numbers have at least one repeated digit)\\n      return N - res;\\n  }\\n\\n  // Calculate permutations: A(m, n) = m! / (m-n)!\\n  public int A(int m, int n) {\\n      return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n  }\\n}\\n```\\nThis is my version of the code. Same idea different details\\n```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        for(int i=n+1;i>0;i/=10) l.add(i%10);\\n        // All the possible numbers. We will remove the numbers\\n        // with unique digits\\n        int r=n;\\n        // Remove all the numbers with unique digits with size\\n        // \\'l.size()-1\\'. The leftmost digit only has 9 candidates\\n        // as we avoid leading zeros\\n        for(int i=1;i<l.size();i++) r-=9*perm(9,i-1);\\n        Set<Integer> fixed=new HashSet<>();\\n        for(int i=l.size()-1;i>-1;i--) {\\n            int curr=l.get(i);\\n            for(int j=i==l.size()-1?1:0;j<curr;j++) {\\n                // if j has been used (fixed) we cannot use it\\n                if(fixed.contains(j)) continue;\\n                // 10 - 1 - fixed.size() //(10 - the digit j -\\n                // already used/fixed didits)// premuted in i\\n                // spaces\\n                r-=perm(9-fixed.size(),i);\\n            }\\n            // if the i-th has already been fixed lets stop, as\\n            // all digits from now on will be duplicated\\n            if(fixed.contains(curr)) break;\\n            // lets fix the i-th digit on the left\\n            fixed.add(curr);\\n        }\\n        return r;\\n    }\\n    // Permutation of A digits in B spaces\\n    int perm(int a, int b) {\\n        int r=1;\\n        for(int i=0;i<b;i++) r*=a--;\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n\\n  public int numDupDigitsAtMostN(int N) {\\n      // Example: N = 1000\\n      // Transform N + 1 to arrayList\\n      ArrayList<Integer> L = new ArrayList<Integer>();\\n      for (int x = N + 1; x > 0; x /= 10)\\n          L.add(0, x % 10); // Convert N+1 to a list of digits, L = [1, 0, 0, 1]\\n\\n      // Count the number of non-duplicate digits numbers < N\\n      int res = 0, n = L.size();\\n      for (int i = 1; i < n; ++i)\\n          res += 9 * A(9, i - 1); // Calculate permutations with non-duplicate digits, res = 738 //(9 + 9*9 + 9*9*8)\\n                                  // the usual permutation is 10+10*9+10*9*8.. but we use 9 on the left to exclude\\n                                  // leading zeros\\n\\n      // Count the number of non-duplicate digits numbers with the same prefix\\n      HashSet<Integer> seen = new HashSet<>();\\n      for (int i = 0; i < n; ++i) {\\n          for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j) {  // j=i>0?0:1 is because the leftmost digit cannot\\n                                                            // start with 0, otherwise there would be numbers with\\n                                                            // leading zeroes.\\n              // We must avoid ranges that have digits equal to the ones we fixed to the left.\\n              if (!seen.contains(j)) {\\n                  // Add permutations for this prefix\\n                  res += A(9 - i, n - i - 1); // As j=1=L.get(0) on the for, we neve enter the if in the example\\n              }\\n          }\\n          // if N=ABCD.. after processing (1~A-1)XXX, then we will process A(1~B-1)XXX and so on, but if at some\\n          // point a X is equal to any of the numbers precossed to the left we must stop as ALL NUMBERS will have\\n          // at least 2 duplicated numbers\\n          if (seen.contains(L.get(i))) break;\\n          // after processing 0 (or 1) to A-1 (or B-1 or so on) we are fixxing A (or B or..) to the left, so we\\n          // add it also to seen.\\n          seen.add(L.get(i));\\n      }\\n      // Return N - number of non-duplicate digits numbers to get the count of numbers with duplicate digits\\n      // N - res = 1000 - 738 = 262 (262 numbers have at least one repeated digit)\\n      return N - res;\\n  }\\n\\n  // Calculate permutations: A(m, n) = m! / (m-n)!\\n  public int A(int m, int n) {\\n      return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n  }\\n}\\n```\n```java\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        ArrayList<Integer> l=new ArrayList<>();\\n        for(int i=n+1;i>0;i/=10) l.add(i%10);\\n        // All the possible numbers. We will remove the numbers\\n        // with unique digits\\n        int r=n;\\n        // Remove all the numbers with unique digits with size\\n        // \\'l.size()-1\\'. The leftmost digit only has 9 candidates\\n        // as we avoid leading zeros\\n        for(int i=1;i<l.size();i++) r-=9*perm(9,i-1);\\n        Set<Integer> fixed=new HashSet<>();\\n        for(int i=l.size()-1;i>-1;i--) {\\n            int curr=l.get(i);\\n            for(int j=i==l.size()-1?1:0;j<curr;j++) {\\n                // if j has been used (fixed) we cannot use it\\n                if(fixed.contains(j)) continue;\\n                // 10 - 1 - fixed.size() //(10 - the digit j -\\n                // already used/fixed didits)// premuted in i\\n                // spaces\\n                r-=perm(9-fixed.size(),i);\\n            }\\n            // if the i-th has already been fixed lets stop, as\\n            // all digits from now on will be duplicated\\n            if(fixed.contains(curr)) break;\\n            // lets fix the i-th digit on the left\\n            fixed.add(curr);\\n        }\\n        return r;\\n    }\\n    // Permutation of A digits in B spaces\\n    int perm(int a, int b) {\\n        int r=1;\\n        for(int i=0;i<b;i++) r*=a--;\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331923,
                "title": "rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        n - Self::num_not_dup_digits_at_most_n(n)\\n    }\\n\\n    fn num_not_dup_digits_at_most_n(n: i32) -> i32 {\\n        let mut n = n;\\n        let mut digits = Vec::new();\\n\\n        while n > 0 {\\n            digits.push(n % 10);\\n            n /= 10;\\n        }\\n\\n        let k = digits.len();\\n\\n        let mut used: [i32; 10] = [0; 10];\\n        let mut total = 0;\\n\\n        for i in 1..k {\\n            total += 9 * Self::permutation(9, i as i32 - 1);\\n        }\\n\\n        for i in 0..k {\\n            let i = k - 1 - i;\\n            let num = digits[i];\\n\\n            for j in (if i == k - 1 { 1 } else { 0 })..num {\\n                if used[j as usize] != 0 {\\n                    continue;\\n                }\\n                total += Self::permutation((10 - k + i) as i32, i as i32);\\n            }\\n\\n            used[num as usize] += 1;\\n            if used[num as usize] > 1 {\\n                break;\\n            }\\n\\n            if i == 0 {\\n                total += 1;\\n            }\\n        }\\n\\n        total\\n    }\\n\\n    fn permutation(n: i32, k: i32) -> i32 {\\n        Self::factorial(n) / Self::factorial(n - k)\\n    }\\n\\n    fn factorial(n: i32) -> i32 {\\n        match n {\\n            0 | 1 => 1,\\n            n @ _ => n * Self::factorial(n - 1),\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        n - Self::num_not_dup_digits_at_most_n(n)\\n    }\\n\\n    fn num_not_dup_digits_at_most_n(n: i32) -> i32 {\\n        let mut n = n;\\n        let mut digits = Vec::new();\\n\\n        while n > 0 {\\n            digits.push(n % 10);\\n            n /= 10;\\n        }\\n\\n        let k = digits.len();\\n\\n        let mut used: [i32; 10] = [0; 10];\\n        let mut total = 0;\\n\\n        for i in 1..k {\\n            total += 9 * Self::permutation(9, i as i32 - 1);\\n        }\\n\\n        for i in 0..k {\\n            let i = k - 1 - i;\\n            let num = digits[i];\\n\\n            for j in (if i == k - 1 { 1 } else { 0 })..num {\\n                if used[j as usize] != 0 {\\n                    continue;\\n                }\\n                total += Self::permutation((10 - k + i) as i32, i as i32);\\n            }\\n\\n            used[num as usize] += 1;\\n            if used[num as usize] > 1 {\\n                break;\\n            }\\n\\n            if i == 0 {\\n                total += 1;\\n            }\\n        }\\n\\n        total\\n    }\\n\\n    fn permutation(n: i32, k: i32) -> i32 {\\n        Self::factorial(n) / Self::factorial(n - k)\\n    }\\n\\n    fn factorial(n: i32) -> i32 {\\n        match n {\\n            0 | 1 => 1,\\n            n @ _ => n * Self::factorial(n - 1),\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216731,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return N - res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165129,
                "title": "digit-dp-count-with-no-repetition-and-return-remaining",
                "content": "```\\nclass Solution:\\n    def count(self, num, i, n, tight, used):\\n        if i >= n:\\n            return 1\\n        key = (i, tight, used)\\n        if key in self.cache:\\n            return self.cache[key]\\n        maxd = 9\\n        if tight:\\n            maxd = int(num[i])\\n        res = 0\\n        for d in range(maxd + 1):\\n            if not used & (1 << d):\\n                newused = used | (1 << d)\\n                if used == 0 and d == 0:\\n                    newused = used\\n                res += self.count(num, i + 1, n, tight and d == maxd, newused)\\n        self.cache[key] = res\\n        return res\\n    \\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        self.cache = {}\\n        num = str(n)\\n        return n - self.count(num, 0, len(num), True, 0) + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num, i, n, tight, used):\\n        if i >= n:\\n            return 1\\n        key = (i, tight, used)\\n        if key in self.cache:\\n            return self.cache[key]\\n        maxd = 9\\n        if tight:\\n            maxd = int(num[i])\\n        res = 0\\n        for d in range(maxd + 1):\\n            if not used & (1 << d):\\n                newused = used | (1 << d)\\n                if used == 0 and d == 0:\\n                    newused = used\\n                res += self.count(num, i + 1, n, tight and d == maxd, newused)\\n        self.cache[key] = res\\n        return res\\n    \\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        self.cache = {}\\n        num = str(n)\\n        return n - self.count(num, 0, len(num), True, 0) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160997,
                "title": "easy-digit-dp-solution-with-c",
                "content": "# Intuition\\n\\nThe idea of this solution is to count the number of integers with unique digits from 0 to N, Then substruct the number from n.\\n\\n# Approach\\nWe can use Digit dp with 4 parameters, The first one is the number of the index, and the 2nd one is the tight variable(It will save us exceeding the given number range), the 3rd one keeps track of the leading zero and the 4th one will keep track the numbers that have been used.\\n\\nsuppose we have 2 indexes. If we use 0 in the 2nd index then we will have 9 numbers to put in the 1st index,(1-->9). And if we use 1 in the 2nd index, then we will also have 9 numbers to put in the 1st index.(0,2-->9). \\nIf you go through the code , the approach will become more clear to you.\\n\\n \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[12][2][2][10];\\n\\n    int calc(string& s, int ind, int tight, int parbo, set<int>&v) {\\n        if (ind == 0) {\\n            if (parbo == 1) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int n = v.size();\\n        if (dp[ind][tight][parbo][n] != -1)return dp[ind][tight][parbo][n];\\n        // Check the upper Bound\\n        int ub = tight == 1 ? (s[s.size() - ind] - \\'0\\') : 9;\\n        int ans = 0;\\n        // Filling index with leading zeroes.\\n        if (parbo == 1) {\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 1, v);\\n        }\\n        // the zero i put will not be a leading zero if a have put a number (1-->9) before this index\\n        else if (v.find(0) == v.end()) {// checking if i have used 0 before\\n            v.insert(0);\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 0, v);\\n            v.erase(v.find(0));\\n        }\\n        for (int i = 1; i <= ub; i++) {\\n            if (v.find(i) == v.end()) {\\n                v.insert(i);\\n                ans += calc(s, ind - 1, (tight & (i == ub)), 0, v);\\n                v.erase(v.find(i));\\n            }\\n        }\\n        return dp[ind][tight][parbo][n] =  ans;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string S = to_string(n);\\n        set<int>v;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = calc(S, S.size(), 1, 1, v);\\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[12][2][2][10];\\n\\n    int calc(string& s, int ind, int tight, int parbo, set<int>&v) {\\n        if (ind == 0) {\\n            if (parbo == 1) {\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        int n = v.size();\\n        if (dp[ind][tight][parbo][n] != -1)return dp[ind][tight][parbo][n];\\n        // Check the upper Bound\\n        int ub = tight == 1 ? (s[s.size() - ind] - \\'0\\') : 9;\\n        int ans = 0;\\n        // Filling index with leading zeroes.\\n        if (parbo == 1) {\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 1, v);\\n        }\\n        // the zero i put will not be a leading zero if a have put a number (1-->9) before this index\\n        else if (v.find(0) == v.end()) {// checking if i have used 0 before\\n            v.insert(0);\\n            ans += calc(s, ind - 1, (tight & (0 == ub)), 0, v);\\n            v.erase(v.find(0));\\n        }\\n        for (int i = 1; i <= ub; i++) {\\n            if (v.find(i) == v.end()) {\\n                v.insert(i);\\n                ans += calc(s, ind - 1, (tight & (i == ub)), 0, v);\\n                v.erase(v.find(i));\\n            }\\n        }\\n        return dp[ind][tight][parbo][n] =  ans;\\n    }\\n\\n    int numDupDigitsAtMostN(int n) {\\n        string S = to_string(n);\\n        set<int>v;\\n        memset(dp, -1, sizeof(dp));\\n        int ans = calc(S, S.size(), 1, 1, v);\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063291,
                "title": "simple-python-solution-but-time-limit-exceed",
                "content": "class Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        count=0\\n        for i in range(1,n+1):\\n            temp=str(i)\\n            d={}\\n            for i in temp:\\n                if i in d:\\n                    count+=1\\n                    break\\n                else:\\n                    d[i]=1\\n       return count",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "class Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        count=0\\n        for i in range(1,n+1):\\n            temp=str(i)\\n            d={}",
                "codeTag": "Java"
            },
            {
                "id": 3029660,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        fn _a(m: i32, n: i32) -> i32 {\\n            if n == 0 {\\n                1\\n            } else {\\n                _a(m, n - 1) * (m - n + 1)\\n            }\\n        }\\n\\n        let mut digits = Vec::new();\\n        let mut x = n + 1;\\n        while x > 0 {\\n            digits.insert(0, x % 10);\\n            x /= 10;\\n        }\\n\\n        let mut res = 0;\\n        let len = digits.len();\\n        for i in 1..len {\\n            res += 9 * _a(9, i as i32 - 1);\\n        }\\n\\n        let mut seen = std::collections::HashSet::new();\\n        for (i, &digit) in digits.iter().enumerate().take(len) {\\n            for j in i32::from(i == 0)..digit {\\n                if !seen.contains(&j) {\\n                    res += _a(9 - i as i32, len as i32 - i as i32 - 1);\\n                }\\n            }\\n            if seen.contains(&digit) {\\n                break;\\n            }\\n            seen.insert(digit);\\n        }\\n        n - res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\\n        fn _a(m: i32, n: i32) -> i32 {\\n            if n == 0 {\\n                1\\n            } else {\\n                _a(m, n - 1) * (m - n + 1)\\n            }\\n        }\\n\\n        let mut digits = Vec::new();\\n        let mut x = n + 1;\\n        while x > 0 {\\n            digits.insert(0, x % 10);\\n            x /= 10;\\n        }\\n\\n        let mut res = 0;\\n        let len = digits.len();\\n        for i in 1..len {\\n            res += 9 * _a(9, i as i32 - 1);\\n        }\\n\\n        let mut seen = std::collections::HashSet::new();\\n        for (i, &digit) in digits.iter().enumerate().take(len) {\\n            for j in i32::from(i == 0)..digit {\\n                if !seen.contains(&j) {\\n                    res += _a(9 - i as i32, len as i32 - i as i32 - 1);\\n                }\\n            }\\n            if seen.contains(&digit) {\\n                break;\\n            }\\n            seen.insert(digit);\\n        }\\n        n - res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994696,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1: continue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]: k += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n    \\tT = [9,261,4725,67509,831429,9287109,97654149,994388229]\\n    \\tt = [99,999,9999,99999,999999,9999999,99999999,999999999]\\n    \\tif N < 10:\\n    \\t\\treturn 0\\n    \\tL = len(str(N))\\n    \\tm, n = [1], []\\n    \\tg = 11-L\\n    \\tfor i in range(L):\\n    \\t\\tn.append(int(str(N)[i]))\\n    \\t\\tm.append(g)\\n    \\t\\tg = g*(12-L+i)\\n    \\tS = 0\\n    \\tfor i in range(L):\\n    \\t\\tif len(set(n[:L-i-1])) != len(n)-i-1: continue\\n    \\t\\tk = 0\\n    \\t\\tfor j in range(10):\\n    \\t\\t\\tif j not in n[:L-i-1] and j > n[L-i-1]: k += 1\\n    \\t\\tS += k*m[i]\\n    \\treturn(T[L-2]-(t[L-2]-N-S))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942870,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n  let digits = toDigits(N);\\n  let len = digits.length;\\n  //console.log(digits);\\n\\n  let d = 0;\\n\\n  //1 to 10^{len-1}-1\\n  for (let r = 1; r < len; r++) {\\n    let dr = countDiff(r);\\n    d += dr;\\n  }\\n\\n  //10^len to N-1\\n  for (let i = 0; i < len; i++) {\\n    let di = countDiff1(digits, i);\\n    d += di;\\n  }\\n\\n  //N\\n  if (isDuplicated(digits, len) == false) d++;\\n\\n  return N - d;\\n};\\n\\nfunction countDiff(r) {\\n  //print range\\n  let start = [1];\\n  for (let j = 1; j < r; j++) start.push(0);\\n  let end = [];\\n  for (let j = 0; j < r; j++) end.push(9);\\n  //console.log(`scan ${start} to ${end}`);\\n\\n  //first digit starts from 1\\n  let d = 9 * permutation(r - 1, 9);\\n  //console.log(`\\\\tr=${r} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction countDiff1(digits, i) {\\n  //print range\\n  let start = digits.slice(0, i + 1);\\n  start[i] = i == 0 ? 1 : 0;\\n  for (let j = i + 1; j < digits.length; j++) start.push(0);\\n  let end = digits.slice(0, i + 1);\\n  end[i] = end[i] - 1;\\n  for (let j = i + 1; j < digits.length; j++) end.push(9);\\n  //console.log(`scan2 from ${start} to ${end}`);\\n\\n  if (start[i] > end[i]) return 0;\\n\\n  //duplicated\\n  if (isDuplicated(digits, i)) return 0;\\n\\n  let remainingDigits = getRemainingDigits(digits, i);\\n\\n  //keep di\\n  let r = digits.length - 1 - i; //remaining len\\n  let n = 10 - i - 1; //remaining digits 0-9\\n  let d = remainingDigits * permutation(r, n);\\n  //console.log(`\\\\tr=${r} n=${n} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction getRemainingDigits(digits, i) {\\n  let used = getUsedDigits(digits, i);\\n\\n  let start = i == 0 ? 1 : 0;\\n  let end = digits[i] - 1;\\n\\n  let x = [];\\n  for (let i = start; i <= end; i++) {\\n    if (!used.has(i)) x.push(i);\\n  }\\n\\n  return x.length;\\n}\\n\\nfunction getUsedDigits(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (!map.has(d)) map.set(d, 1);\\n  }\\n\\n  return map;\\n}\\n\\nfunction isDuplicated(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (map.has(d)) return true;\\n\\n    map.set(d, 1);\\n  }\\n\\n  return false;\\n}\\n\\nfunction toDigits(n) {\\n  let a = new Array();\\n\\n  while (n > 0) {\\n    let d = n % 10;\\n    a.push(d);\\n\\n    n = Math.floor(n / 10);\\n  }\\n\\n  a.reverse();\\n\\n  return a;\\n}\\n\\nfunction permutation(r, n) {\\n  if (r == 0) return 1;\\n\\n  let p = 1;\\n  for (let i = 0; i < r; i++) {\\n    p *= n - i;\\n  }\\n\\n  return p;\\n}\\n\\nconsole.log(numDupDigitsAtMostN(1000));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n  let digits = toDigits(N);\\n  let len = digits.length;\\n  //console.log(digits);\\n\\n  let d = 0;\\n\\n  //1 to 10^{len-1}-1\\n  for (let r = 1; r < len; r++) {\\n    let dr = countDiff(r);\\n    d += dr;\\n  }\\n\\n  //10^len to N-1\\n  for (let i = 0; i < len; i++) {\\n    let di = countDiff1(digits, i);\\n    d += di;\\n  }\\n\\n  //N\\n  if (isDuplicated(digits, len) == false) d++;\\n\\n  return N - d;\\n};\\n\\nfunction countDiff(r) {\\n  //print range\\n  let start = [1];\\n  for (let j = 1; j < r; j++) start.push(0);\\n  let end = [];\\n  for (let j = 0; j < r; j++) end.push(9);\\n  //console.log(`scan ${start} to ${end}`);\\n\\n  //first digit starts from 1\\n  let d = 9 * permutation(r - 1, 9);\\n  //console.log(`\\\\tr=${r} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction countDiff1(digits, i) {\\n  //print range\\n  let start = digits.slice(0, i + 1);\\n  start[i] = i == 0 ? 1 : 0;\\n  for (let j = i + 1; j < digits.length; j++) start.push(0);\\n  let end = digits.slice(0, i + 1);\\n  end[i] = end[i] - 1;\\n  for (let j = i + 1; j < digits.length; j++) end.push(9);\\n  //console.log(`scan2 from ${start} to ${end}`);\\n\\n  if (start[i] > end[i]) return 0;\\n\\n  //duplicated\\n  if (isDuplicated(digits, i)) return 0;\\n\\n  let remainingDigits = getRemainingDigits(digits, i);\\n\\n  //keep di\\n  let r = digits.length - 1 - i; //remaining len\\n  let n = 10 - i - 1; //remaining digits 0-9\\n  let d = remainingDigits * permutation(r, n);\\n  //console.log(`\\\\tr=${r} n=${n} d=${d}`);\\n\\n  return d;\\n}\\n\\nfunction getRemainingDigits(digits, i) {\\n  let used = getUsedDigits(digits, i);\\n\\n  let start = i == 0 ? 1 : 0;\\n  let end = digits[i] - 1;\\n\\n  let x = [];\\n  for (let i = start; i <= end; i++) {\\n    if (!used.has(i)) x.push(i);\\n  }\\n\\n  return x.length;\\n}\\n\\nfunction getUsedDigits(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (!map.has(d)) map.set(d, 1);\\n  }\\n\\n  return map;\\n}\\n\\nfunction isDuplicated(digits, i) {\\n  let map = new Map();\\n\\n  for (let j = 0; j < i; j++) {\\n    let d = digits[j];\\n\\n    //duplicated\\n    if (map.has(d)) return true;\\n\\n    map.set(d, 1);\\n  }\\n\\n  return false;\\n}\\n\\nfunction toDigits(n) {\\n  let a = new Array();\\n\\n  while (n > 0) {\\n    let d = n % 10;\\n    a.push(d);\\n\\n    n = Math.floor(n / 10);\\n  }\\n\\n  a.reverse();\\n\\n  return a;\\n}\\n\\nfunction permutation(r, n) {\\n  if (r == 0) return 1;\\n\\n  let p = 1;\\n  for (let i = 0; i < r; i++) {\\n    p *= n - i;\\n  }\\n\\n  return p;\\n}\\n\\nconsole.log(numDupDigitsAtMostN(1000));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2919057,
                "title": "digit-dp-using-bitmask-recursive-memoization-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[10][2050][2][12];\\n    int solve(string &s, int dig, int mask, int IsTight, int digit)\\n    {\\n        int ub = 9, ans = 0;\\n        if(dp[dig][mask][IsTight][digit] != -1)return dp[dig][mask][IsTight][digit];\\n        if(dig == s.size())\\n        {\\n            int cnt = 0;\\n            for(int i=0;i<=9;i++)if(mask & (1 << i))cnt++;\\n            if(digit == 11 || cnt == s.size()-digit)return dp[dig][mask][IsTight][digit] = 0;\\n            return dp[dig][mask][IsTight][digit] = 1;\\n        }\\n        if(IsTight)ub = s[dig]-\\'0\\';\\n        if(digit == 11)\\n        {\\n            ans += solve(s, dig+1, mask, 0, 11);\\n            for(int i=1;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,dig);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,dig);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,dig);\\n        }\\n        else\\n        {\\n            for(int i=0;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,digit);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,digit);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,digit);\\n        }\\n        return dp[dig][mask][IsTight][digit] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1 , sizeof(dp));\\n        // reverse(s.begin(),s.end());\\n        if(n <= 10)return 0;\\n        return solve(s, 0, 0, 1, 11);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][2050][2][12];\\n    int solve(string &s, int dig, int mask, int IsTight, int digit)\\n    {\\n        int ub = 9, ans = 0;\\n        if(dp[dig][mask][IsTight][digit] != -1)return dp[dig][mask][IsTight][digit];\\n        if(dig == s.size())\\n        {\\n            int cnt = 0;\\n            for(int i=0;i<=9;i++)if(mask & (1 << i))cnt++;\\n            if(digit == 11 || cnt == s.size()-digit)return dp[dig][mask][IsTight][digit] = 0;\\n            return dp[dig][mask][IsTight][digit] = 1;\\n        }\\n        if(IsTight)ub = s[dig]-\\'0\\';\\n        if(digit == 11)\\n        {\\n            ans += solve(s, dig+1, mask, 0, 11);\\n            for(int i=1;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,dig);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,dig);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,dig);\\n        }\\n        else\\n        {\\n            for(int i=0;i<ub;i++)ans += solve(s, dig + 1,mask | (1 << i),0,digit);\\n            if(!IsTight)ans += solve(s, dig + 1, mask | (1 << ub),0,digit);\\n            else  ans += solve(s, dig + 1, mask | (1 << ub),1,digit);\\n        }\\n        return dp[dig][mask][IsTight][digit] = ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1 , sizeof(dp));\\n        // reverse(s.begin(),s.end());\\n        if(n <= 10)return 0;\\n        return solve(s, 0, 0, 1, 11);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907178,
                "title": "python-solution-count-numbers-with-non-repeating-digits",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        limit, s = list(map(int, str(N + 1))), set()\\n        n, res = len(limit), sum(9 * perm(9, i) for i in range(len(limit) - 1))\\n        for i, x in enumerate(limit):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: \\n                break\\n            s.add(x)\\n        return N - res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        limit, s = list(map(int, str(N + 1))), set()\\n        n, res = len(limit), sum(9 * perm(9, i) for i in range(len(limit) - 1))\\n        for i, x in enumerate(limit):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: \\n                break\\n            s.add(x)\\n        return N - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884796,
                "title": "python-simple-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n):\\n        ans = [int(i) for i in str(n)]\\n        \\n        @lru_cache(None)\\n        def dp(pos,tight,mask):\\n            if pos == len(ans):\\n                return 1\\n\\n            total = 0\\n\\n            upperlimit = ans[pos] if tight else 9\\n\\n            for d in range(upperlimit+1):\\n                if mask&(1<<d):\\n                    continue\\n\\n                new_tight = tight and d == upperlimit\\n                new_mask = mask if mask == 0 and d == 0 else mask|(1<<d)\\n\\n                total += dp(pos+1,new_tight,new_mask)\\n\\n            return total\\n\\n        return n - (dp(0,True,0) - 1)\\n\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n):\\n        ans = [int(i) for i in str(n)]\\n        \\n        @lru_cache(None)\\n        def dp(pos,tight,mask):\\n            if pos == len(ans):\\n                return 1\\n\\n            total = 0\\n\\n            upperlimit = ans[pos] if tight else 9\\n\\n            for d in range(upperlimit+1):\\n                if mask&(1<<d):\\n                    continue\\n\\n                new_tight = tight and d == upperlimit\\n                new_mask = mask if mask == 0 and d == 0 else mask|(1<<d)\\n\\n                total += dp(pos+1,new_tight,new_mask)\\n\\n            return total\\n\\n        return n - (dp(0,True,0) - 1)\\n\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821335,
                "title": "numbers-with-repeated-digits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<int> V;\\n        int n2 = n;\\n        while(n2){\\n            V.emplace_back(n2%10);\\n            n2/=10;\\n        }\\n        int len = V.size();\\n        \\n        int sum = 0;\\n        for(int i = 0; i < len-1; i++){\\n            sum += 9*A(9,i);\\n        }\\n        \\n        vector<int> dig_visited(10,0);\\n        for(int i = len-1; i >= 0; i--){\\n            int dig = V[i];\\n            int count = 0;\\n            for(int j = 0; j < dig; j++){\\n                if(dig_visited[j]){continue;}\\n                count++;\\n            }\\n            if(i == len-1){count--;}\\n            sum += count*A(10-(len-i), i);\\n            if(dig_visited[dig]){break;}\\n            if(i == 0 && dig_visited[dig] == 0){sum++;}\\n            dig_visited[dig] = 1;\\n        }\\n        \\n        return n - sum;\\n    }\\n    \\n    int A(int num, int len){\\n        int tmp = 1;\\n        for(int i = 0; i < len; i++){tmp *= (num-i);}\\n        return tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787947,
                "title": "c-100-concept-find-numbers-from-1-to-n-which-are-having-non-repeating-digits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount **non-repeater** the Number Without Repeated Digit\\nThen the number with repeated digits = N - **non-repeater**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn comments I have explained whole code with examples.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g.$$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n        vector<int> prefix;   //it will store all possible permutation of those numbers which have non-repeation digit\\n    \\npublic:\\n    Solution(){\\n        prefix.push_back(0); //for zero length digit -> possible cases = 0 \\n        prefix.push_back(9);\\n        int prev=9;\\n        int cnt=9;\\n        while(cnt>0){\\n            prefix.push_back(prefix.back()+(cnt*prev));    // 9 + 9*9 + 9*9*8 + 9*9*8*7 + .... 9*9*8*7*6*5*4*3*2*1 \\n            prev*=cnt;\\n            cnt--;\\n        }\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        //find no repeatation numbers count and then subtract it with n;\\n        vector<int> hash;\\n        int temp=n;\\n        while(temp>0){\\n            hash.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        reverse(hash.begin(),hash.end());  \\n        int len=hash.size();\\n        \\n        int non_repeater=this->prefix[len-1]; // total possible cases upto given length -1 digits eg: 1000 -> 4 digits so we find upto 3 digits possible cases upto 999\\n        \\n        unordered_set<int> ap; //those number which are already present in n;\\n        \\n        //for remaining cases which are of length equals to n number\\'s digits eg: n=700 then remaining are 100 to 699 all are of 3 digit\\n        \\n        \\n        //eg: n=746 -> i=0 it will cnt -> 100 to 699 cases , then i=1  pos[0]=7->fixed & cnt-> 0 to 39 , then i=2 pos[0]=7 & pos[1]=4-> fixed & cnt->0 to 5\\n        for(int i=0;i<hash.size();i++){\\n            if(ap.size()<i){   //eg n=9999 so if i=2 therefore pos[0]=9 & pos[1]=9 are fixed and both are same so after that all cases are having repeation bcz of pos[0]&pos[1] \\n                break;\\n            }\\n            int j=0;\\n            // in first position zero is not inluded\\n            if(i==0){\\n                j=1;\\n            }\\n            int cnt=0;\\n            for(;j<hash[i];j++){\\n                if(ap.find(j)==ap.end()){\\n                    cnt++;\\n                }\\n            }\\n            \\n            int st=9-ap.size(); // those which are present in n & are now fixed like in above eg are not included\\n            for(int k=i+1;k<hash.size() && st>0;k++){\\n                cnt*=st;\\n                st--;\\n            }\\n            ap.insert(hash[i]); \\n            non_repeater+=cnt;\\n        }\\n        \\n        return n-non_repeater-(ap.size()==len); //the given number itself is checked here\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n        vector<int> prefix;   //it will store all possible permutation of those numbers which have non-repeation digit\\n    \\npublic:\\n    Solution(){\\n        prefix.push_back(0); //for zero length digit -> possible cases = 0 \\n        prefix.push_back(9);\\n        int prev=9;\\n        int cnt=9;\\n        while(cnt>0){\\n            prefix.push_back(prefix.back()+(cnt*prev));    // 9 + 9*9 + 9*9*8 + 9*9*8*7 + .... 9*9*8*7*6*5*4*3*2*1 \\n            prev*=cnt;\\n            cnt--;\\n        }\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        //find no repeatation numbers count and then subtract it with n;\\n        vector<int> hash;\\n        int temp=n;\\n        while(temp>0){\\n            hash.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        reverse(hash.begin(),hash.end());  \\n        int len=hash.size();\\n        \\n        int non_repeater=this->prefix[len-1]; // total possible cases upto given length -1 digits eg: 1000 -> 4 digits so we find upto 3 digits possible cases upto 999\\n        \\n        unordered_set<int> ap; //those number which are already present in n;\\n        \\n        //for remaining cases which are of length equals to n number\\'s digits eg: n=700 then remaining are 100 to 699 all are of 3 digit\\n        \\n        \\n        //eg: n=746 -> i=0 it will cnt -> 100 to 699 cases , then i=1  pos[0]=7->fixed & cnt-> 0 to 39 , then i=2 pos[0]=7 & pos[1]=4-> fixed & cnt->0 to 5\\n        for(int i=0;i<hash.size();i++){\\n            if(ap.size()<i){   //eg n=9999 so if i=2 therefore pos[0]=9 & pos[1]=9 are fixed and both are same so after that all cases are having repeation bcz of pos[0]&pos[1] \\n                break;\\n            }\\n            int j=0;\\n            // in first position zero is not inluded\\n            if(i==0){\\n                j=1;\\n            }\\n            int cnt=0;\\n            for(;j<hash[i];j++){\\n                if(ap.find(j)==ap.end()){\\n                    cnt++;\\n                }\\n            }\\n            \\n            int st=9-ap.size(); // those which are present in n & are now fixed like in above eg are not included\\n            for(int k=i+1;k<hash.size() && st>0;k++){\\n                cnt*=st;\\n                st--;\\n            }\\n            ap.insert(hash[i]); \\n            non_repeater+=cnt;\\n        }\\n        \\n        return n-non_repeater-(ap.size()==len); //the given number itself is checked here\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688925,
                "title": "digit-dp-python-time-o-m-space-o-m",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        A = list(map(int, str(n)))\\n        N = len(A)\\n        \\n        @cache\\n        def dp(pos, tight, mask, hasDup):\\n            if pos >= N:\\n                if hasDup:\\n                    return 1\\n                return 0\\n            \\n            upperLimit = A[pos] if tight else 9\\n            ans = 0\\n            for d in range(upperLimit + 1):\\n                tight2 = tight and d == upperLimit\\n                \\n                # mask represents the used digits:\\n                # 0000000000 <-- mask\\n                # 9876543210 <-- represented numbers\\n                \\n                # if mask is 0, it means that we haven\\'t included any digit yet,\\n                # and we if d == 0 we don\\'t want to include it, because it would result in a leading zero.\\n                mask2 = mask if mask == 0 and d == 0 else mask | (1 << d)\\n                hasDup2 = hasDup or (mask & (1 << d))\\n                ans += dp(pos + 1, tight2, mask2, hasDup2)\\n            return ans\\n            \\n        return dp(0, True, 0, False)\\n        # Time: O(m) where m is the number of digits of n.\\n        #         The other parameters of function dp are constant (2 * 2 ** 10 = 2000),\\n        #         therefore can be ignored\\n        # Space: O(m)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        A = list(map(int, str(n)))\\n        N = len(A)\\n        \\n        @cache\\n        def dp(pos, tight, mask, hasDup):\\n            if pos >= N:\\n                if hasDup:\\n                    return 1\\n                return 0\\n            \\n            upperLimit = A[pos] if tight else 9\\n            ans = 0\\n            for d in range(upperLimit + 1):\\n                tight2 = tight and d == upperLimit\\n                \\n                # mask represents the used digits:\\n                # 0000000000 <-- mask\\n                # 9876543210 <-- represented numbers\\n                \\n                # if mask is 0, it means that we haven\\'t included any digit yet,\\n                # and we if d == 0 we don\\'t want to include it, because it would result in a leading zero.\\n                mask2 = mask if mask == 0 and d == 0 else mask | (1 << d)\\n                hasDup2 = hasDup or (mask & (1 << d))\\n                ans += dp(pos + 1, tight2, mask2, hasDup2)\\n            return ans\\n            \\n        return dp(0, True, 0, False)\\n        # Time: O(m) where m is the number of digits of n.\\n        #         The other parameters of function dp are constant (2 * 2 ** 10 = 2000),\\n        #         therefore can be ignored\\n        # Space: O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683084,
                "title": "c",
                "content": "(```) class Solution {\\npublic:\\n    int dfs(long curr, int mask, int n)\\n    {\\n        if(curr > n)\\n        {\\n            return 0;\\n        }\\n        \\n        int ans = 1;\\n        \\n        for(int i=0; i<10; i++)\\n        {\\n            if(i == 0 && mask == 0)\\n            {\\n                continue;\\n            }\\n            \\n            if(mask & (1 << i))\\n            {\\n                continue;\\n            }\\n            \\n            ans += dfs(curr*10+i, mask+ (1<<i), n);\\n        }\\n        \\n        return ans;\\n       \\n    }\\n    \\n    int numDupDigitsAtMostN(int n)\\n    {\\n        return n+1 - dfs(0,0,n);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dfs(long curr, int mask, int n)\\n    {\\n        if(curr > n)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2548368,
                "title": "digit-dp-bitmasking-beginner-friendly",
                "content": "```\\nclass Solution {\\n    string s;\\n    int m;\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int f(int pos,int mask,int leadingZeros,int bound){\\n        \\n        if(pos==m)return 1;\\n        if(dp[pos][mask][leadingZeros][bound]!=-1)\\n            return dp[pos][mask][leadingZeros][bound];\\n        int maxdigit=bound?s[pos]-\\'0\\':9;\\n        int ans=0;\\n        if(leadingZeros)\\n            ans+=f(pos+1,mask,1,0);\\n        \\n        for(int digit=0;digit<=maxdigit;digit++)\\n        {   \\n            if(leadingZeros && digit==0)continue;\\n            if(mask&(1<<digit)){\\n                ans+=f(pos+1,mask^(1<<digit),0,bound&(digit==maxdigit));\\n            }\\n            \\n        }\\n        return dp[pos][mask][leadingZeros][bound]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        this->s=to_string(n);\\n        this->m=s.size();\\n        int mask=(1<<10)-1;\\n        memset(dp,-1,sizeof dp);\\n        int ans=f(0,mask,1,1)-1;\\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    string s;\\n    int m;\\npublic:\\n    int dp[10][1<<10][2][2];\\n    int f(int pos,int mask,int leadingZeros,int bound){\\n        \\n        if(pos==m)return 1;\\n        if(dp[pos][mask][leadingZeros][bound]!=-1)\\n            return dp[pos][mask][leadingZeros][bound];\\n        int maxdigit=bound?s[pos]-\\'0\\':9;\\n        int ans=0;\\n        if(leadingZeros)\\n            ans+=f(pos+1,mask,1,0);\\n        \\n        for(int digit=0;digit<=maxdigit;digit++)\\n        {   \\n            if(leadingZeros && digit==0)continue;\\n            if(mask&(1<<digit)){\\n                ans+=f(pos+1,mask^(1<<digit),0,bound&(digit==maxdigit));\\n            }\\n            \\n        }\\n        return dp[pos][mask][leadingZeros][bound]=ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        this->s=to_string(n);\\n        this->m=s.size();\\n        int mask=(1<<10)-1;\\n        memset(dp,-1,sizeof dp);\\n        int ans=f(0,mask,1,1)-1;\\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545019,
                "title": "simplified-digit-dp",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n// typedef unsigned long long ll;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e6 + 3;\\ntemplate<typename T>\\n \\n\\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint dp[10][2][(1 << 10) + 1][2][2];\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int n;\\n    int solve(int pos, int tight, int mask, int repeated, int st){\\n        if(pos >= n) return repeated;\\n        if(dp[pos][tight][mask][repeated][st] != -1) return dp[pos][tight][mask][repeated][st];\\n        // int output = 0;\\n        int ub = tight == 1 ? s[pos] - \\'0\\' : 9;\\n        int output = 0;\\n        if(st == 0){     \\n            //you can avoid to start\\n            output = solve(pos+1, 0, mask, repeated, 0);\\n            \\n            //either you can start no\\n            forn2(i, 1, ub+1){\\n                //you cannot put a zero currently\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated, 1);\\n            }\\n        }\\n        else{\\n            //sequence is started\\n            forn(i, ub+1){\\n                bool occured = (mask & (1 << i));\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated || occured, st);\\n            }\\n        }\\n        return dp[pos][tight][mask][repeated][st] = output;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n_) {\\n        s = to_string(n_);\\n        n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        int output = solve(0, 1, 0, 0, 0);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n// typedef unsigned long long ll;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e6 + 3;\\ntemplate<typename T>\\n \\n\\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint dp[10][2][(1 << 10) + 1][2][2];\\n\\nclass Solution {\\npublic:\\n    string s;\\n    int n;\\n    int solve(int pos, int tight, int mask, int repeated, int st){\\n        if(pos >= n) return repeated;\\n        if(dp[pos][tight][mask][repeated][st] != -1) return dp[pos][tight][mask][repeated][st];\\n        // int output = 0;\\n        int ub = tight == 1 ? s[pos] - \\'0\\' : 9;\\n        int output = 0;\\n        if(st == 0){     \\n            //you can avoid to start\\n            output = solve(pos+1, 0, mask, repeated, 0);\\n            \\n            //either you can start no\\n            forn2(i, 1, ub+1){\\n                //you cannot put a zero currently\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated, 1);\\n            }\\n        }\\n        else{\\n            //sequence is started\\n            forn(i, ub+1){\\n                bool occured = (mask & (1 << i));\\n                output += solve(pos+1, tight & (i == ub), mask | (1 << i), repeated || occured, st);\\n            }\\n        }\\n        return dp[pos][tight][mask][repeated][st] = output;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n_) {\\n        s = to_string(n_);\\n        n = s.size();\\n        memset(dp, -1, sizeof(dp));\\n        int output = solve(0, 1, 0, 0, 0);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2516633,
                "title": "python-help-needed-to-optimise-this",
                "content": "Hi, \\n\\nI have come up with a solution to this problem in a partially optimsed way but I need some help with \\nthe counter logic. I understand the last part of my code is sub-optimal but looking for ideas/inspiration that can make this work. \\n\\nPS: It works fine but exceeds the time limit. \\n\\nAny comments/feedback are welcome and appriciated :)\\n\\nThanks.\\n\\nUpdate: Came up with another solution where I count the numbers with unique digits and subtract the count from n. Still exceding the time limit. \\n\\nWould appricate any help! Thank you :)\\n\\nSolution # 1:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        if n < 11:\\n            return 0\\n        \\n        count = 0\\n        \\n        for i in range(11,n+1):\\n            ds = Counter()\\n            \\n            # count each digit of number and store in hashmap\\n            while i > 0:\\n                digit = i%10\\n                ds[digit] += 1\\n                i //=10\\n            \\n            \\n            #for each digit if val of digit >=2 they have atleast one repeating digit\\n            # This logic is wrong since it will increment count for every digit \\n            # will run into problems after 100\\n            # if i say any val in dict >=2 add 1 to internal counter \\n            # if there is value for an internal count add 1 to total count \\n            \\n            internal_count = 0\\n            for key, val in ds.items():\\n                if val >= 2:\\n                    internal_count += 1\\n            \\n            if internal_count:\\n                count += 1\\n        \\n        \\n        return count \\n\\n```\\n\\nSolution # 2:\\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        # lets find out numbers with no repeated digits\\n        # I want to subtract the count of numbers with unique digits from n \\n        \\n        def repeated(num: int) -> int:\\n            \\n            seen = []\\n            \\n            while num > 0:\\n                digit = num%10\\n                if digit in seen:\\n                    return 0\\n                seen.append(digit)\\n                num //= 10\\n            \\n            return 1\\n                \\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            \\n            count += repeated(i)\\n        \\n        return n-count\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        if n < 11:\\n            return 0\\n        \\n        count = 0\\n        \\n        for i in range(11,n+1):\\n            ds = Counter()\\n            \\n            # count each digit of number and store in hashmap\\n            while i > 0:\\n                digit = i%10\\n                ds[digit] += 1\\n                i //=10\\n            \\n            \\n            #for each digit if val of digit >=2 they have atleast one repeating digit\\n            # This logic is wrong since it will increment count for every digit \\n            # will run into problems after 100\\n            # if i say any val in dict >=2 add 1 to internal counter \\n            # if there is value for an internal count add 1 to total count \\n            \\n            internal_count = 0\\n            for key, val in ds.items():\\n                if val >= 2:\\n                    internal_count += 1\\n            \\n            if internal_count:\\n                count += 1\\n        \\n        \\n        return count \\n\\n```\n```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        \\n        # lets find out numbers with no repeated digits\\n        # I want to subtract the count of numbers with unique digits from n \\n        \\n        def repeated(num: int) -> int:\\n            \\n            seen = []\\n            \\n            while num > 0:\\n                digit = num%10\\n                if digit in seen:\\n                    return 0\\n                seen.append(digit)\\n                num //= 10\\n            \\n            return 1\\n                \\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            \\n            count += repeated(i)\\n        \\n        return n-count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506921,
                "title": "java-quick-solution-with-math",
                "content": "We can turn the problem into \"Numbers with no repeated digits\", which is much easier to find.\\n\\nLet us denote the number of integers with no repeated digits ranging from `a` to `b` as `N(a,b)`, where  **`a` is inclusive but `b` is not**. When we want to find `N(10, 100)`, we know that the tens can be `1,2,...,9`, and ones can be `0,1,...,9` but should be different from the tens. Hence, `N(10, 100)=9 * 9 =9 * P(9, 1)`.\\n\\nNow try `N(100, 1000)`, hundreds can be `1,2,...,9` (remember that top place cannot be 0), tens can be `0,1,...,9` but should be different from the hundreds, and ones can be `0,1,...,9` but should be different from both hundreds and tens. Therefore, `N(100,1000)=9*9*8=9*P(9,2)`.\\n\\nFollowing this rule we can deal with the problem. Take 3456 as example.\\n`N(0, 3456)=N(0,10)+N(10,100)+N(100,1000)+N(1000,3000)+N(3000, 3400)+N(3400,3450)+N(3450,3456)`.\\n\\n`N(0,10)`, `N(10,100)`, and `N(100,1000)` can be pre-calculated. Let\\'s focus on subsequent terms.\\nIt is easy to find `N(1000, 3000)=2*P(9,3)`, then `N(3000,3400)=3*8*7=3*P(8,2)`, where the first `3` indicates that hundreds can be `0,1,2,3`, but `3` has been taken so the number of remained options is 3; likewise, tens can be `0,1,2,4,...,9`, and one of them has been taken by hundreds.\\n\\nSee another example: `2220`. `N(2000, 2220)=N(2000, 2200)+N(2200,2220)`. We don\\'t have to calculate `N(2200, 2220)` because numbers in this range definitely have two `2`s, so the result must be 0.\\n\\n```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\t// pre = [0, N(0,10), N(10,100), N(100, 1000), ...] \\n\\tint[] pre = {0, 0, 9, 252, 4464, 62784, 763920, 8455680, 88367040}, digits = new int[9];\\n\\tint ans = 0, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) {\\n\\t\\tans += pre[len];\\n\\t\\tdigits[len] = t % 10;\\n\\t}\\n\\n\\tans += n - Math.pow(10, len - 1) + 1;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tboolean alreadyRepeated = false;\\n\\tfor (int i = 0; i < len && !alreadyRepeated; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit into the map;\\n\\t\\tif (++map[digit] > 1) alreadyRepeated = true;\\n\\t}\\n\\n\\treturn ans;\\n}\\n\\n// P(n, r) = n * (n - 1) * ... * (n - r + 1)\\n// example: P(5, 2) = 5 * 4\\npublic int P(int n, int r) {\\n\\tint ans = 1;\\n\\tfor (int i = n; i > n - r; i--) ans *= i;\\n\\treturn ans;\\n}\\n```\\n\\nTime complexity: `O(len(n)^2)=O(1)`, where `len(n)` is the number of digits of `n`. Because `len(n) < 9`, and `9` is a constant, so the time complexity is `O(1)`.\\n\\n---\\n\\nSomebody may say using `pre` array is cheating. The following is the version without `pre` array.\\n```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\tint[] digits = new int[9];\\n\\tint ans = n, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) digits[len] = t % 10;\\n\\tfor (int i = 1; i < len; i++) ans -= 9 * P(9, len - i - 1) ;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit to the map;\\n\\t\\tif (++map[digit] > 1) break;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\t// pre = [0, N(0,10), N(10,100), N(100, 1000), ...] \\n\\tint[] pre = {0, 0, 9, 252, 4464, 62784, 763920, 8455680, 88367040}, digits = new int[9];\\n\\tint ans = 0, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) {\\n\\t\\tans += pre[len];\\n\\t\\tdigits[len] = t % 10;\\n\\t}\\n\\n\\tans += n - Math.pow(10, len - 1) + 1;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tboolean alreadyRepeated = false;\\n\\tfor (int i = 0; i < len && !alreadyRepeated; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit into the map;\\n\\t\\tif (++map[digit] > 1) alreadyRepeated = true;\\n\\t}\\n\\n\\treturn ans;\\n}\\n\\n// P(n, r) = n * (n - 1) * ... * (n - r + 1)\\n// example: P(5, 2) = 5 * 4\\npublic int P(int n, int r) {\\n\\tint ans = 1;\\n\\tfor (int i = n; i > n - r; i--) ans *= i;\\n\\treturn ans;\\n}\\n```\n```java\\npublic int numDupDigitsAtMostN(int n) {\\n\\tint[] digits = new int[9];\\n\\tint ans = n, len = 0, t = n;   // [len] is the number of digits\\n\\n\\tfor (; t > 0; t /= 10, len++) digits[len] = t % 10;\\n\\tfor (int i = 1; i < len; i++) ans -= 9 * P(9, len - i - 1) ;\\n\\n\\t// operate digit by digit\\n\\tint[] map = new int[10];\\n\\tfor (int i = 0; i < len; i++) {\\n\\t\\tint digit = digits[len - i - 1], s = i == 0 ? 1 : 0, options = digit - s;\\n\\t\\tfor (int j = 0; j < digit; j++) if (map[j] > 0) options--;\\n\\t\\tif (i == len - 1 && map[digit] == 0) options++;\\n\\n\\t\\t// subtract the number of no-repeated-number integers\\n\\t\\tif (options > 0) ans -= options * P(10 - i - 1, len - i - 1);\\n\\n\\t\\t// put the digit to the map;\\n\\t\\tif (++map[digit] > 1) break;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2452657,
                "title": "c-solution-with-digit-dp-and-bitmasking-just-one-line-code-change-in-2376-count-special-integer",
                "content": "```\\nclass Solution {\\n    \\n    // Exactly same as 2376. Count Special Intgers. just one line change at the end\\n    \\n    // max pos or digit in a number = 11\\n    // tight = either 1 or 0\\n    // mask = 1024\\n    // dp[pos][tight][mask]\\n    \\n    int dp[11][2][1024];\\n    \\n    int helper(string &str, int pos, int tight, int mask){\\n        // base case - if you reach at end digit of number\\n        if(pos == str.size()){\\n            return mask != 0;\\n        }\\n        \\n        // if already calculated then return its value from dp table\\n        if(dp[pos][tight][mask] != -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n\\t\\t// \"ans\" will store the count of all integers having distinct digits \\n        int ans = 0;\\n        \\n        // if tight case\\n        if(tight == 1){\\n            \\n            // digit can take only value from 0 to str[pos]-\\'0\\', so loop over them\\n            for(int i=0; i<= str[pos]-\\'0\\'; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                // create new mask for next position of digit in number\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                // tight case for next digit also\\n                if(i == str[pos]-\\'0\\'){\\n                    ans = ans + helper(str, pos+1, 1, newMask);\\n                }\\n                // non-tight case for next digits\\n                else{\\n                    ans = ans + helper(str, pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        \\n        // non tight case for next positions of digits in number\\n        else{\\n            \\n            // digit can take any value from 0 to 9, so loop over them\\n            for(int i=0; i<=9; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                 // create new mask for next position of digit in number\\n                int  newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                ans = ans + helper(str, pos+1, 0, newMask);\\n            }\\n        }\\n\\t\\t// store it into dp table and return\\n        return dp[pos][tight][mask] = ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        int res = helper(str, 0, 1, 0);\\n        // at the end return total number minus numbers having distinct digits\\n\\t\\t// it will give all numbers having repeated digits\\n        return n - res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Exactly same as 2376. Count Special Intgers. just one line change at the end\\n    \\n    // max pos or digit in a number = 11\\n    // tight = either 1 or 0\\n    // mask = 1024\\n    // dp[pos][tight][mask]\\n    \\n    int dp[11][2][1024];\\n    \\n    int helper(string &str, int pos, int tight, int mask){\\n        // base case - if you reach at end digit of number\\n        if(pos == str.size()){\\n            return mask != 0;\\n        }\\n        \\n        // if already calculated then return its value from dp table\\n        if(dp[pos][tight][mask] != -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n\\t\\t// \"ans\" will store the count of all integers having distinct digits \\n        int ans = 0;\\n        \\n        // if tight case\\n        if(tight == 1){\\n            \\n            // digit can take only value from 0 to str[pos]-\\'0\\', so loop over them\\n            for(int i=0; i<= str[pos]-\\'0\\'; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                // create new mask for next position of digit in number\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                // tight case for next digit also\\n                if(i == str[pos]-\\'0\\'){\\n                    ans = ans + helper(str, pos+1, 1, newMask);\\n                }\\n                // non-tight case for next digits\\n                else{\\n                    ans = ans + helper(str, pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        \\n        // non tight case for next positions of digits in number\\n        else{\\n            \\n            // digit can take any value from 0 to 9, so loop over them\\n            for(int i=0; i<=9; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                 // create new mask for next position of digit in number\\n                int  newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                ans = ans + helper(str, pos+1, 0, newMask);\\n            }\\n        }\\n\\t\\t// store it into dp table and return\\n        return dp[pos][tight][mask] = ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        string str = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        int res = helper(str, 0, 1, 0);\\n        // at the end return total number minus numbers having distinct digits\\n\\t\\t// it will give all numbers having repeated digits\\n        return n - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448898,
                "title": "need-help-to-optimise-this-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    #define vi vector<int>\\n    #define REP(i,a,b) for(int i=a;i<b;i++)\\n    \\n    #define umap unordered_map\\n    \\n    ll recurr(string&R,int N,bool leading,bool tight,vi&vis,umap<string,ll>&dp){\\n        \\n        if(N==0)\\n            return 1;\\n        \\n        string key = to_string(N) + \\'#\\' + to_string(leading) + \\'#\\' + to_string(tight);\\n        \\n        for(auto ele:vis){\\n            key += to_string(ele) + \\'#\\';\\n        }\\n        \\n        if(dp.count(key)!=0)\\n            return dp[key];\\n        \\n        int ub = 9;\\n        if(tight)\\n            ub = R[ R.size()-N ]-\\'0\\';\\n        \\n        ll ans =0;\\n        int i;\\n        REP(i,0,ub+1){\\n            \\n            if(!leading)\\n            {\\n                if(i==0){\\n                    \\n                    ans += recurr(R,N-1,false,tight&&(i==ub),vis,dp);\\n                \\n                }\\n                else{\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    \\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    \\n                    vis[i]=-1;\\n                    \\n                    \\n                }\\n                \\n            }\\n            else{\\n                \\n                if(vis[i]==-1){\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    vis[i] = -1;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string R = to_string(n);\\n        vector<int>vis(11,-1);\\n        umap<string,ll>dp;\\n        return n - recurr(R,R.size(),false,true,vis,dp) +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    #define vi vector<int>\\n    #define REP(i,a,b) for(int i=a;i<b;i++)\\n    \\n    #define umap unordered_map\\n    \\n    ll recurr(string&R,int N,bool leading,bool tight,vi&vis,umap<string,ll>&dp){\\n        \\n        if(N==0)\\n            return 1;\\n        \\n        string key = to_string(N) + \\'#\\' + to_string(leading) + \\'#\\' + to_string(tight);\\n        \\n        for(auto ele:vis){\\n            key += to_string(ele) + \\'#\\';\\n        }\\n        \\n        if(dp.count(key)!=0)\\n            return dp[key];\\n        \\n        int ub = 9;\\n        if(tight)\\n            ub = R[ R.size()-N ]-\\'0\\';\\n        \\n        ll ans =0;\\n        int i;\\n        REP(i,0,ub+1){\\n            \\n            if(!leading)\\n            {\\n                if(i==0){\\n                    \\n                    ans += recurr(R,N-1,false,tight&&(i==ub),vis,dp);\\n                \\n                }\\n                else{\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    \\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    \\n                    vis[i]=-1;\\n                    \\n                    \\n                }\\n                \\n            }\\n            else{\\n                \\n                if(vis[i]==-1){\\n                    \\n                    vis[i] = R.size() - N +1;\\n                    ans += recurr(R,N-1,true,tight&&(i==ub),vis,dp);\\n                    vis[i] = -1;\\n                    \\n                }\\n                \\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string R = to_string(n);\\n        vector<int>vis(11,-1);\\n        umap<string,ll>dp;\\n        return n - recurr(R,R.size(),false,true,vis,dp) +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433382,
                "title": "javascript-digit-dp",
                "content": "**Solution: Digit DP**\\n\\nMemoize each `dp(i, mask, state, hasRepeat)`, where\\n*   `i = the ith digit`\\n*   `mask = bitmask which indicates which digit we have already used`\\n*   `state = indicates whether the current number is tracking smaller, equal, or greater than n `\\n\\t*    `0 = smaller`\\n\\t*    `1 = equal`\\n\\t*    `2 = greater`  \\n\\n*  `hasRepeat = whether we have a repeated digit `\\n\\nIf `hasRepeat` is true (1), count it as 1 way.\\nFor each state, count the total number of ways after appending each digit (`0 - 9`).\\n\\n`state`:\\n*   If `digit < n[index]`, update state to `0` (smaller) if state is currently `1` (equal). \\n*   If `digit === n[index]`, keep state the same.\\n*   If `digit > n[index]`, update state to `2` (greater) if state is currently `1` (equal).\\n\\n`d = number of digits in n`\\nTime Complexity: `O(d * 2^10 * 3 * 2 * 10)` 488ms\\n  `d * 2^10 * 3 * 2` = the number of different states we can have\\n  `10` = at each state we have `10` options for digits `0-9`\\nSpace Complexity: `O(d * 2^10 * 3 * 2)` 62MB\\n```\\nvar numDupDigitsAtMostN = function(n) {\\n  let str = n.toString(), size = str.length, memo = new Map();\\n  return dp(0, 0, 1, 0);\\n  \\n  function dp(i, mask, state, hasRepeat) {\\n    if (i === size) return state < 2 && hasRepeat ? 1 : 0;\\n    let key = `${i},${mask},${state},${hasRepeat}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = hasRepeat;\\n    for (let digit = 0; digit <= 9; digit++) {\\n      if (i === 0 && digit === 0) continue;\\n      let newMask = mask | (1 << digit), repeat = hasRepeat || (mask === newMask ? 1 : 0);\\n      if (digit < Number(str[i])) {\\n        ans += dp(i + 1, newMask, state === 1 ? 0 : state, repeat);\\n      } else if (digit === Number(str[i])) {\\n        ans += dp(i + 1, newMask, state, repeat);\\n      } else {\\n        ans += dp(i + 1, newMask, state === 1 ? 2 : state, repeat);\\n      }\\n    }\\n    memo.set(key, ans);\\n    return ans;\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numDupDigitsAtMostN = function(n) {\\n  let str = n.toString(), size = str.length, memo = new Map();\\n  return dp(0, 0, 1, 0);\\n  \\n  function dp(i, mask, state, hasRepeat) {\\n    if (i === size) return state < 2 && hasRepeat ? 1 : 0;\\n    let key = `${i},${mask},${state},${hasRepeat}`;\\n    if (memo.has(key)) return memo.get(key);\\n    \\n    let ans = hasRepeat;\\n    for (let digit = 0; digit <= 9; digit++) {\\n      if (i === 0 && digit === 0) continue;\\n      let newMask = mask | (1 << digit), repeat = hasRepeat || (mask === newMask ? 1 : 0);\\n      if (digit < Number(str[i])) {\\n        ans += dp(i + 1, newMask, state === 1 ? 0 : state, repeat);\\n      } else if (digit === Number(str[i])) {\\n        ans += dp(i + 1, newMask, state, repeat);\\n      } else {\\n        ans += dp(i + 1, newMask, state === 1 ? 2 : state, repeat);\\n      }\\n    }\\n    memo.set(key, ans);\\n    return ans;\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431077,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\n    private:\\n        int permutations(int n, int r){\\n            int ans = 1;\\n            for (int i=(n-r+1); i <= n; ++i){\\n                ans *= i;\\n            }\\n            return ans;\\n        }\\n        unordered_map<int, int> numberToCount(int number, int number_of_digits){\\n            unordered_map<int, int> count;\\n            for (int i=1; i<= number_of_digits; ++i){\\n                int digit = number % 10;\\n                ++count[digit];\\n                number = number / 10;\\n            }\\n            return count;\\n        }\\n        vector<int> uniqueChoices(unordered_map<int, int> & count, int digit, bool first){\\n            --count[digit];\\n            vector<int> ans;\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return ans;\\n                }\\n            }\\n            for (int i=first; i < digit; ++i){\\n                if (count[i]==0){\\n                    ans.push_back(i);\\n                }\\n            }\\n            return ans;\\n        }\\n        bool isRepeated(unordered_map<int, int> & count){\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int number_of_digits = int(floor(log10(n))) + 1;\\n        long ans = 0;\\n        for (int i=1; i < number_of_digits; ++i){\\n            if (i<=10){\\n                // all possible choices - all unique choices\\n                ans += long(9 * pow(10, i-1) - 9 * permutations(9, i-1));                \\n            }else{\\n                // this condition is not going to happen\\n                ans += long(9 * pow(10, i-1));\\n            }\\n        }\\n        unordered_map<int, int> count =  numberToCount(n, number_of_digits);\\n\\n        // check the number itself\\n        if(isRepeated(count))\\n            ans += 1;\\n\\n        int number = n;\\n        // evaluate the possibilities\\n        // when we choose smaller numbers on all digits one by one\\n        for (int i=1; i<= number_of_digits; ++i){\\n            int digit = number % 10;\\n            vector<int> choices = uniqueChoices(count, digit, i==number_of_digits);\\n            int nb_choices;\\n            // the first digit from left to right\\n            if(i==number_of_digits) \\n                nb_choices = digit-1;\\n            else // other digits\\n                nb_choices = digit;\\n            // all possible choices - all unique choices\\n            ans += long(nb_choices * pow(10, i-1) - choices.size() * permutations(10-(number_of_digits-i+1),i-1));\\n            number = number / 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n        int permutations(int n, int r){\\n            int ans = 1;\\n            for (int i=(n-r+1); i <= n; ++i){\\n                ans *= i;\\n            }\\n            return ans;\\n        }\\n        unordered_map<int, int> numberToCount(int number, int number_of_digits){\\n            unordered_map<int, int> count;\\n            for (int i=1; i<= number_of_digits; ++i){\\n                int digit = number % 10;\\n                ++count[digit];\\n                number = number / 10;\\n            }\\n            return count;\\n        }\\n        vector<int> uniqueChoices(unordered_map<int, int> & count, int digit, bool first){\\n            --count[digit];\\n            vector<int> ans;\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return ans;\\n                }\\n            }\\n            for (int i=first; i < digit; ++i){\\n                if (count[i]==0){\\n                    ans.push_back(i);\\n                }\\n            }\\n            return ans;\\n        }\\n        bool isRepeated(unordered_map<int, int> & count){\\n            for (auto it=count.begin(); it!=count.end(); ++it){\\n                if (it->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int number_of_digits = int(floor(log10(n))) + 1;\\n        long ans = 0;\\n        for (int i=1; i < number_of_digits; ++i){\\n            if (i<=10){\\n                // all possible choices - all unique choices\\n                ans += long(9 * pow(10, i-1) - 9 * permutations(9, i-1));                \\n            }else{\\n                // this condition is not going to happen\\n                ans += long(9 * pow(10, i-1));\\n            }\\n        }\\n        unordered_map<int, int> count =  numberToCount(n, number_of_digits);\\n\\n        // check the number itself\\n        if(isRepeated(count))\\n            ans += 1;\\n\\n        int number = n;\\n        // evaluate the possibilities\\n        // when we choose smaller numbers on all digits one by one\\n        for (int i=1; i<= number_of_digits; ++i){\\n            int digit = number % 10;\\n            vector<int> choices = uniqueChoices(count, digit, i==number_of_digits);\\n            int nb_choices;\\n            // the first digit from left to right\\n            if(i==number_of_digits) \\n                nb_choices = digit-1;\\n            else // other digits\\n                nb_choices = digit;\\n            // all possible choices - all unique choices\\n            ans += long(nb_choices * pow(10, i-1) - choices.size() * permutations(10-(number_of_digits-i+1),i-1));\\n            number = number / 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430193,
                "title": "digit-dp-solution-c",
                "content": "```\\nclass Solution\\n{\\n\\n    int dp[11][2][2][1024];\\n\\n    int countNumbers(string &str, int pos = 0, int tight = 1, int repeated = 0, int mask = 0)\\n    {\\n        if (pos == str.length())\\n            return ((mask != 0) and (repeated != 0));\\n        \\n        \\n        if(dp[pos][tight][repeated][mask] != -1)\\n            return dp[pos][tight][repeated][mask];\\n      \\n        int count = 0;\\n        if (tight)\\n        {\\n            for (int digit = 0; digit <= str[pos] - \\'0\\'; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                if (digit == str[pos] - \\'0\\')\\n                    count += countNumbers(str, pos + 1, 1, newRepeated, newMask);\\n                else\\n                    count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n        else\\n        {\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n\\n        return dp[pos][tight][repeated][mask] = count;\\n    }\\n\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string str = to_string(n);\\n            memset(dp, -1, sizeof(dp));\\n            return countNumbers(str);\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n\\n    int dp[11][2][2][1024];\\n\\n    int countNumbers(string &str, int pos = 0, int tight = 1, int repeated = 0, int mask = 0)\\n    {\\n        if (pos == str.length())\\n            return ((mask != 0) and (repeated != 0));\\n        \\n        \\n        if(dp[pos][tight][repeated][mask] != -1)\\n            return dp[pos][tight][repeated][mask];\\n      \\n        int count = 0;\\n        if (tight)\\n        {\\n            for (int digit = 0; digit <= str[pos] - \\'0\\'; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                if (digit == str[pos] - \\'0\\')\\n                    count += countNumbers(str, pos + 1, 1, newRepeated, newMask);\\n                else\\n                    count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n        else\\n        {\\n            for (int digit = 0; digit <= 9; digit++)\\n            {\\n                int newRepeated = repeated or (((mask == 0 and digit == 0) ? 0 : ((mask & (1 << digit)) != 0)));\\n                int newMask = ((mask == 0 and digit == 0) ? 0 : (mask | (1 << digit)));\\n\\n                count += countNumbers(str, pos + 1, 0, newRepeated, newMask);\\n            }\\n        }\\n\\n        return dp[pos][tight][repeated][mask] = count;\\n    }\\n\\n    public:\\n        int numDupDigitsAtMostN(int n)\\n        {\\n            string str = to_string(n);\\n            memset(dp, -1, sizeof(dp));\\n            return countNumbers(str);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425530,
                "title": "100-javascript-solution",
                "content": "```\\nconst permutation = (n,r) => {\\n    let nonRepeatingNumbers = 1;\\n    for(let i=0;i<r;i++){\\n        nonRepeatingNumbers *= n;\\n        n--;\\n    }\\n    return nonRepeatingNumbers;\\n}\\n\\nvar numDupDigitsAtMostN = function(n) {\\n    let count = 0;\\n    const numDigits = [];\\n    \\n    let temp = n+1;\\n    while(temp!==0){\\n        const num = temp%10;\\n        numDigits.unshift(num);\\n        temp = parseInt(temp/10);\\n    }\\n\\n    for(let i=0;i<numDigits.length-1;i++){\\n        count+=9*permutation(9,i);\\n    }\\n\\n    const mySet = new Set();\\n    for(let i=0;i<numDigits.length;i++){\\n        for(let j=i===0?1:0; j<numDigits[i];j++){\\n            if(mySet.has(j)) continue;\\n            count += permutation(10-(i+1),numDigits.length-(i+1)); \\n        }\\n        if(mySet.has(numDigits[i])) break;\\n        mySet.add(numDigits[i]);\\n\\n    }\\n    \\n    return n-count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nconst permutation = (n,r) => {\\n    let nonRepeatingNumbers = 1;\\n    for(let i=0;i<r;i++){\\n        nonRepeatingNumbers *= n;\\n        n--;\\n    }\\n    return nonRepeatingNumbers;\\n}\\n\\nvar numDupDigitsAtMostN = function(n) {\\n    let count = 0;\\n    const numDigits = [];\\n    \\n    let temp = n+1;\\n    while(temp!==0){\\n        const num = temp%10;\\n        numDigits.unshift(num);\\n        temp = parseInt(temp/10);\\n    }\\n\\n    for(let i=0;i<numDigits.length-1;i++){\\n        count+=9*permutation(9,i);\\n    }\\n\\n    const mySet = new Set();\\n    for(let i=0;i<numDigits.length;i++){\\n        for(let j=i===0?1:0; j<numDigits[i];j++){\\n            if(mySet.has(j)) continue;\\n            count += permutation(10-(i+1),numDigits.length-(i+1)); \\n        }\\n        if(mySet.has(numDigits[i])) break;\\n        mySet.add(numDigits[i]);\\n\\n    }\\n    \\n    return n-count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423455,
                "title": "c-math-combinatorics",
                "content": "```\\nclass Solution {\\n    vector<int> getarray(int n) {\\n        vector<int> a;\\n        while(n != 0) {\\n            a.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(a.rbegin(), a.rend());\\n        return a;\\n    }\\n    \\n    int npr(int n, int r) {\\n        int ans = 1;\\n        for(int i = 1; i <= n; i++)\\n            ans *= i;\\n        for(int i = 1; i <= n-r; i++)\\n            ans /= i;\\n        return ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        if(n <= 10)\\n            return 0;\\n        \\n        vector<int> a = getarray(n);\\n        int len = a.size();\\n        \\n        // the approach is too count the numbers with distinct digit\\n\\n        // counting possibilities of 1 to len-1 digit number\\n        // 0-9, 10-99, 100-999, 1000-9999, ............        \\n        int ans = 0;\\n        for(int i = 1; i < len; i++) \\n            ans += 9 * npr(10-1, i-1);\\n            \\n        // for len digit number which are less than n\\n        vector<bool> used(10);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = i==0?1:0; j < a[i]; j++) {\\n                if(used[j]) continue;\\n                ans += npr(10-i-1, len-i-1);\\n            }\\n            if(used[a[i]]) \\n                break;\\n            used[a[i]] = true;\\n        }\\n        \\n        vector<bool> dup(10);\\n        bool flag = false;\\n        for(int i = 0; i < len; i++) {\\n            if(dup[a[i]]) {\\n                flag = true;\\n                break;\\n            }\\n            dup[a[i]] = true;\\n        }\\n        \\n        if(!flag) ans += 1;\\n                \\n        return n - ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> getarray(int n) {\\n        vector<int> a;\\n        while(n != 0) {\\n            a.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(a.rbegin(), a.rend());\\n        return a;\\n    }\\n    \\n    int npr(int n, int r) {\\n        int ans = 1;\\n        for(int i = 1; i <= n; i++)\\n            ans *= i;\\n        for(int i = 1; i <= n-r; i++)\\n            ans /= i;\\n        return ans;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        if(n <= 10)\\n            return 0;\\n        \\n        vector<int> a = getarray(n);\\n        int len = a.size();\\n        \\n        // the approach is too count the numbers with distinct digit\\n\\n        // counting possibilities of 1 to len-1 digit number\\n        // 0-9, 10-99, 100-999, 1000-9999, ............        \\n        int ans = 0;\\n        for(int i = 1; i < len; i++) \\n            ans += 9 * npr(10-1, i-1);\\n            \\n        // for len digit number which are less than n\\n        vector<bool> used(10);\\n        for(int i = 0; i < len; i++) {\\n            for(int j = i==0?1:0; j < a[i]; j++) {\\n                if(used[j]) continue;\\n                ans += npr(10-i-1, len-i-1);\\n            }\\n            if(used[a[i]]) \\n                break;\\n            used[a[i]] = true;\\n        }\\n        \\n        vector<bool> dup(10);\\n        bool flag = false;\\n        for(int i = 0; i < len; i++) {\\n            if(dup[a[i]]) {\\n                flag = true;\\n                break;\\n            }\\n            dup[a[i]] = true;\\n        }\\n        \\n        if(!flag) ans += 1;\\n                \\n        return n - ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422782,
                "title": "javascript-dfs-bitmask-2833ms",
                "content": "```\\nconst numDupDigitsAtMostN = (N) => countNumberWithoutRepeatedDigit(N);\\n\\nlet res, n;\\nconst countNumberWithoutRepeatedDigit = (N) => {\\n    n = N;\\n    res = 0;\\n    dfs(0, 1023);\\n    return N - (res - 1);\\n};\\n\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst dfs = (cur, rem) => {\\n    if (cur > n) return;\\n    res++;\\n    for (let i = cur == 0 ? 1 : 0; i < 10; i++) {\\n        if (checkIthBit(rem, i)) {\\n            dfs(cur * 10 + i, rem ^ (1 << i))\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nconst numDupDigitsAtMostN = (N) => countNumberWithoutRepeatedDigit(N);\\n\\nlet res, n;\\nconst countNumberWithoutRepeatedDigit = (N) => {\\n    n = N;\\n    res = 0;\\n    dfs(0, 1023);\\n    return N - (res - 1);\\n};\\n\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst dfs = (cur, rem) => {\\n    if (cur > n) return;\\n    res++;\\n    for (let i = cur == 0 ? 1 : 0; i < 10; i++) {\\n        if (checkIthBit(rem, i)) {\\n            dfs(cur * 10 + i, rem ^ (1 << i))\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422690,
                "title": "c-simple-greedy-precomputation-approach-o-log10-n-tc-nearly-constant-tc",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<ll> dp(10);\\n        ll g=n;\\n        for(int i=1;i<=9;i++)\\n        {\\n            int z=9;\\n            if(i==1)\\n            {\\n                dp[i]=9;\\n            }\\n            else \\n            {\\n                ll k=i;\\n                --k;\\n                dp[i]=9;\\n                while(k--)\\n                {\\n                    dp[i]*=(z);\\n                    z--;\\n                }\\n            }\\n        }\\n        ll z=log10(n)+1;\\n \\n        ll ans=0;\\n        \\n        for(ll i=1;i<=z-1;i++)\\n        {\\n            ans+=dp[i];\\n        }\\n        vector<ll> digit;\\n        while(n)\\n        {\\n            digit.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(digit.begin(),digit.end());\\n        set<ll> st;\\n        bool ok=true;\\n        int j;\\n        for(ll i=0;i<z-1;i++)\\n        {\\n            ll k=digit[i]-1;\\n            if(k==0&&i==0)\\n            {\\n                st.insert(1);\\n                continue;\\n            }\\n            ll zz=1;\\n\\n            ll mul=0;\\n            for(ll m=0;m<=k;m++)\\n            {\\n                if(st.find(m)==st.end())\\n                mul++;\\n            }\\n            if(i==0)\\n            {\\n                mul--;\\n            }\\n            ll c=10-i-1;\\n\\n            for(ll j=i+1;j<z;j++)\\n            {\\n                zz*=c;\\n                c--;\\n            }\\n            zz*=mul;\\n            ans+=zz;\\n            if(st.find(digit[i])!=st.end())\\n            {\\n                ok=false;\\n                j=i;\\n                break;\\n            }\\n            st.insert(digit[i]);\\n        }\\n        if(ok)\\n        {\\n            ll f=digit[z-1];\\n            ll c=0;\\n            for(ll i=0;i<=f;i++)\\n            {\\n                if(st.find(i)==st.end())\\n                c++;\\n            }\\n            ans+=c;\\n            \\n            if(z==1)\\n            { \\n                ans--;\\n            }\\n        }\\n        return g-ans;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        vector<ll> dp(10);\\n        ll g=n;\\n        for(int i=1;i<=9;i++)\\n        {\\n            int z=9;\\n            if(i==1)\\n            {\\n                dp[i]=9;\\n            }\\n            else \\n            {\\n                ll k=i;\\n                --k;\\n                dp[i]=9;\\n                while(k--)\\n                {\\n                    dp[i]*=(z);\\n                    z--;\\n                }\\n            }\\n        }\\n        ll z=log10(n)+1;\\n \\n        ll ans=0;\\n        \\n        for(ll i=1;i<=z-1;i++)\\n        {\\n            ans+=dp[i];\\n        }\\n        vector<ll> digit;\\n        while(n)\\n        {\\n            digit.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(digit.begin(),digit.end());\\n        set<ll> st;\\n        bool ok=true;\\n        int j;\\n        for(ll i=0;i<z-1;i++)\\n        {\\n            ll k=digit[i]-1;\\n            if(k==0&&i==0)\\n            {\\n                st.insert(1);\\n                continue;\\n            }\\n            ll zz=1;\\n\\n            ll mul=0;\\n            for(ll m=0;m<=k;m++)\\n            {\\n                if(st.find(m)==st.end())\\n                mul++;\\n            }\\n            if(i==0)\\n            {\\n                mul--;\\n            }\\n            ll c=10-i-1;\\n\\n            for(ll j=i+1;j<z;j++)\\n            {\\n                zz*=c;\\n                c--;\\n            }\\n            zz*=mul;\\n            ans+=zz;\\n            if(st.find(digit[i])!=st.end())\\n            {\\n                ok=false;\\n                j=i;\\n                break;\\n            }\\n            st.insert(digit[i]);\\n        }\\n        if(ok)\\n        {\\n            ll f=digit[z-1];\\n            ll c=0;\\n            for(ll i=0;i<=f;i++)\\n            {\\n                if(st.find(i)==st.end())\\n                c++;\\n            }\\n            ans+=c;\\n            \\n            if(z==1)\\n            { \\n                ans--;\\n            }\\n        }\\n        return g-ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418330,
                "title": "need-help-converting-recursion-code-to-dp-code",
                "content": "Hello, could anyone please help me on how to identify DP states and memoize this solution ? Thanks.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int target;\\n    \\n    int solve(int cur, int mask, int num, int len)\\n    {\\n        if(num > target)\\n            return 0;\\n        if(cur==len){\\n            return 1;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            // for all 10 digits\\n            if(cur==0 && i==0)\\n                continue;\\n            if(mask & (1<<i))\\n                continue;\\n            ans+=solve(cur+1, mask | (1<<i), num*10+i, len);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        int full_len=to_string(n).size();\\n        int uniq=0;\\n        target=n;\\n        for(int i=1;i<=full_len;i++)\\n        {\\n            int x=solve(0,0,0,i);\\n            uniq+=x;\\n        }\\n        return n-uniq;\\n    }\\n};\\n```\\n\\nI also tried out another recursive solution\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int target;\\n    unordered_map<int, unordered_map<int,int> >dp;\\n    int sum=0;\\n    int solve(string &num, int cur, int mask, int bound, int lz, int len)\\n    {\\n\\n        if(cur==len){\\n            return 1;\\n        }\\n\\n        int upper_bound=(bound)? num[cur]-\\'0\\': 9;\\n        \\n        int ans=0;\\n        for(int i=0;i<=upper_bound;i++)\\n        {\\n            if(i==0 && lz==1)\\n            {\\n                ans+=solve(num, cur+1, mask, 0, lz, len);\\n            }\\n            else if(!(mask & (1<<i)))\\n                ans+=solve(num, cur+1, mask | (1<<i), bound & (i==upper_bound), lz & (i==0), len);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        string num=to_string(n);\\n        int full_len=num.size();\\n        int uniq=0;\\n        target=n;\\n        dp.clear();\\n        sum=solve(num, 0,0,1,1,full_len);    \\n        return n-sum+1;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int target;\\n    \\n    int solve(int cur, int mask, int num, int len)\\n    {\\n        if(num > target)\\n            return 0;\\n        if(cur==len){\\n            return 1;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            // for all 10 digits\\n            if(cur==0 && i==0)\\n                continue;\\n            if(mask & (1<<i))\\n                continue;\\n            ans+=solve(cur+1, mask | (1<<i), num*10+i, len);\\n        }\\n        return ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        int full_len=to_string(n).size();\\n        int uniq=0;\\n        target=n;\\n        for(int i=1;i<=full_len;i++)\\n        {\\n            int x=solve(0,0,0,i);\\n            uniq+=x;\\n        }\\n        return n-uniq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155741,
                "title": "digit-dp-with-bitmasking-c",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tlong long int dp[11][2][2][(1<<10)];\\n\\t\\tint f(int idx,bool flag,bool repeat,int mask,string &s){\\n\\n\\t\\t\\tif(idx==s.size()){\\n\\t\\t\\t\\treturn repeat;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(dp[idx][flag][repeat][mask]!=-1) return dp[idx][flag][repeat][mask];\\n\\n\\t\\t\\tint limit = s[idx]-\\'0\\';\\n\\t\\t\\tif(flag) limit = 9;\\n\\n\\t\\t\\tint ans=0;\\n\\n\\t\\t\\tfor(int digit=0;digit<=limit;digit++){\\n\\n\\n\\n\\t\\t\\t\\t if(digit < (s[idx]-\\'0\\')){\\n\\n\\t\\t\\t\\t\\t\\tif(digit==0 and mask==0){\\n\\t\\t\\t\\t\\t\\t\\t ans+=f(idx+1,true,false,mask,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\telse if(mask&(1<<digit)){\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,true,true,mask,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,true,repeat,mask | (1<<digit),s);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(digit==0 and mask==0){\\n\\t\\t\\t\\t\\t\\tans+=f(idx+1,flag,false,mask,s);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\telse if(mask&(1<<digit)){\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,flag,true,mask,s);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\tans+=f(idx+1,flag,repeat,mask | (1<<digit),s);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[idx][flag][repeat][mask]=ans;\\n\\t\\t}\\n\\t\\tint numDupDigitsAtMostN(int n) {\\n\\n\\t\\t\\tstring r = to_string(n);\\n\\t\\t\\tmemset(dp,-1,sizeof dp);\\n\\n\\n\\n\\t\\t\\treturn f(0,false,false,0,r);\\n\\t\\t}\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\tlong long int dp[11][2][2][(1<<10)];\\n\\t\\tint f(int idx,bool flag,bool repeat,int mask,string &s){\\n\\n\\t\\t\\tif(idx==s.size()){\\n\\t\\t\\t\\treturn repeat;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1962444,
                "title": "python-solution-with-explanation",
                "content": "We can count how many numbers that are smaller than` n` and have unique numbers in it. Then we do a subtraction to get non-unique number count.\\n\\n```\\ndef numDupDigitsAtMostN(self, n: int) -> int:\\n        n0 = n\\n        n_list = []\\n        while n0>0:\\n            n_list = [n0%10] + n_list\\n            n0 = n0//10\\n\\n        l = len(n_list)\\n        unique = 0\\n        used = set()\\n        x = n_list[0]\\n        # part 1, calculates how many unique numbers are of length l\\n        # part 1a, for the leftmost digit, it cannot be 0. \\n        # Example: 23456 -> x???? \\n        # x can be from x=1 to x=(2-1)=1 -> x can only be 1\\n        # ???? can be any unique number with possible numbers being 8, and it can start with 0\\n\\t\\t# multiply the available x and ???? we get the count of unique numbers which are smaller than 20000.\\n        ans = (n_list[0] - 1 - unique) * self.uniqueNumberStartingWith0(l-1, 9-1)\\n        used.add(n_list[0])\\n        \\n        # part 1b, for the rest digits, it can be any number smaller than the given one. We check each digit gradually. \\n        # Example: 23456 -> 2x???. How many unique numbers y are there which satisfies 20000<=y<23000?\\n        # x can be from x=0 to x=3 and deduct any used digits (here it\\'ll be 2) -> x can be 0 or 1\\n        # ?? can be any unique number with possible numbers being (9-length of (2)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 23x?? -> How many unique numbers y are there which satisfies 23000<=y<23400?\\n        # 0<=x<4 and deduct any used digits (here it\\'ll be 2 and 3) -> x can be 0 or 1 \\n        # ?? can be any unique number with possible numbers being (9-length of (23)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 234x? -> How many unique numbers y are there which satisfies 23400<=y<23450?\\n        # 0<=x<5 and deduct any used digits (here it\\'ll be 2, 3, and 4) -> x can be 0 or 1 \\n        # ? can be any unique number with possible numbers being (9-length of (234)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 2345x -> How many unique numbers y are there which satisfies 23450<=y<23456?\\n        # 0<=x<6 and deduct any used digits (here it\\'ll be 2, 3, and 4, 5) -> x can be 0 or 1 \\n        for i in range(1, l):\\n            x = n_list[i]\\n            unique = 0\\n            for j in used:\\n                if j<x:\\n                    unique += 1\\n            ans += max(x - unique, 0) * self.uniqueNumberStartingWith0(l-i-1, 9-i-1)\\n            if x in used:\\n                break\\n            used.add(x)\\n            \\n        # calculates how many unique numbers are of length 1 , ..., to (l-1)\\n        for i in range(1,l):\\n            ans += self.uniqueNumberNotStartingWith0(i, 9)\\n        \\n        # if the number itself is unique, then subtract it from the total; otherwise, do not subtract\\n        return n-self.isUnique(n_list)-ans \\n        \\n    def isUnique(self, n: list[int]) -> int:\\n        # this function determines if a number itself is unique\\n        used = set()\\n        for i in n:\\n            if i in used:\\n                return 0\\n            else:\\n                used.add(i)\\n        return 1\\n        \\n    def uniqueNumberNotStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does not start from 0, given the length of number being digit, and the possible_digit representing how many digits can be used here\\n        ans = 1\\n        step = 0\\n        while digit>0:\\n            ans *= possible_digit\\n            if step==0:\\n                pass\\n            else:\\n                possible_digit -= 1\\n            digit -= 1\\n            step += 1\\n        return ans\\n        \\n    def uniqueNumberStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does can start from 0\\n        ans = 1\\n        while digit>0:\\n            ans *= possible_digit+1\\n            possible_digit -= 1\\n            digit -= 1\\n        return ans```",
                "solutionTags": [],
                "code": "```\\ndef numDupDigitsAtMostN(self, n: int) -> int:\\n        n0 = n\\n        n_list = []\\n        while n0>0:\\n            n_list = [n0%10] + n_list\\n            n0 = n0//10\\n\\n        l = len(n_list)\\n        unique = 0\\n        used = set()\\n        x = n_list[0]\\n        # part 1, calculates how many unique numbers are of length l\\n        # part 1a, for the leftmost digit, it cannot be 0. \\n        # Example: 23456 -> x???? \\n        # x can be from x=1 to x=(2-1)=1 -> x can only be 1\\n        # ???? can be any unique number with possible numbers being 8, and it can start with 0\\n\\t\\t# multiply the available x and ???? we get the count of unique numbers which are smaller than 20000.\\n        ans = (n_list[0] - 1 - unique) * self.uniqueNumberStartingWith0(l-1, 9-1)\\n        used.add(n_list[0])\\n        \\n        # part 1b, for the rest digits, it can be any number smaller than the given one. We check each digit gradually. \\n        # Example: 23456 -> 2x???. How many unique numbers y are there which satisfies 20000<=y<23000?\\n        # x can be from x=0 to x=3 and deduct any used digits (here it\\'ll be 2) -> x can be 0 or 1\\n        # ?? can be any unique number with possible numbers being (9-length of (2)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 23x?? -> How many unique numbers y are there which satisfies 23000<=y<23400?\\n        # 0<=x<4 and deduct any used digits (here it\\'ll be 2 and 3) -> x can be 0 or 1 \\n        # ?? can be any unique number with possible numbers being (9-length of (23)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 234x? -> How many unique numbers y are there which satisfies 23400<=y<23450?\\n        # 0<=x<5 and deduct any used digits (here it\\'ll be 2, 3, and 4) -> x can be 0 or 1 \\n        # ? can be any unique number with possible numbers being (9-length of (234)-1), and it can start with 0\\n\\t\\t# Example: 23456 -> 2345x -> How many unique numbers y are there which satisfies 23450<=y<23456?\\n        # 0<=x<6 and deduct any used digits (here it\\'ll be 2, 3, and 4, 5) -> x can be 0 or 1 \\n        for i in range(1, l):\\n            x = n_list[i]\\n            unique = 0\\n            for j in used:\\n                if j<x:\\n                    unique += 1\\n            ans += max(x - unique, 0) * self.uniqueNumberStartingWith0(l-i-1, 9-i-1)\\n            if x in used:\\n                break\\n            used.add(x)\\n            \\n        # calculates how many unique numbers are of length 1 , ..., to (l-1)\\n        for i in range(1,l):\\n            ans += self.uniqueNumberNotStartingWith0(i, 9)\\n        \\n        # if the number itself is unique, then subtract it from the total; otherwise, do not subtract\\n        return n-self.isUnique(n_list)-ans \\n        \\n    def isUnique(self, n: list[int]) -> int:\\n        # this function determines if a number itself is unique\\n        used = set()\\n        for i in n:\\n            if i in used:\\n                return 0\\n            else:\\n                used.add(i)\\n        return 1\\n        \\n    def uniqueNumberNotStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does not start from 0, given the length of number being digit, and the possible_digit representing how many digits can be used here\\n        ans = 1\\n        step = 0\\n        while digit>0:\\n            ans *= possible_digit\\n            if step==0:\\n                pass\\n            else:\\n                possible_digit -= 1\\n            digit -= 1\\n            step += 1\\n        return ans\\n        \\n    def uniqueNumberStartingWith0(self, digit: int, possible_digit: int) -> int:\\n        # this function calculates how many unique numbers are there which does can start from 0\\n        ans = 1\\n        while digit>0:\\n            ans *= possible_digit+1\\n            possible_digit -= 1\\n            digit -= 1\\n        return ans```",
                "codeTag": "Python3"
            },
            {
                "id": 1880228,
                "title": "digit-dp-bitsmask-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[12][2][2][1<<11];\\n    int solve(string s,int n,int tight,int st,long long m)\\n    {\\n        if(n==0 && !st)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n][tight][st][m]!=-1)return dp[n][tight][st][m];\\n        int ans=0;\\n        int ub=tight ? s[s.length()-n]-\\'0\\' : 9;\\n        \\n        for(int i=0;i<=ub;i++)\\n        {\\n            if(!st)\\n            {\\n                if(i==0)\\n                    ans+=solve(s,n-1,(tight&(i==ub)),st,m);\\n                else\\n                {\\n                    // m=m|(1<<i);\\n                    ans+=solve(s,n-1,(tight&(i==ub)),1,m | (1<<i));\\n                    // m=m&(~(1<<i));\\n                }\\n                \\n            }\\n            else\\n            {\\n                if(!(m&(1<<i)))\\n                {\\n                    // m=m|(1<<i);\\n                    ans+=solve(s,n-1,(tight&(i==ub)),st,m | (1<<i));\\n                    // m=m&(~(1<<i));\\n                }\\n            }\\n            \\n            \\n        }\\n        return dp[n][tight][st][m]=ans;\\n        return ans;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        long long m=0;\\n        \\n        string s=to_string(n);\\n        memset(dp,-1,sizeof dp);\\n        return n-solve(s,s.length(),1,0,m);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[12][2][2][1<<11];\\n    int solve(string s,int n,int tight,int st,long long m)\\n    {\\n        if(n==0 && !st)\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        if(dp[n][tight][st][m]!=-1)return dp[n][tight][st][m];\\n        int ans=0;\\n        int ub=tight ? s[s.length()-n]-\\'0\\' : 9;\\n        \\n        for(int i=0;i<=ub;i++)\\n        {\\n            if(!st)\\n            {\\n                if(i==0)\\n                    ans+=solve(s,n-1,(tight&(i==ub)),st,m);\\n                else\\n                {\\n                    // m=m|(1<<i);\\n                    ans+=solve(s,n-1,(tight&(i==ub)),1,m | (1<<i));\\n                    // m=m&(~(1<<i));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1817215,
                "title": "c-2d-digit-dp",
                "content": "We are just treating numbers with restriction specially.\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        dp = vector(10,vector(1024,-1));\\n        int last = 0;\\n        string s = to_string(n);\\n        int len = s.size();\\n        bool flag = false; // if edge number are satisfy the condition\\n        int result=0;\\n        bool valid=false; // no leading zero for numbers with restriction.\\n        for(int i=0;i<len;++i)\\n        {\\n            int limit = s[i]-\\'0\\';\\n            for(int j=0;j<limit;++j)\\n            {\\n                int tvalid = valid || j >0;\\n                if((tvalid && isSet(last,j)) || flag)\\n                {\\n                    int dLeft = s.size()-i -1;\\n                    result += pow(10,dLeft);\\n                }\\n                else if(tvalid)\\n                {\\n                    int mask = setBit(last,j);\\n                    result+=digit_dp(s,i+1,mask,tvalid);\\n                }\\n                else\\n                    result+=digit_dp(s,i+1,0,tvalid);\\n            }\\n            if(isSet(last,limit))\\n                flag = true;\\n            valid = true;\\n            last = setBit(last,limit);\\n        }\\n        return result+flag;\\n    }\\n    int digit_dp(string s,int pos,int last,bool valid) // valid = valid number not starting with zero\\n    {\\n        if(pos==s.size())\\n            return 0;\\n        if(dp[pos][last]!=-1)\\n            return dp[pos][last];\\n        int sum=0;\\n        for(int i=0;i<10;++i)\\n        {\\n            int tvalid = valid || i>0;\\n            if(tvalid && isSet(last,i)) // satisfy the condition, calculate count\\n            {\\n                int dLeft = s.size()-pos -1;\\n                sum += pow(10,dLeft);\\n            }\\n            else if(tvalid)\\n            {\\n                int mask = setBit(last,i);\\n                sum+=digit_dp(s,pos+1,mask,tvalid);\\n            }\\n            else // not a valid number till now\\n                 sum+=digit_dp(s,pos+1,0,tvalid);\\n        }\\n        return dp[pos][last] = sum;\\n    }\\n    bool isSet(int number, int bit)\\n    {\\n        return number & (1<<bit);\\n    }\\n    int setBit(int number, int bit)\\n    {\\n        return number | (1<<bit);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        dp = vector(10,vector(1024,-1));\\n        int last = 0;\\n        string s = to_string(n);\\n        int len = s.size();\\n        bool flag = false; // if edge number are satisfy the condition\\n        int result=0;\\n        bool valid=false; // no leading zero for numbers with restriction.\\n        for(int i=0;i<len;++i)\\n        {\\n            int limit = s[i]-\\'0\\';\\n            for(int j=0;j<limit;++j)\\n            {\\n                int tvalid = valid || j >0;\\n                if((tvalid && isSet(last,j)) || flag)\\n                {\\n                    int dLeft = s.size()-i -1;\\n                    result += pow(10,dLeft);\\n                }\\n                else if(tvalid)\\n                {\\n                    int mask = setBit(last,j);\\n                    result+=digit_dp(s,i+1,mask,tvalid);\\n                }\\n                else\\n                    result+=digit_dp(s,i+1,0,tvalid);\\n            }\\n            if(isSet(last,limit))\\n                flag = true;\\n            valid = true;\\n            last = setBit(last,limit);\\n        }\\n        return result+flag;\\n    }\\n    int digit_dp(string s,int pos,int last,bool valid) // valid = valid number not starting with zero\\n    {\\n        if(pos==s.size())\\n            return 0;\\n        if(dp[pos][last]!=-1)\\n            return dp[pos][last];\\n        int sum=0;\\n        for(int i=0;i<10;++i)\\n        {\\n            int tvalid = valid || i>0;\\n            if(tvalid && isSet(last,i)) // satisfy the condition, calculate count\\n            {\\n                int dLeft = s.size()-pos -1;\\n                sum += pow(10,dLeft);\\n            }\\n            else if(tvalid)\\n            {\\n                int mask = setBit(last,i);\\n                sum+=digit_dp(s,pos+1,mask,tvalid);\\n            }\\n            else // not a valid number till now\\n                 sum+=digit_dp(s,pos+1,0,tvalid);\\n        }\\n        return dp[pos][last] = sum;\\n    }\\n    bool isSet(int number, int bit)\\n    {\\n        return number & (1<<bit);\\n    }\\n    int setBit(int number, int bit)\\n    {\\n        return number | (1<<bit);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741000,
                "title": "c-top-down-bitmask-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int DP[10][1 << 10][2][2];\\n\\n    int solve(const int idx, const int bm, const bool val, const bool onBorder, const bool doubleDigits, const string& S) {\\n        if (idx == int(S.length()))\\n            return doubleDigits;\\n        if (!onBorder && DP[idx][bm][val][doubleDigits] != -1)\\n            return DP[idx][bm][val][doubleDigits];\\n        int tot = 0;\\n        int until = onBorder ? (S[idx] - \\'0\\') : 9;\\n        for (int i = 0; i <= until; i++) {\\n            int nxtBm = bm;\\n            if (val || i > 0)\\n                nxtBm |= (1 << i);\\n            tot += solve(idx + 1, nxtBm, val || (i > 0), onBorder && i == until, doubleDigits || (bm & (1 << i)), S);\\n        }\\n        if (!onBorder)\\n            return DP[idx][bm][val][doubleDigits] = tot;\\n        return tot;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(DP, -1, sizeof(DP));\\n        return solve(0, 0, 0, 1, 0, to_string(n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int DP[10][1 << 10][2][2];\\n\\n    int solve(const int idx, const int bm, const bool val, const bool onBorder, const bool doubleDigits, const string& S) {\\n        if (idx == int(S.length()))\\n            return doubleDigits;\\n        if (!onBorder && DP[idx][bm][val][doubleDigits] != -1)\\n            return DP[idx][bm][val][doubleDigits];\\n        int tot = 0;\\n        int until = onBorder ? (S[idx] - \\'0\\') : 9;\\n        for (int i = 0; i <= until; i++) {\\n            int nxtBm = bm;\\n            if (val || i > 0)\\n                nxtBm |= (1 << i);\\n            tot += solve(idx + 1, nxtBm, val || (i > 0), onBorder && i == until, doubleDigits || (bm & (1 << i)), S);\\n        }\\n        if (!onBorder)\\n            return DP[idx][bm][val][doubleDigits] = tot;\\n        return tot;\\n    }\\n    \\n    int numDupDigitsAtMostN(int n) {\\n        memset(DP, -1, sizeof(DP));\\n        return solve(0, 0, 0, 1, 0, to_string(n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658861,
                "title": "c-math-based-solution-with-o-len-digits-n-time-and-o-1-space",
                "content": "When dealing with combinatorials, if you are looking for the number of possibilities with at least 1 of something (in this case, repeats), it can sometimes be easier to find the opposite (where there are no repeats) and then subtract that from the total number of possibilities.\\n\\n```\\n// Uncomment to increase debuggability (which increases run time)\\n//#define DEBUG\\n\\n#ifdef DEBUG\\n# define PRINT  printf\\n# define ASSERT assert\\n#else\\n# define PRINT\\n# define ASSERT\\n#endif\\n\\nstatic inline int numberOfDigits(int n)\\n{\\n    int count = 0;\\n    \\n    while(n > 0) {\\n        n /= 10;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\nint numDupDigitsAtMostN(int n){\\n    const int origN = n;\\n    const int origNumDigits = numberOfDigits(n);\\n    \\n    bool highUsed[10] = { false };\\n    // Count of numbers with NO repeated digits\\n    int count = 0;\\n    int multiple = 1;\\n    \\n    for (int i = 1; i < origNumDigits; i++) {\\n        multiple *= 10;\\n    }\\n    const int origMultiple = multiple;\\n    \\n    // test number = [1..(highDigit-1)]...\\n    if ((n / multiple) > 1) {\\n        int add = (n / multiple) - 1; // All digits below highDigit except 0\\n        for (int numUsed = 1; numUsed < origNumDigits; numUsed++) {\\n\\t\\t    // 10 is for all digits 0 to 9\\n\\t\\t\\t// numUsed is the number of those digits already used to generate the test number\\n            add *= 10 - numUsed;\\n        }\\n        count += add;\\n    }\\n    \\n    PRINT(\"1: %d\\\\n\", count);\\n    \\n    // test number = [prevHighDigit]...[highDigit][0..(nextHighDigit-1)]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    \\n        if (highUsed[highDigit] == true) {\\n\\t\\t    // If our highDigit was already used before, then all non-repeating solutions were counted\\n\\t\\t\\t// in previous loop iterations already\\n            break;\\n        } else if (numDigits == 1) {\\n\\t\\t    // The last digit in the number allows us to not repeat using all highDigits, so add one\\n            count++;\\n        } else {\\n            const int nextHighDigit = n / multiple;\\n            int numOptions = 0;\\n            int numUsed = 0;\\n                \\n            highUsed[highDigit] = true;\\n\\n            for (int i = 0; i < 10; i++) {\\n                if (highUsed[i] == false) {\\n                    if (i < nextHighDigit) {\\n                        numOptions++;\\n                    }\\n                } else {\\n                    numUsed++;\\n                }\\n            }\\n            if (numOptions > 0) {\\n                int add = numOptions;\\n\\n                numUsed++;\\n                for (; numUsed < origNumDigits; numUsed++) {\\n                    add *= 10 - numUsed;\\n                }\\n                count += add;\\n            }\\n        }\\n\\n        PRINT(\"2: %d\\\\n\", count);\\n    }\\n    \\n    n = origN;\\n    multiple = origMultiple;\\n    \\n    // test number = 0...0[1..9]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n                \\n        if (numDigits > 1) {\\n            int add = 9; // All digits except 0\\n            for (int numUsed = 1; numUsed < (numDigits - 1); numUsed++) {\\n                add *= 10 - numUsed;\\n            }\\n            count += add;\\n        }\\n        \\n        PRINT(\"3: %d\\\\n\", count);\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    }\\n    \\n    PRINT(\"%d vs %d\\\\n\", origN, count);\\n    ASSERT(origN >= count);\\n    return (origN - count);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Uncomment to increase debuggability (which increases run time)\\n//#define DEBUG\\n\\n#ifdef DEBUG\\n# define PRINT  printf\\n# define ASSERT assert\\n#else\\n# define PRINT\\n# define ASSERT\\n#endif\\n\\nstatic inline int numberOfDigits(int n)\\n{\\n    int count = 0;\\n    \\n    while(n > 0) {\\n        n /= 10;\\n        count++;\\n    }\\n    \\n    return count;\\n}\\n\\nint numDupDigitsAtMostN(int n){\\n    const int origN = n;\\n    const int origNumDigits = numberOfDigits(n);\\n    \\n    bool highUsed[10] = { false };\\n    // Count of numbers with NO repeated digits\\n    int count = 0;\\n    int multiple = 1;\\n    \\n    for (int i = 1; i < origNumDigits; i++) {\\n        multiple *= 10;\\n    }\\n    const int origMultiple = multiple;\\n    \\n    // test number = [1..(highDigit-1)]...\\n    if ((n / multiple) > 1) {\\n        int add = (n / multiple) - 1; // All digits below highDigit except 0\\n        for (int numUsed = 1; numUsed < origNumDigits; numUsed++) {\\n\\t\\t    // 10 is for all digits 0 to 9\\n\\t\\t\\t// numUsed is the number of those digits already used to generate the test number\\n            add *= 10 - numUsed;\\n        }\\n        count += add;\\n    }\\n    \\n    PRINT(\"1: %d\\\\n\", count);\\n    \\n    // test number = [prevHighDigit]...[highDigit][0..(nextHighDigit-1)]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    \\n        if (highUsed[highDigit] == true) {\\n\\t\\t    // If our highDigit was already used before, then all non-repeating solutions were counted\\n\\t\\t\\t// in previous loop iterations already\\n            break;\\n        } else if (numDigits == 1) {\\n\\t\\t    // The last digit in the number allows us to not repeat using all highDigits, so add one\\n            count++;\\n        } else {\\n            const int nextHighDigit = n / multiple;\\n            int numOptions = 0;\\n            int numUsed = 0;\\n                \\n            highUsed[highDigit] = true;\\n\\n            for (int i = 0; i < 10; i++) {\\n                if (highUsed[i] == false) {\\n                    if (i < nextHighDigit) {\\n                        numOptions++;\\n                    }\\n                } else {\\n                    numUsed++;\\n                }\\n            }\\n            if (numOptions > 0) {\\n                int add = numOptions;\\n\\n                numUsed++;\\n                for (; numUsed < origNumDigits; numUsed++) {\\n                    add *= 10 - numUsed;\\n                }\\n                count += add;\\n            }\\n        }\\n\\n        PRINT(\"2: %d\\\\n\", count);\\n    }\\n    \\n    n = origN;\\n    multiple = origMultiple;\\n    \\n    // test number = 0...0[1..9]...\\n    for (int numDigits = origNumDigits; numDigits > 0; numDigits--) {\\n        const int highDigit = n / multiple;\\n        const int highN = highDigit * multiple;\\n                \\n        if (numDigits > 1) {\\n            int add = 9; // All digits except 0\\n            for (int numUsed = 1; numUsed < (numDigits - 1); numUsed++) {\\n                add *= 10 - numUsed;\\n            }\\n            count += add;\\n        }\\n        \\n        PRINT(\"3: %d\\\\n\", count);\\n        \\n        // Prepare for next loop\\n        n -= highN;\\n        multiple /= 10;\\n    }\\n    \\n    PRINT(\"%d vs %d\\\\n\", origN, count);\\n    ASSERT(origN >= count);\\n    return (origN - count);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1601626,
                "title": "help",
                "content": "class Solution(object):\\n    def numDupDigitsAtMostN(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def check(n):\\n            if len(set(str(n))) == len(str(n)):\\n                return 0 \\n            else:\\n                return 1\\n        Count=0\\n        list_nums=[];\\n        for N in range(n+1):\\n            Count+=check(N)\\n        \\n    \\n            \\n        return Count\\n\\t\\t\\n\\t\\tSo this works, but for really big numbers it is slow and the time limit is exceeeded. Anyone has a fix for my code ?\\n\\t\\tcheers",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numDupDigitsAtMostN(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def check(n):\\n            if len(set(str(n))) == len(str(n)):\\n                return 0 \\n            else:\\n                return 1\\n        Count=0\\n        list_nums=[];\\n        for N in range(n+1):\\n            Count+=check(N)\\n        \\n    \\n            \\n        return Count\\n\\t\\t\\n\\t\\tSo this works, but for really big numbers it is slow and the time limit is exceeeded. Anyone has a fix for my code ?\\n\\t\\tcheers",
                "codeTag": "Java"
            },
            {
                "id": 1544355,
                "title": "c-solution-0ms-o-lgn-with-explanation",
                "content": "We can simply count the number of numbers with repeated digits.\\n\\nConsider numbers within range of [*a* *10^(*x* + 1),  *a* *10^(*x* + 1)+10^*x* - 1], the number of numbers without repeated digits is A_{10}^*x*. However, in the case where there are preceding 0s (for example, 120 might actually be 0120), the preceding 0s will not count as repeating digits. Therefore, the number must be specially counted when *a=0*. \\nLet *f(i)* be the count of repeating numbers in a range [*a* * 10^(i+1), *a* * 10^(i+1) + 10^i - 1] where *a>0*. Let *g(i)* be the count of numbers in [0, 10^i - 1]. Then we can solve *f(i), g(i)* with *g(i)* = *g(i-1) +9 * f(i-1)* and *f(i) = 10^i - A_9^i*. \\n\\nTake a random number 42430 for example. We first count the repeating numbers in [1, 10000], which is *g(4)*. Then in [10001, 40000], which is 3 * *f(4)*.\\nNext, count the repeating numbers in [40001, 42000]. Note that because 4 is already used, every thousand has only A_8^3 non-repeating numbers, and the count of non-repeating number is 2 * (1000 - A_8^3).\\nThen, count range [42001, 42400]. Because 2 is less than 3, all numbers 422xx will have repeated digits. The total count will be 3 * (100 - A_7^2) + 100. Notice that 4 is repeated now, every number since will have repeated digits.\\n\\n```\\nclass Solution {\\npublic:\\n    int comb[9][9];\\n    int numDupDigitsAtMostN(int n) {\\n        if (n <= 10) return 0;\\n        int f[8], g[9], power[8];\\n        // f: 1, 28, 496...\\n        // g: 0, 10, 262, ...\\n        // power: 10, 100, 1000, ...\\n        int product = 1;\\n        int total = 1;\\n        for (int i = 0; i < 8; i++)\\n        {\\n            product *= 9 - i;\\n            total *= 10;\\n            power[i] = total;\\n            f[i] = total - product;\\n        }\\n        g[0] = 1;\\n        for (int i = 1; i < 9; i++) \\n            g[i] = 9 * f[i - 1] + g[i - 1];\\n        g[0] = 0;\\n        if (n == 1000000000) return g[8];\\n        int ans = 0;\\n        vector<int> digits;\\n        for (int i = 7; i >= 0; i--)\\n        {\\n            if (n == power[i]) return g[i];\\n            if (n < power[i]) continue;\\n            ans += g[i];\\n\\n            bool has[10];\\n            for (int i = 0; i < 10; i++) has[i] = false;\\n            while (n > 0)\\n            {\\n                digits.push_back(n % 10); n /= 10;\\n            }\\n            int d = digits.back();\\n            digits.pop_back();\\n            has[d] = true;\\n            ans += f[i] * (d - 1);\\n            \\n            int j = i - 1;\\n            if (j < 0)  // two digits\\n            {\\n                if (digits[0] >= d) ans++;\\n            }\\n            while (j >= 0)\\n            {\\n                d = digits.back();\\n                digits.pop_back();\\n                for (int k = 0; k < d; k++)\\n                    ans += has[k]? power[j]: power[j] - A(j + 1, 9 - i + j);\\n                if (j == 0 && !has[d]) \\n                {\\n                    ans--;\\n                    has[d] = true;\\n                    for (int k = 0; k <= digits.back(); k++)\\n                        ans += has[k]? 1: 0;\\n                    break;\\n                }\\n                if (has[d])\\n                {\\n                    // add all as repeated\\n                    int p = 1;\\n                    for (int dd: digits)\\n                    {\\n                        ans += dd * p; p *= 10;\\n                    }\\n                    break;\\n                }\\n                has[d] = true;        \\n                j--;\\n            }\\n            break;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n    int A(int x, int y)\\n    {\\n        // x <= y;\\n        if (comb[x][y] != 0) return comb[x][y];\\n        int product = 1;\\n        for (int i = 0; i < x; i++)\\n            product *= y - i;\\n        comb[x][y] = product;\\n        return product;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int comb[9][9];\\n    int numDupDigitsAtMostN(int n) {\\n        if (n <= 10) return 0;\\n        int f[8], g[9], power[8];\\n        // f: 1, 28, 496...\\n        // g: 0, 10, 262, ...\\n        // power: 10, 100, 1000, ...\\n        int product = 1;\\n        int total = 1;\\n        for (int i = 0; i < 8; i++)\\n        {\\n            product *= 9 - i;\\n            total *= 10;\\n            power[i] = total;\\n            f[i] = total - product;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1442782,
                "title": "javascript-digits-traversal",
                "content": "```\\nvar numDupDigitsAtMostN = function(n) {\\n    n = n.toString();\\n    \\n    let count = 0, set = new Set(), distinctDigits;\\n\\n    let ways = 9;\\n    \\n    // Numbers with digits less then N\\n\\n    for (let i = 0; i < n.length - 1; i++) {\\n        count += ways;\\n        ways *= (9 - i);\\n    }\\n\\n    const permutation = (total, selectCount) => {\\n        let nCr = 1;\\n        for (let i = 0; i < selectCount; i++)\\n            nCr *= (total - i);\\n\\n        return nCr;\\n    }\\n    \\n    for (let i = 0; i < n.length; i++) {\\n        distinctDigits = 0;\\n        for (let j = (i === 0) ? 1 : 0; j < n.charCodeAt(i) - \"0\".charCodeAt(0); j++) {\\n            if (!set.has(`${j}`))\\n                distinctDigits++;\\n        }\\n        count += distinctDigits * permutation(9 - set.size, n.length - 1 - i);;\\n\\n        if (set.has(n[i]))\\n            break;\\n\\n        set.add(n[i]);\\n    }\\n\\n    count += (set.size === n.length);\\n\\n    return Number(n) - count;\\n};",
                "solutionTags": [],
                "code": "```\\nvar numDupDigitsAtMostN = function(n) {\\n    n = n.toString();\\n    \\n    let count = 0, set = new Set(), distinctDigits;\\n\\n    let ways = 9;\\n    \\n    // Numbers with digits less then N\\n\\n    for (let i = 0; i < n.length - 1; i++) {\\n        count += ways;\\n        ways *= (9 - i);\\n    }\\n\\n    const permutation = (total, selectCount) => {\\n        let nCr = 1;\\n        for (let i = 0; i < selectCount; i++)\\n            nCr *= (total - i);\\n\\n        return nCr;\\n    }\\n    \\n    for (let i = 0; i < n.length; i++) {\\n        distinctDigits = 0;\\n        for (let j = (i === 0) ? 1 : 0; j < n.charCodeAt(i) - \"0\".charCodeAt(0); j++) {\\n            if (!set.has(`${j}`))\\n                distinctDigits++;\\n        }\\n        count += distinctDigits * permutation(9 - set.size, n.length - 1 - i);;\\n\\n        if (set.has(n[i]))\\n            break;\\n\\n        set.add(n[i]);\\n    }\\n\\n    count += (set.size === n.length);\\n\\n    return Number(n) - count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1440444,
                "title": "c-solution-dp-combinations",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n         vector<int> number;\\n         for(int i=n; i>0; i/=10) number.push_back(i%10);\\n         reverse(number.begin(),number.end());\\n         int len=number.size();\\n         vector<int> dp(len,0);\\n         int tot=0;\\n         for(int i=0; i<len-1; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               tot+=dp[i];\\n         }\\n         vector<int> cnt(10,0);\\n         dp.clear();\\n         dp.resize(len,0);\\n         bool same=0;\\n         for(int i=0; i<len; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               int diff=0;\\n               if(!same) {\\n                  for(int digit=number[i]+1; digit<10; digit++) diff+=(cnt[digit]==0);\\n                  dp[i]-=diff;\\n                  cnt[number[i]]++;\\n                  if(cnt[number[i]]>1) same=1;\\n               }\\n         }\\n        return n-(tot+dp[len-1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n         vector<int> number;\\n         for(int i=n; i>0; i/=10) number.push_back(i%10);\\n         reverse(number.begin(),number.end());\\n         int len=number.size();\\n         vector<int> dp(len,0);\\n         int tot=0;\\n         for(int i=0; i<len-1; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               tot+=dp[i];\\n         }\\n         vector<int> cnt(10,0);\\n         dp.clear();\\n         dp.resize(len,0);\\n         bool same=0;\\n         for(int i=0; i<len; i++) {\\n               dp[i]=i==0?9:dp[i-1]*(10-i);\\n               int diff=0;\\n               if(!same) {\\n                  for(int digit=number[i]+1; digit<10; digit++) diff+=(cnt[digit]==0);\\n                  dp[i]-=diff;\\n                  cnt[number[i]]++;\\n                  if(cnt[number[i]]>1) same=1;\\n               }\\n         }\\n        return n-(tot+dp[len-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439792,
                "title": "python-33ms-o-len-digit-n-solution-dp-and-descent",
                "content": "We have follow observation, if we want to count all numbers with repeated digits with i digits:\\n1. all count *cnt = 9 * (10 ** (i - 1)* numbers;\\n2. dp[k] can form by two part:(1) (i - 1) digits numbers with repeated numbers append 0-9 in the end, dp[i - 1] * 10; (2) (i - 1) digits numbers without repeated numbers,  so we can choose one from these (i - 1) different digits,(cnt - dp[i - 1]) * (i -1);\\n3. All repeated digits sperate equally in numbers starting with 1-9.\\n\\nThen, if we want to count specific number 3779, we have follow ideas:\\nWe first count all numbers have less digits, ans = sum(dp[0:4]) = 261;then process the number from high to low digits, 1*** = 2***=...=9***= dp[4] / 9 = 496, ans += 2 * 496=1253;\\nthe we process 30**, 31**,...36**, notice 33** all 100 numbers meet condition,  so all other 30**..,39** have (496 - 100) / 9 = 44, ans += 100 + 44 * 6 = 1617; then we process 370*, 371*,...376*, notice 373* and 377* all 20 numbers meet condition, so all other 370*, ...379* have (44 - 20)/8=3, ans += 10 + 3 * 6=1645; then we have reapeated digits in prefix, so all left 3770-3779 all meet condition, ans += 10 = 1655\\n\\n```\\nfrom math import log10\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        m = int(log10(n)) + 1\\n        if m == 1: return 0\\n        dp = [0] * (m + 1)\\n        dp[2] = 9\\n        cnt = 90\\n        for i in range(3, m + 1):\\n            dp[i] = dp[i - 1] * 10 + (cnt - dp[i - 1]) * (i - 1)\\n            cnt *= 10\\n        ans = sum(dp[:-1])\\n        init, t = dp[-1], 10 ** (m - 1)\\n        prefix = []\\n        for i, v in enumerate(str(n)):\\n            v = ord(v) - ord(\\'0\\')\\n            if not prefix:\\n                prefix.append(v)\\n                init //= 9\\n                ans += (v - 1) * init\\n            else:\\n                same = 0\\n                for k in range(v):\\n                    if k in prefix: same += 1\\n                ans += same * t\\n                init = (init - len(prefix) * t) // (10 - len(prefix))\\n                if v - same > 0: ans += init * (v - same)\\n                if v in prefix:\\n                    ans += 1\\n                    if str(n)[i + 1:]: ans += int(str(n)[i + 1:])\\n                    break\\n                prefix.append(v)\\n            t //= 10\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import log10\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        m = int(log10(n)) + 1\\n        if m == 1: return 0\\n        dp = [0] * (m + 1)\\n        dp[2] = 9\\n        cnt = 90\\n        for i in range(3, m + 1):\\n            dp[i] = dp[i - 1] * 10 + (cnt - dp[i - 1]) * (i - 1)\\n            cnt *= 10\\n        ans = sum(dp[:-1])\\n        init, t = dp[-1], 10 ** (m - 1)\\n        prefix = []\\n        for i, v in enumerate(str(n)):\\n            v = ord(v) - ord(\\'0\\')\\n            if not prefix:\\n                prefix.append(v)\\n                init //= 9\\n                ans += (v - 1) * init\\n            else:\\n                same = 0\\n                for k in range(v):\\n                    if k in prefix: same += 1\\n                ans += same * t\\n                init = (init - len(prefix) * t) // (10 - len(prefix))\\n                if v - same > 0: ans += init * (v - same)\\n                if v in prefix:\\n                    ans += 1\\n                    if str(n)[i + 1:]: ans += int(str(n)[i + 1:])\\n                    break\\n                prefix.append(v)\\n            t //= 10\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412851,
                "title": "digit-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][5000];\\n    int fnd(int i, bool tight, int used, string& n)\\n    {\\n        if(i==n.length())\\n            return 1;\\n        \\n        if(dp[i][tight][used]!=-1)\\n            return dp[i][tight][used];\\n        \\n        int ub= tight? n[i]-\\'0\\':10,ans=0;\\n        \\n        for(int j=0;j<ub;j++)\\n        {\\n            if(used==0 && j==0)\\n            {\\n                ans+=fnd(i+1,false,used,n);\\n                continue;\\n            }\\n            \\n            if(used&(1<<j))\\n                continue;\\n            \\n            ans+=fnd(i+1,false,used|(1<<j),n);\\n        }\\n        \\n        if(tight && (used&(1<<ub))==0)\\n            ans+=fnd(i+1,true,used|(1<<ub),n);\\n        \\n        return dp[i][tight][used]=ans;\\n        \\n    }\\n    \\n    int numDupDigitsAtMostN(int num) {\\n        string n=to_string(num);\\n        memset(dp,-1,sizeof(dp));\\n        return num-fnd(0,true,0,n)+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[11][2][5000];\\n    int fnd(int i, bool tight, int used, string& n)\\n    {\\n        if(i==n.length())\\n            return 1;\\n        \\n        if(dp[i][tight][used]!=-1)\\n            return dp[i][tight][used];\\n        \\n        int ub= tight? n[i]-\\'0\\':10,ans=0;\\n        \\n        for(int j=0;j<ub;j++)\\n        {\\n            if(used==0 && j==0)\\n            {\\n                ans+=fnd(i+1,false,used,n);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1388486,
                "title": "python-logarithmic-recursion",
                "content": "```\\nimport operator as op\\nfrom functools import reduce\\n\\ndef generate(num):\\n    if len(num) == 1:\\n        return int(num) + 1\\n    \\n    ans = (int(num[0]) - 1) * reduce(op.mul, [9 - i for i in range(len(num) - 1)])\\n    pool = set([int(num[0])])\\n    \\n    for i in range(1, len(num)):\\n        res = 1\\n        for j in range(i + 1, len(num)):\\n            res *= (10 - j)\\n\\n        ans += res * len(set([i for i in range(int(num[i]))]).difference(pool))\\n        if int(num[i]) in pool:\\n            break\\n        pool.add(int(num[i]))\\n        \\n    return ans + int(isUnique(num)) + generate(\\'9\\' * (len(num) - 1))\\n\\ndef isUnique(num):\\n    marked = [-1 for i in range(10)]\\n    num = int(num)\\n    while num:\\n        d = num % 10\\n        if marked[d] != -1:\\n            return False\\n        marked[d] = 1\\n        num //= 10\\n    \\n    return True\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        return n - (generate(str(n)) - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nimport operator as op\\nfrom functools import reduce\\n\\ndef generate(num):\\n    if len(num) == 1:\\n        return int(num) + 1\\n    \\n    ans = (int(num[0]) - 1) * reduce(op.mul, [9 - i for i in range(len(num) - 1)])\\n    pool = set([int(num[0])])\\n    \\n    for i in range(1, len(num)):\\n        res = 1\\n        for j in range(i + 1, len(num)):\\n            res *= (10 - j)\\n\\n        ans += res * len(set([i for i in range(int(num[i]))]).difference(pool))\\n        if int(num[i]) in pool:\\n            break\\n        pool.add(int(num[i]))\\n        \\n    return ans + int(isUnique(num)) + generate(\\'9\\' * (len(num) - 1))\\n\\ndef isUnique(num):\\n    marked = [-1 for i in range(10)]\\n    num = int(num)\\n    while num:\\n        d = num % 10\\n        if marked[d] != -1:\\n            return False\\n        marked[d] = 1\\n        num //= 10\\n    \\n    return True\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        return n - (generate(str(n)) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381869,
                "title": "test-cases-passed-tle-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int sum=0,i,j,k;\\n        for(i=1;i<=n;i++)\\n        {\\n            string s=to_string(i);\\n            int sz=s.size();\\n            set<char> st;\\n            for(j=0;j<sz;j++)\\n                st.insert(s[j]);\\n            if(st.size()<sz)\\n                sum++;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numDupDigitsAtMostN(int n) {\\n        int sum=0,i,j,k;\\n        for(i=1;i<=n;i++)\\n        {\\n            string s=to_string(i);\\n            int sz=s.size();\\n            set<char> st;\\n            for(j=0;j<sz;j++)\\n                st.insert(s[j]);\\n            if(st.size()<sz)\\n                sum++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1367853,
                "title": "c-commented-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int permutation(int m,int n){\\n        if(n==0)return 1;\\n        return (m-n+1)*permutation(m,n-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        vector<int>num;\\n        int number=N;\\n        N=N+1;\\n        while(N>0){                // storing all digits \\n            num.push_back(N%10);\\n            N=N/10;\\n        }\\n        reverse(num.begin(),num.end());    \\n        int n=num.size();\\n        int res=0;\\n        for(int i=0;i<n-1;i++){         //calculate all numbers which have less digits than in N\\n            res+=9*permutation(9,i);\\n        }\\n        unordered_set<int>seen;\\n/*calculate number which have same disits as N and not contain any two digits same ans less than N */\\n        for(int i=0;i<n;i++){  \\n            for(int j=i>0?0:1;j<num[i];j++){  //check for which is less than current digit in N \\n                if(seen.find(j)==seen.end()){  //check if it has not visited yet\\n                    res+=permutation(9-i,n-i-1);\\n                }\\n            }\\n            if(seen.find(num[i])!=seen.end()) break;  //if a number is repeated in N itself no more number possible which are less and not contain duplicate\\n            seen.insert(num[i]);   //mark as seen current digit\\n        }\\n        return number-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int permutation(int m,int n){\\n        if(n==0)return 1;\\n        return (m-n+1)*permutation(m,n-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        vector<int>num;\\n        int number=N;\\n        N=N+1;\\n        while(N>0){                // storing all digits \\n            num.push_back(N%10);\\n            N=N/10;\\n        }\\n        reverse(num.begin(),num.end());    \\n        int n=num.size();\\n        int res=0;\\n        for(int i=0;i<n-1;i++){         //calculate all numbers which have less digits than in N\\n            res+=9*permutation(9,i);\\n        }\\n        unordered_set<int>seen;\\n/*calculate number which have same disits as N and not contain any two digits same ans less than N */\\n        for(int i=0;i<n;i++){  \\n            for(int j=i>0?0:1;j<num[i];j++){  //check for which is less than current digit in N \\n                if(seen.find(j)==seen.end()){  //check if it has not visited yet\\n                    res+=permutation(9-i,n-i-1);\\n                }\\n            }\\n            if(seen.find(num[i])!=seen.end()) break;  //if a number is repeated in N itself no more number possible which are less and not contain duplicate\\n            seen.insert(num[i]);   //mark as seen current digit\\n        }\\n        return number-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365853,
                "title": "c-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int dp[12][11];\\n    int dp1[12][12][3];\\n    int solve(int vis[],int ind,int max){\\n        if(dp[ind][max]!=-1){\\n            return dp[ind][max];\\n        }\\n        if(ind>max){\\n             return 1;\\n        }\\n        int  res=0;\\n        for(int i=0;i<=9;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                res+=solve(vis,ind+1,max);\\n                 vis[i]=0;\\n            }\\n        }\\n        return  dp[ind][max]=res;\\n        \\n    }\\n    int solve1(vector<int>&v,int vis[],int ind,int max,bool isTrue){\\n        if(dp1[ind][max][isTrue]!=-1){\\n            return dp1[ind][max][isTrue];\\n        }\\n       if(ind>max){\\n             return 1;\\n        }\\n        int end=9;\\n        if(isTrue){\\n            end=v[ind-1];\\n        }\\n        int res=0;\\n        for(int i=0;i<=end;i++){\\n            if(vis[i]==0){\\n                vis[i]=1;\\n                res+=solve1(v,vis,ind+1,max,(isTrue)&(v[ind-1]==i));\\n                vis[i]=0;\\n            }\\n        }\\n        return dp1[ind][max][isTrue]= res;\\n        \\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof dp);\\n        memset(dp1,-1,sizeof dp1);\\n        int xn=n;\\n        int count=0;\\n        vector<int>v;\\n        while(xn!=0){\\n            v.push_back(xn%10);\\n            xn/=10;\\n            count++;\\n        }\\n     \\n        reverse(v.begin(),v.end());\\n        int res=0;\\n        int vis[10];\\n        memset(vis,0,sizeof vis);\\n        for(int i=1;i<count;i++){\\n            for(int j=1;j<=9;j++){\\n                memset(vis,0,sizeof vis);\\n                vis[j]=1;\\n                res+=solve(vis,2,i);\\n                vis[j]=0;\\n              \\n            }\\n        }\\n        \\n         for(int j=1;j<=v[0];j++){\\n             memset(vis,0,sizeof vis);\\n             vis[j]=1;\\n             \\n            res+=solve1(v,vis,2,count,true&(j==v[0]));\\n           \\n         }\\n             \\n\\n        return n-(res);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[12][11];\\n    int dp1[12][12][3];\\n    int solve(int vis[],int ind,int max){\\n        if(dp[ind][max]!=-1){\\n            return dp[ind][max];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1332533,
                "title": "c-solution-faster-than-100",
                "content": "```\\n// Check if N is without repeated digits.\\nint isRepeated(const vector<int> &num){\\n    const int size = static_cast<int>(num.size());\\n    vector<int> digit(10, 0);\\n    for (int i=0; i<size; ++i) {\\n        if (digit[num[i]] > 0) {return true;}\\n        ++digit[num[i]];\\n    }\\n    return false;\\n}\\n\\nint numDupDigitsAtMostN(int n) {\\n    if (n == 0) {return 0;}\\n    \\n    // Int -> int vector\\n    const int N = n;\\n    int size = 0;\\n    vector<int> num;\\n    while (n != 0) {\\n        num.push_back(n % 10);\\n        n /= 10;\\n        ++ size;\\n    }\\n    reverse(num.begin(), num.end());\\n    \\n    // Calculate the number of 1 ~ (size - 1) digits without repeated digits.\\n    int noRepeated = 0;\\n    for (int i=1; i<=size-1; ++i) {\\n        int remain = 9;\\n        int count = 9;\\n        for (int j=2; j<=i; ++j) {\\n            count *= remain--;\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Calculate the number of size digits without repeated digits.\\n    for (int i=0; i<size; ++i) {\\n        // Initialization of remain\\n        int remain;\\n        i == 0 ? remain = num[i] - 1 : remain = num[i];\\n        \\n        // If prefix is the number with repaeted digits, the loop break\\n        vector<int> prefix(i);\\n        copy(num.begin(), num.begin() + i, prefix.begin());\\n        if (isRepeated(prefix)) {break;}\\n        \\n        // Delete choosen numbers from remain\\n        for (int j=0; j<i; ++j) {\\n            if (num[j] <= num[i] - 1) {--remain;}\\n        }\\n        \\n        // Count\\n        int count = remain;\\n        for (int j=i+1; j<size; ++j) {\\n            count *= (10 - j);\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Check if N is the number without repeated digits.\\n    isRepeated(num) ? 1 : ++noRepeated;\\n    \\n    return N - noRepeated;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Check if N is without repeated digits.\\nint isRepeated(const vector<int> &num){\\n    const int size = static_cast<int>(num.size());\\n    vector<int> digit(10, 0);\\n    for (int i=0; i<size; ++i) {\\n        if (digit[num[i]] > 0) {return true;}\\n        ++digit[num[i]];\\n    }\\n    return false;\\n}\\n\\nint numDupDigitsAtMostN(int n) {\\n    if (n == 0) {return 0;}\\n    \\n    // Int -> int vector\\n    const int N = n;\\n    int size = 0;\\n    vector<int> num;\\n    while (n != 0) {\\n        num.push_back(n % 10);\\n        n /= 10;\\n        ++ size;\\n    }\\n    reverse(num.begin(), num.end());\\n    \\n    // Calculate the number of 1 ~ (size - 1) digits without repeated digits.\\n    int noRepeated = 0;\\n    for (int i=1; i<=size-1; ++i) {\\n        int remain = 9;\\n        int count = 9;\\n        for (int j=2; j<=i; ++j) {\\n            count *= remain--;\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Calculate the number of size digits without repeated digits.\\n    for (int i=0; i<size; ++i) {\\n        // Initialization of remain\\n        int remain;\\n        i == 0 ? remain = num[i] - 1 : remain = num[i];\\n        \\n        // If prefix is the number with repaeted digits, the loop break\\n        vector<int> prefix(i);\\n        copy(num.begin(), num.begin() + i, prefix.begin());\\n        if (isRepeated(prefix)) {break;}\\n        \\n        // Delete choosen numbers from remain\\n        for (int j=0; j<i; ++j) {\\n            if (num[j] <= num[i] - 1) {--remain;}\\n        }\\n        \\n        // Count\\n        int count = remain;\\n        for (int j=i+1; j<size; ++j) {\\n            count *= (10 - j);\\n        }\\n        noRepeated += count;\\n    }\\n    \\n    // Check if N is the number without repeated digits.\\n    isRepeated(num) ? 1 : ++noRepeated;\\n    \\n    return N - noRepeated;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1248941,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<11)return 0;\\n        string s=to_string(N);\\n        int n=s.size();\\n        int ans=0;\\n        vector<bool>used(10,false);\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            int keep=ans;\\n            used[i]=true;\\n            ans+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        used[s[0]-\\'0\\']=true;\\n        ans+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return N-ans;\\n    }\\n    int helper(string s,int limit,vector<bool> used)\\n    {\\n        int n=s.size();\\n        int size=0;\\n        for(auto x:used)if(x==true)size++;\\n        if(n==1&&limit==10)return 10-size;\\n        if(n==1&&limit!=10)\\n        {\\n            int res=0;\\n            for(int i=s[0]-\\'0\\';i>=0;i--)if(used[i]==false)res++;\\n            return res;\\n        }\\n        if(limit==10)\\n        {\\n            int res=1;\\n            if(size==1&&used[0]==true)\\n            {\\n                res=9;\\n                for(int i=0;i<n-1;i++)res*=(10-size-i);\\n                res+=helper(s.substr(1),10,used);\\n                return res;\\n            }\\n            for(int i=0;i<n;i++)res*=(10-size-i);\\n            return res;\\n        }\\n        int res=0;\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            if(used[i]==true)continue;\\n            used[i]=true;\\n            res+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        if(used[s[0]-\\'0\\']==true)return res;\\n        used[s[0]-\\'0\\']=true;\\n        res+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<11)return 0;\\n        string s=to_string(N);\\n        int n=s.size();\\n        int ans=0;\\n        vector<bool>used(10,false);\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            int keep=ans;\\n            used[i]=true;\\n            ans+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        used[s[0]-\\'0\\']=true;\\n        ans+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return N-ans;\\n    }\\n    int helper(string s,int limit,vector<bool> used)\\n    {\\n        int n=s.size();\\n        int size=0;\\n        for(auto x:used)if(x==true)size++;\\n        if(n==1&&limit==10)return 10-size;\\n        if(n==1&&limit!=10)\\n        {\\n            int res=0;\\n            for(int i=s[0]-\\'0\\';i>=0;i--)if(used[i]==false)res++;\\n            return res;\\n        }\\n        if(limit==10)\\n        {\\n            int res=1;\\n            if(size==1&&used[0]==true)\\n            {\\n                res=9;\\n                for(int i=0;i<n-1;i++)res*=(10-size-i);\\n                res+=helper(s.substr(1),10,used);\\n                return res;\\n            }\\n            for(int i=0;i<n;i++)res*=(10-size-i);\\n            return res;\\n        }\\n        int res=0;\\n        for(int i=0;i<s[0]-\\'0\\';i++)\\n        {\\n            if(used[i]==true)continue;\\n            used[i]=true;\\n            res+=helper(s.substr(1),10,used);\\n            used[i]=false;\\n        }\\n        if(used[s[0]-\\'0\\']==true)return res;\\n        used[s[0]-\\'0\\']=true;\\n        res+=helper(s.substr(1),s[0]-\\'0\\',used);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248246,
                "title": "swift-dp",
                "content": "```swift\\nclass Solution {\\n    private var memo = [Int:Int]()\\n    private var upperBound = [Int]()\\n    \\n    func numDupDigitsAtMostN(_ n: Int) -> Int {\\n        \\n        self.upperBound = caculateUpperBound(of: n)\\n        self.memo = [:]\\n        \\n        return n - dfs(self.upperBound.count - 1, 0, 0,0) + 1\\n    }\\n    \\n    private func caculateUpperBound(of num: Int) -> [Int] {\\n        var ans = [Int]()\\n        var n = num\\n        while n > 0 {\\n            ans.append(n % 10)\\n            n /= 10\\n        }\\n        return ans\\n    }\\n    \\n    private func dfs(_ curPos: Int, _ preNum: Int, _ targetMax: Int, _ usedDigits: Int) -> Int {\\n        guard curPos >= 0 else {\\n            return 1\\n        }\\n        let key =  (usedDigits << 32) | curPos\\n        if preNum < targetMax && preNum != 0 {\\n            guard nil == self.memo[key] else {\\n                return self.memo[key]!\\n            }\\n        }\\n        let upperLimit = preNum < targetMax ? 9 : self.upperBound[curPos]\\n        var ret = 0\\n        for num in 0...upperLimit {\\n            //\\u4FDD\\u8BC1\\u6CA1\\u6709\\u4F7F\\u7528\\u8FC7\\n            if usedDigits & (1 << num) == 0 {\\n                ret += dfs(curPos - 1, preNum * 10 + num, targetMax * 10 + self.upperBound[curPos], preNum + num == 0 ? 0 : (usedDigits | (1 << num)) )\\n            }\\n        }\\n        if preNum < targetMax && preNum != 0 {\\n            self.memo[key] = ret\\n        }\\n        return ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```swift\\nclass Solution {\\n    private var memo = [Int:Int]()\\n    private var upperBound = [Int]()\\n    \\n    func numDupDigitsAtMostN(_ n: Int) -> Int {\\n        \\n        self.upperBound = caculateUpperBound(of: n)\\n        self.memo = [:]\\n        \\n        return n - dfs(self.upperBound.count - 1, 0, 0,0) + 1\\n    }\\n    \\n    private func caculateUpperBound(of num: Int) -> [Int] {\\n        var ans = [Int]()\\n        var n = num\\n        while n > 0 {\\n            ans.append(n % 10)\\n            n /= 10\\n        }\\n        return ans\\n    }\\n    \\n    private func dfs(_ curPos: Int, _ preNum: Int, _ targetMax: Int, _ usedDigits: Int) -> Int {\\n        guard curPos >= 0 else {\\n            return 1\\n        }\\n        let key =  (usedDigits << 32) | curPos\\n        if preNum < targetMax && preNum != 0 {\\n            guard nil == self.memo[key] else {\\n                return self.memo[key]!\\n            }\\n        }\\n        let upperLimit = preNum < targetMax ? 9 : self.upperBound[curPos]\\n        var ret = 0\\n        for num in 0...upperLimit {\\n            //\\u4FDD\\u8BC1\\u6CA1\\u6709\\u4F7F\\u7528\\u8FC7\\n            if usedDigits & (1 << num) == 0 {\\n                ret += dfs(curPos - 1, preNum * 10 + num, targetMax * 10 + self.upperBound[curPos], preNum + num == 0 ? 0 : (usedDigits | (1 << num)) )\\n            }\\n        }\\n        if preNum < targetMax && preNum != 0 {\\n            self.memo[key] = ret\\n        }\\n        return ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233695,
                "title": "digit-dp-and-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][2][1025];\\n    int recursive(vector<int> &vec,int idx,int mask,int tight,int flag)\\n    {\\n        if(idx==vec.size())\\n        {\\n            //cout<<mask<<endl;\\n            return 1;\\n        }\\n        if(dp[idx][tight][flag][mask]!=-1)\\n            return dp[idx][tight][flag][mask];\\n        int var=0;\\n        if(tight==1)\\n        {\\n            for(int i=0;i<=vec[idx];i++)\\n            {\\n                if(i==vec[idx])\\n                {\\n                    if((mask&1<<i)==0)\\n                    {\\n                         if(flag==0&&i==0)\\n                             var+=recursive(vec,idx+1,mask,1,flag);\\n                         else\\n                             var+=recursive(vec,idx+1,mask|1<<i,1,flag|1);\\n                    }\\n                }\\n                else\\n                {\\n                    if((mask&1<<i)==0)\\n                    {\\n                         if(flag==0&&i==0)\\n                             var+=recursive(vec,idx+1,mask,0,flag);\\n                         else\\n                             var+=recursive(vec,idx+1,mask|1<<i,0,flag|1);\\n                    }\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<=9;i++)\\n            {\\n                if((mask&1<<i)==0)\\n                {\\n                    if(flag==0&&i==0)\\n                        var+=recursive(vec,idx+1,mask,0,flag);\\n                    else\\n                        var+=recursive(vec,idx+1,mask|1<<i,0,flag|1);\\n                }\\n            }\\n        }\\n        \\n        \\n        return dp[idx][tight][flag][mask]=var;\\n    }\\n    int numDupDigitsAtMostN(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> vec;\\n        int var=n;\\n        while(n)\\n        {\\n            vec.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        /*for(int i=0;i<vec.size();i++)\\n            cout<<vec[i]<<\" \";*/\\n        //cout<<(1<<0)<<endl;\\n        int ans=recursive(vec,0,0,1,0);\\n        //cout<<ans<<endl;\\n        return var-ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[10][2][2][1025];\\n    int recursive(vector<int> &vec,int idx,int mask,int tight,int flag)\\n    {\\n        if(idx==vec.size())\\n        {\\n            //cout<<mask<<endl;\\n            return 1;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1220443,
                "title": "faster-than-98-python3-solution",
                "content": "First idea: we will count numbers from [1;n] where all digit are different. If we get **S**, then we return **n-S** as the answer.\\nWe start with finding number nd such as 10^nd<=n<10^(nd+1). First digit of n will be **fd=n//(10^nd)**.\\nAll numbers from [1;n] with different digits consist of three parts.\\n1. Those that have **nd** or less digits - **uptod**(nd) function computes that.\\n2. Those that have first digit from [1;fd-1] range, and after that come other **nd** digits. For each starting digit, there are **ndig(nd,1)** of them.\\n3. Those that start from **fd** and after that have other **nd** digits - that set is computed with **zupto** call.\\n\\nFunction **ndig** calculates, how many combination of **nd** digits there are, if **nused** digits are already used (thus prohibited).\\nFunction **uptod** calculates, how many numbers that have **nd** digits or less, consist of all different digits.\\nFunction **zupto** calculates, how many (zero-padded) numbers with **nd** digits, not greater than **n**, there can be, if **used** set is prohibited,\\n\\n```\\nfrom math import factorial as fac\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        def ndig(nd,nused):\\n            navail = 10-nused\\n            if nd>navail:\\n                return 0\\n            return fac(navail)//fac(navail-nd)\\n        def uptod(nd):\\n            if nd==1:\\n                return 9\\n            #assert(nd>1)\\n            return uptod(nd-1)+9*ndig(nd-1,1)\\n        def zupto(nd,n,used):\\n            if nd==1:\\n                return sum(1 for d in range(n+1) if d not in used)\\n            #assert(nd>1)\\n            #assert(n<10**nd)\\n            f1 = 10**(nd-1)\\n            fd = n//f1\\n            S = 0\\n            for d in range(fd):\\n                if d not in used:\\n                    S += ndig(nd-1,len(used)+1)\\n            if fd not in used:\\n                used.add(fd)\\n                S += zupto(nd-1,n%f1,used)\\n                used.remove(fd)\\n            return S\\n        \\n        if n<=10:\\n            return 0\\n        \\n        pow10 = 10\\n        nd = 0\\n        while pow10<=n:\\n            pow10 *= 10\\n            nd += 1\\n        pow10 //= 10\\n        print(pow10,nd)\\n        assert(len(str(n))==nd+1)\\n        S = uptod(nd)\\n        fd = n//pow10\\n        S += (fd-1)*ndig(nd,1)\\n        used = {fd}\\n        S += zupto(nd,n%pow10,used)\\n        return n-S\\n```    \\n",
                "solutionTags": [],
                "code": "```\\nfrom math import factorial as fac\\n\\nclass Solution:\\n    def numDupDigitsAtMostN(self, n: int) -> int:\\n        def ndig(nd,nused):\\n            navail = 10-nused\\n            if nd>navail:\\n                return 0\\n            return fac(navail)//fac(navail-nd)\\n        def uptod(nd):\\n            if nd==1:\\n                return 9\\n            #assert(nd>1)\\n            return uptod(nd-1)+9*ndig(nd-1,1)\\n        def zupto(nd,n,used):\\n            if nd==1:\\n                return sum(1 for d in range(n+1) if d not in used)\\n            #assert(nd>1)\\n            #assert(n<10**nd)\\n            f1 = 10**(nd-1)\\n            fd = n//f1\\n            S = 0\\n            for d in range(fd):\\n                if d not in used:\\n                    S += ndig(nd-1,len(used)+1)\\n            if fd not in used:\\n                used.add(fd)\\n                S += zupto(nd-1,n%f1,used)\\n                used.remove(fd)\\n            return S\\n        \\n        if n<=10:\\n            return 0\\n        \\n        pow10 = 10\\n        nd = 0\\n        while pow10<=n:\\n            pow10 *= 10\\n            nd += 1\\n        pow10 //= 10\\n        print(pow10,nd)\\n        assert(len(str(n))==nd+1)\\n        S = uptod(nd)\\n        fd = n//pow10\\n        S += (fd-1)*ndig(nd,1)\\n        used = {fd}\\n        S += zupto(nd,n%pow10,used)\\n        return n-S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195635,
                "title": "32ms-python-solution-n-no-of-non-repeated-digit-integer-approach",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        if N <= 10:\\n            return 0\\n        \\n        lst = list(str(N))\\n        l = len(lst)\\n\\t\\t# Create memo for no. of non repeated digits for cases, 10, 100, 1000...\\n\\t\\t# Calculation: 9 x 9 x 8 x .....\\n        memo = { 1: 0, \\n                 2: 9, \\n                 3: 81, \\n                 4: 648, \\n                 5: 4536,\\n                 6: 27216, \\n                 7: 136080, \\n                 8: 544320,\\n                 9: 1632960,\\n                 10: 3265920}\\n        \\n        prev = []\\n        \\n        nrpc = 0\\n        for i in range(l):\\n            nrpc += memo[i+1]        \\n        \\n        nrpc += ((int(lst[0])-1) * int(memo[i+2]/9))\\n        prev.append(int(lst[0]))\\n        not_repeat = True\\n        \\n        for i in range(1, l):\\n            if not_repeat:\\n                if lst[i] != \\'0\\' and i != l-1:\\n                    c = 9-i\\n                    r = l-1-i\\n                    if lst[i] == \\'1\\' and 0 not in prev:\\n                        nrpc = nrpc + self.pMu(c,r)\\n                    else:\\n                        nrpc = nrpc + (self.noChoice(prev, int(lst[i])-1)) * self.pMu(c,r)\\n                elif lst[i] == \\'0\\' and i != l-1:\\n                    pass\\n                else:\\n                    nrpc = nrpc + self.noChoice(prev, int(lst[i]))\\n                \\n            if int(lst[i]) in prev:\\n                not_repeat = False\\n                \\n            prev.append(int(lst[i]))\\n        \\n        \\n        return N-nrpc\\n    \\n    def pMu(self, c: int, r: int) -> int:\\n        res = 1\\n        while r != 0:\\n            res = res * c\\n            c -=1\\n            r -=1\\n        return res\\n    \\n    def noChoice(self, prev: List[int], n: int) -> int:\\n        #print(prev)\\n        tmp = list(range(0,n+1))\\n        nChoice = n+1\\n        for no in tmp:\\n            if no in prev:\\n                nChoice -= 1\\n        return nChoice\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        if N <= 10:\\n            return 0\\n        \\n        lst = list(str(N))\\n        l = len(lst)\\n\\t\\t# Create memo for no. of non repeated digits for cases, 10, 100, 1000...\\n\\t\\t# Calculation: 9 x 9 x 8 x .....\\n        memo = { 1: 0, \\n                 2: 9, \\n                 3: 81, \\n                 4: 648, \\n                 5: 4536,\\n                 6: 27216, \\n                 7: 136080, \\n                 8: 544320,\\n                 9: 1632960,\\n                 10: 3265920}\\n        \\n        prev = []\\n        \\n        nrpc = 0\\n        for i in range(l):\\n            nrpc += memo[i+1]        \\n        \\n        nrpc += ((int(lst[0])-1) * int(memo[i+2]/9))\\n        prev.append(int(lst[0]))\\n        not_repeat = True\\n        \\n        for i in range(1, l):\\n            if not_repeat:\\n                if lst[i] != \\'0\\' and i != l-1:\\n                    c = 9-i\\n                    r = l-1-i\\n                    if lst[i] == \\'1\\' and 0 not in prev:\\n                        nrpc = nrpc + self.pMu(c,r)\\n                    else:\\n                        nrpc = nrpc + (self.noChoice(prev, int(lst[i])-1)) * self.pMu(c,r)\\n                elif lst[i] == \\'0\\' and i != l-1:\\n                    pass\\n                else:\\n                    nrpc = nrpc + self.noChoice(prev, int(lst[i]))\\n                \\n            if int(lst[i]) in prev:\\n                not_repeat = False\\n                \\n            prev.append(int(lst[i]))\\n        \\n        \\n        return N-nrpc\\n    \\n    def pMu(self, c: int, r: int) -> int:\\n        res = 1\\n        while r != 0:\\n            res = res * c\\n            c -=1\\n            r -=1\\n        return res\\n    \\n    def noChoice(self, prev: List[int], n: int) -> int:\\n        #print(prev)\\n        tmp = list(range(0,n+1))\\n        nChoice = n+1\\n        for no in tmp:\\n            if no in prev:\\n                nChoice -= 1\\n        return nChoice\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165501,
                "title": "javascript-time-limit-exceede",
                "content": "/**\\n * @param {number} N\\n * @return {number}\\n */\\nfunction detect_duplicate(N){\\n    let myFunc = num => Number(num);\\n    var intArr = Array.from(String(N), myFunc);\\n    for (var i = 0; i < intArr.length; i++) {\\n        for (var j = i; j < intArr.length; j++) {\\n            if( i !== j && intArr[i] === intArr[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n    result=0;\\n    for (var i = 10; i <= N; i++) {\\n        if(detect_duplicate(i)){\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n\\nHow can i improve this code?\\nI already used filter function. but got same result.",
                "solutionTags": [],
                "code": "/**\\n * @param {number} N\\n * @return {number}\\n */\\nfunction detect_duplicate(N){\\n    let myFunc = num => Number(num);\\n    var intArr = Array.from(String(N), myFunc);\\n    for (var i = 0; i < intArr.length; i++) {\\n        for (var j = i; j < intArr.length; j++) {\\n            if( i !== j && intArr[i] === intArr[j] ){\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvar numDupDigitsAtMostN = function(N) {\\n    result=0;\\n    for (var i = 10; i <= N; i++) {\\n        if(detect_duplicate(i)){\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n\\nHow can i improve this code?\\nI already used filter function. but got same result.",
                "codeTag": "Unknown"
            },
            {
                "id": 1163551,
                "title": "python-3-time-limit-exceeded",
                "content": "class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        repeated_number_checks = set() #To store and check if any number is repeating\\n        temp=0     #using for storing the number after division\\n        y=0        #to use copy of iterated number\\n        count = 0\\n        \\n        if(N < 100):\\n            for x in range(1,N+1):\\n                if(x % 11 == 0):\\n                    count = count+1\\n        else:\\n            for x in range(0,N+1):\\n                y=x\\n                repeated_number_checks.clear()\\n                while(y>0):\\n                    temp =y%10\\n                    if(temp in repeated_number_checks):\\n                        count=count+1\\n                        break\\n                    else:\\n                        repeated_number_checks.add(temp)\\n                        y=int(y/10)\\n        return(count)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        repeated_number_checks = set() #To store and check if any number is repeating\\n        temp=0     #using for storing the number after division\\n        y=0        #to use copy of iterated number\\n        count = 0\\n        \\n        if(N < 100):\\n            for x in range(1,N+1):\\n                if(x % 11 == 0):\\n                    count = count+1\\n        else:\\n            for x in range(0,N+1):\\n                y=x\\n                repeated_number_checks.clear()\\n                while(y>0):\\n                    temp =y%10\\n                    if(temp in repeated_number_checks):\\n                        count=count+1\\n                        break\\n                    else:\\n                        repeated_number_checks.add(temp)\\n                        y=int(y/10)\\n        return(count)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1156601,
                "title": "a-c-solution",
                "content": "We can solve this problem by count numbers with unique digits.\\nFor a given number `N+1={A_1 A_2 A_3 A_4 ... A_L}`, we can set:\\n`base={1, 9, 9*8, 9*8*7, ..., 9*8*7*6*5*4*3*2*1}`\\n`sum={9, 9+9*9, 9+9*9+9*9*8, ...}`\\nThe variable `no_rep` can be divided into these parts:\\n1. `(A_1 - 1)*base[L-1] + 9*base[L-2] + 9*base[L-3] + ... + 9*base[1] + 9*base[0]`, which is same as `(A_1 - 1)*base[L-1] + sum[L-2]`.\\n2. `(A_2 - |B2|)*base[L-1]/base[1]`, which `|B2|` means the number of digits unequal to `A_1` from `0` to `A_2 - 1`.\\n3. The rest can be done in the same manner. And the last part can be `(A_L - |B_L|)*1`.\\n\\nIn this process, if we meet a digit `A_j` which is equal to `A_i (i<j)`, we can stop next steps.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<10) return 0;\\n        vector<long> base={1},sum={9};\\n        for(int i=9;i>0;i--){\\n            base.push_back(base.back()*i);\\n            sum.push_back(sum.back()+9*base.back());\\n        }\\n        string s=to_string(N+1);\\n        int len=s.size();\\n        int vis[10]={0};\\n        long no_rep=(s[0]-\\'0\\'-1)*base[len-1]+sum[len-2];\\n        vis[s[0]-\\'0\\']=1;\\n        for(int i=1;i<len;i++){\\n            int cnt=0;\\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n                if(vis[j]==0) ++cnt;\\n            no_rep+=cnt*base[len-1]/base[i];\\n            if(vis[s[i]-\\'0\\']!=0) break;\\n            vis[s[i]-\\'0\\']=1;\\n        }\\n        return N-no_rep;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N<10) return 0;\\n        vector<long> base={1},sum={9};\\n        for(int i=9;i>0;i--){\\n            base.push_back(base.back()*i);\\n            sum.push_back(sum.back()+9*base.back());\\n        }\\n        string s=to_string(N+1);\\n        int len=s.size();\\n        int vis[10]={0};\\n        long no_rep=(s[0]-\\'0\\'-1)*base[len-1]+sum[len-2];\\n        vis[s[0]-\\'0\\']=1;\\n        for(int i=1;i<len;i++){\\n            int cnt=0;\\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n                if(vis[j]==0) ++cnt;\\n            no_rep+=cnt*base[len-1]/base[i];\\n            if(vis[s[i]-\\'0\\']!=0) break;\\n            vis[s[i]-\\'0\\']=1;\\n        }\\n        return N-no_rep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138631,
                "title": "unsure-what-i-m-doing-wrong-python",
                "content": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n\\n        \"123 --> [12] [23]\"\\n        \"1234 --> [12] [23] [34]\"\\n        \\n        repeatedDigits = 0\\n        \\n        for num in range(1, N + 1):\\n            strNum = str(num)\\n            numLen = len(strNum)\\n            \\n            strPairs = []\\n            \\n            for pairIndex in range(0, numLen - 1):\\n                strPairs.append(strNum[pairIndex:pairIndex + 2])\\n                \\n            print(strPairs)\\n                \\n            for pair in strPairs:\\n                print(pair)\\n                if pair[0] == pair[1]:\\n                    repeatedDigits += 1\\n\\t\\t\\t\\t\\tbreak\\n                \\n        return repeatedDigits\\n```\\n\\nLooking through other solutions it seems as though this problem is much more complicated than I thought it\\'d be. Maybe I misread the question but I seem to be missing numbers? This should check every integer up to N (inclusive) for matching twos but I can\\'t seem to figure it out.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numDupDigitsAtMostN(self, N):\\n\\n        \"123 --> [12] [23]\"\\n        \"1234 --> [12] [23] [34]\"\\n        \\n        repeatedDigits = 0\\n        \\n        for num in range(1, N + 1):\\n            strNum = str(num)\\n            numLen = len(strNum)\\n            \\n            strPairs = []\\n            \\n            for pairIndex in range(0, numLen - 1):\\n                strPairs.append(strNum[pairIndex:pairIndex + 2])\\n                \\n            print(strPairs)\\n                \\n            for pair in strPairs:\\n                print(pair)\\n                if pair[0] == pair[1]:\\n                    repeatedDigits += 1\\n\\t\\t\\t\\t\\tbreak\\n                \\n        return repeatedDigits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090260,
                "title": "c-o-logn-2-2-1-10-dummy-dp-solution-using-digit-dp-template-with-bitmask",
                "content": "Using basic digit DP template as the base of this solution. If you are not familiar with digit DP template, you can refer to LC357 https://leetcode.com/problems/count-numbers-with-unique-digits\\nor LC233 https://leetcode.com/problems/number-of-digit-one There are introduction to this technique that could solve this kind of \"digit count\" problem without using brain.\\n\\nThis solution uses limit, leadingZero label\\n\\nThe creative part of this solution is the bitMask to track the previous usage of numbers and a repeated label. The size of this bitMask is 1 << 10 since there are at most 10 numbers from 0 to 9. \\nso once we meet a number that has been in the bitMask, we toggle the repeated label to true. We only count the final state with repeated label = true.\\n\\nThen this problem becomes damn simple.\\n\\n```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string n = to_string(N);\\n        vector<vector<vector<vector<int>>>> memo(n.size(), vector<vector<vector<int>>>(2, vector<vector<int>>(2, vector<int>(1 << 10, -1))));\\n        return dp(n, 0, 1, 1, 0, 0, memo);\\n    }\\n\\n    int dp(string& n, int idx, int limit, int leadingZero, int prevMask, int repeated, vector<vector<vector<vector<int>>>>& memo) {\\n        if (idx == n.size()) {\\n            return repeated == 1 ? 1 : 0;\\n        }\\n        if (memo[idx][limit][repeated][prevMask] != -1) {\\n            return memo[idx][limit][repeated][prevMask];\\n        }\\n        int upper = (limit == 1 ? n[idx] - \\'0\\' : 9);\\n        int sum = 0;\\n        for (int i = 0; i <= upper; i++) {\\n            bool rp = false;\\n            for (int j = 0; j <= upper; j++) {\\n                if (((1 << j) | prevMask) == prevMask && i == j) {\\n                    rp = true;\\n                    break;\\n                }\\n            }\\n            int zero = leadingZero == 1 && i == 0 ? 1 : 0;\\n            int new_prev = prevMask;\\n            if (zero != 1) {\\n                new_prev |= 1 << i;\\n            }\\n            sum += dp(n, idx + 1, limit == 1 && i == upper ? 1 : 0,\\n\\n                zero\\n\\n                , new_prev, repeated == 1 || rp ? 1 : 0, memo);\\n        }\\n        return memo[idx][limit][repeated][prevMask] = sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string n = to_string(N);\\n        vector<vector<vector<vector<int>>>> memo(n.size(), vector<vector<vector<int>>>(2, vector<vector<int>>(2, vector<int>(1 << 10, -1))));\\n        return dp(n, 0, 1, 1, 0, 0, memo);\\n    }\\n\\n    int dp(string& n, int idx, int limit, int leadingZero, int prevMask, int repeated, vector<vector<vector<vector<int>>>>& memo) {\\n        if (idx == n.size()) {\\n            return repeated == 1 ? 1 : 0;\\n        }\\n        if (memo[idx][limit][repeated][prevMask] != -1) {\\n            return memo[idx][limit][repeated][prevMask];\\n        }\\n        int upper = (limit == 1 ? n[idx] - \\'0\\' : 9);\\n        int sum = 0;\\n        for (int i = 0; i <= upper; i++) {\\n            bool rp = false;\\n            for (int j = 0; j <= upper; j++) {\\n                if (((1 << j) | prevMask) == prevMask && i == j) {\\n                    rp = true;\\n                    break;\\n                }\\n            }\\n            int zero = leadingZero == 1 && i == 0 ? 1 : 0;\\n            int new_prev = prevMask;\\n            if (zero != 1) {\\n                new_prev |= 1 << i;\\n            }\\n            sum += dp(n, idx + 1, limit == 1 && i == upper ? 1 : 0,\\n\\n                zero\\n\\n                , new_prev, repeated == 1 || rp ? 1 : 0, memo);\\n        }\\n        return memo[idx][limit][repeated][prevMask] = sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073568,
                "title": "python-28ms-faster-than-85-81-probability-approach",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        if N<=10:\\n            return 0\\n    \\n        Nd = len(str(N))\\n\\n        # Put the digits in a dictionary\\n        D = {i:int(v) for i,v in enumerate(str(N)[::-1])}            \\n        \\n        # Number of digits smaller or equal than the first digit\\n        Nsm={0:0}\\n        for v in list(D.values())[1:]:\\n            if v<= D[0]:\\n                Nsm[0]+=1\\n                \\n        # Number of digits smaller than the n-th digit\\n        for n in range(1,Nd-1):\\n            Nsm[n]=0\\n            for v in list(D.values())[n+1:]:\\n                if v<D[n]:\\n                    Nsm[n]+=1\\n\\n                    \\n        # Find unique numbers up to Nd\\n        c = 9\\n        total_sm = c\\n        for i in range(2,Nd):\\n            c *= (10-i+1)\\n            total_sm += c\\n\\n            \\n        # Counter for each digit\\n        cnt = {}\\n\\n        # Treat highest digit separately\\n        hi_cnt = D[Nd-1]-1\\n        for i in range(1,Nd):\\n            hi_cnt *= (10-i)            \\n        cnt[Nd-1] = hi_cnt\\n        \\n        # Digits between highest and lowest digit\\n        fmid = {}\\n        for i in range(1,Nd-1):\\n            f=1\\n            for d in range(1,i+1):\\n                f*=(10-Nd+d)\\n                \\n            # Need to account for not allowed values in case of duplicate digits\\n            fmid[i]=1\\n            if i<Nd-2:\\n                for k in range(i+1,Nd-1):\\n                    for m in range(k+1,Nd):\\n                        if D[k]==D[m]:\\n                            fmid[i] = 0\\n                            break\\n\\n            cnt[i] = fmid[i]*f*(D[i]-Nsm[i])\\n                        \\n            \\n        # Treat Lowest digit separately as well\\n        uf=1\\n        for d in range(1,Nd-1):\\n            for k in range(d+1,Nd):\\n                if D[d]==D[k]:\\n                    uf=0\\n                    break\\n        cnt[0] = uf*(D[0]+1 - Nsm[0])\\n        \\n        \\n        total_count = total_sm # Unique digits for numbers with lower #digits\\n        for d in range(Nd):\\n            total_count += cnt[d]\\n                        \\n        return N-total_count\\n    \\n ######################################################           \\n            \\n            \\n            \\n            \\n# \"Manual\" recursive way up to five digits, shows the pattern that is programmed above\\n#         if(Nd==2):\\n#             count = 9 + (D[1]-1)*9 + D[0]+1 - Nsm[0]\\n#         if(Nd==3):           \\n#             U0 = D[0]+1-Nsm[0] if D[1]!=D[2] else 0\\n#             count1 = 90\\n#             count2 = (D[2]-1)*9*8 + 8*(D[1]-Nsm[1])\\n#             count = count1 + count2 + U0\\n#         if(Nd==4):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[2]!=D[3]) else 0\\n#             U1 = 7*(D[1]-Nsm[1]) if D[2]!=D[3] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = (D[3]-1)*9*8*7 + 8*7*(D[2]-Nsm[2]) + U1 + U0\\n#             count = count1 + count2 + count3\\n#         if(Nd==5):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[1]!=D[3]  and D[1]!=D[4] and D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U1 = 6*(D[1]-Nsm[1]) if (D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U2 = 7*6*(D[2]-Nsm[2]) if D[3]!=D[4] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = 8*9*8*7 + 8*7*9\\n#             count = count1 + count2 + count3 + (D[4]-1)*9*8*7*6 + 8*7*6*(D[3]-Nsm[3]) + U2  + U1 + U0\\n#         else:\\n#             count=0\\n\\n#         return N-count\\n    \\n\\n# Brain-dead way, too slow\\n#         count = 0        \\n#         for i in range(10,N+1):\\n#             digits = list(str(i))\\n#             if len(digits) != len(set(digits)):\\n#                 count=count+1\\n\\n#         return count\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        \\n        if N<=10:\\n            return 0\\n    \\n        Nd = len(str(N))\\n\\n        # Put the digits in a dictionary\\n        D = {i:int(v) for i,v in enumerate(str(N)[::-1])}            \\n        \\n        # Number of digits smaller or equal than the first digit\\n        Nsm={0:0}\\n        for v in list(D.values())[1:]:\\n            if v<= D[0]:\\n                Nsm[0]+=1\\n                \\n        # Number of digits smaller than the n-th digit\\n        for n in range(1,Nd-1):\\n            Nsm[n]=0\\n            for v in list(D.values())[n+1:]:\\n                if v<D[n]:\\n                    Nsm[n]+=1\\n\\n                    \\n        # Find unique numbers up to Nd\\n        c = 9\\n        total_sm = c\\n        for i in range(2,Nd):\\n            c *= (10-i+1)\\n            total_sm += c\\n\\n            \\n        # Counter for each digit\\n        cnt = {}\\n\\n        # Treat highest digit separately\\n        hi_cnt = D[Nd-1]-1\\n        for i in range(1,Nd):\\n            hi_cnt *= (10-i)            \\n        cnt[Nd-1] = hi_cnt\\n        \\n        # Digits between highest and lowest digit\\n        fmid = {}\\n        for i in range(1,Nd-1):\\n            f=1\\n            for d in range(1,i+1):\\n                f*=(10-Nd+d)\\n                \\n            # Need to account for not allowed values in case of duplicate digits\\n            fmid[i]=1\\n            if i<Nd-2:\\n                for k in range(i+1,Nd-1):\\n                    for m in range(k+1,Nd):\\n                        if D[k]==D[m]:\\n                            fmid[i] = 0\\n                            break\\n\\n            cnt[i] = fmid[i]*f*(D[i]-Nsm[i])\\n                        \\n            \\n        # Treat Lowest digit separately as well\\n        uf=1\\n        for d in range(1,Nd-1):\\n            for k in range(d+1,Nd):\\n                if D[d]==D[k]:\\n                    uf=0\\n                    break\\n        cnt[0] = uf*(D[0]+1 - Nsm[0])\\n        \\n        \\n        total_count = total_sm # Unique digits for numbers with lower #digits\\n        for d in range(Nd):\\n            total_count += cnt[d]\\n                        \\n        return N-total_count\\n    \\n ######################################################           \\n            \\n            \\n            \\n            \\n# \"Manual\" recursive way up to five digits, shows the pattern that is programmed above\\n#         if(Nd==2):\\n#             count = 9 + (D[1]-1)*9 + D[0]+1 - Nsm[0]\\n#         if(Nd==3):           \\n#             U0 = D[0]+1-Nsm[0] if D[1]!=D[2] else 0\\n#             count1 = 90\\n#             count2 = (D[2]-1)*9*8 + 8*(D[1]-Nsm[1])\\n#             count = count1 + count2 + U0\\n#         if(Nd==4):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[2]!=D[3]) else 0\\n#             U1 = 7*(D[1]-Nsm[1]) if D[2]!=D[3] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = (D[3]-1)*9*8*7 + 8*7*(D[2]-Nsm[2]) + U1 + U0\\n#             count = count1 + count2 + count3\\n#         if(Nd==5):\\n#             U0 = D[0]+1-Nsm[0] if (D[1]!=D[2] and D[1]!=D[3]  and D[1]!=D[4] and D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U1 = 6*(D[1]-Nsm[1]) if (D[2]!=D[3] and D[2]!=D[4] and D[3]!=D[4]) else 0\\n#             U2 = 7*6*(D[2]-Nsm[2]) if D[3]!=D[4] else 0\\n            \\n#             count1 = 90\\n#             count2 = 8*9*8+8*9\\n#             count3 = 8*9*8*7 + 8*7*9\\n#             count = count1 + count2 + count3 + (D[4]-1)*9*8*7*6 + 8*7*6*(D[3]-Nsm[3]) + U2  + U1 + U0\\n#         else:\\n#             count=0\\n\\n#         return N-count\\n    \\n\\n# Brain-dead way, too slow\\n#         count = 0        \\n#         for i in range(10,N+1):\\n#             digits = list(str(i))\\n#             if len(digits) != len(set(digits)):\\n#                 count=count+1\\n\\n#         return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980483,
                "title": "p23-5",
                "content": "Inclusio and exclusion\\nN- (all numbers from 1 to N which have no repating digits)\\nUse combinations\\nDebug exampl \\n335\\n1234\\n225\\nSay for above 335, when we have formed all numbers starting from less than 3(1,2,3)\\nthen we come to second 3, now again form all numbers(3x., x=0,1,2) now as soon as 33 is fixed, no new can be",
                "solutionTags": [],
                "code": "Inclusio and exclusion\\nN- (all numbers from 1 to N which have no repating digits)\\nUse combinations\\nDebug exampl \\n335\\n1234\\n225\\nSay for above 335, when we have formed all numbers starting from less than 3(1,2,3)\\nthen we come to second 3, now again form all numbers(3x., x=0,1,2) now as soon as 33 is fixed, no new can be",
                "codeTag": "Unknown"
            },
            {
                "id": 968620,
                "title": "count-numbers-with-unique-digits",
                "content": "Subtract from N possible numbers the count of numbers with unique digits.\\nThe code below will have explanation without loss of generailty to a number in\\nform of: ```abcd``` \\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int len = 1, tens = 1;\\n\\t\\t//len(abcd)=4,tens(abcd)=1000\\n        for(int i = N; i > 9; i/=10, ++len){\\n            tens *= 10;\\n        }\\n        int ans = N;\\n\\t\\t//count unique(p)+unique(pq)+unique(pqr)\\n        for(int i = len-1; i > 0; --i){\\n            int cnt = 9, j = 9;\\n            for(int k = i-1; k > 0; --k, --j){\\n                cnt *= j;\\n            }\\n            ans -= cnt;\\n        }\\n\\t\\t//count unique(pqrs) where pqrs <= abcd\\n        //for a given prefix with unique digits, count all possible suffixes\\n        var pfx = new HashSet<Integer>();\\n        for(int i = N, l = len; tens > 0;i %= tens, tens /= 10, --l){\\n            //cnt represents the cnt of possible digits extending the prefix\\n            int cnt = i/tens-(i==N?1:0);//choice because first digit has no zero, but subsequents could have\\n            //pfx digits below current digit cannot be reused\\n            for(var j : pfx) cnt = Math.max(0,cnt-(j < i/tens ? 1 : 0));\\n            //initial subsequent digit range\\n            int j = Math.max(0,9-pfx.size());\\n            for(int k = l-1; k > 0; --k, --j){//pick choices for suffix\\n                cnt *= Math.max(0,j);\\n            }\\n            ans -= cnt;\\n            if (pfx.contains(i/tens)) break;//true if prefix has duplicate digit, no more solutions with this prefix\\n            pfx.add(i/tens);//extend the prefix, it still has unique digits\\n        }\\n        ans -= pfx.size() == len ? 1 : 0;//check if N itself has unique digits\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```abcd```\n```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        int len = 1, tens = 1;\\n\\t\\t//len(abcd)=4,tens(abcd)=1000\\n        for(int i = N; i > 9; i/=10, ++len){\\n            tens *= 10;\\n        }\\n        int ans = N;\\n\\t\\t//count unique(p)+unique(pq)+unique(pqr)\\n        for(int i = len-1; i > 0; --i){\\n            int cnt = 9, j = 9;\\n            for(int k = i-1; k > 0; --k, --j){\\n                cnt *= j;\\n            }\\n            ans -= cnt;\\n        }\\n\\t\\t//count unique(pqrs) where pqrs <= abcd\\n        //for a given prefix with unique digits, count all possible suffixes\\n        var pfx = new HashSet<Integer>();\\n        for(int i = N, l = len; tens > 0;i %= tens, tens /= 10, --l){\\n            //cnt represents the cnt of possible digits extending the prefix\\n            int cnt = i/tens-(i==N?1:0);//choice because first digit has no zero, but subsequents could have\\n            //pfx digits below current digit cannot be reused\\n            for(var j : pfx) cnt = Math.max(0,cnt-(j < i/tens ? 1 : 0));\\n            //initial subsequent digit range\\n            int j = Math.max(0,9-pfx.size());\\n            for(int k = l-1; k > 0; --k, --j){//pick choices for suffix\\n                cnt *= Math.max(0,j);\\n            }\\n            ans -= cnt;\\n            if (pfx.contains(i/tens)) break;//true if prefix has duplicate digit, no more solutions with this prefix\\n            pfx.add(i/tens);//extend the prefix, it still has unique digits\\n        }\\n        ans -= pfx.size() == len ? 1 : 0;//check if N itself has unique digits\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951416,
                "title": "js-solution-using-combinatorics",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar numDupDigitsAtMostN = function(N) {\\n    \\n    let num = [];\\n    let n = N;\\n    while(N>0){\\n        num.unshift(N%10);\\n        N = Math.floor(N/10);\\n    }\\n    \\n    let digits = num.length;\\n    console.log(digits);\\n    let base = 0;\\n    let fac = 9;\\n    \\n    // Unique numbers of digits less than the number\\'s digits\\n    for(let d=9,i=1;i<digits;d--,i++){\\n        \\n        base+=fac;\\n        fac*=d;\\n        \\n    }\\n    \\n    \\n    // digits to the left of current digit (c) which are less than c\\n    let findOffSet = (arr,i)=>{\\n        \\n        let offSet = 0;\\n        arr.forEach((e)=>{\\n            \\n            offSet+=+(e<i);\\n        });\\n        \\n        return offSet;\\n    }\\n    \\n    let ans = base;\\n    base = 0;\\n    fac = 1;\\n    \\n    for(let i=num.length-1,d=10-digits+1;i>=0;i--,d++){\\n        \\n        let mySet = new Set(num.slice(0,i));\\n        \\n        // if the prefix has unique digits then proceed further otherwise skip iteration\\n        if(mySet.size == num.slice(0,i).length){\\n            \\n            let offSet = findOffSet(new Set(num.slice(0,i)), num[i]);\\n        \\n\\t\\t   if(i==0) // For leftMost Digit, remove digit \\'0\\' from the set of possible answers\\n               base = base+fac*(num[i]-1);\\n           else\\n            base = base+fac*(num[i]-offSet);     \\n        }\\n       \\n        \\n        \\n       fac*=d;\\n        \\n    }\\n    \\n    ans+=base;\\n    ans+=+((new Set(num)).size == num.length)   //whether the number N has unique digits\\n    return n-ans;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Combinatorics"
                ],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar numDupDigitsAtMostN = function(N) {\\n    \\n    let num = [];\\n    let n = N;\\n    while(N>0){\\n        num.unshift(N%10);\\n        N = Math.floor(N/10);\\n    }\\n    \\n    let digits = num.length;\\n    console.log(digits);\\n    let base = 0;\\n    let fac = 9;\\n    \\n    // Unique numbers of digits less than the number\\'s digits\\n    for(let d=9,i=1;i<digits;d--,i++){\\n        \\n        base+=fac;\\n        fac*=d;\\n        \\n    }\\n    \\n    \\n    // digits to the left of current digit (c) which are less than c\\n    let findOffSet = (arr,i)=>{\\n        \\n        let offSet = 0;\\n        arr.forEach((e)=>{\\n            \\n            offSet+=+(e<i);\\n        });\\n        \\n        return offSet;\\n    }\\n    \\n    let ans = base;\\n    base = 0;\\n    fac = 1;\\n    \\n    for(let i=num.length-1,d=10-digits+1;i>=0;i--,d++){\\n        \\n        let mySet = new Set(num.slice(0,i));\\n        \\n        // if the prefix has unique digits then proceed further otherwise skip iteration\\n        if(mySet.size == num.slice(0,i).length){\\n            \\n            let offSet = findOffSet(new Set(num.slice(0,i)), num[i]);\\n        \\n\\t\\t   if(i==0) // For leftMost Digit, remove digit \\'0\\' from the set of possible answers\\n               base = base+fac*(num[i]-1);\\n           else\\n            base = base+fac*(num[i]-offSet);     \\n        }\\n       \\n        \\n        \\n       fac*=d;\\n        \\n    }\\n    \\n    ans+=base;\\n    ans+=+((new Set(num)).size == num.length)   //whether the number N has unique digits\\n    return n-ans;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866309,
                "title": "no-repeated-digit-two-situation-explanation",
                "content": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // -> total numbers of no-repeated digits\\n        // N+1\\n        // eg. 8765 -> N+1 = 8766\\n        List<Integer> array = new ArrayList<>();\\n        for (int x=N+1; x>0; x/=10){\\n            array.add(x%10);\\n        }\\n        Collections.reverse(array);\\n        // 1. no-repeated numbers with less digits with N+1\\n        // XXX: 9*9*8\\n        // XX:  9*9\\n        // X:   9\\n        int res = 0;\\n        int n = array.size();\\n        for (int i=1; i<n; i++){ // i is the digits number\\n            res += 9*A(9,i-1);\\n        }\\n        // 2. no-repeated numbers(smaller than N+1) with same digits with N+1\\n        // (1~7)XXX: 9*8*7\\n        // 8(0~6)XX: 8*7\\n        // 87(0-5)X: 7\\n        // 876(0-5): 1\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i=0; i<n; i++){\\n            int j = i==0?1:0;\\n            for (; j<array.get(i); j++){\\n                if (!seen.contains(j)){\\n                    res += A(9-i, n-i-1);\\n                }\\n            }\\n            if (!seen.add(array.get(i))){\\n                break;\\n            }\\n        }\\n        return N-res;\\n    }\\n    \\n    private int A(int n, int m){\\n        // n*(n-1)*...*(n-m+1)\\n        if (m==0) return 1;\\n        return A(n, m-1)*(n-m+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int N) {\\n        // -> total numbers of no-repeated digits\\n        // N+1\\n        // eg. 8765 -> N+1 = 8766\\n        List<Integer> array = new ArrayList<>();\\n        for (int x=N+1; x>0; x/=10){\\n            array.add(x%10);\\n        }\\n        Collections.reverse(array);\\n        // 1. no-repeated numbers with less digits with N+1\\n        // XXX: 9*9*8\\n        // XX:  9*9\\n        // X:   9\\n        int res = 0;\\n        int n = array.size();\\n        for (int i=1; i<n; i++){ // i is the digits number\\n            res += 9*A(9,i-1);\\n        }\\n        // 2. no-repeated numbers(smaller than N+1) with same digits with N+1\\n        // (1~7)XXX: 9*8*7\\n        // 8(0~6)XX: 8*7\\n        // 87(0-5)X: 7\\n        // 876(0-5): 1\\n        Set<Integer> seen = new HashSet<>();\\n        for (int i=0; i<n; i++){\\n            int j = i==0?1:0;\\n            for (; j<array.get(i); j++){\\n                if (!seen.contains(j)){\\n                    res += A(9-i, n-i-1);\\n                }\\n            }\\n            if (!seen.add(array.get(i))){\\n                break;\\n            }\\n        }\\n        return N-res;\\n    }\\n    \\n    private int A(int n, int m){\\n        // n*(n-1)*...*(n-m+1)\\n        if (m==0) return 1;\\n        return A(n, m-1)*(n-m+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841556,
                "title": "python-a-messy-bitmask-solution",
                "content": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        a = list(map(int, list(str(N))))\\n        b = sorted(a)\\n        a_is_distinct = True\\n        for i in range(1, len(b)):\\n            if b[i] == b[i - 1]:\\n                a_is_distinct = False\\n        def num_less_distinct(i, taken): #taken is a bitmask\\n            #there are 3 ways to build a number that is less than num:\\n            #1. copy first number a[i], then call num_less(i + 1)\\n            #2. choose first number from {0, .., a[i] - 1}, then free to choose the rest (9 - i) * (8 - i)*...()\\n            #3. #digits less than i\\n            if i == len(a):\\n                return 1 if a_is_distinct else 0\\n            res = 0\\n            \\n            #1\\n            if taken & (1 << a[i]):\\n                x = 0\\n            else:\\n                x = num_less_distinct(i + 1, taken + (1 << a[i]))\\n            #2\\n            first = 0\\n            for j in range(1 if i == 0 else 0, a[i]):\\n                if not (taken & (1 << j)):\\n                    first += 1\\n            y = first\\n            for j in range(i + 1, len(a)):\\n                y *= (10 - j)\\n            return x + y\\n        z = 0\\n        for k in range(1, len(a)):\\n            #k digits\\n            first = 9\\n            for i in range(1, k):\\n                first *= (10 - i)\\n            z += first\\n        return N - num_less_distinct(0, 0) - z\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        a = list(map(int, list(str(N))))\\n        b = sorted(a)\\n        a_is_distinct = True\\n        for i in range(1, len(b)):\\n            if b[i] == b[i - 1]:\\n                a_is_distinct = False\\n        def num_less_distinct(i, taken): #taken is a bitmask\\n            #there are 3 ways to build a number that is less than num:\\n            #1. copy first number a[i], then call num_less(i + 1)\\n            #2. choose first number from {0, .., a[i] - 1}, then free to choose the rest (9 - i) * (8 - i)*...()\\n            #3. #digits less than i\\n            if i == len(a):\\n                return 1 if a_is_distinct else 0\\n            res = 0\\n            \\n            #1\\n            if taken & (1 << a[i]):\\n                x = 0\\n            else:\\n                x = num_less_distinct(i + 1, taken + (1 << a[i]))\\n            #2\\n            first = 0\\n            for j in range(1 if i == 0 else 0, a[i]):\\n                if not (taken & (1 << j)):\\n                    first += 1\\n            y = first\\n            for j in range(i + 1, len(a)):\\n                y *= (10 - j)\\n            return x + y\\n        z = 0\\n        for k in range(1, len(a)):\\n            #k digits\\n            first = 9\\n            for i in range(1, k):\\n                first *= (10 - i)\\n            z += first\\n        return N - num_less_distinct(0, 0) - z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825501,
                "title": "c-digit-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    vector<int> v;\\n    int dp[11][1025][2][2];\\n    \\n    int util(int i, int mask, int works, int less, int start){\\n        if(i>=n){\\n            if(works) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][mask][works][less]!=-1) return dp[i][mask][works][less];\\n        int lim=less?9:v[i], ans=0;\\n        if(start){\\n            for(int dig=0; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n        }\\n        else{\\n            for(int dig=1; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n            ans+=util(i+1, mask, works, 1, 0);\\n        }\\n        return dp[i][mask][works][less]=ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            v.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(v.begin(), v.end());\\n        n=v.size();\\n        memset(dp, -1, sizeof(dp));\\n        return util(0, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    vector<int> v;\\n    int dp[11][1025][2][2];\\n    \\n    int util(int i, int mask, int works, int less, int start){\\n        if(i>=n){\\n            if(works) return 1;\\n            else return 0;\\n        }\\n        if(dp[i][mask][works][less]!=-1) return dp[i][mask][works][less];\\n        int lim=less?9:v[i], ans=0;\\n        if(start){\\n            for(int dig=0; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n        }\\n        else{\\n            for(int dig=1; dig<=lim; dig++)\\n                ans+=util(i+1, mask|(1<<dig), works|((mask>>dig)&1), less|(dig<v[i]), 1);\\n            ans+=util(i+1, mask, works, 1, 0);\\n        }\\n        return dp[i][mask][works][less]=ans;\\n    }\\n    \\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            v.push_back(N%10);\\n            N/=10;\\n        }\\n        reverse(v.begin(), v.end());\\n        n=v.size();\\n        memset(dp, -1, sizeof(dp));\\n        return util(0, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739623,
                "title": "c-o-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N < 10) return 0;\\n        int k = 0;\\n        for(int i = N; i > 0; i /= 10) k++;\\n        vector<int> digit(k, 0); \\n        for(int i = 0, j = N; i < k; i++, j /= 10) digit[k - 1 - i] = j % 10;\\n        \\n        int noDupBaseSum = 0;\\n        vector<int> noDupBase(k - 1, 0); \\n        for(int i = 0; i < k - 1; i++)\\n        {\\n            noDupBase[i] = i == 0 ? 9 : noDupBase[i - 1] * (10 - i);\\n            noDupBaseSum += noDupBase[i];\\n        }\\n        \\n        int count[10] = {0};\\n        vector<int> noDupRes(k, 0); \\n        \\n        bool duplicate = false;\\n        for(int i = 0; i < k; i++)\\n        {\\n            noDupRes[i] = i == 0 ? 9 : noDupRes[i - 1] * (10 - i);\\n            if(!duplicate)\\n            {\\n                int diff = 0;\\n                for(int j = digit[i] + 1; j < 10; j++) diff += count[j] == 0;\\n                noDupRes[i] -= diff;\\n                count[digit[i]]++;\\n                if(count[digit[i]] > 1) duplicate = true;\\n            }\\n        }\\n        return N - (noDupBaseSum + noDupRes[k - 1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        if(N < 10) return 0;\\n        int k = 0;\\n        for(int i = N; i > 0; i /= 10) k++;\\n        vector<int> digit(k, 0); \\n        for(int i = 0, j = N; i < k; i++, j /= 10) digit[k - 1 - i] = j % 10;\\n        \\n        int noDupBaseSum = 0;\\n        vector<int> noDupBase(k - 1, 0); \\n        for(int i = 0; i < k - 1; i++)\\n        {\\n            noDupBase[i] = i == 0 ? 9 : noDupBase[i - 1] * (10 - i);\\n            noDupBaseSum += noDupBase[i];\\n        }\\n        \\n        int count[10] = {0};\\n        vector<int> noDupRes(k, 0); \\n        \\n        bool duplicate = false;\\n        for(int i = 0; i < k; i++)\\n        {\\n            noDupRes[i] = i == 0 ? 9 : noDupRes[i - 1] * (10 - i);\\n            if(!duplicate)\\n            {\\n                int diff = 0;\\n                for(int j = digit[i] + 1; j < 10; j++) diff += count[j] == 0;\\n                noDupRes[i] -= diff;\\n                count[digit[i]]++;\\n                if(count[digit[i]] > 1) duplicate = true;\\n            }\\n        }\\n        return N - (noDupBaseSum + noDupRes[k - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706450,
                "title": "c-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint count=0;\\n\\t\\tint permu(int M, int N)\\n\\t\\t{\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=0;i<N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres*=M;\\n\\t\\t\\t\\tM--; \\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tvoid dfs(vector<int>& num, vector<int>& digit, int cur)\\n\\t\\t{\\n\\t\\t\\tif(cur>=num.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(i==0 && cur==0) continue;\\n\\t\\t\\t\\tif(i<num[cur])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(digit[i]==1) continue;\\n\\t\\t\\t\\t\\tint av=0;\\n\\t\\t\\t\\t\\tfor(auto& x:digit)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(x==0)\\n\\t\\t\\t\\t\\t\\t\\tav++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcount+=permu(av-1,num.size()-cur-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(digit[i]==1) continue;\\n\\t\\t\\t\\t\\tif(i==num[cur])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdigit[i]=1;\\n\\t\\t\\t\\t\\t\\tdfs(num,digit,cur+1);\\n\\t\\t\\t\\t\\t\\tdigit[i]=0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint numDupDigitsAtMostN(int N) {\\n\\t\\t\\tif(N<=10) return 0;\\n\\t\\t\\tvector<int> num;\\n\\t\\t\\tint n=N;\\n\\t\\t\\twhile(n>0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnum.push_back(n%10);\\n\\t\\t\\t\\tn/=10;\\n\\t\\t\\t}\\n\\t\\t\\treverse(num.begin(),num.end());\\n\\n\\t\\t\\tint len=num.size();\\n\\t\\t\\tfor(int i=1;i<len-1;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount+=9*permu(9,i);\\n\\t\\t\\t}\\n\\t\\t\\tcount+=9;\\n\\t\\t\\tvector<int> digit(10);\\n\\t\\t\\tdfs(num,digit,0);\\n\\t\\t\\treturn N-count; \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint count=0;\\n\\t\\tint permu(int M, int N)\\n\\t\\t{\\n\\t\\t\\tint res=1;\\n\\t\\t\\tfor(int i=0;i<N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres*=M;\\n\\t\\t\\t\\tM--; \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 705053,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        # N -> total numbers less than or equal to N\\n        # We will calculate the integers with all different digits (which are less than/equal to N)\\n        # Then the answer would be: N - nums_with_different_digits\\n        \\n        # Calculate the number of digits in N\\n        NN, dd = N, 0\\n        nums = [] # store the digits\\n        while(NN):\\n            dd += 1\\n            nums.append(NN % 10)\\n            NN //= 10\\n        nums.reverse()\\n        \\n        \\n        # numbers with less digits than that of N\\n        numbers = 0\\n        for i in range(dd-1):\\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\\n        \\n        \\n        # find the N-digit numbers (all-different)\\n        already_visited_digits = set()\\n        \\n        def fac2(n, k):\\n            return math.factorial(n) // math.factorial(n-k)\\n        \\n        for i,n in enumerate(nums):\\n            k = 0\\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\\n                if(j in already_visited_digits):\\n                    continue\\n                k += 1\\n            numbers += k * fac2(10-i-1, dd-i-1)\\n            if n in already_visited_digits:\\n                # All the numbers with this prefix will have at least one common digit\\n                break\\n            already_visited_digits.add(n)\\n            \\n        return N - numbers\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        # N -> total numbers less than or equal to N\\n        # We will calculate the integers with all different digits (which are less than/equal to N)\\n        # Then the answer would be: N - nums_with_different_digits\\n        \\n        # Calculate the number of digits in N\\n        NN, dd = N, 0\\n        nums = [] # store the digits\\n        while(NN):\\n            dd += 1\\n            nums.append(NN % 10)\\n            NN //= 10\\n        nums.reverse()\\n        \\n        \\n        # numbers with less digits than that of N\\n        numbers = 0\\n        for i in range(dd-1):\\n            numbers += 9 * (math.factorial(9) // math.factorial(9-i))\\n        \\n        \\n        # find the N-digit numbers (all-different)\\n        already_visited_digits = set()\\n        \\n        def fac2(n, k):\\n            return math.factorial(n) // math.factorial(n-k)\\n        \\n        for i,n in enumerate(nums):\\n            k = 0\\n            for j in range((1 if i==0 else 0), (n+1 if i==dd-1 else n)):\\n                if(j in already_visited_digits):\\n                    continue\\n                k += 1\\n            numbers += k * fac2(10-i-1, dd-i-1)\\n            if n in already_visited_digits:\\n                # All the numbers with this prefix will have at least one common digit\\n                break\\n            already_visited_digits.add(n)\\n            \\n        return N - numbers\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 690339,
                "title": "digit-dp-solution-5d-dp-time-o-2-2-2-1024-10",
                "content": "# Time complexity - O(2 * 2 * 2 * 1024 * 10)\\n# DP- STATES:\\n* ***st*** - keep track of leading zeros so that we dont count them\\n* ***i*** - current position\\n* ***tight*** - upper limit of value to be put in the ith palce\\n* ***repeated*** - True if we found repeating element\\n* ***element*** - A mask stores value from 0-9. Set ith bit if it is found.\\n\\n```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        A = [i for i in str(N)]\\n        dp = [[[[[-1 for i in range(2)] for j in range(2)] for k in range(2)] for l in range((1<<10) + 1)] for m in range(10)]\\n        \\n        def digits(S,i,tight,repeated,element,st):\\n            if i == len(S):\\n                return repeated\\n            if dp[i][element][repeated][tight][st] != -1: return dp[i][element][repeated][tight][st]\\n            res = 0\\n            if tight == 1:\\n                till = ord(S[i]) - ord(\\'0\\')\\n                for j in range(till + 1):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    if j == till:\\n                        res += digits(S, i+1, 1,nrepeated,nelement,nst)\\n                    else:\\n                        res += digits(S, i+1, 0, nrepeated,nelement,nst)\\n            else:\\n                for j in range(10):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    res += digits(S, i+1, 0,nrepeated,nelement,nst)\\n            dp[i][element][repeated][tight][st] = res\\n            return dp[i][element][repeated][tight][st]\\n        ans = digits(A,0,1,False,0,0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numDupDigitsAtMostN(self, N: int) -> int:\\n        A = [i for i in str(N)]\\n        dp = [[[[[-1 for i in range(2)] for j in range(2)] for k in range(2)] for l in range((1<<10) + 1)] for m in range(10)]\\n        \\n        def digits(S,i,tight,repeated,element,st):\\n            if i == len(S):\\n                return repeated\\n            if dp[i][element][repeated][tight][st] != -1: return dp[i][element][repeated][tight][st]\\n            res = 0\\n            if tight == 1:\\n                till = ord(S[i]) - ord(\\'0\\')\\n                for j in range(till + 1):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    if j == till:\\n                        res += digits(S, i+1, 1,nrepeated,nelement,nst)\\n                    else:\\n                        res += digits(S, i+1, 0, nrepeated,nelement,nst)\\n            else:\\n                for j in range(10):\\n                    nst = j != 0 or st > 0\\n                    nrepeated = True if (((element & (1 << j)) > 0) and st > 0) else repeated\\n                    nelement = (element | (1 << j)) if nst else element\\n                    res += digits(S, i+1, 0,nrepeated,nelement,nst)\\n            dp[i][element][repeated][tight][st] = res\\n            return dp[i][element][repeated][tight][st]\\n        ans = digits(A,0,1,False,0,0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664081,
                "title": "c-o-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int s,int re){\\n        if(re==0) return 1;\\n        return (s-re+1)*fun(s,re-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        int ans=0,dig=0;\\n        for(int i=N+1;i>0;i/=10){\\n            dig++;\\n        }\\n        for(int i=1;i<dig;i++){\\n            ans+=9*fun(9,i-1);\\n        }\\n        //cout<<ans;\\n        vector<int> vec;\\n        int t=N+1;\\n        while(t){\\n            vec.push_back(t%10);\\n            t/=10;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        set<int> st;\\n        for(int i=0;i<vec.size();i++){\\n            //cout<<vec[i]<<\" \";\\n            for(int j=((i>0) ? 0 : 1) ;j<vec[i];j++){\\n                if(st.find(j)==st.end()){\\n                    //cout<<vec[i]<<\" \"<<j<<endl;\\n                ans+=fun(9-i,vec.size()-1-i);}\\n            }\\n            if(st.find(vec[i])!=st.end()){\\n                break;\\n            }\\n            st.insert(vec[i]);\\n        }\\n        return N-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int s,int re){\\n        if(re==0) return 1;\\n        return (s-re+1)*fun(s,re-1);\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        int ans=0,dig=0;\\n        for(int i=N+1;i>0;i/=10){\\n            dig++;\\n        }\\n        for(int i=1;i<dig;i++){\\n            ans+=9*fun(9,i-1);\\n        }\\n        //cout<<ans;\\n        vector<int> vec;\\n        int t=N+1;\\n        while(t){\\n            vec.push_back(t%10);\\n            t/=10;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        set<int> st;\\n        for(int i=0;i<vec.size();i++){\\n            //cout<<vec[i]<<\" \";\\n            for(int j=((i>0) ? 0 : 1) ;j<vec[i];j++){\\n                if(st.find(j)==st.end()){\\n                    //cout<<vec[i]<<\" \"<<j<<endl;\\n                ans+=fun(9-i,vec.size()-1-i);}\\n            }\\n            if(st.find(vec[i])!=st.end()){\\n                break;\\n            }\\n            st.insert(vec[i]);\\n        }\\n        return N-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 648838,
                "title": "c-recursive-100-speed-and-memory-beat",
                "content": "Caculate all permutations less or equal to number N, then substract it from N is the right answer.\\ncurSum returns the permutations number with begin available option with start, digits number with len, whether all formers are zero with allZero.\\n\\n```\\nclass Solution {\\nprivate:\\n    int curSum(int start, int len, bool allZero) {\\n        if (len == 1) {\\n            if (allZero) {\\n                return 9;\\n            } else {\\n                return start;\\n            }\\n        }\\n        if (allZero) {\\n            return curSum(10, len-1, true) + 9 * curSum(9, len-1, false);\\n        } else {\\n            return start * curSum(start - 1, len-1, false);\\n        }\\n    }\\n    \\n    int helper(unordered_set<int> used, string s) {\\n       if (s.size() == 1) {\\n            int temp = 0;\\n            for (int i = 0; i < 10; i++) {\\n                if (used.find(i) == used.end()) {\\n                    if (i < s[0] - \\'0\\')\\n                        temp++;\\n                }\\n            }\\n            return temp;\\n        }\\n\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            if (used.find(i) == used.end()) {\\n                curNums += curSum(9 - used.size(), len - 1, false);\\n            }\\n        }\\n\\n        string nextStr = s.substr(1);\\n        if (nextStr.size() == 0 || (used.find(top) != used.end())) {\\n            return curNums;\\n        }\\n        used.insert(top);\\n        curNums += helper(used, nextStr);\\n        return curNums;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string s = to_string(N);\\n        int cnt[10] = {0};\\n        bool repeat = false;\\n        for (auto c: s) {\\n            if (cnt[c - \\'0\\']) {\\n                repeat = true;\\n                break;\\n            }\\n            cnt[c - \\'0\\']++;\\n        }\\n        unordered_set<int> used;\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        if (len == 1) {\\n            return 0;\\n        }\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            curNums += curSum(9, len - 1, i == 0);\\n        }\\n        used.insert(top);\\n        curNums += helper(used, s.substr(1));\\n        return N - curNums - (repeat == false? 1 : 0);\\n    }\\n};\\n\\n\\n/*\\n\\n100:\\n    \\n    [0,1], {}\\n    0: 10*9\\n    1: xx, \\n\\n123:\\n    [0,1], {}\\n    0: 10 * 9\\n    1: xx {1}\\n        [0, 2]\\n        10: 8\\n        12: 2\\n\\n2234:\\n    [0, 1, 2], {}\\n    0: 10 * 9 * 8 {0}\\n    1: 9 * 8 * 7  {1}\\n    2: xxx {2}\\n        [0, 1]    {2}\\n        20: 8*7   {2,0}\\n        21: 8*7   {2,1}\\n        22: 0     {2}\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int curSum(int start, int len, bool allZero) {\\n        if (len == 1) {\\n            if (allZero) {\\n                return 9;\\n            } else {\\n                return start;\\n            }\\n        }\\n        if (allZero) {\\n            return curSum(10, len-1, true) + 9 * curSum(9, len-1, false);\\n        } else {\\n            return start * curSum(start - 1, len-1, false);\\n        }\\n    }\\n    \\n    int helper(unordered_set<int> used, string s) {\\n       if (s.size() == 1) {\\n            int temp = 0;\\n            for (int i = 0; i < 10; i++) {\\n                if (used.find(i) == used.end()) {\\n                    if (i < s[0] - \\'0\\')\\n                        temp++;\\n                }\\n            }\\n            return temp;\\n        }\\n\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            if (used.find(i) == used.end()) {\\n                curNums += curSum(9 - used.size(), len - 1, false);\\n            }\\n        }\\n\\n        string nextStr = s.substr(1);\\n        if (nextStr.size() == 0 || (used.find(top) != used.end())) {\\n            return curNums;\\n        }\\n        used.insert(top);\\n        curNums += helper(used, nextStr);\\n        return curNums;\\n    }\\n    \\npublic:\\n    int numDupDigitsAtMostN(int N) {\\n        string s = to_string(N);\\n        int cnt[10] = {0};\\n        bool repeat = false;\\n        for (auto c: s) {\\n            if (cnt[c - \\'0\\']) {\\n                repeat = true;\\n                break;\\n            }\\n            cnt[c - \\'0\\']++;\\n        }\\n        unordered_set<int> used;\\n        int len = s.size(), top = s[0] - \\'0\\';\\n        if (len == 1) {\\n            return 0;\\n        }\\n        int curNums = 0;\\n        for (int i = 0; i < top; i++) {\\n            curNums += curSum(9, len - 1, i == 0);\\n        }\\n        used.insert(top);\\n        curNums += helper(used, s.substr(1));\\n        return N - curNums - (repeat == false? 1 : 0);\\n    }\\n};\\n\\n\\n/*\\n\\n100:\\n    \\n    [0,1], {}\\n    0: 10*9\\n    1: xx, \\n\\n123:\\n    [0,1], {}\\n    0: 10 * 9\\n    1: xx {1}\\n        [0, 2]\\n        10: 8\\n        12: 2\\n\\n2234:\\n    [0, 1, 2], {}\\n    0: 10 * 9 * 8 {0}\\n    1: 9 * 8 * 7  {1}\\n    2: xxx {2}\\n        [0, 1]    {2}\\n        20: 8*7   {2,0}\\n        21: 8*7   {2,1}\\n        22: 0     {2}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645759,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10][1<<10][2][2];\\n    string no;\\n    int n;\\n    int kil(int idx, int digits, int isRepeated, int isSmall){\\n        if(idx == n){\\n            if(isRepeated)\\n                return 1;\\n            return 0;\\n        }\\n\\n        if(dp[idx][digits][isRepeated][isSmall] != -1)\\n            return dp[idx][digits][isRepeated][isSmall];\\n\\n        dp[idx][digits][isRepeated][isSmall] = 0;\\n\\n        if(isSmall){\\n            for(int i=0;i<=9;i++){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, isSmall);\\n            }\\n        }else{\\n            int upper = no[idx]-\\'0\\';\\n            for(int i=upper;i>=0;i--){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, (i == upper) ? 0 : 1);\\n            }\\n        }\\n        return dp[idx][digits][isRepeated][isSmall];\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            no += N%10 + \\'0\\';\\n            N /= 10;\\n        }\\n        reverse(no.begin(), no.end());\\n        int ans  = 0;\\n        for(int len=2;len<=no.size();len++){\\n            memset(dp, -1, sizeof dp);\\n            n = len;\\n            if(len == no.size()){\\n                for(int i=no[0]-\\'0\\';i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, (i == no[0]-\\'0\\') ? 0 : 1);\\n                }\\n            }else{\\n                for(int i=9;i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[10][1<<10][2][2];\\n    string no;\\n    int n;\\n    int kil(int idx, int digits, int isRepeated, int isSmall){\\n        if(idx == n){\\n            if(isRepeated)\\n                return 1;\\n            return 0;\\n        }\\n\\n        if(dp[idx][digits][isRepeated][isSmall] != -1)\\n            return dp[idx][digits][isRepeated][isSmall];\\n\\n        dp[idx][digits][isRepeated][isSmall] = 0;\\n\\n        if(isSmall){\\n            for(int i=0;i<=9;i++){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, isSmall);\\n            }\\n        }else{\\n            int upper = no[idx]-\\'0\\';\\n            for(int i=upper;i>=0;i--){\\n                int ndigits = (digits | (1<<i));\\n                int repeat = ((digits & (1<<i)) || isRepeated);\\n                dp[idx][digits][isRepeated][isSmall] += kil(idx+1, ndigits, repeat, (i == upper) ? 0 : 1);\\n            }\\n        }\\n        return dp[idx][digits][isRepeated][isSmall];\\n    }\\n    int numDupDigitsAtMostN(int N) {\\n        while(N){\\n            no += N%10 + \\'0\\';\\n            N /= 10;\\n        }\\n        reverse(no.begin(), no.end());\\n        int ans  = 0;\\n        for(int len=2;len<=no.size();len++){\\n            memset(dp, -1, sizeof dp);\\n            n = len;\\n            if(len == no.size()){\\n                for(int i=no[0]-\\'0\\';i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, (i == no[0]-\\'0\\') ? 0 : 1);\\n                }\\n            }else{\\n                for(int i=9;i>0;i--){\\n                    int ndigits = (1<<i);\\n                    ans += kil(1, ndigits, 0, 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619284,
                "title": "scala-dfs-with-memorization-o-2048lgn-with-digit-state",
                "content": "```\\nobject Solution {\\n  def numDupDigitsAtMostN(N: Int): Int = {\\n    val str: String = N.toString\\n    val len: Int = str.length\\n    var ans: Int = 0\\n    val memo = Array.fill(len, 1 << 10, 2)(-1)\\n    for {\\n      i <- 1 to (str(0) - \\'0\\')\\n    } {\\n      if(i < str(0) - \\'0\\') {\\n        ans += helper(1, len, 0, str, (1 << i), memo)\\n      }\\n      else if(i == str(0) - \\'0\\') {\\n        ans += helper(1, len, 1, str, (1 << i), memo)\\n      }\\n    }\\n    var nei: Int = 0\\n    for {\\n      k <- len - 1 to 1 by -1 if k > 0\\n    } {\\n      nei += A(9, k) + (k - 1) * A(9, k - 1)\\n    }\\n    N - ans - nei\\n  }\\n\\n  def A(n: Int, m: Int): Int = {\\n    if(m > n) return 0\\n    var ans: Int = 1\\n    var i: Int = n\\n    while(i >= (n - m + 1)) {\\n      ans *= i\\n      i -= 1\\n    }\\n    return ans\\n  }\\n\\n  def helper(ind: Int, len: Int, rb: Int, str: String, state: Int, memo: Array[Array[Array[Int]]]): Int = {\\n    if(ind >= len) return 1\\n    if(memo(ind)(state)(rb) > 0) return memo(ind)(state)(rb)\\n    val upper: Int = (if(rb == 1){str(ind) - \\'0\\'}else {9})\\n    var ret: Int = 0\\n    for {\\n      i <- 0 to upper\\n    } {\\n      if((state & (1 << i)) == 0) {\\n        ret += helper(ind + 1, len, (if(rb == 1 && i == upper) {1} else {0}), str, (state | (1 << i)), memo)\\n      }\\n    }\\n    memo(ind)(state)(rb) = ret\\n    return ret\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def numDupDigitsAtMostN(N: Int): Int = {\\n    val str: String = N.toString\\n    val len: Int = str.length\\n    var ans: Int = 0\\n    val memo = Array.fill(len, 1 << 10, 2)(-1)\\n    for {\\n      i <- 1 to (str(0) - \\'0\\')\\n    } {\\n      if(i < str(0) - \\'0\\') {\\n        ans += helper(1, len, 0, str, (1 << i), memo)\\n      }\\n      else if(i == str(0) - \\'0\\') {\\n        ans += helper(1, len, 1, str, (1 << i), memo)\\n      }\\n    }\\n    var nei: Int = 0\\n    for {\\n      k <- len - 1 to 1 by -1 if k > 0\\n    } {\\n      nei += A(9, k) + (k - 1) * A(9, k - 1)\\n    }\\n    N - ans - nei\\n  }\\n\\n  def A(n: Int, m: Int): Int = {\\n    if(m > n) return 0\\n    var ans: Int = 1\\n    var i: Int = n\\n    while(i >= (n - m + 1)) {\\n      ans *= i\\n      i -= 1\\n    }\\n    return ans\\n  }\\n\\n  def helper(ind: Int, len: Int, rb: Int, str: String, state: Int, memo: Array[Array[Array[Int]]]): Int = {\\n    if(ind >= len) return 1\\n    if(memo(ind)(state)(rb) > 0) return memo(ind)(state)(rb)\\n    val upper: Int = (if(rb == 1){str(ind) - \\'0\\'}else {9})\\n    var ret: Int = 0\\n    for {\\n      i <- 0 to upper\\n    } {\\n      if((state & (1 << i)) == 0) {\\n        ret += helper(ind + 1, len, (if(rb == 1 && i == upper) {1} else {0}), str, (state | (1 << i)), memo)\\n      }\\n    }\\n    memo(ind)(state)(rb) = ret\\n    return ret\\n  }\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566855,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1569459,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1573235,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1569457,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            },
            {
                "id": 1572531,
                "content": [
                    {
                        "username": "mengpq",
                        "content": "https://youtu.be/_Zxsa37aVeo\\n\\n1012: O(log(N))\\n1013: constants time\\n1014: O(N * log(sum)) where sum is the total weight.\\n1015: O(L) where L is the number of digit of N."
                    },
                    {
                        "username": "igbgotiz",
                        "content": "Can someone clarify what this question means by \"repeated digits\"?\\n\\nFor example, the number 101 has the digit \"1\" repeated twice, so it has repeated digits.\\n\\nBut in the question examples, all examples of qualifying numbers have consecutive repeated digits, so I was wondering if anyone could clarify."
                    },
                    {
                        "username": "abednego",
                        "content": "Does the number 101 have repeated digits? All of the examples have the digits repeating consecutively."
                    },
                    {
                        "username": "tonghuikang",
                        "content": "https://stackoverflow.com/a/13249899 offers a solution, a simple modification is sufficient to provide the answer to the last question.\\n\\nWhat are the rules regarding copying code? Where can you copy code from? How does leetcode detect plagiarism?"
                    },
                    {
                        "username": "sohelH",
                        "content": "My first submission got time limit exceeded for the input 896089023. When I tested my code with this input in the editor, it was producing the output in 220 ms."
                    }
                ]
            }
        ]
    },
    {
        "title": "Allocate Mailboxes",
        "question_content": "<p>Given the array <code>houses</code> where <code>houses[i]</code> is the location of the <code>i<sup>th</sup></code> house along a street and an integer <code>k</code>, allocate <code>k</code> mailboxes in the street.</p>\n\n<p>Return <em>the <strong>minimum</strong> total distance between each house and its nearest mailbox</em>.</p>\n\n<p>The test cases are generated so that the answer fits in a 32-bit integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/07/sample_11_1816.png\" style=\"width: 454px; height: 154px;\" />\n<pre>\n<strong>Input:</strong> houses = [1,4,8,10,20], k = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Allocate mailboxes in position 3, 9 and 20.\nMinimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/05/07/sample_2_1816.png\" style=\"width: 433px; height: 154px;\" />\n<pre>\n<strong>Input:</strong> houses = [2,3,5,12,18], k = 2\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Allocate mailboxes in position 3 and 14.\nMinimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= houses.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= houses[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All the integers of <code>houses</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 685620,
                "title": "java-c-python-top-down-dp-prove-median-mailbox-o-n-3",
                "content": "**Idea**\\n- The idea is we try to allocate each mailbox to `k` group of the consecutive houses `houses[i:j]`. We found a solution if we can distribute total `k` mailboxes to `n` houses devided into `k` groups `[0..i], [i+1..j], ..., [l..n-1]`. \\n- After all, we choose the **minimum cost** among our solutions.\\n\\n\\n![image](https://assets.leetcode.com/users/hiepit/image_1592073922.png)\\n*(Attached image from Leetcode for easy to understand the idea)*\\n\\n- Let `costs[i][j]` is the total travel distance from houses `houses[i:j]` to a mailbox when putting the mailbox among `houses[i:j]`, the best way is put the mail box at **median position** among `houses[i:j]`\\n![image](https://assets.leetcode.com/users/hiepit/image_1592098756.png)\\n\\n<iframe src=\"https://leetcode.com/playground/7Lcbmjmb/shared\" frameBorder=\"0\" width=\"100%\" height=\"540\"></iframe>\\n\\n**Complexity**\\n- Time: `O(n^3)`\\n\\t+ `costs` takes `O(n^3)`\\n\\t+ `dp` takes `O(k*n*n)`, because `dp(k, i)` has total `k*n` states, each state need a for loop up to `n` elements.\\n- Space: `O(n^2)`\\n\\n\\n",
                "solutionTags": [],
                "code": "**Idea**\\n- The idea is we try to allocate each mailbox to `k` group of the consecutive houses `houses[i:j]`. We found a solution if we can distribute total `k` mailboxes to `n` houses devided into `k` groups `[0..i], [i+1..j], ..., [l..n-1]`. \\n- After all, we choose the **minimum cost** among our solutions.\\n\\n\\n![image](https://assets.leetcode.com/users/hiepit/image_1592073922.png)\\n*(Attached image from Leetcode for easy to understand the idea)*\\n\\n- Let `costs[i][j]` is the total travel distance from houses `houses[i:j]` to a mailbox when putting the mailbox among `houses[i:j]`, the best way is put the mail box at **median position** among `houses[i:j]`\\n![image](https://assets.leetcode.com/users/hiepit/image_1592098756.png)\\n\\n<iframe src=\"https://leetcode.com/playground/7Lcbmjmb/shared\" frameBorder=\"0\" width=\"100%\" height=\"540\"></iframe>\\n\\n**Complexity**\\n- Time: `O(n^3)`\\n\\t+ `costs` takes `O(n^3)`\\n\\t+ `dp` takes `O(k*n*n)`, because `dp(k, i)` has total `k*n` states, each state need a for loop up to `n` elements.\\n- Space: `O(n^2)`\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 685516,
                "title": "python3-detailed-explanation-and-commented-code",
                "content": "Hi everyone, first time completing hard in competition (didnt get question 3 tho D:) & also first blog post so I will try my best to explain what I did.\\n\\nAfter weeks of doing DP, this question jumped out to me as a possible DP problem. The giveaway, at least for me, was that K can be increasing from 1-len(houses), so it is likely that there are some subproblems repeated.\\n\\nWhen approaching DP/Recursion, it is not intutive for me, so I like to think of the base cases first.\\n\\nWhen **K == 1**, theres only 1 mailbox. So, we put it in the median of the what we are currently checking. For example [4,8,20], we put the mailbox at 8, and then we calculate the difference accordingly.\\n\\nWhen **K == len(houses)**, this is also trivial, you can put a mailbox at every house, so distance will be 0.\\n\\nSo with base cases considered, we now go to higher numbers of K. What if K == 2? Then we can portion one part of the house into one group, put a mailbox there, and the remaining houses will be another group putting another mailbox. E.g\\n\\n[1, 300, 301, 302] can be thought as:\\n[1], [300, 301, 302] OR\\n[1, 300], [301, 302] OR\\n[1, 300, 301], [302]\\n\\nSo this is when K == 2. Right now we can visually see that the first answer is the best.\\n\\nConsider further, if K == 3. Then decide where we want to put the first group, and then solve the subproblems recursively. Same example as above.\\n\\n[1] (first group) [300,301,302] will be split into **another** 2 groups. So it will recursively call \\n[300] [301, 302] \\n[300, 301] [302]\\n\\nOR \\n[1, 300] - > first group, [301, 302] - > split this into **another**  2 groups. Then\\n[301], [302]\\n\\nRecently I learnt that DP can be thought as a *careful brute force* (thanks MIT openware :)) and I think it really shows here. We do not know where to cut the mailboxes into group, so what do we do? We try everything, partioning at every possible place, but saving the answer prevents us from doing something multiple times.\\n\\n**In general, we pick a place to form one group, then, the remaining elements must form K - 1 groups, and we try to minimise the answer.**\\n\\nIf you read this far, thanks for sticking around for my first post and I hope I\\'m able to make the solution clearer for you (consider giving an **upvote** if you thought it was good & want to boost its visibility for others :))\\n\\nSome other trivial things include if there are more mailbox than houses, our grouping is not good alr, because you can put the extra mailbox earlier. Theres no point putting 3 mailboxes for 2 houses. \\n\\nAnother thing to note is recently I also found out that using a table is much faster than using dictionary, it may be easier to use dictionary for python but I was afraid of TLE so I used a 3D table instead.\\n\\nI\\'ll try to answer anything in the comments below. Cheers everyone :)\\n\\n\\n```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        \\n    //  sort the houses, cause we dont want to have a situation where houses [301, 240, 360] \\n    houses.sort()\\n    \\n    //  Memo table, using a dictionary is easier but slower\\n    memo = [[[-1 for i in range(len(houses) + 3)] for j in range(len(houses) + 3)] for _ in range(k + 3)]\\n    \\n    //  left = left index of sorted houses, right = Including right index, num = num of mailbox that we can place for this group\\n    def helper(left, right, num):\\n        \\n        //  previously computed, lets not waste time to compute it again\\n        if memo[num][left][right] != -1:\\n            return memo[num][left][right]\\n        \\n        //  too many mailbox, too little houses, we have done something wrong in grouping earlier grouping. So return a \\'FAIL\\' answer\\n        if right - left  + 1 < num:\\n            return float(\\'inf\\')\\n\\n        //  Base case, one mailbox, put mailbox in median of houses. \\n        if num == 1:\\n            ans = 0\\n            mid = (left + right) // 2\\n            for i in range(left, right + 1):\\n                ans += abs(houses[i] - houses[mid])\\n            memo[num][left][right] = ans\\n            return ans\\n\\n        //  Have a mailbox for every house, great!\\n        if num == right - left + 1:\\n            return 0\\n        \\n        \\n        ans = float(\\'inf\\')\\n        \\n        //  \"Careful Brute Force\"\\n        for i in range(left, right):\\n            ans = min(ans, helper(left, i, 1) + helper(i + 1, right, num - 1))\\n        \\n        //  Store ans\\n        memo[num][left][right] = ans\\n        return ans\\n    \\n\\n    return helper(0, len(houses) - 1, k)\\n```\\n\\nEdit: Reason for K = 1 being Median (Credits @kimchimadeinhouston in comments section)\\n\\nSuppose there are N houses along a straight line and you are at position A. There are X houses to the left of you and N - X houses to the right of you.\\n\\nConsider taking one more step to the right. You are 1 step closer to N - X houses. So you gain N - X. At the same time, you are 1 step further from X houses. So you lose X.\\n\\nYou keep walking to the right as long as N - X > X because the gain will be more than the loss. When do you stop? It is at the median point, at which you have an equal number of houses to the left or to the right of you. This is the basic intuition.\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        \\n    //  sort the houses, cause we dont want to have a situation where houses [301, 240, 360] \\n    houses.sort()\\n    \\n    //  Memo table, using a dictionary is easier but slower\\n    memo = [[[-1 for i in range(len(houses) + 3)] for j in range(len(houses) + 3)] for _ in range(k + 3)]\\n    \\n    //  left = left index of sorted houses, right = Including right index, num = num of mailbox that we can place for this group\\n    def helper(left, right, num):\\n        \\n        //  previously computed, lets not waste time to compute it again\\n        if memo[num][left][right] != -1:\\n            return memo[num][left][right]\\n        \\n        //  too many mailbox, too little houses, we have done something wrong in grouping earlier grouping. So return a \\'FAIL\\' answer\\n        if right - left  + 1 < num:\\n            return float(\\'inf\\')\\n\\n        //  Base case, one mailbox, put mailbox in median of houses. \\n        if num == 1:\\n            ans = 0\\n            mid = (left + right) // 2\\n            for i in range(left, right + 1):\\n                ans += abs(houses[i] - houses[mid])\\n            memo[num][left][right] = ans\\n            return ans\\n\\n        //  Have a mailbox for every house, great!\\n        if num == right - left + 1:\\n            return 0\\n        \\n        \\n        ans = float(\\'inf\\')\\n        \\n        //  \"Careful Brute Force\"\\n        for i in range(left, right):\\n            ans = min(ans, helper(left, i, 1) + helper(i + 1, right, num - 1))\\n        \\n        //  Store ans\\n        memo[num][left][right] = ans\\n        return ans\\n    \\n\\n    return helper(0, len(houses) - 1, k)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685403,
                "title": "java-c-python-dp-solution",
                "content": "# Explantion\\n`dp[i]` will means that,\\nthe minimum distance of i + 1 first house.\\n\\n`B[i] = A[0] + A[1] + A[2] + .. + A[i-1]`\\n`cal(i, j)` will return the minimum distance,\\nbetween `A[i]~A[j]` with only one mailbox.\\n\\nInitialy, when `k = 1`, `dp[i] = cal(0, i)`\\nwhen we increment `k`, we can update `dp` with one more mailbox added.\\n\\nHere we brute force the number of houses that new mailbox in charge.\\nThe brute force here are good enough to get accepted.\\n<br>\\n\\n# Explantion for the cost\\nWhat and why is `last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);`\\n\\nAll from @caohuicn:\\n\\nFirst of all,\\nlast is to calculate distances for houses [i + 1, j] with 1 mailbox,\\nsince the dp recurrence relation is:\\n`dp[j][k] = min(dp[i][k-1] + cal[i + 1, j])`\\n(second dimension is implicit in the code);\\n\\nFor houses `[i + 1, j]`,\\nif the number of houses is odd,\\nthe only mailbox should always be placed in the middle house.\\nIf number of house is even, it can be placed anywhere\\nbetween the middle 2 houses.\\n\\nLet\\'s say we always put it at m1;\\nNow let\\'s see the meaning of m1 and m2. For even houses,\\nm1 + 1 == m2, for odd houses, m1 == m2.\\nThe point of introducing 2 variables is to \\nmake sure number of houses between [i+1, m1] and [m2,j] are always equal.\\n`(B[j + 1] - B[m2])` means `A[m2] + A[m2+1] + ... + A[j]`,\\n`(B[m1 + 1] - B[i + 1]`) means `A[i+1] + A[i+2] + ... + A[m1]`,\\nso last becomes `A[j] - A[i+1] + A[j-1] - A[i+2] +... + A[m2] - A[m1]`.\\n\\nWe can interpret it as:\\nif the mailbox is placed between any 2 houses x and y,\\nthe sum of distances for both houses will be A[y] - A[x].\\nSay we have 2n houses, then there will be n pairs;\\nif we have 2n + 1 houses, then there will n + 1 pairs.\\nAnother way to interpret it is: \\nif the mailbox is placed at m1, \\nfor all the right side houses, \\nthe sum of distances will be \\n`A[m2]-A[m1] + A[m2+1]-A[m1] + ... + A[j]-A[m1]`, \\nand for the left side (including m1), \\nit\\'ll be `A[m1]-A[i+1]+A[m1]-A[i+2]+...+A[m1]-A[m1-1] + A[m1]-A[m1]`. \\n\\nAdding these 2 things together, \\nA[m1]s will be cancelled out, \\nsince number of houses between [i+1, m1] and [m2,j] are always equal.\\n\\nHope it helps.\\n\\n\\n\\n# Complexity\\nTime `O(KNN)`\\nSpace `O(N)`\\n\\nNote that solution `O(KN)` is also possible to come up with.\\n<br>\\n\\n**Java**\\n```java\\n    public int minDistance(int[] A, int K) {\\n        Arrays.sort(A);\\n        int n = A.length, B[] = new int[n+1], dp[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            B[i + 1] = B[i] + A[i];\\n            dp[i] = (int)1e6;\\n        }\\n        for (int k = 1; k <= K; ++k) {\\n            for (int j = n - 1; j > k - 2; --j) {\\n                for (int i = k - 2; i < j; ++i) {\\n                    int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n                    int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n                    dp[j] = Math.min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```\\n**C++**\\n```cpp\\n    int minDistance(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int n = A.size();\\n        vector<int> B(n + 1, 0), dp(n, 1e6);\\n        for (int i = 0; i < n; ++i)\\n            B[i + 1] = B[i] + A[i];\\n        for (int k = 1; k <= K; ++k)\\n            for (int j = n - 1; j > k - 2; --j)\\n                for (int i = k - 2; i < j; ++i) {\\n                    int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n                    int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n                    dp[j] = min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n                }\\n        return dp[n - 1];\\n    }\\n```\\n**Python:**\\n```py\\n    def minDistance(self, A, k):\\n        A.sort()\\n        n = len(A)\\n        B = [0]\\n        for i, a in enumerate(A):\\n            B.append(B[i] + a)\\n\\n        def cal(i, j):\\n            m1, m2 = (i + j) / 2, (i + j + 1) / 2\\n            return (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i])\\n\\n        dp = [cal(0, j) for j in xrange(n)]\\n        for k in xrange(2, k + 1):\\n            for j in xrange(n - 1, k - 2, -1):\\n                for i in xrange(k - 2, j):\\n                    dp[j] = min(dp[j], dp[i] + cal(i + 1, j))\\n        return int(dp[-1])\\n```\\n<br>\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minDistance(int[] A, int K) {\\n        Arrays.sort(A);\\n        int n = A.length, B[] = new int[n+1], dp[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            B[i + 1] = B[i] + A[i];\\n            dp[i] = (int)1e6;\\n        }\\n        for (int k = 1; k <= K; ++k) {\\n            for (int j = n - 1; j > k - 2; --j) {\\n                for (int i = k - 2; i < j; ++i) {\\n                    int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n                    int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n                    dp[j] = Math.min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n                }\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n```\n```cpp\\n    int minDistance(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int n = A.size();\\n        vector<int> B(n + 1, 0), dp(n, 1e6);\\n        for (int i = 0; i < n; ++i)\\n            B[i + 1] = B[i] + A[i];\\n        for (int k = 1; k <= K; ++k)\\n            for (int j = n - 1; j > k - 2; --j)\\n                for (int i = k - 2; i < j; ++i) {\\n                    int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n                    int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n                    dp[j] = min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n                }\\n        return dp[n - 1];\\n    }\\n```\n```py\\n    def minDistance(self, A, k):\\n        A.sort()\\n        n = len(A)\\n        B = [0]\\n        for i, a in enumerate(A):\\n            B.append(B[i] + a)\\n\\n        def cal(i, j):\\n            m1, m2 = (i + j) / 2, (i + j + 1) / 2\\n            return (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i])\\n\\n        dp = [cal(0, j) for j in xrange(n)]\\n        for k in xrange(2, k + 1):\\n            for j in xrange(n - 1, k - 2, -1):\\n                for i in xrange(k - 2, j):\\n                    dp[j] = min(dp[j], dp[i] + cal(i + 1, j))\\n        return int(dp[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685321,
                "title": "java-heavily-commented-proof-on-why-median-work",
                "content": "Core idea: Best way to place 1 mailbox for a set of houses is to place at the house that sits in the middle.\\n\\nWhy?\\n\\n>Let\\'s assume there are r houses to right and l houses to the left of the place where we place mailbox. Now, If you don\\'t place the mailbox in the middle house but to the left of the middle(i.e. r > l). Moving one place to right will reduce distances by r and increase distance by l which will be an improvement since r > l. Hence, it\\'s best we keep moving towards middle house.\\n\\nFor example: [6, 8, 9, 11, 15] and you have 1 mailbox. \\n\\nNow if you place mailbox at 6: Cost = (8-6) + (9-6) + (11-6) + (15-6)                                 ====> 19\\nNow if you place mailbox at 7: Cost = (7-6) + (8-7) + (9-7) + (11-7) + (15-7)                    ====> 16\\nNow if you place mailbox at 8: Cost = (8-6)  + (9-8) + (11-8) + (15-8)                                ====> 13\\nNow if you place mailbox at 9: Cost = (9-6)  + (9-8) + (11-9) + (15-9)                                ====> 12   <---------- Middle house has lowest\\nNow if you place mailbox at 10: Cost = (10-6)  + (10-8) + (10-9) + (11-10) + (15-10)    ====> 13\\nNow if you place mailbox at 11: Cost = (11-6)  + (11-8) + (11-9) + (15-11)                      ====> 14\\nNow if you place mailbox at 15: Cost = (15-6)  + (15-8) + (15-9) + (15-11)                      ====> 26\\n\\n9 has the lowest cost.\\n\\nNow, we can recursively solve this:\\n\\nAt step 1: Try to place 1st mailbox in (1, 2, 3, 4 .. n) houses. After placing at the ith point, move to step 2\\nAt step 2: Try to place 2nd mailbox in (i+1, i+2, ... n) houses.\\n\\nAt step k: Try to place kth mailbox remaining houses.\\n\\nPossible common mistake: We will need to sort the houses since they are not given sorted in input.\\n\\n\\n```\\nclass Solution {\\n    int MAX = 10000000;\\n\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[n][k];\\n        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], -1);\\n        return solve(houses, k, 0, 0, dp);\\n    }\\n\\n    public int solve(int[] houses, int k, int pos, int curK, int[][] dp) {\\n        if (pos == houses.length) {\\n            if (curK == k) {\\n                return 0;\\n            }\\n            return MAX;\\n        }\\n        if (curK == k) return MAX;\\n        if (dp[pos][curK] != -1) return dp[pos][curK];\\n\\n        int answer = MAX;\\n        for (int i = pos; i < houses.length; ++i) {\\n            // Best way to place a mailbox between [i, pos] houses is to place at the median house\\n            int median = houses[(i + pos) / 2];\\n\\n            // Step 1: Calculate cost when we place at median house\\n            int cost = 0;\\n            for (int j = pos; j <= i; ++j) {\\n                cost += Math.abs(median - houses[j]);\\n            }\\n\\n            // Step 2: Recursively, calculate cost of placing rest of the mailboxes at i+1 pos\\n            answer = Math.min(answer, solve(houses, k, i + 1, curK + 1, dp) + cost);\\n        }\\n\\n        dp[pos][curK] = answer;\\n        return answer;\\n    }\\n}\\n```\\n\\n\\nComplexity: There are n * k DP states with each performing n * n operations. ```O(k * n^3)``` \\n\\nNote, we can pre-compute cost for all range of houses beforehand and therefore, reducing the complexity:\\n\\n```\\nclass Solution {\\n    int MAX = 10000000;\\n\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[n][k];\\n        int[][] cost = new int[n][n];\\n\\t\\t\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int median = houses[(i + j) / 2];\\n                int sum = 0;\\n                for (int l = i; l <= j; ++l) {\\n                    sum += Math.abs(median - houses[l]);\\n                }\\n                cost[i][j] = sum;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], -1);\\n        return solve(houses, k, 0, 0, dp, cost);\\n    }\\n\\n    public int solve(int[] houses, int k, int pos, int curK, int[][] dp, int[][] cost) {\\n        if (pos == houses.length) {\\n            if (curK == k) {\\n                return 0;\\n            }\\n            return MAX;\\n        }\\n        if (curK == k) return MAX;\\n        if (dp[pos][curK] != -1) return dp[pos][curK];\\n\\n        int answer = MAX;\\n        for (int i = pos; i < houses.length; ++i) {\\n            answer = Math.min(answer, solve(houses, k, i + 1, curK + 1, dp, cost) + cost[pos][i]);\\n        }\\n\\n        dp[pos][curK] = answer;\\n        return answer;\\n    }\\n}\\n```\\n\\nComplexity: There are n * k DP states with each performing n operations. ```O(n^3 + k * n^2)```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int MAX = 10000000;\\n\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[n][k];\\n        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], -1);\\n        return solve(houses, k, 0, 0, dp);\\n    }\\n\\n    public int solve(int[] houses, int k, int pos, int curK, int[][] dp) {\\n        if (pos == houses.length) {\\n            if (curK == k) {\\n                return 0;\\n            }\\n            return MAX;\\n        }\\n        if (curK == k) return MAX;\\n        if (dp[pos][curK] != -1) return dp[pos][curK];\\n\\n        int answer = MAX;\\n        for (int i = pos; i < houses.length; ++i) {\\n            // Best way to place a mailbox between [i, pos] houses is to place at the median house\\n            int median = houses[(i + pos) / 2];\\n\\n            // Step 1: Calculate cost when we place at median house\\n            int cost = 0;\\n            for (int j = pos; j <= i; ++j) {\\n                cost += Math.abs(median - houses[j]);\\n            }\\n\\n            // Step 2: Recursively, calculate cost of placing rest of the mailboxes at i+1 pos\\n            answer = Math.min(answer, solve(houses, k, i + 1, curK + 1, dp) + cost);\\n        }\\n\\n        dp[pos][curK] = answer;\\n        return answer;\\n    }\\n}\\n```\n```O(k * n^3)```\n```\\nclass Solution {\\n    int MAX = 10000000;\\n\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[n][k];\\n        int[][] cost = new int[n][n];\\n\\t\\t\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int median = houses[(i + j) / 2];\\n                int sum = 0;\\n                for (int l = i; l <= j; ++l) {\\n                    sum += Math.abs(median - houses[l]);\\n                }\\n                cost[i][j] = sum;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i) Arrays.fill(dp[i], -1);\\n        return solve(houses, k, 0, 0, dp, cost);\\n    }\\n\\n    public int solve(int[] houses, int k, int pos, int curK, int[][] dp, int[][] cost) {\\n        if (pos == houses.length) {\\n            if (curK == k) {\\n                return 0;\\n            }\\n            return MAX;\\n        }\\n        if (curK == k) return MAX;\\n        if (dp[pos][curK] != -1) return dp[pos][curK];\\n\\n        int answer = MAX;\\n        for (int i = pos; i < houses.length; ++i) {\\n            answer = Math.min(answer, solve(houses, k, i + 1, curK + 1, dp, cost) + cost[pos][i]);\\n        }\\n\\n        dp[pos][curK] = answer;\\n        return answer;\\n    }\\n}\\n```\n```O(n^3 + k * n^2)```",
                "codeTag": "Java"
            },
            {
                "id": 685772,
                "title": "python-classical-down-up-solution-explained-o-n-3",
                "content": "Let `dp[i][k]` be a minimum total distance when we use `i` houses and only `k` mailboxes.\\nThe idea is when we add new mailbox, undersand, how many houses it can cover.\\nHow we can evaluate `dp[i][k]`? We need to look for all smaller `j` at the element `dp[j][k-1]` and also we need to know what distance we need to add for houses between `j` and `i` with only one mailbox.\\n\\nGood idea is to precalculate all possible `costs[i][j]`: total distances to cover all houses between number `i` and number `j`. I used idea of **@hiepit**, who did it in `O(n^3)` elegant way: we need to put mailbox into the median of our points. Note, that this part can be improved to `O(n^2)`, but it is not worth it, because we have bigger terms.\\n\\nNow, all we need to do is to iterate over all `n` houses and over all `k` mailboxes and update all table `dp`, let us do it on example `houses = [1,4,8,10,20]`. Here by # I denoted elements which are in fact should be zeros: number of houses is less or equal than number of mailboxes. However it is not neccesary to see what is inside, because we never use these elements. We also define the first row of our `dp` table with `costs[0][:]`, because it is exactly total minimum distance for `1` mailbox.\\n\\n|       | 1 | 4 | 8 | 10 | 20 |\\n|-------|---|---|---|----|----|\\n| **k = 1** | # | 3 | 7 | 13 | 15 |\\n| **k = 2** | # | # | 3 | 5  | 13 |\\n| **k = 3** | # | # | # | 2  | 5  |\\n\\n**Complexity**: time complexity is `O(n^3 + n^2k) = O(n^3)`, space complexity is `O(nk)`.\\n\\n\\n```\\nclass Solution:\\n    def minDistance(self, houses, k):\\n        n = len(houses)\\n        houses = sorted(houses)\\n        costs = [[0] * n for _ in range(n)]\\n        \\n        for i, j in product(range(n), range(n)):\\n            median = houses[(i + j) // 2]\\n            for t in range(i, j + 1):\\n                costs[i][j] += abs(median - houses[t])\\n     \\n        dp = [[10**6] * k for _ in range(n)]\\n        for i in range(n): dp[i][0] = costs[0][i]\\n        \\n        for k_it in range(1, k):\\n            for i_1 in range(n):\\n                for i_2 in range(i_1):\\n                    dp[i_1][k_it] = min(dp[i_1][k_it], dp[i_2][k_it-1] + costs[i_2+1][i_1])\\n      \\n        return dp[-1][-1] \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses, k):\\n        n = len(houses)\\n        houses = sorted(houses)\\n        costs = [[0] * n for _ in range(n)]\\n        \\n        for i, j in product(range(n), range(n)):\\n            median = houses[(i + j) // 2]\\n            for t in range(i, j + 1):\\n                costs[i][j] += abs(median - houses[t])\\n     \\n        dp = [[10**6] * k for _ in range(n)]\\n        for i in range(n): dp[i][0] = costs[0][i]\\n        \\n        for k_it in range(1, k):\\n            for i_1 in range(n):\\n                for i_2 in range(i_1):\\n                    dp[i_1][k_it] = min(dp[i_1][k_it], dp[i_2][k_it-1] + costs[i_2+1][i_1])\\n      \\n        return dp[-1][-1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 685661,
                "title": "c-neighborhoods-12-ms",
                "content": "A neighborhood is one or more nearby houses that share a mailbox. We can sort our houses and organize them into neighborhoods. A neighborhood can be defined by its first `j` and last `i` house, and the best location of the mailbox can be easily determined:\\n- For odd number of houses, it\\'s right on the house in the middle.\\n- For even number of houses, it\\'s between two houses in the middle.\\n\\n> Why is that? For the smallest total distance, we should have the same amount of houses on the left and right sides of the mailbox.\\n\\nWe can find the best neighborhood layout using a depth-first search. In the function below, `i` is the position of the current house, `j` is the position of the first house in the current neighborhood, and `k` is the number of remaining neighborhoods (or mailboxes). For each house we can:\\n- Close the neighborhood, so `i` is the last house. House `i + 1` will start a new neighborhood.\\n- Continue the neighborhood.\\n\\nTo speed up things, we memoise the solutions by `i`, `j`, and `k`.\\n\\n> Update: see the optimized solutions below, that have 20 and 12 ms runtime.\\n\\n```cpp\\nint dp[101][101][101] = {};\\nint dfs(vector<int>& h, int i, int j, int k) {\\n    if (i >= h.size() || k <= 0)\\n        return i == h.size() && k == 0 ? 0 : INT_MAX;\\n    if (dp[i][j][k])\\n        return dp[i][j][k];\\n    dp[i][j][k] = dfs(h, i + 1, i + 1, k - 1); // New neighborhood\\n    if (dp[i][j][k] != INT_MAX)\\n        for (auto p = j; p <= i; ++p)\\n            dp[i][j][k] += abs(h[(i + j) / 2] - h[p]);        \\n    return dp[i][j][k] = min(dp[i][j][k], dfs(h, i + 1, j, k)); // Continue neighborhood\\n}\\nint minDistance(vector<int>& houses, int k) {      \\n    sort(begin(houses), end(houses));\\n    return dfs(houses, 0, 0, k);\\n}\\n```\\n\\nNow, we can optimize our solution by precomputing costs for each possible neighborhood [i, j]. Then, instead of continuing/starting a neighborhood, we can analyze all neighborhoods that starts from i. This reduces the memory complexity to O(n * k).\\n\\n```cpp\\nint dp[101][101] = {};\\nint dfs(vector<int>& h, vector<vector<int>> &costs, int i, int k) {\\n    if (i >= h.size() || k <= 0)\\n        return i == h.size() && k == 0 ? 0 : 10000000;\\n    if (!dp[i][k]) {\\n        dp[i][k] = 10000000;\\n        for (auto j = i; j <= h.size() - k; ++j)\\n            dp[i][k] = min(dp[i][k], costs[i][j] + dfs(h, costs, j + 1, k - 1));\\n    }\\n    return dp[i][k];\\n}\\nint minDistance(vector<int>& h, int k) {      \\n    sort(begin(h), end(h));\\n    vector<vector<int>> costs(h.size(), vector<int>(h.size()));\\n    for (auto i = 0; i < h.size(); ++i) {\\n        for (auto j = i; j < h.size(); ++j) {\\n            int mailbox = h[(i + j) / 2];\\n            for (auto p = i; p <= j; ++p)\\n                costs[i][j] += abs(mailbox - h[p]);\\n        }\\n    }\\n    return dfs(h, costs, 0, k);\\n}\\n```\\n\\nOne more optimization; we can calculate cost for a neighborhood `[i, j]` in O(1) by adjusting cost for `[i, j - 1]`. This brings the runtime down from 20 to 12 ms.\\n\\n> How that adjustment works? When we add a new house `j`, the mailbox position moves from `mbold` to `mbnew`, and the cost increases by `house[j] - mbnew`. At the same time, the distance from houses on the left increases by `mbnew - mbold` for each house, and decreases by the same value for houses on the right. When the number of houses is even, we have one more house on the left than on the right. So, we need to add `mbnew - mbold` to the cost when the number of houses is even.\\n\\n```cpp\\nint dp[101][101] = {};\\nint dfs(vector<int>& h, vector<vector<int>> &costs, int i, int k) {\\n    if (i >= h.size() || k <= 0)\\n        return i == h.size() && k == 0 ? 0 : 10000000;\\n    if (!dp[i][k]) {\\n        dp[i][k] = 10000000;\\n        for (auto j = i; j <= h.size() - k; ++j)\\n            dp[i][k] = min(dp[i][k], costs[i][j] + dfs(h, costs, j + 1, k - 1));\\n    }\\n    return dp[i][k];\\n}\\nint minDistance(vector<int>& h, int k) {      \\n    sort(begin(h), end(h));\\n    vector<vector<int>> costs(h.size(), vector<int>(h.size()));\\n    for (auto i = 0; i < h.size(); ++i) {\\n        for (auto j = i; j < h.size(); ++j) {\\n            int mbold = h[(i + j - 1) / 2], mbnew = h[(i + j) / 2];\\n            costs[i][j] = (j == 0 ? 0 : costs[i][j - 1]) + \\n                h[j] - mbnew + (mbnew - mbold) * (j - i) % 2;\\n        }\\n    }\\n    return dfs(h, costs, 0, k);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nint dp[101][101][101] = {};\\nint dfs(vector<int>& h, int i, int j, int k) {\\n    if (i >= h.size() || k <= 0)\\n        return i == h.size() && k == 0 ? 0 : INT_MAX;\\n    if (dp[i][j][k])\\n        return dp[i][j][k];\\n    dp[i][j][k] = dfs(h, i + 1, i + 1, k - 1); // New neighborhood\\n    if (dp[i][j][k] != INT_MAX)\\n        for (auto p = j; p <= i; ++p)\\n            dp[i][j][k] += abs(h[(i + j) / 2] - h[p]);        \\n    return dp[i][j][k] = min(dp[i][j][k], dfs(h, i + 1, j, k)); // Continue neighborhood\\n}\\nint minDistance(vector<int>& houses, int k) {      \\n    sort(begin(houses), end(houses));\\n    return dfs(houses, 0, 0, k);\\n}\\n```\n```cpp\\nint dp[101][101] = {};\\nint dfs(vector<int>& h, vector<vector<int>> &costs, int i, int k) {\\n    if (i >= h.size() || k <= 0)\\n        return i == h.size() && k == 0 ? 0 : 10000000;\\n    if (!dp[i][k]) {\\n        dp[i][k] = 10000000;\\n        for (auto j = i; j <= h.size() - k; ++j)\\n            dp[i][k] = min(dp[i][k], costs[i][j] + dfs(h, costs, j + 1, k - 1));\\n    }\\n    return dp[i][k];\\n}\\nint minDistance(vector<int>& h, int k) {      \\n    sort(begin(h), end(h));\\n    vector<vector<int>> costs(h.size(), vector<int>(h.size()));\\n    for (auto i = 0; i < h.size(); ++i) {\\n        for (auto j = i; j < h.size(); ++j) {\\n            int mailbox = h[(i + j) / 2];\\n            for (auto p = i; p <= j; ++p)\\n                costs[i][j] += abs(mailbox - h[p]);\\n        }\\n    }\\n    return dfs(h, costs, 0, k);\\n}\\n```\n```cpp\\nint dp[101][101] = {};\\nint dfs(vector<int>& h, vector<vector<int>> &costs, int i, int k) {\\n    if (i >= h.size() || k <= 0)\\n        return i == h.size() && k == 0 ? 0 : 10000000;\\n    if (!dp[i][k]) {\\n        dp[i][k] = 10000000;\\n        for (auto j = i; j <= h.size() - k; ++j)\\n            dp[i][k] = min(dp[i][k], costs[i][j] + dfs(h, costs, j + 1, k - 1));\\n    }\\n    return dp[i][k];\\n}\\nint minDistance(vector<int>& h, int k) {      \\n    sort(begin(h), end(h));\\n    vector<vector<int>> costs(h.size(), vector<int>(h.size()));\\n    for (auto i = 0; i < h.size(); ++i) {\\n        for (auto j = i; j < h.size(); ++j) {\\n            int mbold = h[(i + j - 1) / 2], mbnew = h[(i + j) / 2];\\n            costs[i][j] = (j == 0 ? 0 : costs[i][j - 1]) + \\n                h[j] - mbnew + (mbnew - mbold) * (j - i) % 2;\\n        }\\n    }\\n    return dfs(h, costs, 0, k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691057,
                "title": "python-well-commented-solution-and-why-the-median-house",
                "content": "The examples were quite misleading. The key insight to the problem is not that this is a dynamic programming problem, it\\'s that the best place to put mailboxes is always at some house\\'s location itself! The examples suggest that it should be placed in between houses. But that is not the case. If the best location is between two houses at X and at Y, then a location just as good, is at X. Because while we\\'ve increased the distance of Y from the mailbox, we\\'ve reduced that of X to zero. The sum  distance remains the same. Once we realize that, then it\\'s just a problem of cutting the houses into k groups and assigning a mailbox to each group where the mailbox sits at the house with the median index of that group.\\n\\n```\\nclass Solution(object):\\n    def minDistance(self, houses, k):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        n = len(houses)\\n        \\n        # Given the group of houses in the range [i, j], the optimal mailbox location\\n        # is *at* the house with the *median index*. The examples provided by the problem was\\n        # extremely misleading which suggested one should place mailboxes in between houses.\\n        # But that\\'s not necessary, for given any optimal mailbox location between two houses,\\n        # we would get the same total distance over all houses to that mailbox by moving the\\n        # mailbox to the house at the *median index*. (Yes the distance to the house we\\'ve moved\\n        # away from will get longer but the distance to the house we\\'ve moved closer to will get\\n        # shorter, the total distance remain unchanged)\\n        def dist_to_optimal_mbox(i, j):\\n            median_loc = houses[(i + j) // 2]\\n            dist = 0\\n            for h_idx in range(i, j + 1):\\n                dist += abs(houses[h_idx] - median_loc)\\n            return dist\\n\\n        memo = {}\\n        def f(i, k):\\n            if i == n:\\n                # Note here we don\\'t actually check for the value of k, Why? Because\\n                # we don\\'t actually care if the recursion reaches the end of the houses\\n                # array but we still have extra mailboxes unassigned, i.e. k > 0 (k cannot\\n                # be less than 0 because we stop at k == 1 in the base case below). We know\\n                # that the more mailboxes we use, the smaller the total distance. So there\\'s\\n                # no way for us to arrive at a smaller total distance by NOT using all k \\n                # mailboxes. The branches of the recursion tree where i == n and k > 0 will\\n                # definitely have larger total distance and be eventually ignored.\\n                return 0\\n            \\n            if (i, k) in memo:\\n                return memo[(i, k)]\\n            \\n            # Assuming k >= 1, if we only have one mailbox left to assign, only thing we can\\n            # do is placing it at the median index of the range [i, n - 1] and return the distance\\n            if k == 1:\\n                memo[(i, k)] = dist_to_optimal_mbox(i, n - 1)\\n                return memo[(i, k)]\\n                \\n            # Starting from i, we could create a group of houses that includes those in\\n            # the inclusive range [i, j] and assign one mailbox to them. Think of the mailbox\\n            # assigned as those houses\\' home-base mailbox. We are looking to place k home-base\\n            # mailboxes, one per group of houses. Since we do not know where we\\'d lop off the\\n            # group, i.e. where we\\'d end the group starting at i, we\\'ll try all possible ending\\n            # position for this group\\n            min_dist = float(\\'inf\\')\\n            for j in xrange(i, n):\\n                # If this group starts at i and ends at j, inclusive, then recurse and place\\n                # k - 1 remaining mailboxes to k - 1 remaining groups\\n                dist = dist_to_optimal_mbox(i, j) + f(j + 1, k - 1)\\n                min_dist = min(min_dist, dist)\\n            \\n            memo[(i, k)] = min_dist\\n            return min_dist\\n        \\n        return f(0, k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, houses, k):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        houses.sort()\\n        n = len(houses)\\n        \\n        # Given the group of houses in the range [i, j], the optimal mailbox location\\n        # is *at* the house with the *median index*. The examples provided by the problem was\\n        # extremely misleading which suggested one should place mailboxes in between houses.\\n        # But that\\'s not necessary, for given any optimal mailbox location between two houses,\\n        # we would get the same total distance over all houses to that mailbox by moving the\\n        # mailbox to the house at the *median index*. (Yes the distance to the house we\\'ve moved\\n        # away from will get longer but the distance to the house we\\'ve moved closer to will get\\n        # shorter, the total distance remain unchanged)\\n        def dist_to_optimal_mbox(i, j):\\n            median_loc = houses[(i + j) // 2]\\n            dist = 0\\n            for h_idx in range(i, j + 1):\\n                dist += abs(houses[h_idx] - median_loc)\\n            return dist\\n\\n        memo = {}\\n        def f(i, k):\\n            if i == n:\\n                # Note here we don\\'t actually check for the value of k, Why? Because\\n                # we don\\'t actually care if the recursion reaches the end of the houses\\n                # array but we still have extra mailboxes unassigned, i.e. k > 0 (k cannot\\n                # be less than 0 because we stop at k == 1 in the base case below). We know\\n                # that the more mailboxes we use, the smaller the total distance. So there\\'s\\n                # no way for us to arrive at a smaller total distance by NOT using all k \\n                # mailboxes. The branches of the recursion tree where i == n and k > 0 will\\n                # definitely have larger total distance and be eventually ignored.\\n                return 0\\n            \\n            if (i, k) in memo:\\n                return memo[(i, k)]\\n            \\n            # Assuming k >= 1, if we only have one mailbox left to assign, only thing we can\\n            # do is placing it at the median index of the range [i, n - 1] and return the distance\\n            if k == 1:\\n                memo[(i, k)] = dist_to_optimal_mbox(i, n - 1)\\n                return memo[(i, k)]\\n                \\n            # Starting from i, we could create a group of houses that includes those in\\n            # the inclusive range [i, j] and assign one mailbox to them. Think of the mailbox\\n            # assigned as those houses\\' home-base mailbox. We are looking to place k home-base\\n            # mailboxes, one per group of houses. Since we do not know where we\\'d lop off the\\n            # group, i.e. where we\\'d end the group starting at i, we\\'ll try all possible ending\\n            # position for this group\\n            min_dist = float(\\'inf\\')\\n            for j in xrange(i, n):\\n                # If this group starts at i and ends at j, inclusive, then recurse and place\\n                # k - 1 remaining mailboxes to k - 1 remaining groups\\n                dist = dist_to_optimal_mbox(i, j) + f(j + 1, k - 1)\\n                min_dist = min(min_dist, dist)\\n            \\n            memo[(i, k)] = min_dist\\n            return min_dist\\n        \\n        return f(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685423,
                "title": "java-dfs-with-cache-o-kn-3-nlogn",
                "content": "The question can be convert to: split houses to k group, find shortest distance sum from each group.\\n(In a array/subarray, the shortest distance sum is the distance from median index)\\n```\\nclass Solution {\\n    private Integer[][] cache;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        cache = new Integer[houses.length+1][k+1];\\n        int res = dfs(houses, 0, k);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    private int dfs(int[] houses, int idx, int k){\\n        if(k == 0 || idx >= houses.length) return Integer.MAX_VALUE;\\n        if(cache[idx][k]!=null) return cache[idx][k];\\n        if(k == 1){\\n            return getMedianSum(houses, idx, houses.length - 1);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=idx; i<houses.length-k+1; i++){\\n            //next group\\n            int m1 = getMedianSum(houses, idx, i);\\n            int d1 = dfs(houses, i+1, k - 1);\\n            if(m1 != Integer.MAX_VALUE && d1 != Integer.MAX_VALUE){\\n                min = Math.min(min, m1 + d1);\\n            }\\n        }\\n        cache[idx][k] = min;\\n        return min;\\n    }\\n    private int getMedianSum(int houses[], int l, int r) { \\n        int m = houses[l + (r-l)/2];\\n        int sum = 0;\\n        for(int i=l;i<=r;i++){\\n            sum += Math.abs(houses[i] - m);\\n        }\\n        return sum;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Integer[][] cache;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        cache = new Integer[houses.length+1][k+1];\\n        int res = dfs(houses, 0, k);\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n    private int dfs(int[] houses, int idx, int k){\\n        if(k == 0 || idx >= houses.length) return Integer.MAX_VALUE;\\n        if(cache[idx][k]!=null) return cache[idx][k];\\n        if(k == 1){\\n            return getMedianSum(houses, idx, houses.length - 1);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=idx; i<houses.length-k+1; i++){\\n            //next group\\n            int m1 = getMedianSum(houses, idx, i);\\n            int d1 = dfs(houses, i+1, k - 1);\\n            if(m1 != Integer.MAX_VALUE && d1 != Integer.MAX_VALUE){\\n                min = Math.min(min, m1 + d1);\\n            }\\n        }\\n        cache[idx][k] = min;\\n        return min;\\n    }\\n    private int getMedianSum(int houses[], int l, int r) { \\n        int m = houses[l + (r-l)/2];\\n        int sum = 0;\\n        for(int i=l;i<=r;i++){\\n            sum += Math.abs(houses[i] - m);\\n        }\\n        return sum;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685460,
                "title": "c-o-n-3-dp",
                "content": "Sort the houses first\\n\\n`dp[i][j]` = min sum of distance of houses with indexes in `[0, j]` using `i` mailboxes\\n`cost[l][r]` = sum of distance of houses with indexes in `[l, r]` using one mailbox = sum of distance of the houses to the median house\\n\\n`dp[i][j] = min{ dp[i - 1][x] + cost[x + 1][j] | x in [0, j - 1] }`\\n(assign the first `x` houses to first `i - 1` mailboxes and assign the others to the last mailbox)\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        const int INF = 1e9 + 10;\\n        int n = houses.size();\\n        vector<vector<int>> dp(k + 1, vector<int>(n));\\n        vector<vector<int>> cost(n, vector<int>(n));\\n\\n        sort(houses.begin(), houses.end());\\n        \\n        for(int i = 0; i < n; ++i) {\\n            for(int j = i; j < n; ++j) {\\n                cost[i][j] = 0;\\n                for(int u = i; u <= j; ++u) {\\n                    cost[i][j] += abs(houses[u] - houses[i + (j - i) / 2]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            dp[1][i] = cost[0][i];\\n        }\\n\\n        for(int t = 2; t <= k; ++t) {\\n            for(int i = 0; i < n; ++i) {\\n                dp[t][i] = INF;\\n                for(int j = 0; j < i; ++j) {\\n                    dp[t][i] = min(dp[t][i], dp[t - 1][j] + cost[j + 1][i]);\\n                }\\n            }\\n        }\\n        return dp[k][n - 1];\\n    }\\n};\\n```\\n\\nanother solution (n^2 * logn):\\nhttps://pastebin.com/n9D91s5N",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        const int INF = 1e9 + 10;\\n        int n = houses.size();\\n        vector<vector<int>> dp(k + 1, vector<int>(n));\\n        vector<vector<int>> cost(n, vector<int>(n));\\n\\n        sort(houses.begin(), houses.end());\\n        \\n        for(int i = 0; i < n; ++i) {\\n            for(int j = i; j < n; ++j) {\\n                cost[i][j] = 0;\\n                for(int u = i; u <= j; ++u) {\\n                    cost[i][j] += abs(houses[u] - houses[i + (j - i) / 2]);\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; ++i) {\\n            dp[1][i] = cost[0][i];\\n        }\\n\\n        for(int t = 2; t <= k; ++t) {\\n            for(int i = 0; i < n; ++i) {\\n                dp[t][i] = INF;\\n                for(int j = 0; j < i; ++j) {\\n                    dp[t][i] = min(dp[t][i], dp[t - 1][j] + cost[j + 1][i]);\\n                }\\n            }\\n        }\\n        return dp[k][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811629,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int helper(int i, int k, vector<int>& houses){\\n        if(i>=houses.size()) return 0;\\n        if(k==0){ \\n            dp[i][k] = 1e9;\\n            return dp[i][k];\\n        }\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int ans = 1e9;\\n        dp[i][k] = 0;\\n        int mid = 0;\\n        \\n        for(int j=i;j<houses.size();j++){\\n            mid = (i+j)/2;\\n            int c = 0;\\n            for(int l = i; l<=j ; l++){\\n                c+=abs(houses[mid]-houses[l]);\\n            }\\n            ans = min(ans, c+helper(j+1, k-1, houses));\\n        }\\n        //cout<<i<<\" \"<<e<<endl;\\n        dp[i][k] = ans;\\n        return dp[i][k];\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        if(houses.size()<2) return 0;\\n        if(k>=houses.size()) return 0;\\n        memset(dp, -1, sizeof(dp));\\n        sort(houses.begin(), houses.end());\\n        return helper(0, k, houses);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int helper(int i, int k, vector<int>& houses){\\n        if(i>=houses.size()) return 0;\\n        if(k==0){ \\n            dp[i][k] = 1e9;\\n            return dp[i][k];\\n        }\\n\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int ans = 1e9;\\n        dp[i][k] = 0;\\n        int mid = 0;\\n        \\n        for(int j=i;j<houses.size();j++){\\n            mid = (i+j)/2;\\n            int c = 0;\\n            for(int l = i; l<=j ; l++){\\n                c+=abs(houses[mid]-houses[l]);\\n            }\\n            ans = min(ans, c+helper(j+1, k-1, houses));\\n        }\\n        //cout<<i<<\" \"<<e<<endl;\\n        dp[i][k] = ans;\\n        return dp[i][k];\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        if(houses.size()<2) return 0;\\n        if(k>=houses.size()) return 0;\\n        memset(dp, -1, sizeof(dp));\\n        sort(houses.begin(), houses.end());\\n        return helper(0, k, houses);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 685361,
                "title": "clean-python-3-o-nnk-with-top-down-dp",
                "content": "Time: `O(NNK + NN) = O(NNK)`.\\nSpace: `O(NNK + NN) = O(NNK)`\\n```\\nimport functools\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @functools.lru_cache(None)\\n        def dist(start: int, end: int):\\n            if start == 0:\\n                total = 0\\n                while start < end:\\n                    total += houses[end] - houses[start]\\n                    start += 1\\n                    end -= 1\\n                return total\\n            else:\\n                mid = start + (end - start) // 2\\n                return dist(start - 1, end) - (houses[mid] - houses[start - 1])\\n\\n        @functools.lru_cache(None)\\n        def dfs(i: int, last: int, group: int) -> int:\\n            if i == n: return float(\\'inf\\')\\n            if group == k - 1: return dist(i, n - 1)\\n            new_group = dfs(i + 1, i + 1, group + 1) + dist(last, i)\\n            no_new_group = dfs(i + 1, last, group)\\n            return min(new_group, no_new_group)\\n\\n        n = len(houses)\\n        houses.sort()\\n        return dfs(0, 0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @functools.lru_cache(None)\\n        def dist(start: int, end: int):\\n            if start == 0:\\n                total = 0\\n                while start < end:\\n                    total += houses[end] - houses[start]\\n                    start += 1\\n                    end -= 1\\n                return total\\n            else:\\n                mid = start + (end - start) // 2\\n                return dist(start - 1, end) - (houses[mid] - houses[start - 1])\\n\\n        @functools.lru_cache(None)\\n        def dfs(i: int, last: int, group: int) -> int:\\n            if i == n: return float(\\'inf\\')\\n            if group == k - 1: return dist(i, n - 1)\\n            new_group = dfs(i + 1, i + 1, group + 1) + dist(last, i)\\n            no_new_group = dfs(i + 1, last, group)\\n            return min(new_group, no_new_group)\\n\\n        n = len(houses)\\n        houses.sort()\\n        return dfs(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800027,
                "title": "c-detailed-explanation",
                "content": "Before reading my explanation, check out another amazing one- https://leetcode.com/problems/allocate-mailboxes/discuss/685516/Python3-oror-Detailed-Explanation-and-Commented-Code\\n\\nThis question can be explained better by looking at a few base examples.\\nSay if the array is [1,2,3,4] and we have 1 mailbox. My approach here was to find the median of the first and last index. So in this case, it would be (0 +3) /2 + 0= 1. So the median house in this example would be houses[1]=2. If you calculate the difference from this median point to all the houses, you get (1 + 0 + 1 + 2)=4 which is the smallest distance calculable. This also worksif there are an odd number of houses. Say, if houses=[1,2,3,4,5] and k==1, the median index would be  (4+0)/2 +0=2 and the median house would be houses[2]=3. Then the minimum distance would be (3-1 + 3-2 + 3-3 + 4-3 + 5-3) = 6.\\n\\nSo now that u have hopefully understood the median approach in calculating the minimum distance with a single mailbox, what do you do if there is more than one mailbox. My approach here was to split the array into k groups of houses , given k mailboxes. Here each group would be allocated a single mailbox. Let\\'s use an example to simplify this. \\nIf the array houses =[1,2,3,4,5] and k=2, the 2 groups (given 2 mailboxes) could be represented as \\n[1], [2,3,4,5]  OR  [1,2], [3,4,5]  OR  [1,2,3],[4,5] OR  [1,2,3,4],[5].  Then via the median concept explained previously, the minimum total distance can be calculated for each grouping arrangement and the minimum of those returned. The answer in this case can be found in the groups [1,2,3],[4,5] which results in a distance of 3.\\n\\nNow say if the array remains the same and k =3,  multiple new arrangements of groups of houses can be calculated through the initial groups. For example, the group [1], [2,3,4,5] can be extended to\\n[1],[2,3,4],[5] or [1],[2,3],[4,5] OR [1],[2],[3,4,5]. Similar to the situation with 2 mailboxes, the minimum total distance created by all the possible permutations of groups is returned.  \\n\\nSo now that the main concept for creating groups of houses and calculating the minimum distances in said groups is explained, how can it be implemented. I used a recursive function which took as input the starting index ,start, and the remaining number of mailboxes,k. This can be represented by helper(start,k). This function would essentially, calculate the minimum distance of all the possible permutations of creating k groups of houses from the starting index onwards, and return the total minimum distance.  Taking an example to expain this, given the  array [1,2,3,4] and k (number of mailboxes) as 2, going step by step, the function would\\n\\n- Take the starting index as 0, and the starting k value as 2\\n- calculate the minimum distance  given one mailbox is allocated  to the house ,[1] and sum this value to the value returned by the function  for the remaining houses. This would represented as helper(0+1,2-1) as the new starting index is 1 with 1 mailbox remaing.\\n- Calculate the minimum distance  given the houses [2,3,4] and 1 mailbox which is =2.\\n\\nThis process would be replicated for every other possible arrangement, the minimum distance of which would be returned.\\n\\nNow to optimize this program, one can memoize previously calculated values for a starting index and remaining number of mailboxes. The matrice memo[start][k]  can do this.\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int start,vector<int>& houses, int k,vector<vector<int>>&memo){\\n        if (k==1){\\n            int ans=0;\\n            int end=houses.size()-1;\\n            int med=(end-start)/2 + start;\\n            for (int i = start; i<=end;i++) ans+= abs(houses[i]-houses[med]);\\n            return ans;\\n        }\\n        if (memo[start][k]) return memo[start][k];\\n        int temp=start;\\n        int ans=INT_MAX;\\n        while (houses.size()-1-temp >=k-1){\\n            int med=(temp-start)/2 + start;\\n            int newans=0;\\n            for (int i=start;i<=temp;i++) newans+=abs(houses[i]-houses[med]);\\n            newans+=helper(temp+1,houses,k-1,memo);\\n            ans=min(ans,newans);\\n            temp++;\\n        }\\n        return memo[start][k]=ans;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        if (k>=houses.size()) return 0;\\n        vector<vector<int>>memo(houses.size(), vector<int>(k+1));\\n        sort(houses.begin(), houses.end());\\n        return helper(0,houses,k,memo);\\n    }\\n};\\n```\\n\\nHope this helps",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int start,vector<int>& houses, int k,vector<vector<int>>&memo){\\n        if (k==1){\\n            int ans=0;\\n            int end=houses.size()-1;\\n            int med=(end-start)/2 + start;\\n            for (int i = start; i<=end;i++) ans+= abs(houses[i]-houses[med]);\\n            return ans;\\n        }\\n        if (memo[start][k]) return memo[start][k];\\n        int temp=start;\\n        int ans=INT_MAX;\\n        while (houses.size()-1-temp >=k-1){\\n            int med=(temp-start)/2 + start;\\n            int newans=0;\\n            for (int i=start;i<=temp;i++) newans+=abs(houses[i]-houses[med]);\\n            newans+=helper(temp+1,houses,k-1,memo);\\n            ans=min(ans,newans);\\n            temp++;\\n        }\\n        return memo[start][k]=ans;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        if (k>=houses.size()) return 0;\\n        vector<vector<int>>memo(houses.size(), vector<int>(k+1));\\n        sort(houses.begin(), houses.end());\\n        return helper(0,houses,k,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513947,
                "title": "the-explanation-you-ve-been-waiting-for",
                "content": "Let\\'s first understand the optimal strategy to put a single mailbox.\\n* If there is only one house, we can put the mailbox at that house, resulting in a distance of zero.\\n* If there are two houses, the best place to put the mailbox is in the middle, optimally dividing the distance between the houses.\\n* If there are three houses, the best place to put the mailbox is at the second house.\\n\\nGeneralizing, given an even number of houses, we will put the mailbox in between the middle two houses.\\nFor an odd number of houses, we will put the mailbox at the middle house.\\n\\nSo, now we understand how to put one mailbox, but where do we put it to begin with? Observe that given `n` houses and `k` mailboxes, the last house we can put the first mailbox is at index `n - k`.\\n\\nFor example, `n=6`, `k=3`, we can put the first mailbox anywhere from the 1st house (index 0) till the 4th house (index 3). If we put the first mailbox beyond the 4th house, we won\\'t have enough houses left to put the remaining 2 mailboxes.\\n\\nOnce we have put the first mailbox covering up to the i-th house, we are left with `n - i` houses and `k - 1` mailboxes, which is a subproblem of the original problem.\\n\\nFor each choice of putting the first mailbox, we use the logic described in the beginning to calculate the distance. We then recurse on the smaller subproblem and add the two distances. The answer is the minimum of all such distances.\\n\\nThere are two base cases:\\n1. If there\\'s only one mailbox to put, we use the logic described in the beginning to calculate the distance.\\n2. If there are as many mailboxes as there are houses, we put one mailbox at each house resulting in a total distance of zero.\\n\\nTime complexity:\\n* Consider the example of `k=1` for any `n`. The time complexity to calculate the distance is `O(n)`.\\n* Consider the example of `k=2` for any `n`. For each placement of the first mailbox, we take `O(n)` time to calculate the distance from the second mailbox. Since the first mailbox can be placed at any of the `n - 1` positions, the total time complexity is `O(n^2)`.\\n* Consider the example of `k=3` for any `n`. For each placement of the first mailbox, we take `O(n^2)` time to place the remaining two mailboxes.\\n\\nClearly, the total time complexity is `O(n^k)`. However, due to memoization, this is much better in reality.\\n\\n```\\nimport functools\\n\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @functools.cache\\n        def _loop(start: int, end: int, num_mailboxes: int) -> int:\\n            num_houses = end - start + 1\\n            if num_houses == num_mailboxes:\\n                return 0\\n            if num_mailboxes == 1:\\n                if num_houses % 2 == 0:\\n                    mid = start + num_houses // 2\\n                    pos = houses[mid - 1] + (houses[mid] - houses[mid - 1]) // 2\\n                else:\\n                    mid = start + (num_houses - 1) // 2\\n                    pos = houses[mid]\\n\\n                return sum(abs(pos - houses[i]) for i in range(start, end + 1))\\n\\n            min_dist = sys.maxsize\\n            for i in range(start, len(houses) - num_mailboxes + 1):\\n                dist = _loop(start, i, 1) + _loop(i + 1, end, num_mailboxes - 1)\\n                min_dist = min(min_dist, dist)\\n\\n            return min_dist\\n\\n        houses.sort()\\n        return _loop(0, len(houses) - 1, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport functools\\n\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @functools.cache\\n        def _loop(start: int, end: int, num_mailboxes: int) -> int:\\n            num_houses = end - start + 1\\n            if num_houses == num_mailboxes:\\n                return 0\\n            if num_mailboxes == 1:\\n                if num_houses % 2 == 0:\\n                    mid = start + num_houses // 2\\n                    pos = houses[mid - 1] + (houses[mid] - houses[mid - 1]) // 2\\n                else:\\n                    mid = start + (num_houses - 1) // 2\\n                    pos = houses[mid]\\n\\n                return sum(abs(pos - houses[i]) for i in range(start, end + 1))\\n\\n            min_dist = sys.maxsize\\n            for i in range(start, len(houses) - num_mailboxes + 1):\\n                dist = _loop(start, i, 1) + _loop(i + 1, end, num_mailboxes - 1)\\n                min_dist = min(min_dist, dist)\\n\\n            return min_dist\\n\\n        houses.sort()\\n        return _loop(0, len(houses) - 1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191705,
                "title": "share-my-simple-and-easy-to-understand-dp-solution",
                "content": "## Step 1,\\nwe need to understand a sub-problem: when there\\'s only one mailbox, what\\'s its optimal position? And how can we calculate the minimum sum? \\n\\nApparently, the optimal position of the mailbox when there\\'s **n** houses(index starting from 0) should obey the following rule:\\n\\nIf **n** is odd, mailbox should at house **n / 2**; if **n** is even, mailbox should at any point between **n / 2** and **n / 2 + 1**.\\n\\nThe way to calculate the sum of distances from all houses (we are assuming house\\'s position are sorted) to the mailbox when there\\'s **i + 1** houses can be done using the following code:\\n\\n```\\nfor (int i = 1, pos = 0, sum = 0; i < n; i++) {  //originally, sum of distances equals to 0, mailbox is at house[0] \\n\\tsum += houses[i] - houses[pos];      //when adding a new house i, keep mailbox at its original place, so the total distance increased by the distance between ith house and mailbox.\\n\\tdist[i] = sum;      //dist[i] indicates the minimum sum when there\\'s i + 1 houses\\n    if (i % 2 == 1) pos++;     //when there\\'s 2, 4, 6.. houses, to prepare for the next coming house (we move the mailbox to the next house)\\n\\t//if you have difficulty understanding how this part works, draw on your scratch paper and follow the change of number of houses and the position of the mailbox in this loop\\n}\\n```\\n\\n## Step 2, \\nwe need to understand how dynamic programming works for solving the problem. Use **dp[i][j]** to denote the minimum sum of distance when there\\'s **i + 1** mailboxes and **j + 1** houses. We will have the following transition equaltion:\\n```\\n dp[i][j] = min(dp[i-1][m-1] + min(sum of distances of m-th ~ j-th houses to the last mailbox)) \\n```\\nwe can use a loop to find the best **m**, so that **dp[i][j]** is optimized. Note that in this loop, we will use the same calculation logic used in the first step to calculate ```min(sum of distances of m-th ~ j-th houses to the last mailbox)```.\\n\\nSo the complete code is as following:\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[k][n];\\n        for (int i = 1, pos = 0; i < n; i++) {   // this part is our step 1\\n\\t\\t\\tdp[0][i] = dp[0][i-1] + houses[i] - houses[pos];\\n            if (i % 2 == 1) pos++;\\n        }\\n        \\n        for (int i = 1; i < k; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                dp[i][j] = dp[i-1][j-1];     //initialize dp[i][j] as if we just put the i-th mailbox at the j-th house\\n                for (int m = j - 1, pos = j, sum = 0; m > 0; m--) {  // note here we use the same logic as step 1, but in the opposite direction \\n                    sum += houses[pos] - houses[m];\\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][m-1] + sum);\\n                    if ((j - m) % 2 == 1) pos--;\\n                }\\n            }\\n        }\\n        return dp[k-1][n-1];\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nfor (int i = 1, pos = 0, sum = 0; i < n; i++) {  //originally, sum of distances equals to 0, mailbox is at house[0] \\n\\tsum += houses[i] - houses[pos];      //when adding a new house i, keep mailbox at its original place, so the total distance increased by the distance between ith house and mailbox.\\n\\tdist[i] = sum;      //dist[i] indicates the minimum sum when there\\'s i + 1 houses\\n    if (i % 2 == 1) pos++;     //when there\\'s 2, 4, 6.. houses, to prepare for the next coming house (we move the mailbox to the next house)\\n\\t//if you have difficulty understanding how this part works, draw on your scratch paper and follow the change of number of houses and the position of the mailbox in this loop\\n}\\n```\n```\\n dp[i][j] = min(dp[i-1][m-1] + min(sum of distances of m-th ~ j-th houses to the last mailbox)) \\n```\n```min(sum of distances of m-th ~ j-th houses to the last mailbox)```\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[k][n];\\n        for (int i = 1, pos = 0; i < n; i++) {   // this part is our step 1\\n\\t\\t\\tdp[0][i] = dp[0][i-1] + houses[i] - houses[pos];\\n            if (i % 2 == 1) pos++;\\n        }\\n        \\n        for (int i = 1; i < k; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                dp[i][j] = dp[i-1][j-1];     //initialize dp[i][j] as if we just put the i-th mailbox at the j-th house\\n                for (int m = j - 1, pos = j, sum = 0; m > 0; m--) {  // note here we use the same logic as step 1, but in the opposite direction \\n                    sum += houses[pos] - houses[m];\\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][m-1] + sum);\\n                    if ((j - m) % 2 == 1) pos--;\\n                }\\n            }\\n        }\\n        return dp[k-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937354,
                "title": "c-2d-dp-bottom-up-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(),houses.end());\\n        vector<vector<int>> dp(n,vector<int>(k+1,INT_MAX));\\n        for(int i=0;i<n;++i) dp[i][1] = findDist(houses,-1,i);\\n        for(int j=2;j<=k;++j)\\n            for(int i=0;i<n;++i)\\n                for(int h=0;h<i;++h)\\n                    dp[i][j] = min((double)(dp[i][j]),dp[h][j-1]+findDist(houses,h,i));\\n        return dp[n-1][k];\\n    }\\n    \\n    double findDist(vector<int>& houses, int h, int i){\\n        double mid, dist = 0;\\n        if((i-h) % 2 == 1) \\n            mid = houses[(i+h+1)/2];\\n        else\\n            mid = (houses[(i+h)/2] + houses[(i+h)/2+1])/(double)2;\\n        \\n        for(int cur=h+1;cur<=i;++cur)\\n            dist += abs(mid-houses[cur]);\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(),houses.end());\\n        vector<vector<int>> dp(n,vector<int>(k+1,INT_MAX));\\n        for(int i=0;i<n;++i) dp[i][1] = findDist(houses,-1,i);\\n        for(int j=2;j<=k;++j)\\n            for(int i=0;i<n;++i)\\n                for(int h=0;h<i;++h)\\n                    dp[i][j] = min((double)(dp[i][j]),dp[h][j-1]+findDist(houses,h,i));\\n        return dp[n-1][k];\\n    }\\n    \\n    double findDist(vector<int>& houses, int h, int i){\\n        double mid, dist = 0;\\n        if((i-h) % 2 == 1) \\n            mid = houses[(i+h+1)/2];\\n        else\\n            mid = (houses[(i+h)/2] + houses[(i+h)/2+1])/(double)2;\\n        \\n        for(int cur=h+1;cur<=i;++cur)\\n            dist += abs(mid-houses[cur]);\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732781,
                "title": "c-o-nlg-n-lg-sum-binary-search-convex-hull-trick-solution",
                "content": "It is also called Aliens trick + Monotone queue optimization.\\n\\n`S[i] = sum { A[j] : 1 \\u2264 j \\u2264 i }`\\n\\n`cost[l][r] = sum { abs(A[i] - A[m]) : l < i \\u2264 r }`\\n`= sum { A[i] - A[m] : m < i \\u2264 r } + sum { A[m] - A[i] : l < i \\u2264 m }`\\n`= A[m] * (2 * m - l - r) + S[l] + S[r] - 2 * S[m]`\\n\\n`dp[k][i] = min { dp[k-1][j] + cost[j][i] : j < i }`\\ncost is monge array. so dp can be optimized by binary search and convex hull trick.\\n\\n```\\nstruct ij {\\n    int i, j;\\n};\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& A, int K) {\\n        const int N = A.size();\\n        vector<int> S(N + 1), C(N + 1), D(N + 1);\\n        A.push_back(0);\\n        sort(begin(A), end(A));\\n        for (int i = 1; i <= N; i++)\\n            S[i] = S[i - 1] + A[i];\\n\\n        auto cost = [&](int l, int r) {\\n            const int m = l + r + 1 >> 1;\\n            return D[l] + A[m] * (2 * m - l - r) + S[l] + S[r] - 2 * S[m];\\n        };\\n        auto intersection = [&](int i, int j) {\\n            int l = j, r = N;\\n            while (l < r) {\\n                int m = l + r >> 1;\\n                if (cost(i, m + 1) < cost(j, m + 1))\\n                    l = m + 1;\\n                else\\n                    r = m;\\n            }\\n            return r;\\n        };\\n\\n        vector<ij> Q(N);\\n        int l = 0, r = S[N], ans = 0;\\n        while (l <= r) {\\n            int m = l + r + 1 >> 1;\\n            for (int i = 1, s = 0, e = 0; i <= N; i++) {\\n                while (s + 1 <= e) {\\n                    Q[e - 1].j = intersection(Q[e - 1].i, i - 1);\\n                    if (s + 1 == e || Q[e - 2].j < Q[e - 1].j)\\n                        break;\\n                    e--;\\n                }\\n                Q[e++] = { i - 1, N };\\n                while (s + 1 < e && cost(Q[s].i, i) >= cost(Q[s + 1].i, i))\\n                    s++;\\n\\n                D[i] = cost(Q[s].i, i) + m;\\n                C[i] = C[Q[s].i] + 1;\\n                if (l < r && (C[i] > K || C[i] + N - i < K)) {\\n                    C[N] = C[i];\\n                    break;\\n                }\\n            }\\n            if (C[N] == K || l == r) {\\n                ans = D[N] - m * K;\\n                break;\\n            }\\n            if (C[N] > K)\\n                l = m;\\n            else\\n                r = m - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstruct ij {\\n    int i, j;\\n};\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& A, int K) {\\n        const int N = A.size();\\n        vector<int> S(N + 1), C(N + 1), D(N + 1);\\n        A.push_back(0);\\n        sort(begin(A), end(A));\\n        for (int i = 1; i <= N; i++)\\n            S[i] = S[i - 1] + A[i];\\n\\n        auto cost = [&](int l, int r) {\\n            const int m = l + r + 1 >> 1;\\n            return D[l] + A[m] * (2 * m - l - r) + S[l] + S[r] - 2 * S[m];\\n        };\\n        auto intersection = [&](int i, int j) {\\n            int l = j, r = N;\\n            while (l < r) {\\n                int m = l + r >> 1;\\n                if (cost(i, m + 1) < cost(j, m + 1))\\n                    l = m + 1;\\n                else\\n                    r = m;\\n            }\\n            return r;\\n        };\\n\\n        vector<ij> Q(N);\\n        int l = 0, r = S[N], ans = 0;\\n        while (l <= r) {\\n            int m = l + r + 1 >> 1;\\n            for (int i = 1, s = 0, e = 0; i <= N; i++) {\\n                while (s + 1 <= e) {\\n                    Q[e - 1].j = intersection(Q[e - 1].i, i - 1);\\n                    if (s + 1 == e || Q[e - 2].j < Q[e - 1].j)\\n                        break;\\n                    e--;\\n                }\\n                Q[e++] = { i - 1, N };\\n                while (s + 1 < e && cost(Q[s].i, i) >= cost(Q[s + 1].i, i))\\n                    s++;\\n\\n                D[i] = cost(Q[s].i, i) + m;\\n                C[i] = C[Q[s].i] + 1;\\n                if (l < r && (C[i] > K || C[i] + N - i < K)) {\\n                    C[N] = C[i];\\n                    break;\\n                }\\n            }\\n            if (C[N] == K || l == r) {\\n                ans = D[N] - m * K;\\n                break;\\n            }\\n            if (C[N] > K)\\n                l = m;\\n            else\\n                r = m - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685335,
                "title": "java-dfs-memo-o-n-3",
                "content": "Idea:\\n\\t\\t1. pre-calculate the min distance if we place a mail-box in each house interval (what the cost array store) \\n\\t\\t2. dp, the state would be how many box in each house interval\\n```\\nclass Solution {\\n    int cost[][];\\n    int dp[][];\\n    public int minDistance(int[] A, int k) {\\n        Arrays.sort(A);\\n        cost=new int[A.length][A.length];\\n        for(int i=0;i<A.length;i++){\\n            for(int j=i+1;j<A.length;j++){\\n                cost[i][j]=cal(A,i,j);\\n            }\\n        }\\n        \\n        dp=new int[A.length][k+1];\\n        for(int i=0;i<dp.length;i++)Arrays.fill(dp[i],-1);\\n        int val= dfs(A,A.length-1,k);\\n        return val;\\n    }\\n        \\n    public int dfs(int A[],int index,int k){\\n        if(index<0)return 0;\\n        if(k==1){\\n            return cost[0][index];\\n        }\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<=index;i++){\\n            res=Math.min(res,cost[i][index]+dfs(A,i,k-1));\\n            res=Math.min(res,cost[i][index]+dfs(A,i-1,k-1));\\n        }\\n        dp[index][k]=res;\\n        return res;\\n    }\\n    \\n    public int cal(int A[],int l,int r){\\n        int size=r-l+1;\\n        int res=0;\\n        int index=0;\\n        if(size%2==1){\\n            index=(r-l)/2+l;\\n            for(int i=l;i<=r;i++){\\n                res+=Math.abs(A[i]-A[index]);\\n            }\\n        }else{\\n            int median=(A[(r-l)/2+l+1]-A[(r-l)/2+l])/2+A[(r-l)/2+l];\\n            for(int i=l;i<=r;i++){\\n                res+=Math.abs(A[i]-median);\\n            }\\n        }\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cost[][];\\n    int dp[][];\\n    public int minDistance(int[] A, int k) {\\n        Arrays.sort(A);\\n        cost=new int[A.length][A.length];\\n        for(int i=0;i<A.length;i++){\\n            for(int j=i+1;j<A.length;j++){\\n                cost[i][j]=cal(A,i,j);\\n            }\\n        }\\n        \\n        dp=new int[A.length][k+1];\\n        for(int i=0;i<dp.length;i++)Arrays.fill(dp[i],-1);\\n        int val= dfs(A,A.length-1,k);\\n        return val;\\n    }\\n        \\n    public int dfs(int A[],int index,int k){\\n        if(index<0)return 0;\\n        if(k==1){\\n            return cost[0][index];\\n        }\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<=index;i++){\\n            res=Math.min(res,cost[i][index]+dfs(A,i,k-1));\\n            res=Math.min(res,cost[i][index]+dfs(A,i-1,k-1));\\n        }\\n        dp[index][k]=res;\\n        return res;\\n    }\\n    \\n    public int cal(int A[],int l,int r){\\n        int size=r-l+1;\\n        int res=0;\\n        int index=0;\\n        if(size%2==1){\\n            index=(r-l)/2+l;\\n            for(int i=l;i<=r;i++){\\n                res+=Math.abs(A[i]-A[index]);\\n            }\\n        }else{\\n            int median=(A[(r-l)/2+l+1]-A[(r-l)/2+l])/2+A[(r-l)/2+l];\\n            for(int i=l;i<=r;i++){\\n                res+=Math.abs(A[i]-median);\\n            }\\n        }\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080770,
                "title": "c-recursion-memoization-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find all possible combinations of consecutive K groups. \\n2. From each group find the median element and calculate the cost of the group. Cost can be calculated as the absolute difference between the elements of the group and the median element.\\n3. Track the minimum answer from all possible combinations.\\n\\n# Recursion\\n```\\nclass Solution {\\nprivate:\\n    int recursion(int index, int k, int size, vector<int>&houses)\\n    {\\n        if(k == 1)\\n        {\\n            int median = houses[((size - index) / 2) + index];\\n            int ans = 0;\\n            for(int i = index; i < size; ++i)\\n            {\\n                ans += abs(houses[i] - median);\\n            }\\n            return ans;\\n        }\\n        int mini = INT_MAX;\\n        for(int i = index; i <= (size - k); ++i)\\n        {\\n            int median = houses[((i - index) / 2) + index];\\n            int currAns = 0;\\n            for(int j = index; j <= i; ++j)\\n            {\\n                currAns += abs(houses[j] - median);\\n            }\\n            int ans = currAns + recursion(i + 1, k - 1, size, houses);\\n            mini = min(mini, ans);\\n        }\\n        return mini;\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int size = houses.size();\\n        sort(houses.begin(), houses.end());\\n        return recursion(0, k, size, houses);\\n    }\\n};\\n```\\n\\n\\n# Memoization\\n```\\nclass Solution {\\nprivate:\\n    int memoization(int index, int k, int size, vector<int>&houses, vector<vector<int>>&dp)\\n    {\\n        if(k == 1)\\n        {\\n            int average = houses[((size - index) / 2) + index];\\n            int ans = 0;\\n            for(int i = index; i < size; ++i)\\n            {\\n                ans += abs(houses[i] - average);\\n            }\\n            return ans;\\n        }\\n        if(dp[index][k] != -1)\\n        {\\n            return dp[index][k];\\n        }\\n        int mini = INT_MAX;\\n        for(int i = index; i <= (size - k); ++i)\\n        {\\n            int average = houses[((i - index) / 2) + index];\\n            int currAns = 0;\\n            for(int j = index; j <= i; ++j)\\n            {\\n                currAns += abs(houses[j] - average);\\n            }\\n            int ans = currAns + memoization(i + 1, k - 1, size, houses, dp);\\n            mini = min(mini, ans);\\n        }\\n        return dp[index][k] = mini;\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int size = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>>dp(size, vector<int>(k + 1, -1));\\n        return memoization(0, k, size, houses, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int recursion(int index, int k, int size, vector<int>&houses)\\n    {\\n        if(k == 1)\\n        {\\n            int median = houses[((size - index) / 2) + index];\\n            int ans = 0;\\n            for(int i = index; i < size; ++i)\\n            {\\n                ans += abs(houses[i] - median);\\n            }\\n            return ans;\\n        }\\n        int mini = INT_MAX;\\n        for(int i = index; i <= (size - k); ++i)\\n        {\\n            int median = houses[((i - index) / 2) + index];\\n            int currAns = 0;\\n            for(int j = index; j <= i; ++j)\\n            {\\n                currAns += abs(houses[j] - median);\\n            }\\n            int ans = currAns + recursion(i + 1, k - 1, size, houses);\\n            mini = min(mini, ans);\\n        }\\n        return mini;\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int size = houses.size();\\n        sort(houses.begin(), houses.end());\\n        return recursion(0, k, size, houses);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int memoization(int index, int k, int size, vector<int>&houses, vector<vector<int>>&dp)\\n    {\\n        if(k == 1)\\n        {\\n            int average = houses[((size - index) / 2) + index];\\n            int ans = 0;\\n            for(int i = index; i < size; ++i)\\n            {\\n                ans += abs(houses[i] - average);\\n            }\\n            return ans;\\n        }\\n        if(dp[index][k] != -1)\\n        {\\n            return dp[index][k];\\n        }\\n        int mini = INT_MAX;\\n        for(int i = index; i <= (size - k); ++i)\\n        {\\n            int average = houses[((i - index) / 2) + index];\\n            int currAns = 0;\\n            for(int j = index; j <= i; ++j)\\n            {\\n                currAns += abs(houses[j] - average);\\n            }\\n            int ans = currAns + memoization(i + 1, k - 1, size, houses, dp);\\n            mini = min(mini, ans);\\n        }\\n        return dp[index][k] = mini;\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int size = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>>dp(size, vector<int>(k + 1, -1));\\n        return memoization(0, k, size, houses, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496112,
                "title": "beginner-friendly-easy-to-understand-dp-solution",
                "content": "## IDEA:\\n* Firstly we will create cost[i][j]. \\n* cost[i][j] = total travel distance by putting one mailbox in between i & j houses.\\n* It means cost[i][j] is the total travel distance from between houses[i:j] to a mailbox when putting the mailbox among houses[i:j], the best way is put the mail box at median position among houses[i:j].\\n\\n* Now after creating costs table, we can directly go with the number of mailboxes left and starting index of the free houses.\\n* It\\'s something like backtracking.\\n* We are checking each possible combination of putting the mailbox.\\n* Since constraint is low, we can go with O(n^3).\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        \\n        n = len(houses)\\n        houses.sort()\\n        cost = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mid_house = houses[(i+j)//2]\\n                for t in range(i,j+1):\\n                    cost[i][j]+= abs(mid_house-houses[t])\\n        \\n        @lru_cache(None)\\n        def dp(k,ind):\\n            if k==0 and ind==n: return 0\\n            if k==0 or ind==n: return float(\\'inf\\')\\n            res = float(\\'inf\\')\\n            for j in range(ind,n):\\n                c = cost[ind][j]\\n                res = min(res, c + dp(k-1,j+1))\\n            \\n            return res\\n        \\n        return dp(k,0)\\n\\n**Feel free to ask If you have any doubt.**\\uD83E\\uDD17\\n### Thanks and Upvote If you like the idea!!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "## IDEA:\\n* Firstly we will create cost[i][j]. \\n* cost[i][j] = total travel distance by putting one mailbox in between i & j houses.\\n* It means cost[i][j] is the total travel distance from between houses[i:j] to a mailbox when putting the mailbox among houses[i:j], the best way is put the mail box at median position among houses[i:j].\\n\\n* Now after creating costs table, we can directly go with the number of mailboxes left and starting index of the free houses.\\n* It\\'s something like backtracking.\\n* We are checking each possible combination of putting the mailbox.\\n* Since constraint is low, we can go with O(n^3).\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        \\n        n = len(houses)\\n        houses.sort()\\n        cost = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mid_house = houses[(i+j)//2]\\n                for t in range(i,j+1):\\n                    cost[i][j]+= abs(mid_house-houses[t])\\n        \\n        @lru_cache(None)\\n        def dp(k,ind):\\n            if k==0 and ind==n: return 0\\n            if k==0 or ind==n: return float(\\'inf\\')\\n            res = float(\\'inf\\')\\n            for j in range(ind,n):\\n                c = cost[ind][j]\\n                res = min(res, c + dp(k-1,j+1))\\n            \\n            return res\\n        \\n        return dp(k,0)\\n\\n**Feel free to ask If you have any doubt.**\\uD83E\\uDD17\\n### Thanks and Upvote If you like the idea!!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1477610,
                "title": "dp-o-n-3-approach",
                "content": "The idea is to divide our array into k parts and assign mail boxes for each of the group\\n\\n```\\n#define ll long long int\\nclass Solution {\\n    int n;\\n    ll dp[101][101],cost[101][101];\\npublic:\\n    ll solver(int st,vector<int>& a,int k){\\n        if(st>=n)\\n            return 0;\\n        if(k==1)\\n            return cost[st][n-1]; // optimal cost for a[st,...,n-1]\\n        if(dp[st][k]!=-1)\\n            return dp[st][k];\\n        ll nxt=LONG_MAX;\\n        for(int i=st;i<n;i++)\\n            nxt=min({nxt,cost[st][i]+solver(i+1,a,k-1)});// we make a[st,..,i] into a group and find optimal answer for the rest        \\n        return dp[st][k]=nxt;\\n    }\\n    \\n    int minDistance(vector<int>& a, int k) {\\n        n=a.size();\\n        if(n<=k)\\n            return 0;\\n        // sorting the positions for distributing in groups\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++){\\n                cost[i][j]=0; // if we want to group all houses a[i,..,j] in 1 group then optimal distance is stored in cost[i][j]\\n                int m=a[(i+j)/2]; // median postion of the group where we put the mailbox\\n                for(int k=i;k<=j;k++)\\n                    cost[i][j]+=abs(a[k]-m);\\n            }\\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,a,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    int n;\\n    ll dp[101][101],cost[101][101];\\npublic:\\n    ll solver(int st,vector<int>& a,int k){\\n        if(st>=n)\\n            return 0;\\n        if(k==1)\\n            return cost[st][n-1]; // optimal cost for a[st,...,n-1]\\n        if(dp[st][k]!=-1)\\n            return dp[st][k];\\n        ll nxt=LONG_MAX;\\n        for(int i=st;i<n;i++)\\n            nxt=min({nxt,cost[st][i]+solver(i+1,a,k-1)});// we make a[st,..,i] into a group and find optimal answer for the rest        \\n        return dp[st][k]=nxt;\\n    }\\n    \\n    int minDistance(vector<int>& a, int k) {\\n        n=a.size();\\n        if(n<=k)\\n            return 0;\\n        // sorting the positions for distributing in groups\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++)\\n            for(int j=i;j<n;j++){\\n                cost[i][j]=0; // if we want to group all houses a[i,..,j] in 1 group then optimal distance is stored in cost[i][j]\\n                int m=a[(i+j)/2]; // median postion of the group where we put the mailbox\\n                for(int k=i;k<=j;k++)\\n                    cost[i][j]+=abs(a[k]-m);\\n            }\\n        memset(dp,-1,sizeof(dp));\\n        return solver(0,a,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406342,
                "title": "c-memoization-matrix-chain-multiplication-style-dp",
                "content": "### Approach: Dynamic Programming (Matrix Chain Multiplication)\\n\\nTo minimize the total distance of houses from mailboxes, the most optimal approach is, to place the mailboxes in medians of intervals.\\n\\nIntervals would be divided according to the number of mailboxes to be placed (k). \\n\\nTo get the divisions, so that total distance of houses from mailboxes (cost), we have to use dynamic programming (matrix chain multiplication).\\n\\nFor cost function, we have to calculate the median index and we have to sum up the absolute difference of all houses from house of median index in that interval.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //Cost Function of installing one mailbox in given interval.\\n    \\n    int get_cost(vector<int>& houses , int& start , int& end){\\n        int length = end - start + 1;\\n        int median = 0;\\n        if(length & 1 == 0){\\n            int index = start + (end - start)/2;\\n            median = (houses[index] + houses[index + 1])/2;\\n        } else {\\n            int index = start + (end - start)/2;\\n            median = houses[index];\\n        }\\n        int costing = 0;\\n        for(int i = start ; i <= end ; ++i){\\n            costing += abs(houses[i] - median);\\n        }\\n        return costing;\\n    }\\n    \\n    //Generalised solution for k mailboxes in array intervals.\\n    \\n    int memoize(vector<int>& houses , int start , int count , vector<vector<int>>& dp){\\n        if(count == 0 || start >= houses.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[start][count] != -1){\\n            return dp[start][count];\\n        }\\n        \\n        int answer = INT_MAX , temp = 0;\\n        \\n        for(int counter = start ; counter < houses.size() ; counter++){\\n            if(count != 1 || counter == houses.size() - 1){\\n                temp = get_cost(houses , start , counter);\\n                answer = min(answer , temp + memoize(houses, counter + 1 , count - 1 , dp));\\n            }\\n        }\\n        return dp[start][count] = answer;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin() , houses.end());\\n        if(k == houses.size()){\\n            return 0;\\n        }\\n        \\n        int n = houses.size();\\n        \\n        vector<vector<int>> dp(n + 1 , vector<int>(k + 1 , -1));\\n        \\n        return memoize(houses , 0 , k , dp);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Cost Function of installing one mailbox in given interval.\\n    \\n    int get_cost(vector<int>& houses , int& start , int& end){\\n        int length = end - start + 1;\\n        int median = 0;\\n        if(length & 1 == 0){\\n            int index = start + (end - start)/2;\\n            median = (houses[index] + houses[index + 1])/2;\\n        } else {\\n            int index = start + (end - start)/2;\\n            median = houses[index];\\n        }\\n        int costing = 0;\\n        for(int i = start ; i <= end ; ++i){\\n            costing += abs(houses[i] - median);\\n        }\\n        return costing;\\n    }\\n    \\n    //Generalised solution for k mailboxes in array intervals.\\n    \\n    int memoize(vector<int>& houses , int start , int count , vector<vector<int>>& dp){\\n        if(count == 0 || start >= houses.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[start][count] != -1){\\n            return dp[start][count];\\n        }\\n        \\n        int answer = INT_MAX , temp = 0;\\n        \\n        for(int counter = start ; counter < houses.size() ; counter++){\\n            if(count != 1 || counter == houses.size() - 1){\\n                temp = get_cost(houses , start , counter);\\n                answer = min(answer , temp + memoize(houses, counter + 1 , count - 1 , dp));\\n            }\\n        }\\n        return dp[start][count] = answer;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin() , houses.end());\\n        if(k == houses.size()){\\n            return 0;\\n        }\\n        \\n        int n = houses.size();\\n        \\n        vector<vector<int>> dp(n + 1 , vector<int>(k + 1 , -1));\\n        \\n        return memoize(houses , 0 , k , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694974,
                "title": "o-n-3-simple-dp-python-c",
                "content": "Start by sorting the list of houses. \\n\\nNow, to allocate `k` mailboxes to `n` houses optimally, try for every `1 <= i <= n`:\\n1. Allocate `1` mailbox to the last `i` houses.\\n2. Allocate `k - 1` mailboxes to the remaining `n - i` houses.\\n\\n**Python 3**\\n```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minDistance(self, A, k):\\n        A.sort()\\n        \\n        @lru_cache(None)\\n        def cost(lo, hi):\\n            return sum(abs(A[i] - A[(lo + hi) // 2]) for i in range(lo, hi))\\n        \\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == 0: return 0\\n            if k == 0: return float(\"inf\")\\n            return min(dp(n - i, k - 1) + cost(n - i, n) for i in range(1, n + 1))\\n                \\n        return dp(len(A), k)\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        \\n        int n = A.size();\\n        int cost[100][100] = {};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                for (int k = i; k <= j; k++) {\\n                    cost[i][j] += abs(A[k] - A[(i + j + 1) / 2]);\\n                }\\n            }\\n        }\\n        \\n        int dp[101] = {};\\n        for (int j = 0; j <= K; j++) {\\n            for (int i = n; i >= 0; i--) {\\n                if (i == 0) {\\n                    dp[i] = 0;\\n                } else if (j == 0) {\\n                    dp[i] = 1e9;\\n                } else {\\n                    dp[i] = 1e9;\\n                    for (int k = 1; k <= i; k++) {\\n                        dp[i] = min(dp[i], cost[i - k][i - 1] + dp[i - k]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def minDistance(self, A, k):\\n        A.sort()\\n        \\n        @lru_cache(None)\\n        def cost(lo, hi):\\n            return sum(abs(A[i] - A[(lo + hi) // 2]) for i in range(lo, hi))\\n        \\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == 0: return 0\\n            if k == 0: return float(\"inf\")\\n            return min(dp(n - i, k - 1) + cost(n - i, n) for i in range(1, n + 1))\\n                \\n        return dp(len(A), k)\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        \\n        int n = A.size();\\n        int cost[100][100] = {};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                for (int k = i; k <= j; k++) {\\n                    cost[i][j] += abs(A[k] - A[(i + j + 1) / 2]);\\n                }\\n            }\\n        }\\n        \\n        int dp[101] = {};\\n        for (int j = 0; j <= K; j++) {\\n            for (int i = n; i >= 0; i--) {\\n                if (i == 0) {\\n                    dp[i] = 0;\\n                } else if (j == 0) {\\n                    dp[i] = 1e9;\\n                } else {\\n                    dp[i] = 1e9;\\n                    for (int k = 1; k <= i; k++) {\\n                        dp[i] = min(dp[i], cost[i - k][i - 1] + dp[i - k]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687502,
                "title": "java-simple-dp",
                "content": "1, dp[i][j] rep min cost to put i mail boxes to first j houeses, ending j - 1;\\n2, some default values:\\n\\tdp[i][j] where j <= i  should be 0, default value;\\n3, greedy, to make sure every mailbox is at least for 1 houses.\\n4, another greedy, best way to put mailbox at median or btw medians. see getCost method\\n```\\nclass Solution {\\n    public int minDistance(int[] hs, int k) {\\n        Arrays.sort(hs);\\n        int n = hs.length, dp[][] = new int[k + 1][n + 1]; \\n        for (int i = 1; i <= k; i++) {\\n            for (int j = i + 1; j <= n; j++) {  \\n                if (i == 1) {\\n                    dp[i][j] = getCost(hs, 0, j - 1);\\n                    continue;\\n                }\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int l = i - 1; l < j; l++) {  // when there is only one mailbox, just calculate first j;\\n                    dp[i][j] = Math.min(dp[i][j], getCost(hs, l, j - 1) + dp[i - 1][l]);\\n                }\\n            }\\n        }\\n        return dp[k][n];\\n    }\\n    \\n    private int getCost(int[] hs, int l, int r) {\\n        int res = 0;   // best to put the mailbox in median;\\n        while (l < r) res += hs[r--] - hs[l++];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] hs, int k) {\\n        Arrays.sort(hs);\\n        int n = hs.length, dp[][] = new int[k + 1][n + 1]; \\n        for (int i = 1; i <= k; i++) {\\n            for (int j = i + 1; j <= n; j++) {  \\n                if (i == 1) {\\n                    dp[i][j] = getCost(hs, 0, j - 1);\\n                    continue;\\n                }\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int l = i - 1; l < j; l++) {  // when there is only one mailbox, just calculate first j;\\n                    dp[i][j] = Math.min(dp[i][j], getCost(hs, l, j - 1) + dp[i - 1][l]);\\n                }\\n            }\\n        }\\n        return dp[k][n];\\n    }\\n    \\n    private int getCost(int[] hs, int l, int r) {\\n        int res = 0;   // best to put the mailbox in median;\\n        while (l < r) res += hs[r--] - hs[l++];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061275,
                "title": "python-3-7-lines-two-ptr-recursion-w-brief-explanation-t-m-100-54",
                "content": "Here\\'s the plan:\\nFor a given interval `interval`, we \"divide and conquer\" until we encounter either one of these base cases:\\n1. `k = 1`: If `len(interval)` is odd, we must place the box at the middle house. If `len(interval)` is even, we may place it anywhere at either of the two middle houses. The total distance and then be computed for that box and the houses in`interval`.\\n2. `len(interval) == k = 1`: Each house may have its own mailbox so the sum is zero. (Note`right - k + 2`in the code.) There\\'s no need to parse up such an interval once its sum is zero.\\n\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def dp(left, right, k):\\n            if k == 1:                                          # <-- 1.\\n                mid = houses[(left+right) // 2]\\n                return sum(abs(houses[i] - mid) for i in range(left, right + 1))\\n\\n            return min(dp(left, i, 1) + dp(i+1, right, k - 1) \\n                       for i in range(left, right - k + 2))     # <-- 2.\\n\\n        return dp(0, len(houses)-1, k)\\n```\\n[https://leetcode.com/problems/allocate-mailboxes/submissions/879441443/?envType=study-plan&id=dynamic-programming-iii](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2 * k) and space complexity is *O*(*N*^2 * k), because of the cache.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def dp(left, right, k):\\n            if k == 1:                                          # <-- 1.\\n                mid = houses[(left+right) // 2]\\n                return sum(abs(houses[i] - mid) for i in range(left, right + 1))\\n\\n            return min(dp(left, i, 1) + dp(i+1, right, k - 1) \\n                       for i in range(left, right - k + 2))     # <-- 2.\\n\\n        return dp(0, len(houses)-1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214831,
                "title": "java-o-1-n-space-o-knn-time-dp",
                "content": "Suppose we only place 1 mailbox and know the optimal distance, \\nthen when we add an extra mailbox at the end at index `i`, the distance will be increased by `houses[i]-houses[i/2]`.\\nHence, our base caes is `dp[i]=dp[i-1]+houses[i]-houses[i/2]`, for `i=1 to n-1`.\\n\\nI saw most other people have a separate 2D or 1D array for the cost (distance), but it is not needed.\\nWe can calculate it on the fly in O(1) space & time for any house between `i` and `j` indexes.\\n> If you find it hard to conceptualize this, see the drawing in the bottom\\n\\n\\n\\nso, we can write the following **non-optimized** code: \\n\\n```Java\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[] dp = new int[n];\\n        for (int i = 1; i < n; i++){ // know optimal dist for i-1, then for i, we add houses[i] - houses[i/2]\\n            dp[i]=dp[i-1]+houses[i]-houses[i/2];\\n        }\\n        for (int i = 0; i < k-1; i++){\\n            int[] next = new int[n];\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < n; j++){\\n                int sum = 0;\\n                for (int m = j; m >= 0; m--){\\n                    sum += houses[(m+j+1)>>1]-houses[m]; // likewise, adding to the front needs the +1 to account for the truncation.\\n                    next[j] = Math.min(next[j], (m==0?0:dp[m-1])+sum);\\n                }\\n            }\\n            dp=next;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\nNow, did you see that? I certainly didn\\'t when I was first writing it. \\nbut upon reviewing, I notice something stupid. \\nsince our `dp[]` equation only relies on previous numbers, why don\\'t we update it from the end to the start? \\nThat way, there is no need for `next[]`  dp array. Right?\\n\\n**Time Complexity : O(KNN) as we have 3 for-loop.**\\n**Space Complexity: O(1*N) as we have 1 DP array.**\\n\\n```Java\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[] dp = new int[n];\\n        for (int i = 1; i < n; i++){\\n            dp[i]=dp[i-1]+houses[i]-houses[i/2];\\n        }\\n        for (int i = 0; i < k-1; i++){\\n            for (int j = n-1; j >= 0; j--){\\n                int sum = 0;\\n                for (int m = j; m >= 0; m--){\\n                    sum += houses[(m+j+1)>>1]-houses[m];\\n                    dp[j] = Math.min(dp[j], (m==0?0:dp[m-1])+sum);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\\n#### Explanation\\nSome may find it hard to conceptualize the idea for the base case above, so I drew this:\\nYellow house was added, we can indeed see an increase of the red segment, \\nand by comparing to the state before the yellow house was added (the 3 blue lines on the top),\\nwe can see that the 3 blue lines on the bottom (after yellow house was added) matches with it and thus \\nresults in an increase in red segment. In general, this trend holds, so we only have to adjust the median node accordingly.\\n![image](https://assets.leetcode.com/users/images/1449cada-bfc1-4122-9935-5700a762c5fa_1656532959.9482968.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[] dp = new int[n];\\n        for (int i = 1; i < n; i++){ // know optimal dist for i-1, then for i, we add houses[i] - houses[i/2]\\n            dp[i]=dp[i-1]+houses[i]-houses[i/2];\\n        }\\n        for (int i = 0; i < k-1; i++){\\n            int[] next = new int[n];\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < n; j++){\\n                int sum = 0;\\n                for (int m = j; m >= 0; m--){\\n                    sum += houses[(m+j+1)>>1]-houses[m]; // likewise, adding to the front needs the +1 to account for the truncation.\\n                    next[j] = Math.min(next[j], (m==0?0:dp[m-1])+sum);\\n                }\\n            }\\n            dp=next;\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[] dp = new int[n];\\n        for (int i = 1; i < n; i++){\\n            dp[i]=dp[i-1]+houses[i]-houses[i/2];\\n        }\\n        for (int i = 0; i < k-1; i++){\\n            for (int j = n-1; j >= 0; j--){\\n                int sum = 0;\\n                for (int m = j; m >= 0; m--){\\n                    sum += houses[(m+j+1)>>1]-houses[m];\\n                    dp[j] = Math.min(dp[j], (m==0?0:dp[m-1])+sum);\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020526,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        init(houses);\\n        auto dp = vector(n+1, vector(k+1, 10000000));\\n        dp[0] = vector(k+1, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=1;j<=k;j++){\\n                for(int u=0;u<=i;u++){\\n                    dp[i+1][j] = min(dp[i+1][j], vv[u][i] + dp[u][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n    \\n    void init(vector<int>& houses){\\n        sort(houses.begin(), houses.end());\\n        n = houses.size();\\n        vv = vector(n, vector(n, 0));\\n        for(int len = 2; len <= n; len++){\\n            for(int i=0;i+len-1<n;i++){\\n                int j = i+len-1;\\n                vv[i][j] = houses[j] - houses[i] + vv[i+1][j-1];\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> vv; // vv[i][j] is the min sum distance of house [i, j] where there is one mailbox \\n    int n;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        init(houses);\\n        auto dp = vector(n+1, vector(k+1, 10000000));\\n        dp[0] = vector(k+1, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=1;j<=k;j++){\\n                for(int u=0;u<=i;u++){\\n                    dp[i+1][j] = min(dp[i+1][j], vv[u][i] + dp[u][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1003638,
                "title": "python-3-top-down-10-lines",
                "content": "```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        if k==len(houses): return 0\\n        houses.sort();     \\n        prefix=[0]\\n        for i,x in enumerate(houses):\\n            prefix.append(prefix[i]+x)\\n        @functools.lru_cache(None)\\n        def dfs(i,j,k):\\n            if k==1: return (prefix[j+1]-prefix[(i+j+1)//2])-(prefix[(i+j)//2+1]-prefix[i])\\n            return min([dfs(i,m,1)+dfs(m+1,j,k-1) for m in range(i,j+1)]+[float(\\'inf\\')])\\n        return dfs(0,len(houses)-1,k)",
                "solutionTags": [],
                "code": "```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        if k==len(houses): return 0\\n        houses.sort();     \\n        prefix=[0]\\n        for i,x in enumerate(houses):\\n            prefix.append(prefix[i]+x)\\n        @functools.lru_cache(None)\\n        def dfs(i,j,k):\\n            if k==1: return (prefix[j+1]-prefix[(i+j+1)//2])-(prefix[(i+j)//2+1]-prefix[i])\\n            return min([dfs(i,m,1)+dfs(m+1,j,k-1) for m in range(i,j+1)]+[float(\\'inf\\')])\\n        return dfs(0,len(houses)-1,k)",
                "codeTag": "Python3"
            },
            {
                "id": 720746,
                "title": "c-top-down-dp-recursion-memoization-brute-force-approach-using-median",
                "content": "The problem is quite similar to any DP **partioning** problem that we have.\\nWe can try to put the mailboxes at all the positions and try to compute the minimum distance. But even we memoize this approach we would still get a TLE.\\n\\nA better approach would be to place the mailboxes on the median of the houses. Since, a median is guranteed to give us the minimum distance between the houses.\\n\\nThe commented code is for the brute force approach.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int cost[101][101];\\n    \\n    /* Brute force approach\\n    int distance(vector<int>& houses, int i, int j, int place) {\\n        if (dist_dp[i][j][place] != -1) return dist_dp[i][j][place];\\n        int d = 0;\\n        for (int idx = i; idx <= j; idx++) {\\n            d += abs(place - houses[idx]);\\n        }\\n        return dist_dp[i][j][place] = d;\\n    }\\n    */\\n    \\n    int ff(vector<int>& houses, int k, int i) {\\n        \\n        if (i == houses.size() && k == 0) return 0;\\n        if (i == houses.size() || k == 0) return INT_MAX;\\n        \\n        int res = INT_MAX;\\n        \\n        if (dp[i][k] != -1) return dp[i][k];\\n        \\n        for (int idx = i; idx < houses.size(); idx++) {\\n            \\n            /* Median Approach */\\n            if (cost[i][idx] == -1) {\\n                cost[i][idx] = 0;\\n                for (int j=i; j <= idx; j++) \\n                    cost[i][idx] += abs(houses[(i + idx) / 2] - houses[j]);\\n            }\\n            \\n            /* Brute force approach\\n            int dist = INT_MAX;\\n            for (int place = houses[i]; place <= houses[idx]; place++) {\\n                dist = min(dist, distance(houses, i, idx, place));\\n            }\\n            */\\n            \\n            int ans = ff(houses, k - 1, idx + 1);\\n            if (ans != INT_MAX)\\n                res = min(res, cost[i][idx] + ans);\\n        }\\n        \\n        return dp[i][k] = res;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        if (k >= houses.size()) return 0;\\n        memset(dp, -1, sizeof dp);\\n        memset(cost, -1, sizeof cost);\\n        sort(houses.begin(), houses.end());\\n        return ff(houses, k, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int cost[101][101];\\n    \\n    /* Brute force approach\\n    int distance(vector<int>& houses, int i, int j, int place) {\\n        if (dist_dp[i][j][place] != -1) return dist_dp[i][j][place];\\n        int d = 0;\\n        for (int idx = i; idx <= j; idx++) {\\n            d += abs(place - houses[idx]);\\n        }\\n        return dist_dp[i][j][place] = d;\\n    }\\n    */\\n    \\n    int ff(vector<int>& houses, int k, int i) {\\n        \\n        if (i == houses.size() && k == 0) return 0;\\n        if (i == houses.size() || k == 0) return INT_MAX;\\n        \\n        int res = INT_MAX;\\n        \\n        if (dp[i][k] != -1) return dp[i][k];\\n        \\n        for (int idx = i; idx < houses.size(); idx++) {\\n            \\n            /* Median Approach */\\n            if (cost[i][idx] == -1) {\\n                cost[i][idx] = 0;\\n                for (int j=i; j <= idx; j++) \\n                    cost[i][idx] += abs(houses[(i + idx) / 2] - houses[j]);\\n            }\\n            \\n            /* Brute force approach\\n            int dist = INT_MAX;\\n            for (int place = houses[i]; place <= houses[idx]; place++) {\\n                dist = min(dist, distance(houses, i, idx, place));\\n            }\\n            */\\n            \\n            int ans = ff(houses, k - 1, idx + 1);\\n            if (ans != INT_MAX)\\n                res = min(res, cost[i][idx] + ans);\\n        }\\n        \\n        return dp[i][k] = res;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        if (k >= houses.size()) return 0;\\n        memset(dp, -1, sizeof dp);\\n        memset(cost, -1, sizeof cost);\\n        sort(houses.begin(), houses.end());\\n        return ff(houses, k, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700737,
                "title": "top-down-dp-java",
                "content": "import java.util.Arrays;\\n\\nclass Solution {\\n\\n    int size;\\n    int inf=1000000;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n\\n        int[][] dp=new int[houses.length+1][k+1];\\n        for (int i=0;i<dp.length;i++){\\n            int[] temp=new int[k+1];\\n            Arrays.fill(temp,-1);\\n            dp[i]=temp;\\n        }\\n        return  helper(houses,0,k,dp);\\n\\n\\n\\n    }\\n    public int helper(int[] house , int pos,int k,int[][] dp){\\n        if (pos==house.length || k==0){\\n            if (k==0 && pos==house.length ){\\n                return 0;\\n            }\\n            return inf;\\n\\n        }\\n        if (dp[pos][k]!=-1){\\n            return dp[pos][k];\\n        }\\n        int res=inf;\\n\\n        for (int i=pos;i<house.length;i++){\\n            int mid=house[(pos+i)/2];\\n            int cost=0;\\n\\n            for (int j=pos;j<=i;j++){\\n                cost+=Math.abs(mid-house[j]);\\n            }\\n            res=Math.min(res,helper(house,i+1,k-1,dp)+cost);\\n        }\\n        return dp[pos][k]=res;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int size;\\n    int inf=1000000;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n\\n        int[][] dp=new int[houses.length+1][k+1];\\n        for (int i=0;i<dp.length;i++){\\n            int[] temp=new int[k+1];\\n            Arrays.fill(temp,-1);\\n            dp[i]=temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 685370,
                "title": "java-dp-with-explanation",
                "content": "First, it is neccessary to understand that each mailbox has a leftmost and rightmost house of which it is the closest mailbox to. Every house in between will also use this mailbox. With this information, we can see that the problem is asking to divide the sorted sequence of houses into k subarrays (each subarray contains 1 mailbox), and minimize the total cost, with each subarray having a specific cost, which can be solved with dynamic programming in O(n^2) time.\\n\\nSo now we just need to calculate the total distance for each possible subarray.\\n\\nThe distance for a single subarray can be found in O(nk) time with a complete search, but since there are n^2 subarrays, the total time complexity would be O(n^3k) which is too slow. It turns out that the optimal location for the mailbox will always be the median house, or in the case of an even number of houses it could be any point between the two middle houses. To understand why, it helps to break the problem down. If you have only two houses, with a mailbox somewhere between them, its easy to see that the total distance will always be the distance between the two houses. If there are more than two houses, we can look at the leftmost and rightmost houses, knowing that the mailbox is somewhere between them, and find that the total distance is the distance between these two houses plus the total distance for the rest of the houses. Therefore if the array of houses is length N, the total distance when adding a single mailbox will be the sum of arr[N - 1 - i]-arr[i] for each i such that i <= N - 1 - i.\\n\\nThe total complexity of this solution is O(n^3)\\n\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] dist = new int[houses.length][houses.length];\\n        for (int i = 0; i < houses.length; i++) {\\n            for (int j = i; j < houses.length; j++) {\\n                dist[i][j] = dist(houses, i, j);\\n            }\\n        }\\n        int[][] dp = new int[houses.length][k + 1];\\n        for (int i = 0; i < houses.length; i++) {\\n            for (int j = 0; j <= k; j++) {\\n                dp[i][j] = 100_000_000;\\n            }\\n            dp[i][1] = dist[0][i];\\n            for (int j = i - 1; j >= 0; j--) {\\n                for (int p = 1; p <= k; p++) {\\n                    dp[i][p] = Math.min(dp[i][p], dp[j][p - 1] + dist[j + 1][i]);\\n                }\\n            }\\n        }\\n        return dp[houses.length - 1][k];\\n    }\\n    public int dist(int[] houses, int left, int right) {\\n        int dist = 0;\\n        for (int i = 0; left + i <= right - i; i++) {\\n            dist += houses[right - i] - houses[left + i];\\n        }\\n        return dist;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] dist = new int[houses.length][houses.length];\\n        for (int i = 0; i < houses.length; i++) {\\n            for (int j = i; j < houses.length; j++) {\\n                dist[i][j] = dist(houses, i, j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2348951,
                "title": "c-dp-make-groups",
                "content": "* **RunTime -> 178ms**\\n \\n* Reference -> [@votrubac](https://leetcode.com/problems/allocate-mailboxes/discuss/685661/C%2B%2B-Neighborhoods-12-ms)\\n\\n\\n* This solution is not the most optimal but it may be easy to understand.\\n\\n* Starting from `pos` ,we expand out group upto `j`. `[pos , pos + 1 , ......... , j]` -> asssign whole group a mailbox.\\n\\n* Then start new group from `j + 1`.\\n\\n* If we encounter a path where we finished seeing all houses but some mailboxes remain, we return a large number to ignore that path in our calculations.\\n\\n* Cost Calucation part can be further optimised with prefix and suffix arrays.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101] ;\\n    int solve(vector<int>&houses , int pos , int k){\\n        if(k < 0) return 1e9 ;\\n        if(pos >= houses.size()) return k ? 1e9 : 0 ; \\n        if(dp[pos][k] != -1) return dp[pos][k] ;\\n        \\n        //at current position pos, spread the group from (pos upto j) and allot this whole group 1 mailbox.\\n        //start new neigbour at j + 1\\n        \\n        int ans = INT_MAX ;\\n        for(int j = pos ; j < houses.size() ; ++j ){\\n            int middle = (pos + j) / 2 , cost = 0 ;\\n            //cost calculation\\n            for(int i = pos ; i <= j ; ++i ) cost += abs(houses[middle] - houses[i]);\\n            \\n            ans = min(ans,cost + solve(houses,j + 1, k - 1)) ;\\n        }\\n        return dp[pos][k] = ans ;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(begin(houses),end(houses)) ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        \\n        return solve(houses,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101] ;\\n    int solve(vector<int>&houses , int pos , int k){\\n        if(k < 0) return 1e9 ;\\n        if(pos >= houses.size()) return k ? 1e9 : 0 ; \\n        if(dp[pos][k] != -1) return dp[pos][k] ;\\n        \\n        //at current position pos, spread the group from (pos upto j) and allot this whole group 1 mailbox.\\n        //start new neigbour at j + 1\\n        \\n        int ans = INT_MAX ;\\n        for(int j = pos ; j < houses.size() ; ++j ){\\n            int middle = (pos + j) / 2 , cost = 0 ;\\n            //cost calculation\\n            for(int i = pos ; i <= j ; ++i ) cost += abs(houses[middle] - houses[i]);\\n            \\n            ans = min(ans,cost + solve(houses,j + 1, k - 1)) ;\\n        }\\n        return dp[pos][k] = ans ;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(begin(houses),end(houses)) ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        \\n        return solve(houses,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138208,
                "title": "c-memoization-time-o-k-n-2-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int pre[101],dp[101][101];\\n    int retsum(vector<int> &a,int i,int n,int s){\\n        \\n        /* \\n            consider array in this form:[a,b,c,median,x,y,z]\\n    \\n            here we are calculating cost from a to median\\n            sum=(median-a)+(median-b)+(median-c)\\n            sum=(3*median)-(a+b+c)\\n            sum=((number_of_element ahead of it)*median)-(a+b+c)\\n            \\n            (a+b+c)-> can be calculated in O(1) by using prefix sum\\n        */\\n        int sum=0;\\n        int median=(i+n)/2;\\n        int tot=(median-i);\\n        tot=a[median]*tot;\\n        sum=0;\\n        if(median-1>=0){\\n            sum=pre[median-1];\\n        }\\n        if(i-1>=0){\\n           sum-=pre[i-1];\\n        }\\n        tot-=sum;\\n        int ans=tot;\\n        \\n         /* \\n         \\n            here we are calculating cost from median to z\\n            sum=(x-median)+(y-median)+(z-median)\\n            sum=(x+y+z)-(3*median)\\n            sum=(x+y+z)((number_of_elements after median)*median)\\n            \\n            (x+y+z)-> can be calculated in O(1) by using prefix sum\\n        */\\n        \\n        \\n        tot=n-median;\\n        tot=tot*a[median];\\n        sum=pre[n];\\n        if(median>=0)\\n            sum-=pre[median];\\n        sum-=tot;\\n        ans+=sum;\\n        return ans;\\n    }\\n    int sol(vector<int> &arr,int i,int n,int k){\\n        if(dp[i][k]!=-1)    return dp[i][k];\\n        if(i==n){\\n            return dp[i][k]=0;\\n        }\\n        if(k==1){\\n            return dp[i][k]=retsum(arr,i,n-1,n);\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int i1=i;i1<n;i1++){\\n            int s1=sol(arr,i1+1,n,k-1);\\n            ans=min(ans,retsum(arr,i,i1,n)+s1);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(),houses.end());\\n        int n=houses.size();\\n        \\n        // prefix sum\\n        pre[0]=houses[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=houses[i];\\n            pre[i]+=pre[i-1];\\n        }\\n        memset(dp,-1,sizeof dp);\\n        return sol(houses,0,n,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pre[101],dp[101][101];\\n    int retsum(vector<int> &a,int i,int n,int s){\\n        \\n        /* \\n            consider array in this form:[a,b,c,median,x,y,z]\\n    \\n            here we are calculating cost from a to median\\n            sum=(median-a)+(median-b)+(median-c)\\n            sum=(3*median)-(a+b+c)\\n            sum=((number_of_element ahead of it)*median)-(a+b+c)\\n            \\n            (a+b+c)-> can be calculated in O(1) by using prefix sum\\n        */\\n        int sum=0;\\n        int median=(i+n)/2;\\n        int tot=(median-i);\\n        tot=a[median]*tot;\\n        sum=0;\\n        if(median-1>=0){\\n            sum=pre[median-1];\\n        }\\n        if(i-1>=0){\\n           sum-=pre[i-1];\\n        }\\n        tot-=sum;\\n        int ans=tot;\\n        \\n         /* \\n         \\n            here we are calculating cost from median to z\\n            sum=(x-median)+(y-median)+(z-median)\\n            sum=(x+y+z)-(3*median)\\n            sum=(x+y+z)((number_of_elements after median)*median)\\n            \\n            (x+y+z)-> can be calculated in O(1) by using prefix sum\\n        */\\n        \\n        \\n        tot=n-median;\\n        tot=tot*a[median];\\n        sum=pre[n];\\n        if(median>=0)\\n            sum-=pre[median];\\n        sum-=tot;\\n        ans+=sum;\\n        return ans;\\n    }\\n    int sol(vector<int> &arr,int i,int n,int k){\\n        if(dp[i][k]!=-1)    return dp[i][k];\\n        if(i==n){\\n            return dp[i][k]=0;\\n        }\\n        if(k==1){\\n            return dp[i][k]=retsum(arr,i,n-1,n);\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int i1=i;i1<n;i1++){\\n            int s1=sol(arr,i1+1,n,k-1);\\n            ans=min(ans,retsum(arr,i,i1,n)+s1);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(),houses.end());\\n        int n=houses.size();\\n        \\n        // prefix sum\\n        pre[0]=houses[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=houses[i];\\n            pre[i]+=pre[i-1];\\n        }\\n        memset(dp,-1,sizeof dp);\\n        return sol(houses,0,n,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906329,
                "title": "dp-with-explanation",
                "content": "Before we place multiple mailbox, let\\'s consider the base cases when there are 0 and 1 mailbox.\\n\\nWhen k is 0, it means there is no mailbox needed. The overall distance is zero.\\n\\nWhen k is 1, where is the bast place to set up the mailbox? The answer is the median among all the house position. Why? Let\\'s look at this arrangement.\\n\\nIf there are odd number of houses, the best place is the `4th` place to set up the mailbox.\\n```\\n1 2 3 4 5 6 7\\n-------------\\na a a x b b b\\n```\\nThe overall distance will be `left + right`, where \\n`left` is the total distance to `x` from left houses. ( `(4-1)+(4-2)+(4-3)` )\\n`right` is the total distance to `x` from right houses. ( `(5-4)+(6-4)+(7-4)` )\\n\\nIf we move x to the left by 1 unit to `3rd`, the distance becomes `left - 3 + right + 4`. \\n```\\n1 2 3 4 5 6 7\\n-------------\\na a x b b b b\\n```\\n\\nIf we move x to the right by 1 unit to `5th`, the distance becomes `left +4 + right - 3`.\\n```\\n1 2 3 4 5 6 7\\n-------------\\na a a X b b b\\n```\\n\\nSo there is no better place to set up the mailbox except the median for odd number of houses.\\n\\nNow, let\\'s look the case when the number of houses is even.\\n```\\n1 2 3 4 5 6 7 8\\n---------------\\na a a x b b b b\\n\\n1 2 3 4 5 6 7 8\\n---------------\\na a a a x b b b\\n```\\nFor even number of houses, the median can be any place inbetween `4th` and `5th`, both inclusive.\\n\\nIf we choose `4th`, the distance is `left+right`, where \\n`left` is the total distance to `x` from left houses. ( `(4-1)+(4-2)+(4-3)` )\\n`right` is the total distance to `x` from right houses. ( `(5-4)+(6-4)+(7-4)+(8-4)` )\\n\\nIf we choose `5th`, the distance is `left+right`, where \\n`left` is the total distance to `x` from left houses. ( `(5-1)+(4-1)+(4-2)+(4-3)` )\\n`right` is the total distance to `x` from right houses. ( `(6-5)+(7-5)+(8-5)` )\\n\\nThe distances are the same whether we place the mailbox on `4th` or `5th`. Using the same way as in odd number case, we can see when we shift the mailbox to the left of `4th` or to the right of `5th`, the overall distance will increase. \\n\\nAfter we establish the rule for 1 mailbox case, now back to the problem. How can we place multiple mailboxs when the number is 2 ore more?\\n\\nSuppose we have N houses, and 1 mailbox to set up. We know from above that the best place is the median among the houses.\\nNow, we want to add one more mailbox and the overall distance needs to be the minimal. \\n\\nWe don\\'t know the best places yet but we do know the final arrangement will be something like this\\n```\\n1................N\\n|  1      |   2  | \\n```\\nThe intuitive way is to \\n1. Have 3 loops to look for two mailbox places (`O(N^2)`).\\n2. For every possible mailbox places,  calcuate the miminal distance for every house (`O(N)`).\\nThat would already be `O(N^3)` for just two mailboxes. For more mailboxes, the time complexity will grow much bigger.\\n\\nLet\\'s look at this problem the other way. \\n```\\n1.........i.......N\\n|  1      |   2   | \\n```\\nFor the overall distance to be the minimum, we need to find a place `i` such that `dist1 + dist2` is the minimum, where\\n\\n`dist1`: the overall distance for the first mailbox in the houses `1..i`.\\n`dist2`: the overall distance for the second mailbox in the houses `i+1..N`.\\n\\nSo, `dist = min { dist[1..i] + dist[i+1..N] }` for `i` in `1..N`\\n\\nNow it should be much clearer to you it is be solved using dynamic programming.\\n\\nDefine DP state:\\n\\n`dp[i][N]`: The miminum distance of setting up `N` mailboxes in `i` houses.\\n\\nRelation:\\n`dp[i][N] = min { dp[j][N-1] + dist[i+1][N] }`, where\\n`j`: `1~i`, remembe we have only `i` houses, therefore `j` cannot be greater than `i`.\\n\\nAnd for DP problem, we need the sub(smaller) problems to be solved before bigger ones,\\n\\n`N` will be 1,2,3... to the maximum number of mailboxes.\\n`i` will be 1,2,3... to the maximum number of houses.\\n\\nCases:\\n`N = 0`, we already know from the above, the distance is 0.\\n`N = 1`, we know we can get it by adding the distance from the median to all houses.\\n`N > 1`, the above relation will help use to find the minimal distance.  \\n\\nAtte\\n\\n```\\nclass Solution {\\npublic:\\n    int dist[101][101] = {0};\\n    \\n    int minDistance(vector<int>& houses, int K) {\\n        int n = houses.size();\\n        sort(begin(houses), end(houses));\\n        \\n        // Make housese 1-bases. \\n        // The 0 ~ n-1 index will become 1 ~ n.\\n        houses.insert(houses.begin(), -1);\\n        \\n        for(int i=1; i<=n; i++) {\\n            for(int j=i; j<=n; j++) {\\n                // dist[i][j]: the minimum distance of placing a mailbox in houses[i..j]\\n                int m = houses[ (i+j)/2 ];\\n                for(int k=i; k<=j; k++) {\\n                    dist[i][j] += abs( m - houses[k] );\\n                }\\n            }\\n        }\\n        \\n        // dp state:\\n        //\\n        // dp[i][k]: minimum distance when allocating k mailboxes in i houses\\n        //\\n        // relation:\\n        //\\n        // dp[i][k] = dp[j][k-1] + dist[j+1][i]\\n        //\\n        //  1.........j......i\\n        /// |  k-1    |   k  | \\n        vector<vector<int>> dp(n+1, vector<int>(K+1, n*n));\\n     \\n\\t\\t// base cases:\\n        // 0 mailbox: dp[i][0] will be 0 (no mailbox is needed)\\n        // 1 mailbox: dp[i][1] will be equal to dist[1][i], meaning placing an mailbox between house 1..i\\n        for(int i=1; i<=n; i++) {\\n            dp[i][0] = 0;\\n            dp[i][1] = dist[1][i];\\n        }\\n        \\n        for(int i=1; i<=n; i++) {\\n\\t\\t\\t// Why we need k to start from 2?\\n\\t\\t\\t// 1.........i.......n\\n\\t\\t\\t// |  X      |   1   | \\n\\t\\t\\t// If k is 1, we will have dp[j][0], which is invalid because we cannot skip the houses 1..i to set up 1 mailbox.\\n            for(int k=2; k<=K; k++) {\\n                for(int j=1; j+1<=i; j++) {\\n                    dp[i][k] = min(dp[i][k], dp[j][k-1] + dist[j+1][i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][K];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1 2 3 4 5 6 7\\n-------------\\na a a x b b b\\n```\n```\\n1 2 3 4 5 6 7\\n-------------\\na a x b b b b\\n```\n```\\n1 2 3 4 5 6 7\\n-------------\\na a a X b b b\\n```\n```\\n1 2 3 4 5 6 7 8\\n---------------\\na a a x b b b b\\n\\n1 2 3 4 5 6 7 8\\n---------------\\na a a a x b b b\\n```\n```\\n1................N\\n|  1      |   2  | \\n```\n```\\n1.........i.......N\\n|  1      |   2   | \\n```\n```\\nclass Solution {\\npublic:\\n    int dist[101][101] = {0};\\n    \\n    int minDistance(vector<int>& houses, int K) {\\n        int n = houses.size();\\n        sort(begin(houses), end(houses));\\n        \\n        // Make housese 1-bases. \\n        // The 0 ~ n-1 index will become 1 ~ n.\\n        houses.insert(houses.begin(), -1);\\n        \\n        for(int i=1; i<=n; i++) {\\n            for(int j=i; j<=n; j++) {\\n                // dist[i][j]: the minimum distance of placing a mailbox in houses[i..j]\\n                int m = houses[ (i+j)/2 ];\\n                for(int k=i; k<=j; k++) {\\n                    dist[i][j] += abs( m - houses[k] );\\n                }\\n            }\\n        }\\n        \\n        // dp state:\\n        //\\n        // dp[i][k]: minimum distance when allocating k mailboxes in i houses\\n        //\\n        // relation:\\n        //\\n        // dp[i][k] = dp[j][k-1] + dist[j+1][i]\\n        //\\n        //  1.........j......i\\n        /// |  k-1    |   k  | \\n        vector<vector<int>> dp(n+1, vector<int>(K+1, n*n));\\n     \\n\\t\\t// base cases:\\n        // 0 mailbox: dp[i][0] will be 0 (no mailbox is needed)\\n        // 1 mailbox: dp[i][1] will be equal to dist[1][i], meaning placing an mailbox between house 1..i\\n        for(int i=1; i<=n; i++) {\\n            dp[i][0] = 0;\\n            dp[i][1] = dist[1][i];\\n        }\\n        \\n        for(int i=1; i<=n; i++) {\\n\\t\\t\\t// Why we need k to start from 2?\\n\\t\\t\\t// 1.........i.......n\\n\\t\\t\\t// |  X      |   1   | \\n\\t\\t\\t// If k is 1, we will have dp[j][0], which is invalid because we cannot skip the houses 1..i to set up 1 mailbox.\\n            for(int k=2; k<=K; k++) {\\n                for(int j=1; j+1<=i; j++) {\\n                    dp[i][k] = min(dp[i][k], dp[j][k-1] + dist[j+1][i]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][K];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603797,
                "title": "python-consistently-beats-100-it-is-much-easier-if-you-treat-it-as-another-problem",
                "content": "This problem is equivalent to:\\n1. **Divide sorted `houses` into `k` subarrays**\\n2. For each subarray, put a mailbox in the middle and calculate the total distance.\\n\\nThen we just need to check all the possible subarray divisions.\\n\\n\\n```\\nclass Solution(object):\\n    def minDistance(self, houses, k):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        l = len(houses)\\n        if k >= l:\\n            return 0\\n        \\n        houses.sort()\\n        \\n        results = {}\\n        \\n        def findResult(start, end, r):\\n            if end - start <= r:\\n                return 0\\n            if (start, end, r) in results:\\n                return results[(start, end ,r)]\\n            \\n            if r == 1: # Calculate total distance for one subarray\\n                left = start\\n                right = end - 1\\n                current_result = 0\\n                while left < right:\\n                    current_result += houses[right] - houses[left]\\n                    right -= 1\\n                    left += 1\\n            else:\\n                current_result = 2147483647\\n                for i in range(start + 1, end - r + 2):\\n                    current_result = min(current_result, findResult(start, i, 1) + findResult(i, end, r-1))\\n            \\n            results[(start, end, r)] = current_result\\n            return current_result\\n        \\n        return findResult(0, l, k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, houses, k):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        l = len(houses)\\n        if k >= l:\\n            return 0\\n        \\n        houses.sort()\\n        \\n        results = {}\\n        \\n        def findResult(start, end, r):\\n            if end - start <= r:\\n                return 0\\n            if (start, end, r) in results:\\n                return results[(start, end ,r)]\\n            \\n            if r == 1: # Calculate total distance for one subarray\\n                left = start\\n                right = end - 1\\n                current_result = 0\\n                while left < right:\\n                    current_result += houses[right] - houses[left]\\n                    right -= 1\\n                    left += 1\\n            else:\\n                current_result = 2147483647\\n                for i in range(start + 1, end - r + 2):\\n                    current_result = min(current_result, findResult(start, i, 1) + findResult(i, end, r-1))\\n            \\n            results[(start, end, r)] = current_result\\n            return current_result\\n        \\n        return findResult(0, l, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183279,
                "title": "c-recursion-memoization-median-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&h ,int k,int n,int i,vector<vector<int>>&cost)\\n    {\\n        // base case\\n        if(i == n && k == 0)\\n            return 0;\\n        if(i == n || k == 0)return 1e7;\\n        int ans = 1e7;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        for(int j = i ; j <= n-k ; j++)\\n            ans =min(ans, cost[i][j] + solve(h,k-1,n,j+1,cost));\\n        dp[i][k] = ans;\\n        return dp[i][k];\\n    }\\n    int minDistance(vector<int>& h, int k) {\\n        int n = h.size();\\n        // first store the median of houses of with k == 1 storing the mailboxes in between the \\n        // houses as the difference won\\'t change \\n        \\n        vector<vector<int>>cost(n , vector<int>(n , 0));\\n        sort(h.begin() , h.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j= i+1;j<n;j++)\\n            {\\n                int l = i;\\n                int r = j;\\n                while(r > l)\\n                {\\n                    cost[i][j] += h[r--] - h[l++];\\n                }\\n            }\\n        }\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(h,k,n,0,cost);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&h ,int k,int n,int i,vector<vector<int>>&cost)\\n    {\\n        // base case\\n        if(i == n && k == 0)\\n            return 0;\\n        if(i == n || k == 0)return 1e7;\\n        int ans = 1e7;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        for(int j = i ; j <= n-k ; j++)\\n            ans =min(ans, cost[i][j] + solve(h,k-1,n,j+1,cost));\\n        dp[i][k] = ans;\\n        return dp[i][k];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1111625,
                "title": "python3-dp-w-running-median",
                "content": "\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort() # ascending order \\n        n = len(houses)\\n        \\n        mdist = [[0]*n for _ in range(n)] # mdist[i][j] median distance of houses[i:j+1]\\n        for i in range(n):\\n            for j in range(i+1, n): \\n                mdist[i][j] = mdist[i][j-1] + houses[j] - houses[i+j >> 1]\\n        \\n        @cache\\n        def fn(n, k):\\n            \"\"\"Return min distance of allocating k mailboxes to n houses.\"\"\"\\n            if n <= k: return 0 # one mailbox for each house\\n            if k == 1: return mdist[0][n-1]\\n            ans = inf \\n            for nn in range(k-1, n): \\n                ans = min(ans, fn(nn, k-1) + mdist[nn][n-1])\\n            return ans \\n        \\n        return fn(n, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort() # ascending order \\n        n = len(houses)\\n        \\n        mdist = [[0]*n for _ in range(n)] # mdist[i][j] median distance of houses[i:j+1]\\n        for i in range(n):\\n            for j in range(i+1, n): \\n                mdist[i][j] = mdist[i][j-1] + houses[j] - houses[i+j >> 1]\\n        \\n        @cache\\n        def fn(n, k):\\n            \"\"\"Return min distance of allocating k mailboxes to n houses.\"\"\"\\n            if n <= k: return 0 # one mailbox for each house\\n            if k == 1: return mdist[0][n-1]\\n            ans = inf \\n            for nn in range(k-1, n): \\n                ans = min(ans, fn(nn, k-1) + mdist[nn][n-1])\\n            return ans \\n        \\n        return fn(n, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909599,
                "title": "java-recursive-tle-memoization-2d-bottom-up",
                "content": "```\\n- It will be difficult to find the proper placement if the location of each house is not sorted\\n\\t- So, lets first sort the input houses in ascending order\\n- If we currently have \\'x\\' number of houses and we have 1 mailbox, where should we place the box?\\n\\t- The best location is to place it at the middle house at \\'x / 2\\'\\n- If we are currently starting at index \\'i\\'\\n\\t- We have a choice of placing a mailbox in between \\'i\\' and \\'j\\'\\n\\t\\t- We can perform a prescan on the input array to find the distance of placing at mailbox in between indices \\'i\\' and \\'j\\'\\n\\t\\t- Then we can place the next mailbox starting from \\'j + 1\\'\\n\\t- We will want to find the index \\'j\\' that will give us the minimum total distance\\n```\\n```\\npublic class AllocateMailBoxesRecursiveApproach {\\n    private static final int MAX_DISTANCE = (int) Math.pow(10, 8);\\n\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] distance = getDistanceWhenPlacingMailbox(houses);\\n        return minDistance(0, k, houses, distance);\\n    }\\n\\n    private int minDistance(int start, int k, int[] houses, int[][] distance) {\\n        if (start >= houses.length) return (k == 0) ? 0 : MAX_DISTANCE;\\n        if (k == 0) return MAX_DISTANCE;\\n\\n        int minDist = MAX_DISTANCE;\\n\\n        for (int i = start; i < houses.length; i++) {\\n            minDist = Math.min(minDist, minDistance(i + 1, k - 1, houses, distance) + distance[start][i]);\\n        }\\n\\n        return minDist;\\n    }\\n\\n    private int[][] getDistanceWhenPlacingMailbox(int[] houses) {\\n        int[][] distance = new int[houses.length][houses.length];\\n\\n        for (int i = 0; i < houses.length - 1; i++) {\\n            for (int j = i + 1; j < houses.length; j++) {\\n                int location = houses[(i + j) / 2];\\n\\n                for (int k = i; k <= j; k++) {\\n                    distance[i][j] += Math.abs(location - houses[k]);\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n```\\n```\\npublic class AllocateMailBoxesMemoizationApproach {\\n    private static final int MAX_DISTANCE = (int) Math.pow(10, 8);\\n\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] distance = getDistanceWhenPlacingMailbox(houses);\\n        int[][] memo = new int[houses.length][k + 1];\\n\\n        for (int r = 0; r < memo.length; r++) {\\n            Arrays.fill(memo[r], -1);\\n        }\\n\\n        return minDistance(0, k, houses, distance, memo);\\n    }\\n\\n    private int minDistance(int start, int k, int[] houses, int[][] distance, int[][] memo) {\\n        if (start >= houses.length) return (k == 0) ? 0 : MAX_DISTANCE;\\n        if (k == 0) return MAX_DISTANCE;\\n        if (memo[start][k] != -1) return memo[start][k];\\n\\n        int minDist = MAX_DISTANCE;\\n\\n        for (int i = start; i < houses.length; i++) {\\n            minDist = Math.min(minDist, minDistance(i + 1, k - 1, houses, distance, memo) + distance[start][i]);\\n        }\\n\\n        return memo[start][k] = minDist;\\n    }\\n\\n    private int[][] getDistanceWhenPlacingMailbox(int[] houses) {\\n        int[][] distance = new int[houses.length][houses.length];\\n\\n        for (int i = 0; i < houses.length - 1; i++) {\\n            for (int j = i + 1; j < houses.length; j++) {\\n                int location = houses[(i + j) / 2];\\n\\n                for (int k = i; k <= j; k++) {\\n                    distance[i][j] += Math.abs(location - houses[k]);\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n```\\n```\\npublic class AllocateMailBoxesBottomUp2DApproach {\\n    private static final int MAX_DISTANCE = (int) Math.pow(10, 8);\\n\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] distance = getDistanceWhenPlacingMailbox(houses);\\n        int[][] minDist = new int[houses.length + 1][k + 1];\\n\\n        for (int start = houses.length; start >= 0; start--) {\\n            for (int boxes = 0; boxes <= k; boxes++) {\\n                if (start == houses.length) {\\n                    minDist[start][boxes] = (boxes == 0) ? 0 : MAX_DISTANCE;\\n                    continue;\\n                }\\n\\n                if (boxes == 0) {\\n                    minDist[start][boxes] = MAX_DISTANCE;\\n                    continue;\\n                }\\n\\n                minDist[start][boxes] = MAX_DISTANCE;\\n\\n                for (int i = start; i < houses.length; i++) {\\n                    minDist[start][boxes] = Math.min(minDist[start][boxes],\\n                            minDist[i + 1][boxes - 1] + distance[start][i]);\\n                }\\n            }\\n        }\\n\\n        return minDist[0][k];\\n    }\\n\\n    private int[][] getDistanceWhenPlacingMailbox(int[] houses) {\\n        int[][] distance = new int[houses.length][houses.length];\\n\\n        for (int i = 0; i < houses.length - 1; i++) {\\n            for (int j = i + 1; j < houses.length; j++) {\\n                int location = houses[(i + j) / 2];\\n\\n                for (int k = i; k <= j; k++) {\\n                    distance[i][j] += Math.abs(location - houses[k]);\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- It will be difficult to find the proper placement if the location of each house is not sorted\\n\\t- So, lets first sort the input houses in ascending order\\n- If we currently have \\'x\\' number of houses and we have 1 mailbox, where should we place the box?\\n\\t- The best location is to place it at the middle house at \\'x / 2\\'\\n- If we are currently starting at index \\'i\\'\\n\\t- We have a choice of placing a mailbox in between \\'i\\' and \\'j\\'\\n\\t\\t- We can perform a prescan on the input array to find the distance of placing at mailbox in between indices \\'i\\' and \\'j\\'\\n\\t\\t- Then we can place the next mailbox starting from \\'j + 1\\'\\n\\t- We will want to find the index \\'j\\' that will give us the minimum total distance\\n```\n```\\npublic class AllocateMailBoxesRecursiveApproach {\\n    private static final int MAX_DISTANCE = (int) Math.pow(10, 8);\\n\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] distance = getDistanceWhenPlacingMailbox(houses);\\n        return minDistance(0, k, houses, distance);\\n    }\\n\\n    private int minDistance(int start, int k, int[] houses, int[][] distance) {\\n        if (start >= houses.length) return (k == 0) ? 0 : MAX_DISTANCE;\\n        if (k == 0) return MAX_DISTANCE;\\n\\n        int minDist = MAX_DISTANCE;\\n\\n        for (int i = start; i < houses.length; i++) {\\n            minDist = Math.min(minDist, minDistance(i + 1, k - 1, houses, distance) + distance[start][i]);\\n        }\\n\\n        return minDist;\\n    }\\n\\n    private int[][] getDistanceWhenPlacingMailbox(int[] houses) {\\n        int[][] distance = new int[houses.length][houses.length];\\n\\n        for (int i = 0; i < houses.length - 1; i++) {\\n            for (int j = i + 1; j < houses.length; j++) {\\n                int location = houses[(i + j) / 2];\\n\\n                for (int k = i; k <= j; k++) {\\n                    distance[i][j] += Math.abs(location - houses[k]);\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n```\n```\\npublic class AllocateMailBoxesMemoizationApproach {\\n    private static final int MAX_DISTANCE = (int) Math.pow(10, 8);\\n\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] distance = getDistanceWhenPlacingMailbox(houses);\\n        int[][] memo = new int[houses.length][k + 1];\\n\\n        for (int r = 0; r < memo.length; r++) {\\n            Arrays.fill(memo[r], -1);\\n        }\\n\\n        return minDistance(0, k, houses, distance, memo);\\n    }\\n\\n    private int minDistance(int start, int k, int[] houses, int[][] distance, int[][] memo) {\\n        if (start >= houses.length) return (k == 0) ? 0 : MAX_DISTANCE;\\n        if (k == 0) return MAX_DISTANCE;\\n        if (memo[start][k] != -1) return memo[start][k];\\n\\n        int minDist = MAX_DISTANCE;\\n\\n        for (int i = start; i < houses.length; i++) {\\n            minDist = Math.min(minDist, minDistance(i + 1, k - 1, houses, distance, memo) + distance[start][i]);\\n        }\\n\\n        return memo[start][k] = minDist;\\n    }\\n\\n    private int[][] getDistanceWhenPlacingMailbox(int[] houses) {\\n        int[][] distance = new int[houses.length][houses.length];\\n\\n        for (int i = 0; i < houses.length - 1; i++) {\\n            for (int j = i + 1; j < houses.length; j++) {\\n                int location = houses[(i + j) / 2];\\n\\n                for (int k = i; k <= j; k++) {\\n                    distance[i][j] += Math.abs(location - houses[k]);\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n```\n```\\npublic class AllocateMailBoxesBottomUp2DApproach {\\n    private static final int MAX_DISTANCE = (int) Math.pow(10, 8);\\n\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int[][] distance = getDistanceWhenPlacingMailbox(houses);\\n        int[][] minDist = new int[houses.length + 1][k + 1];\\n\\n        for (int start = houses.length; start >= 0; start--) {\\n            for (int boxes = 0; boxes <= k; boxes++) {\\n                if (start == houses.length) {\\n                    minDist[start][boxes] = (boxes == 0) ? 0 : MAX_DISTANCE;\\n                    continue;\\n                }\\n\\n                if (boxes == 0) {\\n                    minDist[start][boxes] = MAX_DISTANCE;\\n                    continue;\\n                }\\n\\n                minDist[start][boxes] = MAX_DISTANCE;\\n\\n                for (int i = start; i < houses.length; i++) {\\n                    minDist[start][boxes] = Math.min(minDist[start][boxes],\\n                            minDist[i + 1][boxes - 1] + distance[start][i]);\\n                }\\n            }\\n        }\\n\\n        return minDist[0][k];\\n    }\\n\\n    private int[][] getDistanceWhenPlacingMailbox(int[] houses) {\\n        int[][] distance = new int[houses.length][houses.length];\\n\\n        for (int i = 0; i < houses.length - 1; i++) {\\n            for (int j = i + 1; j < houses.length; j++) {\\n                int location = houses[(i + j) / 2];\\n\\n                for (int k = i; k <= j; k++) {\\n                    distance[i][j] += Math.abs(location - houses[k]);\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716152,
                "title": "python-dynamic-programming-plus-binary-search-solution-without-the-insight-about-the-median",
                "content": "Here is an accepted solution where we don\\'t use the median insight and instead use binary search\\nto find the best place to put mailbox in order to cover houses in an interval:\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        # dp(i, j) = min distance if we have put j mailboxes and have assigned i houses to them\\n        # bestPutMail(z, i) = min distance for houses from z to i to the mailbox if we put the\\n        # mailbox somewhere on the road between house[z] and house[i]\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def bestPutMail(z, i):\\n            # with binary search find best the position for mailbox to cover houses from k to i\\n            def test(pos):\\n                resCur, resNext = 0, 0\\n                for x in range(z + 1, i + 1):\\n                    resCur += abs(houses[x - 1] - pos)\\n                    resNext += abs(houses[x - 1] - pos - 1)\\n                return resCur <= resNext, resCur\\n\\n            lo, hi, best = 0, houses[-1] + 1, 0\\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                t = test(mid)\\n                if t[0]:\\n                    hi = mid\\n                    best = t[1]\\n                else:\\n                    lo = mid + 1\\n            return best\\n\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if j >= i: return 0\\n            if j == 0:\\n                return 1e9 if i > 0 else 0\\n            if i == 0:\\n                return 0\\n            res = 1e9\\n            for z in range(i + 1):\\n                res = min(res, dp(z, j - 1) + bestPutMail(z, i))\\n            return res\\n\\n        return dp(len(houses), k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        # dp(i, j) = min distance if we have put j mailboxes and have assigned i houses to them\\n        # bestPutMail(z, i) = min distance for houses from z to i to the mailbox if we put the\\n        # mailbox somewhere on the road between house[z] and house[i]\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def bestPutMail(z, i):\\n            # with binary search find best the position for mailbox to cover houses from k to i\\n            def test(pos):\\n                resCur, resNext = 0, 0\\n                for x in range(z + 1, i + 1):\\n                    resCur += abs(houses[x - 1] - pos)\\n                    resNext += abs(houses[x - 1] - pos - 1)\\n                return resCur <= resNext, resCur\\n\\n            lo, hi, best = 0, houses[-1] + 1, 0\\n            while lo < hi:\\n                mid = (lo + hi) // 2\\n                t = test(mid)\\n                if t[0]:\\n                    hi = mid\\n                    best = t[1]\\n                else:\\n                    lo = mid + 1\\n            return best\\n\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if j >= i: return 0\\n            if j == 0:\\n                return 1e9 if i > 0 else 0\\n            if i == 0:\\n                return 0\\n            res = 1e9\\n            for z in range(i + 1):\\n                res = min(res, dp(z, j - 1) + bestPutMail(z, i))\\n            return res\\n\\n        return dp(len(houses), k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711391,
                "title": "c-bottom-up-dp-clean-code-commented-explanation-o-n-3-time",
                "content": "```\\n#define inf 999999999\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    int minDistance(vector<int>& houses, int K) {\\n//         time O(n * n * k)  || space O(n * k), where n is number of houses and k is number of mailboxes\\n        \\n//         Core Idea:\\n        \\n//         1. We need to find out how to group the consecutive houses and assign a mailbox to each group of houses\\n//            such that total distance between houses to the nearest mailbox shoud be minimum.\\n            \\n//         2. Let\\'s say the problem statement is, we have some n houses and we need install a mailbox at some location l such that sum of distance of houses to this location l is minimum.\\n            \\n//            We can find out l greedily.\\n           \\n//            Case 1. When the size of group is odd:\\n//                    say a gp of house locations are : [1, 5, 17, 19, 88].\\n//                    we will install mailbox at location 17, as given :\\n                       \\n//                           mailbox\\n//                             ^\\n//                             |\\n//                     [1, 5, 17, 19, 88]\\n                    \\n//                    Assigning mailbox any left or right to 17, will increase the distance by 3 and decrease by 2, which is overall increment in distance, thus 17 is the best location to install a mailbox .\\n                       \\n//           Case 2. When the group size is even:\\n//                   say a gp of house locations are : [1, 5, 17, 19].\\n//                   here we can install mailbox anywhere in range [5, 17]\\n                      \\n//                       mailbox\\n//                         ^\\n//                         |\\n//                     [1, 5, 17, 19]\\n                      \\n//                   As installing any where < 5 or > 17 would increment the total distance by 2.\\n                      \\n//         3. So we sort houses array first.\\n                      \\n//         4. Now, we assign houses[0] to hosues[i] to first mailbox, then \\n//            we assign houses[i + 1]....houses[(i + 1) +  r : (0, n - i - 2) ] to second mailbox, \\n//            and continous doing it untill all houses are covered.\\n               \\n//         5. so dp state is dp[i][j] where 0 <= i <= n - 1, 1 <= j <= k\\n//            dp[i][j] represents the min total distance of houses i to n - 1 from mailboxes, allocating j number of mailboxes\\n           \\n//         Recursive relation: \\n//            dp[i][j] = min(dis[i, i]     +  dp[i + 1][j - 1],\\n//                           dis[i, i + 1] +  dp[i + 2][j - 1],\\n//                           dis[i, i + 2] +  dp[i + 3][j - 1]....\\n//                          )\\n               \\n//            where dis[i, j] is min total dis for houses i to j from the mailbox allocated for them, \\n//            which we can find out as per discussed in point 2.\\n                      \\n        \\n        \\n        sort(houses.begin(), houses.end());\\n        int n = houses.size();\\n        if(K >= n) return 0; // if number of mailboxes >= number of houses, then ans = 0(min total dis)\\n        \\n        vector<vector<int>> dp(n, vector<int>(K + 1, inf));\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int k = K; k >= 1; k--) {\\n                 \\n                if(k >= (n - i))   // if, number of mailboxes >= number of houses, thus minTotalDis would be 0\\n                    dp[i][k] = 0;\\n                \\n                else {\\n                    \\n                    int sum = 0;\\n                    int mindis = INT_MAX;\\n                    int inc = 0;\\n                    for(int ge = i, c = i; ge <= (n - k); ge += 1) {\\n                        sum += (houses[ge] - houses[c]);\\n                        mindis = min(mindis, sum + (ge + 1 < n ? dp[ge + 1][k - 1] : 0));\\n                         \\n                        if(inc) c += 1;\\n                        inc ^= 1;\\n                    }\\n                    \\n                    dp[i][k] = mindis;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][K];\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define inf 999999999\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    int minDistance(vector<int>& houses, int K) {\\n//         time O(n * n * k)  || space O(n * k), where n is number of houses and k is number of mailboxes\\n        \\n//         Core Idea:\\n        \\n//         1. We need to find out how to group the consecutive houses and assign a mailbox to each group of houses\\n//            such that total distance between houses to the nearest mailbox shoud be minimum.\\n            \\n//         2. Let\\'s say the problem statement is, we have some n houses and we need install a mailbox at some location l such that sum of distance of houses to this location l is minimum.\\n            \\n//            We can find out l greedily.\\n           \\n//            Case 1. When the size of group is odd:\\n//                    say a gp of house locations are : [1, 5, 17, 19, 88].\\n//                    we will install mailbox at location 17, as given :\\n                       \\n//                           mailbox\\n//                             ^\\n//                             |\\n//                     [1, 5, 17, 19, 88]\\n                    \\n//                    Assigning mailbox any left or right to 17, will increase the distance by 3 and decrease by 2, which is overall increment in distance, thus 17 is the best location to install a mailbox .\\n                       \\n//           Case 2. When the group size is even:\\n//                   say a gp of house locations are : [1, 5, 17, 19].\\n//                   here we can install mailbox anywhere in range [5, 17]\\n                      \\n//                       mailbox\\n//                         ^\\n//                         |\\n//                     [1, 5, 17, 19]\\n                      \\n//                   As installing any where < 5 or > 17 would increment the total distance by 2.\\n                      \\n//         3. So we sort houses array first.\\n                      \\n//         4. Now, we assign houses[0] to hosues[i] to first mailbox, then \\n//            we assign houses[i + 1]....houses[(i + 1) +  r : (0, n - i - 2) ] to second mailbox, \\n//            and continous doing it untill all houses are covered.\\n               \\n//         5. so dp state is dp[i][j] where 0 <= i <= n - 1, 1 <= j <= k\\n//            dp[i][j] represents the min total distance of houses i to n - 1 from mailboxes, allocating j number of mailboxes\\n           \\n//         Recursive relation: \\n//            dp[i][j] = min(dis[i, i]     +  dp[i + 1][j - 1],\\n//                           dis[i, i + 1] +  dp[i + 2][j - 1],\\n//                           dis[i, i + 2] +  dp[i + 3][j - 1]....\\n//                          )\\n               \\n//            where dis[i, j] is min total dis for houses i to j from the mailbox allocated for them, \\n//            which we can find out as per discussed in point 2.\\n                      \\n        \\n        \\n        sort(houses.begin(), houses.end());\\n        int n = houses.size();\\n        if(K >= n) return 0; // if number of mailboxes >= number of houses, then ans = 0(min total dis)\\n        \\n        vector<vector<int>> dp(n, vector<int>(K + 1, inf));\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int k = K; k >= 1; k--) {\\n                 \\n                if(k >= (n - i))   // if, number of mailboxes >= number of houses, thus minTotalDis would be 0\\n                    dp[i][k] = 0;\\n                \\n                else {\\n                    \\n                    int sum = 0;\\n                    int mindis = INT_MAX;\\n                    int inc = 0;\\n                    for(int ge = i, c = i; ge <= (n - k); ge += 1) {\\n                        sum += (houses[ge] - houses[c]);\\n                        mindis = min(mindis, sum + (ge + 1 < n ? dp[ge + 1][k - 1] : 0));\\n                         \\n                        if(inc) c += 1;\\n                        inc ^= 1;\\n                    }\\n                    \\n                    dp[i][k] = mindis;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][K];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687712,
                "title": "c-recursion-with-memo-prefix-sum",
                "content": "```\\nclass Solution {\\n// Time complexity: O(k * n^2), where n = number of houses, k = number of mailboxes. If our constraints alter such that k becomes > n, then it will be O(min(n, k) * n^2)\\n// Space complexity: O(k * n^2)\\n\\nprivate:\\n    int MinDistanceHelper(const vector<int> &houses, vector<vector<vector<int>>> &dp, const vector<int> &prefix_sums, int k, int left, int right) {\\n        \\n        // If we already have computed this subproblem, return the result\\n        if (dp[k][left][right] != -1) return dp[k][left][right];\\n        \\n        // If there is only one mailbox, it must be placed at the median\\n        // Whether it\\'s the mathematical median (if number of elements is even, return average of the middle 2 elements), median_low, median_high doesn\\'t matter\\n        // All we want to ensure is to minimize the max(number of houses on the left, number of houses on the right)\\n        if (k == 1) {\\n            int mid = left + (right - left) / 2;\\n            \\n            // Here we have computed the prefix_sums beforehand and determined the total distance through a formula in O(1) time\\n            // This is not strictly necessary as we can also use an additional memo instead where memo(left, right) = total distance from mailbox given one mailbox between left and right or similar\\n            dp[k][left][right] = houses[mid] * (2 * mid - left - right) - prefix_sums[mid] + prefix_sums[left] + prefix_sums[right + 1] - prefix_sums[mid + 1];\\n            return dp[k][left][right];\\n        } else {\\n            \\n            // For each other case, we can divide it into the subproblem of \"between where will we put our last mailbox, and between where will be put every other mailbox\"\\n            // We will iterate through mid, such that the minimum total distance when we place k - 1 mailboxes for houses index [left, mid], and for (mid, right]\\n            // Note that mid starts at left + k - 2, as there will be (k - 1) mailbox placed for (mid - left + 1) houses, and there\\'s no point in assigning more than that many mailboxes for houses (as we\\'ll have 1 mailbox at house / dist = 0)\\n            int cur_min = numeric_limits<int>::max();\\n            for (int mid = left + k - 2; mid < right; ++mid) {\\n                cur_min = min(cur_min, MinDistanceHelper(houses, dp, prefix_sums, k - 1, left, mid) + MinDistanceHelper(houses, dp, prefix_sums, 1, mid + 1, right));\\n            }\\n            dp[k][left][right] = cur_min;\\n            return cur_min;\\n        }\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        // every house can have a mailbox right on it if k == house.size()\\n        if (k == houses.size()) return 0;\\n        \\n        // sort the houses by their position, and precompute our prefix sum\\n        sort(houses.begin(), houses.end());\\n        vector<int> prefix_sums;\\n        prefix_sums.reserve(houses.size() + 1);\\n        int sum = 0;\\n        prefix_sums.emplace_back(sum);\\n        for (int pos: houses) {\\n            sum += pos;\\n            prefix_sums.emplace_back(sum);\\n        }\\n        \\n        // initialize our dp memo, then perform our dfs recursive call\\n        vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(houses.size(), vector<int>(houses.size(), -1)));\\n        return MinDistanceHelper(houses, dp, prefix_sums, k, 0, houses.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n// Time complexity: O(k * n^2), where n = number of houses, k = number of mailboxes. If our constraints alter such that k becomes > n, then it will be O(min(n, k) * n^2)\\n// Space complexity: O(k * n^2)\\n\\nprivate:\\n    int MinDistanceHelper(const vector<int> &houses, vector<vector<vector<int>>> &dp, const vector<int> &prefix_sums, int k, int left, int right) {\\n        \\n        // If we already have computed this subproblem, return the result\\n        if (dp[k][left][right] != -1) return dp[k][left][right];\\n        \\n        // If there is only one mailbox, it must be placed at the median\\n        // Whether it\\'s the mathematical median (if number of elements is even, return average of the middle 2 elements), median_low, median_high doesn\\'t matter\\n        // All we want to ensure is to minimize the max(number of houses on the left, number of houses on the right)\\n        if (k == 1) {\\n            int mid = left + (right - left) / 2;\\n            \\n            // Here we have computed the prefix_sums beforehand and determined the total distance through a formula in O(1) time\\n            // This is not strictly necessary as we can also use an additional memo instead where memo(left, right) = total distance from mailbox given one mailbox between left and right or similar\\n            dp[k][left][right] = houses[mid] * (2 * mid - left - right) - prefix_sums[mid] + prefix_sums[left] + prefix_sums[right + 1] - prefix_sums[mid + 1];\\n            return dp[k][left][right];\\n        } else {\\n            \\n            // For each other case, we can divide it into the subproblem of \"between where will we put our last mailbox, and between where will be put every other mailbox\"\\n            // We will iterate through mid, such that the minimum total distance when we place k - 1 mailboxes for houses index [left, mid], and for (mid, right]\\n            // Note that mid starts at left + k - 2, as there will be (k - 1) mailbox placed for (mid - left + 1) houses, and there\\'s no point in assigning more than that many mailboxes for houses (as we\\'ll have 1 mailbox at house / dist = 0)\\n            int cur_min = numeric_limits<int>::max();\\n            for (int mid = left + k - 2; mid < right; ++mid) {\\n                cur_min = min(cur_min, MinDistanceHelper(houses, dp, prefix_sums, k - 1, left, mid) + MinDistanceHelper(houses, dp, prefix_sums, 1, mid + 1, right));\\n            }\\n            dp[k][left][right] = cur_min;\\n            return cur_min;\\n        }\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        // every house can have a mailbox right on it if k == house.size()\\n        if (k == houses.size()) return 0;\\n        \\n        // sort the houses by their position, and precompute our prefix sum\\n        sort(houses.begin(), houses.end());\\n        vector<int> prefix_sums;\\n        prefix_sums.reserve(houses.size() + 1);\\n        int sum = 0;\\n        prefix_sums.emplace_back(sum);\\n        for (int pos: houses) {\\n            sum += pos;\\n            prefix_sums.emplace_back(sum);\\n        }\\n        \\n        // initialize our dp memo, then perform our dfs recursive call\\n        vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(houses.size(), vector<int>(houses.size(), -1)));\\n        return MinDistanceHelper(houses, dp, prefix_sums, k, 0, houses.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687084,
                "title": "python-bottom-up-dp-solution-with-space-o-n-2-or-o-n-time-o-kn-2",
                "content": "Note that the space complexity can be reduced to O(n) if we don\\'t store an additional 2D list `dist` here but instead calculate the minimum distance on the fly. This would not change the time complexity asymptotically. However, the actual running time would increase roughly 10 times from ~400ms to ~4000ms.\\n\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], num_mailbox: int) -> int:\\n        if num_mailbox >= len(houses): return 0\\n        \\n        houses.sort()\\n        # dist[i][j] stores the minimum distance \\n        #   when a single mailbox is put between houses[i] and houses[j]\\n        dist = [[0] * len(houses) for i in range(len(houses))]\\n        for i in range(len(houses)):\\n            for j in range(i + 1, len(houses)):\\n                mailbox = houses[(i+j)//2]\\n                dist[i][j] = sum([abs(mailbox - house) for house in houses[i:j+1]])\\n        \\n        # dp[i] stores the minimum distance when we put k mailboxes up until houses[i] \\n        # dp is initialized for k = 1\\n        dp = [dist[0][i] for i in range(len(houses))]\\n            \\n        for k in range(2, num_mailbox + 1):\\n            for i in range(len(houses) - 1, -1, -1):\\n                for j in range(k-2, i):\\n                    # try to put a new mailbox between houses[j+1] and houses[i]\\n                    dp[i] = min(dp[i], dp[j] + dist[j+1][i])\\n\\n        return dp[-1]\\n```\\n\\nP.S. `n` is the number of houses and `k` is the number of mailboxes for the space/time complexity.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], num_mailbox: int) -> int:\\n        if num_mailbox >= len(houses): return 0\\n        \\n        houses.sort()\\n        # dist[i][j] stores the minimum distance \\n        #   when a single mailbox is put between houses[i] and houses[j]\\n        dist = [[0] * len(houses) for i in range(len(houses))]\\n        for i in range(len(houses)):\\n            for j in range(i + 1, len(houses)):\\n                mailbox = houses[(i+j)//2]\\n                dist[i][j] = sum([abs(mailbox - house) for house in houses[i:j+1]])\\n        \\n        # dp[i] stores the minimum distance when we put k mailboxes up until houses[i] \\n        # dp is initialized for k = 1\\n        dp = [dist[0][i] for i in range(len(houses))]\\n            \\n        for k in range(2, num_mailbox + 1):\\n            for i in range(len(houses) - 1, -1, -1):\\n                for j in range(k-2, i):\\n                    # try to put a new mailbox between houses[j+1] and houses[i]\\n                    dp[i] = min(dp[i], dp[j] + dist[j+1][i])\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686103,
                "title": "python-o-n-2-k-dp-solution-no-need-to-calculate-median",
                "content": "The cost for last M houses can be derived on-the-go.\\n```\\n    def minDistance(self, houses: List[int], K: int) -> int:\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i < 0:\\n                return 0\\n            if k == 0:\\n                return sys.maxsize\\n\\n            res = dp(i-1, k-1) # install the mailbox at the last house\\n            dist = 0\\n            for j in reversed(range(i)):\\n                dist = dist + houses[(i + j + 1) // 2] - houses[j]\\n                res = min(res, dp(j-1, k-1) + dist)\\n            return res\\n        \\n        return dp(len(houses) - 1, K)\\n```",
                "solutionTags": [],
                "code": "```\\n    def minDistance(self, houses: List[int], K: int) -> int:\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i < 0:\\n                return 0\\n            if k == 0:\\n                return sys.maxsize\\n\\n            res = dp(i-1, k-1) # install the mailbox at the last house\\n            dist = 0\\n            for j in reversed(range(i)):\\n                dist = dist + houses[(i + j + 1) // 2] - houses[j]\\n                res = min(res, dp(j-1, k-1) + dist)\\n            return res\\n        \\n        return dp(len(houses) - 1, K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685995,
                "title": "java-dfs-memorization-aka-top-down-dp",
                "content": "Intuition:\\nIt\\'s enought to consider house positions for mailboxes only. No need to put mailbox in between of the houses.\\nConsider next example: `houses = [1, 4], k = 1`, result is `3` and it\\'s the same for mailbox at position `1`, `2`, `3` or `4`.\\n\\nAlgorithm: DFS + memorization (aka top-down DP)\\n1. place mailbox at position `i`\\n2. try to place next mailbox starting from the position `i + 1`\\n\\n\\n```\\npublic int minDistance(int[] houses, int k) {\\n\\tArrays.sort(houses);\\n\\tint[][] cache = new int[houses.length + 1][k + 1];\\n\\tfor (int i = 0; i < cache.length; i++) {\\n\\t\\tArrays.fill(cache[i], -1);\\n\\t}\\n\\treturn dfs(houses, 0, k, -1, cache);\\n}\\n\\nprivate int dfs(int[] houses, int start, int k, int prevMailbox, int[][] cache) {\\n\\tif (k == 0) {\\n\\t\\t// no more mailboxes left\\n\\t\\t// we need to return sum of distances from previous mailbox to each house without mailbox assigned\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = prevMailbox; i < houses.length; i++) {\\n\\t\\t\\tsum += houses[i] - houses[prevMailbox];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tif (cache[start][k] != -1) {\\n\\t\\treturn cache[start][k];\\n\\t}\\n\\n\\tint res = 10_000_000;\\n\\t// place mailbox at ith house position\\n\\tfor (int i = start; i < houses.length; i++) {\\n\\t\\t// for houses in between: get distance to the closest mailbox\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = start; j < i; j++) {\\n\\t\\t\\t// distance to mailbox at i\\n\\t\\t\\tint distance = houses[i] - houses[j];\\n\\t\\t\\tif (prevMailbox != -1) {\\n\\t\\t\\t\\t// compare to the distance to mailbox at prevMailbox\\n\\t\\t\\t\\tdistance = Math.min(distance, houses[j] - houses[prevMailbox]);\\n\\t\\t\\t}\\n\\t\\t\\tsum += distance;\\n\\t\\t}\\n\\t\\t// place next mailbox\\n\\t\\tres = Math.min(res, dfs(houses, i + 1, k - 1, i, cache) + sum);\\n\\t}\\n\\n\\treturn cache[start][k] = res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int minDistance(int[] houses, int k) {\\n\\tArrays.sort(houses);\\n\\tint[][] cache = new int[houses.length + 1][k + 1];\\n\\tfor (int i = 0; i < cache.length; i++) {\\n\\t\\tArrays.fill(cache[i], -1);\\n\\t}\\n\\treturn dfs(houses, 0, k, -1, cache);\\n}\\n\\nprivate int dfs(int[] houses, int start, int k, int prevMailbox, int[][] cache) {\\n\\tif (k == 0) {\\n\\t\\t// no more mailboxes left\\n\\t\\t// we need to return sum of distances from previous mailbox to each house without mailbox assigned\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = prevMailbox; i < houses.length; i++) {\\n\\t\\t\\tsum += houses[i] - houses[prevMailbox];\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n\\n\\tif (cache[start][k] != -1) {\\n\\t\\treturn cache[start][k];\\n\\t}\\n\\n\\tint res = 10_000_000;\\n\\t// place mailbox at ith house position\\n\\tfor (int i = start; i < houses.length; i++) {\\n\\t\\t// for houses in between: get distance to the closest mailbox\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = start; j < i; j++) {\\n\\t\\t\\t// distance to mailbox at i\\n\\t\\t\\tint distance = houses[i] - houses[j];\\n\\t\\t\\tif (prevMailbox != -1) {\\n\\t\\t\\t\\t// compare to the distance to mailbox at prevMailbox\\n\\t\\t\\t\\tdistance = Math.min(distance, houses[j] - houses[prevMailbox]);\\n\\t\\t\\t}\\n\\t\\t\\tsum += distance;\\n\\t\\t}\\n\\t\\t// place next mailbox\\n\\t\\tres = Math.min(res, dfs(houses, i + 1, k - 1, i, cache) + sum);\\n\\t}\\n\\n\\treturn cache[start][k] = res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444480,
                "title": "python-3-optimal-dp",
                "content": "# Complexity\\n- Time complexity:\\n$O(n^2k)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        dp = ([math.inf] * n) + [0]\\n        for _ in range(k):\\n            for i in range(n):\\n                median = i\\n                change = False\\n                less = more = 0\\n                for j in range(i, n):\\n                    more += houses[j]\\n                    if change:\\n                        less += houses[median]\\n                        more -= houses[median]\\n                        median += 1\\n                        change = False\\n                    else:\\n                        change = True\\n                    m = median - i - (j - median + 1)\\n                    dist = m*houses[median] - less + more\\n                    dp[i] = min(dp[i], dp[j + 1] + dist)\\n        return dp[0]\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        dp = ([math.inf] * n) + [0]\\n        for _ in range(k):\\n            for i in range(n):\\n                median = i\\n                change = False\\n                less = more = 0\\n                for j in range(i, n):\\n                    more += houses[j]\\n                    if change:\\n                        less += houses[median]\\n                        more -= houses[median]\\n                        median += 1\\n                        change = False\\n                    else:\\n                        change = True\\n                    m = median - i - (j - median + 1)\\n                    dist = m*houses[median] - less + more\\n                    dp[i] = min(dp[i], dp[j + 1] + dist)\\n        return dp[0]\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432373,
                "title": "short-and-simple-memoization-in-python-with-explanation-faster-than-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to divide the `n` houses into `m` groups so that the total distance between houses and mailboxes is minimized. The problem can be typically handled by dynamic programming to explore different ways to grouping. For a group of houses, the best position of the mailbox is the median of the houses. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution is implemented with memoization for simplicity. The cost function is also cached for speed up. \\n\\n# Complexity\\n- Time complexity: $$O(n^2m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(nm)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], m: int) -> int:\\n        @cache\\n        def cost(l, r):\\n            median = houses[(l + r) // 2]\\n            return sum(abs(houses[i] - median) for i in range(l, r))\\n\\n        @cache\\n        def dp(i, j):\\n            if i == n:\\n                return 0\\n            if j == m:\\n                return inf\\n            return min(dp(k, j+1) + cost(i, k) for k in range(i+1, n+1-(m-j-1)))\\n\\n        houses.sort()\\n        n = len(houses)\\n        return dp(0, 0)               \\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], m: int) -> int:\\n        @cache\\n        def cost(l, r):\\n            median = houses[(l + r) // 2]\\n            return sum(abs(houses[i] - median) for i in range(l, r))\\n\\n        @cache\\n        def dp(i, j):\\n            if i == n:\\n                return 0\\n            if j == m:\\n                return inf\\n            return min(dp(k, j+1) + cost(i, k) for k in range(i+1, n+1-(m-j-1)))\\n\\n        houses.sort()\\n        n = len(houses)\\n        return dp(0, 0)               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925999,
                "title": "100-0ms-easy-o-nlogn-cache-proof",
                "content": "# UPVOTE PLS\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/4d0f1475-cb4e-438a-a59d-6798c2c732b1_1671381332.071796.png)\\n\\n\\n# Code\\n```\\n// class Solution {\\n//         public int minDistance(int[] A, int K) {\\n//         Arrays.sort(A);\\n//         int n = A.length, B[] = new int[n+1], dp[] = new int[n];\\n//         for (int i = 0; i < n; ++i) {\\n//             B[i + 1] = B[i] + A[i];\\n//             dp[i] = (int)1e6;\\n//         }\\n//         for (int k = 1; k <= K; ++k) {\\n//             for (int j = n - 1; j > k - 2; --j) {\\n//                 for (int i = k - 2; i < j; ++i) {\\n//                     int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n//                     int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n//                     dp[j] = Math.min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n//                 }\\n//             }\\n//         }\\n//         return dp[n - 1];\\n//     }\\n// }\\n\\nclass Solution {\\n    private int[][] cache;\\n\\n    public int minDistance(int[] houses, int k) {\\n        cache = new int[houses.length][k + 1];\\n        Arrays.sort(houses);\\n        return minDist(houses, 0, k);\\n    }\\n\\n    private int minDist(int[] houses, int pos, int k) {\\n        if (cache[pos][k] != 0) {\\n            return cache[pos][k] - 1;\\n        }\\n\\n        if (k == 1) {\\n            int n = houses.length - pos;\\n\\n            if (n < 4) {\\n                cache[pos][k] = houses[pos + n - 1] - houses[pos] + 1;\\n            } else {\\n                int sum = 0;\\n                int m = houses[pos + n / 2];\\n\\n                for (int p = pos; p < houses.length; p++) {\\n                    sum += Math.abs(houses[p] - m);\\n                }\\n                cache[pos][k] = sum + 1;\\n            }\\n        } else if (houses.length - pos == k) {\\n            cache[pos][k] = 1;\\n            return 0;\\n        } else {\\n            int sum = 0;\\n            int min = minDist(houses, pos + 1, k - 1);\\n\\n            for (int i = pos + 1, is = (pos + (houses.length - k + 1)) >> 1; ; i++) {\\n                sum += houses[i + (i - pos - 1)] - houses[i - 1];\\n                min = Math.min(min, sum + minDist(houses, i + i - pos, k - 1));\\n\\n                if (i == is) {\\n                    if (i + i - pos <= houses.length - k) {\\n                        sum += houses[i + i - pos] - houses[i];\\n                        min = Math.min(min, sum + minDist(houses, i + i - pos + 1, k - 1));\\n                    }\\n                    break;\\n                }\\n                sum += houses[i + i - pos] - houses[i];\\n                min = Math.min(min, sum + minDist(houses, i + i - pos + 1, k - 1));\\n            }\\n            cache[pos][k] = min + 1;\\n            return min;\\n        }\\n\\n        return cache[pos][k] - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n// class Solution {\\n//         public int minDistance(int[] A, int K) {\\n//         Arrays.sort(A);\\n//         int n = A.length, B[] = new int[n+1], dp[] = new int[n];\\n//         for (int i = 0; i < n; ++i) {\\n//             B[i + 1] = B[i] + A[i];\\n//             dp[i] = (int)1e6;\\n//         }\\n//         for (int k = 1; k <= K; ++k) {\\n//             for (int j = n - 1; j > k - 2; --j) {\\n//                 for (int i = k - 2; i < j; ++i) {\\n//                     int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n//                     int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n//                     dp[j] = Math.min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n//                 }\\n//             }\\n//         }\\n//         return dp[n - 1];\\n//     }\\n// }\\n\\nclass Solution {\\n    private int[][] cache;\\n\\n    public int minDistance(int[] houses, int k) {\\n        cache = new int[houses.length][k + 1];\\n        Arrays.sort(houses);\\n        return minDist(houses, 0, k);\\n    }\\n\\n    private int minDist(int[] houses, int pos, int k) {\\n        if (cache[pos][k] != 0) {\\n            return cache[pos][k] - 1;\\n        }\\n\\n        if (k == 1) {\\n            int n = houses.length - pos;\\n\\n            if (n < 4) {\\n                cache[pos][k] = houses[pos + n - 1] - houses[pos] + 1;\\n            } else {\\n                int sum = 0;\\n                int m = houses[pos + n / 2];\\n\\n                for (int p = pos; p < houses.length; p++) {\\n                    sum += Math.abs(houses[p] - m);\\n                }\\n                cache[pos][k] = sum + 1;\\n            }\\n        } else if (houses.length - pos == k) {\\n            cache[pos][k] = 1;\\n            return 0;\\n        } else {\\n            int sum = 0;\\n            int min = minDist(houses, pos + 1, k - 1);\\n\\n            for (int i = pos + 1, is = (pos + (houses.length - k + 1)) >> 1; ; i++) {\\n                sum += houses[i + (i - pos - 1)] - houses[i - 1];\\n                min = Math.min(min, sum + minDist(houses, i + i - pos, k - 1));\\n\\n                if (i == is) {\\n                    if (i + i - pos <= houses.length - k) {\\n                        sum += houses[i + i - pos] - houses[i];\\n                        min = Math.min(min, sum + minDist(houses, i + i - pos + 1, k - 1));\\n                    }\\n                    break;\\n                }\\n                sum += houses[i + i - pos] - houses[i];\\n                min = Math.min(min, sum + minDist(houses, i + i - pos + 1, k - 1));\\n            }\\n            cache[pos][k] = min + 1;\\n            return min;\\n        }\\n\\n        return cache[pos][k] - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850320,
                "title": "python3-solution-dp-o-n-3",
                "content": "# Complexity\\n- Time complexity: $$O(n^3)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, A, K):\\n        A.sort()\\n        N = len(A)\\n        P = [0] + list(accumulate(A))\\n        dp = [0] + [float(\\'inf\\')] * N\\n        for i in range(K):\\n            for j in range(N - 1, i - 1, -1):\\n                for k in range(j, i - 1, -1):\\n                    m = (k + j) >> 1\\n                    cost = P[j + 1] + P[k] - 2 * P[m] - A[m] * (j - 2 * m + k + 1)\\n                    dp[j + 1] = min(dp[j + 1], dp[k] + cost)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, A, K):\\n        A.sort()\\n        N = len(A)\\n        P = [0] + list(accumulate(A))\\n        dp = [0] + [float(\\'inf\\')] * N\\n        for i in range(K):\\n            for j in range(N - 1, i - 1, -1):\\n                for k in range(j, i - 1, -1):\\n                    m = (k + j) >> 1\\n                    cost = P[j + 1] + P[k] - 2 * P[m] - A[m] * (j - 2 * m + k + 1)\\n                    dp[j + 1] = min(dp[j + 1], dp[k] + cost)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840938,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from lee215\\nclass Solution {\\npublic:\\n        int minDistance(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int n = A.size();\\n        vector<int> B(n + 1, 0), dp(n, 1e6);\\n        for (int i = 0; i < n; ++i)\\n            B[i + 1] = B[i] + A[i];\\n        for (int k = 1; k <= K; ++k)\\n            for (int j = n - 1; j > k - 2; --j)\\n                for (int i = k - 2; i < j; ++i) {\\n                    int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n                    int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n                    dp[j] = min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n                }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from lee215\\nclass Solution {\\npublic:\\n        int minDistance(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int n = A.size();\\n        vector<int> B(n + 1, 0), dp(n, 1e6);\\n        for (int i = 0; i < n; ++i)\\n            B[i + 1] = B[i] + A[i];\\n        for (int k = 1; k <= K; ++k)\\n            for (int j = n - 1; j > k - 2; --j)\\n                for (int i = k - 2; i < j; ++i) {\\n                    int m1 =  (i + j + 1) / 2, m2 = (i + j + 2) / 2;\\n                    int last = (B[j + 1] - B[m2]) - (B[m1 + 1] - B[i + 1]);\\n                    dp[j] = min(dp[j], (i >= 0 ? dp[i] : 0) + last);\\n                }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742216,
                "title": "c-dp-memoization-easy-to-understand-heavily-commented",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// place k mailboxes on the location of the house (try every possibilty)\\n    int dp[105][105][105];\\n    int solve(int n, int k, int pre[][105], int prev, int i)\\n    {\\n        if(i > n) return (k == 0) ? 0 : INT_MAX;\\n        if(k == 0)\\n        {\\n\\t\\t\\t// when k is 0, just add up all the houses distance to the right\\n            int sum = 0; \\n            for(int j = prev + 1; j <= n; j++)\\n            {\\n                sum += pre[prev][j];\\n            }\\n            return sum;\\n        }\\n        \\n        if(dp[prev][i][k] != -1) return dp[prev][i][k];\\n\\t\\t\\n        // option 1: don\\'t consider this house\\n        int a = solve(n, k, pre, prev, i + 1); \\n\\t\\t\\n\\t\\t// option 2: consider this house (i.e, place mailbox at this location) and\\n\\t\\t// add the minimum distance between the current and the \\n\\t\\t// previously placed mailbox of all the houses in between\\n        \\n\\t\\tint b = INT_MAX; \\n        int sum = 0;\\n\\t\\t\\n        for(int j = prev + 1; j < i; j++)\\n        {\\n            if(prev != 0) sum += min(pre[prev][j], pre[i][j]);\\n            else sum += pre[i][j];\\n        }\\n        \\n        int val = solve(n, k - 1, pre, i, i + 1);\\n        if(val != INT_MAX) b = sum + val;\\n        \\n        return dp[prev][i][k] = min(a, b);\\n    }\\n    \\n    int minDistance(vector<int>& house, int k) {\\n        int n = house.size();\\n        int pre[105][105]; // pre[i][j] stores the distance from ith house to jth house\\n        sort(house.begin(), house.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                pre[i + 1][j + 1] = abs(house[i] - house[j]);\\n            }\\n        }\\n        \\n        memset(dp, -1, sizeof dp);\\n        return solve(n, k, pre, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// place k mailboxes on the location of the house (try every possibilty)\\n    int dp[105][105][105];\\n    int solve(int n, int k, int pre[][105], int prev, int i)\\n    {\\n        if(i > n) return (k == 0) ? 0 : INT_MAX;\\n        if(k == 0)\\n        {\\n\\t\\t\\t// when k is 0, just add up all the houses distance to the right\\n            int sum = 0; \\n            for(int j = prev + 1; j <= n; j++)\\n            {\\n                sum += pre[prev][j];\\n            }\\n            return sum;\\n        }\\n        \\n        if(dp[prev][i][k] != -1) return dp[prev][i][k];\\n\\t\\t\\n        // option 1: don\\'t consider this house\\n        int a = solve(n, k, pre, prev, i + 1); \\n\\t\\t\\n\\t\\t// option 2: consider this house (i.e, place mailbox at this location) and\\n\\t\\t// add the minimum distance between the current and the \\n\\t\\t// previously placed mailbox of all the houses in between\\n        \\n\\t\\tint b = INT_MAX; \\n        int sum = 0;\\n\\t\\t\\n        for(int j = prev + 1; j < i; j++)\\n        {\\n            if(prev != 0) sum += min(pre[prev][j], pre[i][j]);\\n            else sum += pre[i][j];\\n        }\\n        \\n        int val = solve(n, k - 1, pre, i, i + 1);\\n        if(val != INT_MAX) b = sum + val;\\n        \\n        return dp[prev][i][k] = min(a, b);\\n    }\\n    \\n    int minDistance(vector<int>& house, int k) {\\n        int n = house.size();\\n        int pre[105][105]; // pre[i][j] stores the distance from ith house to jth house\\n        sort(house.begin(), house.end());\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                pre[i + 1][j + 1] = abs(house[i] - house[j]);\\n            }\\n        }\\n        \\n        memset(dp, -1, sizeof dp);\\n        return solve(n, k, pre, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667817,
                "title": "can-someone-help-me",
                "content": "I have written a solution which is giving me TLE, can someone help me with this?\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int MAX_ = 1e7;\\n    \\n    int helper(vector<int> &houses, int k, int start, vector<vector<int>> &dp, vector<vector<int>> cost) {\\n        int n = houses.size();\\n        if (k == 0 && start == n) return 0;\\n        if (k == 0 || start == n) return MAX_;\\n        if (dp[k][start] != -1) return dp[k][start];\\n        int ans = 1e7;\\n        for (int i = start; i < n ; i++) {\\n            ans = min(ans, cost[start][i] + helper(houses, k - 1, i + 1, dp, cost));\\n        }\\n        return dp[k][start] = ans;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        vector<vector<int>> cost(n, vector<int>(n, 0));\\n        sort(houses.begin(), houses.end());\\n        vector<int> prefix(n + 1, 0);\\n        for (int i = 0; i < n; i++) {\\n            prefix[i + 1] = prefix[i] + houses[i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int e = (i + j)/2;\\n                int d = (j - i)/2;\\n                cost[i][j] += abs((prefix[e + 1] - prefix[i]) - (d + 1) * houses[e]);\\n                if ((i + j - 1) % 2) {\\n                    cost[i][j] += abs((prefix[j + 1] - prefix[e + 1]) - (d * houses[e]));\\n                }\\n                else {\\n                    cost[i][j] += abs((prefix[j + 1] - prefix[e + 1]) - (d + 1) * houses[e]);   \\n                }\\n\\n            }\\n        }\\n        vector<vector<int>> dp(k + 1, vector<int>(n, -1));\\n        return helper(houses, k, 0, dp, cost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MAX_ = 1e7;\\n    \\n    int helper(vector<int> &houses, int k, int start, vector<vector<int>> &dp, vector<vector<int>> cost) {\\n        int n = houses.size();\\n        if (k == 0 && start == n) return 0;\\n        if (k == 0 || start == n) return MAX_;\\n        if (dp[k][start] != -1) return dp[k][start];\\n        int ans = 1e7;\\n        for (int i = start; i < n ; i++) {\\n            ans = min(ans, cost[start][i] + helper(houses, k - 1, i + 1, dp, cost));\\n        }\\n        return dp[k][start] = ans;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        vector<vector<int>> cost(n, vector<int>(n, 0));\\n        sort(houses.begin(), houses.end());\\n        vector<int> prefix(n + 1, 0);\\n        for (int i = 0; i < n; i++) {\\n            prefix[i + 1] = prefix[i] + houses[i];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int e = (i + j)/2;\\n                int d = (j - i)/2;\\n                cost[i][j] += abs((prefix[e + 1] - prefix[i]) - (d + 1) * houses[e]);\\n                if ((i + j - 1) % 2) {\\n                    cost[i][j] += abs((prefix[j + 1] - prefix[e + 1]) - (d * houses[e]));\\n                }\\n                else {\\n                    cost[i][j] += abs((prefix[j + 1] - prefix[e + 1]) - (d + 1) * houses[e]);   \\n                }\\n\\n            }\\n        }\\n        vector<vector<int>> dp(k + 1, vector<int>(n, -1));\\n        return helper(houses, k, 0, dp, cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508079,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vi(vi(ll))cost, dp;\\n    ll sz;\\n    ll func(const vi(int)& v, ll i, ll k) {\\n        if (i == sz && k == 0) {\\n            return 0; // valid distribution completed\\n        }\\n        if (i == sz || k == 0) {\\n            return LLONG_MAX; // invalid dist. formed\\n        }\\n        if (dp[i][k] == -1) {\\n            dp[i][k] = LLONG_MAX;\\n            for (ll j = i;j < sz;++j) { lets put a smile on that face\\n                ll rec = func(v, j + 1, k - 1);\\n                if (rec < LLONG_MAX) {\\n                    rec += cost[i][j];\\n                }\\n                dp[i][k] = min(dp[i][k], rec);\\n            }\\n        }\\n        return dp[i][k];\\n    }\\n    int minDistance(vector<int>& v, int k) {\\n        sort(v.begin(), v.end());\\n        sz = v.size();\\n        cost.resize(sz, vi(ll)(sz, 0));\\n        for (ll i = 0;i < sz;++i) { // for every possible valid range [i,j], we shall obtain the total cost for it by placing one mailpost. The position for the mailpost must be the median of the positions of all the houses that lie in this range.\\n            for (ll j = i;j < sz;++j) {\\n                for (ll k = i;k <= j;++k) {  // k -> the houses in this range\\n                    cost[i][j] += abs(v[(i + j) / 2] - v[k]); // (i+j)/2 => median house\\n                }\\n            }\\n        }\\n        dp.resize(sz, vi(ll)(k + 1, -1));\\n        return func(v, 0, k);\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vi(vi(ll))cost, dp;\\n    ll sz;\\n    ll func(const vi(int)& v, ll i, ll k) {\\n        if (i == sz && k == 0) {\\n            return 0; // valid distribution completed\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2406693,
                "title": "ez-python-knapsack-top-down-bounded-sequence-dp",
                "content": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        \"\"\"\\n            q. \\n            \\n            \\n            it always make sense to put mail box in the middle most position\\n            now question remains, middle of how many houses.. since we need lookahead to find how many houses should be taken for current-i mailbox, we will dp this\\n            \\n            \\n            sequence bounded knapsack\\n            minimize house to mailbox distance\\n            \\n            dp(curr_house_i, prev_covered_house ,remaining_mailbox)\\n                states\\n            state transition\\n                1. but mail box here\\n                    currcost() + dp(curr_h, curr_h, rem-1)\\n                2. donot put mail here\\n                    dp(curr_house_i+1, prev_covered, remain)\\n                \\n                return min\\n                \\n                currcost() -> take current_i, prev_i and return cost \\n                \\n            \\n            \\n            base case\\n                reached at end \\n            \\n        \"\"\"\\n        houses.sort()\\n        \\n        @cache\\n        def curr_cost(start_i, end_i):\\n            \\n            if start_i == end_i:\\n                return 0\\n            \\n            mid = houses[(end_i + start_i) // 2]\\n            \\n            diff = 0\\n            \\n            for i in range(start_i, end_i + 1):\\n                diff += abs(mid - houses[i])\\n            \\n            return diff\\n    \\n        @cache\\n        def dp(ci, pi, remains):\\n            \\n            if ci == len(houses):\\n                if ci == pi and remains == 0:\\n                    return 0\\n                else:\\n                    return inf\\n                \\n            if remains == 0:\\n                # cant place any more mailboxes\\n                return inf\\n            \\n            \\n            cost_place_here = curr_cost(pi, ci)\\n            \\n            return min(cost_place_here + dp(ci+1, ci+1, remains-1), dp(ci+1, pi, remains))\\n    \\n        \\n        return dp(0, 0, k)\\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        \"\"\"\\n            q. \\n            \\n            \\n            it always make sense to put mail box in the middle most position\\n            now question remains, middle of how many houses.. since we need lookahead to find how many houses should be taken for current-i mailbox, we will dp this\\n            \\n            \\n            sequence bounded knapsack\\n            minimize house to mailbox distance\\n            \\n            dp(curr_house_i, prev_covered_house ,remaining_mailbox)\\n                states\\n            state transition\\n                1. but mail box here\\n                    currcost() + dp(curr_h, curr_h, rem-1)\\n                2. donot put mail here\\n                    dp(curr_house_i+1, prev_covered, remain)\\n                \\n                return min\\n                \\n                currcost() -> take current_i, prev_i and return cost \\n                \\n            \\n            \\n            base case\\n                reached at end \\n            \\n        \"\"\"\\n        houses.sort()\\n        \\n        @cache\\n        def curr_cost(start_i, end_i):\\n            \\n            if start_i == end_i:\\n                return 0\\n            \\n            mid = houses[(end_i + start_i) // 2]\\n            \\n            diff = 0\\n            \\n            for i in range(start_i, end_i + 1):\\n                diff += abs(mid - houses[i])\\n            \\n            return diff\\n    \\n        @cache\\n        def dp(ci, pi, remains):\\n            \\n            if ci == len(houses):\\n                if ci == pi and remains == 0:\\n                    return 0\\n                else:\\n                    return inf\\n                \\n            if remains == 0:\\n                # cant place any more mailboxes\\n                return inf\\n            \\n            \\n            cost_place_here = curr_cost(pi, ci)\\n            \\n            return min(cost_place_here + dp(ci+1, ci+1, remains-1), dp(ci+1, pi, remains))\\n    \\n        \\n        return dp(0, 0, k)\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185552,
                "title": "java-o-k-n-2-solution-bottom-up-dp",
                "content": "I like this problem and struggled hardly to figure out this solution.\\nSo I want to share my code for those still working on this.\\n\\nThe explanation is briefly described in comments.\\nIf there still are questions, feel free to ask.\\n\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        \\n        // place[i][j] is the distance to place a box to cover house i to j\\n        int[][] place = new int[houses.length][houses.length];\\n        for (int i = 0; i < houses.length; ++i) {\\n            for (int j = i + 1; j < houses.length; ++j) {\\n                place[i][j] = placeMailBox(houses, i, j);\\n            }\\n        }\\n        \\n        // distance[i][j] is the distance to place j boxes to cover house i to n - 1\\n        int[][] distance = new int[houses.length][k + 1];\\n        // iterate over i\\n        for (int i = houses.length - 1; i >= 0; --i) {\\n            distance[i][1] = place[i][houses.length - 1];\\n            \\n            // iterate over j\\n            for (int j = Math.max(2, k - i); j <= houses.length - i && j <= k; ++j) {\\n                distance[i][j] = Integer.MAX_VALUE;\\n                // iterate over the range the first box cover\\n                for (int m = i; m < houses.length - (j - 1); ++m) {\\n                    distance[i][j] = Math.min(distance[i][j], place[i][m] + distance[m + 1][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return distance[0][k];\\n    }\\n    \\n    private int placeMailBox(int[] houses, int start, int end) {\\n        // median is the best position to place mail box\\n        int median = (start + end) / 2;\\n        int distance = 0;\\n        for (int i = start; i <= end; ++i) {\\n            if (i <= median) {\\n                distance += houses[median] - houses[i];\\n            } else {\\n                distance += houses[i] - houses[median];\\n            }\\n        }\\n        \\n        return distance;\\n    }\\n}\\n```\\n\\nlet N be the number of houses\\ntime complexity: O(k * N^2)\\nspace complexity: O(N^2)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        \\n        // place[i][j] is the distance to place a box to cover house i to j\\n        int[][] place = new int[houses.length][houses.length];\\n        for (int i = 0; i < houses.length; ++i) {\\n            for (int j = i + 1; j < houses.length; ++j) {\\n                place[i][j] = placeMailBox(houses, i, j);\\n            }\\n        }\\n        \\n        // distance[i][j] is the distance to place j boxes to cover house i to n - 1\\n        int[][] distance = new int[houses.length][k + 1];\\n        // iterate over i\\n        for (int i = houses.length - 1; i >= 0; --i) {\\n            distance[i][1] = place[i][houses.length - 1];\\n            \\n            // iterate over j\\n            for (int j = Math.max(2, k - i); j <= houses.length - i && j <= k; ++j) {\\n                distance[i][j] = Integer.MAX_VALUE;\\n                // iterate over the range the first box cover\\n                for (int m = i; m < houses.length - (j - 1); ++m) {\\n                    distance[i][j] = Math.min(distance[i][j], place[i][m] + distance[m + 1][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return distance[0][k];\\n    }\\n    \\n    private int placeMailBox(int[] houses, int start, int end) {\\n        // median is the best position to place mail box\\n        int median = (start + end) / 2;\\n        int distance = 0;\\n        for (int i = start; i <= end; ++i) {\\n            if (i <= median) {\\n                distance += houses[median] - houses[i];\\n            } else {\\n                distance += houses[i] - houses[median];\\n            }\\n        }\\n        \\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745888,
                "title": "java-top-down-dp-solution-with-detailed-comments-beat-30-70-in-time",
                "content": "```\\nclass Solution {\\n    // This is used for dp calculatio mnmemory\\n    private static Integer[][][] memo;\\n    private int[] houses;\\n    private int k;\\n    // This is for sum calculation memory\\n    private static Integer[][] sum;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        memo = new Integer[houses.length][houses.length][k + 1];\\n        sum = new Integer[houses.length][houses.length];\\n        this.houses = houses;\\n        this.k = k;     \\n        return dp(0, houses.length - 1, k);\\n    }\\n    \\n    private int dp(int start, int end, int k){\\n        // BASE CASE: This means we will build a mail box right at the house, then the cost for that house is 0. \\n        if(start == end) return 0;\\n        if(memo[start][end][k] != null) return memo[start][end][k];\\n        int cur = Integer.MAX_VALUE;\\n        if(k > 1){\\n            //From current house, we try all the posibilties for the next mail box and choose the least cost one.\\n            for(int i = start; i < end; i++){     \\n                // The cost for next mail box has two components.\\n                //First, from start to ith mail box. This part is straight forward just use the median to calculate the cost.\\n                //Second, the cost after this mail box. This part we use recursion to calculate. If we build a mail box at i,\\n                //then only k - 1 mail box left for the houses after i. So it equals to dp(i + 1, k - 1).\\n                cur = Math.min(cur, findSum(start, i) + dp(i + 1, end, k - 1 ));                \\n            }  \\n        }else{\\n            // If k == 1, then that means we can not build any more mail box, then we just use helper function to find the cost.\\n            cur = findSum(start, end);\\n        }\\n        memo[start][end][k] = cur;\\n        return memo[start][end][k];\\n    }\\n    // There is trick here: the MEDIAN point at the least distance sum to all the others points in the line.\\n    // Using this information we can use a for loop to calculate the least distance.Also we use a int matrix to avoid repeated calculation.\\n    private int findSum(int start, int end){  \\n        if(sum[start][end] != null){\\n            return sum[start][end];\\n        }\\n        int medium = start + (end - start) / 2;\\n        int result = 0;\\n        for(int i = start; i <= end; i++){\\n            result += Math.abs(houses[i] - houses[medium]);\\n        }\\n        sum[start][end] = result;\\n        return sum[start][end]; \\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // This is used for dp calculatio mnmemory\\n    private static Integer[][][] memo;\\n    private int[] houses;\\n    private int k;\\n    // This is for sum calculation memory\\n    private static Integer[][] sum;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        memo = new Integer[houses.length][houses.length][k + 1];\\n        sum = new Integer[houses.length][houses.length];\\n        this.houses = houses;\\n        this.k = k;     \\n        return dp(0, houses.length - 1, k);\\n    }\\n    \\n    private int dp(int start, int end, int k){\\n        // BASE CASE: This means we will build a mail box right at the house, then the cost for that house is 0. \\n        if(start == end) return 0;\\n        if(memo[start][end][k] != null) return memo[start][end][k];\\n        int cur = Integer.MAX_VALUE;\\n        if(k > 1){\\n            //From current house, we try all the posibilties for the next mail box and choose the least cost one.\\n            for(int i = start; i < end; i++){     \\n                // The cost for next mail box has two components.\\n                //First, from start to ith mail box. This part is straight forward just use the median to calculate the cost.\\n                //Second, the cost after this mail box. This part we use recursion to calculate. If we build a mail box at i,\\n                //then only k - 1 mail box left for the houses after i. So it equals to dp(i + 1, k - 1).\\n                cur = Math.min(cur, findSum(start, i) + dp(i + 1, end, k - 1 ));                \\n            }  \\n        }else{\\n            // If k == 1, then that means we can not build any more mail box, then we just use helper function to find the cost.\\n            cur = findSum(start, end);\\n        }\\n        memo[start][end][k] = cur;\\n        return memo[start][end][k];\\n    }\\n    // There is trick here: the MEDIAN point at the least distance sum to all the others points in the line.\\n    // Using this information we can use a for loop to calculate the least distance.Also we use a int matrix to avoid repeated calculation.\\n    private int findSum(int start, int end){  \\n        if(sum[start][end] != null){\\n            return sum[start][end];\\n        }\\n        int medium = start + (end - start) / 2;\\n        int result = 0;\\n        for(int i = start; i <= end; i++){\\n            result += Math.abs(houses[i] - houses[medium]);\\n        }\\n        sum[start][end] = result;\\n        return sum[start][end]; \\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703494,
                "title": "python-dp-no-relaxation",
                "content": "Many top down dp solution uses INF defaults to do relaxation, I think it is not neccessary. \\n\\n```python\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n\\n        @cache\\n        def cost(i,j):  # min total distance use 1 mailbox for house i to j\\n            if i == j: return 0\\n            if j == i + 1: return houses[j] - houses[i]\\n            return cost(i+1, j-1) + houses[j] - houses[i]\\n        \\n        @cache\\n        def dp(i, k):   # use k mailbox to cover house 0 to i \\n            if k > i: return 0\\n            if k == 1: return cost(0, i)\\n            return min(dp(p, k-1) + cost(p+1, i) for p in range(i))\\n\\n        return dp(n-1, k)    \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n\\n        @cache\\n        def cost(i,j):  # min total distance use 1 mailbox for house i to j\\n            if i == j: return 0\\n            if j == i + 1: return houses[j] - houses[i]\\n            return cost(i+1, j-1) + houses[j] - houses[i]\\n        \\n        @cache\\n        def dp(i, k):   # use k mailbox to cover house 0 to i \\n            if k > i: return 0\\n            if k == 1: return cost(0, i)\\n            return min(dp(p, k-1) + cost(p+1, i) for p in range(i))\\n\\n        return dp(n-1, k)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457488,
                "title": "can-we-do-it-using-binary-search-algorithm",
                "content": "First thing that came to my mind is to use approach similar to aggresive cows (SPOJ).\\n<b>Logic:</b>Find the Minimum Distance possible to arrange all mailboxes.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,int k,vector<int>&arr){\\n        vector<int>distance;\\n        int cnt{0};\\n        for(int i=0;i<arr.size();i++){\\n            if(distance.size()==0){\\n                cnt++;\\n                distance.push_back(arr[i]+mid);\\n            }\\n            else{\\n                int x=distance[distance.size()-1];\\n                int y=abs(x-arr[i]);\\n                \\n                if(y>mid){\\n                    cnt++;\\n                    distance.push_back(arr[i]+mid);\\n                }\\n            }\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        \\n        \\n        \\n        return true;\\n        \\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        // Binary Search Solution\\n        sort(houses.begin(),houses.end());\\n        int n=houses.size();\\n        int start=0,end=houses[n-1],ans;\\n        \\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            \\n            if(check(mid,k,houses)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nHere <b>ans</b> is the minimum distance to arrange the mailboxes.\\nBut now i am unable to find the sum.\\nIs there any way to find the sum or DP is the only approach to solve this Problem.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int mid,int k,vector<int>&arr){\\n        vector<int>distance;\\n        int cnt{0};\\n        for(int i=0;i<arr.size();i++){\\n            if(distance.size()==0){\\n                cnt++;\\n                distance.push_back(arr[i]+mid);\\n            }\\n            else{\\n                int x=distance[distance.size()-1];\\n                int y=abs(x-arr[i]);\\n                \\n                if(y>mid){\\n                    cnt++;\\n                    distance.push_back(arr[i]+mid);\\n                }\\n            }\\n        }\\n        \\n        if(cnt>k)\\n            return false;\\n        \\n        \\n        \\n        return true;\\n        \\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        // Binary Search Solution\\n        sort(houses.begin(),houses.end());\\n        int n=houses.size();\\n        int start=0,end=houses[n-1],ans;\\n        \\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            \\n            if(check(mid,k,houses)){\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375811,
                "title": "java-time-o-nk-memory-o-nk-suffix-sum",
                "content": "<iframe src=\"https://leetcode.com/playground/Nk3R4Cy8/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/Nk3R4Cy8/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1193828,
                "title": "c-o-n-3-dp",
                "content": "- Sort all hourses by their positions\\n- From left to right, we pick a range of houses and assign 1 mailbox to the range\\n\\t- the single mailbox can be arranged greadily in the middle (see the `dist` method)\\n    - recurse on the remaining range\\n\\nTime: There\\'s at most n^2 `dist` calls in total, and another n^3 `solve` calls. So the overall time is O(n^3).\\nSpace: O(n^2)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> H;\\n    vector<vector<int>> dp, memo;\\n    \\n    int dist(int a, int b) {\\n        if (memo[a][b] >= 0) return memo[a][b];\\n        int res = 0, x = a, y = b;\\n        while (a + 2 < b) res += H[b--] - H[a++];\\n        if (a != b) return memo[x][y] = res + H[b] - H[a];\\n        return memo[x][y] = res;\\n    }\\n    \\n    int solve(int h, int k) {\\n        if (h >= H.size()) return 0;\\n        if (dp[h][k] >= 0) return dp[h][k];\\n        if (k == 1) return dp[h][k] = dist(h, H.size() - 1);\\n        \\n        int res = solve(h + 1, k - 1);\\n        for (int i = h + 1; i < H.size(); ++i) {\\n            res = min(res, dist(h, i) + solve(i + 1, k - 1));\\n        }\\n        return dp[h][k] = res;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        swap(H, houses);\\n        dp.assign(H.size(), vector<int>(k + 1, -1));\\n        memo.assign(H.size(), vector<int>(H.size(), -1));\\n        sort(H.begin(), H.end());\\n        return solve(0, k);\\n    }\\n};\\n```\\n\\nAlternatively, a bottom up implementation:\\n```\\n    int minDistance(vector<int>& houses, int m) {\\n        swap(H, houses);\\n        int n = H.size();\\n        vector<int> dp(n + 1);\\n        memo.assign(n, vector<int>(n, -1));\\n        sort(H.begin(), H.end());\\n        for (int i = 0; i < n; ++i) dp[i] = dist(i, n - 1);\\n        for (int k = 0; k + 1 < m; ++k) {\\n            for (int i = 0; i < n; ++i) {\\n                dp[i] = min(dp[i], dp[i + 1]);\\n                for (int j = i + 1; j < n; ++j) {\\n                    dp[i] = min(dp[i], dist(i, j) + dp[j + 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> H;\\n    vector<vector<int>> dp, memo;\\n    \\n    int dist(int a, int b) {\\n        if (memo[a][b] >= 0) return memo[a][b];\\n        int res = 0, x = a, y = b;\\n        while (a + 2 < b) res += H[b--] - H[a++];\\n        if (a != b) return memo[x][y] = res + H[b] - H[a];\\n        return memo[x][y] = res;\\n    }\\n    \\n    int solve(int h, int k) {\\n        if (h >= H.size()) return 0;\\n        if (dp[h][k] >= 0) return dp[h][k];\\n        if (k == 1) return dp[h][k] = dist(h, H.size() - 1);\\n        \\n        int res = solve(h + 1, k - 1);\\n        for (int i = h + 1; i < H.size(); ++i) {\\n            res = min(res, dist(h, i) + solve(i + 1, k - 1));\\n        }\\n        return dp[h][k] = res;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        swap(H, houses);\\n        dp.assign(H.size(), vector<int>(k + 1, -1));\\n        memo.assign(H.size(), vector<int>(H.size(), -1));\\n        sort(H.begin(), H.end());\\n        return solve(0, k);\\n    }\\n};\\n```\n```\\n    int minDistance(vector<int>& houses, int m) {\\n        swap(H, houses);\\n        int n = H.size();\\n        vector<int> dp(n + 1);\\n        memo.assign(n, vector<int>(n, -1));\\n        sort(H.begin(), H.end());\\n        for (int i = 0; i < n; ++i) dp[i] = dist(i, n - 1);\\n        for (int k = 0; k + 1 < m; ++k) {\\n            for (int i = 0; i < n; ++i) {\\n                dp[i] = min(dp[i], dp[i + 1]);\\n                for (int j = i + 1; j < n; ++j) {\\n                    dp[i] = min(dp[i], dist(i, j) + dp[j + 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175608,
                "title": "a-basic-recursive-memo-code-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[101][101];\\n    int minDistance(vector<int>& houses, int k) {\\n        \\n        sort(houses.begin(), houses.end());\\n        \\n        if(houses.size() == k)\\n            return 0;\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int ans = solve(houses, k, 0);\\n        \\n        return ans;\\n    }\\n    \\n    int solve(vector<int> houses, int k, int start)\\n    {\\n        if(k == 0 || start >= houses.size())\\n            return 0;\\n        \\n        if(t[k][start] != -1)\\n            return t[k][start];\\n        \\n        int ans = INT_MAX;\\n        int sum = 0;\\n        for(int end = start; end < houses.size(); end++)\\n            if(k != 1 || end == houses.size() - 1)\\n            {\\n                int sum = find(houses, start, end); //find the median from start till end and then the sum of the  differences.\\n                ans = min(ans, sum + solve(houses, k - 1, end + 1));\\n            }\\n        \\n        return t[k][start] = ans;\\n    }\\n    \\n    int find(vector<int>& houses, int& start, int& end)\\n    {\\n        int size = end - start + 1;\\n        \\n        int res;\\n        if(size & 1) // if size is odd\\n            res = houses[start + (end - start) / 2];\\n        \\n        else // if size is even\\n        {\\n            int temp1 = start + (end - start) / 2;\\n            res = (houses[temp1] + houses[temp1 + 1]) / 2;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = start; i <= end; i++)\\n            sum += abs(houses[i] - res);\\n            \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[101][101];\\n    int minDistance(vector<int>& houses, int k) {\\n        \\n        sort(houses.begin(), houses.end());\\n        \\n        if(houses.size() == k)\\n            return 0;\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int ans = solve(houses, k, 0);\\n        \\n        return ans;\\n    }\\n    \\n    int solve(vector<int> houses, int k, int start)\\n    {\\n        if(k == 0 || start >= houses.size())\\n            return 0;\\n        \\n        if(t[k][start] != -1)\\n            return t[k][start];\\n        \\n        int ans = INT_MAX;\\n        int sum = 0;\\n        for(int end = start; end < houses.size(); end++)\\n            if(k != 1 || end == houses.size() - 1)\\n            {\\n                int sum = find(houses, start, end); //find the median from start till end and then the sum of the  differences.\\n                ans = min(ans, sum + solve(houses, k - 1, end + 1));\\n            }\\n        \\n        return t[k][start] = ans;\\n    }\\n    \\n    int find(vector<int>& houses, int& start, int& end)\\n    {\\n        int size = end - start + 1;\\n        \\n        int res;\\n        if(size & 1) // if size is odd\\n            res = houses[start + (end - start) / 2];\\n        \\n        else // if size is even\\n        {\\n            int temp1 = start + (end - start) / 2;\\n            res = (houses[temp1] + houses[temp1 + 1]) / 2;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = start; i <= end; i++)\\n            sum += abs(houses[i] - res);\\n            \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143482,
                "title": "java-simple-median",
                "content": "```\\nclass Solution {\\n    int[][] costs;\\n    int[][] dp;\\n    public int minDistance(int[] houses, int k) {\\n        int len = houses.length;\\n        if(len == k) return 0;\\n        Arrays.sort(houses);\\n        costs = new int[len][len];\\n        dp = new int[k][len];\\n        for(int i = 0; i < len; i++) {\\n            for(int j = i; j < len; j++) {\\n                int mid = houses[(i+j)/2];\\n                for(int l = i; l <= j; l++) {\\n                    costs[i][j] += (Math.abs(houses[l]-mid));\\n                }\\n            }\\n        } \\n        for(int i = 0; i < k; i++) {\\n            for(int j = 0; j < len; j++) {\\n                dp[i][j] = Integer.MIN_VALUE;\\n            }\\n        }\\n        \\n        return minDistance(houses, k, 0);\\n    }\\n    \\n    private int minDistance(int[] houses, int k, int i) {\\n        int len = houses.length;\\n        if(i == len && k == 0) return 0;\\n        if(i == len || k == 0) return Integer.MAX_VALUE;\\n        if(dp[k-1][i] != Integer.MIN_VALUE) return dp[k-1][i];\\n        int res = Integer.MAX_VALUE;\\n        for(int j = i; j < len; j++) {\\n            int tmpRes = minDistance(houses, k-1, j+1);\\n            if(tmpRes != Integer.MAX_VALUE) {\\n                res = Math.min(tmpRes + costs[i][j], res);\\n            }       \\n        }\\n        dp[k-1][i] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] costs;\\n    int[][] dp;\\n    public int minDistance(int[] houses, int k) {\\n        int len = houses.length;\\n        if(len == k) return 0;\\n        Arrays.sort(houses);\\n        costs = new int[len][len];\\n        dp = new int[k][len];\\n        for(int i = 0; i < len; i++) {\\n            for(int j = i; j < len; j++) {\\n                int mid = houses[(i+j)/2];\\n                for(int l = i; l <= j; l++) {\\n                    costs[i][j] += (Math.abs(houses[l]-mid));\\n                }\\n            }\\n        } \\n        for(int i = 0; i < k; i++) {\\n            for(int j = 0; j < len; j++) {\\n                dp[i][j] = Integer.MIN_VALUE;\\n            }\\n        }\\n        \\n        return minDistance(houses, k, 0);\\n    }\\n    \\n    private int minDistance(int[] houses, int k, int i) {\\n        int len = houses.length;\\n        if(i == len && k == 0) return 0;\\n        if(i == len || k == 0) return Integer.MAX_VALUE;\\n        if(dp[k-1][i] != Integer.MIN_VALUE) return dp[k-1][i];\\n        int res = Integer.MAX_VALUE;\\n        for(int j = i; j < len; j++) {\\n            int tmpRes = minDistance(houses, k-1, j+1);\\n            if(tmpRes != Integer.MAX_VALUE) {\\n                res = Math.min(tmpRes + costs[i][j], res);\\n            }       \\n        }\\n        dp[k-1][i] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995761,
                "title": "javascript-answer-92",
                "content": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n    let n = houses.length;\\n    let sorted = houses.sort((a,b)=> a-b)\\n    costs = new Array(n)\\n    for (let i = 0; i < n;i++){\\n        costs[i] = new Array(n).fill(0)\\n    }\\n    const memo = new Array(100)\\n    \\n    for (let i = 0; i < 100;i++){\\n        memo[i] = new Array(100)\\n    }\\n    \\n    for (let i = 0 ; i < n ; i++){\\n        for (let j = 0; j < n ; j++){\\n            let median = sorted[Math.floor((i+j)/2)]\\n            for (let t = i; t < j+1; t++){\\n                costs[i][j] += Math.abs(median - sorted[t])\\n            }\\n        }\\n    }\\n\\n    const dp = (k, i ) => {\\n        if (k ===0 && i === n) return 0;\\n        if (k ===0 || i === n) return Infinity;\\n        if (memo[k][i] != null) return memo[k][i]\\n        let ans = Infinity\\n        for (let j = i; j < n;j++){\\n            let cost = costs[i][j]\\n            ans = Math.min(ans , cost + dp(k-1,j+1))\\n        }\\n        memo[k][i] = ans\\n        return ans\\n    }\\n    \\n    return dp(k, 0)\\n};\\n```\\n\\ncredits go to hiepit for explaining the solution\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n    let n = houses.length;\\n    let sorted = houses.sort((a,b)=> a-b)\\n    costs = new Array(n)\\n    for (let i = 0; i < n;i++){\\n        costs[i] = new Array(n).fill(0)\\n    }\\n    const memo = new Array(100)\\n    \\n    for (let i = 0; i < 100;i++){\\n        memo[i] = new Array(100)\\n    }\\n    \\n    for (let i = 0 ; i < n ; i++){\\n        for (let j = 0; j < n ; j++){\\n            let median = sorted[Math.floor((i+j)/2)]\\n            for (let t = i; t < j+1; t++){\\n                costs[i][j] += Math.abs(median - sorted[t])\\n            }\\n        }\\n    }\\n\\n    const dp = (k, i ) => {\\n        if (k ===0 && i === n) return 0;\\n        if (k ===0 || i === n) return Infinity;\\n        if (memo[k][i] != null) return memo[k][i]\\n        let ans = Infinity\\n        for (let j = i; j < n;j++){\\n            let cost = costs[i][j]\\n            ans = Math.min(ans , cost + dp(k-1,j+1))\\n        }\\n        memo[k][i] = ans\\n        return ans\\n    }\\n    \\n    return dp(k, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992357,
                "title": "simple-dp-solution-with-o-k-n-2-time-and-o-k-n-space-complexity",
                "content": "```\\nclass Solution {\\n        \\n    public int minDistance(int[] houses, int k) {\\n        \\n        // If we have more or equal mailBoxes to houses, then we can place\\n        // one mail box in each house\\n        if (k >= houses.length)\\n            return 0;\\n        \\n        Arrays.sort(houses);\\n        \\n        // Create a sum array of each index from 0 index\\n        int[] sumArray = createSumArray(houses);\\n        \\n        int[][] memo = new int[k+1][houses.length+1];\\n        \\n        for(int i=2; i<=houses.length; ++i)\\n            memo[1][i] = findDistance(1, i, sumArray, houses);\\n        \\n        for(int mailBox=2; mailBox <= k; ++mailBox) {\\n            // This loop decides the last house that we need to cover\\n            for(int tillHouse=mailBox; tillHouse <= houses.length; ++tillHouse) {\\n                int minValue = Integer.MAX_VALUE;\\n                // This loop partitions and checks whether current partition makes low value\\n                for(int partition=1; partition<tillHouse; ++partition) {\\n                    int curValue = memo[mailBox-1][partition] + \\n                        findDistance(partition+1, tillHouse, sumArray, houses);\\n                    minValue = Math.min(minValue, curValue);\\n                }\\n                memo[mailBox][tillHouse] = minValue;\\n            }\\n        }\\n        return memo[k][houses.length];\\n    }\\n    \\n    /*\\n    we create a sum array to make range sum in constant time\\n    Index   :     0  1  2  3. 4\\n    houses  :    [1, 2, 3, 4, 5]\\n\\n    Index   :  0  1  2  3  4   5\\n    sumArray: [0, 1, 3, 6, 10, 15]\\n    Find sum between index(1-3) = sumArray(3) -sumArray(1-0) \\n                                = sumArray(3) -sumArray(1) \\n                                = 10 - 1\\n                                = 9\\n    */\\n    private int[] createSumArray(int[] houses) {\\n        int[] sumArray = new int[houses.length+1];\\n        for(int i=1; i<=houses.length; ++i)\\n            sumArray[i] = sumArray[i-1] + houses[i-1];\\n        return sumArray;\\n    }\\n    \\n    private int sum(int i, int j, int[] sumArray) {\\n        return sumArray[j] - sumArray[i-1];\\n    }    \\n    \\n    /*\\n    Using the sumArray and houses, we can find the distance of all the house to \\n    the midHouse in constant time\\n    \\n    houses: 1 4 8 10\\n    midhouse: (1 + 4)/2 = 2nd house\\n    our value should be = 4-1 + 8-4 + 10-4\\n                        = 1*4 - (1) + (8+10) - 2*4\\n                        = 1*4 - sum(1 to 1) + sum(8 to 10) - 2*4\\n                        = 4 - 1 + 18 - 8\\n                        = 13\\n    */\\n    private int findDistance(int i, int j, int[] sumArray, int[] houses) {\\n        if (i == j)\\n            return 0;\\n        int midHouse = (i+j)/2;\\n        \\n        int leftHouseCount = midHouse - i, \\n            rightHouseCount = j - midHouse;\\n        int leftSum = sum(i, midHouse-1 , sumArray), \\n            rightSum = sum(midHouse+1, j, sumArray);\\n        \\n        return rightSum - rightHouseCount*houses[midHouse-1] + leftHouseCount*houses[midHouse-1] - leftSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    public int minDistance(int[] houses, int k) {\\n        \\n        // If we have more or equal mailBoxes to houses, then we can place\\n        // one mail box in each house\\n        if (k >= houses.length)\\n            return 0;\\n        \\n        Arrays.sort(houses);\\n        \\n        // Create a sum array of each index from 0 index\\n        int[] sumArray = createSumArray(houses);\\n        \\n        int[][] memo = new int[k+1][houses.length+1];\\n        \\n        for(int i=2; i<=houses.length; ++i)\\n            memo[1][i] = findDistance(1, i, sumArray, houses);\\n        \\n        for(int mailBox=2; mailBox <= k; ++mailBox) {\\n            // This loop decides the last house that we need to cover\\n            for(int tillHouse=mailBox; tillHouse <= houses.length; ++tillHouse) {\\n                int minValue = Integer.MAX_VALUE;\\n                // This loop partitions and checks whether current partition makes low value\\n                for(int partition=1; partition<tillHouse; ++partition) {\\n                    int curValue = memo[mailBox-1][partition] + \\n                        findDistance(partition+1, tillHouse, sumArray, houses);\\n                    minValue = Math.min(minValue, curValue);\\n                }\\n                memo[mailBox][tillHouse] = minValue;\\n            }\\n        }\\n        return memo[k][houses.length];\\n    }\\n    \\n    /*\\n    we create a sum array to make range sum in constant time\\n    Index   :     0  1  2  3. 4\\n    houses  :    [1, 2, 3, 4, 5]\\n\\n    Index   :  0  1  2  3  4   5\\n    sumArray: [0, 1, 3, 6, 10, 15]\\n    Find sum between index(1-3) = sumArray(3) -sumArray(1-0) \\n                                = sumArray(3) -sumArray(1) \\n                                = 10 - 1\\n                                = 9\\n    */\\n    private int[] createSumArray(int[] houses) {\\n        int[] sumArray = new int[houses.length+1];\\n        for(int i=1; i<=houses.length; ++i)\\n            sumArray[i] = sumArray[i-1] + houses[i-1];\\n        return sumArray;\\n    }\\n    \\n    private int sum(int i, int j, int[] sumArray) {\\n        return sumArray[j] - sumArray[i-1];\\n    }    \\n    \\n    /*\\n    Using the sumArray and houses, we can find the distance of all the house to \\n    the midHouse in constant time\\n    \\n    houses: 1 4 8 10\\n    midhouse: (1 + 4)/2 = 2nd house\\n    our value should be = 4-1 + 8-4 + 10-4\\n                        = 1*4 - (1) + (8+10) - 2*4\\n                        = 1*4 - sum(1 to 1) + sum(8 to 10) - 2*4\\n                        = 4 - 1 + 18 - 8\\n                        = 13\\n    */\\n    private int findDistance(int i, int j, int[] sumArray, int[] houses) {\\n        if (i == j)\\n            return 0;\\n        int midHouse = (i+j)/2;\\n        \\n        int leftHouseCount = midHouse - i, \\n            rightHouseCount = j - midHouse;\\n        int leftSum = sum(i, midHouse-1 , sumArray), \\n            rightSum = sum(midHouse+1, j, sumArray);\\n        \\n        return rightSum - rightHouseCount*houses[midHouse-1] + leftHouseCount*houses[midHouse-1] - leftSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861951,
                "title": "java-simple-dp-with-explaination-beats-100-o-n-2-k-nlgn",
                "content": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        if(n==1 || k==n) return 0;\\n        Arrays.sort(houses);\\n        \\n        \\n        //G(x,y), When there is only 1 mailbox form House x to House y , \\n        //  people in House x to y need to walk at a sum of G(x,y); \\n        \\n        int[][] distance = new int[n][n];\\n        for (int x = 0; x < n; x++) \\n            for (int y = x; y < n; y++) \\n                    distance[x][y] = x == y ? 0 : distance[x][y-1] + houses[y] - houses[(x+y)/2];\\n        \\n        //F(a,N), When there are exactly a mailboxes form House 0 to House N,\\n        //  people in House 0 to N need to walk at a sum of F(a,N); \\n        \\n        //if we get all probable F(a-1,??) ,then we just add another mailbox to the street;\\n        // we will get F(a,N).  The range of ?? is (a-1,N-1).\\n        \\n        \\n        int[][] distanceSum = new int[k][n];\\n        for (int N = 0; N < n+1-k; N++) distanceSum[0][N] = distance[0][N];\\n\\n        for (int a = 1; a < k; a++) \\n            for (int N = 0; N < n+a-k+1; N++) {\\n                int min = Integer.MAX_VALUE;\\n                for (int i = a-1; i < N; i++) \\n                    min = Math.min(min,distanceSum[a-1][i]+distance[i+1][N]);\\n                distanceSum[a][N] = min;\\n            }\\n        \\n        return distanceSum[k-1][n-1];\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        if(n==1 || k==n) return 0;\\n        Arrays.sort(houses);\\n        \\n        \\n        //G(x,y), When there is only 1 mailbox form House x to House y , \\n        //  people in House x to y need to walk at a sum of G(x,y); \\n        \\n        int[][] distance = new int[n][n];\\n        for (int x = 0; x < n; x++) \\n            for (int y = x; y < n; y++) \\n                    distance[x][y] = x == y ? 0 : distance[x][y-1] + houses[y] - houses[(x+y)/2];\\n        \\n        //F(a,N), When there are exactly a mailboxes form House 0 to House N,\\n        //  people in House 0 to N need to walk at a sum of F(a,N); \\n        \\n        //if we get all probable F(a-1,??) ,then we just add another mailbox to the street;\\n        // we will get F(a,N).  The range of ?? is (a-1,N-1).\\n        \\n        \\n        int[][] distanceSum = new int[k][n];\\n        for (int N = 0; N < n+1-k; N++) distanceSum[0][N] = distance[0][N];\\n\\n        for (int a = 1; a < k; a++) \\n            for (int N = 0; N < n+a-k+1; N++) {\\n                int min = Integer.MAX_VALUE;\\n                for (int i = a-1; i < N; i++) \\n                    min = Math.min(min,distanceSum[a-1][i]+distance[i+1][N]);\\n                distanceSum[a][N] = min;\\n            }\\n        \\n        return distanceSum[k-1][n-1];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818319,
                "title": "rust-translated",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_distance(mut houses: Vec<i32>, k: i32) -> i32 {\\n        fn helper(h: &[i32], start: i32, k: i32, memo: &mut Vec<Vec<i32>>) -> i32 {\\n            if k == 1 {\\n                let end = h.len() as i32 - 1;\\n                let med = (end - start) / 2 + start;\\n                let mean = h[med as usize];\\n                return h\\n                    .iter()\\n                    .skip(start as usize)\\n                    .fold(0, |acc, &x| acc + (x - mean).abs());\\n            }\\n            if memo[start as usize][k as usize] != -1 {\\n                return memo[start as usize][k as usize];\\n            }\\n            let mut t = start;\\n            let mut ans = std::i32::MAX;\\n            while h.len() as i32 - 1 - t >= k - 1 {\\n                let med = (t - start) / 2 + start;\\n                let mut res = 0;\\n                for i in start..=t {\\n                    res += (h[i as usize] - h[med as usize]).abs();\\n                }\\n                res += helper(h, t + 1, k - 1, memo);\\n                if ans > res {\\n                    ans = res\\n                }\\n                t += 1;\\n            }\\n            memo[start as usize][k as usize] = ans;\\n            ans\\n        }\\n\\n        let n = houses.len();\\n        if k >= n as i32 {\\n            return 0;\\n        }\\n        houses.sort();\\n        let mut memo = vec![vec![-1; k as usize + 1]; n];\\n        helper(&houses, 0, k, &mut memo)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_distance() {\\n        assert_eq!(Solution::min_distance(vec![1, 4, 8, 10, 20], 3), 5)\\n    }\\n\\n    #[test]\\n    fn test_min_distance_02() {\\n        assert_eq!(Solution::min_distance(vec![2, 3, 5, 12, 18], 2), 9)\\n    }\\n\\n    #[test]\\n    fn test_min_distance_03() {\\n        assert_eq!(Solution::min_distance(vec![7, 4, 6, 1], 1), 8)\\n    }\\n\\n    #[test]\\n    fn test_min_distance_04() {\\n        assert_eq!(Solution::min_distance(vec![3, 6, 14, 10], 4), 0)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_distance(mut houses: Vec<i32>, k: i32) -> i32 {\\n        fn helper(h: &[i32], start: i32, k: i32, memo: &mut Vec<Vec<i32>>) -> i32 {\\n            if k == 1 {\\n                let end = h.len() as i32 - 1;\\n                let med = (end - start) / 2 + start;\\n                let mean = h[med as usize];\\n                return h\\n                    .iter()\\n                    .skip(start as usize)\\n                    .fold(0, |acc, &x| acc + (x - mean).abs());\\n            }\\n            if memo[start as usize][k as usize] != -1 {\\n                return memo[start as usize][k as usize];\\n            }\\n            let mut t = start;\\n            let mut ans = std::i32::MAX;\\n            while h.len() as i32 - 1 - t >= k - 1 {\\n                let med = (t - start) / 2 + start;\\n                let mut res = 0;\\n                for i in start..=t {\\n                    res += (h[i as usize] - h[med as usize]).abs();\\n                }\\n                res += helper(h, t + 1, k - 1, memo);\\n                if ans > res {\\n                    ans = res\\n                }\\n                t += 1;\\n            }\\n            memo[start as usize][k as usize] = ans;\\n            ans\\n        }\\n\\n        let n = houses.len();\\n        if k >= n as i32 {\\n            return 0;\\n        }\\n        houses.sort();\\n        let mut memo = vec![vec![-1; k as usize + 1]; n];\\n        helper(&houses, 0, k, &mut memo)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_distance() {\\n        assert_eq!(Solution::min_distance(vec![1, 4, 8, 10, 20], 3), 5)\\n    }\\n\\n    #[test]\\n    fn test_min_distance_02() {\\n        assert_eq!(Solution::min_distance(vec![2, 3, 5, 12, 18], 2), 9)\\n    }\\n\\n    #[test]\\n    fn test_min_distance_03() {\\n        assert_eq!(Solution::min_distance(vec![7, 4, 6, 1], 1), 8)\\n    }\\n\\n    #[test]\\n    fn test_min_distance_04() {\\n        assert_eq!(Solution::min_distance(vec![3, 6, 14, 10], 4), 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711155,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinDistance(int[] houses, int k) \\n    {\\n        Array.Sort(houses);\\n        int[,] costs = new int[100, 100];\\n        for (int i = 0; i < houses.Length; i++)\\n            for (int j = 0; j < houses.Length; j++)\\n                for (int t = i; t <= j; t++)\\n                    costs[i, j] += Math.Abs(houses[(i + j) / 2] - houses[t]);\\n        return MinDistance(houses, k, 0, new int[100, 100], costs);\\n    }\\n    \\n    int MinDistance(int[] houses, int k, int i, int[,] memo, int[,] costs)\\n    {\\n        if (k == 0 && i == houses.Length) return 0;\\n        if (k == 0 || i == houses.Length) return 1000000;\\n        if (memo[k, i] != 0) return memo[k, i];\\n        int ans = 1000000;\\n        for (int j = i; j < houses.Length; j++)\\n            ans = Math.Min(ans, costs[i, j] + MinDistance(houses, k-1, j + 1, memo, costs));\\n        return memo[k, i] = ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinDistance(int[] houses, int k) \\n    {\\n        Array.Sort(houses);\\n        int[,] costs = new int[100, 100];\\n        for (int i = 0; i < houses.Length; i++)\\n            for (int j = 0; j < houses.Length; j++)\\n                for (int t = i; t <= j; t++)\\n                    costs[i, j] += Math.Abs(houses[(i + j) / 2] - houses[t]);\\n        return MinDistance(houses, k, 0, new int[100, 100], costs);\\n    }\\n    \\n    int MinDistance(int[] houses, int k, int i, int[,] memo, int[,] costs)\\n    {\\n        if (k == 0 && i == houses.Length) return 0;\\n        if (k == 0 || i == houses.Length) return 1000000;\\n        if (memo[k, i] != 0) return memo[k, i];\\n        int ans = 1000000;\\n        for (int j = i; j < houses.Length; j++)\\n            ans = Math.Min(ans, costs[i, j] + MinDistance(houses, k-1, j + 1, memo, costs));\\n        return memo[k, i] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688702,
                "title": "c-ride-the-lightning-dp-8ms-linear-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(), houses.end());\\n        int n = houses.size();\\n        int dp[101] = { 0 };\\n        for (int j = 1, T = 0; j < n; ++j)\\n            dp[j] = T += houses[j] - houses[j / 2];\\n        \\n        for (int i = 1; i < k; ++i) {\\n            for (int j = n; j-- > i;) {\\n                dp[j] = dp[j - 1];\\n                for (int T = 0, t = 1; t <= j - i;) {\\n                    T += houses[j - t / 2] - houses[j - t];\\n                    dp[j] = min(dp[j], T + dp[j - ++t]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(), houses.end());\\n        int n = houses.size();\\n        int dp[101] = { 0 };\\n        for (int j = 1, T = 0; j < n; ++j)\\n            dp[j] = T += houses[j] - houses[j / 2];\\n        \\n        for (int i = 1; i < k; ++i) {\\n            for (int j = n; j-- > i;) {\\n                dp[j] = dp[j - 1];\\n                for (int T = 0, t = 1; t <= j - i;) {\\n                    T += houses[j - t / 2] - houses[j - t];\\n                    dp[j] = min(dp[j], T + dp[j - ++t]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688334,
                "title": "python-dp-sliding-median-detailed-explanation",
                "content": "dp(idx,k) means the minimal cost assigning \"k\" mailboxes \"at and after\" houses[idx]. dp(0,k) is the final result.\\nInside dp, we assign one mail box to a range of houses: houses[idx]~houses[idx2], and assign the rest \"k-1\" boxes to the rest houses, which is dp(idx2, k-1).\\nThe minimal cost assigning 1 box to \"x\" house equals the total distance to the \"median\" house. In case there are \"two medians\", both medians produces the same minimal cost, so we can pick any.\\n\\nTime complexity:\\nDP has 2 inputs, which is O(nk), inside dp there is a \"for\" loop assigning 1 box to all different house ranges, which is O(n), inside \"for\" loop, calculating minimal cost for \"x\" houses takes O(n). Total time: O(kn^3)\\n\\nWe can further improve it by reducing the time computing minimal cost of \"x\" houses to O(1) using a \"sliding median\" approach. This way, total time becomes O(kn^2)\\n\\nSliding Median:\\nAssuming we already know the minimal cost of \"a,b,c\", which is the total distance to median point \"b\".\\nNow a new point \"d\" added to the right, what will the total cost be? Just adding \"d->b\" to the total cost. Because for \"a,b,c,d\", both \"b\" and \"c\" can be the median point and they have the same cost. We take \"b\" as median point so that result of \"a,b,c\" can be directly reused, and \"d\" goes to \"b\" because \"b\" is the median point.\\nNow another point \"e\" comes, what will the total cost be? Just adding \"e->c\" to the total cost. Why? Because for \"a,b,c,d\", both \"b\" and \"c\" can be the median point and they have the same cost. We take \"c\" as median point because \"c\" is the only median point for \"a,b,c,d,e\", and result of \"a,b,c,d\" can be reused because \"c\" is also the median of \"a,b,c,d\".\\nIn conclusion: adding \"x->x//2\" to the total cost, and we can get minimal cost ending at \"x\" in O(1) time.\\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        @functools.lru_cache(None)\\n        def dp(idx,k2):\\n            if k2>=(len(houses)-idx):\\n                return 0\\n            res,cost=math.inf,0\\n            for i in range(idx,len(houses)):\\n                cost+=houses[i]-houses[(i+idx)//2] # sliding median\\n                res=min(res,dp(i+1,k2-1)+cost)\\n            return res\\n        return dp(0,k)\\n```",
                "solutionTags": [],
                "code": "```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        @functools.lru_cache(None)\\n        def dp(idx,k2):\\n            if k2>=(len(houses)-idx):\\n                return 0\\n            res,cost=math.inf,0\\n            for i in range(idx,len(houses)):\\n                cost+=houses[i]-houses[(i+idx)//2] # sliding median\\n                res=min(res,dp(i+1,k2-1)+cost)\\n            return res\\n        return dp(0,k)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 686039,
                "title": "java-dp",
                "content": "dp[i][k]: minimum total distance when k mailboxes are allocated among houses[0:i]\\ndp[i][k] = min( dp[j][k-1] + distances[j+1][i] ), j = 0... i-1\\ndistances[j+1][i]: minimum total distance when one mailbox is allocated among houses[j+1:i]\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int K) {\\n        Arrays.sort(houses);\\n        int N = houses.length;\\n        int[][] dp = new int[N][K+1];\\n        int[][] distances = preprocess(houses);\\n        for( int i = 0; i < N; i++ ){\\n            dp[i][1] = distances[0][i];\\n        } \\n        for( int k = 2; k <= K; k++ ){\\n            for( int j = 1; j < N; j++ ){\\n                dp[j][k] = Integer.MAX_VALUE;\\n                for( int i = 0; i < j; i++ ){\\n                    dp[j][k] = Math.min(dp[j][k], dp[i][k-1] + distances[i+1][j]);\\n                }\\n            }\\n        }\\n        return dp[N-1][K];\\n    }\\n    \\n    // pre-preocess to compute the min total distance between houses[i] and houses[j]\\n    private int[][] preprocess(int[] houses){\\n        int N = houses.length;\\n        int[][] distances = new int[N][N];\\n        for( int i = 0; i < N; i++ ){\\n            for( int j = i+1; j < N; j++ ){\\n                distances[i][j] = getDistance(houses, i, j);\\n            }\\n        }\\n        return distances;\\n    }\\n    \\n    private int getDistance(int[] houses, int start, int end){\\n        int total = 0;\\n        while( start < end ){\\n            total += (houses[end] - houses[start]);\\n            start++;\\n            end--;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int K) {\\n        Arrays.sort(houses);\\n        int N = houses.length;\\n        int[][] dp = new int[N][K+1];\\n        int[][] distances = preprocess(houses);\\n        for( int i = 0; i < N; i++ ){\\n            dp[i][1] = distances[0][i];\\n        } \\n        for( int k = 2; k <= K; k++ ){\\n            for( int j = 1; j < N; j++ ){\\n                dp[j][k] = Integer.MAX_VALUE;\\n                for( int i = 0; i < j; i++ ){\\n                    dp[j][k] = Math.min(dp[j][k], dp[i][k-1] + distances[i+1][j]);\\n                }\\n            }\\n        }\\n        return dp[N-1][K];\\n    }\\n    \\n    // pre-preocess to compute the min total distance between houses[i] and houses[j]\\n    private int[][] preprocess(int[] houses){\\n        int N = houses.length;\\n        int[][] distances = new int[N][N];\\n        for( int i = 0; i < N; i++ ){\\n            for( int j = i+1; j < N; j++ ){\\n                distances[i][j] = getDistance(houses, i, j);\\n            }\\n        }\\n        return distances;\\n    }\\n    \\n    private int getDistance(int[] houses, int start, int end){\\n        int total = 0;\\n        while( start < end ){\\n            total += (houses[end] - houses[start]);\\n            start++;\\n            end--;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685903,
                "title": "python-just-for-fun-lloyd-s-algorithm",
                "content": "The problem is a 1D K means clustering problem. So I went into the wrong direction when I tried to implement the solution. Now the code is just for fun.\\n\\nI didn\\'t manage to trick the judge and get accepted. As we know, Lloyd\\'s algorithm can land into a local minimum. If we increase the number of interations, we will increase the likelihood to reach the global minimum. But I got TLE if I tried to increase the `num_iter` to 1000 already.\\n```\\nclass Solution:\\n    def minDistance(self, A, k):\\n        if k >= len(A): return 0\\n        \\n        def assign(centers):\\n            clusters = defaultdict(list)\\n            for house in A:\\n                key = min([(abs(c-house), i) for i, c in enumerate(centers)])[1]\\n                clusters[key].append(house)\\n            return clusters\\n        \\n        def reevaluate(centers, clusters):\\n            new_centers = []\\n            for key in range(k):\\n                if key in clusters:\\n                    new_centers.append(ceil(mean(clusters[key])))\\n                else:\\n                    new_centers.append(centers[key])\\n            return new_centers\\n        \\n        A.sort()\\n\\n        dist = math.inf\\n        num_iter = 1000\\n        for _ in range(num_iter):\\n            centers = [random.randint(A[0], A[-1]) for _ in range(k)]\\n            new_centers = copy.deepcopy(centers)\\n            new_centers[0] += 1 # to ensure centers != new_centers initially\\n            while centers != new_centers:\\n                centers = new_centers\\n                clusters = assign(centers)\\n                new_centers = reevaluate(centers, clusters)\\n                curr_dist = 0\\n                for key in range(k):\\n                    curr_dist += sum([abs(centers[key]-house) for house in clusters[key]])\\n                dist = min(dist, curr_dist)\\n            \\n            \\n        return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, A, k):\\n        if k >= len(A): return 0\\n        \\n        def assign(centers):\\n            clusters = defaultdict(list)\\n            for house in A:\\n                key = min([(abs(c-house), i) for i, c in enumerate(centers)])[1]\\n                clusters[key].append(house)\\n            return clusters\\n        \\n        def reevaluate(centers, clusters):\\n            new_centers = []\\n            for key in range(k):\\n                if key in clusters:\\n                    new_centers.append(ceil(mean(clusters[key])))\\n                else:\\n                    new_centers.append(centers[key])\\n            return new_centers\\n        \\n        A.sort()\\n\\n        dist = math.inf\\n        num_iter = 1000\\n        for _ in range(num_iter):\\n            centers = [random.randint(A[0], A[-1]) for _ in range(k)]\\n            new_centers = copy.deepcopy(centers)\\n            new_centers[0] += 1 # to ensure centers != new_centers initially\\n            while centers != new_centers:\\n                centers = new_centers\\n                clusters = assign(centers)\\n                new_centers = reevaluate(centers, clusters)\\n                curr_dist = 0\\n                for key in range(k):\\n                    curr_dist += sum([abs(centers[key]-house) for house in clusters[key]])\\n                dist = min(dist, curr_dist)\\n            \\n            \\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685585,
                "title": "python-short-dp-solution-no-dfs",
                "content": "```python\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n\\tdef calc(i, j):\\n\\t\\tm = (i + j) // 2\\n\\t\\treturn sum([abs(h - houses[m]) for h in houses[i:j]])\\n\\n\\thouses.sort()\\n\\tH = len(houses)\\n\\tdp = [[float(\\'inf\\') for _ in range(k+1)] for _ in range(H+1)]\\n\\tfor i in range(1, H+1):\\n\\t\\tdp[i][1] = calc(0, i)\\n\\tfor j in range(2, k+1):  # use j mail boxes\\n\\t\\tfor i in range(j, H+1):  # only consider the first i houses\\n\\t\\t\\tfor x in range(j-1, i):\\n\\t\\t\\t\\t# the last mail box serves for houses[x:i]\\n\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[x][j-1] + calc(x, i))\\n\\treturn dp[H][k]\\n```\\n\\nI believe there\\'s a faster solution, since the `min` function updates only several times then it won\\'t be updated again, if we reverse x range\\'s direction (`for x in range(i-1, j-2, -1)`). However, I cannot find the condition that allows us to break x\\'s for loop earlier.",
                "solutionTags": [],
                "code": "```python\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n\\tdef calc(i, j):\\n\\t\\tm = (i + j) // 2\\n\\t\\treturn sum([abs(h - houses[m]) for h in houses[i:j]])\\n\\n\\thouses.sort()\\n\\tH = len(houses)\\n\\tdp = [[float(\\'inf\\') for _ in range(k+1)] for _ in range(H+1)]\\n\\tfor i in range(1, H+1):\\n\\t\\tdp[i][1] = calc(0, i)\\n\\tfor j in range(2, k+1):  # use j mail boxes\\n\\t\\tfor i in range(j, H+1):  # only consider the first i houses\\n\\t\\t\\tfor x in range(j-1, i):\\n\\t\\t\\t\\t# the last mail box serves for houses[x:i]\\n\\t\\t\\t\\tdp[i][j] = min(dp[i][j], dp[x][j-1] + calc(x, i))\\n\\treturn dp[H][k]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685427,
                "title": "python-top-down-short-concise-readable-with-explanation",
                "content": "**Intuition**\\nWe guess a range of houses that share a mailbox \\nWe try to put a mailbox in the middle of our range and calculate the cost\\nUnlike the picture in the description, we always place a mailbox at a house and not between houses\\nThis may not be fair to some houses but it leads to an optimal solution\\n\\n```python\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        \\n        @lru_cache(None)\\n        def min_distance(start, left):\\n            if start == len(houses):\\n                return 0 if left == 0 else float(\\'inf\\')\\n            \\n            distance = float(\\'inf\\')\\n            \\n            for end in range(start, len(houses)):\\n                box = houses[(end + start) // 2]\\n                cost = sum(abs(num - box) for num in islice(houses, start, end + 1))\\n                distance = min(distance, cost + min_distance(end + 1, left - 1))\\n\\n            return distance\\n        \\n        return min_distance(0, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        \\n        @lru_cache(None)\\n        def min_distance(start, left):\\n            if start == len(houses):\\n                return 0 if left == 0 else float(\\'inf\\')\\n            \\n            distance = float(\\'inf\\')\\n            \\n            for end in range(start, len(houses)):\\n                box = houses[(end + start) // 2]\\n                cost = sum(abs(num - box) for num in islice(houses, start, end + 1))\\n                distance = min(distance, cost + min_distance(end + 1, left - 1))\\n\\n            return distance\\n        \\n        return min_distance(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685369,
                "title": "python-3-dynamic-programming-dp-iterative-solution",
                "content": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        n = len(houses)\\n        houses.sort()\\n        dp = [0 for i in range(n)]\\n        dp[0] = 0\\n        sudo = 0\\n        for i in range(1 , n):\\n            sudo += i * (houses[i] - houses[i - 1])\\n            dp[i] = sudo\\n        for b in range(2 , k + 1):\\n            for i in range(n - 1 , -1 , -1):\\n                if i == 0:\\n                    cur_temp = 0\\n                else:\\n                    cur_temp = dp[i - 1]\\n                dist = 0\\n                cur_pos = i\\n                for j in range(i - 2 , -1 , -1):\\n                    dist += (cur_pos - 1 - j) * (houses[j + 1] - houses[j])\\n                    while cur_pos > j and 2 * houses[cur_pos - 1] >= houses[i] + houses[j]:\\n                        cur_pos -= 1\\n                        dist -= 2 * houses[cur_pos] - houses[i] - houses[j]\\n                    cur_temp = min(cur_temp , dp[j] + dist)\\n                dp[i] = cur_temp\\n        ans = dp[n - 1]\\n        sudo = 0\\n        for i in range(n - 2 , -1 , -1):\\n            sudo += (n - 1 - i) * (houses[i + 1] - houses[i])\\n            ans = min(ans , sudo + dp[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        n = len(houses)\\n        houses.sort()\\n        dp = [0 for i in range(n)]\\n        dp[0] = 0\\n        sudo = 0\\n        for i in range(1 , n):\\n            sudo += i * (houses[i] - houses[i - 1])\\n            dp[i] = sudo\\n        for b in range(2 , k + 1):\\n            for i in range(n - 1 , -1 , -1):\\n                if i == 0:\\n                    cur_temp = 0\\n                else:\\n                    cur_temp = dp[i - 1]\\n                dist = 0\\n                cur_pos = i\\n                for j in range(i - 2 , -1 , -1):\\n                    dist += (cur_pos - 1 - j) * (houses[j + 1] - houses[j])\\n                    while cur_pos > j and 2 * houses[cur_pos - 1] >= houses[i] + houses[j]:\\n                        cur_pos -= 1\\n                        dist -= 2 * houses[cur_pos] - houses[i] - houses[j]\\n                    cur_temp = min(cur_temp , dp[j] + dist)\\n                dp[i] = cur_temp\\n        ans = dp[n - 1]\\n        sudo = 0\\n        for i in range(n - 2 , -1 , -1):\\n            sudo += (n - 1 - i) * (houses[i + 1] - houses[i])\\n            ans = min(ans , sudo + dp[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685363,
                "title": "c-o-n-3-bottom-up-dp",
                "content": "For each segment of sorted positions and one mailbox, the minimum sum of distances is achieved when the mailbox is at median position.\\n\\nsums[i][j] means minimum distance sum of one mailboxe regarding i to j houses.\\n\\nState definition: dp[k][i] means minimum distance sum of k mailboxes regarding 0 to i houses.\\nInitialization: dp[1][i] = sums[0][i]\\nInduction: dp[k][i] is min{dp[k - 1][j] + sums[j + 1][i], for all valid j}\\nResult: dp[k][n - 1]\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>> sums(n, vector<int>(n));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int m = houses[(i + j) / 2];\\n                int dist = 0;\\n                for (int l = i; l <= j; l++) {\\n                    dist += abs(houses[l] - m);\\n                }\\n                sums[i][j] = dist;\\n            }\\n        }\\n        vector<vector<int>> dp(k + 1, vector<int>(n, INT_MAX));\\n        for (int i = 0; i < n; i++) {\\n            dp[1][i] = sums[0][i];\\n        }\\n        for (int l = 2; l <= k; l++) {\\n            for (int i = l - 1; i < n; i++) {\\n                int dist = INT_MAX;\\n                for (int j = l - 2; j < i; j++) {\\n                    dist = min(dist, dp[l - 1][j] + sums[j + 1][i]);\\n                }\\n                dp[l][i] = dist;\\n            }\\n        }\\n        \\n        return dp[k][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>> sums(n, vector<int>(n));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i; j < n; j++) {\\n                int m = houses[(i + j) / 2];\\n                int dist = 0;\\n                for (int l = i; l <= j; l++) {\\n                    dist += abs(houses[l] - m);\\n                }\\n                sums[i][j] = dist;\\n            }\\n        }\\n        vector<vector<int>> dp(k + 1, vector<int>(n, INT_MAX));\\n        for (int i = 0; i < n; i++) {\\n            dp[1][i] = sums[0][i];\\n        }\\n        for (int l = 2; l <= k; l++) {\\n            for (int i = l - 1; i < n; i++) {\\n                int dist = INT_MAX;\\n                for (int j = l - 2; j < i; j++) {\\n                    dist = min(dist, dp[l - 1][j] + sums[j + 1][i]);\\n                }\\n                dp[l][i] = dist;\\n            }\\n        }\\n        \\n        return dp[k][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064966,
                "title": "it-is-always-beneficial-to-put-mailboxes-at-the-houses-only-no-need-of-median-and-middle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nso if you try to put one mailbox between two houses lets say x and y\\n\\nx  p  y --> where p is the position of mailbox\\n\\nthen p-x + y-p , for this two houses (x,y) there is no meaning for p we can put it anywhere\\n\\nlets say there are x1 houses in the left of x and x2 on the right of y which have p as nearest mailboxes\\n\\nthen value would be x1*p-sum_of_those_houses_position(in left)+\\n                    sum_of_those_houses_position(in right)-x2*p so we can see if x1>x2 then it is beneficial to be p = x and p=y otherewise     \\n\\n\\n# Complexity\\n- Time complexity:\\n- o(N*N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long int ll;\\n#define set set<int>\\n#define uset unordered_set<int> \\n#define veci vector<int> \\n#define vecs vector<string>\\n#define stack stack<int> \\n#define pb push_back\\n// #define mp make_pair\\n#define pii pair<int,int>\\n#define all(x) (x).begin(), (x).end() \\n#define FOR(s,n) for(int i = s; i < n; i++)\\n\\ntemplate<typename T> \\nostream& operator<<(ostream& COUT, vector<T>& v){ for(int i=0 ; i<v.size() ; i++){ COUT<<v[i]<<\" \"; } COUT << endl; return COUT; }\\ntemplate<typename T> \\nistream& operator>>(istream& CIN, vector<T>& a){ for(int i=0 ; i<a.size() ; i++) CIN>>a[i]; return CIN; }\\ntemplate<typename T> \\nvoid pws(const T& arg){ cout << arg <<endl;}\\ntemplate <typename T, typename... Args>\\nvoid pws(const T& first, const Args&... args) {cout << first << \" \";pws(args...);}\\n\\nint dir[8][2] = {{0,1},{1,0},{-1,0},{0,-1},{1,1},{-1,1},{1,-1},{-1,-1}};\\nint MOD = 1e9 + 7,inf=1e7;\\nint n,m,k;\\n\\nconst int N = 1e4+3,M=103;\\nint sum[N];\\nint cnt[N];\\nint mp[N];\\nint dp[M][M][M];\\n\\nint rec(int i,int prev,int k,veci& h){\\n    if(k<0) return inf;\\n    if(i==n){\\n        if(k!=0) return inf;\\n        else{\\n            int pval=h[prev];\\n            int temp= sum[N-1]-sum[pval]-(cnt[N-1]-cnt[pval])*pval;\\n            return temp;\\n        }\\n    }\\n    if(dp[i][prev][k]!=-1) return dp[i][prev][k];\\n    int loc = 0;\\n    int pos2 = rec(i+1,prev,k,h);\\n   if(prev!=101){\\n         int mid = (h[i]+h[prev])/2;\\n         int pval = h[prev],cval = h[i];\\n         int pos1= sum[mid+1]-sum[pval]-(cnt[mid+1]-cnt[pval])*pval;\\n         pos1+=(cnt[cval+1]-cnt[mid+1])*cval-(sum[cval+1]-sum[mid+1]);\\n         pos1+=rec(i+1,i,k-1,h); \\n         loc = min(pos1,pos2);\\n   }\\n   else{\\n    int pos1 = cnt[h[i]]*h[i]-sum[h[i]];\\n    int temp = pos1;\\n    pos1+=rec(i+1,i,k-1,h);\\n    \\n    loc = min(pos1,pos2);\\n   }\\n   return dp[i][prev][k]=loc;\\n}\\n\\n\\nclass Solution {\\npublic:\\n\\n   int minDistance(vector<int>& houses, int k) {\\n     n = houses.size();\\n     sort(all(houses));\\n\\n     memset(dp,-1,sizeof(dp));\\n     memset(mp,0,sizeof(mp));\\n     memset(cnt,0,sizeof(cnt));\\n     memset(sum,0,sizeof(sum));\\n\\n     for(int v:houses) mp[v]++;\\n\\n\\n     for(int i=1;i<N-1;i++){\\n        sum[i+1]=sum[i]+mp[i]*i;\\n        cnt[i+1]=cnt[i]+mp[i];\\n     }\\n\\n\\n     \\n     int ans = rec(0,101,k,houses);      \\n     return ans;\\n  }\\n\\n     \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long int ll;\\n#define set set<int>\\n#define uset unordered_set<int> \\n#define veci vector<int> \\n#define vecs vector<string>\\n#define stack stack<int> \\n#define pb push_back\\n// #define mp make_pair\\n#define pii pair<int,int>\\n#define all(x) (x).begin(), (x).end() \\n#define FOR(s,n) for(int i = s; i < n; i++)\\n\\ntemplate<typename T> \\nostream& operator<<(ostream& COUT, vector<T>& v){ for(int i=0 ; i<v.size() ; i++){ COUT<<v[i]<<\" \"; } COUT << endl; return COUT; }\\ntemplate<typename T> \\nistream& operator>>(istream& CIN, vector<T>& a){ for(int i=0 ; i<a.size() ; i++) CIN>>a[i]; return CIN; }\\ntemplate<typename T> \\nvoid pws(const T& arg){ cout << arg <<endl;}\\ntemplate <typename T, typename... Args>\\nvoid pws(const T& first, const Args&... args) {cout << first << \" \";pws(args...);}\\n\\nint dir[8][2] = {{0,1},{1,0},{-1,0},{0,-1},{1,1},{-1,1},{1,-1},{-1,-1}};\\nint MOD = 1e9 + 7,inf=1e7;\\nint n,m,k;\\n\\nconst int N = 1e4+3,M=103;\\nint sum[N];\\nint cnt[N];\\nint mp[N];\\nint dp[M][M][M];\\n\\nint rec(int i,int prev,int k,veci& h){\\n    if(k<0) return inf;\\n    if(i==n){\\n        if(k!=0) return inf;\\n        else{\\n            int pval=h[prev];\\n            int temp= sum[N-1]-sum[pval]-(cnt[N-1]-cnt[pval])*pval;\\n            return temp;\\n        }\\n    }\\n    if(dp[i][prev][k]!=-1) return dp[i][prev][k];\\n    int loc = 0;\\n    int pos2 = rec(i+1,prev,k,h);\\n   if(prev!=101){\\n         int mid = (h[i]+h[prev])/2;\\n         int pval = h[prev],cval = h[i];\\n         int pos1= sum[mid+1]-sum[pval]-(cnt[mid+1]-cnt[pval])*pval;\\n         pos1+=(cnt[cval+1]-cnt[mid+1])*cval-(sum[cval+1]-sum[mid+1]);\\n         pos1+=rec(i+1,i,k-1,h); \\n         loc = min(pos1,pos2);\\n   }\\n   else{\\n    int pos1 = cnt[h[i]]*h[i]-sum[h[i]];\\n    int temp = pos1;\\n    pos1+=rec(i+1,i,k-1,h);\\n    \\n    loc = min(pos1,pos2);\\n   }\\n   return dp[i][prev][k]=loc;\\n}\\n\\n\\nclass Solution {\\npublic:\\n\\n   int minDistance(vector<int>& houses, int k) {\\n     n = houses.size();\\n     sort(all(houses));\\n\\n     memset(dp,-1,sizeof(dp));\\n     memset(mp,0,sizeof(mp));\\n     memset(cnt,0,sizeof(cnt));\\n     memset(sum,0,sizeof(sum));\\n\\n     for(int v:houses) mp[v]++;\\n\\n\\n     for(int i=1;i<N-1;i++){\\n        sum[i+1]=sum[i]+mp[i]*i;\\n        cnt[i+1]=cnt[i]+mp[i];\\n     }\\n\\n\\n     \\n     int ans = rec(0,101,k,houses);      \\n     return ans;\\n  }\\n\\n     \\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4028751,
                "title": "easy-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Sort the houses array to facilitate distance calculations.\\n- Initialize an array dp of size n to store the optimal distances.\\n- Loop through the houses array and calculate the optimal distance for each position. Store it in the dp array.\\n- Iterate k-1 times (since we already calculated one set of optimal distances) to allocate mailboxes.\\n- In each iteration, use a single array next to calculate the optimal distances for the current configuration.\\n- For each position, compute the distance and find the minimum among the possibilities.\\n- Swap the arrays dp and next for the next iteration.\\n- Finally, return dp[n-1] which represents the minimum total distance.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSorting the houses array takes O(n*log(n)).\\nThe first loop to calculate optimal distances takes O(n).\\nThe loop for allocating mailboxes runs k-1 times, and in each iteration, it takes O(n^2).\\nOverall, the time complexity is O(n^2) due to the nested loops.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTwo arrays of size n (dp and next), which results in O(n) space complexity.\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[] dp = new int[n];\\n        int[] next = new int[n]; \\n        \\n        for (int i = 1; i < n; i++){\\n            dp[i]=dp[i-1]+houses[i]-houses[i/2];\\n        }\\n        \\n        for (int i = 0; i < k-1; i++){\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < n; j++){\\n                int sum = 0;\\n                for (int m = j; m >= 0; m--){\\n                    sum += houses[(m+j+1)>>1]-houses[m];\\n                    next[j] = Math.min(next[j], (m==0?0:dp[m-1])+sum);\\n                }\\n            }\\n            int[] temp = dp;\\n            dp = next;\\n            next = temp; // Swap the arrays for next iteration\\n        }\\n        return dp[n-1];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[] dp = new int[n];\\n        int[] next = new int[n]; \\n        \\n        for (int i = 1; i < n; i++){\\n            dp[i]=dp[i-1]+houses[i]-houses[i/2];\\n        }\\n        \\n        for (int i = 0; i < k-1; i++){\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < n; j++){\\n                int sum = 0;\\n                for (int m = j; m >= 0; m--){\\n                    sum += houses[(m+j+1)>>1]-houses[m];\\n                    next[j] = Math.min(next[j], (m==0?0:dp[m-1])+sum);\\n                }\\n            }\\n            int[] temp = dp;\\n            dp = next;\\n            next = temp; // Swap the arrays for next iteration\\n        }\\n        return dp[n-1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020596,
                "title": "clean-c-code-using-median-concept",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    int cost[101][101];\\n    int dp[101][101];\\n\\n    int minDistance(vector<int>& a, int t) {\\n        \\n        n=a.size();\\n\\n        sort(a.begin(),a.end());\\n\\n        memset(cost,0,sizeof(cost));\\n        memset(dp,-1,sizeof(dp));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int medind = (i+j)/2;\\n                for(int k=i;k<=j;k++){\\n                    cost[i][j]+=abs(a[medind]-a[k]);\\n                }\\n            }\\n        }\\n\\n        return f(a,0,t);\\n    }\\n\\n    int f(vector<int>&a, int st,int t){\\n\\n        if(st==n && t==0)return 0; // we have to use all houses and mailboxes\\n        if(st==n || t==0)return 1e8; // else its an invalid option\\n\\n        if(dp[st][t]!=-1)return dp[st][t];\\n\\n        int ans=1e8;\\n        for(int k=st;k<n;k++){\\n            int temp = cost[st][k]+f(a,k+1,t-1);\\n            ans=min(ans,temp);\\n        }\\n\\n        return dp[st][t]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    int cost[101][101];\\n    int dp[101][101];\\n\\n    int minDistance(vector<int>& a, int t) {\\n        \\n        n=a.size();\\n\\n        sort(a.begin(),a.end());\\n\\n        memset(cost,0,sizeof(cost));\\n        memset(dp,-1,sizeof(dp));\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int medind = (i+j)/2;\\n                for(int k=i;k<=j;k++){\\n                    cost[i][j]+=abs(a[medind]-a[k]);\\n                }\\n            }\\n        }\\n\\n        return f(a,0,t);\\n    }\\n\\n    int f(vector<int>&a, int st,int t){\\n\\n        if(st==n && t==0)return 0; // we have to use all houses and mailboxes\\n        if(st==n || t==0)return 1e8; // else its an invalid option\\n\\n        if(dp[st][t]!=-1)return dp[st][t];\\n\\n        int ans=1e8;\\n        for(int k=st;k<n;k++){\\n            int temp = cost[st][k]+f(a,k+1,t-1);\\n            ans=min(ans,temp);\\n        }\\n\\n        return dp[st][t]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944228,
                "title": "c-median",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cache[105][105];\\n    const int inf = INT_MAX;\\n    int f(vector<int>& houses, int k, int p) {\\n        if(k == 0 && p == houses.size()) return 0;\\n        if(k == 0 || p == houses.size()) return inf;\\n\\n        if(cache[p][k] != -1) return cache[p][k];\\n        int res = inf;\\n        for(int q = p; q < houses.size(); ++q) {\\n            int sum = 0;\\n            for(int r = p; r <= q; ++r) {\\n                sum += abs(houses[(p + q) / 2] - houses[r]);\\n            }\\n            int ans = f(houses, k - 1, q + 1);\\n            if(ans == inf) continue;\\n            res = min(res, ans + sum);\\n        }\\n        return cache[p][k] = res;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        memset(cache, -1, sizeof(cache));\\n        sort(houses.begin(), houses.end());\\n        return f(houses, k, 0);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cache[105][105];\\n    const int inf = INT_MAX;\\n    int f(vector<int>& houses, int k, int p) {\\n        if(k == 0 && p == houses.size()) return 0;\\n        if(k == 0 || p == houses.size()) return inf;\\n\\n        if(cache[p][k] != -1) return cache[p][k];\\n        int res = inf;\\n        for(int q = p; q < houses.size(); ++q) {\\n            int sum = 0;\\n            for(int r = p; r <= q; ++r) {\\n                sum += abs(houses[(p + q) / 2] - houses[r]);\\n            }\\n            int ans = f(houses, k - 1, q + 1);\\n            if(ans == inf) continue;\\n            res = min(res, ans + sum);\\n        }\\n        return cache[p][k] = res;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        memset(cache, -1, sizeof(cache));\\n        sort(houses.begin(), houses.end());\\n        return f(houses, k, 0);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861867,
                "title": "subarray-dp",
                "content": "# Intuition\\nOn careful observation we see that this prblm can be solved in O(N^3).\\ndp(i,j)(k) denotes total sum for houses in range (i,j) using k mailboxes. If anyhow we find transitions then problem is solved. \\nSo now we are left with finding the cost of a subarray of houses for 1 mailbox. We are computing that cost array seperately for all subarrays, i.e. min cost of placing a mailbox for a subarray of houses.\\nThen once this cost is known to us then we will make dp(i)(k) denoting total sum for houses (0,i) using k mailboxes. Writing transitions using a for loop and the cost array we created.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2*k)\\n- Space complexity:\\nO(N^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& h, int k) \\n    {\\n        int n = h.size();\\n        vector<vector<int>> cost(n, vector<int>(n, 0));        \\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));   \\n        sort(h.begin(), h.end());     \\n        calc_cost(h, cost);    \\n        return dp_fun(dp, cost, n-1, k);\\n    }\\n    \\n    int dp_fun(vector<vector<int>>&dp, vector<vector<int>>&cost, int ind, int k)\\n    {\\n        if(k <= 0 || ind < 0)\\n        {\\n            if(ind < 0 && k <= 0)\\n            {\\n                return 0;\\n            }\\n            return (1e7);\\n        }\\n        if(dp[ind][k] == -1)\\n        {\\n            int ans = INT_MAX;\\n            for(int w = ind; w >= 0; w--)\\n            {\\n                ans = min(ans, dp_fun(dp, cost, w-1, k-1) + cost[w][ind]);\\n            }\\n            dp[ind][k] = ans;\\n        }\\n        return dp[ind][k];\\n    }\\n\\n\\n    void calc_cost(vector<int>&h, vector<vector<int>>&cost)\\n    {\\n        int n = h.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i; j < n; j++)\\n            {\\n                int mid = ((j-i+2)/2)-1+i, elm;\\n                if((j-i+1) % 2 == 0)\\n                {\\n                    elm = (h[mid]+h[mid+1])/2;\\n                }\\n                else \\n                {\\n                    elm = h[mid];\\n                }\\n                for(int w = i; w <= j; w++)\\n                {\\n                    cost[i][j] += max(elm-h[w], h[w]-elm);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& h, int k) \\n    {\\n        int n = h.size();\\n        vector<vector<int>> cost(n, vector<int>(n, 0));        \\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));   \\n        sort(h.begin(), h.end());     \\n        calc_cost(h, cost);    \\n        return dp_fun(dp, cost, n-1, k);\\n    }\\n    \\n    int dp_fun(vector<vector<int>>&dp, vector<vector<int>>&cost, int ind, int k)\\n    {\\n        if(k <= 0 || ind < 0)\\n        {\\n            if(ind < 0 && k <= 0)\\n            {\\n                return 0;\\n            }\\n            return (1e7);\\n        }\\n        if(dp[ind][k] == -1)\\n        {\\n            int ans = INT_MAX;\\n            for(int w = ind; w >= 0; w--)\\n            {\\n                ans = min(ans, dp_fun(dp, cost, w-1, k-1) + cost[w][ind]);\\n            }\\n            dp[ind][k] = ans;\\n        }\\n        return dp[ind][k];\\n    }\\n\\n\\n    void calc_cost(vector<int>&h, vector<vector<int>>&cost)\\n    {\\n        int n = h.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i; j < n; j++)\\n            {\\n                int mid = ((j-i+2)/2)-1+i, elm;\\n                if((j-i+1) % 2 == 0)\\n                {\\n                    elm = (h[mid]+h[mid+1])/2;\\n                }\\n                else \\n                {\\n                    elm = h[mid];\\n                }\\n                for(int w = i; w <= j; w++)\\n                {\\n                    cost[i][j] += max(elm-h[w], h[w]-elm);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860671,
                "title": "java-dfs-with-memo",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        Integer[][] memo = new Integer[houses.length][k + 1];\\n        return min(houses, 0, k, memo);\\n    }\\n\\n    private int min(int[] houses, int idx, int k, Integer[][] memo) {\\n        if (k == 0) {\\n            return idx == houses.length ? 0 : Integer.MAX_VALUE;\\n        }\\n        if (idx == houses.length) return Integer.MAX_VALUE;\\n        if (memo[idx][k] != null) {\\n            return memo[idx][k];\\n        }\\n\\n        int cost = Integer.MAX_VALUE;\\n        for (int i = idx; i < houses.length; i++) {\\n            // put [idx, i] in one group, then\\n            int val = min(houses, i + 1, k - 1, memo);\\n            if (val == Integer.MAX_VALUE) continue;\\n            cost = Math.min(cost, cost(houses, idx, i) + val);\\n        }\\n        memo[idx][k] = cost;\\n        return cost;\\n    }\\n\\n    private int cost(int[] houses, int left, int right) {\\n        int cost = 0;\\n        while (left < right) {\\n            cost += houses[right] - houses[left];\\n            left++;\\n            right--;\\n        }\\n        return cost;\\n    }\\n}\\n\\n/**\\nk groups\\n\\nin each group, the minimal distance should be putting mail box in the middle pos.\\n\\n1 + 3 = 4;\\n1 + 5 = 6;\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        Integer[][] memo = new Integer[houses.length][k + 1];\\n        return min(houses, 0, k, memo);\\n    }\\n\\n    private int min(int[] houses, int idx, int k, Integer[][] memo) {\\n        if (k == 0) {\\n            return idx == houses.length ? 0 : Integer.MAX_VALUE;\\n        }\\n        if (idx == houses.length) return Integer.MAX_VALUE;\\n        if (memo[idx][k] != null) {\\n            return memo[idx][k];\\n        }\\n\\n        int cost = Integer.MAX_VALUE;\\n        for (int i = idx; i < houses.length; i++) {\\n            // put [idx, i] in one group, then\\n            int val = min(houses, i + 1, k - 1, memo);\\n            if (val == Integer.MAX_VALUE) continue;\\n            cost = Math.min(cost, cost(houses, idx, i) + val);\\n        }\\n        memo[idx][k] = cost;\\n        return cost;\\n    }\\n\\n    private int cost(int[] houses, int left, int right) {\\n        int cost = 0;\\n        while (left < right) {\\n            cost += houses[right] - houses[left];\\n            left++;\\n            right--;\\n        }\\n        return cost;\\n    }\\n}\\n\\n/**\\nk groups\\n\\nin each group, the minimal distance should be putting mail box in the middle pos.\\n\\n1 + 3 = 4;\\n1 + 5 = 6;\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726903,
                "title": "c-easy-solution-mcm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nrelate it to previous problem . (i.e mcm )\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(N * N * N * N ) ;\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(N * N * N ) ;\\n# Code\\n```\\n//  trick is middle is median \\n\\nclass Solution {\\npublic:\\n    int dp[102][102][102] ;\\n    vector<int> pre ;\\n    int getDist(int l , int r ){\\n        if(l == r ) return 0 ; \\n\\n        int cnt = r-l+1 ;\\n        int m = (l + r) / 2 ;\\n        if(cnt % 2 == 0 ){\\n            int ans = pre[r] - pre[m] ;\\n            int a2 = pre[m] ;\\n            if(l > 0 ) a2 -= pre[l-1]  ;\\n\\n            return ans - a2 ;\\n        }\\n        else{\\n            int ans = pre[r] - pre[m] ;\\n            int a2 = pre[m-1] ;\\n            if(l > 0 ) a2 -= pre[l-1]  ; \\n            return ans - a2;\\n        }\\n    }\\n\\n    int f(int i , int j , int k ){\\n\\n        if(j < i || ( j - i + 1 ) <= k) return 0 ; \\n        if( k == 0 ) return INT_MAX ; \\n        if( i == j ) return 0 ; \\n\\n        if(dp[i][j][k] != -1 ) return dp[i][j][k] ;\\n\\n        int ans = INT_MAX ;\\n        for(int u = i ; u <= j ; ++u ){\\n            int lans = getDist(i , u ) ;\\n            int rans = f(u+1 , j , k-1 ) ;\\n            if(rans != INT_MAX ){\\n                ans = min(ans , lans + rans ) ;\\n            }\\n        }\\n        \\n        return dp[i][j][k] = ans ;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        memset(dp , -1 , sizeof(dp) ) ;\\n        pre = houses ;\\n        sort(pre.begin() , pre.end() ) ;\\n        int n = houses.size() ;\\n        for(int i = 1 ; i< n ; ++i ){\\n            pre[i] += pre[i-1] ;\\n        }\\n\\n        return f(0 , houses.size() -1 , k ) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n//  trick is middle is median \\n\\nclass Solution {\\npublic:\\n    int dp[102][102][102] ;\\n    vector<int> pre ;\\n    int getDist(int l , int r ){\\n        if(l == r ) return 0 ; \\n\\n        int cnt = r-l+1 ;\\n        int m = (l + r) / 2 ;\\n        if(cnt % 2 == 0 ){\\n            int ans = pre[r] - pre[m] ;\\n            int a2 = pre[m] ;\\n            if(l > 0 ) a2 -= pre[l-1]  ;\\n\\n            return ans - a2 ;\\n        }\\n        else{\\n            int ans = pre[r] - pre[m] ;\\n            int a2 = pre[m-1] ;\\n            if(l > 0 ) a2 -= pre[l-1]  ; \\n            return ans - a2;\\n        }\\n    }\\n\\n    int f(int i , int j , int k ){\\n\\n        if(j < i || ( j - i + 1 ) <= k) return 0 ; \\n        if( k == 0 ) return INT_MAX ; \\n        if( i == j ) return 0 ; \\n\\n        if(dp[i][j][k] != -1 ) return dp[i][j][k] ;\\n\\n        int ans = INT_MAX ;\\n        for(int u = i ; u <= j ; ++u ){\\n            int lans = getDist(i , u ) ;\\n            int rans = f(u+1 , j , k-1 ) ;\\n            if(rans != INT_MAX ){\\n                ans = min(ans , lans + rans ) ;\\n            }\\n        }\\n        \\n        return dp[i][j][k] = ans ;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        memset(dp , -1 , sizeof(dp) ) ;\\n        pre = houses ;\\n        sort(pre.begin() , pre.end() ) ;\\n        int n = houses.size() ;\\n        for(int i = 1 ; i< n ; ++i ){\\n            pre[i] += pre[i-1] ;\\n        }\\n\\n        return f(0 , houses.size() -1 , k ) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630436,
                "title": "python-top-down-memoization",
                "content": "# Code\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        cost = [[0]*101 for _ in range(101)]\\n        houses.sort()\\n\\n        n = len(houses)\\n        ## Finding the cummulative distance if I place a mailbox at position x\\n        ## Many clusers are possible, for each cluster, the median is the optimal choice\\n        for i in range(n):\\n            for j in range(i, n):\\n                for x in range(i, j+1):\\n                    cost[i][j] += abs(houses[(i+j)//2] - houses[x])\\n        \\n        ## Top - Down DP\\n        @lru_cache(None)\\n        def dfs(start, k):\\n            if k == 0 and start == n:\\n                return 0\\n            if k == 0 or start == n:\\n                return math.inf\\n            \\n            mini = math.inf\\n            for index in range(start, n):\\n                mini = min(mini, cost[start][index] + dfs(index + 1, k - 1))\\n\\n            return mini\\n        \\n        return dfs(0, k)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        cost = [[0]*101 for _ in range(101)]\\n        houses.sort()\\n\\n        n = len(houses)\\n        ## Finding the cummulative distance if I place a mailbox at position x\\n        ## Many clusers are possible, for each cluster, the median is the optimal choice\\n        for i in range(n):\\n            for j in range(i, n):\\n                for x in range(i, j+1):\\n                    cost[i][j] += abs(houses[(i+j)//2] - houses[x])\\n        \\n        ## Top - Down DP\\n        @lru_cache(None)\\n        def dfs(start, k):\\n            if k == 0 and start == n:\\n                return 0\\n            if k == 0 or start == n:\\n                return math.inf\\n            \\n            mini = math.inf\\n            for index in range(start, n):\\n                mini = min(mini, cost[start][index] + dfs(index + 1, k - 1))\\n\\n            return mini\\n        \\n        return dfs(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458985,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        houses.insert(houses.begin(), 0);\\n        vector<vector<int>>dp(n+1, vector<int>(k+1, INT_MAX/2));\\n\\n        int midianSum[n+1][n+1];\\n        for (int i = 1; i <= n; i++){\\n            for (int j = i; j <= n; j++)\\n            {\\n                int sum = 0;\\n                for (int p = i; p <= j; p++)\\n                    sum += abs(houses[p] - houses[(i+j)/2]);\\n                midianSum[i][j] = sum;\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n            dp[i][1] = midianSum[1][i];\\n\\n        for (int i = 1; i <= n; i++){\\n            for (int j = 2; j <= k; j++)\\n            {\\n                for (int p = j-1; p < i; p++)\\n                    dp[i][j] = min(dp[i][j],  dp[p][j-1] + midianSum[p+1][i]);\\n            }\\n        }\\n        return dp[n][k];        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        houses.insert(houses.begin(), 0);\\n        vector<vector<int>>dp(n+1, vector<int>(k+1, INT_MAX/2));\\n\\n        int midianSum[n+1][n+1];\\n        for (int i = 1; i <= n; i++){\\n            for (int j = i; j <= n; j++)\\n            {\\n                int sum = 0;\\n                for (int p = i; p <= j; p++)\\n                    sum += abs(houses[p] - houses[(i+j)/2]);\\n                midianSum[i][j] = sum;\\n            }\\n        }\\n\\n        for (int i = 1; i <= n; i++)\\n            dp[i][1] = midianSum[1][i];\\n\\n        for (int i = 1; i <= n; i++){\\n            for (int j = 2; j <= k; j++)\\n            {\\n                for (int p = j-1; p < i; p++)\\n                    dp[i][j] = min(dp[i][j],  dp[p][j-1] + midianSum[p+1][i]);\\n            }\\n        }\\n        return dp[n][k];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444107,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, houses, k):\\n        n = len(houses)\\n\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def func(i,j):\\n            median = houses[(i+j)//2]\\n            return sum([abs(houses[k] - median) for k in range(i,j+1)])\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k == 1:\\n                return func(i,n-1)\\n\\n            max_val = float(\"inf\")\\n\\n            for j in range(i,n):\\n                max_val = min(max_val,func(i,j-1) + dfs(j,k-1))\\n\\n            return max_val\\n\\n        return dfs(0,k)\\n\\n\\n\\n\\n            \\n\\n\\n\\n        \\n        \\n        \\n\\n\\n            \\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses, k):\\n        n = len(houses)\\n\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def func(i,j):\\n            median = houses[(i+j)//2]\\n            return sum([abs(houses[k] - median) for k in range(i,j+1)])\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k == 1:\\n                return func(i,n-1)\\n\\n            max_val = float(\"inf\")\\n\\n            for j in range(i,n):\\n                max_val = min(max_val,func(i,j-1) + dfs(j,k-1))\\n\\n            return max_val\\n\\n        return dfs(0,k)\\n\\n\\n\\n\\n            \\n\\n\\n\\n        \\n        \\n        \\n\\n\\n            \\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399922,
                "title": "python-intuition-for-dp-o-n-3",
                "content": "As always we need to realize one thing-\\n1. Median will always be optimal choice.\\n\\nNow if you observe, these mail boxes forms a group having some assoicated cost.\\nSo we just need to minimize cost to form such k groups. (classic dp problem)\\nCost can be calculated using median.\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, A: List[int], k: int) -> int:\\n        A.sort()\\n        n =len(A)\\n        @cache\\n        def cost(start,end):\\n            med = (start+end)//2\\n            res = 0\\n            for i in range(start,end+1):\\n                res += abs(A[med]-A[i])\\n            return res\\n        @cache\\n        def dp(idx,k):\\n            if(idx==n): return 0\\n            res = float(\\'inf\\')\\n            if(k==0): return res\\n            for i in range(idx,n-k+1):\\n                c = cost(idx,i)\\n                res = min(res,dp(i+1,k-1)+c)\\n            return res\\n        return dp(0,k)\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, A: List[int], k: int) -> int:\\n        A.sort()\\n        n =len(A)\\n        @cache\\n        def cost(start,end):\\n            med = (start+end)//2\\n            res = 0\\n            for i in range(start,end+1):\\n                res += abs(A[med]-A[i])\\n            return res\\n        @cache\\n        def dp(idx,k):\\n            if(idx==n): return 0\\n            res = float(\\'inf\\')\\n            if(k==0): return res\\n            for i in range(idx,n-k+1):\\n                c = cost(idx,i)\\n                res = min(res,dp(i+1,k-1)+c)\\n            return res\\n        return dp(0,k)\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394707,
                "title": "fk-this-median-shit-just-give-shit-to-houses-itself-in-a-better-way",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, hs: List[int], kk: int) -> int:\\n        hs=[0]+hs\\n        hs.sort()\\n        n=len(hs)\\n        dp=[[-1]*(n+1) for i in range(kk+1)]\\n        def rec(id,i):\\n            nonlocal kk\\n            if i>=n:\\n                return float(\"inf\")\\n            if id==kk:\\n                return sum(hs[i+1:])-(len(hs[i+1:])*hs[i])\\n            if dp[id][i]!=-1:\\n                return dp[id][i]\\n            ans=float(\"inf\")\\n            for j in range(i+1,len(hs)):\\n                rs=0\\n                for k in range(i+1,j):\\n                    if i!=0:\\n                        rs+=min(abs(hs[j]-hs[k]),abs(hs[i]-hs[k]))\\n                    else:\\n                        rs+=abs(hs[j]-hs[k])\\n                x=rec(id+1,j)\\n                ans=min(ans,rs+x)\\n            dp[id][i]=ans\\n            return ans\\n        return rec(0,0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, hs: List[int], kk: int) -> int:\\n        hs=[0]+hs\\n        hs.sort()\\n        n=len(hs)\\n        dp=[[-1]*(n+1) for i in range(kk+1)]\\n        def rec(id,i):\\n            nonlocal kk\\n            if i>=n:\\n                return float(\"inf\")\\n            if id==kk:\\n                return sum(hs[i+1:])-(len(hs[i+1:])*hs[i])\\n            if dp[id][i]!=-1:\\n                return dp[id][i]\\n            ans=float(\"inf\")\\n            for j in range(i+1,len(hs)):\\n                rs=0\\n                for k in range(i+1,j):\\n                    if i!=0:\\n                        rs+=min(abs(hs[j]-hs[k]),abs(hs[i]-hs[k]))\\n                    else:\\n                        rs+=abs(hs[j]-hs[k])\\n                x=rec(id+1,j)\\n                ans=min(ans,rs+x)\\n            dp[id][i]=ans\\n            return ans\\n        return rec(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277081,
                "title": "1-dimension-dynamic-programming-with-prefix-sum-to-calculate-distances",
                "content": "# Intuition\\n\\nComments in the code.\\n\\nPlease notice that `memo[i]` represents the min distance of the `i` left houses, and not until the index `i` (it would actually be until index `i-1`). I do this to avoid having to check if `i==0` as it would go out of bounds of the array.\\n\\nNotice that once we calculate the prefix sum, calcutating the distance on a range is done in `0(1)`.\\n\\nAt last just a comment about min distance with one middle point, on this exercise please read \"middle point\" as \"mailbox\" and \"mesure point\" as house:\\n\\n1. With one measure point the min distance is when the middle point if on the measure point (the mailbox is in the house)\\n2. With two measure points the measure point can be anywhere between the mesured points. As it can be anywhere between the easiest choise is one of them.\\n3. With 3 measure points notice that the point 2 applies to the edge measure points, and item one applies to the measure point in the middle, therefore the min distance is when the middle point is in the middle measure point. So just choose the measure point `(index of the measure point on the right - index of the measure point on the left) /2`\\n4. Notice that on this case you can apply the secont iem twice, therefore just choose  the measure point `(index of the measure point on the right - index of the measure point on the left) /2` rounded up or down.\\n5. The formula continues to apply for any number.\\n\\nThe calculations of the distance is trivial if you have the prefix sum, I comment the formula in the code.\\n\\n# Approach\\n\\n- Dynamic Programming\\n- Prefix Sum\\n\\n# Complexity\\n- Time complexity:\\n$$O(k*houses^2)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/5de76804-e936-48e4-ba41-115f3abf65f4_1678378978.7260015.png)\\n\\n```java\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        // they never promise to pass the houses in order\\n        Arrays.sort(houses);\\n        // prefix sum, this will help a lot to calculate the dustances\\n        int[] ps=new int[houses.length];\\n        ps[0]=houses[0];\\n        for(int i=1;i<ps.length;i++) ps[i]=ps[i-1]+houses[i];\\n        // memo will work to inform the min distance of the i prefix\\n        // houses with k-1 mail boxes. Notice that i=0 means \"no houses\"\\n        int[] memo=new int[houses.length+1], tmp=new int[memo.length];\\n        // with 0 mail boxes the distance is infinite except for 0\\n        // houses\\n        Arrays.fill(memo,Integer.MAX_VALUE/2);\\n        memo[0]=0;\\n        // lets add one mail box at the time\\n        for(int i=0;i<k;i++) {\\n            // the min houses on the left is the number of mail boxes\\n            for(int j=i+1;j<=houses.length;j++) {\\n                // lets check the min distance by checking the min\\n                // distance with the prefix houses and k-1 houses\\n                // plus distance on the suffix houses until j\\n                int min=Integer.MAX_VALUE/2;\\n                for(int g=i;g<j;g++)\\n                    min=Math.min(min,memo[g]+groupDist(g,j-1,ps,houses));\\n                tmp[j]=min;\\n            }\\n            // for the next iteration tmp becomes memo. I could create\\n            // a new tmp array, but I ended up switching to reuse the\\n            // discarded memo\\n            int[] t=tmp;\\n            tmp=memo;\\n            memo=t;\\n        }\\n        return memo[memo.length-1];\\n    }\\n    int groupDist(int left, int right, int[] ps, int[] houses) {\\n        // for min distance the secret is ALLWAYS choosing the middle\\n        // house. If there are more than one (e.g pair number) choose\\n        // any of them\\n        int mid=(left+right)>>1, midHouse=houses[mid], psMid=ps[mid];\\n        // (h[mid]-h[left])+(h[mid]-h[left+1])+..+(h[mid]-h[mid])\\n        //   = h[mid]*(mid-left+1) - (ps[mid]-pd[left-1])\\n        int leftDist=midHouse*(mid-left+1)-psMid+(left==0?0:ps[left-1]);\\n        // (h[mid+1]-h[mid])+(h[mid+2]-h[mid])+..+(h[right]-h[mid])\\n        //   = (ps[right]-pd[mid]) - h[mid]*(right-mid)\\n        int rightDist=ps[right]-psMid-(midHouse*(right-mid));\\n        return leftDist+rightDist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```java\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        // they never promise to pass the houses in order\\n        Arrays.sort(houses);\\n        // prefix sum, this will help a lot to calculate the dustances\\n        int[] ps=new int[houses.length];\\n        ps[0]=houses[0];\\n        for(int i=1;i<ps.length;i++) ps[i]=ps[i-1]+houses[i];\\n        // memo will work to inform the min distance of the i prefix\\n        // houses with k-1 mail boxes. Notice that i=0 means \"no houses\"\\n        int[] memo=new int[houses.length+1], tmp=new int[memo.length];\\n        // with 0 mail boxes the distance is infinite except for 0\\n        // houses\\n        Arrays.fill(memo,Integer.MAX_VALUE/2);\\n        memo[0]=0;\\n        // lets add one mail box at the time\\n        for(int i=0;i<k;i++) {\\n            // the min houses on the left is the number of mail boxes\\n            for(int j=i+1;j<=houses.length;j++) {\\n                // lets check the min distance by checking the min\\n                // distance with the prefix houses and k-1 houses\\n                // plus distance on the suffix houses until j\\n                int min=Integer.MAX_VALUE/2;\\n                for(int g=i;g<j;g++)\\n                    min=Math.min(min,memo[g]+groupDist(g,j-1,ps,houses));\\n                tmp[j]=min;\\n            }\\n            // for the next iteration tmp becomes memo. I could create\\n            // a new tmp array, but I ended up switching to reuse the\\n            // discarded memo\\n            int[] t=tmp;\\n            tmp=memo;\\n            memo=t;\\n        }\\n        return memo[memo.length-1];\\n    }\\n    int groupDist(int left, int right, int[] ps, int[] houses) {\\n        // for min distance the secret is ALLWAYS choosing the middle\\n        // house. If there are more than one (e.g pair number) choose\\n        // any of them\\n        int mid=(left+right)>>1, midHouse=houses[mid], psMid=ps[mid];\\n        // (h[mid]-h[left])+(h[mid]-h[left+1])+..+(h[mid]-h[mid])\\n        //   = h[mid]*(mid-left+1) - (ps[mid]-pd[left-1])\\n        int leftDist=midHouse*(mid-left+1)-psMid+(left==0?0:ps[left-1]);\\n        // (h[mid+1]-h[mid])+(h[mid+2]-h[mid])+..+(h[right]-h[mid])\\n        //   = (ps[right]-pd[mid]) - h[mid]*(right-mid)\\n        int rightDist=ps[right]-psMid-(midHouse*(right-mid));\\n        return leftDist+rightDist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159938,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_distance(houses: Vec<i32>, k: i32) -> i32 {\\n        let mut houses = houses;\\n        houses.sort();\\n        let n = houses.len();\\n        let mut dp = vec![vec![0; n]; n];\\n        for (i, item) in dp.iter_mut().enumerate().take(n) {\\n            for (j, item0) in item.iter_mut().enumerate().take(n).skip(i) {\\n                let mid = (i + j) / 2;\\n                for k in i..=j {\\n                    *item0 += (houses[k] - houses[mid]).abs();\\n                }\\n            }\\n        }\\n        let mut dp2 = vec![vec![0; n]; k as usize];\\n        for i in 0..n {\\n            dp2[0][i] = dp[0][i];\\n        }\\n        for i in 1..k as usize {\\n            for j in i..n {\\n                let mut min = std::i32::MAX;\\n                for k in i - 1..j {\\n                    min = min.min(dp2[i - 1][k] + dp[k + 1][j]);\\n                }\\n                dp2[i][j] = min;\\n            }\\n        }\\n        dp2[k as usize - 1][n - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_distance(houses: Vec<i32>, k: i32) -> i32 {\\n        let mut houses = houses;\\n        houses.sort();\\n        let n = houses.len();\\n        let mut dp = vec![vec![0; n]; n];\\n        for (i, item) in dp.iter_mut().enumerate().take(n) {\\n            for (j, item0) in item.iter_mut().enumerate().take(n).skip(i) {\\n                let mid = (i + j) / 2;\\n                for k in i..=j {\\n                    *item0 += (houses[k] - houses[mid]).abs();\\n                }\\n            }\\n        }\\n        let mut dp2 = vec![vec![0; n]; k as usize];\\n        for i in 0..n {\\n            dp2[0][i] = dp[0][i];\\n        }\\n        for i in 1..k as usize {\\n            for j in i..n {\\n                let mut min = std::i32::MAX;\\n                for k in i - 1..j {\\n                    min = min.min(dp2[i - 1][k] + dp[k + 1][j]);\\n                }\\n                dp2[i][j] = min;\\n            }\\n        }\\n        dp2[k as usize - 1][n - 1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086260,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n\\n    houses = houses.sort((a,b) => a-b)\\n    \\n    const solution = []\\n    for (let i=0; i<houses.length; i++) {\\n        const row = []\\n        for (let j=0; j<k+1; j++) {\\n            if (j == 0) {\\n                row.push(Number.MAX_SAFE_INTEGER)\\n            } else {\\n                row.push(NaN)\\n            }\\n        }\\n        solution.push(row)\\n    }\\n\\n    for (let j=1; j<=k; j++) {\\n\\n        for (let i=houses.length-1; i>=0; i--) {\\n\\n            if (j >= houses.length-i) {\\n                solution[i][j] = 0\\n                continue\\n            } \\n\\n            let minCost = singleCover(houses, i, houses.length-1)\\n\\n            for (let m=i; m<houses.length-1; m++) {\\n\\n                const cost = singleCover(houses, i, m)  + solution[m+1][j-1] \\n\\n                if (cost < minCost) {\\n                    minCost = cost\\n                }\\n            }\\n\\n            solution[i][j] = minCost\\n        }\\n    }\\n\\n    return solution[0][k]\\n};\\n\\n\\nfunction singleCover(houses, i, j) {\\n\\n    let minDist = 0\\n\\n    let mailboxIndex = Math.floor((i+j)/2)\\n\\n    for (let k=i; k<=j; k++) {\\n        minDist += Math.abs(houses[mailboxIndex]-houses[k])\\n    }\\n\\n    return minDist\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n\\n    houses = houses.sort((a,b) => a-b)\\n    \\n    const solution = []\\n    for (let i=0; i<houses.length; i++) {\\n        const row = []\\n        for (let j=0; j<k+1; j++) {\\n            if (j == 0) {\\n                row.push(Number.MAX_SAFE_INTEGER)\\n            } else {\\n                row.push(NaN)\\n            }\\n        }\\n        solution.push(row)\\n    }\\n\\n    for (let j=1; j<=k; j++) {\\n\\n        for (let i=houses.length-1; i>=0; i--) {\\n\\n            if (j >= houses.length-i) {\\n                solution[i][j] = 0\\n                continue\\n            } \\n\\n            let minCost = singleCover(houses, i, houses.length-1)\\n\\n            for (let m=i; m<houses.length-1; m++) {\\n\\n                const cost = singleCover(houses, i, m)  + solution[m+1][j-1] \\n\\n                if (cost < minCost) {\\n                    minCost = cost\\n                }\\n            }\\n\\n            solution[i][j] = minCost\\n        }\\n    }\\n\\n    return solution[0][k]\\n};\\n\\n\\nfunction singleCover(houses, i, j) {\\n\\n    let minDist = 0\\n\\n    let mailboxIndex = Math.floor((i+j)/2)\\n\\n    for (let k=i; k<=j; k++) {\\n        minDist += Math.abs(houses[mailboxIndex]-houses[k])\\n    }\\n\\n    return minDist\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012725,
                "title": "what-would-you-do-if-you-had-only-1-mailbox",
                "content": "# Intuition\\n- If you had only 1 mailbox where would you put it? Yes, at the centre house i.e. the median. \\n- Now if you have more than 1 mailbox, then you don\\'t know where to put them. But since we know if we only have to place 1 mailbox we can try and partition the houses into groups. Again we dont know where to partition, so will partition at every index possible.\\n- Now in the first partition we know where we want to put the mailbox and we can find the distance. \\n- Now we can try and allocate the remaining mailboxes to the remaining houses.\\n\\n**NOTE: If you are thinking what if we dont make any partition and only place one mailbox, then we don\\'t actually have to worry about it because the distance will reduce the more mailboxes we place. So if we dont place all mailboxes then that distance will be bigger and will be ignored anyways. I know this was trivial but it was something that was holding me back so I just thought I would put it out there just incase anyone had the same thought.**\\n# Complexity\\n- Time complexity:\\n$$O(NlogN)+O(N^3)$$\\n\\n- Space complexity:\\n$$O(k*N)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n\\n        @cache\\n        def dfs(i,k):\\n            if i==n: return 0\\n            if k==1: return self.allocateMailbox(i,n-1,houses)\\n\\n            minDist = float(\"inf\")\\n            for j in range(i,n):\\n                dist = self.allocateMailbox(i,j,houses) + dfs(j+1,k-1)\\n                minDist = min(minDist,dist)\\n            \\n            return minDist\\n        \\n        return dfs(0,k)\\n\\n    def allocateMailbox(self,i,j,houses):\\n        bestLoc = houses[(i+j)//2]\\n        dist = 0\\n        for x in range(i,j+1):\\n            dist += abs(bestLoc-houses[x])\\n        return dist\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n\\n        @cache\\n        def dfs(i,k):\\n            if i==n: return 0\\n            if k==1: return self.allocateMailbox(i,n-1,houses)\\n\\n            minDist = float(\"inf\")\\n            for j in range(i,n):\\n                dist = self.allocateMailbox(i,j,houses) + dfs(j+1,k-1)\\n                minDist = min(minDist,dist)\\n            \\n            return minDist\\n        \\n        return dfs(0,k)\\n\\n    def allocateMailbox(self,i,j,houses):\\n        bestLoc = houses[(i+j)//2]\\n        dist = 0\\n        for x in range(i,j+1):\\n            dist += abs(bestLoc-houses[x])\\n        return dist\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961399,
                "title": "o-n-k-n-k-beats-99-6-iterating-over-integer-partitions-of-len-houses",
                "content": "# Intuition\\nThink not in terms of mailbox and house location, but rather in terms of \"zones\", where each zone corresponds to one group of houses and their nearest mailbox.\\n\\nIt can be shown that the sum distance of the houses to their mailbox within a given zone will be minimized when the mailbox is placed at the median of the house locations within the zone.  (If there are $$x$$ houses to the right of a mailbox and $$y$$ houses to the left, then moving it to the right by $$1$$ will decrease the distance sum by $$x-y$$.  Thus the distance will be minimized when $$x-y=0$$, or when $$x=y$$.  If there\\'s an odd number of houses, this occurs precisely at the median.  If there\\'s an even number of houses, then this occurs anywhere between the 2 innermost houses, which includes the median.)\\n\\nWe brute-force examine every single possible combination of which houses can go into which (contiguous) zones, and return the minimum sum distance.\\n\\nThe brute-force algorithm is very close to the algorithm for recursively iterating over all partitions of an integer with $k$ terms, using memoization, and only storing the sum distance instead of the actual partition.\\n\\n(e.g. if there are 5 houses and k=3, then the partitions of 5 with 3 terms are 1+1+3, 1+2+2, 1+3+1, 2+1+2, 2+2+1, 3+1+1. 2+1+2 would correspond to zone sizes of 2, 1, 2, or houses #1&#2 in zone 1, house #3 in zone 2, and houses #4&#5 in zone 3.)\\n\\n# Approach\\nStart with the first zone. It could have anywhere from 1 to `len(houses)-k` houses in it. Simply iterate over all of these possibilities, looking at the sum distance within the zone, and the sum distance for all other zones. Return the one that minimizes.\\n\\nFor the second zone, it could have anywhere from 1 to `len(houses)-k-i+1` houses in it, where `i` is the index of the first house in zone #2.\\n\\nFor the last zone, it must have `len(houses)-i` houses in it, and so it\\'s minimum distance is just the distance of the zone defined by `houses[i:]`.\\n\\n# Complexity\\n- Time complexity: Probably $$O\\\\left(\\\\frac{n!}{k!(n-k)!}\\\\right)$$, where $n$ is the number of houses and $k$ is the number of zones, which is the number of ways to partition the integer `len(houses)` into $k$ terms, but I might be missing out on a bit of complexity with this assessment.\\n- Space complexity: Probably $$O\\\\left(\\\\frac{n!}{k!(n-k)!}\\\\right)$$ for the memoization.\\n\\n# Code\\n```\\nfrom functools import lru_cache\\nfrom math import inf\\n\\n\\ndef int_median(sorted_nums):\\n    left = (len(sorted_nums)-1)//2  # 1 -> 0, 2 -> 0\\n    right = len(sorted_nums)//2  # 1 -> 0, 2 -> 1\\n    return (sorted_nums[left] + sorted_nums[right]) // 2\\n\\n\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        # Try brute-force recursion.....\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def zone_distance(start_i, stop_i):\\n            zone_houses = houses[start_i:stop_i]\\n            mailbox_x = int_median(zone_houses)\\n            return sum(abs(house_x-mailbox_x) for house_x in zone_houses)\\n\\n        @lru_cache(None)\\n        def recursive_minimum(i, k):\\n            \"\"\"\\nReturn the minimum sum distance for dividing houses[i:] up into k zones.\\n\"\"\"\\n            if k == 1:\\n                return zone_distance(i, len(houses))\\n            else:\\n                best = inf\\n                for j in range(i+1, len(houses)-k+2):\\n                    # If you let j be shorter, then there is not\\n                    # guaranteed at least 1 house in this zone.\\n                    # If you let j be longer, the remaning k-1 zones\\n                    # Won\\'t have enough houses to put one house in each zone.\\n                    my_distance = zone_distance(i, j)\\n                    remaining_distance_min = recursive_minimum(j, k-1)\\n                    best = min(best, my_distance + remaining_distance_min)\\n                return best\\n        \\n        return recursive_minimum(0, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import lru_cache\\nfrom math import inf\\n\\n\\ndef int_median(sorted_nums):\\n    left = (len(sorted_nums)-1)//2  # 1 -> 0, 2 -> 0\\n    right = len(sorted_nums)//2  # 1 -> 0, 2 -> 1\\n    return (sorted_nums[left] + sorted_nums[right]) // 2\\n\\n\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        # Try brute-force recursion.....\\n        houses.sort()\\n\\n        @lru_cache(None)\\n        def zone_distance(start_i, stop_i):\\n            zone_houses = houses[start_i:stop_i]\\n            mailbox_x = int_median(zone_houses)\\n            return sum(abs(house_x-mailbox_x) for house_x in zone_houses)\\n\\n        @lru_cache(None)\\n        def recursive_minimum(i, k):\\n            \"\"\"\\nReturn the minimum sum distance for dividing houses[i:] up into k zones.\\n\"\"\"\\n            if k == 1:\\n                return zone_distance(i, len(houses))\\n            else:\\n                best = inf\\n                for j in range(i+1, len(houses)-k+2):\\n                    # If you let j be shorter, then there is not\\n                    # guaranteed at least 1 house in this zone.\\n                    # If you let j be longer, the remaning k-1 zones\\n                    # Won\\'t have enough houses to put one house in each zone.\\n                    my_distance = zone_distance(i, j)\\n                    remaining_distance_min = recursive_minimum(j, k-1)\\n                    best = min(best, my_distance + remaining_distance_min)\\n                return best\\n        \\n        return recursive_minimum(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877587,
                "title": "rust-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_distance(houses: Vec<i32>, k: i32) -> i32 {\\n        let (n, k) = (houses.len(), k as usize);\\n        let mut dp = vec![vec![0; k]; n];\\n        let mut houses = houses;\\n\\n        houses.sort();\\n        Self::calculate(&houses, n - 1, k - 1, &mut dp)\\n    }\\n\\n    fn calculate(houses: &Vec<i32>, i: usize, j: usize, dp: &mut Vec<Vec<i32>>) -> i32 {\\n        if i <= j || dp[i][j] > 0 { return dp[i][j] }\\n        if j == 0 {\\n            dp[i][j] = Self::one_box(houses, 0, i);\\n            return dp[i][j]\\n        }\\n\\n        dp[i][j] = i32::MAX;\\n        for k in j ..= i {\\n            let temp = Self::one_box(houses, k, i);\\n            dp[i][j] = dp[i][j].min(temp + Self::calculate(houses, k - 1, j - 1, dp));\\n        }\\n\\n        dp[i][j]\\n    }\\n\\n    fn one_box(houses: &Vec<i32>, l: usize, r: usize) -> i32 {\\n        let mut ret = i32::MAX;\\n        for i in l ..= r {\\n            let mut temp = 0;\\n            for j in l ..= r { temp += i32::abs(houses[i] - houses[j]); }\\n            ret = ret.min(temp);\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_distance(houses: Vec<i32>, k: i32) -> i32 {\\n        let (n, k) = (houses.len(), k as usize);\\n        let mut dp = vec![vec![0; k]; n];\\n        let mut houses = houses;\\n\\n        houses.sort();\\n        Self::calculate(&houses, n - 1, k - 1, &mut dp)\\n    }\\n\\n    fn calculate(houses: &Vec<i32>, i: usize, j: usize, dp: &mut Vec<Vec<i32>>) -> i32 {\\n        if i <= j || dp[i][j] > 0 { return dp[i][j] }\\n        if j == 0 {\\n            dp[i][j] = Self::one_box(houses, 0, i);\\n            return dp[i][j]\\n        }\\n\\n        dp[i][j] = i32::MAX;\\n        for k in j ..= i {\\n            let temp = Self::one_box(houses, k, i);\\n            dp[i][j] = dp[i][j].min(temp + Self::calculate(houses, k - 1, j - 1, dp));\\n        }\\n\\n        dp[i][j]\\n    }\\n\\n    fn one_box(houses: &Vec<i32>, l: usize, r: usize) -> i32 {\\n        let mut ret = i32::MAX;\\n        for i in l ..= r {\\n            let mut temp = 0;\\n            for j in l ..= r { temp += i32::abs(houses[i] - houses[j]); }\\n            ret = ret.min(temp);\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2865484,
                "title": "simple-python-dp",
                "content": "# Intuition\\nSimple DP following hint. At each step, given houses 0...i and boxes 0...j look at all options for how many houses to associate with the last box.\\n\\n# Complexity\\n- Time complexity (outer loop * inner loop):\\n$$O(nk)*O(n^2) = O(n^3k)$$\\n\\n- Space complexity:\\n$$O(nk)$$\\n\\n# Code\\n```\\nfrom statistics import median\\n\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n\\n        # cost to serve specific houses with one mailbox\\n        def cost_one_box(houses):\\n            box = int(median(houses))\\n            return sum(abs(house - box) for house in houses)\\n\\n        # C[i][j] = cost of serving houses 0...i with mailboxes 0...j\\n        C = [[0 for _ in range(k)] for _ in range(len(houses))]\\n        for j in range(k):\\n            C[0][j] = 0\\n        for i in range(len(houses)):\\n            C[i][0] = cost_one_box(houses[:i+1])\\n        \\n        # C[i][j] = min([C[i\\'][j-1] + cost of serving houses i\\'+1...i with mailbox j] for i\\' in [0 (or j-1)...i-1]) \\n        for i in range(1, len(houses)):\\n            for j in range(1, k):\\n                C[i][j] = min(C[_i][j-1] + cost_one_box(houses[_i+1:i+1]) for _i in range(min(i-1,j-1), i))\\n                \\n        return C[-1][-1]\\n                \\n\\n         \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom statistics import median\\n\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n\\n        # cost to serve specific houses with one mailbox\\n        def cost_one_box(houses):\\n            box = int(median(houses))\\n            return sum(abs(house - box) for house in houses)\\n\\n        # C[i][j] = cost of serving houses 0...i with mailboxes 0...j\\n        C = [[0 for _ in range(k)] for _ in range(len(houses))]\\n        for j in range(k):\\n            C[0][j] = 0\\n        for i in range(len(houses)):\\n            C[i][0] = cost_one_box(houses[:i+1])\\n        \\n        # C[i][j] = min([C[i\\'][j-1] + cost of serving houses i\\'+1...i with mailbox j] for i\\' in [0 (or j-1)...i-1]) \\n        for i in range(1, len(houses)):\\n            for j in range(1, k):\\n                C[i][j] = min(C[_i][j-1] + cost_one_box(houses[_i+1:i+1]) for _i in range(min(i-1,j-1), i))\\n                \\n        return C[-1][-1]\\n                \\n\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856746,
                "title": "java-using-recursion-memoization-and-median-to-get-min-distance",
                "content": "# class Solution {\\n    int[][] dp;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        dp = new int[houses.length+1][k+1];\\n        return recursion(houses, k, 0);\\n    }\\n    \\n    int recursion(int[] houses, int k, int start){\\n        if(start == houses.length && k > 1){\\n            return 1000000;\\n        }\\n        if(k==1){\\n            int currentTotalDistance = getDistance(start, houses.length-1, houses); \\n            return currentTotalDistance;\\n        }\\n        if(dp[start][k] != 0){\\n            return dp[start][k];\\n        }\\n        \\n        int retDistance = 1000000;\\n        for(int i=start; i< houses.length; i++){\\n            int currentTotalDistance = getDistance(start, i, houses);\\n            int remainingTotalDistance = recursion(houses, k-1, i+1);\\n            retDistance = Math.min(retDistance, currentTotalDistance+remainingTotalDistance);\\n        }\\n        \\n        dp[start][k] = retDistance;\\n        return retDistance;\\n    }\\n    \\n    \\n    //finding minimum distance using median value\\n    int getDistance(int start, int end, int[] houses){\\n        int mid = (end+start)/2;\\n        int distance = 0;\\n        for(int i=start; i<= end; i++){\\n            distance += Math.abs(houses[mid]-houses[i]);\\n        }\\n        \\n        return distance;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[][] dp;\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        dp = new int[houses.length+1][k+1];\\n        return recursion(houses, k, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2777900,
                "title": "swift-solution-beats-100",
                "content": "## Code \\n\\n```\\n// Allocate mailboxes\\n// https://leetcode.com/problems/allocate-mailboxes/\\n\\nclass Solution {\\n    func minDistance(_ houses: [Int], _ k: Int) -> Int {\\n        let houses = houses.sorted()\\n        var dp = Array(repeating: Array(repeating: Int.max, count: houses.count), count: k)\\n        for i in 0..<houses.count {\\n            dp[0][i] = cost(houses, 0, i)\\n        }\\n        for i in 1..<k {\\n            for j in i..<houses.count {\\n                for m in i-1..<j {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][m] + cost(houses, m+1, j))\\n                }\\n            }\\n        }\\n        return dp[k-1][houses.count-1]\\n    }\\n    \\n    func cost(_ houses: [Int], _ start: Int, _ end: Int) -> Int {\\n        var cost = 0\\n        let mid = houses[(start+end)/2]\\n        for i in start...end {\\n            cost += abs(houses[i] - mid)\\n        }\\n        return cost\\n    }\\n}\\n```\\n\\n## Explanation\\n\\n. Sort the houses in ascending order.\\n. For each mailbox 1 to k, for each house, find the \"average\" distance to all the houses after it. This is done by filling dp[k][i] with the lowest cost of putting a mailbox at the midpoint between the houses at index i and j, where i < j. The cost is the sum of the distances to all the houses between i and j.\\n. Return the lowest cost of putting k mailboxes after sorting the houses.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// Allocate mailboxes\\n// https://leetcode.com/problems/allocate-mailboxes/\\n\\nclass Solution {\\n    func minDistance(_ houses: [Int], _ k: Int) -> Int {\\n        let houses = houses.sorted()\\n        var dp = Array(repeating: Array(repeating: Int.max, count: houses.count), count: k)\\n        for i in 0..<houses.count {\\n            dp[0][i] = cost(houses, 0, i)\\n        }\\n        for i in 1..<k {\\n            for j in i..<houses.count {\\n                for m in i-1..<j {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][m] + cost(houses, m+1, j))\\n                }\\n            }\\n        }\\n        return dp[k-1][houses.count-1]\\n    }\\n    \\n    func cost(_ houses: [Int], _ start: Int, _ end: Int) -> Int {\\n        var cost = 0\\n        let mid = houses[(start+end)/2]\\n        for i in start...end {\\n            cost += abs(houses[i] - mid)\\n        }\\n        return cost\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727581,
                "title": "c-dfs-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        auto memo = vector<vector<int>>(houses.size(), vector<int>(k + 1, -1));\\n        sort(houses.begin(), houses.end());\\n        return DFS(0, 1, k, houses, memo);\\n    }   \\n\\n    int DFS(int index, int group, int k, vector<int>& houses, vector<vector<int>>& memo){\\n        if(index >= houses.size()){\\n            // only when index reaches the end but the group has not reached k\\n            return INT_MAX / 2;\\n        }\\n\\n        if(memo[index][group] != -1){\\n            return memo[index][group];\\n        }\\n\\n        if(group == k){\\n            return calDistance(index, houses.size()-1, houses);\\n        }\\n\\n        int res = INT_MAX / 2;\\n\\n        for(int i=index; i<houses.size(); i++){\\n            int local_distance = calDistance(index, i, houses);\\n            res = min(res, local_distance + DFS(i + 1, group + 1, k, houses, memo));\\n        }\\n        // update memo\\n        memo[index][group] = res;\\n\\n        return res;\\n    }\\n\\n    int calDistance(int start, int end, vector<int>& houses){\\n        int mid = (end + start) / 2;\\n        int res = 0;\\n        for(int i = start; i <= end; i++){\\n            res += abs(houses[i] - houses[mid]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        auto memo = vector<vector<int>>(houses.size(), vector<int>(k + 1, -1));\\n        sort(houses.begin(), houses.end());\\n        return DFS(0, 1, k, houses, memo);\\n    }   \\n\\n    int DFS(int index, int group, int k, vector<int>& houses, vector<vector<int>>& memo){\\n        if(index >= houses.size()){\\n            // only when index reaches the end but the group has not reached k\\n            return INT_MAX / 2;\\n        }\\n\\n        if(memo[index][group] != -1){\\n            return memo[index][group];\\n        }\\n\\n        if(group == k){\\n            return calDistance(index, houses.size()-1, houses);\\n        }\\n\\n        int res = INT_MAX / 2;\\n\\n        for(int i=index; i<houses.size(); i++){\\n            int local_distance = calDistance(index, i, houses);\\n            res = min(res, local_distance + DFS(i + 1, group + 1, k, houses, memo));\\n        }\\n        // update memo\\n        memo[index][group] = res;\\n\\n        return res;\\n    }\\n\\n    int calDistance(int start, int end, vector<int>& houses){\\n        int mid = (end + start) / 2;\\n        int res = 0;\\n        for(int i = start; i <= end; i++){\\n            res += abs(houses[i] - houses[mid]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727555,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        \\n        int[][] minDist = new int[n][n];\\n        \\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < n - i; j++) {\\n                minDist[j][j + i] = minDistance(houses, j, j + i);\\n            }\\n        }\\n       \\n        int[][] dp = new int[k][n];\\n        \\n        for(int i = 0; i < k; i++) {\\n            for(int j = i; j < n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = minDist[i][j];\\n                else {\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                    \\n                    for(int m = j; m >= i; m--) {\\n                        dp[i][j] = Math.min(dp[i - 1][m - 1] + minDist[m][j], dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[k - 1][n - 1];\\n    }\\n    \\n    public int minDistance(int[] houses, int i, int j) {\\n        int mid = (i + j)/2;\\n        int median = (j - i + 1)%2 == 0 ? (houses[mid] + houses[mid + 1])/2 : houses[mid];\\n        int sum = 0;\\n\\n        while(i <= j) {\\n            sum += Math.abs(median - houses[i]);\\n            i++;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minDistance(int[] houses, int k) {\\n        int n = houses.length;\\n        Arrays.sort(houses);\\n        \\n        int[][] minDist = new int[n][n];\\n        \\n        for(int i = 1; i < n; i++) {\\n            for(int j = 0; j < n - i; j++) {\\n                minDist[j][j + i] = minDistance(houses, j, j + i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2722073,
                "title": "top-down-dp-python",
                "content": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @cache\\n        def calcDistance(i, j):\\n            medianHousePos = houses[(i + j) // 2]\\n            distance = 0\\n            for idx in range(i, j + 1):\\n                distance += abs(medianHousePos - houses[idx])\\n            return distance\\n        \\n        @cache\\n        def dp(i, left):\\n            if i >= N:\\n                return 0\\n            if left == 1:\\n                return calcDistance(i, N - 1)\\n            \\n            ans = float(\\'inf\\')\\n            # Place a mailbox at house j \\n            # (which is a house between house i and the end of the street)\\n            for j in range(i, N):\\n                ans = min(ans, calcDistance(i, j) + dp(j + 1, left - 1))\\n            return ans       \\n        \\n        N = len(houses)\\n        houses.sort()\\n        return dp(0, k)\\n    # Time: O(N^3 * k)\\n    # Space: O(N * k)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @cache\\n        def calcDistance(i, j):\\n            medianHousePos = houses[(i + j) // 2]\\n            distance = 0\\n            for idx in range(i, j + 1):\\n                distance += abs(medianHousePos - houses[idx])\\n            return distance\\n        \\n        @cache\\n        def dp(i, left):\\n            if i >= N:\\n                return 0\\n            if left == 1:\\n                return calcDistance(i, N - 1)\\n            \\n            ans = float(\\'inf\\')\\n            # Place a mailbox at house j \\n            # (which is a house between house i and the end of the street)\\n            for j in range(i, N):\\n                ans = min(ans, calcDistance(i, j) + dp(j + 1, left - 1))\\n            return ans       \\n        \\n        N = len(houses)\\n        houses.sort()\\n        return dp(0, k)\\n    # Time: O(N^3 * k)\\n    # Space: O(N * k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703472,
                "title": "c-concise-recursion-with-memoization-o-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(std::vector<int> & houses, int k) {\\n        std::sort(std::begin(houses), std::end(houses));\\n        std::vector<std::vector<int>> memo(std::size(houses), std::vector<int>(k + 1, -1));\\n        std::function<int (int, int)> getMinimumTotalDistance = [&houses] (int firstHouse, int lastHouse) noexcept {\\n            int median = (lastHouse - firstHouse) & 1 ? (houses[(lastHouse + firstHouse) >> 1] + houses[((lastHouse + firstHouse) >> 1) + 1]) >> 1 : houses[(lastHouse + firstHouse) >> 1];\\n            int sum = 0;\\n            for (; firstHouse <= lastHouse; ++firstHouse)\\n                sum += std::abs(median - houses[firstHouse]);\\n            return sum;\\n        };\\n        std::function<int (int, int)> dfs = [&] (int house, int boxes) noexcept {\\n            if (memo[house][boxes] != -1)\\n                return memo[house][boxes];\\n            if (boxes == 1)\\n                return getMinimumTotalDistance(house, std::size(houses) - 1);            \\n            int min = INT_MAX;\\n            for (int i = house; i < std::size(houses) - (boxes - 1); ++i)\\n                min = std::min(min, getMinimumTotalDistance(house, i) + dfs(i + 1, boxes - 1));\\n            return memo[house][boxes] = min;\\n        };\\n        return dfs(0, k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(std::vector<int> & houses, int k) {\\n        std::sort(std::begin(houses), std::end(houses));\\n        std::vector<std::vector<int>> memo(std::size(houses), std::vector<int>(k + 1, -1));\\n        std::function<int (int, int)> getMinimumTotalDistance = [&houses] (int firstHouse, int lastHouse) noexcept {\\n            int median = (lastHouse - firstHouse) & 1 ? (houses[(lastHouse + firstHouse) >> 1] + houses[((lastHouse + firstHouse) >> 1) + 1]) >> 1 : houses[(lastHouse + firstHouse) >> 1];\\n            int sum = 0;\\n            for (; firstHouse <= lastHouse; ++firstHouse)\\n                sum += std::abs(median - houses[firstHouse]);\\n            return sum;\\n        };\\n        std::function<int (int, int)> dfs = [&] (int house, int boxes) noexcept {\\n            if (memo[house][boxes] != -1)\\n                return memo[house][boxes];\\n            if (boxes == 1)\\n                return getMinimumTotalDistance(house, std::size(houses) - 1);            \\n            int min = INT_MAX;\\n            for (int i = house; i < std::size(houses) - (boxes - 1); ++i)\\n                min = std::min(min, getMinimumTotalDistance(house, i) + dfs(i + 1, boxes - 1));\\n            return memo[house][boxes] = min;\\n        };\\n        return dfs(0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645236,
                "title": "java-top-down-dynamic-programming-approach",
                "content": "# Approach\\nWhen K == 1, theres only 1 mailbox. So, we put it in the median of the what we are currently checking. For example [4,8,20], we put the mailbox at 8, and then we calculate the difference accordingly.\\n\\nWhen K == len(houses), this is also trivial, you can put a mailbox at every house, so distance will be 0.\\n\\nSo with base cases considered, we now go to higher numbers of K. What if K == 2? Then we can portion one part of the house into one group, put a mailbox there, and the remaining houses will be another group putting another mailbox. E.g\\n\\n[1, 300, 301, 302] can be thought as:\\n[1], [300, 301, 302] OR\\n[1, 300], [301, 302] OR\\n[1, 300, 301], [302]\\n\\nSo this is when K == 2. Right now we can visually see that the first answer is the best.\\n\\nConsider further, if K == 3. Then decide where we want to put the first group, and then solve the subproblems recursively. Same example as above.\\n\\n[1] (first group) [300,301,302] will be split into another 2 groups. So it will recursively call\\n[300] [301, 302]\\n[300, 301] [302]\\n\\nOR\\n[1, 300] - > first group, [301, 302] - > split this into another 2 groups. Then\\n[301], [302]\\n\\nRecently I learnt that DP can be thought as a careful brute force (thanks MIT openware :)) and I think it really shows here. We do not know where to cut the mailboxes into group, so what do we do? We try everything, partioning at every possible place, but saving the answer prevents us from doing something multiple times.\\n\\nIn general, we pick a place to form one group, then, the remaining elements must form K - 1 groups, and we try to minimise the answer.\\n\\n\\n# Complexity\\n- Time complexity: $$O(k * n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k * n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][][] dp;\\n    int[] houses;\\n    public int minDistance(int[] h, int k) {\\n        houses = h;\\n        // Sort the houses, cause we don\\'t want to have a situation like [301, 240, 360]\\n        // and without sorting we\\'d place the mailbox at the box element, i.e. 240, which is inefficient\\n        // instead it should have been placed at 301.\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        dp = new int[n][n][k + 1];\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n\\n        return recurse(0, n - 1, k);\\n    }\\n\\n    // left = left index of sorted houses\\n    // right = including right index\\n    // k = number of mailboxes that we can place for this group\\n    private int recurse(int left, int right, int k) {\\n        // previously computed, lets not waster time to compute it again\\n        if (dp[left][right][k] != -1) return  dp[left][right][k];\\n        \\n        // too many mailboxes, too little houses, we have done something wrong in grouping earlier houses.\\n        // So return an impossible answer\\n        if (right - left + 1 < k) return (int)(1e4 + 1);\\n        \\n        // Base case: one mailbox, put mailbox in median of house\\n        if (k == 1) {\\n            int mid = left + (right - left) / 2;\\n            int ans = 0;\\n            for (int i = left; i <= right; ++i) {\\n                ans += Math.abs(houses[i] - houses[mid]);\\n            }\\n            dp[left][right][k] = ans;\\n            return ans;\\n        }\\n\\n        // have a mailbox for every house, great!\\n        if (right - left + 1 == k) return 0;\\n        \\n        int ans = Integer.MAX_VALUE;\\n\\n        // \\'Careful brute force\\'\\n        // - MIT CS Opencourseware\\n        for (int i = left; i < right; ++i) {\\n            ans = Math.min(ans, recurse(left, i, 1) + recurse(i + 1, right, k - 1));\\n        }\\n\\n        // Store answer\\n        dp[left][right][k] = ans;\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[][][] dp;\\n    int[] houses;\\n    public int minDistance(int[] h, int k) {\\n        houses = h;\\n        // Sort the houses, cause we don\\'t want to have a situation like [301, 240, 360]\\n        // and without sorting we\\'d place the mailbox at the box element, i.e. 240, which is inefficient\\n        // instead it should have been placed at 301.\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        dp = new int[n][n][k + 1];\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n\\n        return recurse(0, n - 1, k);\\n    }\\n\\n    // left = left index of sorted houses\\n    // right = including right index\\n    // k = number of mailboxes that we can place for this group\\n    private int recurse(int left, int right, int k) {\\n        // previously computed, lets not waster time to compute it again\\n        if (dp[left][right][k] != -1) return  dp[left][right][k];\\n        \\n        // too many mailboxes, too little houses, we have done something wrong in grouping earlier houses.\\n        // So return an impossible answer\\n        if (right - left + 1 < k) return (int)(1e4 + 1);\\n        \\n        // Base case: one mailbox, put mailbox in median of house\\n        if (k == 1) {\\n            int mid = left + (right - left) / 2;\\n            int ans = 0;\\n            for (int i = left; i <= right; ++i) {\\n                ans += Math.abs(houses[i] - houses[mid]);\\n            }\\n            dp[left][right][k] = ans;\\n            return ans;\\n        }\\n\\n        // have a mailbox for every house, great!\\n        if (right - left + 1 == k) return 0;\\n        \\n        int ans = Integer.MAX_VALUE;\\n\\n        // \\'Careful brute force\\'\\n        // - MIT CS Opencourseware\\n        for (int i = left; i < right; ++i) {\\n            ans = Math.min(ans, recurse(left, i, 1) + recurse(i + 1, right, k - 1));\\n        }\\n\\n        // Store answer\\n        dp[left][right][k] = ans;\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634687,
                "title": "python-recursive-dp-using-median-of-chunks",
                "content": "I divided the list in to smaller subarrays and found their minimum distances using dp\\nminimum distance can be obtained by placing mail box on their median\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        \\n        @cache\\n        def calculate_distance(i, j):\\n            median = houses[i+j >> 1]\\n            return sum(abs(houses[x]-median) for x in range(i,j+1))\\n        \\n        n = len(houses)\\n\\n        @cache\\n        def dp(start=0, k=k):\\n            if k == 1:\\n                return calculate_distance(start, n-1)\\n            \\n            res = float(\\'inf\\')\\n            for nxt in range(start+1, n):\\n                res = min(res, dp(nxt, k-1)+calculate_distance(start, nxt-1))\\n\\n            return res\\n\\n        \\n        return dp()\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        \\n        @cache\\n        def calculate_distance(i, j):\\n            median = houses[i+j >> 1]\\n            return sum(abs(houses[x]-median) for x in range(i,j+1))\\n        \\n        n = len(houses)\\n\\n        @cache\\n        def dp(start=0, k=k):\\n            if k == 1:\\n                return calculate_distance(start, n-1)\\n            \\n            res = float(\\'inf\\')\\n            for nxt in range(start+1, n):\\n                res = min(res, dp(nxt, k-1)+calculate_distance(start, nxt-1))\\n\\n            return res\\n\\n        \\n        return dp()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614662,
                "title": "easy-to-understand-array-partitioning-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDistance(vector <int> &houses, int s, int e) {\\n\\t\\t// Distance to median\\n        int l = s, r = e, d = 0;\\n        \\n        while(l < r) {\\n            d += houses[r] - houses[l];\\n            \\n            l++;\\n            r--;\\n        }\\n        \\n        return d;\\n    }\\n    \\n    int positionMailboxes(vector<int>& houses, int k, int idx, vector <vector<int>> &cache) {\\n        if(idx >= houses.size()) {\\n            if(k == 0) return 0;\\n            return INT_MAX;\\n        }\\n        if(k == 0) {\\n            return getDistance(houses, idx, houses.size() - 1);\\n        }\\n        if(cache[idx][k] != -1) {\\n            return cache[idx][k];\\n        }\\n        \\n        int dist = INT_MAX;\\n        \\n        for(int i = idx; i < houses.size(); i++) {\\n            int res = positionMailboxes(houses, k - 1, i + 1, cache);\\n            \\n            if(res != INT_MAX) {\\n                dist = min(\\n                    dist, \\n                    getDistance(houses, idx, i) + res\\n                ); \\n            }\\n        }\\n                           \\n        return cache[idx][k] = dist;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(), houses.end());\\n        vector <vector<int>> cache(houses.size(), vector<int>(k, -1));\\n        \\n        // making (k - 1) partitions to split array into k blocks\\n        return positionMailboxes(houses, k - 1, 0, cache);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDistance(vector <int> &houses, int s, int e) {\\n\\t\\t// Distance to median\\n        int l = s, r = e, d = 0;\\n        \\n        while(l < r) {\\n            d += houses[r] - houses[l];\\n            \\n            l++;\\n            r--;\\n        }\\n        \\n        return d;\\n    }\\n    \\n    int positionMailboxes(vector<int>& houses, int k, int idx, vector <vector<int>> &cache) {\\n        if(idx >= houses.size()) {\\n            if(k == 0) return 0;\\n            return INT_MAX;\\n        }\\n        if(k == 0) {\\n            return getDistance(houses, idx, houses.size() - 1);\\n        }\\n        if(cache[idx][k] != -1) {\\n            return cache[idx][k];\\n        }\\n        \\n        int dist = INT_MAX;\\n        \\n        for(int i = idx; i < houses.size(); i++) {\\n            int res = positionMailboxes(houses, k - 1, i + 1, cache);\\n            \\n            if(res != INT_MAX) {\\n                dist = min(\\n                    dist, \\n                    getDistance(houses, idx, i) + res\\n                ); \\n            }\\n        }\\n                           \\n        return cache[idx][k] = dist;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(), houses.end());\\n        vector <vector<int>> cache(houses.size(), vector<int>(k, -1));\\n        \\n        // making (k - 1) partitions to split array into k blocks\\n        return positionMailboxes(houses, k - 1, 0, cache);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602693,
                "title": "splitting-array-into-k",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findMiddle(int i, int j, vector<int>& houses) {\\n\\t\\t\\tint x = 0;\\n\\t\\t\\tfor(int k = i+1; k <= j; k++) {\\n\\t\\t\\t\\tx += houses[k]-houses[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = x;\\n\\t\\t\\tfor(int k = i+1; k <= j; k++) {\\n\\t\\t\\t\\tx += (k-i-j+k-1) * abs(houses[k]-houses[k-1]);\\n\\t\\t\\t\\tans = min(x, ans);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tint dp[101][101];\\n\\n\\t\\tint solve(int i, int k, vector<int>& houses) {\\n\\t\\t\\tif(houses.size()-i <= k)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tif(dp[i][k] != -1)\\n\\t\\t\\t\\treturn dp[i][k];\\n\\n\\t\\t\\tif(k == 1) {\\n\\t\\t\\t\\treturn dp[i][k] = findMiddle(i, houses.size()-1, houses);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint c = i;\\n\\t\\t\\tint x = 0;\\n\\t\\t\\tint temp = INT_MAX;\\n\\t\\t\\tfor(int j=i+1; j < houses.size(); j++) {\\n\\t\\t\\t\\tint t = solve(j, k-1, houses);\\n\\t\\t\\t\\tif(t != INT_MAX)\\n\\t\\t\\t\\t\\ttemp = min(x+t, temp);\\n\\n\\t\\t\\t\\tx += abs(houses[j]-houses[c]);\\n\\t\\t\\t\\twhile((2*(c+1)-(i+j+1))*abs(houses[c+1]-houses[c])<0) {\\n\\t\\t\\t\\t\\tx += (2*(c+1)-(i+j+1))*abs(houses[c+1]-houses[c]);\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[i][k] = temp;\\n\\t\\t}\\n\\n\\t\\tint minDistance(vector<int>& houses, int k) {\\n\\t\\t\\tsort(houses.begin(), houses.end());\\n\\t\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\t\\tif(houses.size() == k)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\treturn solve(0, k, houses);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findMiddle(int i, int j, vector<int>& houses) {\\n\\t\\t\\tint x = 0;\\n\\t\\t\\tfor(int k = i+1; k <= j; k++) {\\n\\t\\t\\t\\tx += houses[k]-houses[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2574398,
                "title": "c",
                "content": "class Solution {\\npublic:\\n\\n    int find(int ind, int k, vector<int>& houses, vector<vector<int>>& dp) {\\n        if(k<0) return 1e9;\\n        if(ind>=houses.size()) return k? 1e9:0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n        int ans=1e9;\\n        \\n        for(int i=ind; i<houses.size(); i++) {\\n            int mid=ind+(i-ind)/2;\\n            int cost=0;\\n            \\n            for(int j=ind; j<=i; j++)\\n                cost+=abs(houses[mid]-houses[j]);\\n            \\n            ans=min(ans, cost+find(i+1, k-1, houses, dp));\\n        }\\n        \\n        return dp[ind][k]=ans;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(), houses.end());\\n        \\n        vector<vector<int>>dp(houses.size(),vector<int>(k+1,-1));\\n        return find(0, k, houses, dp);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int find(int ind, int k, vector<int>& houses, vector<vector<int>>& dp) {\\n        if(k<0) return 1e9;\\n        if(ind>=houses.size()) return k? 1e9:0;\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n        int ans=1e9;\\n        \\n        for(int i=ind; i<houses.size(); i++) {\\n            int mid=ind+(i-ind)/2;\\n            int cost=0;\\n            \\n            for(int j=ind; j<=i; j++)\\n                cost+=abs(houses[mid]-houses[j]);\\n            \\n            ans=min(ans, cost+find(i+1, k-1, houses, dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2570382,
                "title": "very-simple-javascript-solution-beats-91-91-other-submissions-clean-code",
                "content": "I discovered this Github repository that contains solutions for Leetcode problems https://github.com/AnasImloul/Leetcode-solutions\\nIt is very helpful, and I recommend checking it out.\\n\\n```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n    var distance=[],median,dist,cache={};\\n    houses.sort(function(a,b){return a-b});\\n    //distance[i][j] is the minimun distacne if we cover houses from ith index to jth index with 1 mailbox. This mailbox will be at the median index of sub array from ith index to jth index.\\n    for(let i=0;i<houses.length;i++){\\n        for(let j=i;j<houses.length;j++){\\n            median = Math.floor((i+j)/2);\\n            dist=0;\\n            for(let k=i;k<=j;k++){\\n                dist+=Math.abs(houses[median]-houses[k]);\\n            }\\n            if(distance[i]===undefined){\\n                distance[i]=[];\\n            }\\n            distance[i][j]=dist;\\n        }\\n    }\\n    return dp(0,k);\\n    function dp(i,k){\\n        let cacheKey=i+\"_\"+k;\\n        if(cache[cacheKey]!==undefined){\\n            return cache[cacheKey];\\n        }\\n        let min=Number.MAX_SAFE_INTEGER,ans;\\n        if(i===houses.length && k===0){//Its a correct answer only if we have used all the mailboxes and all the houses are completed. \\n            return 0;\\n        }\\n        if(i===houses.length || k===0){//Other than the first if condition, every other condition to exhaust either mailboxes for houses is an invalid answer. So returning minus an infinite number from here. \\n            return min;\\n        }\\n        \\n        for(let j=i;j<houses.length;j++){//Here in each step we are covering houses from ith index to jth index with one mailbox and calling dp function to cover the rest of the houses, starting from jth+1 index with the remaining k-1 houses. In each possible answer we will keep the minimum ans. \\n            ans = dp(j+1,k-1)+distance[i][j];\\n            min = Math.min(min,ans);\\n        }\\n        cache[cacheKey]=min;\\n        return min;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n    var distance=[],median,dist,cache={};\\n    houses.sort(function(a,b){return a-b});\\n    //distance[i][j] is the minimun distacne if we cover houses from ith index to jth index with 1 mailbox. This mailbox will be at the median index of sub array from ith index to jth index.\\n    for(let i=0;i<houses.length;i++){\\n        for(let j=i;j<houses.length;j++){\\n            median = Math.floor((i+j)/2);\\n            dist=0;\\n            for(let k=i;k<=j;k++){\\n                dist+=Math.abs(houses[median]-houses[k]);\\n            }\\n            if(distance[i]===undefined){\\n                distance[i]=[];\\n            }\\n            distance[i][j]=dist;\\n        }\\n    }\\n    return dp(0,k);\\n    function dp(i,k){\\n        let cacheKey=i+\"_\"+k;\\n        if(cache[cacheKey]!==undefined){\\n            return cache[cacheKey];\\n        }\\n        let min=Number.MAX_SAFE_INTEGER,ans;\\n        if(i===houses.length && k===0){//Its a correct answer only if we have used all the mailboxes and all the houses are completed. \\n            return 0;\\n        }\\n        if(i===houses.length || k===0){//Other than the first if condition, every other condition to exhaust either mailboxes for houses is an invalid answer. So returning minus an infinite number from here. \\n            return min;\\n        }\\n        \\n        for(let j=i;j<houses.length;j++){//Here in each step we are covering houses from ith index to jth index with one mailbox and calling dp function to cover the rest of the houses, starting from jth+1 index with the remaining k-1 houses. In each possible answer we will keep the minimum ans. \\n            ans = dp(j+1,k-1)+distance[i][j];\\n            min = Math.min(min,ans);\\n        }\\n        cache[cacheKey]=min;\\n        return min;\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522847,
                "title": "cpp-mcm-variation-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dist;\\n    int distance(int i,int j){\\n        return dist[i][j];\\n    }\\n    int memo[101][101][101];\\n    int mcm(vector<int> &h,int i,int j,int m){\\n        if(m==1){\\n            return distance(i,j);\\n        }\\n        if(memo[i][j][m]!=-1) return memo[i][j][m];\\n        int temp = 1000000;\\n        for(int k=i;k<j;k++){\\n            int val = distance(i,k);\\n            temp = min(temp,val+mcm(h,k+1,j,m-1));\\n        }\\n        return memo[i][j][m]=temp;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(),houses.end());\\n        memset(memo,-1,sizeof(memo));\\n        dist.assign(houses.size(),vector<int>(houses.size(),0));\\n        for(int i=0;i<houses.size();i++){\\n            for(int j=i;j<houses.size();j++){\\n                int n = (i+j)/2;\\n                for(int l=i;l<=j;l++){\\n                    dist[i][j] += abs(houses[l]-houses[n]);\\n                }\\n            }\\n        }\\n       \\n        return mcm(houses,0,houses.size()-1,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dist;\\n    int distance(int i,int j){\\n        return dist[i][j];\\n    }\\n    int memo[101][101][101];\\n    int mcm(vector<int> &h,int i,int j,int m){\\n        if(m==1){\\n            return distance(i,j);\\n        }\\n        if(memo[i][j][m]!=-1) return memo[i][j][m];\\n        int temp = 1000000;\\n        for(int k=i;k<j;k++){\\n            int val = distance(i,k);\\n            temp = min(temp,val+mcm(h,k+1,j,m-1));\\n        }\\n        return memo[i][j][m]=temp;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(),houses.end());\\n        memset(memo,-1,sizeof(memo));\\n        dist.assign(houses.size(),vector<int>(houses.size(),0));\\n        for(int i=0;i<houses.size();i++){\\n            for(int j=i;j<houses.size();j++){\\n                int n = (i+j)/2;\\n                for(int l=i;l<=j;l++){\\n                    dist[i][j] += abs(houses[l]-houses[n]);\\n                }\\n            }\\n        }\\n       \\n        return mcm(houses,0,houses.size()-1,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512807,
                "title": "c-top-down-dp-with-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][102];\\n    vector<int> prefix;\\n    \\n    int prefsum(vector<int> &nums,int lo,int hi){\\n        return (prefix[hi] - (lo-1>=0?prefix[lo-1]:0));\\n    }\\n    int cost(vector<int> &nums,int lo,int hi){\\n        int m = (hi-lo)/2 + lo;\\n        int am = nums[m];\\n        \\n        return ((m-lo+1)*am - prefsum(nums,lo,m)) + (prefsum(nums,m+1,hi) - (hi-m)*am);\\n    }\\n    \\n    int infinity = (1<<20);\\n    \\n    int solve(int i,int j,int k,vector<int> &nums){\\n        if(k == 1){\\n            return cost(nums,i,j);\\n        }\\n        if(k>(j-i+1)) return infinity;\\n        \\n        if(dp[i][j][k] != -1) return dp[i][j][k];\\n        \\n        int minsum = infinity;\\n        for(int kp=i;kp<=j-1;kp++){\\n            minsum = min(minsum,solve(i,kp,1,nums)+solve(kp+1,j,k-1,nums));\\n        }\\n        return dp[i][j][k] = minsum;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        for(int i=0;i<102;i++){\\n            for(int j=0;j<102;j++){\\n                for(int k=0;k<102;k++){\\n                    dp[i][j][k] = -1;\\n                }   \\n            }      \\n        }\\n        \\n        sort(houses.begin(),houses.end());\\n        prefix.resize(houses.size());\\n        \\n        prefix[0] = houses[0];\\n        for(int i=1;i<houses.size();i++){\\n            prefix[i] = prefix[i-1]+houses[i];\\n        }\\n        \\n              \\n        return solve(0,houses.size()-1,k,houses);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][102];\\n    vector<int> prefix;\\n    \\n    int prefsum(vector<int> &nums,int lo,int hi){\\n        return (prefix[hi] - (lo-1>=0?prefix[lo-1]:0));\\n    }\\n    int cost(vector<int> &nums,int lo,int hi){\\n        int m = (hi-lo)/2 + lo;\\n        int am = nums[m];\\n        \\n        return ((m-lo+1)*am - prefsum(nums,lo,m)) + (prefsum(nums,m+1,hi) - (hi-m)*am);\\n    }\\n    \\n    int infinity = (1<<20);\\n    \\n    int solve(int i,int j,int k,vector<int> &nums){\\n        if(k == 1){\\n            return cost(nums,i,j);\\n        }\\n        if(k>(j-i+1)) return infinity;\\n        \\n        if(dp[i][j][k] != -1) return dp[i][j][k];\\n        \\n        int minsum = infinity;\\n        for(int kp=i;kp<=j-1;kp++){\\n            minsum = min(minsum,solve(i,kp,1,nums)+solve(kp+1,j,k-1,nums));\\n        }\\n        return dp[i][j][k] = minsum;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        for(int i=0;i<102;i++){\\n            for(int j=0;j<102;j++){\\n                for(int k=0;k<102;k++){\\n                    dp[i][j][k] = -1;\\n                }   \\n            }      \\n        }\\n        \\n        sort(houses.begin(),houses.end());\\n        prefix.resize(houses.size());\\n        \\n        prefix[0] = houses[0];\\n        for(int i=1;i<houses.size();i++){\\n            prefix[i] = prefix[i-1]+houses[i];\\n        }\\n        \\n              \\n        return solve(0,houses.size()-1,k,houses);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507999,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>> dp(n, vector<int> (k + 1, INF));\\n        auto getSum = [&] (int l, int r) {\\n            int m = (l + r) / 2;\\n            int total = 0;\\n            for (int i = l; i <= r; i++) {\\n                total += abs(houses[i] - houses[m]);\\n            }\\n            return total;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            dp[i][1] = getSum(0, i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 2; j <= k; j++) {\\n                for (int l = 0; l + 1 <= i; l++) {\\n                    dp[i][j] = min(dp[i][j], dp[l][j - 1] + getSum(l + 1, i));\\n                }\\n            }\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>> dp(n, vector<int> (k + 1, INF));\\n        auto getSum = [&] (int l, int r) {\\n            int m = (l + r) / 2;\\n            int total = 0;\\n            for (int i = l; i <= r; i++) {\\n                total += abs(houses[i] - houses[m]);\\n            }\\n            return total;\\n        };\\n        for (int i = 0; i < n; i++) {\\n            dp[i][1] = getSum(0, i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 2; j <= k; j++) {\\n                for (int l = 0; l + 1 <= i; l++) {\\n                    dp[i][j] = min(dp[i][j], dp[l][j - 1] + getSum(l + 1, i));\\n                }\\n            }\\n        }\\n        return dp[n - 1][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434096,
                "title": "simple-recursive-solution",
                "content": "class Solution {\\npublic:\\n    \\n    #define ll long long\\n    vector<vector<int>>pre_comput;\\n    int dp[101][101][101];\\n    \\n    \\n    // ll cost(vector<int>&houses,int prev,int index){\\n    //     vector<int>temp;\\n    //     for(int i=prev;i<index;i++){\\n    //         temp.push_back(houses[i]);\\n    //     }\\n    //     int n=temp.size(),answer=0,m=n/2;\\n    //     for(int i=0;i<n;i++){\\n    //         answer+=abs(temp[i]-temp[m]);    \\n    //     }\\n    //     return answer;\\n    // }\\n    \\n    ll solve(vector<int>&houses,int index,int n,int k,int prev){\\n        if(k==1){\\n            return pre_comput[prev][n-1]; \\n        }\\n        if(index>=n){\\n            return INT_MAX;\\n        }\\n        if(dp[index][k][prev]!=-1){\\n            return dp[index][k][prev];\\n        }\\n        ll total,a=INT_MAX,b=INT_MAX;\\n        a=solve(houses,index+1,n,k,prev); \\n        b=pre_comput[prev][index-1]+solve(houses,index+1,n,k-1,index);\\n        total=min(a,b);\\n        return dp[index][k][prev]=total;\\n    }\\n    \\n    ll minDistance(vector<int>& houses,int k) {\\n        sort(houses.begin(),houses.end());\\n        ll n=houses.size();memset(dp,-1,sizeof(dp));\\n        pre_comput.resize(n);\\n        for(int i=0;i<n;i++){\\n            pre_comput[i].resize(n);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int mid=(i+j)>>1,temp=0;\\n                for(int k=i;k<=j;k++){\\n                    temp+=abs(houses[k]-houses[mid]);\\n                }\\n                pre_comput[i][j]=temp;\\n            }\\n        }\\n        ll answer=solve(houses,1,n,k,0);\\n        return answer;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    #define ll long long\\n    vector<vector<int>>pre_comput;\\n    int dp[101][101][101];\\n    \\n    \\n    // ll cost(vector<int>&houses,int prev,int index){\\n    //     vector<int>temp;\\n    //     for(int i=prev;i<index;i++){\\n    //         temp.push_back(houses[i]);\\n    //     }",
                "codeTag": "Java"
            },
            {
                "id": 2420213,
                "title": "python-dp-mcm-comments-google-oa-variation",
                "content": "This question got on my nerves. Somehow its related to question recently being asked in google OA and i thought to give it a try.       \\nIts a variation of the mcm dp pattern.\\nsome of the key observation you need to make here is that the you dont need to put the mailbox in between two houses(that is the point which is empty), rather you can get your answer by putting the mailboxes on some house.\\n\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        costToPutBoxHere = [[0 for _ in range(len(houses))] for _ in range(len(houses))]\\n        for i in range(len(houses)):\\n            for j in range(i,len(houses)):\\n                median = (house[(i+j)//2])\\n                for m in range(i,j+1):\\n                    costToPutBoxHere[i][j] += abs(median-houses[m])\\n        dp = [[-1 for _ in range(k+1)] for _ in range(len(houses)+1)]\\n        @cache\\n        def f(i,k):\\n            if k == 0 and i == len(houses):\\n                return 0\\n            if k == 0 or i == len(houses):\\n                return float(\"inf\")\\n            # if dp[i][k] != -1:\\n            #     return dp[i][k]\\n            ans = float(\"inf\")\\n            for c in range(i,len(houses)):\\n                ans = min(ans,costToPutBoxHere[i][c]+f(c+1,k-1))\\n            # dp[i][k] = ans\\n            return ans\\n        return f(0,k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        costToPutBoxHere = [[0 for _ in range(len(houses))] for _ in range(len(houses))]\\n        for i in range(len(houses)):\\n            for j in range(i,len(houses)):\\n                median = (house[(i+j)//2])\\n                for m in range(i,j+1):\\n                    costToPutBoxHere[i][j] += abs(median-houses[m])\\n        dp = [[-1 for _ in range(k+1)] for _ in range(len(houses)+1)]\\n        @cache\\n        def f(i,k):\\n            if k == 0 and i == len(houses):\\n                return 0\\n            if k == 0 or i == len(houses):\\n                return float(\"inf\")\\n            # if dp[i][k] != -1:\\n            #     return dp[i][k]\\n            ans = float(\"inf\")\\n            for c in range(i,len(houses)):\\n                ans = min(ans,costToPutBoxHere[i][c]+f(c+1,k-1))\\n            # dp[i][k] = ans\\n            return ans\\n        return f(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398022,
                "title": "python3-iterative",
                "content": "class Solution:\\n\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        dist = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i,n):\\n                mid = houses[(i+j)//2]\\n                for h in range(i,j+1):\\n                    dist[i][j]+=abs(mid-houses[h])\\n                    \\n        dp = [[float(\\'inf\\')]*k for _ in range(n)]\\n        for i in range(n):\\n            dp[i][0] = dist[0][i]\\n        \\n        for t in range(1,k):\\n            for i in range(n):\\n                for j in range(i):\\n                    dp[i][t] = min(dp[i][t],dist[j+1][i]+dp[j][t-1])\\n                    \\n        return dp[-1][-1]",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        dist = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i,n):\\n                mid = houses[(i+j)//2]\\n                for h in range(i,j+1):\\n                    dist[i][j]+=abs(mid-houses[h])\\n                    \\n        dp = [[float(\\'inf\\')]*k for _ in range(n)]\\n        for i in range(n):\\n            dp[i][0] = dist[0][i]\\n        \\n        for t in range(1,k):\\n            for i in range(n):\\n                for j in range(i):\\n                    dp[i][t] = min(dp[i][t],dist[j+1][i]+dp[j][t-1])\\n                    \\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 2397606,
                "title": "python3-recursion",
                "content": "class Solution:\\n\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        dist = [[0]*n for _ in range(n)]\\n        MAX = float(\"inf\")\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mid = houses[(i+j)//2]\\n                for h in range(i,j+1):\\n                    dist[i][j]+=abs(mid-houses[h])\\n              \\n        @lru_cache(None)\\n        def Helper(i,k):\\n            if i==n and k==0:\\n                return 0\\n            if i==n or k==0:\\n                return MAX\\n            res = MAX\\n            for j in range(i,n):\\n                res = min(res,dist[i][j]+Helper(j+1,k-1))\\n            return res\\n        \\n        return Helper(0,k)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        dist = [[0]*n for _ in range(n)]\\n        MAX = float(\"inf\")\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mid = houses[(i+j)//2]\\n                for h in range(i,j+1):\\n                    dist[i][j]+=abs(mid-houses[h])\\n              \\n        @lru_cache(None)\\n        def Helper(i,k):\\n            if i==n and k==0:\\n                return 0\\n            if i==n or k==0:\\n                return MAX\\n            res = MAX\\n            for j in range(i,n):\\n                res = min(res,dist[i][j]+Helper(j+1,k-1))\\n            return res\\n        \\n        return Helper(0,k)",
                "codeTag": "Java"
            },
            {
                "id": 2368366,
                "title": "c-memeoization",
                "content": "```\\nint t[101][101] ;\\n    int cost(vector<int>&houses , int k , int pos , int n){\\n        if(pos >= n && k == 0){\\n            return 0 ;\\n        }\\n        if(k == 0 || (pos >= n && k >0)){\\n            return 1e7 ;\\n        }\\n        if(t[pos][k] != -1){\\n            return t[pos][k]; \\n        }\\n        int ans = INT_MAX ;\\n        for(int i = pos; i<n ; i++){\\n            int med = (i+pos)/2 ;\\n            int val = 0 ;\\n            for(int j = pos ; j<=i ; j++){\\n                val += abs(houses[j] - houses[med]) ;\\n            }\\n            ans = min(ans , val + cost(houses , k-1 , i+1 , n)) ;\\n        }\\n        return t[pos][k] = ans ;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin() , houses.end()) ;\\n        int n = houses.size() ;\\n        memset(t ,-1 , sizeof(t)) ;\\n        return cost(houses  , k , 0 , n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint t[101][101] ;\\n    int cost(vector<int>&houses , int k , int pos , int n){\\n        if(pos >= n && k == 0){\\n            return 0 ;\\n        }\\n        if(k == 0 || (pos >= n && k >0)){\\n            return 1e7 ;\\n        }\\n        if(t[pos][k] != -1){\\n            return t[pos][k]; \\n        }\\n        int ans = INT_MAX ;\\n        for(int i = pos; i<n ; i++){\\n            int med = (i+pos)/2 ;\\n            int val = 0 ;\\n            for(int j = pos ; j<=i ; j++){\\n                val += abs(houses[j] - houses[med]) ;\\n            }\\n            ans = min(ans , val + cost(houses , k-1 , i+1 , n)) ;\\n        }\\n        return t[pos][k] = ans ;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin() , houses.end()) ;\\n        int n = houses.size() ;\\n        memset(t ,-1 , sizeof(t)) ;\\n        return cost(houses  , k , 0 , n);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362162,
                "title": "python-solution-lee215-s-prefix-sum-solution-with-more-detailed-examples",
                "content": "This is like a textbook example of DP, although calculating the cost quickly is rather tricky.\\n```\\nclass Solution:\\n    # First we sort houses\\n    # This problem is inherently a DP problem.\\n    # dp[i][k] = minimum total distance between each house and its nearest mailbox, if the rightmost house has index i and k mailbox is allocated\\n    # Given n houses and k, we can choose houses[i:n] to be a group we give a mailbox to the range.\\n    # Then dp[n][k] = dp[i-1][k-1] + cost(i,n)\\n    # cost(i,n) = the cost if we have one mailbox for houses in the range between i and n-1\\n    # We wish to calculate this quantity quickly\\n    # From the picture we should notice that if the mailbox is inserted between 2 houses i and i + 1, the cost is equal to houses[i+1] - houses[i]\\n    # If a mainbox is inserted between 4 houses, the cost is equal to \\n    # house[i+3] - house[i+1] + house[i+2] - house[i+1] + house[i+1] - house[i]\\n    # = house[i+3] + house[i+2] - house[i+1] - house[i]\\n    # = (prefix[i+4] - prefix[i+2]) - (prefix[i+2] - prefix[i])\\n    # How about 5 houses? It will be\\n    # house[i+4] - house[i+2] + house[i+3] - house[i+2] + house[i+2] - house[i+1] + house[i+2] - house[i]\\n    # = house[i+4] + house[i+3] - house[i+1] - house[i]\\n    # = (prefix[i+5] - prefix[i+3]) - (prefix[i+2] - prefix[i])\\n    # To get cost(i, j), let\\'s define m1 = (i+j)//2, m2 = (i+j+1)// 2\\n    # quick check: if j = i + 4, m1 = i + 2, m2 = i + 2\\n    # quick check: if j = i + 5, m1 = i + 2, m2 = i + 3\\n    # So cost(i,j) = prefix[j] + prefix[i] - prefix[m1] - prefix[m2]\\n    # Base cases:\\n    # dp[i][0] = cost(0, i+1)\\n    # For k > 0:\\n    # dp[j][k] = min(dp[j][k], dp[i-1][k-1] + cost(i,j+1))\\n    # When we use the formula, We calculate j from 0 to n-1, and loop i from j to 1\\n\\n    def cost(self, i, j):\\n        m1, m2 = (i+j) // 2, (i+j+1) // 2\\n        return self.prefix[j] + self.prefix[i] - self.prefix[m1] - self.prefix[m2] \\n    \\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        self.prefix = [0]\\n        for house in houses:\\n            self.prefix.append(self.prefix[-1] + house)\\n        dp = [[float(\\'inf\\') for l in range(k)] for i in range(n)]\\n        for l in range(k):\\n            if l == 0:\\n                for i in range(n):\\n                    dp[i][l] = self.cost(0, i+1)\\n            else:\\n                for j in range(n):\\n                    for i in range(j, 0, -1):\\n                        dp[j][l] = min(dp[j][l], dp[i-1][l-1] + self.cost(i,j+1))\\n        return dp[n-1][k-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # First we sort houses\\n    # This problem is inherently a DP problem.\\n    # dp[i][k] = minimum total distance between each house and its nearest mailbox, if the rightmost house has index i and k mailbox is allocated\\n    # Given n houses and k, we can choose houses[i:n] to be a group we give a mailbox to the range.\\n    # Then dp[n][k] = dp[i-1][k-1] + cost(i,n)\\n    # cost(i,n) = the cost if we have one mailbox for houses in the range between i and n-1\\n    # We wish to calculate this quantity quickly\\n    # From the picture we should notice that if the mailbox is inserted between 2 houses i and i + 1, the cost is equal to houses[i+1] - houses[i]\\n    # If a mainbox is inserted between 4 houses, the cost is equal to \\n    # house[i+3] - house[i+1] + house[i+2] - house[i+1] + house[i+1] - house[i]\\n    # = house[i+3] + house[i+2] - house[i+1] - house[i]\\n    # = (prefix[i+4] - prefix[i+2]) - (prefix[i+2] - prefix[i])\\n    # How about 5 houses? It will be\\n    # house[i+4] - house[i+2] + house[i+3] - house[i+2] + house[i+2] - house[i+1] + house[i+2] - house[i]\\n    # = house[i+4] + house[i+3] - house[i+1] - house[i]\\n    # = (prefix[i+5] - prefix[i+3]) - (prefix[i+2] - prefix[i])\\n    # To get cost(i, j), let\\'s define m1 = (i+j)//2, m2 = (i+j+1)// 2\\n    # quick check: if j = i + 4, m1 = i + 2, m2 = i + 2\\n    # quick check: if j = i + 5, m1 = i + 2, m2 = i + 3\\n    # So cost(i,j) = prefix[j] + prefix[i] - prefix[m1] - prefix[m2]\\n    # Base cases:\\n    # dp[i][0] = cost(0, i+1)\\n    # For k > 0:\\n    # dp[j][k] = min(dp[j][k], dp[i-1][k-1] + cost(i,j+1))\\n    # When we use the formula, We calculate j from 0 to n-1, and loop i from j to 1\\n\\n    def cost(self, i, j):\\n        m1, m2 = (i+j) // 2, (i+j+1) // 2\\n        return self.prefix[j] + self.prefix[i] - self.prefix[m1] - self.prefix[m2] \\n    \\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        self.prefix = [0]\\n        for house in houses:\\n            self.prefix.append(self.prefix[-1] + house)\\n        dp = [[float(\\'inf\\') for l in range(k)] for i in range(n)]\\n        for l in range(k):\\n            if l == 0:\\n                for i in range(n):\\n                    dp[i][l] = self.cost(0, i+1)\\n            else:\\n                for j in range(n):\\n                    for i in range(j, 0, -1):\\n                        dp[j][l] = min(dp[j][l], dp[i-1][l-1] + self.cost(i,j+1))\\n        return dp[n-1][k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322039,
                "title": "clean-dp-memoization-o-n-3-k-to-o-n-2-k",
                "content": "```\\nclass Solution {\\n    vector<int> v;\\n    int len;\\n    int dp[101][101];\\n    int cost[101][101];\\n    // int cost(int s, int e){\\n    //     int c=0;\\n    //     while(s<e){\\n    //         c+=(v[e]-v[s]);\\n    //         s++;e--;\\n    //     }\\n    //     return c;\\n    // }\\n    void createCost(){\\n        for(int l=1;l<=len;l++){\\n            for(int start=0,end=start+l-1;end<len;start++,end++){\\n                if(l==1)\\n                    cost[start][end]=0;\\n                else if(l==2)\\n                    cost[start][end]=v[end]-v[start];\\n                else\\n                    cost[start][end]=(v[end]-v[start])+cost[start+1][end-1];\\n            }\\n        }\\n    }\\n    int dfs(int idx, int k){//n*k\\n        if(idx>=len)\\n            return 0;\\n        if(k==1)\\n            // return cost(idx,len-1);\\n            return cost[idx][len-1];\\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        int res=INT_MAX;\\n        for(int i=idx;i<len;i++){//n\\n            // res=min(cost(idx,i)+dfs(i+1,k-1),res);//n\\n            res=min(cost[idx][i]+dfs(i+1,k-1),res);//1\\n        }\\n        return dp[idx][k]=res;\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(),houses.end());\\n        v=houses;\\n        len=v.size();\\n        memset(dp,-1,sizeof(dp));\\n        createCost();\\n        return dfs(0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> v;\\n    int len;\\n    int dp[101][101];\\n    int cost[101][101];\\n    // int cost(int s, int e){\\n    //     int c=0;\\n    //     while(s<e){\\n    //         c+=(v[e]-v[s]);\\n    //         s++;e--;\\n    //     }\\n    //     return c;\\n    // }\\n    void createCost(){\\n        for(int l=1;l<=len;l++){\\n            for(int start=0,end=start+l-1;end<len;start++,end++){\\n                if(l==1)\\n                    cost[start][end]=0;\\n                else if(l==2)\\n                    cost[start][end]=v[end]-v[start];\\n                else\\n                    cost[start][end]=(v[end]-v[start])+cost[start+1][end-1];\\n            }\\n        }\\n    }\\n    int dfs(int idx, int k){//n*k\\n        if(idx>=len)\\n            return 0;\\n        if(k==1)\\n            // return cost(idx,len-1);\\n            return cost[idx][len-1];\\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        int res=INT_MAX;\\n        for(int i=idx;i<len;i++){//n\\n            // res=min(cost(idx,i)+dfs(i+1,k-1),res);//n\\n            res=min(cost[idx][i]+dfs(i+1,k-1),res);//1\\n        }\\n        return dp[idx][k]=res;\\n    }\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(),houses.end());\\n        v=houses;\\n        len=v.size();\\n        memset(dp,-1,sizeof(dp));\\n        createCost();\\n        return dfs(0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206218,
                "title": "top-down-dp-heavily-commented-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int MinDistance(int[] houses, int k) {\\n        \\n        Array.Sort(houses);\\n        \\n        Dictionary<(int, int, int), int> memo = new();\\n        \\n        return minAllocation(k, 0, houses.Length - 1);\\n        \\n        int minAllocation(int boxes, int left, int right)\\n        {\\n            int freeSpots = right - left + 1;\\n            \\n            if (boxes == freeSpots) return 0;\\n            \\n\\t\\t\\t// skipping that distribution - it\\'s obviously isn\\'t going to be optimal\\n            if (boxes > freeSpots) return int.MaxValue;\\n            \\n            if (memo.TryGetValue((boxes, left, right), out int minDistance)) return minDistance;\\n            \\n            if (boxes == 1)\\n            {\\n                minDistance = 0;\\n                \\n                // for 1 box and n houses the median house is the optimal spot for the box\\n                int medianHouse = left + (right - left) / 2;\\n                \\n                for (int i = left; i <= right; i++) minDistance += Math.Abs(houses[i] - houses[medianHouse]);\\n            }\\n            else\\n            {\\n                minDistance = int.MaxValue;\\n                \\n                // we\\'re going to be trying all the possible splits of\\n                // the current range into 2 sub-ranges: allocate 1 box on the left\\n                // and the remaining boxes - 1 amount on the right\\n                // that way we are goint to try all the possible allocations\\n                // across the whole house line.\\n                for (int cutLine = left; cutLine < right; cutLine++)\\n                {                \\n                    // placing 1 box on the \\'left side\\'\\n                    int leftDistances = minAllocation(1, left, cutLine);\\n                    // and the rest are trying to allocate on the right\\n                    int rightDistances = minAllocation(boxes - 1, cutLine + 1, right);\\n\\n                    if (leftDistances == int.MaxValue || rightDistances == int.MaxValue) continue;\\n\\n                    minDistance = Math.Min(minDistance, leftDistances + rightDistances);\\n                }\\n            }\\n            \\n            memo.Add((boxes, left, right), minDistance);\\n            \\n            return minDistance;\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDistance(int[] houses, int k) {\\n        \\n        Array.Sort(houses);\\n        \\n        Dictionary<(int, int, int), int> memo = new();\\n        \\n        return minAllocation(k, 0, houses.Length - 1);\\n        \\n        int minAllocation(int boxes, int left, int right)\\n        {\\n            int freeSpots = right - left + 1;\\n            \\n            if (boxes == freeSpots) return 0;\\n            \\n\\t\\t\\t// skipping that distribution - it\\'s obviously isn\\'t going to be optimal\\n            if (boxes > freeSpots) return int.MaxValue;\\n            \\n            if (memo.TryGetValue((boxes, left, right), out int minDistance)) return minDistance;\\n            \\n            if (boxes == 1)\\n            {\\n                minDistance = 0;\\n                \\n                // for 1 box and n houses the median house is the optimal spot for the box\\n                int medianHouse = left + (right - left) / 2;\\n                \\n                for (int i = left; i <= right; i++) minDistance += Math.Abs(houses[i] - houses[medianHouse]);\\n            }\\n            else\\n            {\\n                minDistance = int.MaxValue;\\n                \\n                // we\\'re going to be trying all the possible splits of\\n                // the current range into 2 sub-ranges: allocate 1 box on the left\\n                // and the remaining boxes - 1 amount on the right\\n                // that way we are goint to try all the possible allocations\\n                // across the whole house line.\\n                for (int cutLine = left; cutLine < right; cutLine++)\\n                {                \\n                    // placing 1 box on the \\'left side\\'\\n                    int leftDistances = minAllocation(1, left, cutLine);\\n                    // and the rest are trying to allocate on the right\\n                    int rightDistances = minAllocation(boxes - 1, cutLine + 1, right);\\n\\n                    if (leftDistances == int.MaxValue || rightDistances == int.MaxValue) continue;\\n\\n                    minDistance = Math.Min(minDistance, leftDistances + rightDistances);\\n                }\\n            }\\n            \\n            memo.Add((boxes, left, right), minDistance);\\n            \\n            return minDistance;\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139462,
                "title": "runtime-97-ms-faster-than-100-00-of-c-online-submissions",
                "content": "public class Solution {\\n        \\n    public int MinDistance(int[] houses, int k) {\\n        Array.Sort(houses);\\n        int len = houses.Length;\\n        int[,] dist = new int[len,len];\\n        int[,] dp = new int[len,k+1];\\n        \\n        for(int i=0;i<len;i++){\\n            for(int j=i;j<len;j++){\\n                for(int x=i;x<=j;x++){\\n                    dist[i,j]+=Math.Abs(houses[(i+j)/2]-houses[x]);\\n                    \\n                }\\n            }\\n        }\\n        \\n         \\n        \\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<=k;j++){\\n                dp[i,j]=-1;\\n            }\\n        }\\n        \\n       \\n       \\n        return PlaceBox(houses,0,k,dist,dp);\\n        \\n    }\\n    \\n   private int PlaceBox(int[] houses,int start,int k, int[,] dist, int[,] dp){\\n     \\n       if(k==1 && start<houses.Length)\\n           return dist[start,houses.Length-1];\\n       if(start==houses.Length && k==0)\\n           return 0;\\n       if(k==0 || start==houses.Length)\\n           return 100000;\\n       if(dp[start,k]!=-1)\\n           return dp[start,k];\\n       int localMin = 100000;\\n       for(int i=start;i<houses.Length;i++){\\n           \\n           int rest = PlaceBox(houses,i+1,k-1,dist,dp);\\n          \\n           if(rest!=100000){\\n               localMin=Math.Min(localMin,dist[start,i]+rest);\\n           }\\n            \\n       }\\n       dp[start,k]=localMin;\\n       return dp[start,k];\\n   } \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n    public int MinDistance(int[] houses, int k) {\\n        Array.Sort(houses);\\n        int len = houses.Length;\\n        int[,] dist = new int[len,len];\\n        int[,] dp = new int[len,k+1];\\n        \\n        for(int i=0;i<len;i++){\\n            for(int j=i;j<len;j++){\\n                for(int x=i;x<=j;x++){\\n                    dist[i,j]+=Math.Abs(houses[(i+j)/2]-houses[x]);\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2132655,
                "title": "swift-memorization",
                "content": "\\n```\\nclass Solution {\\n    func minDistance(_ houses: [Int], _ k: Int) -> Int {\\n        guard !houses.isEmpty, k > 0 else {\\n            return 0\\n        }\\n        \\n        let houses = houses.sorted()\\n\\n        // 1 <= k <= houses.length <= 100\\n        let n = houses.count\\n        var costs: [[Int]] = Array(repeating: Array(repeating: 0, count: 100), count: 100)\\n        // costs[i][j] denotes the cost when one mailbox is assigned beween houses[i] to houses[j]\\n        // it should be the\\n        for i in 0..<n {\\n            for j in i..<n {\\n                let medianPos = houses[(i + j) / 2]\\n                for m in i...j {\\n                    costs[i][j] += abs(medianPos - houses[m])\\n                }\\n            }\\n        }\\n\\n        var memo: [[Int]] = Array(repeating: Array(repeating: -1, count: 100), count: 100)\\n        return exploreMinDistance(houses, house: 0, k: k, costs: costs, memo: &memo)\\n    }\\n\\n    func exploreMinDistance(_ houses: [Int], house: Int, k: Int, costs: [[Int]], memo: inout [[Int]]) -> Int {\\n        guard k > 0, house < houses.count else {\\n            // Int.max denotes invalid result\\n            return (k == 0 && house >= houses.count) ? 0 : Int.max\\n        }\\n        if memo[k][house] == -1 {\\n            var ans = Int.max\\n            for i in house..<houses.count {\\n                let remainDistance = exploreMinDistance(houses, house: i + 1, k: k - 1, costs: costs, memo: &memo)\\n                if remainDistance != Int.max {\\n                    ans = min(ans, costs[house][i] + remainDistance)\\n                }\\n            }\\n            memo[k][house] = ans\\n        }\\n        return memo[k][house]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minDistance(_ houses: [Int], _ k: Int) -> Int {\\n        guard !houses.isEmpty, k > 0 else {\\n            return 0\\n        }\\n        \\n        let houses = houses.sorted()\\n\\n        // 1 <= k <= houses.length <= 100\\n        let n = houses.count\\n        var costs: [[Int]] = Array(repeating: Array(repeating: 0, count: 100), count: 100)\\n        // costs[i][j] denotes the cost when one mailbox is assigned beween houses[i] to houses[j]\\n        // it should be the\\n        for i in 0..<n {\\n            for j in i..<n {\\n                let medianPos = houses[(i + j) / 2]\\n                for m in i...j {\\n                    costs[i][j] += abs(medianPos - houses[m])\\n                }\\n            }\\n        }\\n\\n        var memo: [[Int]] = Array(repeating: Array(repeating: -1, count: 100), count: 100)\\n        return exploreMinDistance(houses, house: 0, k: k, costs: costs, memo: &memo)\\n    }\\n\\n    func exploreMinDistance(_ houses: [Int], house: Int, k: Int, costs: [[Int]], memo: inout [[Int]]) -> Int {\\n        guard k > 0, house < houses.count else {\\n            // Int.max denotes invalid result\\n            return (k == 0 && house >= houses.count) ? 0 : Int.max\\n        }\\n        if memo[k][house] == -1 {\\n            var ans = Int.max\\n            for i in house..<houses.count {\\n                let remainDistance = exploreMinDistance(houses, house: i + 1, k: k - 1, costs: costs, memo: &memo)\\n                if remainDistance != Int.max {\\n                    ans = min(ans, costs[house][i] + remainDistance)\\n                }\\n            }\\n            memo[k][house] = ans\\n        }\\n        return memo[k][house]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077936,
                "title": "python3-dp-o-kn-2-time-o-max-kn-n-2-space",
                "content": "1) Sort the houses.  This way we only need to consider adjacent houses for groups.  time and space here will be dominated by later computations.\\n\\n\\n2) If there is a mailbox for every house, then the total cost is 0.\\n\\n\\n3) Compute the cost function for every subsubset of adjacent houses if there is only one mailbox for this set.  cost[i,j] is total cost of houses from index i through j inclusive if there is only one mailbox for this group.  We proceed inductively, if there is only one house the cost is 0.  if there are two houses the cost is the distance between them (assuming we put the mail box anywhere between them).  If we know the cost of a group and we add two houses, one on each side then the total cost is the diameter of the group plus the cost of the inner group we already knew.  Since this resoning requires steps of size two we get two base cases and consider even sized groups separately from odd sized groups.  The computation requires O(n^2) time and the cost object requires O(n^2) space.\\n\\n\\n4) Now dp on the first i houses and mail boxes.  dp[i,k] is the total cost of the first i+1 houses if there are k mailboxes allotted to that group.  To compute dp[i,k] we break off the last group of houses and that groups one mail box and add it to the cost of the frist i+1 houses with the other k-1 mail boxes.  Since we want to minimize the cost we take the minimum over all such splits.  The dp for loops cost k and n, and the min also costs n for a total of O(kn^2) time and dp requires O(kn) space.\\n\\n\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        len_houses = len(houses)\\n        if k == len_houses:\\n            return 0\\n        cost = {**{(i,i): 0 for i in range(len_houses)},\\n                **{(i,i+1):houses[i+1] - houses[i]  for i in range(len_houses - 1)}}\\n        for i in range(len_houses):\\n            for r in range(1,min(i+1,len_houses-i)):\\n                cost[i-r,i+r] = cost[i-r+1,i+r-1] + houses[i+r] - houses[i-r]\\n                if i+r + 1 < len_houses:\\n                    cost[i-r,i+r+1] = cost[i-r+1,i+r] + houses[i+r+1] - houses[i-r]\\n        dp = {(j,1):cost[0,j] for j in range(len_houses)} # dp(i,k) is total cost of using k mail boxes for first i houses\\n        for box in range(2, k + 1):\\n            for j in range(box - 1, len_houses):\\n                dp[j,box] = min(dp[i,box-1] + cost[i+1,j] for i in range(box - 2, j))\\n        return dp[len_houses - 1, k]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        len_houses = len(houses)\\n        if k == len_houses:\\n            return 0\\n        cost = {**{(i,i): 0 for i in range(len_houses)},\\n                **{(i,i+1):houses[i+1] - houses[i]  for i in range(len_houses - 1)}}\\n        for i in range(len_houses):\\n            for r in range(1,min(i+1,len_houses-i)):\\n                cost[i-r,i+r] = cost[i-r+1,i+r-1] + houses[i+r] - houses[i-r]\\n                if i+r + 1 < len_houses:\\n                    cost[i-r,i+r+1] = cost[i-r+1,i+r] + houses[i+r+1] - houses[i-r]\\n        dp = {(j,1):cost[0,j] for j in range(len_houses)} # dp(i,k) is total cost of using k mail boxes for first i houses\\n        for box in range(2, k + 1):\\n            for j in range(box - 1, len_houses):\\n                dp[j,box] = min(dp[i,box-1] + cost[i+1,j] for i in range(box - 2, j))\\n        return dp[len_houses - 1, k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007214,
                "title": "java-dp-with-explanation-o-n-3",
                "content": "First thing first, we will sort the houses array so that they all fall on a straight line.\\nTime complexity: O(n log n)\\nSpace complexity: constant space\\n\\nThis problem is to group n houses into k groups, in the sense that the houses in each of the groups are close enough to each other so that the total walking distance is minimal.\\n\\nWe could reduce the problem from k to k-1 using the following approach\\n1. divide the n houses into 2 clusters, namely left and right\\n2. allocate k - 1 mailboxes to the left group, and allocate 1 mailbox to the right group\\n3. try all the combinations so that the sum of walking distance is minimum\\n4. as one important aspect of dynamic programming, we will store the result into a 2D array to avoid making the same calculation again\\n\\ndp(n, k) = minimum value of dp(i, k-1) + distance(i, n - 1) for i from k-1* to n-1\\n**notes: i starts from k-1, as the left group should not get more mailboxes than the number of houses , otherwise some mailboxes will be wasted and the total walking distance will not be minimal*\\n\\nTime complexity: O(n^3)\\nThe complexity for the distance function is O(n^3), because at most we calculated (1 + n) x n / 2 times (triangular number), and at most adding up the distance of n houses for each calculation\\nThe complexity for the dp function is O(n^2 x k), because at most we calculated (1 + n-k) x k /2 times, and at most compared n-k costs for each iterations\\n\\nSpace complexity: O(n x k + n^2) \\nThe size of the 2 tables storing the calculated results\\n![image](https://assets.leetcode.com/users/images/cf52d645-f0b5-45b1-b4ac-ea80ba43594e_1651655944.660787.png)\\n\\nThere are obvious cases that we could directly jump to an answer without going through the above approach, which are\\n1. n is smaller than or equals to k, each of the houses receives a mailbox so the walking distance is 0\\n2. k equals to 1, we have only one mailbox therefore we will just put the mailbox in the median house\\n\\nTime complexity: case 1 constant time / case 2 O(n)\\nSpace complexity: constant space\\n\\n```\\nclass Solution {\\n    private int[][] dptable;\\n    private int[][] disttable;\\n\\n    private int dist(int[] houses, int i, int j) {\\n        if (i == j) return 0;\\n        if (disttable != null && disttable[i][j] != 0) return disttable[i][j];\\n        int mb = houses[(i + j) / 2], ret = 0;\\n        for (int k = i; k <= j; k++) {\\n            ret += Math.abs(houses[k] - mb);\\n        }\\n        if (disttable == null) return ret;\\n        return disttable[i][j] = ret;\\n    }\\n    \\n    private int dp(int[] houses, int n, int k) {\\n        if (n <= k) return 0;\\n        else if (k == 1) return dist(houses, 0, n - 1);\\n        else if (dptable[n][k] != 0) return dptable[n][k];\\n        \\n        int cost = dist(houses, k - 1, n - 1); // dp(k-1, k-1) = 0 so its omitted in this line\\n        for (int i = k; i <= n - 1; i++) cost = Math.min(cost, dp(houses, i, k - 1) + dist(houses, i, n-1));\\n        return dptable[n][k] = cost;\\n    }\\n\\n    public int minDistance(int[] houses, int k) {\\n        int len = houses.length;\\n        if (len == k) return 0;        \\n        Arrays.sort(houses); \\n        if (k == 1) return dist(houses, 0, len - 1);\\n        \\n        dptable = new int[len + 1][k + 1];\\n        disttable = new int[len][len];\\n        return dp(houses, len, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] dptable;\\n    private int[][] disttable;\\n\\n    private int dist(int[] houses, int i, int j) {\\n        if (i == j) return 0;\\n        if (disttable != null && disttable[i][j] != 0) return disttable[i][j];\\n        int mb = houses[(i + j) / 2], ret = 0;\\n        for (int k = i; k <= j; k++) {\\n            ret += Math.abs(houses[k] - mb);\\n        }\\n        if (disttable == null) return ret;\\n        return disttable[i][j] = ret;\\n    }\\n    \\n    private int dp(int[] houses, int n, int k) {\\n        if (n <= k) return 0;\\n        else if (k == 1) return dist(houses, 0, n - 1);\\n        else if (dptable[n][k] != 0) return dptable[n][k];\\n        \\n        int cost = dist(houses, k - 1, n - 1); // dp(k-1, k-1) = 0 so its omitted in this line\\n        for (int i = k; i <= n - 1; i++) cost = Math.min(cost, dp(houses, i, k - 1) + dist(houses, i, n-1));\\n        return dptable[n][k] = cost;\\n    }\\n\\n    public int minDistance(int[] houses, int k) {\\n        int len = houses.length;\\n        if (len == k) return 0;        \\n        Arrays.sort(houses); \\n        if (k == 1) return dist(houses, 0, len - 1);\\n        \\n        dptable = new int[len + 1][k + 1];\\n        disttable = new int[len][len];\\n        return dp(houses, len, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983951,
                "title": "python-dfs-with-meomization-o-k-n-2-explained",
                "content": "First, sort the houses in increasing order\\ncost(i,j): min cost after installing one facility for houses from i to j\\ndfs(i,k): min cost for houses from i to the last by using k facilities\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        @lru_cache(None)\\n        def cost(i,j):\\n            cost = 0\\n            while i < j:\\n                cost += houses[j]-houses[i]\\n                i += 1\\n                j -= 1\\n            return cost\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if i == n:\\n                return 0\\n            if k == 0:\\n                return float(\\'inf\\')\\n            res = float(\\'inf\\')\\n            for j in range(i,n):\\n                res = min(res,cost(i,j)+dfs(j+1,k-1))\\n            return res\\n        return dfs(0,k)\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "First, sort the houses in increasing order\\ncost(i,j): min cost after installing one facility for houses from i to j\\ndfs(i,k): min cost for houses from i to the last by using k facilities\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        @lru_cache(None)\\n        def cost(i,j):\\n            cost = 0\\n            while i < j:\\n                cost += houses[j]-houses[i]\\n                i += 1\\n                j -= 1\\n            return cost\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if i == n:\\n                return 0\\n            if k == 0:\\n                return float(\\'inf\\')\\n            res = float(\\'inf\\')\\n            for j in range(i,n):\\n                res = min(res,cost(i,j)+dfs(j+1,k-1))\\n            return res\\n        return dfs(0,k)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1982261,
                "title": "c-memorization",
                "content": "\\n\\nclass Solution {\\npublic:\\n    \\n    int median(int start, int end, vector<int> arr){\\n        if((end-start)%2 == 0)\\n        {\\n            int num = arr[start + (end-start)/2];\\n            int sum = 0;\\n            for(int i=start; i<end; i++){\\n            sum += abs(arr[i]-num);\\n        }\\n            return sum;\\n        }else{\\n            int num = arr[start + (end-start-1)/2];\\n            int sum = 0;\\n            for(int i=start; i<end; i++){\\n            sum += abs(arr[i]-num);\\n        }\\n            return sum;\\n        }\\n    }\\n    long dp[101][101][101];\\n    long getAns(int start, int end, int k, vector<int> &arr){\\n        if(k == 0 && start == end)\\n        {\\n            return 0;\\n        }\\n        if(k == 0 || start == end)\\n        {\\n            return INT_MAX;\\n        }\\n        if(dp[start][end][k] != -1)\\n            return dp[start][end][k];\\n        long ans = INT_MAX;\\n        for(int i=start; i<end; i++){\\n            ans = min(ans,median(start,i+1,arr)+getAns(i+1,end,k-1,arr));\\n        }\\n        return dp[start][end][k] = ans;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        sort(houses.begin(),houses.end());\\n        memset(dp,-1,sizeof(dp));\\n        return getAns(0,houses.size(),k,houses);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int median(int start, int end, vector<int> arr){\\n        if((end-start)%2 == 0)\\n        {\\n            int num = arr[start + (end-start)/2];\\n            int sum = 0;\\n            for(int i=start; i<end; i++){\\n            sum += abs(arr[i]-num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1901842,
                "title": "python-dp-o-n-n-k",
                "content": "Use a dis[i][j] matrix to store the distance if the mailbox is place at the center of house group i to j. Then use dp to update the minimum distance overall. \\n\\n```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        n = len(houses)\\n        houses.sort()\\n        \\n        if n<=k:\\n            return 0\\n        \\n        dis,dp = [[0]*n for i in range(n)],[[inf]*n for i in range(k)]\\n        for di in range(n):\\n            for i in range(n):\\n                if di==0:\\n                    dis[i][i] = 0\\n                    continue\\n                j = i+di\\n                if j<n:\\n                    dis[i][j] = dis[i][j-1] + houses[j] - houses[i+di//2]\\n        \\n        \\n        for i in range(k):\\n            for j in range(n):\\n                if i==0:\\n                    dp[i][j] = dis[0][j]\\n                    continue\\n                for prevj in range(j):\\n                    dp[i][j] = min(dp[i][j],dp[i-1][prevj]+dis[prevj+1][j])\\n        return dp[k-1][n-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        n = len(houses)\\n        houses.sort()\\n        \\n        if n<=k:\\n            return 0\\n        \\n        dis,dp = [[0]*n for i in range(n)],[[inf]*n for i in range(k)]\\n        for di in range(n):\\n            for i in range(n):\\n                if di==0:\\n                    dis[i][i] = 0\\n                    continue\\n                j = i+di\\n                if j<n:\\n                    dis[i][j] = dis[i][j-1] + houses[j] - houses[i+di//2]\\n        \\n        \\n        for i in range(k):\\n            for j in range(n):\\n                if i==0:\\n                    dp[i][j] = dis[0][j]\\n                    continue\\n                for prevj in range(j):\\n                    dp[i][j] = min(dp[i][j],dp[i-1][prevj]+dis[prevj+1][j])\\n        return dp[k-1][n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1887518,
                "title": "c-memoization",
                "content": "If **k = 1**, then the optimal solution is to place mailbox at the median of array if all elements are sorted. This will actual help a lot, now the problem reduces to just dividing the array into `k` parts and find its median and calulates distance and add it to the result. But how to find the distance of all indicies to median optimally? this can be also done by dp, below is the implementation.\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int dfs(vector<vector<int>> &left,vector<vector<int>> &right,vector<vector<int>> &dp,int k,int in){\\n        if(in>=n){\\n            if(k==0) return 0;\\n            else return INT_MAX;\\n        }\\n        if(k==1){\\n            int t = (in+n-1)/2;\\n            return dp[in][k] = left[in][t]+right[t][n-1];\\n        }\\n        if(dp[in][k]!=-1) return dp[in][k];\\n        int re = INT_MAX;\\n        for(int i = in; i<=n-k;++i){ // try partitioning at every index from index in to possible end\\n            int t = (in+i)/2; // median of range [in,i]\\n            int p = dfs(left,right,dp,k-1,i+1);\\n            if(p!=INT_MIN) p+=left[in][t]+right[t][i]; // distances of this ranges is equal to the left sum and right sum from in to t and t to i respectively\\n            re = min(re,p);\\n        }\\n        return dp[in][k] = re;\\n    }\\n    int minDistance(vector<int>& nums, int k) {\\n        if(k==nums.size()) return 0;\\n        sort(nums.begin(),nums.end()); n = nums.size();\\n        vector<vector<int>> left(n,vector<int>(n,0)); // stores the sum of distances from every index in range [i,j] to median treating jth element as median \\n        vector<vector<int>> right(n,vector<int>(n,0)); // stores the sum of distances from every index in range [i,j] to median treating ith element as median \\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        for(int gap=1;gap<nums.size();++gap){\\n            for(int i = 0,j=gap;j<nums.size();++i,++j){\\n                left[i][j] = left[i][j-1]+(j-i)*(nums[j]-nums[j-1]);\\n                right[i][j] = right[i+1][j] + (j-i)*(nums[i+1]-nums[i]);\\n            }\\n        }\\n        return dfs(left,right,dp, k, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dfs(vector<vector<int>> &left,vector<vector<int>> &right,vector<vector<int>> &dp,int k,int in){\\n        if(in>=n){\\n            if(k==0) return 0;\\n            else return INT_MAX;\\n        }\\n        if(k==1){\\n            int t = (in+n-1)/2;\\n            return dp[in][k] = left[in][t]+right[t][n-1];\\n        }\\n        if(dp[in][k]!=-1) return dp[in][k];\\n        int re = INT_MAX;\\n        for(int i = in; i<=n-k;++i){ // try partitioning at every index from index in to possible end\\n            int t = (in+i)/2; // median of range [in,i]\\n            int p = dfs(left,right,dp,k-1,i+1);\\n            if(p!=INT_MIN) p+=left[in][t]+right[t][i]; // distances of this ranges is equal to the left sum and right sum from in to t and t to i respectively\\n            re = min(re,p);\\n        }\\n        return dp[in][k] = re;\\n    }\\n    int minDistance(vector<int>& nums, int k) {\\n        if(k==nums.size()) return 0;\\n        sort(nums.begin(),nums.end()); n = nums.size();\\n        vector<vector<int>> left(n,vector<int>(n,0)); // stores the sum of distances from every index in range [i,j] to median treating jth element as median \\n        vector<vector<int>> right(n,vector<int>(n,0)); // stores the sum of distances from every index in range [i,j] to median treating ith element as median \\n        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));\\n        for(int gap=1;gap<nums.size();++gap){\\n            for(int i = 0,j=gap;j<nums.size();++i,++j){\\n                left[i][j] = left[i][j-1]+(j-i)*(nums[j]-nums[j-1]);\\n                right[i][j] = right[i+1][j] + (j-i)*(nums[i+1]-nums[i]);\\n            }\\n        }\\n        return dfs(left,right,dp, k, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868250,
                "title": "kotlin-bottom-up-dp",
                "content": "````\\nimport java.util.*\\n\\nclass Solution {\\n    /**\\n     * Sort houses in ascending order. There is no dups so the order is strictly ascending.\\n     * Observation -\\n     *  The first mailbox in the optimal sol covers from 0 to i houses. Then from i+1 on, we\\n     *      just need to find the optimal for the next k-1 mailboxes.\\n     *  We could use a topdown recursive algo starting from 0.\\n     *  But here, we use bottom up dp starting at the last house\\n     *  dp: Array(n+1) { IntArray(k+1) { Int.MAX_VALUE } }\\n     *  dp[i][j] - min total distance for i to n-1 houses with j mailboxes\\n     *  dp[n][j] = 0 for all j\\n     *  dp[i][j] = min(min of 1st mailbox covering up to l + dp[l+1][j-1]), for all l from i to n-1.\\n     *      use fun minDistToOneMailbox to calc min of 1st mailbox covering up to l\\n     *      min(minDistToOneMailbox(i, l) + dp[l+1][j-1], over all l in i .. n-1)\\'\\n     *  Time Complexity: O(k*n^2) due to the three nested loops: 2 over n and 1 over k\\n     *  Storage: O(n*k) for dp and O(n) for pfs\\n     */\\n    fun minDistance(houses: IntArray, k: Int): Int {\\n        Arrays.sort(houses)\\n        val n = houses.size\\n        val dp = Array(n+1) { IntArray(k+1) { Int.MAX_VALUE } }\\n        val pfs = IntArray(n+1) { 0 } // prefix sum for calc distances in minDistToOneMailbox\\n        for (i in 0 .. n-1) {\\n            pfs[i+1] = pfs[i] + houses[i]\\n        }\\n        for (j in 0 .. k) {\\n            dp[n][j] = 0\\n        }\\n        for (i in n-1 downTo 0) {\\n            for (j in 1 .. k) {\\n                /**\\n                 * for each l in i .. n-1, calc total distance for the first mailbox covering i .. l,\\n                 * then choose the min\\n                 */\\n                var min = Int.MAX_VALUE\\n                for (l in i .. n-1) {\\n                    min = min.coerceAtMost(sum(dp[l+1][j-1], minDistToOneMailbox(houses, i, l, pfs)))\\n                }\\n                dp[i][j] = min\\n            }\\n        }\\n        return dp[0][k]\\n    }\\n    private fun minDistToOneMailbox(houses: IntArray, start: Int, end: Int, pfs: IntArray): Int {\\n        /**\\n         * min distance with one mailbox between houses start and end\\n         * number of houses between start and end\\n         *  odd: optimal mailbox must be at the medium house\\n         *  even: it turns out the optimal mailbox can be anywhere between the two houses closest to the medium\\n         *  so in both cases, we choose the optimal location at mid = start + ((end-start) shr 1)\\n         *  Then what is the min total distance?\\n         *      Using prefix sum, there is a small difference between odd and even cases.\\n         */\\n        if (start == end) return 0 // one mailbox for one house\\n        val mid = start + ((end-start) shr 1)\\n        val isEven = ((end - start + 1) % 2) == 0\\n\\n        val res = if (isEven) (pfs[end+1] - pfs[mid+1]) - (pfs[mid+1] - pfs[start]) else (pfs[end+1] - pfs[mid+1]) - (pfs[mid] - pfs[start])\\n\\n        return res\\n    }\\n    private fun sum(a: Int, b: Int): Int {\\n        return if (a == Int.MAX_VALUE) Int.MAX_VALUE\\n        else a + b\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nimport java.util.*\\n\\nclass Solution {\\n    /**\\n     * Sort houses in ascending order. There is no dups so the order is strictly ascending.\\n     * Observation -\\n     *  The first mailbox in the optimal sol covers from 0 to i houses. Then from i+1 on, we\\n     *      just need to find the optimal for the next k-1 mailboxes.\\n     *  We could use a topdown recursive algo starting from 0.\\n     *  But here, we use bottom up dp starting at the last house\\n     *  dp: Array(n+1) { IntArray(k+1) { Int.MAX_VALUE } }\\n     *  dp[i][j] - min total distance for i to n-1 houses with j mailboxes\\n     *  dp[n][j] = 0 for all j\\n     *  dp[i][j] = min(min of 1st mailbox covering up to l + dp[l+1][j-1]), for all l from i to n-1.\\n     *      use fun minDistToOneMailbox to calc min of 1st mailbox covering up to l\\n     *      min(minDistToOneMailbox(i, l) + dp[l+1][j-1], over all l in i .. n-1)\\'\\n     *  Time Complexity: O(k*n^2) due to the three nested loops: 2 over n and 1 over k\\n     *  Storage: O(n*k) for dp and O(n) for pfs\\n     */\\n    fun minDistance(houses: IntArray, k: Int): Int {\\n        Arrays.sort(houses)\\n        val n = houses.size\\n        val dp = Array(n+1) { IntArray(k+1) { Int.MAX_VALUE } }\\n        val pfs = IntArray(n+1) { 0 } // prefix sum for calc distances in minDistToOneMailbox\\n        for (i in 0 .. n-1) {\\n            pfs[i+1] = pfs[i] + houses[i]\\n        }\\n        for (j in 0 .. k) {\\n            dp[n][j] = 0\\n        }\\n        for (i in n-1 downTo 0) {\\n            for (j in 1 .. k) {\\n                /**\\n                 * for each l in i .. n-1, calc total distance for the first mailbox covering i .. l,\\n                 * then choose the min\\n                 */\\n                var min = Int.MAX_VALUE\\n                for (l in i .. n-1) {\\n                    min = min.coerceAtMost(sum(dp[l+1][j-1], minDistToOneMailbox(houses, i, l, pfs)))\\n                }\\n                dp[i][j] = min\\n            }\\n        }\\n        return dp[0][k]\\n    }\\n    private fun minDistToOneMailbox(houses: IntArray, start: Int, end: Int, pfs: IntArray): Int {\\n        /**\\n         * min distance with one mailbox between houses start and end\\n         * number of houses between start and end\\n         *  odd: optimal mailbox must be at the medium house\\n         *  even: it turns out the optimal mailbox can be anywhere between the two houses closest to the medium\\n         *  so in both cases, we choose the optimal location at mid = start + ((end-start) shr 1)\\n         *  Then what is the min total distance?\\n         *      Using prefix sum, there is a small difference between odd and even cases.\\n         */\\n        if (start == end) return 0 // one mailbox for one house\\n        val mid = start + ((end-start) shr 1)\\n        val isEven = ((end - start + 1) % 2) == 0\\n\\n        val res = if (isEven) (pfs[end+1] - pfs[mid+1]) - (pfs[mid+1] - pfs[start]) else (pfs[end+1] - pfs[mid+1]) - (pfs[mid] - pfs[start])\\n\\n        return res\\n    }\\n    private fun sum(a: Int, b: Int): Int {\\n        return if (a == Int.MAX_VALUE) Int.MAX_VALUE\\n        else a + b\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814045,
                "title": "wait-a-sec-is-this-kmeans",
                "content": "can I solve this by treating this as k-means?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1736583,
                "title": "python-dp-solution",
                "content": "```\\ndef minDistance(self, houses: List[int], K: int) -> int:\\n        \\n        m = len(houses)\\n        houses.sort() #nlogn\\n    \\n        mem ={}\\n        def dp(i,j,n):\\n            #O(n**3)\\n            \\n            if i>=j or n>=j-i+1: return 0\\n            \\n            if n==1: \\n                core = houses[(j+i) // 2]\\n                ans = sum([abs(houses[k] - core) for k in range(i, j + 1)])\\n                mem[(i,j,n)]= ans\\n                return ans\\n            \\n            if (i,j,n) in mem: return mem[(i,j,n)]\\n            \\n            ans = float(\"inf\")\\n            for k in range(i,j):\\n                temp_ans= dp(i,k,1) + dp(k+1,j,n-1) \\n                ans = min(ans, temp_ans)\\n            \\n            mem[(i,j,n)]= ans\\n            return ans\\n        \\n        return dp(0,m-1, K)\\n```",
                "solutionTags": [],
                "code": "```\\ndef minDistance(self, houses: List[int], K: int) -> int:\\n        \\n        m = len(houses)\\n        houses.sort() #nlogn\\n    \\n        mem ={}\\n        def dp(i,j,n):\\n            #O(n**3)\\n            \\n            if i>=j or n>=j-i+1: return 0\\n            \\n            if n==1: \\n                core = houses[(j+i) // 2]\\n                ans = sum([abs(houses[k] - core) for k in range(i, j + 1)])\\n                mem[(i,j,n)]= ans\\n                return ans\\n            \\n            if (i,j,n) in mem: return mem[(i,j,n)]\\n            \\n            ans = float(\"inf\")\\n            for k in range(i,j):\\n                temp_ans= dp(i,k,1) + dp(k+1,j,n-1) \\n                ans = min(ans, temp_ans)\\n            \\n            mem[(i,j,n)]= ans\\n            return ans\\n        \\n        return dp(0,m-1, K)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1697923,
                "title": "python-dfs-memo",
                "content": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        #split the houses to k groups\\n        #in each k group, find the optimal postion to minimize the total distance from a house to the mail box\\n        #dfs, try each split position and get the distance\\n        #return the one with minimum distance\\n        #O(n^2*k) time O(n*k) space        \\n        houses.sort()\\n        memo = {}\\n        return self.dfs(houses, 0, k, memo)\\n    \\n    \\n    def dfs(self, houses, i, k, memo):\\n        if (i, k) in memo:\\n            return memo[(i, k)]\\n        \\n        if i == len(houses) and k == 0:\\n            return 0\\n        if i == len(houses) or k == 0:\\n            return float(\"inf\")\\n        \\n        res = float(\"inf\")\\n        for j in range(i, len(houses)):\\n            #find total distance from each houses in [i:j+1] to a optimal mailbox location\\n            distance = self.getDistance(houses, i, j)\\n            res = min(res, self.dfs(houses, j + 1, k - 1, memo) + distance)\\n        \\n        memo[(i, k)] = res\\n        \\n        return res\\n    \\n    \\n    def getDistance(self, houses, i, j):\\n        #if the houses between [i:j + 1] is even, then any position in the range will have the same result\\n        #if odd, we put it in the middle house so distance to the middle house is zero, and the question same as above\\n        #in conclusion, the optimal location is middle house location\\n        \\n        mid = (i + j) // 2\\n        distance = 0\\n        for k in range(i, j + 1):\\n            distance += abs(houses[k] - houses[mid])\\n        return distance\\n        \\n            \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        #split the houses to k groups\\n        #in each k group, find the optimal postion to minimize the total distance from a house to the mail box\\n        #dfs, try each split position and get the distance\\n        #return the one with minimum distance\\n        #O(n^2*k) time O(n*k) space        \\n        houses.sort()\\n        memo = {}\\n        return self.dfs(houses, 0, k, memo)\\n    \\n    \\n    def dfs(self, houses, i, k, memo):\\n        if (i, k) in memo:\\n            return memo[(i, k)]\\n        \\n        if i == len(houses) and k == 0:\\n            return 0\\n        if i == len(houses) or k == 0:\\n            return float(\"inf\")\\n        \\n        res = float(\"inf\")\\n        for j in range(i, len(houses)):\\n            #find total distance from each houses in [i:j+1] to a optimal mailbox location\\n            distance = self.getDistance(houses, i, j)\\n            res = min(res, self.dfs(houses, j + 1, k - 1, memo) + distance)\\n        \\n        memo[(i, k)] = res\\n        \\n        return res\\n    \\n    \\n    def getDistance(self, houses, i, j):\\n        #if the houses between [i:j + 1] is even, then any position in the range will have the same result\\n        #if odd, we put it in the middle house so distance to the middle house is zero, and the question same as above\\n        #in conclusion, the optimal location is middle house location\\n        \\n        mid = (i + j) // 2\\n        distance = 0\\n        for k in range(i, j + 1):\\n            distance += abs(houses[k] - houses[mid])\\n        return distance\\n        \\n            \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695865,
                "title": "topdown-dp",
                "content": "Let dp(i, k) represents the answer for minDistance(houses[i:], k), the answer will be dp(0, k).\\nBase cases:\\n1. more mailboxes than houses (len(houses) - i <= k), return 0\\n2. one mailbox, place the mailbox at the median position, returns oneMailbox(i, len(houses)-1)  \\n     \\nRecursion:\\nif the first mailbox covers houses[i:j], then the distance is oneMailbox(i, j-1) + dp(j, k-1).  \\nIterate over j, and find the minimum value.\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        N = len(houses)\\n        def median(start, end):\\n            \"\"\"returns the median of houses[start:end+1]\"\"\"\\n            l = end + 1 - start\\n            q, r = divmod(l, 2)\\n            if r == 0:\\n                return (houses[start + q] + houses[start + q - 1]) / 2\\n            else:\\n                return houses[start + q]\\n        \\n        @lru_cache(None)\\n        def oneMailbox(start, end):\\n            \"\"\"base case: minDistance(houses[start:end+1], 1)\"\"\"\\n            m = median(start, end)\\n            ans = 0\\n            for i in range(start, end+1):\\n                ans += abs(houses[i] - m)\\n            return ans\\n        \\n        @lru_cache(None)\\n        def dp(i, k):\\n            \"\"\"returns value of minDistance(houses[i:], k)\"\"\"\\n            if N - i == k:\\n                return 0\\n            elif k == 1:\\n                return int(oneMailbox(i, N-1))\\n            else:\\n                ans = float(\\'inf\\')\\n                for j in range(i, N +1-k):\\n                    ans = min(ans, oneMailbox(i, j) + dp(j+1, k-1))\\n                return int(ans)\\n        \\n        return dp(0, k)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        N = len(houses)\\n        def median(start, end):\\n            \"\"\"returns the median of houses[start:end+1]\"\"\"\\n            l = end + 1 - start\\n            q, r = divmod(l, 2)\\n            if r == 0:\\n                return (houses[start + q] + houses[start + q - 1]) / 2\\n            else:\\n                return houses[start + q]\\n        \\n        @lru_cache(None)\\n        def oneMailbox(start, end):\\n            \"\"\"base case: minDistance(houses[start:end+1], 1)\"\"\"\\n            m = median(start, end)\\n            ans = 0\\n            for i in range(start, end+1):\\n                ans += abs(houses[i] - m)\\n            return ans\\n        \\n        @lru_cache(None)\\n        def dp(i, k):\\n            \"\"\"returns value of minDistance(houses[i:], k)\"\"\"\\n            if N - i == k:\\n                return 0\\n            elif k == 1:\\n                return int(oneMailbox(i, N-1))\\n            else:\\n                ans = float(\\'inf\\')\\n                for j in range(i, N +1-k):\\n                    ans = min(ans, oneMailbox(i, j) + dp(j+1, k-1))\\n                return int(ans)\\n        \\n        return dp(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695859,
                "title": "java-dp-o-kn-2-explaination",
                "content": "Similiar idea as: https://leetcode.com/problems/allocate-mailboxes/discuss/687502/Java-Simple-DP\\nBut I cannot understand his last loop, so here is mine lol...\\nideas:\\n```\\n\\tdp[i][j] represent the min cost if we use j mailboxes to serve first i house.\\n\\tbase case:\\n\\tdp[i][j] = 0 if k >= i (we can put mailbox on each house)\\n\\tdp[i][1] = getTotalDist(houses, 0, i-1) (get total distance for first i house)\\n\\tinduction rule:\\n\\tdp[i][j] = Min(dp[k][j-1] + getTotalDist(house, k, i-1)) where 1 <= k < i\\n\\tWe loop all possible k and find the min cost of using j-1 mailboxes to serve first k house, then we can put one more mailbox between\\n\\thouse k and house i-1 to get the cost of last part. (getTotalDist(house, k, i-1))\\n\\t\\n```\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        if (houses == null || houses.length == 0) return 0;\\n        if (k >= houses.length) return 0;\\n        Arrays.sort(houses);\\n        int[][] dp = new int[houses.length+1][k+1];\\n        for (int j=1;j<=k;j++) {\\n            // j mailbox\\n            for (int i=1;i<=houses.length;i++) {\\n                // first i houses\\n                if (j >= i) dp[i][j] = 0;\\n                else if (j == 1) {\\n                    dp[i][j] = getTotalDist(houses, 0, i-1);\\n                }\\n                else {\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                    for (int l=1;l<i;l++) {\\n                        dp[i][j] = Math.min(dp[i][j], dp[l][j-1] + getTotalDist(houses, l, i-1));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[houses.length][k];\\n    }\\n    \\n    // put mailbox to median position and calculate\\n    public int getTotalDist(int[] houses, int l, int r) {\\n        int res = 0;\\n        while (l < r) {\\n            res += houses[r--] - houses[l++];\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tdp[i][j] represent the min cost if we use j mailboxes to serve first i house.\\n\\tbase case:\\n\\tdp[i][j] = 0 if k >= i (we can put mailbox on each house)\\n\\tdp[i][1] = getTotalDist(houses, 0, i-1) (get total distance for first i house)\\n\\tinduction rule:\\n\\tdp[i][j] = Min(dp[k][j-1] + getTotalDist(house, k, i-1)) where 1 <= k < i\\n\\tWe loop all possible k and find the min cost of using j-1 mailboxes to serve first k house, then we can put one more mailbox between\\n\\thouse k and house i-1 to get the cost of last part. (getTotalDist(house, k, i-1))\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688531,
                "title": "python-divide-into-k-groups-o-kn-2",
                "content": "The problem is to divide houses into k groups so that minimize the total distance between any house and its nearest mailbox.\\nSort houses first.\\nSay ***dp[i, j]*** denotes the minimum total distance to allocate i mailbox for houses[:j].\\n1. Obviously, if ***j <= i***, then ***dp[i, j] = 0***\\n2. Otherwise, \\n\\n***`dp[i, j] = min(dp[i - 1, l] + distance(l, j) for l in range(i - 1, j))`***\\n\\nwhere distance(l, j) is the minimum total distance between house[l : j] and the mailbox.\\n\\nThen how to locate mailbox so that distance(l, j) is the minimum?\\nIntuitively, if the number of houses is even, (j - l) % 2 == 0, then the mailbox could at any position between the most inner two houses: [houses[(j + l) // 2], house[(j + l + 1) // 2]]. But if the number of houses is odd, (j - l) % 2 == 1, we just locate the mailbox at the center house: house[(j + l) // 2].\\n\\nHow to calculate distance(l, j) ?\\nFirst, if l >= j - 1, distance(l, j) = 0.\\nFor cases that l < j - 1:\\n***Solution1***: positions of mailbox  for houses[l, j] and houses[l + 1, j - 1] are the same, so we have:\\n**`distance(l, j) = distance(l + 1, j - 1) + houses[j - 1] - house[l]`**\\n\\n***Solution2***: find the relationship between distance(l, j) and distance(l + 1, j)\\n1. if (j - l) is even, the position of mailbox could be any in [houses[(j + l - 1) // 2], house[(j + l) // 2]], and the position of mailbox for houses[l + 1, j] is house[(j + l) // 2], so we locate the mailbox at house[(j + l) // 2], and the extra distance is house[(j + l) // 2] - houses[l], so we have:\\n**`distance(l, j) = distance(l + 1, j) + house[(j + l) // 2] - houses[l]`**\\n\\n2. if (j - l) is odd, the position  of mailbox is house[(j + l - 1) // 2] = house[(j + l) // 2], and the position of mailbox for houses[l + 1, j] could be any in [houses[(j + l) // 2], house[(j + l + 1) // 2]] , so we locate the mailbox at house[(j + l) // 2], and the extra distance is house[(j + l) // 2] - houses[l], so we also have:\\n**`distance(l, j) = distance(l + 1, j) + house[(j + l) // 2] - houses[l]`**\\n\\nHence no matter (j - l) is even or odd, \\n**`distance(l, j) = distance(l + 1, j) + house[(j + l) // 2] - houses[l]`**\\n\\n```\\nclass Solution(object):\\n    def minDistance(self, houses, k):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(houses)\\n        houses.sort()\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        for i in range(1, k + 1):\\n            for j in range(n, i, -1):\\n                distance = 0\\n                for l in range(j - 1, i - 2, -1):\\n                    distance += houses[(j + l) // 2] - houses[l]\\n                    dp[j] = min(dp[j], dp[l] + distance)\\n            dp[i] = 0\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, houses, k):\\n        \"\"\"\\n        :type houses: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(houses)\\n        houses.sort()\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        for i in range(1, k + 1):\\n            for j in range(n, i, -1):\\n                distance = 0\\n                for l in range(j - 1, i - 2, -1):\\n                    distance += houses[(j + l) // 2] - houses[l]\\n                    dp[j] = min(dp[j], dp[l] + distance)\\n            dp[i] = 0\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495306,
                "title": "java-recursive-dp-solution",
                "content": "```\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[][] dp = new int[n][k+1];\\n        for (int[] ar : dp) {\\n            Arrays.fill(ar, -1);\\n        }\\n        int result = recur(houses, 0, k, dp);\\n        return result;\\n    }\\n    \\n    private int recur(int[] houses, int idx, int k, int[][] dp) {\\n        if (dp[idx][k] != -1) {\\n            return dp[idx][k];\\n        }\\n        if (k == 1) {\\n            int dist = calDist(houses, idx, houses.length-1);\\n            dp[idx][k] = dist;\\n            return dp[idx][k];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int i = idx; i+k-1 < houses.length; i++) {\\n            int dist = calDist(houses, idx, i);\\n            dist += recur(houses, i+1, k-1, dp);\\n            min = Math.min(min, dist);\\n        }\\n        dp[idx][k] = min;\\n        return min;\\n    }\\n    \\n    private int calDist(int[] ar, int start, int end) {\\n        int result = 0;\\n        while(start < end) {\\n            result += ar[end--]-ar[start++];\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[][] dp = new int[n][k+1];\\n        for (int[] ar : dp) {\\n            Arrays.fill(ar, -1);\\n        }\\n        int result = recur(houses, 0, k, dp);\\n        return result;\\n    }\\n    \\n    private int recur(int[] houses, int idx, int k, int[][] dp) {\\n        if (dp[idx][k] != -1) {\\n            return dp[idx][k];\\n        }\\n        if (k == 1) {\\n            int dist = calDist(houses, idx, houses.length-1);\\n            dp[idx][k] = dist;\\n            return dp[idx][k];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int i = idx; i+k-1 < houses.length; i++) {\\n            int dist = calDist(houses, idx, i);\\n            dist += recur(houses, i+1, k-1, dp);\\n            min = Math.min(min, dist);\\n        }\\n        dp[idx][k] = min;\\n        return min;\\n    }\\n    \\n    private int calDist(int[] ar, int start, int end) {\\n        int result = 0;\\n        while(start < end) {\\n            result += ar[end--]-ar[start++];\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1480222,
                "title": "sharing-my-js-solution",
                "content": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n\\n    houses = houses.sort((a,b) => a-b)\\n    \\n    const solution = []\\n    for (let i=0; i<houses.length; i++) {\\n        const row = []\\n        for (let j=0; j<k+1; j++) {\\n            if (j == 0) {\\n                row.push(Number.MAX_SAFE_INTEGER)\\n            } else {\\n                row.push(NaN)\\n            }\\n        }\\n        solution.push(row)\\n    }\\n\\n    for (let j=1; j<=k; j++) {\\n\\n        for (let i=houses.length-1; i>=0; i--) {\\n\\n            if (j >= houses.length-i) {\\n                solution[i][j] = 0\\n                continue\\n            } \\n\\n            let minCost = singleCover(houses, i, houses.length-1)\\n\\n            for (let m=i; m<houses.length-1; m++) {\\n\\n                const cost = singleCover(houses, i, m)  + solution[m+1][j-1] \\n\\n                if (cost < minCost) {\\n                    minCost = cost\\n                }\\n            }\\n\\n            solution[i][j] = minCost\\n        }\\n    }\\n\\n    return solution[0][k]\\n};\\n\\n\\nfunction singleCover(houses, i, j) {\\n\\n    let minDist = 0\\n\\n    let mailboxIndex = Math.floor((i+j)/2)\\n\\n    for (let k=i; k<=j; k++) {\\n        minDist += Math.abs(houses[mailboxIndex]-houses[k])\\n    }\\n\\n    return minDist\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n\\n    houses = houses.sort((a,b) => a-b)\\n    \\n    const solution = []\\n    for (let i=0; i<houses.length; i++) {\\n        const row = []\\n        for (let j=0; j<k+1; j++) {\\n            if (j == 0) {\\n                row.push(Number.MAX_SAFE_INTEGER)\\n            } else {\\n                row.push(NaN)\\n            }\\n        }\\n        solution.push(row)\\n    }\\n\\n    for (let j=1; j<=k; j++) {\\n\\n        for (let i=houses.length-1; i>=0; i--) {\\n\\n            if (j >= houses.length-i) {\\n                solution[i][j] = 0\\n                continue\\n            } \\n\\n            let minCost = singleCover(houses, i, houses.length-1)\\n\\n            for (let m=i; m<houses.length-1; m++) {\\n\\n                const cost = singleCover(houses, i, m)  + solution[m+1][j-1] \\n\\n                if (cost < minCost) {\\n                    minCost = cost\\n                }\\n            }\\n\\n            solution[i][j] = minCost\\n        }\\n    }\\n\\n    return solution[0][k]\\n};\\n\\n\\nfunction singleCover(houses, i, j) {\\n\\n    let minDist = 0\\n\\n    let mailboxIndex = Math.floor((i+j)/2)\\n\\n    for (let k=i; k<=j; k++) {\\n        minDist += Math.abs(houses[mailboxIndex]-houses[k])\\n    }\\n\\n    return minDist\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443906,
                "title": "javascript-dp-recursion-memorization",
                "content": "```\\nvar minDistance = function(houses, k) {\\n    houses.sort((b, a) => b - a);\\n\\n    const n = houses.length;\\n    let dp = Array.from({length: n}, _ => Array(k + 1)), prefixSum = [0];\\n\\n    for (let i = 0; i < n; i++) {\\n        prefixSum[i + 1] = prefixSum[i] + houses[i];\\n    }\\n\\n    const minDistanceForThisSetOfHouses = (start, end) => {\\n        const mid = Math.trunc((start + end) / 2);\\n\\n        return (\\n            prefixSum[end] - \\n            prefixSum[mid] - \\n            prefixSum[mid - ((end - start + 1) % 2)] + \\n            prefixSum[start - 1]\\n        );\\n    }\\n\\n    const partition = (idx, k) => {\\n        if (dp[idx][k] === undefined) {\\n            if (n - idx === k) {\\n                dp[idx][k] = 0;\\n            } else if (k === 1) {\\n                dp[idx][k] = minDistanceForThisSetOfHouses(idx + 1, n);\\n            } else {\\n                dp[idx][k] = Number.MAX_SAFE_INTEGER;\\n                for (let i = idx; i <= n - k; i++) {\\n                    dp[idx][k] = Math.min(\\n                        dp[idx][k], \\n                        minDistanceForThisSetOfHouses(idx + 1, i + 1) +\\n                            partition(i + 1, k - 1)\\n                    );\\n                }\\n            }\\n        }\\n\\n        return dp[idx][k];\\n    }\\n    \\n    return partition(0, k);\\n};",
                "solutionTags": [],
                "code": "```\\nvar minDistance = function(houses, k) {\\n    houses.sort((b, a) => b - a);\\n\\n    const n = houses.length;\\n    let dp = Array.from({length: n}, _ => Array(k + 1)), prefixSum = [0];\\n\\n    for (let i = 0; i < n; i++) {\\n        prefixSum[i + 1] = prefixSum[i] + houses[i];\\n    }\\n\\n    const minDistanceForThisSetOfHouses = (start, end) => {\\n        const mid = Math.trunc((start + end) / 2);\\n\\n        return (\\n            prefixSum[end] - \\n            prefixSum[mid] - \\n            prefixSum[mid - ((end - start + 1) % 2)] + \\n            prefixSum[start - 1]\\n        );\\n    }\\n\\n    const partition = (idx, k) => {\\n        if (dp[idx][k] === undefined) {\\n            if (n - idx === k) {\\n                dp[idx][k] = 0;\\n            } else if (k === 1) {\\n                dp[idx][k] = minDistanceForThisSetOfHouses(idx + 1, n);\\n            } else {\\n                dp[idx][k] = Number.MAX_SAFE_INTEGER;\\n                for (let i = idx; i <= n - k; i++) {\\n                    dp[idx][k] = Math.min(\\n                        dp[idx][k], \\n                        minDistanceForThisSetOfHouses(idx + 1, i + 1) +\\n                            partition(i + 1, k - 1)\\n                    );\\n                }\\n            }\\n        }\\n\\n        return dp[idx][k];\\n    }\\n    \\n    return partition(0, k);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1427133,
                "title": "python-c-dp-memoization",
                "content": "Python ->\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @lru_cache(None)\\n        def dp(i,k):\\n            if i==n and k==0:\\n                return 0\\n            if i==n or k==0:\\n                return sys.maxsize\\n            ans=sys.maxsize\\n            for j in range(i,n):\\n                ans=min(ans,dp(j+1,k-1)+dist[i][j])\\n            return ans\\n        n=len(houses)\\n        houses.sort()\\n        dist=[[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i,n):\\n                mid=houses[(i+j)//2]\\n                for h in range(i,j+1):\\n                    dist[i][j]+=abs(mid-houses[h])\\n        return dp(0,k)\\n            \\n            \\n```\\n\\nC++ ->\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> memo;\\n    int dp(vector<vector<int>> dist,int i,int k,int n){\\n        if (memo.find({i,k})!=memo.end()) return memo[{i,k}];\\n        if (i==n and k==0) return 0;\\n        if (i==n or k==0) return INT_MAX/2;\\n        int ans=INT_MAX/2;\\n        for (int j=i;j<n;j++){\\n            ans=min(ans,dp(dist,j+1,k-1,n)+dist[i][j]);\\n        }\\n        memo[{i,k}]=ans;\\n        return ans;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        int n=houses.size();\\n        sort(houses.begin(),houses.end());\\n        vector<vector<int>> dist(n,vector<int>(n,0));\\n        for (int i=0;i<n;i++){\\n            for (int j=i;j<n;j++){\\n                int mid=houses[(i+j)/2];\\n                for (int h=i;h<=j;h++){\\n                    dist[i][j]+=abs(mid-houses[h]);\\n                }\\n            }\\n        }\\n        return dp(dist,0,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        @lru_cache(None)\\n        def dp(i,k):\\n            if i==n and k==0:\\n                return 0\\n            if i==n or k==0:\\n                return sys.maxsize\\n            ans=sys.maxsize\\n            for j in range(i,n):\\n                ans=min(ans,dp(j+1,k-1)+dist[i][j])\\n            return ans\\n        n=len(houses)\\n        houses.sort()\\n        dist=[[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i,n):\\n                mid=houses[(i+j)//2]\\n                for h in range(i,j+1):\\n                    dist[i][j]+=abs(mid-houses[h])\\n        return dp(0,k)\\n            \\n            \\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> memo;\\n    int dp(vector<vector<int>> dist,int i,int k,int n){\\n        if (memo.find({i,k})!=memo.end()) return memo[{i,k}];\\n        if (i==n and k==0) return 0;\\n        if (i==n or k==0) return INT_MAX/2;\\n        int ans=INT_MAX/2;\\n        for (int j=i;j<n;j++){\\n            ans=min(ans,dp(dist,j+1,k-1,n)+dist[i][j]);\\n        }\\n        memo[{i,k}]=ans;\\n        return ans;\\n    }\\n    int minDistance(vector<int>& houses, int k) {\\n        int n=houses.size();\\n        sort(houses.begin(),houses.end());\\n        vector<vector<int>> dist(n,vector<int>(n,0));\\n        for (int i=0;i<n;i++){\\n            for (int j=i;j<n;j++){\\n                int mid=houses[(i+j)/2];\\n                for (int h=i;h<=j;h++){\\n                    dist[i][j]+=abs(mid-houses[h]);\\n                }\\n            }\\n        }\\n        return dp(dist,0,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426798,
                "title": "java-solution",
                "content": "class Solution {\\n     int[][] cost = new int[101][101] ;\\n      int[][] dp = new int[101][101] ;\\n    public int minDistance(int[] houses, int k) \\n    {\\n\\t   int n =  houses.length ;\\n        Arrays.sort( houses ) ;\\n        //  O(n^3)\\n        /*\\n         i to j is one interval and we are travaling in each position in this interval \\n         and find the cost(  interval k mid se har house ki abs distance )\\n        */\\n        for( int i = 0  ; i  < n ; i++ )\\n        {\\n            for( int j = i ;  j < n ; j++ )\\n            {\\n                for( int d = i ; d <= j ; d++ )\\n                {\\n                //                             mid            each house\\n                   cost[i][j] +=  Math.abs( houses[ (i+j)/2 ] -  houses[d] ) ;    \\n                }\\n            }\\n        }\\n         for( int[] item : dp )\\n         {\\n             Arrays.fill( item , -1 ) ;\\n         }\\n        return sol( houses , k , 0 ) ;\\n        \\n    }\\n    public int sol( int[] houses ,  int k , int start )\\n    {\\n        int n = houses.length ;\\n        \\n        if( k == 0 && start == n ) return  0 ;\\n        if( k == 0 || start == n  ) return (int)1e7 ;\\n        if( dp[k][start] != -1 ) \\n        {\\n            return dp[k][start] ;\\n        }\\n         \\n        int ans = (int)1e7 ;\\n        for( int i = start ; i < n ; i++ )\\n        {\\n            ans = Math.min( ans , cost[start][i] + sol( houses , k - 1 , i + 1 ) ) ;\\n        } \\n        dp[k][start] = ans ;\\n        return ans ;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     int[][] cost = new int[101][101] ;\\n      int[][] dp = new int[101][101] ;\\n    public int minDistance(int[] houses, int k) \\n    {\\n\\t   int n =  houses.length ;\\n        Arrays.sort( houses ) ;\\n        //  O(n^3)\\n        /*\\n         i to j is one interval and we are travaling in each position in this interval \\n         and find the cost(  interval k mid se har house ki abs distance )\\n        */\\n        for( int i = 0  ; i  < n ; i++ )\\n        {\\n            for( int j = i ;  j < n ; j++ )\\n            {\\n                for( int d = i ; d <= j ; d++ )\\n                {\\n                //                             mid            each house\\n                   cost[i][j] +=  Math.abs( houses[ (i+j)/2 ] -  houses[d] ) ;    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1403372,
                "title": "c-inline-explaination-with-problem-breakup-easy-solution-97-runtime-memorized-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* \\n        Problem Breakup\\n        ---------------\\n        \\n        We need to divide whole array into k subarrays such that every subarray is a cluster\\n        of closely situated houses having 1 mailbox between them\\n        \\n        Now For placing 1 mailbox in a subarray, \\n        we should place it at the median house to minimize the whole cost\\n        \\n        Hint: Precompute one cost matrix for stroring cost values of placing mailboxes \\n        at median of every possible subarray (or interval)\\n        \\n    */\\n    \\n    \\n    /* Use partion into k subarrays logic for placing mailboxes and use cost of placing from cost matrix */\\n    \\n    int solve (vector<int> & houses, int n, int idx, int k, vector<vector<int>> & cost, vector<vector<int>> & dp){\\n        if(k==1) return cost[idx][n-1];\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        \\n        int ans = INT_MAX;\\n        \\n        /* We can use all k mailboxes so we will check cost till n-k+1 houses for placing curr mailbox */ \\n        \\n        for(int i=idx; i<n-k+1; i++){\\n            int temp = cost[idx][i] + solve (houses, n, i+1, k-1, cost, dp);\\n            ans = min(ans, temp);\\n        }\\n        \\n        return dp[idx][k] = ans;\\n    }\\n    \\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();     \\n        if(k==n) return 0;\\n        \\n        sort(houses.begin(), houses.end());\\n        \\n        vector<vector<int>> cost (n, vector<int> (n, 0));\\n        \\n        /* Filling cost of placing mail box in median point of every interval in cost matrix */\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                \\n                int median = i+(j-i+1)/2;\\n                int mailbox = houses[median];\\n                int c = 0;\\n                \\n                for(int k=i; k<=j; k++)\\n                    c += abs(houses[k]-mailbox);    \\n                \\n                cost[i][j] = c;\\n            }\\n        }\\n        \\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));    // --> For avoiding overlapping computations\\n\\n        return solve (houses, n, 0, k, cost, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* \\n        Problem Breakup\\n        ---------------\\n        \\n        We need to divide whole array into k subarrays such that every subarray is a cluster\\n        of closely situated houses having 1 mailbox between them\\n        \\n        Now For placing 1 mailbox in a subarray, \\n        we should place it at the median house to minimize the whole cost\\n        \\n        Hint: Precompute one cost matrix for stroring cost values of placing mailboxes \\n        at median of every possible subarray (or interval)\\n        \\n    */\\n    \\n    \\n    /* Use partion into k subarrays logic for placing mailboxes and use cost of placing from cost matrix */\\n    \\n    int solve (vector<int> & houses, int n, int idx, int k, vector<vector<int>> & cost, vector<vector<int>> & dp){\\n        if(k==1) return cost[idx][n-1];\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n        \\n        int ans = INT_MAX;\\n        \\n        /* We can use all k mailboxes so we will check cost till n-k+1 houses for placing curr mailbox */ \\n        \\n        for(int i=idx; i<n-k+1; i++){\\n            int temp = cost[idx][i] + solve (houses, n, i+1, k-1, cost, dp);\\n            ans = min(ans, temp);\\n        }\\n        \\n        return dp[idx][k] = ans;\\n    }\\n    \\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();     \\n        if(k==n) return 0;\\n        \\n        sort(houses.begin(), houses.end());\\n        \\n        vector<vector<int>> cost (n, vector<int> (n, 0));\\n        \\n        /* Filling cost of placing mail box in median point of every interval in cost matrix */\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                \\n                int median = i+(j-i+1)/2;\\n                int mailbox = houses[median];\\n                int c = 0;\\n                \\n                for(int k=i; k<=j; k++)\\n                    c += abs(houses[k]-mailbox);    \\n                \\n                cost[i][j] = c;\\n            }\\n        }\\n        \\n        vector<vector<int>> dp (n+1, vector<int> (k+1, -1));    // --> For avoiding overlapping computations\\n\\n        return solve (houses, n, 0, k, cost, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208533,
                "title": "simple-dp-javascript-solution-explained-in-comments",
                "content": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n    var distance=[],median,dist,cache={};\\n    houses.sort(function(a,b){return a-b});\\n    //distance[i][j] is the minimun distacne if we cover houses from ith index to jth index with 1 mailbox. This mailbox will be at the median index of sub array from ith index to jth index.\\n    for(let i=0;i<houses.length;i++){\\n        for(let j=i;j<houses.length;j++){\\n            median = Math.floor((i+j)/2);\\n            dist=0;\\n            for(let k=i;k<=j;k++){\\n                dist+=Math.abs(houses[median]-houses[k]);\\n            }\\n            if(distance[i]===undefined){\\n                distance[i]=[];\\n            }\\n            distance[i][j]=dist;\\n        }\\n    }\\n    return dp(0,k);\\n    function dp(i,k){\\n        let cacheKey=i+\"_\"+k;\\n        if(cache[cacheKey]!==undefined){\\n            return cache[cacheKey];\\n        }\\n        let min=Number.MAX_SAFE_INTEGER,ans;\\n        if(i===houses.length && k===0){//Its a correct answer only if we have used all the mailboxes and all the houses are completed. \\n            return 0;\\n        }\\n        if(i===houses.length || k===0){//Other than the first if condition, every other condition to exhaust either mailboxes for houses is an invalid answer. So returning minus an infinite number from here. \\n            return min;\\n        }\\n        \\n        for(let j=i;j<houses.length;j++){//Here in each step we are covering houses from ith index to jth index with one mailbox and calling dp function to cover the rest of the houses, starting from jth+1 index with the remaining k-1 houses. In each possible answer we will keep the minimum ans. \\n            ans = dp(j+1,k-1)+distance[i][j];\\n            min = Math.min(min,ans);\\n        }\\n        cache[cacheKey]=min;\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} houses\\n * @param {number} k\\n * @return {number}\\n */\\nvar minDistance = function(houses, k) {\\n    var distance=[],median,dist,cache={};\\n    houses.sort(function(a,b){return a-b});\\n    //distance[i][j] is the minimun distacne if we cover houses from ith index to jth index with 1 mailbox. This mailbox will be at the median index of sub array from ith index to jth index.\\n    for(let i=0;i<houses.length;i++){\\n        for(let j=i;j<houses.length;j++){\\n            median = Math.floor((i+j)/2);\\n            dist=0;\\n            for(let k=i;k<=j;k++){\\n                dist+=Math.abs(houses[median]-houses[k]);\\n            }\\n            if(distance[i]===undefined){\\n                distance[i]=[];\\n            }\\n            distance[i][j]=dist;\\n        }\\n    }\\n    return dp(0,k);\\n    function dp(i,k){\\n        let cacheKey=i+\"_\"+k;\\n        if(cache[cacheKey]!==undefined){\\n            return cache[cacheKey];\\n        }\\n        let min=Number.MAX_SAFE_INTEGER,ans;\\n        if(i===houses.length && k===0){//Its a correct answer only if we have used all the mailboxes and all the houses are completed. \\n            return 0;\\n        }\\n        if(i===houses.length || k===0){//Other than the first if condition, every other condition to exhaust either mailboxes for houses is an invalid answer. So returning minus an infinite number from here. \\n            return min;\\n        }\\n        \\n        for(let j=i;j<houses.length;j++){//Here in each step we are covering houses from ith index to jth index with one mailbox and calling dp function to cover the rest of the houses, starting from jth+1 index with the remaining k-1 houses. In each possible answer we will keep the minimum ans. \\n            ans = dp(j+1,k-1)+distance[i][j];\\n            min = Math.min(min,ans);\\n        }\\n        cache[cacheKey]=min;\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151127,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        return dpRec(houses, k, 0, new HashMap<String, Integer>());\\n    }\\n    private int dpRec(int[] houses, int k, int l, Map<String, Integer> cache) {\\n        List<Integer> cluster = new ArrayList<>();\\n        int min = 100000;\\n        if(k == 0 && l == houses.length) return 0;\\n        if(k < 0 || l > houses.length) return min;\\n        if(cache.containsKey(getKey(l,k))) return cache.get(getKey(l,k));\\n        for(int i = l; i < houses.length; i++){\\n            cluster.add(houses[i]);\\n            min = Math.min(min, getDistForCluster(cluster) + dpRec(houses, k-1, i+1, cache));\\n        }\\n        cache.put(getKey(l, k), min);\\n        return min;\\n    }\\n    private int getDistForCluster(List<Integer> cluster) {\\n        int median = getMedian(cluster);\\n        int walk = 0;\\n        for(int j = 0; j < cluster.size(); j++){\\n            walk += Math.abs(median-cluster.get(j));\\n        }\\n        // cluster.clear();\\n        return walk;\\n    }\\n    private int getMedian(List<Integer> cluster){\\n        int mid = cluster.size()/2;\\n        if(cluster.size()%2 == 0) {\\n            return cluster.get(mid);\\n        }\\n        return cluster.get(mid);\\n    }\\n    private String getKey(int l, int k) {\\n        return String.valueOf(l) + \" \" + String.valueOf(k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        return dpRec(houses, k, 0, new HashMap<String, Integer>());\\n    }\\n    private int dpRec(int[] houses, int k, int l, Map<String, Integer> cache) {\\n        List<Integer> cluster = new ArrayList<>();\\n        int min = 100000;\\n        if(k == 0 && l == houses.length) return 0;\\n        if(k < 0 || l > houses.length) return min;\\n        if(cache.containsKey(getKey(l,k))) return cache.get(getKey(l,k));\\n        for(int i = l; i < houses.length; i++){\\n            cluster.add(houses[i]);\\n            min = Math.min(min, getDistForCluster(cluster) + dpRec(houses, k-1, i+1, cache));\\n        }\\n        cache.put(getKey(l, k), min);\\n        return min;\\n    }\\n    private int getDistForCluster(List<Integer> cluster) {\\n        int median = getMedian(cluster);\\n        int walk = 0;\\n        for(int j = 0; j < cluster.size(); j++){\\n            walk += Math.abs(median-cluster.get(j));\\n        }\\n        // cluster.clear();\\n        return walk;\\n    }\\n    private int getMedian(List<Integer> cluster){\\n        int mid = cluster.size()/2;\\n        if(cluster.size()%2 == 0) {\\n            return cluster.get(mid);\\n        }\\n        return cluster.get(mid);\\n    }\\n    private String getKey(int l, int k) {\\n        return String.valueOf(l) + \" \" + String.valueOf(k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144847,
                "title": "swift-solution-with-dp",
                "content": "```\\nclass Solution {\\n    func minDistance(_ houses: [Int], _ k: Int) -> Int {\\n        var memo: [[Int]] = Array(repeating: Array(repeating: -1, count: houses.count), count: houses.count)\\n        var distance = Array(repeating: Array(repeating: 0, count: houses.count), count: houses.count) //interval to distance\\n        var sortedHouses = houses.sorted()\\n        \\n        func findDistance(_ start: Int,_ k: Int) -> Int {\\n            if start == houses.count && k == 0 { return 0}\\n            if start == houses.count || k == 0 { return Int.max}\\n            if memo[k-1][start] != -1 { return memo[k-1][start] } //check memo to save time\\n            var answer = Int.max\\n            for j in start..<houses.count {\\n                let tempAns = findDistance(j + 1, k - 1)\\n                if tempAns != Int.max { //only set answer when min distance returned is not Int.max\\n                    //so that min function here would not compare answer(which is max value) with max value\\n                    answer = min(answer, tempAns + distance[start][j])\\n                }\\n            }\\n            memo[k-1][start] = answer //memo that stores answer to numberOfMailBoxesLeft to the start position, it is k-1 since after this recursion completes, it is assumed that one mailbox is placed until we get to the last.\\n            return answer\\n        }\\n        \\n        let lengthOfHouses = sortedHouses.count\\n        for i in 0..<lengthOfHouses {\\n            for j in i..<lengthOfHouses {\\n                let midPosition = sortedHouses[(i + j) / 2]\\n                for x in i...j { //build distance from each house when mail box is placed at half index of i-j interval/cluster\\n                    distance[i][j] += abs(midPosition - sortedHouses[x])\\n                }\\n            }\\n        }\\n        return findDistance(0, k)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minDistance(_ houses: [Int], _ k: Int) -> Int {\\n        var memo: [[Int]] = Array(repeating: Array(repeating: -1, count: houses.count), count: houses.count)\\n        var distance = Array(repeating: Array(repeating: 0, count: houses.count), count: houses.count) //interval to distance\\n        var sortedHouses = houses.sorted()\\n        \\n        func findDistance(_ start: Int,_ k: Int) -> Int {\\n            if start == houses.count && k == 0 { return 0}\\n            if start == houses.count || k == 0 { return Int.max}\\n            if memo[k-1][start] != -1 { return memo[k-1][start] } //check memo to save time\\n            var answer = Int.max\\n            for j in start..<houses.count {\\n                let tempAns = findDistance(j + 1, k - 1)\\n                if tempAns != Int.max { //only set answer when min distance returned is not Int.max\\n                    //so that min function here would not compare answer(which is max value) with max value\\n                    answer = min(answer, tempAns + distance[start][j])\\n                }\\n            }\\n            memo[k-1][start] = answer //memo that stores answer to numberOfMailBoxesLeft to the start position, it is k-1 since after this recursion completes, it is assumed that one mailbox is placed until we get to the last.\\n            return answer\\n        }\\n        \\n        let lengthOfHouses = sortedHouses.count\\n        for i in 0..<lengthOfHouses {\\n            for j in i..<lengthOfHouses {\\n                let midPosition = sortedHouses[(i + j) / 2]\\n                for x in i...j { //build distance from each house when mail box is placed at half index of i-j interval/cluster\\n                    distance[i][j] += abs(midPosition - sortedHouses[x])\\n                }\\n            }\\n        }\\n        return findDistance(0, k)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144573,
                "title": "from-recursive-to-dp-2d-to-dp-1d-with-picture-explanation-of-prefix-sum-trick-python3",
                "content": "#K-means is an approximation solution for high dimensions, which will not be OK for here. This is 1D space, so a brute force solution must exist!!\\n# It\\u2019s important to realize that the mail box will be either mid_right or mid_left house.\\n#The prefix  sum trick applies to compute the distance: \\n#Sum(A[start:end] = prefix[end]-prefix[start]\\n#Dist(A[start:end]) = prefix[end] - prefix[mid_right] - (prefix[mid_left+1]-prefix[start])\\n![image](https://assets.leetcode.com/users/images/566440fb-8489-4073-a59b-9c866885e5f2_1617673632.211846.png)\\n\\nrecursive solution, which is actually the fastest (~200 ms) here because it only computes the necessary states.\\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses, houses = len(houses), sorted(houses)\\n        prefix = [0]\\n        for h in houses: prefix.append(prefix[-1]+h)\\n        def distance(start,end=nhouses-1):\\n            mid_right, mid_left = start + (end+1-start)//2, start + (end-start)//2\\n            return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1]-prefix[start])\\n\\n        @cache\\n        def helper(start,leftover):\\n            if leftover == 1:     return distance(start)\\n            return  min(distance(start,i)+helper(i+1,leftover-1) for i in range(start,nhouses-leftover+1) )\\n\\n        return helper(0,k)\\n\\n```\\n\\n# 3D recursion which absorbs the base case in also to make the code even shorter!\\n\\t\\t\\t# start+k-2 is the index of the earliest house because at least k-1 houses needed for k-1 mailboxes.\\n\\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses, houses= len(houses), sorted(houses)\\n        @cache\\n        def helper(start,end,k):\\n            if k == 1: \\n                mid_left, mid_right = (start+end)//2, (start+end+1)//2\\n                return sum(houses[mid_right:end+1]) - sum(houses[start:mid_left+1])\\n            return min(helper(start,parti,k-1)+helper(parti+1,end,1) for parti in range(start+k-2,end) )\\n        return helper(0,nhouses-1,k)\\n```\\n# 3D recursion with prefix sum trick (not really faster)\\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses, houses= len(houses), sorted(houses)\\n        prefix = [0]\\n        for h in houses: prefix.append(prefix[-1]+h)\\n        @cache\\n        def helper(start,end,k):\\n            if k == 1: \\n                mid_left, mid_right = (start+end)//2, (start+end+1)//2\\n                return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1] - prefix[start])\\n            return min(helper(start,parti,k-1)+helper(parti+1,end,1) for parti in range(start+k-2,end) ) \\n        return helper(0,nhouses-1,k)\\n```\\n# dp solution O(k*n*n) with 2D memory\\nAssume dp[k][h] is the direct answer for h houses, then write down the transfer function to reduce it to the base case one step at a time.\\nThe leap of faith is to convince yourself that you already know dp[k-1][...]  and write down the transferring equation for dp[k][h].\\n```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses = len(houses)\\n        houses = sorted(houses)\\n        prefix = [0]\\n        for h in houses:  prefix.append(prefix[-1]+h)\\n        def distance(start,end):\\n            #[start,end]\\n            mid_right = start + (end+1-start)//2\\n            mid_left = start + (end-start)//2\\n            return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1]-prefix[start])\\n        \\n        dp = [[0]*nhouses for _ in range(k)]\\n        dp[0] = [distance(0,i) for i in range(nhouses)]\\n        for m in range(1,k):\\n            for end in range(m,nhouses):\\n                dp[m][end] = min(distance(start+1,end)+dp[m-1][start] for start in range(m-1, end) )\\n        \\n        return dp[-1][-1]\\n```\\n\\n# dp solution with 1D memory\\nBecause dp[end] depends on dp[:end], so we need to update from the last item to avoid overwrite\\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses = len(houses)\\n        houses = sorted(houses)\\n        prefix = [0]\\n        for h in houses:  prefix.append(prefix[-1]+h)\\n        def distance(start,end):\\n            #[start,end]\\n            mid_right = start + (end+1-start)//2\\n            mid_left = start + (end-start)//2\\n            return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1]-prefix[start])\\n        \\n        dp = [distance(0,i) for i in range(nhouses)]\\n\\n        for m in range(1,k):\\n            for end in reversed(range(m,nhouses)): # reverse is the key to avoid overwriting!\\n                dp[end] = min(distance(start+1,end)+dp[start] for start in range(m-1, end) )\\n        \\n        return dp[-1]\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses, houses = len(houses), sorted(houses)\\n        prefix = [0]\\n        for h in houses: prefix.append(prefix[-1]+h)\\n        def distance(start,end=nhouses-1):\\n            mid_right, mid_left = start + (end+1-start)//2, start + (end-start)//2\\n            return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1]-prefix[start])\\n\\n        @cache\\n        def helper(start,leftover):\\n            if leftover == 1:     return distance(start)\\n            return  min(distance(start,i)+helper(i+1,leftover-1) for i in range(start,nhouses-leftover+1) )\\n\\n        return helper(0,k)\\n\\n```\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses, houses= len(houses), sorted(houses)\\n        @cache\\n        def helper(start,end,k):\\n            if k == 1: \\n                mid_left, mid_right = (start+end)//2, (start+end+1)//2\\n                return sum(houses[mid_right:end+1]) - sum(houses[start:mid_left+1])\\n            return min(helper(start,parti,k-1)+helper(parti+1,end,1) for parti in range(start+k-2,end) )\\n        return helper(0,nhouses-1,k)\\n```\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses, houses= len(houses), sorted(houses)\\n        prefix = [0]\\n        for h in houses: prefix.append(prefix[-1]+h)\\n        @cache\\n        def helper(start,end,k):\\n            if k == 1: \\n                mid_left, mid_right = (start+end)//2, (start+end+1)//2\\n                return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1] - prefix[start])\\n            return min(helper(start,parti,k-1)+helper(parti+1,end,1) for parti in range(start+k-2,end) ) \\n        return helper(0,nhouses-1,k)\\n```\n```\\ndef minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses = len(houses)\\n        houses = sorted(houses)\\n        prefix = [0]\\n        for h in houses:  prefix.append(prefix[-1]+h)\\n        def distance(start,end):\\n            #[start,end]\\n            mid_right = start + (end+1-start)//2\\n            mid_left = start + (end-start)//2\\n            return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1]-prefix[start])\\n        \\n        dp = [[0]*nhouses for _ in range(k)]\\n        dp[0] = [distance(0,i) for i in range(nhouses)]\\n        for m in range(1,k):\\n            for end in range(m,nhouses):\\n                dp[m][end] = min(distance(start+1,end)+dp[m-1][start] for start in range(m-1, end) )\\n        \\n        return dp[-1][-1]\\n```\n```\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        nhouses = len(houses)\\n        houses = sorted(houses)\\n        prefix = [0]\\n        for h in houses:  prefix.append(prefix[-1]+h)\\n        def distance(start,end):\\n            #[start,end]\\n            mid_right = start + (end+1-start)//2\\n            mid_left = start + (end-start)//2\\n            return prefix[end+1] - prefix[mid_right] - (prefix[mid_left+1]-prefix[start])\\n        \\n        dp = [distance(0,i) for i in range(nhouses)]\\n\\n        for m in range(1,k):\\n            for end in reversed(range(m,nhouses)): # reverse is the key to avoid overwriting!\\n                dp[end] = min(distance(start+1,end)+dp[start] for start in range(m-1, end) )\\n        \\n        return dp[-1]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1114270,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int distance(vector<int>& presum, vector<int>& houses, int begin, int end) {\\n        int mid = (begin + end) >> 1;\\n        int res = 0;\\n        res += houses[mid] * (mid - begin + 1) - (presum[mid+1] - presum[begin]);\\n        res += (presum[end+1] - presum[mid+1]) - houses[mid] * (end - mid);\\n        \\n        return res;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<int> presum;\\n        presum.push_back(0);\\n        for(int i=0; i<n; i++) {\\n            presum.push_back(presum.back() + houses[i]);\\n        }\\n        \\n        vector<vector<int>>dp(k, vector<int>(n+1, 100000000));\\n        for(int j=1; j<=n; j++) {\\n            dp[0][j] = distance(presum, houses, 0, j-1);\\n        }\\n        \\n        for(int i=1; i<k; i++) {\\n            for(int j=i+1; j<=n; j++) {\\n                for(int l=1; l<j; l++) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][l] + distance(presum, houses, l, j-1));\\n                }\\n            }\\n        }\\n                                   \\n        return dp[k-1][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int distance(vector<int>& presum, vector<int>& houses, int begin, int end) {\\n        int mid = (begin + end) >> 1;\\n        int res = 0;\\n        res += houses[mid] * (mid - begin + 1) - (presum[mid+1] - presum[begin]);\\n        res += (presum[end+1] - presum[mid+1]) - houses[mid] * (end - mid);\\n        \\n        return res;\\n    }\\n    \\n    int minDistance(vector<int>& houses, int k) {\\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<int> presum;\\n        presum.push_back(0);\\n        for(int i=0; i<n; i++) {\\n            presum.push_back(presum.back() + houses[i]);\\n        }\\n        \\n        vector<vector<int>>dp(k, vector<int>(n+1, 100000000));\\n        for(int j=1; j<=n; j++) {\\n            dp[0][j] = distance(presum, houses, 0, j-1);\\n        }\\n        \\n        for(int i=1; i<k; i++) {\\n            for(int j=i+1; j<=n; j++) {\\n                for(int l=1; l<j; l++) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][l] + distance(presum, houses, l, j-1));\\n                }\\n            }\\n        }\\n                                   \\n        return dp[k-1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103449,
                "title": "python-dp-with-comments",
                "content": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        costs = [[0]*101 for _ in range(101)] #check constraints\\n        dp = [[-1]*101 for _ in range(101)]\\n        \\n        for i in range(n):\\n            for j in range(i,n):\\n                for x in range(i,j+1):\\n                    costs[i][j] += abs(houses[(i+j)//2] - houses[x]) # mailbox at median - each house dist\\n        \\n        \\n        def helper(houses, k, start):\\n            if k == 0 and start == n: #we\\'ve reached end and no more mailboxes\\n                return 0\\n            if k == 0 or start == n: #either of those and not the other\\n                return float(\\'inf\\') \\n            if dp[k][start] != -1:\\n                return dp[k][start]\\n            \\n            ans = float(\\'inf\\')\\n            for i in range(start, n):\\n                               #start to i cost +  substract one mailbox and increment i\\n                ans = min(ans, costs[start][i] + helper(houses, k-1, i+1))\\n            \\n            dp[k][start] = ans\\n            return dp[k][start]\\n        \\n        return helper(houses, k, 0)      \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        n = len(houses)\\n        costs = [[0]*101 for _ in range(101)] #check constraints\\n        dp = [[-1]*101 for _ in range(101)]\\n        \\n        for i in range(n):\\n            for j in range(i,n):\\n                for x in range(i,j+1):\\n                    costs[i][j] += abs(houses[(i+j)//2] - houses[x]) # mailbox at median - each house dist\\n        \\n        \\n        def helper(houses, k, start):\\n            if k == 0 and start == n: #we\\'ve reached end and no more mailboxes\\n                return 0\\n            if k == 0 or start == n: #either of those and not the other\\n                return float(\\'inf\\') \\n            if dp[k][start] != -1:\\n                return dp[k][start]\\n            \\n            ans = float(\\'inf\\')\\n            for i in range(start, n):\\n                               #start to i cost +  substract one mailbox and increment i\\n                ans = min(ans, costs[start][i] + helper(houses, k-1, i+1))\\n            \\n            dp[k][start] = ans\\n            return dp[k][start]\\n        \\n        return helper(houses, k, 0)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087270,
                "title": "simple-python-solution-beats-99-explained",
                "content": "* `dp(i, j, k)` means the total distance of `houses[i:j+1]` with `k` mailboxs at optimal locations. \\n\\n* The base case is `dp(i, j, 1)`. We compute mininum total distance by putting the only 1 mailbox at the median position of `houses[i:j+1]`. \\n\\n* Recurrence relationship: `dp(i, j, k) = min( dp(i, m, k-1) + dp(m+1, j, 1) for m in range(i+k-2, j) )`. For `house[i: j+1]` with  `k` mailboxs, `j >= i + k - 1` because two mailboxs cannot be put in one location.\\n\\n\\n\\n```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        \\n        @lru_cache(None)\\n        def dp(i, j, k):\\n            if k == 1: \\n                total_distance = 0\\n                while i < j:\\n                    total_distance += houses[j] - houses[i]\\n                    i += 1\\n                    j -= 1\\n                return total_distance\\n            \\n            return min(dp(i,m,k-1) + dp(m+1,j,1) for m in range(i+k-2, j))\\n        \\n        return dp(0, len(houses)-1, k)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, houses: List[int], k: int) -> int:\\n        houses.sort()\\n        \\n        @lru_cache(None)\\n        def dp(i, j, k):\\n            if k == 1: \\n                total_distance = 0\\n                while i < j:\\n                    total_distance += houses[j] - houses[i]\\n                    i += 1\\n                    j -= 1\\n                return total_distance\\n            \\n            return min(dp(i,m,k-1) + dp(m+1,j,1) for m in range(i+k-2, j))\\n        \\n        return dp(0, len(houses)-1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035669,
                "title": "should-we-use-machine-learning-algorithm-like-k-means",
                "content": "just at first glance, I think we should use clustering algorithms like K-means. Then we have k clusters. \\n\\nFor each cluster, we should put the mail box at the median of all houses in this cluster.\\n\\nAny problems with this method?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1018216,
                "title": "java-3d-bottom-up-dp-solution-not-optimal-but-easy-to-understand",
                "content": "This is a pretty straight forward bottom-up dp solution. `dp[m][s][e]` stands for the min distance for [House(e), ..., House(e)] with m mailboxes.\\nI guess we should be able to remove the innermost loop which will reduce the time complexity from n^4 to n^3. The trick might be similar to the one used in 1mailbox case but not sure how. Need more insight on this.\\n```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[][][] dp = new int[k+1][n][n]; // [#mailbox][houses_start][houses_end]\\n        \\n        // H(s)->H(e) with 1 mailbox\\n        for (int s = 0; s < n; s++) {\\n            for (int e = s+1; e < n; e++) {\\n                int d = houses[e] - houses[s+(e-s)/2];\\n                dp[1][s][e] = dp[1][s][e-1] + d;\\n                // System.out.println(\"1,\" + s + \",\" + e + \": \" + dp[1][s][e]);\\n            }\\n        }\\n        \\n        // H(s)->H(e) with m mailbox\\n        for (int m = 2; m <= k; m++) {\\n            for (int s = 0; s < n; s++) {\\n                for (int e = s+m; e < n; e++) {\\n                    dp[m][s][e] = Integer.MAX_VALUE;\\n                    for (int ss = e; ss > s; ss--) {\\n                        dp[m][s][e] = Math.min(dp[m][s][e], dp[m-1][s][ss-1] + dp[1][ss][e]);\\n                    }\\n                    // System.out.println(m + \",\" + s + \",\" + e + \": \" + dp[m][s][e]);\\n                }\\n            }\\n        }\\n        \\n        return dp[k][0][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(int[] houses, int k) {\\n        Arrays.sort(houses);\\n        int n = houses.length;\\n        int[][][] dp = new int[k+1][n][n]; // [#mailbox][houses_start][houses_end]\\n        \\n        // H(s)->H(e) with 1 mailbox\\n        for (int s = 0; s < n; s++) {\\n            for (int e = s+1; e < n; e++) {\\n                int d = houses[e] - houses[s+(e-s)/2];\\n                dp[1][s][e] = dp[1][s][e-1] + d;\\n                // System.out.println(\"1,\" + s + \",\" + e + \": \" + dp[1][s][e]);\\n            }\\n        }\\n        \\n        // H(s)->H(e) with m mailbox\\n        for (int m = 2; m <= k; m++) {\\n            for (int s = 0; s < n; s++) {\\n                for (int e = s+m; e < n; e++) {\\n                    dp[m][s][e] = Integer.MAX_VALUE;\\n                    for (int ss = e; ss > s; ss--) {\\n                        dp[m][s][e] = Math.min(dp[m][s][e], dp[m-1][s][ss-1] + dp[1][ss][e]);\\n                    }\\n                    // System.out.println(m + \",\" + s + \",\" + e + \": \" + dp[m][s][e]);\\n                }\\n            }\\n        }\\n        \\n        return dp[k][0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000971,
                "title": "c-top-down-dp-o-n3",
                "content": "```\\n//TC: O(n3) : precompute the allocation cost between house i and house j\\n//SC: O(n2 + nk)\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        \\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>> memo(n, vector<int>(k+1, -1));   //memo[i][k]: the minimum distance of traversing houses from 0 to i with k mail boxes left\\n        vector<vector<int>> cost(n, vector<int>(n, 0));      //precompute the allocation cost between house i and house j\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = i+1; j < n; j++){\\n                int l = i;\\n                int r = j;\\n                while(r > l) cost[i][j] += houses[r--] - houses[l++];                    \\n            }\\n                \\n        \\n        return dfs(houses, 0, k, memo, cost);\\n        \\n    }\\n    \\n    int dfs(const vector<int>& houses, int i, int k, vector<vector<int>>& memo, const vector<vector<int>>& cost){\\n        \\n        int n = houses.size();\\n        if(i == n && k == 0) return 0;\\n        if(i == n || k == 0) return INT_MAX;\\n        if(memo[i][k] != -1) return memo[i][k];\\n        \\n        long res = INT_MAX;\\n        for(int j = i; j <= n - k; j++)\\n            res = min(res, 0l + cost[i][j] + dfs(houses, j+1, k-1, memo, cost));\\n            \\n        return memo[i][k] = int(res);\\n            \\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//TC: O(n3) : precompute the allocation cost between house i and house j\\n//SC: O(n2 + nk)\\nclass Solution {\\npublic:\\n    int minDistance(vector<int>& houses, int k) {\\n        \\n        int n = houses.size();\\n        sort(houses.begin(), houses.end());\\n        vector<vector<int>> memo(n, vector<int>(k+1, -1));   //memo[i][k]: the minimum distance of traversing houses from 0 to i with k mail boxes left\\n        vector<vector<int>> cost(n, vector<int>(n, 0));      //precompute the allocation cost between house i and house j\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = i+1; j < n; j++){\\n                int l = i;\\n                int r = j;\\n                while(r > l) cost[i][j] += houses[r--] - houses[l++];                    \\n            }\\n                \\n        \\n        return dfs(houses, 0, k, memo, cost);\\n        \\n    }\\n    \\n    int dfs(const vector<int>& houses, int i, int k, vector<vector<int>>& memo, const vector<vector<int>>& cost){\\n        \\n        int n = houses.size();\\n        if(i == n && k == 0) return 0;\\n        if(i == n || k == 0) return INT_MAX;\\n        if(memo[i][k] != -1) return memo[i][k];\\n        \\n        long res = INT_MAX;\\n        for(int j = i; j <= n - k; j++)\\n            res = min(res, 0l + cost[i][j] + dfs(houses, j+1, k-1, memo, cost));\\n            \\n        return memo[i][k] = int(res);\\n            \\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999631,
                "title": "for-dp-based-solution-why-assigning-one-mail-box-to-the-last-houses",
                "content": "I have seen many DP solutions (see below links), and I have the quesion as in the title, which seems to be an implicit assumption held by most of these solutions.\\n\\nLet\\'s say we are doing DP for H houses with K mailboxes, we can calculate DP[H][K] using the followin loop:\\n\\tfor h in range(H):\\n\\t\\tDP[H][K] = min(DP[H][K], DP[h][K-1] + **cost(h+1, i)**)\\n\\nMy question is why assigning one mailbox to the last houses will give the optimal solution? I came up with a DP solution that needs to iterate through also the number of mailboxes assigned to the first houses and then the last houses, which surprisining gives the same result as these solutions, but for me it is not obvious at all why this iteration can be omitted. \\n\\nI would really apprecaite it if someone could clarify this part. Thank you!\\n\\nhttps://leetcode.com/problems/allocate-mailboxes/discuss/992357/Simple-DP-solution-with-O(k*N2)-time-and-O(k*N)-space-complexity\\nhttps://leetcode.com/problems/allocate-mailboxes/discuss/861951/JAVA-or-Simple-DP-With-Explaination-or-Beats-100-or-O(N2*K-%2BNlgN)",
                "solutionTags": [],
                "code": "I have seen many DP solutions (see below links), and I have the quesion as in the title, which seems to be an implicit assumption held by most of these solutions.\\n\\nLet\\'s say we are doing DP for H houses with K mailboxes, we can calculate DP[H][K] using the followin loop:\\n\\tfor h in range(H):\\n\\t\\tDP[H][K] = min(DP[H][K], DP[h][K-1] + **cost(h+1, i)**)\\n\\nMy question is why assigning one mailbox to the last houses will give the optimal solution? I came up with a DP solution that needs to iterate through also the number of mailboxes assigned to the first houses and then the last houses, which surprisining gives the same result as these solutions, but for me it is not obvious at all why this iteration can be omitted. \\n\\nI would really apprecaite it if someone could clarify this part. Thank you!\\n\\nhttps://leetcode.com/problems/allocate-mailboxes/discuss/992357/Simple-DP-solution-with-O(k*N2)-time-and-O(k*N)-space-complexity\\nhttps://leetcode.com/problems/allocate-mailboxes/discuss/861951/JAVA-or-Simple-DP-With-Explaination-or-Beats-100-or-O(N2*K-%2BNlgN)",
                "codeTag": "Unknown"
            },
            {
                "id": 982995,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> dp;\\n    vector<int> houses;\\n    \\n    int getDist(int i, int j) {\\n        int m = (i + j) / 2;\\n        int total = 0;\\n        for (; i <= j; ++i)\\n            total += abs(houses[i] - houses[m]);\\n\\n        return total;\\n    }\\n    \\n    int helper(int n, int k) {\\n        if (dp[n][k] != INT_MAX) return dp[n][k];\\n        if (k == 0) return dp[n][k] = getDist(0, n);\\n        \\n        for (int i = n-1; i >= k-1; --i)\\n            dp[n][k] = min(dp[n][k], helper(i, k-1) + getDist(i+1, n));\\n        \\n        return dp[n][k];\\n    }\\n    \\npublic:\\n    int minDistance(vector<int>& houses_, int k) {\\n        houses = houses_;\\n        sort(houses.begin(), houses.end());\\n        n = houses.size();\\n        dp = vector<vector<int>>(n, vector<int>(k, INT_MAX));\\n        \\n        return helper(n-1, k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> dp;\\n    vector<int> houses;\\n    \\n    int getDist(int i, int j) {\\n        int m = (i + j) / 2;\\n        int total = 0;\\n        for (; i <= j; ++i)\\n            total += abs(houses[i] - houses[m]);\\n\\n        return total;\\n    }\\n    \\n    int helper(int n, int k) {\\n        if (dp[n][k] != INT_MAX) return dp[n][k];\\n        if (k == 0) return dp[n][k] = getDist(0, n);\\n        \\n        for (int i = n-1; i >= k-1; --i)\\n            dp[n][k] = min(dp[n][k], helper(i, k-1) + getDist(i+1, n));\\n        \\n        return dp[n][k];\\n    }\\n    \\npublic:\\n    int minDistance(vector<int>& houses_, int k) {\\n        houses = houses_;\\n        sort(houses.begin(), houses.end());\\n        n = houses.size();\\n        dp = vector<vector<int>>(n, vector<int>(k, INT_MAX));\\n        \\n        return helper(n-1, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944340,
                "title": "c-dp-with-explanation",
                "content": "cost of placing j mail boxes between 0-i  =\\n      cost of placing j-1 mail boxes between 0 to i-m + cost of placing 1 mail box between i-m to i  \\n     \\nresult=cost of placing k mail boxes between 0 to n\\t \\n```\\nclass Solution {\\npublic:\\n    int cost(int lo,int hi,vector<int>&h)\\n    {\\n        int med;\\n        int diff=hi-lo;\\n        if(diff&1)\\n        {\\n            med=h[lo+diff/2];\\n        }\\n        else\\n        {\\n            med=(h[lo+diff/2]+h[lo+diff/2-1])/2;\\n        }\\n        int cost=0;\\n        for(int i=lo;i<hi;i++)\\n        {\\n            cost+=abs(med-h[i]);\\n        }\\n        return cost;\\n    }\\n    int minDistance(vector<int>& h, int k) {\\n        sort(h.begin(),h.end());\\n        int n=h.size();\\n        if(n==1 or k>=n)\\n            return 0;\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(k+1,9999));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                if(j==1)\\n                {\\n                    dp[i][j]=cost(0,i,h);//cost of placing 1st mail box between 0-i BASE CASE\\n                }\\n                \\n                for(int m=1;m<i;m++)\\n                {\\n                    dp[i][j]=min(dp[i][j],dp[i-m][j-1]+cost(i-m,i,h));\\n                    /*cost of placing j mail boxes between 0-i  =\\n                         cost of placing j-1 mail boxes between 0 to i-m + cost of placing 1 mail box between i-m to i  \\n                    \\n                    */           \\n                }\\n            }   \\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(int lo,int hi,vector<int>&h)\\n    {\\n        int med;\\n        int diff=hi-lo;\\n        if(diff&1)\\n        {\\n            med=h[lo+diff/2];\\n        }\\n        else\\n        {\\n            med=(h[lo+diff/2]+h[lo+diff/2-1])/2;\\n        }\\n        int cost=0;\\n        for(int i=lo;i<hi;i++)\\n        {\\n            cost+=abs(med-h[i]);\\n        }\\n        return cost;\\n    }\\n    int minDistance(vector<int>& h, int k) {\\n        sort(h.begin(),h.end());\\n        int n=h.size();\\n        if(n==1 or k>=n)\\n            return 0;\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(k+1,9999));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=k;j++)\\n            {\\n                if(j==1)\\n                {\\n                    dp[i][j]=cost(0,i,h);//cost of placing 1st mail box between 0-i BASE CASE\\n                }\\n                \\n                for(int m=1;m<i;m++)\\n                {\\n                    dp[i][j]=min(dp[i][j],dp[i-m][j-1]+cost(i-m,i,h));\\n                    /*cost of placing j mail boxes between 0-i  =\\n                         cost of placing j-1 mail boxes between 0 to i-m + cost of placing 1 mail box between i-m to i  \\n                    \\n                    */           \\n                }\\n            }   \\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942684,
                "title": "java-o-n-3-top-down-dp",
                "content": "We need to sort the `houses` array because the basecase depends on being able to determine the median location of the houses in a given range `[i,j]`\\n\\n`opt[m][h]` is the optimal total distance for `m` mailboxes and a suffix of houses starting at index `h`\\n\\nBasecases: Place 1 mailbox amongst a suffix of `houses` starting at index `h`. This will be the `median` of all the house locations. See [here](https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-ell-1-norm) for a formal proof. `optOneMailBoxDistance[i][j]` is the minimum distance possible when placing 1 box amongst `houses[i], ... , houses[j]`\\n\\nRecurrence: `opt(m, h) = min (optOneMailBoxDistance(h, j) + opt(m-1, j+1))` for `h <= j <= n-m`\\n\\n```\\nclass Solution {\\n  public int minDistance(int[] houses, int k) {\\n    Arrays.sort(houses);\\n    \\n    int n = houses.length;\\n    // opt(x, i) = the optimal total distance between x mailboxes and suffix of houses starting at index i\\n    // we want opt(k, 0);\\n    int[][] opt = new int[k+1][n];\\n    int[][] optOneMailBoxDistance = new int[n][n];\\n    for (int i = 0; i < n; i++) {\\n      for (int j = i+1; j < n; j++) {\\n        int optMailbox = (i + j) / 2;   // will give lower median for even number of houses, \\n        // but it doesn\\'t matter as the whole interval [houses[optMailbox], houses[optMailbox+1]] \\n        // gives the same cost function\\n        for (int m = i; m <= j; m++){\\n          optOneMailBoxDistance[i][j] += Math.abs(houses[m] - houses[optMailbox]);\\n        }\\n      }\\n    }\\n    for (int[] o: opt) {\\n      Arrays.fill(o, -1);\\n    }  \\n    return optSolve(opt, k, 0, optOneMailBoxDistance, n);\\n  }\\n  \\n  int optSolve(int[][] opt, int m, int h, int[][] optOneMailBoxDistance, int n) {\\n    if (m == 1) {\\n      return optOneMailBoxDistance[h][n-1];\\n    }\\n    if (opt[m][h] != -1) {\\n      return opt[m][h];\\n    }\\n    int min = Integer.MAX_VALUE;\\n    for (int j = h; j <= n-m; j++) {\\n      // place m-1 mailboxes between index j + 1 , .. , (n-1)\\n      min = Math.min(min, optOneMailBoxDistance[h][j] + optSolve(opt, m-1, j+1, optOneMailBoxDistance, n));\\n    }\\n    opt[m][h] = min;\\n    return min;\\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n  public int minDistance(int[] houses, int k) {\\n    Arrays.sort(houses);\\n    \\n    int n = houses.length;\\n    // opt(x, i) = the optimal total distance between x mailboxes and suffix of houses starting at index i\\n    // we want opt(k, 0);\\n    int[][] opt = new int[k+1][n];\\n    int[][] optOneMailBoxDistance = new int[n][n];\\n    for (int i = 0; i < n; i++) {\\n      for (int j = i+1; j < n; j++) {\\n        int optMailbox = (i + j) / 2;   // will give lower median for even number of houses, \\n        // but it doesn\\'t matter as the whole interval [houses[optMailbox], houses[optMailbox+1]] \\n        // gives the same cost function\\n        for (int m = i; m <= j; m++){\\n          optOneMailBoxDistance[i][j] += Math.abs(houses[m] - houses[optMailbox]);\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568353,
                "content": [
                    {
                        "username": "luffy_is_joyboy",
                        "content": "I was thinking of the following solution:\\n1.  If houses.size() <= k, return 0\\n2.  Else start with k houses --> houses[0], houses[n-1], k-2 houses in between\\n3.  Iterate for some loops ->\\n* cluster houses into nearest mail boxes\\n* claculate the integer mean\\n* minimize the current answer with the global answer\\n* Keep repeating\\n4. stop after some fixed number of iterations or when the k mail boxes positions doesn\\'t change.\\n\\nAny idea how to make this work, or why this could fail?"
                    },
                    {
                        "username": "kumom",
                        "content": "So I think many people have the question of where to put the mailbox if k = 1, which is essential in order to solve the base case.\\n\\nHere is [a useful post from Math StackExchange](https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-l-1-norm).\\n\\nAn alternative question would be where to put the mailbox if k = 1 and the distance we are trying to minimize is the Euclidian distance (i.e. term becomes (a-b)^2 instead of |a-b|). The answer for that would be to take the average of all points. One can use derivative to prove that. You can find more details [here](https://math.stackexchange.com/questions/696622/intuition-on-why-the-average-minimizes-the-euclidean-distance)."
                    },
                    {
                        "username": "ykechan",
                        "content": "So quite a few solutions involve calculating the median since it is the location to place the mailbox if k=1. Actually this is not necessary. Imagine there are only two houses at i and j  and k = 1. Place anywhere in between the two houses will yield the same distance |i - j|. If you have 2n houses, places anywhere in between house n - 1 and n will yield the same shortest distance. If you have 2n+1 houses, since this is discussion I will leave for the readers."
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "I think we can use Aggressive Cows concept here\\n"
                    }
                ]
            },
            {
                "id": 1569990,
                "content": [
                    {
                        "username": "luffy_is_joyboy",
                        "content": "I was thinking of the following solution:\\n1.  If houses.size() <= k, return 0\\n2.  Else start with k houses --> houses[0], houses[n-1], k-2 houses in between\\n3.  Iterate for some loops ->\\n* cluster houses into nearest mail boxes\\n* claculate the integer mean\\n* minimize the current answer with the global answer\\n* Keep repeating\\n4. stop after some fixed number of iterations or when the k mail boxes positions doesn\\'t change.\\n\\nAny idea how to make this work, or why this could fail?"
                    },
                    {
                        "username": "kumom",
                        "content": "So I think many people have the question of where to put the mailbox if k = 1, which is essential in order to solve the base case.\\n\\nHere is [a useful post from Math StackExchange](https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-l-1-norm).\\n\\nAn alternative question would be where to put the mailbox if k = 1 and the distance we are trying to minimize is the Euclidian distance (i.e. term becomes (a-b)^2 instead of |a-b|). The answer for that would be to take the average of all points. One can use derivative to prove that. You can find more details [here](https://math.stackexchange.com/questions/696622/intuition-on-why-the-average-minimizes-the-euclidean-distance)."
                    },
                    {
                        "username": "ykechan",
                        "content": "So quite a few solutions involve calculating the median since it is the location to place the mailbox if k=1. Actually this is not necessary. Imagine there are only two houses at i and j  and k = 1. Place anywhere in between the two houses will yield the same distance |i - j|. If you have 2n houses, places anywhere in between house n - 1 and n will yield the same shortest distance. If you have 2n+1 houses, since this is discussion I will leave for the readers."
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "I think we can use Aggressive Cows concept here\\n"
                    }
                ]
            },
            {
                "id": 1752193,
                "content": [
                    {
                        "username": "luffy_is_joyboy",
                        "content": "I was thinking of the following solution:\\n1.  If houses.size() <= k, return 0\\n2.  Else start with k houses --> houses[0], houses[n-1], k-2 houses in between\\n3.  Iterate for some loops ->\\n* cluster houses into nearest mail boxes\\n* claculate the integer mean\\n* minimize the current answer with the global answer\\n* Keep repeating\\n4. stop after some fixed number of iterations or when the k mail boxes positions doesn\\'t change.\\n\\nAny idea how to make this work, or why this could fail?"
                    },
                    {
                        "username": "kumom",
                        "content": "So I think many people have the question of where to put the mailbox if k = 1, which is essential in order to solve the base case.\\n\\nHere is [a useful post from Math StackExchange](https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-l-1-norm).\\n\\nAn alternative question would be where to put the mailbox if k = 1 and the distance we are trying to minimize is the Euclidian distance (i.e. term becomes (a-b)^2 instead of |a-b|). The answer for that would be to take the average of all points. One can use derivative to prove that. You can find more details [here](https://math.stackexchange.com/questions/696622/intuition-on-why-the-average-minimizes-the-euclidean-distance)."
                    },
                    {
                        "username": "ykechan",
                        "content": "So quite a few solutions involve calculating the median since it is the location to place the mailbox if k=1. Actually this is not necessary. Imagine there are only two houses at i and j  and k = 1. Place anywhere in between the two houses will yield the same distance |i - j|. If you have 2n houses, places anywhere in between house n - 1 and n will yield the same shortest distance. If you have 2n+1 houses, since this is discussion I will leave for the readers."
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "I think we can use Aggressive Cows concept here\\n"
                    }
                ]
            },
            {
                "id": 2018181,
                "content": [
                    {
                        "username": "luffy_is_joyboy",
                        "content": "I was thinking of the following solution:\\n1.  If houses.size() <= k, return 0\\n2.  Else start with k houses --> houses[0], houses[n-1], k-2 houses in between\\n3.  Iterate for some loops ->\\n* cluster houses into nearest mail boxes\\n* claculate the integer mean\\n* minimize the current answer with the global answer\\n* Keep repeating\\n4. stop after some fixed number of iterations or when the k mail boxes positions doesn\\'t change.\\n\\nAny idea how to make this work, or why this could fail?"
                    },
                    {
                        "username": "kumom",
                        "content": "So I think many people have the question of where to put the mailbox if k = 1, which is essential in order to solve the base case.\\n\\nHere is [a useful post from Math StackExchange](https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-l-1-norm).\\n\\nAn alternative question would be where to put the mailbox if k = 1 and the distance we are trying to minimize is the Euclidian distance (i.e. term becomes (a-b)^2 instead of |a-b|). The answer for that would be to take the average of all points. One can use derivative to prove that. You can find more details [here](https://math.stackexchange.com/questions/696622/intuition-on-why-the-average-minimizes-the-euclidean-distance)."
                    },
                    {
                        "username": "ykechan",
                        "content": "So quite a few solutions involve calculating the median since it is the location to place the mailbox if k=1. Actually this is not necessary. Imagine there are only two houses at i and j  and k = 1. Place anywhere in between the two houses will yield the same distance |i - j|. If you have 2n houses, places anywhere in between house n - 1 and n will yield the same shortest distance. If you have 2n+1 houses, since this is discussion I will leave for the readers."
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "I think we can use Aggressive Cows concept here\\n"
                    }
                ]
            }
        ]
    }
]