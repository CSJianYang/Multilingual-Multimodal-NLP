[
    {
        "title": "Buddy Strings",
        "question_content": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\n\tFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n\n&nbsp;\nExample 1:\n\nInput: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.\n\nExample 2:\n\nInput: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.\n\nExample 3:\n\nInput: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, goal.length <= 2 * 104\n\ts and goal consist of lowercase letters.",
        "solutions": [
            {
                "id": 141780,
                "title": "easy-understood",
                "content": "If `A.length() != B.length()`: no possible swap\\n\\nIf `A == B`, we need swap two same characters. Check is duplicated char in `A`.\\n\\nIn other cases, we find index for `A[i] != B[i]`. There should be only 2 diffs and it\\'s our one swap.\\n\\n**C++:**\\n```\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) return false;\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) return true;\\n        vector<int> dif;\\n        for (int i = 0; i < A.length(); ++i) if (A[i] != B[i]) dif.push_back(i);\\n        return dif.size() == 2 && A[dif[0]] == B[dif[1]] && A[dif[1]] == B[dif[0]];\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)) {\\n            Set<Character> s = new HashSet<Character>();\\n            for (char c : A.toCharArray()) s.add(c);\\n            return s.size() < A.length();\\n        }\\n        List<Integer> dif = new ArrayList<>();\\n        for (int i = 0; i < A.length(); ++i) if (A.charAt(i) != B.charAt(i)) dif.add(i);\\n        return dif.size() == 2 && A.charAt(dif.get(0)) == B.charAt(dif.get(1)) && A.charAt(dif.get(1)) == B.charAt(dif.get(0));\\n    }\\n```\\n**Python:**\\n```\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        if A == B and len(set(A)) < len(A): return True\\n        dif = [(a, b) for a, b in zip(A, B) if a != b]\\n        return len(dif) == 2 and dif[0] == dif[1][::-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) return false;\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) return true;\\n        vector<int> dif;\\n        for (int i = 0; i < A.length(); ++i) if (A[i] != B[i]) dif.push_back(i);\\n        return dif.size() == 2 && A[dif[0]] == B[dif[1]] && A[dif[1]] == B[dif[0]];\\n    }\\n```\n```\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)) {\\n            Set<Character> s = new HashSet<Character>();\\n            for (char c : A.toCharArray()) s.add(c);\\n            return s.size() < A.length();\\n        }\\n        List<Integer> dif = new ArrayList<>();\\n        for (int i = 0; i < A.length(); ++i) if (A.charAt(i) != B.charAt(i)) dif.add(i);\\n        return dif.size() == 2 && A.charAt(dif.get(0)) == B.charAt(dif.get(1)) && A.charAt(dif.get(1)) == B.charAt(dif.get(0));\\n    }\\n```\n```\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        if A == B and len(set(A)) < len(A): return True\\n        dif = [(a, b) for a, b in zip(A, B) if a != b]\\n        return len(dif) == 2 and dif[0] == dif[1][::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3710426,
                "title": "beat-s-100-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe Intuition is to check if it is possible to swap two characters in string `s` to make it equal to string `goal`. It first handles the case where `s` and `goal` are identical by checking for duplicate characters. If they are not identical, it looks for the first pair of mismatched characters and tries swapping them to achieve equality. The code provides a solution by considering these two scenarios and returns `true` if swapping is successful, otherwise `false`.\\n\\n# Explanation:\\n1. First, it checks if `s` is equal to `goal` using the `==` operator. If they are equal, it means the strings are identical.\\n\\n2. If `s` is equal to `goal`, the code creates a temporary set called `temp` to store the unique characters present in `s`. It does this by converting the string `s` to a set of characters using the `set` constructor.\\n\\n3. The code then returns the result of the comparison `temp.size() < goal.size()`. This comparison checks if the size of the set `temp` (number of unique characters in `s`) is less than the size of the string `goal`. If it is, it means there are duplicate characters in `s`, and swapping any two of them would result in `s` becoming equal to `goal`. In this case, the function returns `true`; otherwise, it returns `false`.\\n\\n4. If `s` is not equal to `goal`, the code proceeds to find the indices `i` and `j` such that `s[i]` and `goal[i]` are the first pair of characters that are different from each other when scanning from the left, and `s[j]` and `goal[j]` are the first pair of characters that are different from each other when scanning from the right.\\n5. The code uses a `while` loop to increment the `i` index from left to right until it finds a mismatch between `s[i]` and `goal[i]`. Similarly, it uses another `while` loop to decrement the `j` index from right to left until it finds a mismatch between `s[j]` and `goal[j]`.\\n6. After finding the mismatched indices, the code checks if `i` is less than `j`. If it is, it means there is a pair of characters that can be swapped to make `s` equal to `goal`. In this case, the code uses the `swap` function to swap the characters `s[i]` and `s[j]`.\\n\\n7. Finally, the code checks if `s` is equal to `goal` after the potential swap. If they are equal, it means we have successfully swapped two characters to make `s` equal to `goal`, and the function returns `true`. Otherwise, it returns `false`.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.length();\\n        \\n        if(goal.length() != n){\\n            return false;\\n        }\\n\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n\\n        int n = s.length();\\n        if (s.equals(goal)) {\\n            Set<Character> temp = new HashSet<>();\\n            for (char c : s.toCharArray()) {\\n                temp.add(c);\\n            }\\n            return temp.size() < goal.length(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while (i < j && s.charAt(i) == goal.charAt(i)) {\\n            i++;\\n        }\\n\\n        while (j >= 0 && s.charAt(j) == goal.charAt(j)) {\\n            j--;\\n        }\\n\\n        if (i < j) {\\n            char[] sArr = s.toCharArray();\\n            char temp = sArr[i];\\n            sArr[i] = sArr[j];\\n            sArr[j] = temp;\\n            s = new String(sArr);\\n        }\\n\\n        return s.equals(goal);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        n = len(s)\\n\\n        if len(goal) != n:\\n            return False;\\n\\n        if s == goal:\\n            temp = set(s)\\n            return len(temp) < len(goal)  # Swapping same characters\\n\\n        i = 0\\n        j = n - 1\\n\\n        while i < j and s[i] == goal[i]:\\n            i += 1\\n\\n        while j >= 0 and s[j] == goal[j]:\\n            j -= 1\\n\\n        if i < j:\\n            s_list = list(s)\\n            s_list[i], s_list[j] = s_list[j], s_list[i]\\n            s = \\'\\'.join(s_list)\\n\\n        return s == goal\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/afc18472-664c-4d6e-8370-25d5a4565caf_1688345134.3503385.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.length();\\n        \\n        if(goal.length() != n){\\n            return false;\\n        }\\n\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n\\n        int n = s.length();\\n        if (s.equals(goal)) {\\n            Set<Character> temp = new HashSet<>();\\n            for (char c : s.toCharArray()) {\\n                temp.add(c);\\n            }\\n            return temp.size() < goal.length(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while (i < j && s.charAt(i) == goal.charAt(i)) {\\n            i++;\\n        }\\n\\n        while (j >= 0 && s.charAt(j) == goal.charAt(j)) {\\n            j--;\\n        }\\n\\n        if (i < j) {\\n            char[] sArr = s.toCharArray();\\n            char temp = sArr[i];\\n            sArr[i] = sArr[j];\\n            sArr[j] = temp;\\n            s = new String(sArr);\\n        }\\n\\n        return s.equals(goal);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        n = len(s)\\n\\n        if len(goal) != n:\\n            return False;\\n\\n        if s == goal:\\n            temp = set(s)\\n            return len(temp) < len(goal)  # Swapping same characters\\n\\n        i = 0\\n        j = n - 1\\n\\n        while i < j and s[i] == goal[i]:\\n            i += 1\\n\\n        while j >= 0 and s[j] == goal[j]:\\n            j -= 1\\n\\n        if i < j:\\n            s_list = list(s)\\n            s_list[i], s_list[j] = s_list[j], s_list[i]\\n            s = \\'\\'.join(s_list)\\n\\n        return s == goal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891469,
                "title": "c-java-python-one-pass-clean-concise-o-n",
                "content": "**Idea**\\n- Using 2 indices `diff1`, `diff2` to store up to 2 different places between string `A` and string `B`.\\n- If there are more than 2 different places -> Invalid.\\n- If there are 2 different places -> Compare A[diff1] vs B[diff2] and A[diff2] vs B[diff1].\\n- If there is only 1 different places -> Invalid.\\n- If no difference between A and B then check if `A` contains at least 1 duplicate letters so that we can swap them.\\n\\t- Example 1: `A = \"ab\"`, `B = \"ab\"`\\n\\t- Example 2: `A = \"aab\"`, `B = \"aab\"`, \\n\\n<iframe src=\"https://leetcode.com/playground/QSYJiwkN/shared\" frameBorder=\"0\" width=\"100%\" height=\"460\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`\\n- Space: `O(26)`, `A_letters` stores up to 26 characters\\n\\nIf you like this solution, I\\'m happy if you give this post a **vote**.\\nHappy coding!",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "**Idea**\\n- Using 2 indices `diff1`, `diff2` to store up to 2 different places between string `A` and string `B`.\\n- If there are more than 2 different places -> Invalid.\\n- If there are 2 different places -> Compare A[diff1] vs B[diff2] and A[diff2] vs B[diff1].\\n- If there is only 1 different places -> Invalid.\\n- If no difference between A and B then check if `A` contains at least 1 duplicate letters so that we can swap them.\\n\\t- Example 1: `A = \"ab\"`, `B = \"ab\"`\\n\\t- Example 2: `A = \"aab\"`, `B = \"aab\"`, \\n\\n<iframe src=\"https://leetcode.com/playground/QSYJiwkN/shared\" frameBorder=\"0\" width=\"100%\" height=\"460\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`\\n- Space: `O(26)`, `A_letters` stores up to 26 characters\\n\\nIf you like this solution, I\\'m happy if you give this post a **vote**.\\nHappy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 891275,
                "title": "python-best-simple-and-clean-explained-solution-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # check same length\\n        if len(A) != len(B): return False\\n        \\n        # if strings are equal - check if there is a double to swap\\n        if A == B:\\n            return True if len(A) - len(set(A)) >= 1 else False\\n        \\n        # count differences between strings\\n        diff = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diff.append(i)\\n                if len(diff) > 2: return False\\n                \\n        # not exactly two differences\\n        if len(diff) != 2: return False\\n        \\n        # check if can be swapped\\n        if A[diff[0]] == B[diff[1]] and A[diff[1]] == B[diff[0]]:\\n            return True\\n        \\n        return False\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # check same length\\n        if len(A) != len(B): return False\\n        \\n        # if strings are equal - check if there is a double to swap\\n        if A == B:\\n            return True if len(A) - len(set(A)) >= 1 else False\\n        \\n        # count differences between strings\\n        diff = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diff.append(i)\\n                if len(diff) > 2: return False\\n                \\n        # not exactly two differences\\n        if len(diff) != 2: return False\\n        \\n        # check if can be swapped\\n        if A[diff[0]] == B[diff[1]] and A[diff[1]] == B[diff[0]]:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142647,
                "title": "clear-c-solution",
                "content": "```\\n    bool buddyStrings(string A, string B) {\\n        // Same length\\n        int len_A = A.size(), len_B = B.size();\\n        if (len_A != len_B) return false;\\n        \\n        // Repeat: same string, A needs repeated char, like \"aab\" \"aab\"\\n        int numChar_A = unordered_set<char>(A.begin(), A.end()).size();\\n        if (A == B && numChar_A < len_B) return true;\\n        \\n        // Swap: There should be only two to change\\n        vector<int> index_diff;\\n                        \\n        for (int i = 0; i < len_A; i++) {\\n          if (A[i] != B[i]) index_diff.push_back(i);\\n          if (index_diff.size() > 2) return false;\\n        } \\n        \\n        return index_diff.size() == 2 &&\\n               A[index_diff[0]] == B[index_diff[1]] &&\\n               A[index_diff[1]] == B[index_diff[0]];        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool buddyStrings(string A, string B) {\\n        // Same length\\n        int len_A = A.size(), len_B = B.size();\\n        if (len_A != len_B) return false;\\n        \\n        // Repeat: same string, A needs repeated char, like \"aab\" \"aab\"\\n        int numChar_A = unordered_set<char>(A.begin(), A.end()).size();\\n        if (A == B && numChar_A < len_B) return true;\\n        \\n        // Swap: There should be only two to change\\n        vector<int> index_diff;\\n                        \\n        for (int i = 0; i < len_A; i++) {\\n          if (A[i] != B[i]) index_diff.push_back(i);\\n          if (index_diff.size() > 2) return false;\\n        } \\n        \\n        return index_diff.size() == 2 &&\\n               A[index_diff[0]] == B[index_diff[1]] &&\\n               A[index_diff[1]] == B[index_diff[0]];        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171410,
                "title": "python-simple-and-intuitive",
                "content": "1. if length differs or set of characters differ, return False directly\\n2. if A and B are equal, returns if we have at least 1 repetitive character in the list\\n3.  if two list have more than 2 indices with different characters, return false\\n4.  In the end check if the swap can happen\\n```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B) or set(A) != set(B): return False       \\n        if A == B:\\n            return len(A) - len(set(A)) >= 1\\n        else:     \\n            indices = []\\n            counter = 0\\n            for i in range(len(A)):\\n                if A[i] != B[i]:\\n                    counter += 1\\n                    indices.append(i)       \\n                if counter > 2:\\n                    return False       \\n            return A[indices[0]] == B[indices[1]] and A[indices[1]] == B[indices[0]]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B) or set(A) != set(B): return False       \\n        if A == B:\\n            return len(A) - len(set(A)) >= 1\\n        else:     \\n            indices = []\\n            counter = 0\\n            for i in range(len(A)):\\n                if A[i] != B[i]:\\n                    counter += 1\\n                    indices.append(i)       \\n                if counter > 2:\\n                    return False       \\n            return A[indices[0]] == B[indices[1]] and A[indices[1]] == B[indices[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141794,
                "title": "java-o-1-space-o-n-time",
                "content": "```\\npublic boolean buddyStrings(String A, String B) {\\n    if (A == null || B == null || A.length() != B.length())  return false;\\n    int a = -1, b = -1, diff = 0;\\n    int[] count = new int[26];\\n    // check if able to switch with the same character.\\n    boolean canSwitch = false;\\n    for (int i = 0; i < A.length(); i++) {\\n      if (++count[A.charAt(i) - \\'a\\'] >= 2)  canSwitch = true;\\n      if (A.charAt(i) != B.charAt(i)) {\\n        diff++;\\n        if (a == -1)  a = i;\\n        else if (b == -1)  b = i;\\n      }\\n    }\\n    return (diff == 0 && canSwitch) || (diff == 2 && A.charAt(a) == B.charAt(b) && A.charAt(b) == B.charAt(a));\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean buddyStrings(String A, String B) {\\n    if (A == null || B == null || A.length() != B.length())  return false;\\n    int a = -1, b = -1, diff = 0;\\n    int[] count = new int[26];\\n    // check if able to switch with the same character.\\n    boolean canSwitch = false;\\n    for (int i = 0; i < A.length(); i++) {\\n      if (++count[A.charAt(i) - \\'a\\'] >= 2)  canSwitch = true;\\n      if (A.charAt(i) != B.charAt(i)) {\\n        diff++;\\n        if (a == -1)  a = i;\\n        else if (b == -1)  b = i;\\n      }\\n    }\\n    return (diff == 0 && canSwitch) || (diff == 2 && A.charAt(a) == B.charAt(b) && A.charAt(b) == B.charAt(a));\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710591,
                "title": "easy-code-100-fast-strings-explanation-in-video-c-java-python",
                "content": "For detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtube.com/@LetsCodeTogether72?sub_confirmation=1\\n or link in comment.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Buddy Strings` on youtube\\n\\n#  C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int ns=s.size(),ng=goal.size();\\n        if(ns != ng ) {\\n            return 0;\\n        }\\n        if(s == goal ) {\\n            vector<int>farr(26,0);\\n            for(auto &x:s){\\n                farr[x-\\'a\\']++;\\n                if(farr[x-\\'a\\']==2)\\n                return true;\\n            }\\n            return false;;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<ns;i++)\\n        {\\n            if(s[i] != goal[i]) {\\n                ans.push_back(i);\\n            }\\n            if(ans.size()>2)\\n            return false;\\n        }\\n        \\n        return  ans.size()==2&&s[ans[0]]==goal[ans[1]] && s[ans[1]]==goal[ans[0]];\\n    }\\n};\\n```\\n#  Java Code\\n```\\n\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int ns = s.length();\\n        int ng = goal.length();\\n        \\n        if (ns != ng) {\\n            return false;\\n        }\\n        \\n        if (s.equals(goal)) {\\n            int[] farr = new int[26];\\n            for (char ch : s.toCharArray()) {\\n                farr[ch - \\'a\\']++;\\n                if (farr[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n        //int count = 0;\\n        for (int i = 0; i < ns; i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n               ans.add(i);\\n                if (ans.size()> 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return ans.size() == 2 && s.charAt(ans.get(0)) == goal.charAt(ans.get(1)) && s.charAt(ans.get(1)) == goal.charAt(ans.get(0));\\n    }\\n}\\n```\\n#  Python3 Code\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        ns = len(s)\\n        ng = len(goal)\\n\\n        if ns != ng:\\n            return False\\n\\n        if s == goal:\\n            farr = [0] * 26\\n            for ch in s:\\n                farr[ord(ch) - ord(\\'a\\')] += 1\\n            \\n            for count in farr:\\n                if count > 1:\\n                    return True\\n            \\n            return False\\n\\n        ans = []\\n        for i in range(ns):\\n            if s[i] != goal[i]:\\n                ans.append(i)\\n                if len(ans) > 2:\\n                    return False\\n\\n        return len(ans) == 2 and s[ans[0]] == goal[ans[1]] and s[ans[1]] == goal[ans[0]]\\n\\n````\\n# please upvote if u like this",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int ns=s.size(),ng=goal.size();\\n        if(ns != ng ) {\\n            return 0;\\n        }\\n        if(s == goal ) {\\n            vector<int>farr(26,0);\\n            for(auto &x:s){\\n                farr[x-\\'a\\']++;\\n                if(farr[x-\\'a\\']==2)\\n                return true;\\n            }\\n            return false;;\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<ns;i++)\\n        {\\n            if(s[i] != goal[i]) {\\n                ans.push_back(i);\\n            }\\n            if(ans.size()>2)\\n            return false;\\n        }\\n        \\n        return  ans.size()==2&&s[ans[0]]==goal[ans[1]] && s[ans[1]]==goal[ans[0]];\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int ns = s.length();\\n        int ng = goal.length();\\n        \\n        if (ns != ng) {\\n            return false;\\n        }\\n        \\n        if (s.equals(goal)) {\\n            int[] farr = new int[26];\\n            for (char ch : s.toCharArray()) {\\n                farr[ch - \\'a\\']++;\\n                if (farr[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        ArrayList<Integer>ans=new ArrayList<>();\\n        //int count = 0;\\n        for (int i = 0; i < ns; i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n               ans.add(i);\\n                if (ans.size()> 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return ans.size() == 2 && s.charAt(ans.get(0)) == goal.charAt(ans.get(1)) && s.charAt(ans.get(1)) == goal.charAt(ans.get(0));\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        ns = len(s)\\n        ng = len(goal)\\n\\n        if ns != ng:\\n            return False\\n\\n        if s == goal:\\n            farr = [0] * 26\\n            for ch in s:\\n                farr[ord(ch) - ord(\\'a\\')] += 1\\n            \\n            for count in farr:\\n                if count > 1:\\n                    return True\\n            \\n            return False\\n\\n        ans = []\\n        for i in range(ns):\\n            if s[i] != goal[i]:\\n                ans.append(i)\\n                if len(ans) > 2:\\n                    return False\\n\\n        return len(ans) == 2 and s[ans[0]] == goal[ans[1]] and s[ans[1]] == goal[ans[0]]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891021,
                "title": "python-o-n-solution-explained",
                "content": "Let us carefully cover all possible cases in this problem:\\n1. If lengths of strings are different, we immedietly return `False`.\\n2. If counters of strings are different, we also return `False`.\\n3. Let us also evaluate for each place if symbols in `A` and `B` are equal. We can afford to have only `2` symbols which are not equal or `0`: in first case we change two different symbols and in second two equal. So, if number of not equal symbols is not `0` or `2`, we return `False`.\\n4. Also, if we have number `diff_places == 0`, it means that we changed two equal symbols. We can not do it if all string has different symbols, like `abtlpe`, so we return `False` in this case.\\n5. If we have `diff_places == 2`, it means that we changed two different symbols. We can not do it if string is just one symbols repeated, like `ddddddd`, so we return `False` in this case.\\n6. Finally, if we did not return anything yet, we return `True`.\\n\\n**Complexity** is `O(n)`, because we use counters, which is linear and number of not equal symbols which is linear as well.\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        Count_A, Count_B = Counter(A), Counter(B)\\n        if Count_A != Count_B: return False\\n        diff_places = sum([i!=j for i,j in zip(A,B)])\\n        if diff_places not in [0, 2]: return False\\n        if diff_places == 0 and len(Count_A) == len(A): return False\\n        if diff_places == 2 and len(Count_A) == 1: return False\\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B): return False\\n        Count_A, Count_B = Counter(A), Counter(B)\\n        if Count_A != Count_B: return False\\n        diff_places = sum([i!=j for i,j in zip(A,B)])\\n        if diff_places not in [0, 2]: return False\\n        if diff_places == 0 and len(Count_A) == len(A): return False\\n        if diff_places == 2 and len(Count_A) == 1: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786309,
                "title": "javascript-clean-and-intuitive-solution",
                "content": "```javascript\\nvar buddyStrings = function(A, B) {\\n    if(A.length != B.length) return false;\\n    const diff = [];\\n    \\n    for(let i = 0; i < A.length; i++) {\\n        if(A[i] != B[i]) diff.push(i);\\n        if(diff.length > 2) return false;\\n    }\\n    if(!diff.length) return A.length != [...new Set(A)].length;\\n    const [i, j] = diff; \\n    return A[i] == B[j] && B[i] == A[j];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar buddyStrings = function(A, B) {\\n    if(A.length != B.length) return false;\\n    const diff = [];\\n    \\n    for(let i = 0; i < A.length; i++) {\\n        if(A[i] != B[i]) diff.push(i);\\n        if(diff.length > 2) return false;\\n    }\\n    if(!diff.length) return A.length != [...new Set(A)].length;\\n    const [i, j] = diff; \\n    return A[i] == B[j] && B[i] == A[j];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405603,
                "title": "python-clear-8-lines-easy-understand",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        A = list(A)\\n        B = list(B)\\n        if len(A)!=len(B): return False\\n        C = [i for i in range(len(A)) if A[i] != B[i]]\\n        if len(C)==2 and A[C[0]]==B[C[1]] and A[C[1]]==B[C[0]]: return True\\n        if not C:\\n            if len(A)>len(set(A)): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        A = list(A)\\n        B = list(B)\\n        if len(A)!=len(B): return False\\n        C = [i for i in range(len(A)) if A[i] != B[i]]\\n        if len(C)==2 and A[C[0]]==B[C[1]] and A[C[1]]==B[C[0]]: return True\\n        if not C:\\n            if len(A)>len(set(A)): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711198,
                "title": "c-easy-explanation-self-explanatory-code-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the code is as follows:\\n\\n1. First, the code checks if the lengths of the two input strings, `s` and `goal`, are not equal or if the length of `s` is less than or equal to 1. If either of these conditions is true, the function returns `false`. This is because for the two strings to be buddy strings, they must have the same length and contain at least two differing characters.\\n\\n2. Next, the code checks if `s` and `goal` are identical. If they are, it means that all characters are the same. In this case, the code creates an set, `distinctChars`, to store the distinct characters from `s`. If the size of `distinctChars` is less than the length of `s`, it means there are duplicate characters, and we can swap two of them to make `s` and `goal` equal. The function returns `true` in this case.\\n\\n3. If the previous conditions are not met, it means that `s` and `goal` are different strings, and we need to check if they can be made equal by swapping exactly two characters.\\n\\n4. The code iterates through each character of `s` and `goal` simultaneously, comparing the characters at each index. Whenever a pair of characters at the same index is different, the index is added to the `index` vector.\\n\\n5. After iterating through both strings, the code checks if the size of `index` is exactly 2. If it\\'s not, it means there are either more or fewer than two differing characters, and the strings cannot be made equal by swapping two characters. In this case, the function returns `false`.\\n\\n6. If there are exactly two differing characters, the code proceeds to swap these characters in `s` by using the indices stored in the `index` vector.\\n\\n7. Finally, the code checks if `s` is now equal to `goal` after the swap. If they are equal, it means that `s` and `goal` can be made equal by swapping two characters, and the function returns `true`. Otherwise, it means the swap did not result in `s` becoming equal to `goal`, and the function returns `false`.\\n\\n\\n# Complexity\\n- Time complexity:    $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445324,
                "title": "c-using-two-pointers-and-set",
                "content": "If the strings are initially equal, just check whether A contains some duplicate letters you can swap to meet the one-swap condition. \\n\\nFor ex., for A= \"aba\" and B=\"aba\" two \"a\"s in A are swappable to leave A equal to B. \\nIn the same manner equal A=\"ab\" and B=\"ab\" strings will fail to meet the condition as A contains only non-duplicate letters, thus making one-swap impossible.\\n \\n The other case is when A != B. In such case look for one-swap possibility running two pointers from two ends. \\n If the swap was done check whether A became equal to B now.\\n \\n```\\nbool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 320883,
                "title": "javascript-solution",
                "content": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    \\n    if (A == B) {\\n        let s = new Set();\\n        \\n        for (let i = 0; i < A.length; i++) {\\n            s.add(A.charAt(i));\\n        }\\n        \\n        return s.size < A.length;\\n    }\\n    \\n    let diff = [];\\n    for (let i = 0; i < A.length; i++) {\\n        if (A.charAt(i) != B.charAt(i)) {\\n            diff.push(i);\\n        }\\n    }\\n    \\n    return diff.length == 2 && A.charAt(diff[0]) == B.charAt(diff[1]) && A.charAt(diff[1]) == B.charAt(diff[0]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    \\n    if (A == B) {\\n        let s = new Set();\\n        \\n        for (let i = 0; i < A.length; i++) {\\n            s.add(A.charAt(i));\\n        }\\n        \\n        return s.size < A.length;\\n    }\\n    \\n    let diff = [];\\n    for (let i = 0; i < A.length; i++) {\\n        if (A.charAt(i) != B.charAt(i)) {\\n            diff.push(i);\\n        }\\n    }\\n    \\n    return diff.length == 2 && A.charAt(diff[0]) == B.charAt(diff[1]) && A.charAt(diff[1]) == B.charAt(diff[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728856,
                "title": "set-two-pointer-easy-100-faster-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n         if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size());\\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n         if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size());\\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711923,
                "title": "o-n-easy-python-soln-with-steps",
                "content": "# Complexity\\n- Time complexity: O(n) time, as it iterates through the characters of both strings once.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        # Step 1: Check if the lengths of s and goal are different\\n        if len(s) != len(goal):\\n            return False\\n        \\n        # Step 2: Check if s and goal are exactly the same\\n        # and there are duplicate characters in s\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        \\n        # Step 3: Find the pairs of different characters in s and goal\\n        diffs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        \\n        # Step 4: Check if there are exactly two different pairs of characters\\n        # and the first pair can be transformed into the second pair by flipping it\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        # Step 1: Check if the lengths of s and goal are different\\n        if len(s) != len(goal):\\n            return False\\n        \\n        # Step 2: Check if s and goal are exactly the same\\n        # and there are duplicate characters in s\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        \\n        # Step 3: Find the pairs of different characters in s and goal\\n        diffs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        \\n        # Step 4: Check if there are exactly two different pairs of characters\\n        # and the first pair can be transformed into the second pair by flipping it\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711866,
                "title": "easiest-c-code-explained-in-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int i,j,k,c=0,a=0;\\n        unordered_map<char,int>map;\\n        for(auto x:s)\\n        map[x]++;\\n\\n        if(map.size()<s.size())\\n        a=1;\\n\\n        for(auto x:goal){                    //comparing that both strings have same number of alphabets\\n            if(map.find(x)==map.end())        //if different alphabets \\n            return 0;                            //return 0;\\n            if(map[x]==1)\\n            map.erase(x);                       //else erase from map\\n            else\\n            map[x]--;\\n        }\\n\\n        if(map.size()>0)                        //if map not empty return 0\\n        return 0;\\n\\n        for(i=0;i<s.size();i++){                  //comparing alphabets at all indexes\\n            if(s[i]!=goal[i])\\n            c++;\\n        }\\n\\n    if(c==2)                                     //if c==2 only 2 alphabets are displaced return 1;\\n    return 1;\\n    if(a==1 and c==0)                            //if any 2 characters are repeating then if c==0 return 1;\\n    return 1;                               //return 0\\n    \\n    return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int i,j,k,c=0,a=0;\\n        unordered_map<char,int>map;\\n        for(auto x:s)\\n        map[x]++;\\n\\n        if(map.size()<s.size())\\n        a=1;\\n\\n        for(auto x:goal){                    //comparing that both strings have same number of alphabets\\n            if(map.find(x)==map.end())        //if different alphabets \\n            return 0;                            //return 0;\\n            if(map[x]==1)\\n            map.erase(x);                       //else erase from map\\n            else\\n            map[x]--;\\n        }\\n\\n        if(map.size()>0)                        //if map not empty return 0\\n        return 0;\\n\\n        for(i=0;i<s.size();i++){                  //comparing alphabets at all indexes\\n            if(s[i]!=goal[i])\\n            c++;\\n        }\\n\\n    if(c==2)                                     //if c==2 only 2 alphabets are displaced return 1;\\n    return 1;\\n    if(a==1 and c==0)                            //if any 2 characters are repeating then if c==0 return 1;\\n    return 1;                               //return 0\\n    \\n    return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274825,
                "title": "python-o-n-simple",
                "content": "More concise\\n\\n```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = [i for i in range(len(A)) if A[i] != B[i]]\\n        \\n        return len(A) == len(B) and len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```\\n\\nLess concise but slightly more efficient (breaks early in for loop).\\n\\n```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if len(A) != len(B):\\n            return False\\n        \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diffs.append(i)\\n                if len(diffs) > 2:\\n                    return False\\n                \\n        return len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = [i for i in range(len(A)) if A[i] != B[i]]\\n        \\n        return len(A) == len(B) and len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```\n```python\\ndef buddyStrings(self, A: str, B: str) -> bool:                \\n        if len(A) != len(B):\\n            return False\\n        \\n        if A == B and len(A) != len(set(A)):\\n            return True\\n        \\n        diffs = []\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                diffs.append(i)\\n                if len(diffs) > 2:\\n                    return False\\n                \\n        return len(diffs) == 2 and A[diffs[0]] == B[diffs[1]] and A[diffs[1]] == B[diffs[0]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1081402,
                "title": "java-solution-with-set",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)){\\n            Set<Character> set = new HashSet<>();\\n            for (char c : A.toCharArray())\\n                set.add(c);\\n            return set.size() < A.length();\\n        }\\n        else{\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0;i<A.length();i++)\\n                if (A.charAt(i) != B.charAt(i)) list.add(i);\\n            return list.size() == 2 && A.charAt(list.get(0)) == B.charAt(list.get(1)) && B.charAt(list.get(0)) == A.charAt(list.get(1));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        if (A.equals(B)){\\n            Set<Character> set = new HashSet<>();\\n            for (char c : A.toCharArray())\\n                set.add(c);\\n            return set.size() < A.length();\\n        }\\n        else{\\n            List<Integer> list = new ArrayList<>();\\n            for (int i = 0;i<A.length();i++)\\n                if (A.charAt(i) != B.charAt(i)) list.add(i);\\n            return list.size() == 2 && A.charAt(list.get(0)) == B.charAt(list.get(1)) && B.charAt(list.get(0)) == A.charAt(list.get(1));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402286,
                "title": "java-1-ms-beats-97-8",
                "content": "```\\nclass Solution {    \\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())\\n            return false;\\n\\n        if (A.equals(B)) {\\n            Set set = new HashSet();\\n            for (int i = 0; i < A.length(); i++) {\\n                if (set.contains(A.charAt(i)))\\n                    return true;\\n                else set.add(A.charAt(i));\\n            }\\n            return false;\\n        }\\n\\n        int counter = 0;\\n        int aChars = 0;\\n        int bChars = 0;\\n        for (int i = 0; i < A.length(); i++) {\\n            aChars += A.charAt(i);\\n            bChars += B.charAt(i);\\n            if (A.charAt(i) != B.charAt(i))\\n                counter++;\\n            if (counter > 2)\\n                return false;\\n        }\\n        return counter <= 2 && aChars == bChars;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {    \\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())\\n            return false;\\n\\n        if (A.equals(B)) {\\n            Set set = new HashSet();\\n            for (int i = 0; i < A.length(); i++) {\\n                if (set.contains(A.charAt(i)))\\n                    return true;\\n                else set.add(A.charAt(i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3713315,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())\\n        {\\n            return false;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)!=goal.charAt(i))\\n            {\\n                count++;\\n            }\\n        }\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        for(char c:goal.toCharArray())\\n        {\\n            b[c-\\'a\\']++;\\n        }\\n        if(count>2)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        if(count==2)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]>=2)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())\\n        {\\n            return false;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)!=goal.charAt(i))\\n            {\\n                count++;\\n            }\\n        }\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        for(char c:goal.toCharArray())\\n        {\\n            b[c-\\'a\\']++;\\n        }\\n        if(count>2)\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                return false;\\n            }\\n        }\\n        if(count==2)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]>=2)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710555,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pL902JiXA6E\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\nThe key idea in any String problem is to come up with many examples before hand and draw the observations.\\n\\ns = abcde g = adbce\\ns = adcbe g = abxde\\ns = abcd g = abcd\\ns = aabc g = aabc\\ns = abc g = ab\\ns = abcd g = abed\\n\\nOnce we understand the above examples, the implementation is quite straight forward.\\n\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        if(s.equals(goal)){\\n            int [] count = new int[26];\\n            int c;\\n            for(int i = 0;i<s.length();i++){\\n                c = s.charAt(i)-\\'a\\';\\n                count[c]++;\\n                if(count[c]==2)return true;\\n            }\\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) != goal.charAt(i)){\\n                if(index1 == -1) index1 = i;\\n                else if(index2 == -1) index2 = i;\\n                else return false;\\n            }\\n        }\\n        if(index2==-1) return false;\\n        return (s.charAt(index1) == goal.charAt(index2) && s.charAt(index2) == goal.charAt(index1));\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n        \\n        if (s == goal) {\\n            vector<int> count(26, 0);\\n            \\n            for (int i = 0; i < s.length(); i++) {\\n                int c = s[i] - \\'a\\';\\n                count[c]++;\\n                if (count[c] == 2)\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != goal[i]) {\\n                if (index1 == -1)\\n                    index1 = i;\\n                else if (index2 == -1)\\n                    index2 = i;\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if (index2 == -1)\\n            return false;\\n        \\n        return (s[index1] == goal[index2] && s[index2] == goal[index1]);\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n\\n        if s == goal:\\n            count = [0] * 26\\n\\n            for i in range(len(s)):\\n                c = ord(s[i]) - ord(\\'a\\')\\n                count[c] += 1\\n                if count[c] == 2:\\n                    return True\\n\\n            return False\\n\\n        index1 = -1\\n        index2 = -1\\n\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if index1 == -1:\\n                    index1 = i\\n                elif index2 == -1:\\n                    index2 = i\\n                else:\\n                    return False\\n\\n        if index2 == -1:\\n            return False\\n\\n        return s[index1] == goal[index2] and s[index2] == goal[index1]\\n        \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        if(s.equals(goal)){\\n            int [] count = new int[26];\\n            int c;\\n            for(int i = 0;i<s.length();i++){\\n                c = s.charAt(i)-\\'a\\';\\n                count[c]++;\\n                if(count[c]==2)return true;\\n            }\\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) != goal.charAt(i)){\\n                if(index1 == -1) index1 = i;\\n                else if(index2 == -1) index2 = i;\\n                else return false;\\n            }\\n        }\\n        if(index2==-1) return false;\\n        return (s.charAt(index1) == goal.charAt(index2) && s.charAt(index2) == goal.charAt(index1));\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n        \\n        if (s == goal) {\\n            vector<int> count(26, 0);\\n            \\n            for (int i = 0; i < s.length(); i++) {\\n                int c = s[i] - \\'a\\';\\n                count[c]++;\\n                if (count[c] == 2)\\n                    return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        int index1 = -1;\\n        int index2 = -1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != goal[i]) {\\n                if (index1 == -1)\\n                    index1 = i;\\n                else if (index2 == -1)\\n                    index2 = i;\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        if (index2 == -1)\\n            return false;\\n        \\n        return (s[index1] == goal[index2] && s[index2] == goal[index1]);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n\\n        if s == goal:\\n            count = [0] * 26\\n\\n            for i in range(len(s)):\\n                c = ord(s[i]) - ord(\\'a\\')\\n                count[c] += 1\\n                if count[c] == 2:\\n                    return True\\n\\n            return False\\n\\n        index1 = -1\\n        index2 = -1\\n\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if index1 == -1:\\n                    index1 = i\\n                elif index2 == -1:\\n                    index2 = i\\n                else:\\n                    return False\\n\\n        if index2 == -1:\\n            return False\\n\\n        return s[index1] == goal[index2] and s[index2] == goal[index1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 891255,
                "title": "c-best-simple-and-clear-explained-solution-o-n-o-1-faster-than-98",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712600,
                "title": "python-3-solution-with-explanation-time-complexity-o-n",
                "content": "# Algorithm :\\n* if len(s) != len(goal) then return false\\n* if s and g are equal then:\\n    * If we have 2 same characters in string \\'s\\', we can swap them and still the strings will remain equal.\\n    * Otherwise, if we swap any two characters, it will make the strings unequal.\\n* Lastly we will iterate and check for 2 indexes in string s :\\n    * if we have at least 3 indices with different characters then, we can never make the strings equal with only one swap.\\n    * Also we can\\'t swap if the character at only one index is different.\\n    * We can only return true when all characters of both strings are the same except two indices.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Video Explanation\\nhttps://youtu.be/t6Y8xY95gL4\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal :\\n            frequency = [0]*26\\n            for ch in s:\\n                frequency[ord(ch)-ord(\\'a\\')] += 1\\n                if frequency[ord(ch)-ord(\\'a\\')] == 2:\\n                    return True\\n            return False\\n        first_index = -1\\n        second_index = -1\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if first_index == -1:\\n                    first_index = i\\n                elif second_index == -1:\\n                    second_index = i\\n                else:\\n                    return False\\n        if second_index == -1:\\n            return False\\n        return s[first_index]==goal[second_index] and s[second_index] == goal[first_index]\\n```\\n#### Upvote if find this solution useful \\uD83D\\uDE01\\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal :\\n            frequency = [0]*26\\n            for ch in s:\\n                frequency[ord(ch)-ord(\\'a\\')] += 1\\n                if frequency[ord(ch)-ord(\\'a\\')] == 2:\\n                    return True\\n            return False\\n        first_index = -1\\n        second_index = -1\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                if first_index == -1:\\n                    first_index = i\\n                elif second_index == -1:\\n                    second_index = i\\n                else:\\n                    return False\\n        if second_index == -1:\\n            return False\\n        return s[first_index]==goal[second_index] and s[second_index] == goal[first_index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661091,
                "title": "python-3-one-pass-solution",
                "content": "The code almost the same in both cases, **but**:\\nIn **1** variant logic for finding duplicate called at the end of execution, if the edge-case is happened.\\nIt\\'s also possible to use concise variant for checking duplicates like: ```len(s) == set(s)```, but it\\'s less optimal.\\nIn **2** variant duplicate value is searching in the first iteration, but not always will be used.\\n\\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx = 2, None\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def isDuplicate():\\n            # len(s) == set(s)\\n            seen = set()\\n            for c in s:\\n                if c in seen: return True\\n                seen.add(c)\\n            return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDuplicate())\\n```\\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx, isDup, seen = 2, None, False, set()\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def searchDuplicate(a):\\n            nonlocal isDup\\n            if isDup is False:\\n                if a not in seen:\\n                    seen.add(a)\\n                else:\\n                    isDup = True\\n                    seen.clear()\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            searchDuplicate(a)\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDup)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```len(s) == set(s)```\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx = 2, None\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def isDuplicate():\\n            # len(s) == set(s)\\n            seen = set()\\n            for c in s:\\n                if c in seen: return True\\n                seen.add(c)\\n            return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDuplicate())\\n```\n```python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        # swapStage: 2 - not swapped, 1 - ready to swap, 0 - swapped\\n        swapStage, swapIdx, isDup, seen = 2, None, False, set()\\n        \\n        # need find any duplicate for case if all symbols are equal for two strings\\n        def searchDuplicate(a):\\n            nonlocal isDup\\n            if isDup is False:\\n                if a not in seen:\\n                    seen.add(a)\\n                else:\\n                    isDup = True\\n                    seen.clear()\\n        \\n        for i, (a, b) in enumerate(zip(s, goal)):\\n            searchDuplicate(a)\\n            if a != b:\\n                if swapStage == 2:\\n                    swapIdx, swapStage = i, 1\\n                elif swapStage == 1:\\n                    if a != goal[swapIdx] or b != s[swapIdx]: return False\\n                    swapStage = 0\\n                else: return False\\n\\n        return swapStage == 0 or (swapStage == 2 and isDup)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891209,
                "title": "python-solution-explained-beats-98-video-code",
                "content": "[](https://www.youtube.com/watch?v=5DNijHoMjzg)\\nhttps://www.youtube.com/watch?v=5DNijHoMjzg\\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # goal: make one swap to A sp that A == B\\n        \\n        # length\\n        if len(A) != len(B):\\n            return False\\n        \\n        # A == B condition\\n        if A == B and len(set(A)) < len(A):\\n            return True\\n        \\n        # The length is same so now we check weather or not we can reach B by making a single swap\\n        differences = []\\n        for x in range(len(B)):\\n            if A[x] != B[x]:\\n                differences.append([A[x], B[x]])\\n\\n        if len(differences) == 2 and differences[0] == differences[-1][::-1]:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        # goal: make one swap to A sp that A == B\\n        \\n        # length\\n        if len(A) != len(B):\\n            return False\\n        \\n        # A == B condition\\n        if A == B and len(set(A)) < len(A):\\n            return True\\n        \\n        # The length is same so now we check weather or not we can reach B by making a single swap\\n        differences = []\\n        for x in range(len(B)):\\n            if A[x] != B[x]:\\n                differences.append([A[x], B[x]])\\n\\n        if len(differences) == 2 and differences[0] == differences[-1][::-1]:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141838,
                "title": "javascript-straightforward",
                "content": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    let [dif, chars] = [[], new Set(A)];\\n    for (i in A) {\\n        if (A[i] != B[i]) {\\n            dif.push([A[i], B[i]]);\\n        }\\n    }\\n    return dif.length == 2 && dif[0].join() == dif[1].reverse().join() || (dif.length == 0 && chars.size != A.length);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar buddyStrings = function(A, B) {\\n    if (A.length != B.length) {\\n        return false;\\n    }\\n    let [dif, chars] = [[], new Set(A)];\\n    for (i in A) {\\n        if (A[i] != B[i]) {\\n            dif.push([A[i], B[i]]);\\n        }\\n    }\\n    return dif.length == 2 && dif[0].join() == dif[1].reverse().join() || (dif.length == 0 && chars.size != A.length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891362,
                "title": "step-by-step-explanation-of-logic-c-code",
                "content": "Base Cases:\\n* if length of both string is not same-----> return false\\n* if length of strings is less than 2--------> return false\\n\\nBoth strings are same initially\\n* search if any duplicate character present in string\\n\\nBoth strings are different initially\\n* search number of indexes where given strings have different character\\n* if there are two such indexes then check if it is possible that by swapping we make both strings same\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    bool buddyStrings(string A, string B) {\\n        //Base Case\\n        if(A.size()!=B.size())         // if length of both strings are different\\n            return false;\\n        \\n        if(A.size()==0 || A.size()==1) // if length of strings is ess than 2 \\n            return false;\\n        \\n        // If both strings are same already then we search if any duplicate character present in string... \\n        if(A==B)\\n        {\\n            set<char> S(A.begin(),A.end());\\n            if(A.size()!=S.size())\\n                return true;\\n            return false;\\n        }\\n        \\n        //if both strings are not same initially then we search if there are two indexes which can be swapped to make both string same\\n        \\n        int first=-1;\\n        int second=-1;\\n        int diff=0;           //to store number of indexes having different character in given strings\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]!=B[i])\\n            {\\n                diff++;\\n                if(first==-1)\\n                    first=i;\\n                else if(second==-1)\\n                    second=i;\\n                \\n                if(diff>2)\\n                    return false;\\n            }\\n        }\\n        \\n        if(diff==2)             \\n        {\\n            if(A[first]==B[second] && A[second]==B[first])  // possible to make both string same by swap\\n                 return true;\\n        }\\n        return false;\\n    }\\n}; \\n```\\n\\n**If you like the soution , please Upvote...**\\n**Also comment if any modification required in solution.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool buddyStrings(string A, string B) {\\n        //Base Case\\n        if(A.size()!=B.size())         // if length of both strings are different\\n            return false;\\n        \\n        if(A.size()==0 || A.size()==1) // if length of strings is ess than 2 \\n            return false;\\n        \\n        // If both strings are same already then we search if any duplicate character present in string... \\n        if(A==B)\\n        {\\n            set<char> S(A.begin(),A.end());\\n            if(A.size()!=S.size())\\n                return true;\\n            return false;\\n        }\\n        \\n        //if both strings are not same initially then we search if there are two indexes which can be swapped to make both string same\\n        \\n        int first=-1;\\n        int second=-1;\\n        int diff=0;           //to store number of indexes having different character in given strings\\n        for(int i=0;i<A.size();i++)\\n        {\\n            if(A[i]!=B[i])\\n            {\\n                diff++;\\n                if(first==-1)\\n                    first=i;\\n                else if(second==-1)\\n                    second=i;\\n                \\n                if(diff>2)\\n                    return false;\\n            }\\n        }\\n        \\n        if(diff==2)             \\n        {\\n            if(A[first]==B[second] && A[second]==B[first])  // possible to make both string same by swap\\n                 return true;\\n        }\\n        return false;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 141935,
                "title": "very-simple-python-solution-with-detailed-explanation-o-n-time-o-n-space-with-40-ms-runtime",
                "content": "Hey guys, I thought my solution was pretty good so I decided to share it with an explanation of how it works. I numbered each part so it\\'d be easier to follow. When I refer to \"N\", I mean the length of A and B (since they\\'re the same). Please leave any feedback on my code or explanation in the comments!  \\n\\t\\n        # 1\\n        if len(A) != len(B):\\n            return False\\n        \\n        # 2\\n        differences = 0\\n        differentIndices = [-1, -1]\\n        differentIndicesCur = 0\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                differentIndices[differentIndicesCur % 2] = i\\n                differentIndicesCur += 1\\n                differences += 1\\n\\n        if differences > 2 or differences == 1:\\n            return False\\n        # 3\\n        elif differences == 2:\\n            return A[differentIndices[0]] == B[differentIndices[1]] and B[differentIndices[0]] == A[differentIndices[1]]\\n        # 4\\n        else:\\n            return len(set(A)) != len(A)\\n\\t\\t\\t\\t\\t\\t\\n#1: If the length of the arrays is unequal, then obviously we won\\'t be able to make the arrays equal without adding or removing a character. We\\'re limited to swapping two characters exactly one time, so this is out of our scope and results in immediate failure. O(1) time and space.\\n\\n#2: A simple run through the array, marking how many differences we encounter along the way. We do this because it is only possible to return \"true\" if there are either **two differences or no differences**. If there is only one difference, then every character is the same between both strings at every index except for one; moving the character at this index to some other index would ruin the equality of the target index, so it is impossible to do. We\\'re only allowed to swap two characters, so obviously if there are three or more differences we have no shot of making them equal. O(N) time, O(1) space.\\n*(06-26-18 update) Additionally, I save two numbers in a 2-array called \"differentIndices\" - as you might expect, this is where I save the indices where A and B differ. This is still O(1) space because the size of the array doesn\\'t depend on any variable - it\\'s always size 2. The reason I only worry about two indices is because, like I said, we\\'ll return false if there are more than two differences anyway.*\\n\\n#3: **(UPDATED 06-26-2018)** Previously, I checked `set(A) == set(B)` here - however, user MonnaGotIt mentioned that `A = \"abcaa\"` and `B = \"abcbb\"` would incorrectly return true at this juncture, so it needed to be changed. Instead, I take the two indices I recorded earlier (both will be initialized to something other than -1 since `differences` is equal to 2 here), and I make sure the characters would be equal if they were swapped. It\\'s not sufficient to just check `A[differentIndices[0]] == B[differentIndices[1]]` or `B[differentIndices[0]] == A[differentIndices[1]]`, because then `A = \"abcab\"` and `B = \"abcbb\"` would incorrectly return true. They must both be checked. O(1) time, O(1) space.\\n`set(A) == set(B)` is what I had before, and it was O(N) time and O(1) space. More specifically, it was O(3N) time - O(N) to make a set out of A, O(N) to make a set out of B, and O(N) to compare the two in the worst case. Thanks to MonnaGotIt for pointing out the issue with this line.\\n\\n#4: Finally, if there are no differences between A and B (the strings are equal), we can only return true if there\\'s at least one character in A and B that repeats at least once. It doesn\\'t matter how many times it repeats or how many characters repeat, but we need to be able to make a meaningless change if we return true. For example, in `A = B = \\'aabacd\\'`, we can swap any of the two \\'a\\' and return true. However, in `A = B = abcd`, swapping any character would result in the strings losing their equality, so we return false. We check this by comparing the length of set(A) and A: like I said before, converting A to a set will remove all duplicate elements. Therefore, if any duplicate element exists in A, the length of set(A) will be less than the length of A. In this case, we return true. If they\\'re equal, then there were no duplicates in A whatsoever, and we return false. O(N) time, O(N) space.\\n\\nThat\\'s about the size of it. I feel like I went way overkill on this explanation, but sometimes that\\'s helpful for people who are lost. Let me know if you thought it was helpful, if there\\'s anything confusing or unclear about my explanation, or if I got anything wrong. Thanks for reading!",
                "solutionTags": [],
                "code": "Hey guys, I thought my solution was pretty good so I decided to share it with an explanation of how it works. I numbered each part so it\\'d be easier to follow. When I refer to \"N\", I mean the length of A and B (since they\\'re the same). Please leave any feedback on my code or explanation in the comments!  \\n\\t\\n        # 1\\n        if len(A) != len(B):\\n            return False\\n        \\n        # 2\\n        differences = 0\\n        differentIndices = [-1, -1]\\n        differentIndicesCur = 0\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                differentIndices[differentIndicesCur % 2] = i\\n                differentIndicesCur += 1\\n                differences += 1\\n\\n        if differences > 2 or differences == 1:\\n            return False\\n        # 3\\n        elif differences == 2:\\n            return A[differentIndices[0]] == B[differentIndices[1]] and B[differentIndices[0]] == A[differentIndices[1]]\\n        # 4\\n        else:\\n            return len(set(A)) != len(A)\\n\\t\\t\\t\\t\\t\\t\\n#1: If the length of the arrays is unequal, then obviously we won\\'t be able to make the arrays equal without adding or removing a character. We\\'re limited to swapping two characters exactly one time, so this is out of our scope and results in immediate failure. O(1) time and space.\\n\\n#2: A simple run through the array, marking how many differences we encounter along the way. We do this because it is only possible to return \"true\" if there are either **two differences or no differences**. If there is only one difference, then every character is the same between both strings at every index except for one; moving the character at this index to some other index would ruin the equality of the target index, so it is impossible to do. We\\'re only allowed to swap two characters, so obviously if there are three or more differences we have no shot of making them equal. O(N) time, O(1) space.\\n*(06-26-18 update) Additionally, I save two numbers in a 2-array called \"differentIndices\" - as you might expect, this is where I save the indices where A and B differ. This is still O(1) space because the size of the array doesn\\'t depend on any variable - it\\'s always size 2. The reason I only worry about two indices is because, like I said, we\\'ll return false if there are more than two differences anyway.*\\n\\n#3: **(UPDATED 06-26-2018)** Previously, I checked `set(A) == set(B)` here - however, user MonnaGotIt mentioned that `A = \"abcaa\"` and `B = \"abcbb\"` would incorrectly return true at this juncture, so it needed to be changed. Instead, I take the two indices I recorded earlier (both will be initialized to something other than -1 since `differences` is equal to 2 here), and I make sure the characters would be equal if they were swapped. It\\'s not sufficient to just check `A[differentIndices[0]] == B[differentIndices[1]]` or `B[differentIndices[0]] == A[differentIndices[1]]`, because then `A = \"abcab\"` and `B = \"abcbb\"` would incorrectly return true. They must both be checked. O(1) time, O(1) space.\\n`set(A) == set(B)` is what I had before, and it was O(N) time and O(1) space. More specifically, it was O(3N) time - O(N) to make a set out of A, O(N) to make a set out of B, and O(N) to compare the two in the worst case. Thanks to MonnaGotIt for pointing out the issue with this line.\\n\\n#4: Finally, if there are no differences between A and B (the strings are equal), we can only return true if there\\'s at least one character in A and B that repeats at least once. It doesn\\'t matter how many times it repeats or how many characters repeat, but we need to be able to make a meaningless change if we return true. For example, in `A = B = \\'aabacd\\'`, we can swap any of the two \\'a\\' and return true. However, in `A = B = abcd`, swapping any character would result in the strings losing their equality, so we return false. We check this by comparing the length of set(A) and A: like I said before, converting A to a set will remove all duplicate elements. Therefore, if any duplicate element exists in A, the length of set(A) will be less than the length of A. In this case, we return true. If they\\'re equal, then there were no duplicates in A whatsoever, and we return false. O(N) time, O(N) space.\\n\\nThat\\'s about the size of it. I feel like I went way overkill on this explanation, but sometimes that\\'s helpful for people who are lost. Let me know if you thought it was helpful, if there\\'s anything confusing or unclear about my explanation, or if I got anything wrong. Thanks for reading!",
                "codeTag": "Unknown"
            },
            {
                "id": 3711393,
                "title": "simple-o-n-solution-passed-99-1-ms-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        char a=\\'a\\',b=\\'a\\';\\n        int count=0;\\n        int [] chars=new int [26];\\n        char [] schar=s.toCharArray();\\n        char [] goalchar=goal.toCharArray();\\n        if(s.length()!=goal.length()) return false;\\n        for(int i=0;i<schar.length;i++)\\n        {\\n            chars[schar[i]-\\'a\\']++;\\n            if(schar[i]!=goalchar[i])\\n            {\\n                if(count==0)\\n                {\\n                    a=schar[i];\\n                    b=goalchar[i];\\n                    count++;\\n                }\\n                else if(a==goalchar[i] && b==schar[i])\\n                    count++;\\n\\n                //if more than 1 swap occurs then return false\\n                else return false;\\n                } \\n            }\\n        }\\n       \\n        if(count==0)\\n            for(int i:chars) \\n              if(i>1) return true;\\n        \\n\\n        return count==2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        char a=\\'a\\',b=\\'a\\';\\n        int count=0;\\n        int [] chars=new int [26];\\n        char [] schar=s.toCharArray();\\n        char [] goalchar=goal.toCharArray();\\n        if(s.length()!=goal.length()) return false;\\n        for(int i=0;i<schar.length;i++)\\n        {\\n            chars[schar[i]-\\'a\\']++;\\n            if(schar[i]!=goalchar[i])\\n            {\\n                if(count==0)\\n                {\\n                    a=schar[i];\\n                    b=goalchar[i];\\n                    count++;\\n                }\\n                else if(a==goalchar[i] && b==schar[i])\\n                    count++;\\n\\n                //if more than 1 swap occurs then return false\\n                else return false;\\n                } \\n            }\\n        }\\n       \\n        if(count==0)\\n            for(int i:chars) \\n              if(i>1) return true;\\n        \\n\\n        return count==2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710526,
                "title": "beats-100-c-python-solutions-using-frequency-table-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem may appear simple at first, but it is more complex than a textbook example. It involves handling several edge cases and considering various scenarios. There are multiple cases that need to be carefully checked.\\n1. check the lengths of both s & goal\\n2. Set some variables: diff denotes  the number of different places. The array freq is the table for  the frequency of  26 alphabets in word s. hasDuplicates denotes whether s has duplicates for any character and needSwap is the array for the indexes need swap\\n3.  Proceed the iteration and check\\n4. According to each different case to determine whether s is convertible to goal or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len=s.size(), glen=goal.size();\\n        if (len!=glen) return 0;\\n        int diff=0;\\n        vector<int> freq(26, 0);\\n        bool hasDuplicates=0;\\n        vector<int> needSwap;\\n        for(int i=0; i<len; i++){\\n            if (s[i]!=goal[i]){\\n                 diff++;\\n                 needSwap.push_back(i);\\n            }\\n            freq[s[i]-\\'a\\']++;\\n            if (!hasDuplicates &&freq[s[i]-\\'a\\']>=2) \\n                hasDuplicates=1;\\n        }\\n        if (s==goal && hasDuplicates) return 1;\\n        if (s!=goal && diff==2){\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            if (s==goal) return 1;\\n            else return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        l=len(s)\\n        glen=len(goal)\\n        if l!=glen: return 0\\n        diff=0\\n        freq=[0]*26\\n        hasDuplicates=False\\n        needSwap=[]\\n        for i in range(l):\\n            if s[i]!=goal[i]:\\n                diff+=1\\n                needSwap.append(i)\\n            freq[ord(s[i])-ord(\\'a\\')]+=1\\n            if hasDuplicates==False and freq[ord(s[i])-ord(\\'a\\')]>=2:\\n                hasDuplicates=True\\n        if s==goal and hasDuplicates: return True\\n        if s!=goal and diff==2:\\n            slist = list(s)\\n            # Swap the characters at the indices stored in needSwap\\n            slist[needSwap[0]], slist[needSwap[1]]=slist[needSwap[1]], slist[needSwap[0]]\\n            # Convert s_list back to a string\\n            s = \"\".join(slist)\\n\\n            if s==goal: return 1\\n            else: return 0\\n        return 0\\n```\\n\\n# Code with Explanation in Comments\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Get the lengths of the input strings\\n        int len = s.size();\\n        int glen = goal.size();\\n        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;\\n        \\n        // Initialize a variable to keep track of the number of differences between s and goal\\n        int diff = 0;\\n        \\n        // Initialize a frequency array to count the occurrences of each character in s\\n        vector<int> freq(26, 0);\\n        \\n        // Initialize a flag to check if s has any duplicate characters\\n        bool hasDuplicates = 0;\\n        \\n        // Initialize a vector to store the indices where characters need to be swapped\\n        vector<int> needSwap;\\n        \\n        // Iterate over the characters of s and goal\\n        for(int i = 0; i < len; i++){\\n            // If the characters at the current position are different, increment the difference count\\n            // and add the index to the needSwap vector\\n            if (s[i] != goal[i]){\\n                diff++;\\n                needSwap.push_back(i);\\n            }\\n            \\n            // Increment the frequency of the current character in s\\n            freq[s[i]-\\'a\\']++;\\n            \\n            // If there are no duplicates yet and the frequency of the current character is 2 or more,\\n            // set the hasDuplicates flag to true\\n            if (!hasDuplicates && freq[s[i]-\\'a\\'] >= 2) \\n                hasDuplicates = 1;\\n        }\\n        \\n        // If s is equal to goal and it has duplicates, return true\\n        if (s == goal && hasDuplicates)\\n            return 1;\\n        \\n        // If s is not equal to goal and there are exactly 2 differences, try swapping the characters\\n        if (s != goal && diff == 2){\\n            // Swap the characters at the indices stored in needSwap\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            \\n            // If the resulting string is equal to goal, return true\\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        // If none of the above conditions are satisfied, return false\\n        return 0;\\n    }\\n};\\n\\n```\\n# Optimized Code runtime 0 ms beats 100%\\nThe code utilizes an unordered_set called alphabet to quickly check for duplicates in s when s == goal. If duplicates are found or if s has more characters than the size of alphabet, the function returns true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len = s.size(), glen = goal.size();        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;       \\n        if (s == goal) {\\n            unordered_set<char> alphabet;\\n            for (char c : s) {\\n                if (alphabet.count(c) > 0)\\n                    return true;\\n                else\\n                    alphabet.insert(c);\\n            }\\n            return s.size() > alphabet.size();\\n        } \\n        else {\\n            int diff = 0;\\n            vector<int> needSwap;\\n            for (int i = 0; i < len; i++) {\\n                if (s[i] != goal[i]) {\\n                    diff++;\\n                    needSwap.push_back(i);\\n                }\\n            }           \\n            //If there are more than two differences, or no differences, return false\\n            if (diff != 2)\\n                return 0;          \\n            swap(s[needSwap[0]], s[needSwap[1]]);          \\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }       \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len=s.size(), glen=goal.size();\\n        if (len!=glen) return 0;\\n        int diff=0;\\n        vector<int> freq(26, 0);\\n        bool hasDuplicates=0;\\n        vector<int> needSwap;\\n        for(int i=0; i<len; i++){\\n            if (s[i]!=goal[i]){\\n                 diff++;\\n                 needSwap.push_back(i);\\n            }\\n            freq[s[i]-\\'a\\']++;\\n            if (!hasDuplicates &&freq[s[i]-\\'a\\']>=2) \\n                hasDuplicates=1;\\n        }\\n        if (s==goal && hasDuplicates) return 1;\\n        if (s!=goal && diff==2){\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            if (s==goal) return 1;\\n            else return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        l=len(s)\\n        glen=len(goal)\\n        if l!=glen: return 0\\n        diff=0\\n        freq=[0]*26\\n        hasDuplicates=False\\n        needSwap=[]\\n        for i in range(l):\\n            if s[i]!=goal[i]:\\n                diff+=1\\n                needSwap.append(i)\\n            freq[ord(s[i])-ord(\\'a\\')]+=1\\n            if hasDuplicates==False and freq[ord(s[i])-ord(\\'a\\')]>=2:\\n                hasDuplicates=True\\n        if s==goal and hasDuplicates: return True\\n        if s!=goal and diff==2:\\n            slist = list(s)\\n            # Swap the characters at the indices stored in needSwap\\n            slist[needSwap[0]], slist[needSwap[1]]=slist[needSwap[1]], slist[needSwap[0]]\\n            # Convert s_list back to a string\\n            s = \"\".join(slist)\\n\\n            if s==goal: return 1\\n            else: return 0\\n        return 0\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Get the lengths of the input strings\\n        int len = s.size();\\n        int glen = goal.size();\\n        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;\\n        \\n        // Initialize a variable to keep track of the number of differences between s and goal\\n        int diff = 0;\\n        \\n        // Initialize a frequency array to count the occurrences of each character in s\\n        vector<int> freq(26, 0);\\n        \\n        // Initialize a flag to check if s has any duplicate characters\\n        bool hasDuplicates = 0;\\n        \\n        // Initialize a vector to store the indices where characters need to be swapped\\n        vector<int> needSwap;\\n        \\n        // Iterate over the characters of s and goal\\n        for(int i = 0; i < len; i++){\\n            // If the characters at the current position are different, increment the difference count\\n            // and add the index to the needSwap vector\\n            if (s[i] != goal[i]){\\n                diff++;\\n                needSwap.push_back(i);\\n            }\\n            \\n            // Increment the frequency of the current character in s\\n            freq[s[i]-\\'a\\']++;\\n            \\n            // If there are no duplicates yet and the frequency of the current character is 2 or more,\\n            // set the hasDuplicates flag to true\\n            if (!hasDuplicates && freq[s[i]-\\'a\\'] >= 2) \\n                hasDuplicates = 1;\\n        }\\n        \\n        // If s is equal to goal and it has duplicates, return true\\n        if (s == goal && hasDuplicates)\\n            return 1;\\n        \\n        // If s is not equal to goal and there are exactly 2 differences, try swapping the characters\\n        if (s != goal && diff == 2){\\n            // Swap the characters at the indices stored in needSwap\\n            swap(s[needSwap[0]], s[needSwap[1]]);\\n            \\n            // If the resulting string is equal to goal, return true\\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        // If none of the above conditions are satisfied, return false\\n        return 0;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int len = s.size(), glen = goal.size();        \\n        // If the lengths are different, return false\\n        if (len != glen)\\n            return 0;       \\n        if (s == goal) {\\n            unordered_set<char> alphabet;\\n            for (char c : s) {\\n                if (alphabet.count(c) > 0)\\n                    return true;\\n                else\\n                    alphabet.insert(c);\\n            }\\n            return s.size() > alphabet.size();\\n        } \\n        else {\\n            int diff = 0;\\n            vector<int> needSwap;\\n            for (int i = 0; i < len; i++) {\\n                if (s[i] != goal[i]) {\\n                    diff++;\\n                    needSwap.push_back(i);\\n                }\\n            }           \\n            //If there are more than two differences, or no differences, return false\\n            if (diff != 2)\\n                return 0;          \\n            swap(s[needSwap[0]], s[needSwap[1]]);          \\n            if (s == goal)\\n                return 1;\\n            else\\n                return 0;\\n        }       \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682224,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* If strings are inequal in lengths, they\\'re not buddies\\n* If strings are the same, they\\'re buddies if it has duplicate chars which can be swapped\\n* For all other cases, there should be exactly 2 different chars and they swap to be make the strings equal\\n> **T/S:** O(n)/O(1), where n = size(s)\\n```\\npublic boolean buddyStrings(String s, String goal) {\\n\\tif (s.length() != goal.length())\\n\\t\\treturn false;\\n\\tif (s.equals(goal) && hasDuplicateChars(s))\\n\\t\\treturn true;\\n\\n\\tvar diffs = findDiffs(s, goal);\\n\\treturn diffs.size() == 2 &&\\n\\t\\t   s.charAt(diffs.getFirst()) == goal.charAt(diffs.getLast()) &&\\n\\t\\t   s.charAt(diffs.getLast()) == goal.charAt(diffs.getFirst());\\n}\\n\\nprivate boolean hasDuplicateChars(String s) {\\n\\tvar chars = new HashSet<Character>();\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.anyMatch(i -> !chars.add(s.charAt(i)));\\n}\\n\\nprivate Deque<Integer> findDiffs(String s, String goal) {\\n\\tvar diffs = new ArrayDeque<Integer>();\\n\\n\\tfor (var i = 0; i < s.length(); i++)\\n\\t\\tif (s.charAt(i) != goal.charAt(i)) {\\n\\t\\t\\tdiffs.add(i);\\n\\t\\t\\tif (diffs.size() > 2)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\treturn diffs;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean buddyStrings(String s, String goal) {\\n\\tif (s.length() != goal.length())\\n\\t\\treturn false;\\n\\tif (s.equals(goal) && hasDuplicateChars(s))\\n\\t\\treturn true;\\n\\n\\tvar diffs = findDiffs(s, goal);\\n\\treturn diffs.size() == 2 &&\\n\\t\\t   s.charAt(diffs.getFirst()) == goal.charAt(diffs.getLast()) &&\\n\\t\\t   s.charAt(diffs.getLast()) == goal.charAt(diffs.getFirst());\\n}\\n\\nprivate boolean hasDuplicateChars(String s) {\\n\\tvar chars = new HashSet<Character>();\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.anyMatch(i -> !chars.add(s.charAt(i)));\\n}\\n\\nprivate Deque<Integer> findDiffs(String s, String goal) {\\n\\tvar diffs = new ArrayDeque<Integer>();\\n\\n\\tfor (var i = 0; i < s.length(); i++)\\n\\t\\tif (s.charAt(i) != goal.charAt(i)) {\\n\\t\\t\\tdiffs.add(i);\\n\\t\\t\\tif (diffs.size() > 2)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\treturn diffs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890967,
                "title": "buddy-strings-java-c-kotlin-o-n",
                "content": "1. If the lengths are not equal, return false\\n2. If the two strings are not the same, there must be only two positions that the char are different and they can be swapped.\\n3. If the two strings are the same, we need to find a duplicate character. \\n\\nNote: \\n1. For 3, if the string length is greater than **26**, it must be **true** and no need to check. \\n2. I don\\'t use set or list to reduce the unnecessary overhead\\n3. Adding a Kotlin solution.  I am kind of new to Kotlin and welcome to all suggestions. \\n\\nIf you like it, please upvote it. Thanks.\\n\\n**java**\\n```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length() || A.isEmpty()) return false;\\n        \\n        if (!A.equals(B))\\n        {\\n            int count = 0;\\n\\t\\t\\t// The value doesn\\'t matter. If no initial value, the compiler will complain\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.length(); i++)\\n            {\\n                if (A.charAt(i) == B.charAt(i)) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A.charAt(i);\\n                    second = B.charAt(i);\\n                    count++;\\n                    continue;\\n                }\\n                if (A.charAt(i) != second || B.charAt(i) != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n\\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.length() > 26) return true;\\n        int [] fre = new int[26];\\n        for (char c : A.toCharArray())\\n        {\\n            if (fre[c-\\'a\\'] == 1) return true;\\n            fre[c-\\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**c++**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size() || A.empty()) return false;\\n        \\n        if (A != B)\\n        {\\n            int count = 0;\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.size(); i++)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        \\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.size() > 26) return true;\\n        int freq[26] = {};\\n        for (auto c: A)\\n        {\\n            if (freq[c - \\'a\\'] == 1) return true;\\n            freq[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**kotlin**\\n```\\nclass Solution {\\n    fun buddyStrings(A: String, B: String): Boolean {\\n        if (A.length != B.length || A.isEmpty()) return false\\n        if (A != B)\\n        {\\n            var count = 0;\\n            var first = \\'a\\'\\n            var second = \\'a\\'\\n            for (i in A.indices)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        if (A.length > 26) return true;\\n        var fre = Array(26){0};\\n        for (i in A.indices)\\n        {\\n            if (fre[A[i]-\\'a\\'] == 1) return true;\\n            fre[A[i] - \\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length() || A.isEmpty()) return false;\\n        \\n        if (!A.equals(B))\\n        {\\n            int count = 0;\\n\\t\\t\\t// The value doesn\\'t matter. If no initial value, the compiler will complain\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.length(); i++)\\n            {\\n                if (A.charAt(i) == B.charAt(i)) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A.charAt(i);\\n                    second = B.charAt(i);\\n                    count++;\\n                    continue;\\n                }\\n                if (A.charAt(i) != second || B.charAt(i) != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n\\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.length() > 26) return true;\\n        int [] fre = new int[26];\\n        for (char c : A.toCharArray())\\n        {\\n            if (fre[c-\\'a\\'] == 1) return true;\\n            fre[c-\\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size() || A.empty()) return false;\\n        \\n        if (A != B)\\n        {\\n            int count = 0;\\n            char first = \\'a\\', second = \\'a\\';\\n            for (int i = 0; i < A.size(); i++)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        \\n        // there must be at least one duplicated char if the length is greater than 26\\n        if (A.size() > 26) return true;\\n        int freq[26] = {};\\n        for (auto c: A)\\n        {\\n            if (freq[c - \\'a\\'] == 1) return true;\\n            freq[c - \\'a\\'] = 1;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun buddyStrings(A: String, B: String): Boolean {\\n        if (A.length != B.length || A.isEmpty()) return false\\n        if (A != B)\\n        {\\n            var count = 0;\\n            var first = \\'a\\'\\n            var second = \\'a\\'\\n            for (i in A.indices)\\n            {\\n                if (A[i] == B[i]) continue;\\n                if (count >= 2) return false;\\n                if (count == 0)\\n                {\\n                    first = A[i];\\n                    second = B[i];\\n                    count++;\\n                    continue;\\n                }\\n                if (A[i] != second || B[i] != first) return false;\\n                count++;\\n            }\\n            return count == 2;\\n        }\\n        if (A.length > 26) return true;\\n        var fre = Array(26){0};\\n        for (i in A.indices)\\n        {\\n            if (fre[A[i]-\\'a\\'] == 1) return true;\\n            fre[A[i] - \\'a\\']++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711799,
                "title": "python-one-liner-beginner-friendly-simple",
                "content": "# Code\\n```\\ndic = [[a,b] for a,b in zip(s,goal) if a!=b]        \\nreturn len(s)==len(goal) and (len(dic)==2 and dic[0][0]==dic[1][1] and dic[1][0]==dic[0][1] or (len(dic)==0 and len(set(s))<len(goal)))\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/4ff36693-09e4-4f10-94fb-43169f427dbc_1688372006.5884976.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndic = [[a,b] for a,b in zip(s,goal) if a!=b]        \\nreturn len(s)==len(goal) and (len(dic)==2 and dic[0][0]==dic[1][1] and dic[1][0]==dic[0][1] or (len(dic)==0 and len(set(s))<len(goal)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710430,
                "title": "java-frequency-check",
                "content": "## If it was helpful please upvote for motivation*\\n**Java Solution if you need explanation please let me know!!**\\n\\n![image](https://assets.leetcode.com/users/images/19e57c4e-6995-46cc-bb07-29ac3c579ed5_1688345204.5127478.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public boolean buddyStrings(String str, String goal) {\\n        if (str.length() != goal.length()) {\\n            return false;\\n        }\\n        if (str.equals(goal)) {\\n            int[] frequency = new int[26];\\n            for (char ch : str.toCharArray()) {\\n                frequency[ch - \\'a\\']++;\\n                if (frequency[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int f = -1;\\n        int s = -1;\\n        for (int i = 0; i < str.length(); ++i) {\\n            if (str.charAt(i) != goal.charAt(i)) {\\n                if (f == -1) {\\n                    f = i;\\n                } \\n                else if (s == -1) {\\n                    s = i;\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        if (s == -1) {\\n            return false;\\n        }\\n        boolean ans = str.charAt(f) == goal.charAt(s) && str.charAt(s) == goal.charAt(f);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String str, String goal) {\\n        if (str.length() != goal.length()) {\\n            return false;\\n        }\\n        if (str.equals(goal)) {\\n            int[] frequency = new int[26];\\n            for (char ch : str.toCharArray()) {\\n                frequency[ch - \\'a\\']++;\\n                if (frequency[ch - \\'a\\'] == 2) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        int f = -1;\\n        int s = -1;\\n        for (int i = 0; i < str.length(); ++i) {\\n            if (str.charAt(i) != goal.charAt(i)) {\\n                if (f == -1) {\\n                    f = i;\\n                } \\n                else if (s == -1) {\\n                    s = i;\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        if (s == -1) {\\n            return false;\\n        }\\n        boolean ans = str.charAt(f) == goal.charAt(s) && str.charAt(s) == goal.charAt(f);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234318,
                "title": "easiest-ever-python",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n\\n        count = 0\\n        k=[]\\n        if len(s)!= len(goal): return False\\n        for i in range(len(s)):\\n            if s[i]!= goal[i]:\\n                count +=1\\n                k.append(i)\\n                    \\n        if count >2 : return False\\n        elif count == 2 and s[k[0]] == goal[k[1]] and s[k[1]] == goal[k[0]]: return True\\n            \\n        elif count == 0 and len(set(s)) < len(s): return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n\\n        count = 0\\n        k=[]\\n        if len(s)!= len(goal): return False\\n        for i in range(len(s)):\\n            if s[i]!= goal[i]:\\n                count +=1\\n                k.append(i)\\n                    \\n        if count >2 : return False\\n        elif count == 2 and s[k[0]] == goal[k[1]] and s[k[1]] == goal[k[0]]: return True\\n            \\n        elif count == 0 and len(set(s)) < len(s): return True",
                "codeTag": "Java"
            },
            {
                "id": 753270,
                "title": "java-2ms-beats-79-by-counting-number-of-mismatches-and-what-characters-are-mismatched",
                "content": "```\\nclass Solution {\\n  public boolean buddyStrings(String A, String B) {\\n    \\n    // strategy: count the Character mismatches between the Strings, and see whether the mismatch can be fixed by a swap\\n\\n    /*\\n    Runtime: 2 ms, faster than 78.62% of Java online submissions for Buddy Strings.\\n    Memory Usage: 39.5 MB, less than 30.81% of Java online submissions for Buddy Strings.\\n    */\\n\\n    // edge case: one or more input Strings are empty\\n    if (A.length() == 0 || B.length() == 0) {\\n      return false; // no swap is possible with empty strings\\n    }\\n\\n    // edge case: input Strings are different lengths\\n    if (A.length() != B.length()) {\\n      return false; // Strings of different length can\\'t be made equal with a Character swap\\n    }\\n\\n    List<Character> charactersInMismatchesInA = new ArrayList<>();\\n    List<Character> charactersInMismatchesInB = new ArrayList<>();\\n    for (int index = 0; index < A.length(); ++index) {\\n      if (A.charAt(index) != B.charAt(index)) {\\n        charactersInMismatchesInA.add(A.charAt(index));\\n        charactersInMismatchesInB.add(B.charAt(index));\\n      }\\n    }\\n\\n    int numberOfMismatches = charactersInMismatchesInA.size();\\n\\n    switch(numberOfMismatches) {\\n      case 0:\\n        // identical Strings, but check whether we have two occurrences of same Character that we can swap\\n        Set<Character> s = new HashSet<>();\\n        for (char c : A.toCharArray()) {\\n          if (s.contains(c)) { // if Set already contains this Character, then String contains 2, so return true\\n            return true;\\n          } else {\\n            s.add(c); // add Character to Set in case we see another one later in String\\n          }\\n        }\\n        return false; // Strings A and B are equal, and there are no duplicate letters for us to swap, so return false\\n      case 1:\\n        return false; // if Strings A and B don\\'t match, we need exactly 2 mismatches for us to swap, so return false\\n      case 2:\\n        if (charactersInMismatchesInA.get(0) == charactersInMismatchesInB.get(1) && charactersInMismatchesInA.get(1) == charactersInMismatchesInB.get(0)) { // if we have same two Characters in the two mismatches, then we can swap\\n          return true;\\n        } else {\\n          return false; // there must be 3 or more Characters in these mismatches, so return false\\n        }\\n      case 3:\\n        // fall through to default\\n      default: // if there are 3 or more mismatches, return false, since a single swap can\\'t make the Strings equal\\n        return false;\\n    }\\n\\n\\n    // note: we return from switch block above\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean buddyStrings(String A, String B) {\\n    \\n    // strategy: count the Character mismatches between the Strings, and see whether the mismatch can be fixed by a swap\\n\\n    /*\\n    Runtime: 2 ms, faster than 78.62% of Java online submissions for Buddy Strings.\\n    Memory Usage: 39.5 MB, less than 30.81% of Java online submissions for Buddy Strings.\\n    */\\n\\n    // edge case: one or more input Strings are empty\\n    if (A.length() == 0 || B.length() == 0) {\\n      return false; // no swap is possible with empty strings\\n    }\\n\\n    // edge case: input Strings are different lengths\\n    if (A.length() != B.length()) {\\n      return false; // Strings of different length can\\'t be made equal with a Character swap\\n    }\\n\\n    List<Character> charactersInMismatchesInA = new ArrayList<>();\\n    List<Character> charactersInMismatchesInB = new ArrayList<>();\\n    for (int index = 0; index < A.length(); ++index) {\\n      if (A.charAt(index) != B.charAt(index)) {\\n        charactersInMismatchesInA.add(A.charAt(index));\\n        charactersInMismatchesInB.add(B.charAt(index));\\n      }\\n    }\\n\\n    int numberOfMismatches = charactersInMismatchesInA.size();\\n\\n    switch(numberOfMismatches) {\\n      case 0:\\n        // identical Strings, but check whether we have two occurrences of same Character that we can swap\\n        Set<Character> s = new HashSet<>();\\n        for (char c : A.toCharArray()) {\\n          if (s.contains(c)) { // if Set already contains this Character, then String contains 2, so return true\\n            return true;\\n          } else {\\n            s.add(c); // add Character to Set in case we see another one later in String\\n          }\\n        }\\n        return false; // Strings A and B are equal, and there are no duplicate letters for us to swap, so return false\\n      case 1:\\n        return false; // if Strings A and B don\\'t match, we need exactly 2 mismatches for us to swap, so return false\\n      case 2:\\n        if (charactersInMismatchesInA.get(0) == charactersInMismatchesInB.get(1) && charactersInMismatchesInA.get(1) == charactersInMismatchesInB.get(0)) { // if we have same two Characters in the two mismatches, then we can swap\\n          return true;\\n        } else {\\n          return false; // there must be 3 or more Characters in these mismatches, so return false\\n        }\\n      case 3:\\n        // fall through to default\\n      default: // if there are 3 or more mismatches, return false, since a single swap can\\'t make the Strings equal\\n        return false;\\n    }\\n\\n\\n    // note: we return from switch block above\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143647,
                "title": "easy-javascript",
                "content": "```\\nvar buddyStrings = function(A, B) {\\n    if(A.length!=B.length || A.length<2 || B.length<2 ) return false;\\n    \\n    if(A==B) {\\n        let setA = new Set(A.split(\\'\\'));\\n        return setA.size<A.length;\\n    }\\n    \\n    let index = [];\\n    for(let i =0; i<A.length; ++i) {\\n        if(A[i]!=B[i]) index.push(i);\\n    }\\n    if(index.length!=2) return false;\\n    \\n    return A[index[0]]==B[index[1]] && A[index[1]]==B[index[0]];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar buddyStrings = function(A, B) {\\n    if(A.length!=B.length || A.length<2 || B.length<2 ) return false;\\n    \\n    if(A==B) {\\n        let setA = new Set(A.split(\\'\\'));\\n        return setA.size<A.length;\\n    }\\n    \\n    let index = [];\\n    for(let i =0; i<A.length; ++i) {\\n        if(A[i]!=B[i]) index.push(i);\\n    }\\n    if(index.length!=2) return false;\\n    \\n    return A[index[0]]==B[index[1]] && A[index[1]]==B[index[0]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710765,
                "title": "c-o-n-frequency-map",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710745,
                "title": "c-beginner-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size() || s.size()==1)return false;\\n        vector<int>different;\\n        vector<int>ct(26,0);\\n        bool f=false;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])different.push_back(i);\\n            else{\\n                ct[s[i]-\\'a\\']++;\\n                if(ct[s[i]-\\'a\\']>=2)f=true;\\n            }\\n        }\\n        if(different.size()>2)return false;\\n        if(different.size()==1)return false;\\n         if(different.size()==0){\\n             return f;\\n         }\\n        int in1,in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1],s[in2]);\\n        return s==goal;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/54b36830-9ed3-4c8a-8928-a351c0059d04_1688355853.402244.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size() || s.size()==1)return false;\\n        vector<int>different;\\n        vector<int>ct(26,0);\\n        bool f=false;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])different.push_back(i);\\n            else{\\n                ct[s[i]-\\'a\\']++;\\n                if(ct[s[i]-\\'a\\']>=2)f=true;\\n            }\\n        }\\n        if(different.size()>2)return false;\\n        if(different.size()==1)return false;\\n         if(different.size()==0){\\n             return f;\\n         }\\n        int in1,in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1],s[in2]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758409,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313464,
                "title": "easy-c-using-two-pointers-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n  bool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  bool buddyStrings(string A, string B) {        \\n        if (A == B)\\n            return (set<char>(A.begin(), A.end()).size() < A.size()); // swap same letters in A\\n        \\n        int n = A.length();\\n        int l = 0, r = n-1;\\n        \\n        while(l < n && A[l] == B[l])\\n            l++;\\n        while(r >= 0 && A[r] == B[r])\\n            r--;\\n        if(l < r)\\n            swap(A[l], A[r]);\\n        \\n        return A == B;                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068810,
                "title": "c-solution",
                "content": "```\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size())\\n\\t\\treturn false;\\n\\n\\tif (A == B && set<char>(A.begin(), A.end()).size() < A.size())\\n\\t\\treturn true;\\n\\n\\tvector<int> diff {};\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\tif (A[i] != B[i])\\n\\t\\t\\tdiff.push_back(i);\\n\\n\\treturn (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size())\\n\\t\\treturn false;\\n\\n\\tif (A == B && set<char>(A.begin(), A.end()).size() < A.size())\\n\\t\\treturn true;\\n\\n\\tvector<int> diff {};\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t\\tif (A[i] != B[i])\\n\\t\\t\\tdiff.push_back(i);\\n\\n\\treturn (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891233,
                "title": "java-o-n-3-cases-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //case 1: if the lengths are not equal, return false\\n        if(A.length()!=B.length())\\n            return false;\\n        //case 2: if strings are equal we have to make sure that \\n        // atleast there are two instances of any char.\\n        // for example \\'a\\' \\'a\\' returns false but \\'aa\\' \\'aa\\' returns true\\n        if(A.equals(B)) {\\n            Set<Character> set = new HashSet<>();\\n            for(char c : A.toCharArray()) {\\n                if(set.contains(c))\\n                    return true;\\n                set.add(c);   \\n            }\\n            return false;\\n        }\\n        //case 3: check if the strings only differ at only two indexes and\\n        //chars at those diff indexes are equal.\\\\\\n        // for example: aabc , aacb returns true.\\n        // aabc, aace -> return false.\\n        List<Integer> diff = new ArrayList<>();\\n        for(int i=0;i<A.length();i++) {\\n            if(A.charAt(i)!=B.charAt(i))\\n                diff.add(i);\\n        }\\n        return diff.size()==2 && (A.charAt(diff.get(0)) == B.charAt(diff.get(1))  &&\\n                                  B.charAt(diff.get(0)) == A.charAt(diff.get(1)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //case 1: if the lengths are not equal, return false\\n        if(A.length()!=B.length())\\n            return false;\\n        //case 2: if strings are equal we have to make sure that \\n        // atleast there are two instances of any char.\\n        // for example \\'a\\' \\'a\\' returns false but \\'aa\\' \\'aa\\' returns true\\n        if(A.equals(B)) {\\n            Set<Character> set = new HashSet<>();\\n            for(char c : A.toCharArray()) {\\n                if(set.contains(c))\\n                    return true;\\n                set.add(c);   \\n            }\\n            return false;\\n        }\\n        //case 3: check if the strings only differ at only two indexes and\\n        //chars at those diff indexes are equal.\\\\\\n        // for example: aabc , aacb returns true.\\n        // aabc, aace -> return false.\\n        List<Integer> diff = new ArrayList<>();\\n        for(int i=0;i<A.length();i++) {\\n            if(A.charAt(i)!=B.charAt(i))\\n                diff.add(i);\\n        }\\n        return diff.size()==2 && (A.charAt(diff.get(0)) == B.charAt(diff.get(1))  &&\\n                                  B.charAt(diff.get(0)) == A.charAt(diff.get(1)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558821,
                "title": "python-different-from-the-included-solution-explained",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A and B and len(A) == len(B):\\n            \\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i])\\n            \\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n        \\n        return False\\n```\\n\\nA lot of posts here repeat the provided solution, so tried to do something different ...\\n\\nThe code is a head on approach:\\n\\n```\\n        if A and B and len(A) == len(B):\\n```\\n\\nsome sanity check first ...\\n\\n```\\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i]))\\n```\\n\\nHere we count characters different between A and B.\\n\\nOk, if `a` is not equal to `b`, that means our string A and B are using different characters, so it\\'s impossible to make them to be the same by reordering characters. But if `a` and `b` are the same, we have two options:\\n\\n1. They are off by exactly 2 same characters:\\n\\n```\\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n```\\n\\nThen we can simply swap those 2 characters.\\n\\n2. The strings are completely identical. Then we need to make sure those string have at least 2 instances of some character so they can be swapped (for example \"aa\" and \"aa\", while swapping first a and second a don\\'t change the string, they can still be swapped). So we find the most common character and make sure it\\'s the same and there is more than one in each string:\\n```\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n```\\n\\nOtherwise - return False.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A and B and len(A) == len(B):\\n            \\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i])\\n            \\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n        \\n        return False\\n```\n```\\n        if A and B and len(A) == len(B):\\n```\n```\\n            a,b = [],[]\\n            \\n            for i in range(len(A)):\\n                if A[i]!=B[i]:\\n                    a.append(A[i])\\n                    b.append(B[i]))\\n```\n```\\n            if set(a)==set(b):\\n                if len(a) == len(b) == 2:\\n                    return True\\n```\n```\\n                else:\\n                    ca,cb = collections.Counter(A), collections.Counter(B)\\n                    if A==B  and cb.most_common(1)[0][1]>1:\\n                        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394976,
                "title": "python3-solution-with-explanation",
                "content": "In another word, A and B are buddy strings iff one of the below two conditions is true\\n1) A == B and A has repetitive letters (so that by swapping them, A is still A)\\n2) A != B but there are exactly 2 different letters (at position m and n) and A[m] = B[n], A[n] = B[m] \\n\\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if len(A) != len(B): return False \\n        if A == B:\\n            return len(A) > len(set(A))\\n        else:\\n            pairs = []\\n            for a, b in zip(A, B):\\n                if a != b: pairs.append((a, b))\\n                if len(pairs) > 2: return False \\n            return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```\\n\\nEdited on 10/13/2020\\nAdded a 3-line solution \\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A == B: return len(A) > len(set(A)) # duplicates in A\\n        stack = [(a, b) for a, b in zip_longest(A, B) if a != b]\\n        return len(stack) == 2 and stack[0] == stack[-1][::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if len(A) != len(B): return False \\n        if A == B:\\n            return len(A) > len(set(A))\\n        else:\\n            pairs = []\\n            for a, b in zip(A, B):\\n                if a != b: pairs.append((a, b))\\n                if len(pairs) > 2: return False \\n            return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n        if A == B: return len(A) > len(set(A)) # duplicates in A\\n        stack = [(a, b) for a, b in zip_longest(A, B) if a != b]\\n        return len(stack) == 2 and stack[0] == stack[-1][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711914,
                "title": "python-elegant-short-counting",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        different_letters = [\\n            (a, b)\\n            for a, b in zip(s, goal)\\n            if a != b\\n        ]\\n\\n        if len(different_letters) != 2:\\n            # If two strings are the same, then we just need to swap duplicates\\n            return not different_letters and len(set(s)) < len(s)\\n\\n        (a1, b1), (a2, b2) = different_letters\\n        return a1 == b2 and b1 == a2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n\\n        different_letters = [\\n            (a, b)\\n            for a, b in zip(s, goal)\\n            if a != b\\n        ]\\n\\n        if len(different_letters) != 2:\\n            # If two strings are the same, then we just need to swap duplicates\\n            return not different_letters and len(set(s)) < len(s)\\n\\n        (a1, b1), (a2, b2) = different_letters\\n        return a1 == b2 and b1 == a2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711757,
                "title": "easy-c-approach-easy-to-understand",
                "content": "# Intuition\\nJust count the the characters which does not match in the given two strings. If cnt is greater than equal to 3 or equal to 1 then it is not possible. \\n\\n\\nIf the cnt is still 0, there can be 2 cases that either it contains all character different or at least one character repetitive. if all characters are different then again it is not possible else for at least one, it is possible.\\n\\nFinally,we arrive at last possibility i.e. we can have two different characters in the string. we can check easily that by swapping these two characters, we can get goal or not. If yes we can return true else return false.\\n# Approach\\ninitilalize cnt variable to check no. of different characters\\n\\nuse a map to check the frequeny of characters in the string which is equal to goal string\\n\\nFinally swap the chars in the string s and check its possibility of being equal to goal.\\n\\n# Complexity\\n- Time complexity:\\no(n): where n is the size of the string s.\\n\\n- Space complexity:\\no(k): where k is the number of unique characters in the string s.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) cnt++;\\n        }\\n        if(cnt>=3 || cnt==1) return false;\\n        if(cnt==0){\\n            map<char, int> m;\\n            for(auto it: s){\\n                m[it]++;\\n            }\\n            for(auto it:m){\\n                if(it.second>1) return true;\\n            }\\n            return false;\\n\\n        }\\n        vector<int> ind;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind.push_back(i);\\n            }\\n        }\\n        swap(s[ind[0]],s[ind[1]]);\\n        cout<<ind[0]<<\" \"<<ind[1]<<endl;\\n        if(s==goal) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) cnt++;\\n        }\\n        if(cnt>=3 || cnt==1) return false;\\n        if(cnt==0){\\n            map<char, int> m;\\n            for(auto it: s){\\n                m[it]++;\\n            }\\n            for(auto it:m){\\n                if(it.second>1) return true;\\n            }\\n            return false;\\n\\n        }\\n        vector<int> ind;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind.push_back(i);\\n            }\\n        }\\n        swap(s[ind[0]],s[ind[1]]);\\n        cout<<ind[0]<<\" \"<<ind[1]<<endl;\\n        if(s==goal) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3710800,
                "title": "c-easy-implementation-commented",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        // check same length\\n        if (A.size() != B.size()) \\n            return false;\\n        \\n        // if strings are equal - check if there is a double to swap\\n        if (A == B) { \\n            unordered_map<char, int> count;\\n            for (auto l:A){\\n                count[l]++;\\n                if (count[l] > 1)\\n                    return true;\\n            }\\n            return false;\\n        }\\n        \\n        // count differences between strings\\n        vector<int> diff;\\n        for (int i=0; i<A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n                if (diff.size() > 2)\\n                    return false;\\n            }\\n        }\\n        // not exactly two differences\\n        if (diff.size() != 2)\\n            return false;\\n        \\n        // check if can be swapped\\n        if ((A[diff[0]] == B[diff[1]]) && (A[diff[1]] == B[diff[0]]))\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710493,
                "title": "easy-to-understand-solution-with-intuitive-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The immediate thought is that $$s$$ and $$goal$$ must have the same length, and they must either be identical or differ in exactly two positions.\\n- If they are identical, $$s$$ must have at least one character that appears more than once, so we can swap the two instances of that character.\\n- If they differ in exactly two positions, the characters at those positions must be reversed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The solution first checks the lengths of $$s$$ and $$goal$$. If they have different lengths, we immediately returns False. \\n- Then we checks if $$s$$ and $$goal$$ are identical and $$s$$ has a character that appears more than once. If both conditions are met, we returns $$True$$. \\n- Otherwise, using zip function, we creates a list of pairs of characters where $$s$$ and $$goal$$ differ. If the length of the list is 2 and the pairs are reversed versions of each other, we returns $$True$$. Otherwise, we returns $$False$$.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        pairs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal):\\n            return False\\n        if s == goal and len(set(s)) < len(s):\\n            return True\\n        pairs = [(a, b) for a, b in zip(s, goal) if a != b]\\n        return len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890999,
                "title": "c-0ms-one-pass-concise-solution-no-extra-ds-needed",
                "content": "There are a few situations:\\n- A and B are with different lengths => false\\n- length < 2 => can\\'t swap, false\\n- only 1 or more than 2 unmatched indexes => false\\n- exactly 2 unmatched indexes, becomes the same after swap => true\\n- A and B are identical, and exists at least 1 letter appeared more than once in each string => true\\n\\nUpdate 2: I have improved it further! Now version 3 is about 3 times faster than version 1 on long strings, based on my benchmark. And there\\'s no any extra data structures used (set, string, array, etc.) You can even replace the bitset with an int and it will just work (but the code will be messier, see below)\\nExplain:\\n- We know `0 ^ x = x` and `x ^ x = 0`, if `x != y` then `x ^ y != 0`. So if we found `(x, y)` in string A and `(y, x)` in string B, `(x ^ y) ^ (y ^ x) == 0`. There is one exception: if we found `(x, x)` in string A and `(y, y)` in string B, `(x ^ x) ^ (y ^ y)` is also `0`, so we have to check the 2 letters found in same string `(x1, x2)` are not the same - `x1 & x2 != 0`.\\n- We are garanteed to be able to find duplicated letters within the first 27 letters, so don\\'t bother to do the checks if we have already found any.\\n#### Version 3\\n```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tbitset<128> bits{0};\\n\\tuint8_t m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits.test(A[i]), bits.set(A[i]);\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\\n### Version 3 ints only\\n```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tuint32_t bits = 0, m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits & (1 << (A[i] - \\'a\\')), bits |= (1 << (A[i] - \\'a\\'));\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\\n----\\nUpdate: I have improved the solution a little bit, and saved a few lines:\\n#### Version 2\\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i];\\n\\t\\t\\tsb = B[i] + sb;\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    return (sa.size() == 2 && sa == sb) || (sa.empty() && dup);\\n}\\n```\\n\\n----\\n#### Version 1\\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i], sb += B[i];\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    if (sa.size() == 2) {\\n        swap(sa[0], sa[1]);\\n        return sa == sb;\\n    }\\n    return sa.empty() && dup;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tbitset<128> bits{0};\\n\\tuint8_t m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits.test(A[i]), bits.set(A[i]);\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\n```cpp\\nbool buddyStrings(string A, string B) {\\n\\tif (A.size() != B.size() || A.size() < 2) return false;\\n\\tuint32_t bits = 0, m1 = 0, m2 = 0, count = 0, dup = 0;\\n\\tfor (int i = 0; i < A.size() && count <= 2; ++i) {\\n\\t\\tif (A[i] != B[i]) m1 ^= A[i] ^ B[i], m2 ^= A[i], ++count;\\n\\t\\tif (!dup) dup = bits & (1 << (A[i] - \\'a\\')), bits |= (1 << (A[i] - \\'a\\'));\\n\\t}\\n\\treturn (count == 2 && !m1 && m2) || (!count && dup);\\n}\\n```\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i];\\n\\t\\t\\tsb = B[i] + sb;\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    return (sa.size() == 2 && sa == sb) || (sa.empty() && dup);\\n}\\n```\n```cpp\\nbool buddyStrings(string A, string B) {\\n    if (A.size() != B.size() || A.size() < 2) return false;\\n    string sa, sb;\\n    bitset<128> bits{0};\\n    bool dup = false;\\n    for (int i = 0; i < A.size() && sa.size() <= 2; ++i) {\\n        if (A[i] != B[i]) {\\n\\t\\t\\tsa += A[i], sb += B[i];\\n        } else {\\n\\t\\t\\tdup |= bits.test(A[i]);\\n\\t\\t\\tbits.set(A[i]);\\n\\t\\t}\\n    }\\n    if (sa.size() == 2) {\\n        swap(sa[0], sa[1]);\\n        return sa == sb;\\n    }\\n    return sa.empty() && dup;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554617,
                "title": "python-3-simple-solution-with-explanation",
                "content": "```\\n\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n\\t\\t# if lengths are different, then must be false\\n        if len(A) != len(B):\\n            return False\\n        # If A and B are same, then A must have duplicate character\\n        if A == B:  \\n            seen = set()\\n            for a in A:\\n                if a in seen: \\n                    return True\\n                seen.add(a)\\n            return False\\n\\n        pair = []\\n        # when A and B are not same\\n        for a, b in zip(A, B): \\n            if a != b:\\n                pair.append((a, b))\\n            if len(pair) > 2:\\n                return False\\n            \\n        return len(pair) == 2 and pair[0] == pair[1][::-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def buddyStrings(self, A: str, B: str) -> bool:\\n\\t\\t# if lengths are different, then must be false\\n        if len(A) != len(B):\\n            return False\\n        # If A and B are same, then A must have duplicate character\\n        if A == B:  \\n            seen = set()\\n            for a in A:\\n                if a in seen: \\n                    return True\\n                seen.add(a)\\n            return False\\n\\n        pair = []\\n        # when A and B are not same\\n        for a, b in zip(A, B): \\n            if a != b:\\n                pair.append((a, b))\\n            if len(pair) > 2:\\n                return False\\n            \\n        return len(pair) == 2 and pair[0] == pair[1][::-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 537249,
                "title": "o-n-space-o-1-space-two-js-solutions",
                "content": "```\\n// O(N) space\\nvar buddyStrings = function(A, B) {\\n    if (A == \"\" || B == \"\" || A.length !== B.length) return false;\\n    if (A == B) {\\n        let set = new Set(A);\\n        return set.size !== A.length;\\n    }\\n    let a = \"\", b = \"\";\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] !== B[i]) {\\n            a += A[i];\\n            b += B[i];\\n        } \\n    }\\n    if (a.length == 2 && a.length == b.length) {\\n        return a[0] == b[1] && a[1] == b[0];    \\n    } \\n    return false; \\n\\t// T.C: O(M), M = length of s\\n\\t// S.C: O(M)\\n};\\n```\\n\\n```\\n// O(1) Space\\n/*\\nImportant Note: You are required to perform a swap of two letters. Exactly one. No less, No more.\\n\\n1. Check strings\\' lengths. If they are different, return false.\\n2. Iterate through both strings. If two characters are different, push the index to an array.\\n3. After iteration is done, array should contain exactly two indices (idx1 and idx2) and\\ns[idx1] == goal[idx2] and s[idx2] == goal[idx1]. Or, another case is that two strings are exactly the same.\\nIn this case, they should contain one same letter that occurs more than once so that strings stay unchanged after one swap.\\nFor all other cases, return false.\\n*/\\nvar buddyStrings = function(s, goal) {\\n    if (s.length !== goal.length) {\\n        return false;\\n    }\\n    let swapIdx = [], chars = new Array(26).fill(0), sameCharTwice = false;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] !== goal[i]) {\\n            swapIdx.push(i);\\n            if (swapIdx.length > 2) return false;\\n        } else {\\n            let idx = s.charCodeAt(i) - 97;\\n            chars[idx]++;\\n            if (chars[idx] > 1) sameCharTwice = true;\\n        }\\n    }\\n    if (swapIdx.length === 2 &&\\n        s[swapIdx[0]] === goal[swapIdx[1]] &&\\n        s[swapIdx[1]] === goal[swapIdx[0]]) {\\n        return true;\\n    }\\n    if (swapIdx.length === 0 && sameCharTwice) {\\n        return true;\\n    }\\n    return false;\\n    // T.C: O(M), M = length of s\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(N) space\\nvar buddyStrings = function(A, B) {\\n    if (A == \"\" || B == \"\" || A.length !== B.length) return false;\\n    if (A == B) {\\n        let set = new Set(A);\\n        return set.size !== A.length;\\n    }\\n    let a = \"\", b = \"\";\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] !== B[i]) {\\n            a += A[i];\\n            b += B[i];\\n        } \\n    }\\n    if (a.length == 2 && a.length == b.length) {\\n        return a[0] == b[1] && a[1] == b[0];    \\n    } \\n    return false; \\n\\t// T.C: O(M), M = length of s\\n\\t// S.C: O(M)\\n};\\n```\n```\\n// O(1) Space\\n/*\\nImportant Note: You are required to perform a swap of two letters. Exactly one. No less, No more.\\n\\n1. Check strings\\' lengths. If they are different, return false.\\n2. Iterate through both strings. If two characters are different, push the index to an array.\\n3. After iteration is done, array should contain exactly two indices (idx1 and idx2) and\\ns[idx1] == goal[idx2] and s[idx2] == goal[idx1]. Or, another case is that two strings are exactly the same.\\nIn this case, they should contain one same letter that occurs more than once so that strings stay unchanged after one swap.\\nFor all other cases, return false.\\n*/\\nvar buddyStrings = function(s, goal) {\\n    if (s.length !== goal.length) {\\n        return false;\\n    }\\n    let swapIdx = [], chars = new Array(26).fill(0), sameCharTwice = false;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] !== goal[i]) {\\n            swapIdx.push(i);\\n            if (swapIdx.length > 2) return false;\\n        } else {\\n            let idx = s.charCodeAt(i) - 97;\\n            chars[idx]++;\\n            if (chars[idx] > 1) sameCharTwice = true;\\n        }\\n    }\\n    if (swapIdx.length === 2 &&\\n        s[swapIdx[0]] === goal[swapIdx[1]] &&\\n        s[swapIdx[1]] === goal[swapIdx[0]]) {\\n        return true;\\n    }\\n    if (swapIdx.length === 0 && sameCharTwice) {\\n        return true;\\n    }\\n    return false;\\n    // T.C: O(M), M = length of s\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3711705,
                "title": "easy-beginer-friendly-cpp-solution-beats-100-with-stepwise-detailed-explanation-no-set-no-hashmap",
                "content": "\\n# Approach\\n1. Check if the lengths of `s` and `goal` are different. If they are not equal, the strings cannot be made equal through a swap. Return `false` in this case.\\n\\n2. Check if the length of the strings is less than 2. If it is, there are not enough characters to perform a valid swap. Return `false` because we need at least two characters to swap.\\n\\n3. Check if the strings `s` and `goal` are equal. If they are equal, there is a possibility of forming a buddy string by swapping two identical characters. Iterate through the string and check if there are any duplicate characters. If there are, return `true` because swapping any two identical characters will not change the string.\\n\\n4. If the strings are not equal, iterate through the strings character by character and find the first and second differing indices. These indices represent the positions where the characters differ between `s` and `goal`.\\n\\n5. If there are more than two differing indices, it is not possible to make the strings equal with a single swap. Return `false` because we can only perform a single swap.\\n\\n6. Check if the characters at the first and second differing indices of `s` and `goal` can be swapped to make the strings equal. If swapping the characters at these indices results in the strings becoming equal, return `true`. Otherwise, return `false`.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\n - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s.size()<2) return false;\\n        \\n            if (s == goal) {\\n            for (int i = 0; i < s.length(); i++) {\\n                for (int j = i + 1; j < s.length(); j++) {\\n                    if (s[i] == s[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        int first=-1,second=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            \\n            if(s[i]!=goal[i])\\n            {\\n                if(first==-1)\\n                {\\n                    first=i;\\n                }\\n                else if(second==-1)\\n                {\\n                    second=i;\\n                }\\n                else return false;\\n            }\\n            \\n        }\\n        return (second != -1 && s[first] == goal[second] && s[second] == goal[first]);\\n    }\\n};\\n```\\n# Please upvote and feel free to ask if you face any difficulty in understanding",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s.size()<2) return false;\\n        \\n            if (s == goal) {\\n            for (int i = 0; i < s.length(); i++) {\\n                for (int j = i + 1; j < s.length(); j++) {\\n                    if (s[i] == s[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        int first=-1,second=-1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            \\n            if(s[i]!=goal[i])\\n            {\\n                if(first==-1)\\n                {\\n                    first=i;\\n                }\\n                else if(second==-1)\\n                {\\n                    second=i;\\n                }\\n                else return false;\\n            }\\n            \\n        }\\n        return (second != -1 && s[first] == goal[second] && s[second] == goal[first]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711680,
                "title": "7ms-c-two-pointers-easy-to-understand-859-buddy-strings",
                "content": "# 7ms | C++ | Two-Pointers | Easy to Understand | 859. Buddy Strings\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711095,
                "title": "brute-force-easy-and-simple-o-n-linear-complexity-unordered-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s==goal){\\n            unordered_map<char,int>m;\\n            for(auto a:s){\\n                m[a]++;\\n                if(m[a]>1)return true;\\n            }\\n            return false;\\n        }\\n        int count=0;\\n        int prev=-1;\\n        int curr=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                count++;\\n                if(prev==-1) prev=i;\\n                else curr=i;\\n            }\\n        }\\n        if(count!=2)return false;\\n        swap(s[prev],s[curr]);\\n        return s==goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        if(s==goal){\\n            unordered_map<char,int>m;\\n            for(auto a:s){\\n                m[a]++;\\n                if(m[a]>1)return true;\\n            }\\n            return false;\\n        }\\n        int count=0;\\n        int prev=-1;\\n        int curr=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                count++;\\n                if(prev==-1) prev=i;\\n                else curr=i;\\n            }\\n        }\\n        if(count!=2)return false;\\n        swap(s[prev],s[curr]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711093,
                "title": "c-stuck-noob-solution-beats-100-lol-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you pass all testcases in the first go, you must either be a **freak** or a **cheat**.\\nWell doesn\\'t matter, lemme explain my own thought process:\\n\\n- Count number of instances where `s[i]!=goal[i]`\\n- Each time `s[i]!=goal[i]`, store both unequal characters \\n    (Eg: `ab` & `ba`), then you\\'ll first store `{a,b}` and then `{b,a}`\\n\\nAfter doing this, you have 3 cases:\\n\\n- If $$instances \\u2260 2$$ then return false\\n- If $$instances = 2$$, check if:\\n<img src=\\'https://assets.leetcode.com/users/images/67b3b47a-3fc3-443f-a494-f7f45be8faf5_1688360971.7869503.png\\' width=\"200\"/>\\n- If $$instances = 0$$, like in case of `s=\"aa\"` and `goal=\"aa\"`,\\n    -> In this case, strings are same, if there is a character with frequency more than 1 (has duplicates), you can exchange the duplicates to get the same exact string!\\n\\n##### DONE, you have successfully understood the NOOB solution!\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkduplicate(vector<int>&freq){\\n        for(int i=0;i<26;i++)\\n            if(freq[i]>1)\\n                return true;\\n        return false;\\n    }\\n    bool buddyStrings(string s, string goal) {\\n        if(goal.length()!=s.length()) return false;\\n        vector<int> freq(26,0);\\n        vector<pair<char,char>> v;\\n        for(int i=0;i<s.length();i++){\\n            freq[s[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n                v.push_back({s[i],goal[i]});\\n        }\\n        if(v.size()==0) //same strings\\n            if(checkduplicate(freq)) return true;\\n        if(v.size()==2&&v[0].first==v[1].second&&v[1].first==v[0].second)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkduplicate(vector<int>&freq){\\n        for(int i=0;i<26;i++)\\n            if(freq[i]>1)\\n                return true;\\n        return false;\\n    }\\n    bool buddyStrings(string s, string goal) {\\n        if(goal.length()!=s.length()) return false;\\n        vector<int> freq(26,0);\\n        vector<pair<char,char>> v;\\n        for(int i=0;i<s.length();i++){\\n            freq[s[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n                v.push_back({s[i],goal[i]});\\n        }\\n        if(v.size()==0) //same strings\\n            if(checkduplicate(freq)) return true;\\n        if(v.size()==2&&v[0].first==v[1].second&&v[1].first==v[0].second)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711018,
                "title": "daily-coding-challenge-java-solution-using-hash-set-arraylist",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!= goal.length()){\\n            return false;\\n        }\\n        HashSet<Character> set=new HashSet<>();\\n        if(s.equals(goal)){\\n           for(char c:s.toCharArray()){\\n               set.add(c);\\n           }\\n           if(set.size()<s.length()){\\n               return true;\\n           }\\n           return false;\\n        }\\n        ArrayList<Integer> diff=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=goal.charAt(i)) {\\n                diff.add(i);\\n            }\\n        }\\n        if(diff.size()==2 && s.charAt(diff.get(0))==goal.charAt(diff.get(1)) &&  s.charAt(diff.get(1))==goal.charAt(diff.get(0)) ){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!= goal.length()){\\n            return false;\\n        }\\n        HashSet<Character> set=new HashSet<>();\\n        if(s.equals(goal)){\\n           for(char c:s.toCharArray()){\\n               set.add(c);\\n           }\\n           if(set.size()<s.length()){\\n               return true;\\n           }\\n           return false;\\n        }\\n        ArrayList<Integer> diff=new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=goal.charAt(i)) {\\n                diff.add(i);\\n            }\\n        }\\n        if(diff.size()==2 && s.charAt(diff.get(0))==goal.charAt(diff.get(1)) &&  s.charAt(diff.get(1))==goal.charAt(diff.get(0)) ){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710903,
                "title": "c-character-comparison-and-swapping-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon initial analysis of the code, here are my thoughts on how to solve the problem:\\n\\n1. The function `buddyStrings` takes two strings, `s` and `goal`, and determines if it is possible to swap two characters in `s` to make it equal to `goal`. The function returns a boolean value indicating whether this is possible.\\n\\n2. The first condition checks if the sizes of `s` and `goal` are different or if the size is 1. If either of these conditions is true, it immediately returns `false` because it is not possible to swap characters in these cases.\\n\\n3. The code uses two vectors, `different` and `ct`. The `different` vector stores the indices where the characters in `s` and `goal` are different. The `ct` vector is used to count the occurrences of each character in `s`.\\n\\n4. The loop iterates over each character in `s` and checks if it is different from the corresponding character in `goal`. If they are different, the index is added to the `different` vector. Otherwise, the count of that character in `s` is incremented in the `ct` vector. If a character occurs more than or equal to twice, the flag `f` is set to true.\\n\\n5. After the loop, several conditions are checked:\\n\\n   - If there are more than 2 different characters, it is not possible to swap two characters to make `s` equal to `goal`. In this case, the function returns `false`.\\n   - If there is only 1 different character, it is also not possible to perform the swap. The function returns `false`.\\n   - If there are no different characters (`different.size() == 0`), the function returns the value of `f`, which indicates whether there are duplicate characters in `s`.\\n\\n6. If the code reaches this point, it means there are exactly 2 different characters in `s`. The code swaps these characters in `s` using the indices stored in `different`.\\n\\n7. Finally, the code checks if the swapped string `s` is equal to `goal`. If they are equal, the function returns `true`; otherwise, it returns `false`.\\n\\nThese are my initial thoughts on how the code solves the problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Based on the provided code, the approach to solving the problem can be summarized as follows:\\n\\n1. The initial checks ensure that the sizes of the input strings are compatible for swapping characters and that they are not trivial cases where swapping is not possible.\\n\\n2. The code iterates through each character of the strings `s` and `goal`. It identifies the indices where the characters differ and stores them in the `different` vector. Additionally, it keeps track of the count of each character in `s` using the `ct` vector and sets the flag `f` if any character occurs more than or equal to twice.\\n\\n3. After the loop, several conditions are checked to determine if swapping is possible or not. If there are more than 2 different characters or if there is only 1 different character, it is not possible to perform the swap, and the function returns `false`. If there are no different characters, the function returns the value of the `f` flag, indicating whether there are duplicate characters in `s`.\\n\\n4. If there are exactly 2 different characters, the code swaps these characters in `s` using the indices stored in the `different` vector.\\n\\n5. Finally, the code checks if the swapped string `s` is equal to the `goal` string. If they are equal, the function returns `true`; otherwise, it returns `false`.\\n\\nOverall, the approach involves identifying the differences between the input strings, handling various edge cases, and determining if the strings can be made equal by swapping two characters.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Check if the sizes of the strings are different or if the size is 1\\n        // In such cases, it\\'s not possible to swap characters to make the strings equal\\n        if (s.size() != goal.size() || s.size() == 1)\\n            return false;\\n        \\n        vector<int> different; // Store the indices where the characters are different\\n        vector<int> ct(26, 0); // Store the count of each character in string s\\n        bool f = false; // Flag to check if there are duplicate characters in string s\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i])\\n                different.push_back(i); // Add index to the different vector\\n            else {\\n                ct[s[i] - \\'a\\']++; // Increment the count of character s[i]\\n                if (ct[s[i] - \\'a\\'] >= 2)\\n                    f = true; // Set flag to true if character s[i] is repeated\\n            }\\n        }\\n        \\n        if (different.size() > 2)\\n            return false; // If there are more than 2 different characters, swapping is not possible\\n        \\n        if (different.size() == 1)\\n            return false; // If there is only 1 different character, swapping is not possible\\n        \\n        if (different.size() == 0)\\n            return f; // If there are no different characters, return whether there are duplicate characters\\n        \\n        // There are exactly 2 different characters, so swap them in string s\\n        int in1, in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1], s[in2]);\\n        \\n        // Check if the swapped string is equal to the goal string\\n        return s == goal;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/7ab32acb-7f72-480e-817d-8eb12f49e71b_1688358519.6356623.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // Check if the sizes of the strings are different or if the size is 1\\n        // In such cases, it\\'s not possible to swap characters to make the strings equal\\n        if (s.size() != goal.size() || s.size() == 1)\\n            return false;\\n        \\n        vector<int> different; // Store the indices where the characters are different\\n        vector<int> ct(26, 0); // Store the count of each character in string s\\n        bool f = false; // Flag to check if there are duplicate characters in string s\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i])\\n                different.push_back(i); // Add index to the different vector\\n            else {\\n                ct[s[i] - \\'a\\']++; // Increment the count of character s[i]\\n                if (ct[s[i] - \\'a\\'] >= 2)\\n                    f = true; // Set flag to true if character s[i] is repeated\\n            }\\n        }\\n        \\n        if (different.size() > 2)\\n            return false; // If there are more than 2 different characters, swapping is not possible\\n        \\n        if (different.size() == 1)\\n            return false; // If there is only 1 different character, swapping is not possible\\n        \\n        if (different.size() == 0)\\n            return f; // If there are no different characters, return whether there are duplicate characters\\n        \\n        // There are exactly 2 different characters, so swap them in string s\\n        int in1, in2;\\n        in1 = different[0];\\n        in2 = different[1];\\n        swap(s[in1], s[in2]);\\n        \\n        // Check if the swapped string is equal to the goal string\\n        return s == goal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710770,
                "title": "c-easy-solution-using-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooping through the string and storing frequency count of each character, if its note same return false. While looping checking if there are more than 2 places with different characters, then return false. Finally checking if there is difference if exactly 2 places then return true and if difference is of 0 places then checking if there is a character with frequency >=2 , if yes return true else return false\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length()!=goal.length())\\n        return false;\\n        vector<int> temp(26,0);\\n        vector<int> temp2(26,0);\\n        int diff=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n            temp2[goal[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n            diff++;\\n\\n            if(diff>2)\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp[i]!=temp2[i])\\n            return false;\\n        }\\n        if(diff==2)\\n        return true;\\n        else\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(temp[i]==0)\\n                continue;\\n                if(temp[i]>=2)\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length()!=goal.length())\\n        return false;\\n        vector<int> temp(26,0);\\n        vector<int> temp2(26,0);\\n        int diff=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n            temp2[goal[i]-\\'a\\']++;\\n            if(s[i]!=goal[i])\\n            diff++;\\n\\n            if(diff>2)\\n            return false;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(temp[i]!=temp2[i])\\n            return false;\\n        }\\n        if(diff==2)\\n        return true;\\n        else\\n        {\\n            for(int i=0;i<26;i++)\\n            {\\n                if(temp[i]==0)\\n                continue;\\n                if(temp[i]>=2)\\n                return true;\\n            }\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710761,
                "title": "simple-c-100-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return 0;\\n        int c=0;\\n        unordered_map<char,int> m;\\n        char prev1=\\'@\\',prev2=\\'@\\';\\n        int t=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) t++;\\n            if(s[i]!=goal[i] && ((goal[i]==prev1 && s[i]==prev2) || prev1==\\'@\\')){\\n                c++;\\n                prev1=s[i];\\n                prev2=goal[i];\\n            } \\n            m[s[i]]++;\\n        }\\n        int flag=0;\\n        for(auto i:m){\\n            if(i.second>1) {flag=1;\\n            break;\\n        }\\n        }\\n        if((c==2 && t==2) || (t==0 && flag==1)) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return 0;\\n        int c=0;\\n        unordered_map<char,int> m;\\n        char prev1=\\'@\\',prev2=\\'@\\';\\n        int t=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) t++;\\n            if(s[i]!=goal[i] && ((goal[i]==prev1 && s[i]==prev2) || prev1==\\'@\\')){\\n                c++;\\n                prev1=s[i];\\n                prev2=goal[i];\\n            } \\n            m[s[i]]++;\\n        }\\n        int flag=0;\\n        for(auto i:m){\\n            if(i.second>1) {flag=1;\\n            break;\\n        }\\n        }\\n        if((c==2 && t==2) || (t==0 && flag==1)) return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710429,
                "title": "c-easiest-2-approaches-map-two-pointers",
                "content": "# Approach\\n- Using hash function \\n    - check hash and swap \\n- Two pointers \\n    - Loop high and low and swap and check if them don\\'t match \\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char,int>mp;\\n        for(int i =0; i<s.length(); i++) mp[s[i]] = i;\\n        for(int i =0; i<goal.length(); i++){\\n            if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Two Pointers \\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return 0;\\n        if(s == goal) return (set<char>(s.begin(), s.end())).size()<s.length();\\n        int low =0, high = s.length()-1;\\n        while(low<=high && s[low] == goal[low]){\\n            low++;\\n        }\\n        while(high >=0 && s[high]== goal[high]){\\n            high--;\\n        }\\n        if(low<high){\\n            swap(s[low], s[high]);\\n        }\\n        return s==goal;\\n    }\\n};\\n```\\n\\nPlease Upvote \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F \\uD83E\\uDD1C\\uD83E\\uDD1B",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char,int>mp;\\n        for(int i =0; i<s.length(); i++) mp[s[i]] = i;\\n        for(int i =0; i<goal.length(); i++){\\n            if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return 0;\\n        if(s == goal) return (set<char>(s.begin(), s.end())).size()<s.length();\\n        int low =0, high = s.length()-1;\\n        while(low<=high && s[low] == goal[low]){\\n            low++;\\n        }\\n        while(high >=0 && s[high]== goal[high]){\\n            high--;\\n        }\\n        if(low<high){\\n            swap(s[low], s[high]);\\n        }\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710369,
                "title": "daily-leetcoding-challenge-july-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/buddy-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/buddy-strings/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3645284,
                "title": "very-easy-approach-in-c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char, int> mp;\\n        for(int i=0;i<s.length();i++) mp[s[i]] = i;\\n        for(int i=0;i<goal.length();i++){\\n            //if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Upvote if helped",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        unordered_map<char, int> mp;\\n        for(int i=0;i<s.length();i++) mp[s[i]] = i;\\n        for(int i=0;i<goal.length();i++){\\n            //if(mp.find(goal[i]) == mp.end()) return false;\\n            if(mp[goal[i]] != i){\\n                swap(s[i], s[mp[goal[i]]]);\\n                if(s == goal) return true;\\n                swap(s[i], s[mp[goal[i]]]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884790,
                "title": "java-easiest-solution-posiible",
                "content": "\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int m = s.length(), n = goal.length();\\n        if (m != n) {\\n            return false;\\n        }\\n        int diff = 0;\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            int a = s.charAt(i), b = goal.charAt(i);\\n            ++cnt1[a - \\'a\\'];\\n            ++cnt2[b - \\'a\\'];\\n            if (a != b) {\\n                ++diff;\\n            }\\n        }\\n        boolean f = false;\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt1[i] != cnt2[i]) {\\n                return false;\\n            }\\n            if (cnt1[i] > 1) {\\n                f = true;\\n            }\\n        }\\n        return diff == 2 || (diff == 0 && f);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        int m = s.length(), n = goal.length();\\n        if (m != n) {\\n            return false;\\n        }\\n        int diff = 0;\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        for (int i = 0; i < n; ++i) {\\n            int a = s.charAt(i), b = goal.charAt(i);\\n            ++cnt1[a - \\'a\\'];\\n            ++cnt2[b - \\'a\\'];\\n            if (a != b) {\\n                ++diff;\\n            }\\n        }\\n        boolean f = false;\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt1[i] != cnt2[i]) {\\n                return false;\\n            }\\n            if (cnt1[i] > 1) {\\n                f = true;\\n            }\\n        }\\n        return diff == 2 || (diff == 0 && f);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347659,
                "title": "python-easy-explanation",
                "content": "Success\\nDetails \\nRuntime: 35 ms, faster than **91.06%** of Python3 online submissions.\\nMemory Usage: 14.1 MB, less than **96.20%** of Python3 online submissions.\\n\\n1. If Length of s and goal is not same the it is not possible to make s equal to goal\\n\\n2. If s and goal are already same then there should be atleast on element in s which apprears two times so that we can replace that element. If no such element is present then return False\\n3. Finally we append all the indexes for wich elemnts of s is not equal to element of goal\\n4. If there are more than 2 such index return False since we are allowed to do only on swap.\\n5. If the element of s present at index l[0] is equal to element of goal present at index [l[1]] and vice versa return true\\n\\n***Leave an upvote if this helps***\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        l=[]\\n        if len(s)!=len(goal):\\n            return False\\n        if s==goal and len(set(s))<len(s):\\n            return True\\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                l.append(i)\\n        if len(l)==2 and s[l[0]]==goal[l[1]] and s[l[1]]==goal[l[0]]:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        l=[]\\n        if len(s)!=len(goal):\\n            return False\\n        if s==goal and len(set(s))<len(s):\\n            return True\\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                l.append(i)\\n        if len(l)==2 and s[l[0]]==goal[l[1]] and s[l[1]]==goal[l[0]]:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363721,
                "title": "easily-understandable-c-solution",
                "content": "``\\nMost important point: One swap is necessary in this question...\\nFirstly we sort both the strings ,if they aren\\'t equal then there\\'s no chance of getting the same string by swapping as well ,so we return false;\\nthen we check for the no.of elements at corresponding indices which are different from one another,if it becomes 2 then we can swap s string once  to become same as goal...\\nif count is greater than 2 then there is no way we can convert s into goal just by performing one swap so it will obviously be false;\\nOnly one catch that is present is if we are given two equal strings e.g s=\"aabc\" goal=\"aabc\" the  count will be 0 but after swapping a with a we will be having the same string,hence we have to return true and that is why i have taken map to track if any element is repeating...\\nWe can\\'t return count<=2, because in case of s=\"ab\" goal=\"ab\" we have to return false because one swap is necessary and we can\\'t perform a swap in ab to make it equal to ab and henceforth we can\\'t return count<=2. \\n        \\n    \\n\\t\\n\\tstring s1=s;\\n    string s2=goal;\\n\\tsort(s1.begin(),s1.end());    \\n    sort(s2.begin(),s2.end());    \\n    map<int,int>m;\\n        \\n    if(s1!=s2){\\n        return false;\\n    }    \\n    int count=0; \\n    bool d=false;\\n    for(int i=0;i<s.size();i++){\\n    if(s[i]!=goal[i]){\\n    count++;\\n    }    \\n    m[s[i]]++;\\n    if(m[s[i]]==2){\\n    d=true;    \\n    }    \\n        \\n    }\\n        \\n        if(count==0&&d==true){\\n            return true;\\n        }\\n        return count==2;",
                "solutionTags": [],
                "code": "``\\nMost important point: One swap is necessary in this question...\\nFirstly we sort both the strings ,if they aren\\'t equal then there\\'s no chance of getting the same string by swapping as well ,so we return false;\\nthen we check for the no.of elements at corresponding indices which are different from one another,if it becomes 2 then we can swap s string once  to become same as goal...\\nif count is greater than 2 then there is no way we can convert s into goal just by performing one swap so it will obviously be false;\\nOnly one catch that is present is if we are given two equal strings e.g s=\"aabc\" goal=\"aabc\" the  count will be 0 but after swapping a with a we will be having the same string,hence we have to return true and that is why i have taken map to track if any element is repeating...\\nWe can\\'t return count<=2, because in case of s=\"ab\" goal=\"ab\" we have to return false because one swap is necessary and we can\\'t perform a swap in ab to make it equal to ab and henceforth we can\\'t return count<=2. \\n        \\n    \\n\\t\\n\\tstring s1=s;\\n    string s2=goal;\\n\\tsort(s1.begin(),s1.end());    \\n    sort(s2.begin(),s2.end());    \\n    map<int,int>m;\\n        \\n    if(s1!=s2){\\n        return false;\\n    }    \\n    int count=0; \\n    bool d=false;\\n    for(int i=0;i<s.size();i++){\\n    if(s[i]!=goal[i]){\\n    count++;\\n    }    \\n    m[s[i]]++;\\n    if(m[s[i]]==2){\\n    d=true;    \\n    }    \\n        \\n    }\\n        \\n        if(count==0&&d==true){\\n            return true;\\n        }\\n        return count==2;",
                "codeTag": "Unknown"
            },
            {
                "id": 1281630,
                "title": "simple-easy-to-understand-c-code",
                "content": "```\\nbool buddyStrings(string s, string goal) \\n    {\\n        if(s.length()!=goal.length())  // if unequal length then return false \\n            return false;\\n        \\n        if(s==goal)\\n        {\\n            unordered_set<char> a=unordered_set<char>(s.begin(),s.end());  \\n            return a.size()<s.length();  // checking if string is madeup of same character eg. \" aa\" or not eg. \"ab\"\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)  //chech index where the character are unequal.\\n        {\\n            if(s[i]!=goal[i])    \\n            v.push_back(i);\\n        }\\n        \\n        return (v.size()==2 && s[v[0]]==goal[v[1]] && s[v[1]]==goal[v[0]]); \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string s, string goal) \\n    {\\n        if(s.length()!=goal.length())  // if unequal length then return false \\n            return false;\\n        \\n        if(s==goal)\\n        {\\n            unordered_set<char> a=unordered_set<char>(s.begin(),s.end());  \\n            return a.size()<s.length();  // checking if string is madeup of same character eg. \" aa\" or not eg. \"ab\"\\n        }\\n        \\n        vector<int> v;\\n        for(int i=0;i<s.length();i++)  //chech index where the character are unequal.\\n        {\\n            if(s[i]!=goal[i])    \\n            v.push_back(i);\\n        }\\n        \\n        return (v.size()==2 && s[v[0]]==goal[v[1]] && s[v[1]]==goal[v[0]]); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891116,
                "title": "c-efficient-solution-explained-100-time-10-space",
                "content": "I have to admit I lowered my guard and this tricky one threw a few tricky edge jabs in my face; I still managed to reach my goal - to solve it using as little extra variables/space as possible.\\n\\nWell, good experience and good learning then :)!\\n\\nOkay, first of all I declared just 2 support variables:\\n* `lenA` that, you guessed it, will store the length of the first string;\\n* `diff` that will store how many mismatches we found in the string and/or where (basically acting as 2 variables in 1, to save memory):\\n\\t* a negative value, like `-1`, the initial value, or `-2` means that we found an even number of mismatches (`0` or `2`, respectively);\\n\\t* a non-negative value, means we found a single mismatch and the value itself is the index of said difference among the 2 strings.\\n\\nNext step: getting rid of some edge cases, returning `false` when either:\\n* the 2 strings have different length;\\n* the 2 strings are too short (you cannot swap anything with less than 2 characters).\\n\\nThe first condition guarantees us that if we are proceeding, now we know both strings have the same size.\\n\\nAnd proceding we go, looping through each character with the index `i`, so that every time we find a mismatch between `a[i]` and `b[i]`, we go and check `diff`\\'s value:\\n* `-1` means that we did not find any mismatch so far, so we just updated it to be the `i`, storing where the mismatch happened;\\n* `-2` means we already found 2 mismatches, so this is the third and we just have to return `false`;\\n* a non negative value means we found one previous mismatch, so now we go and check:\\n\\t* if `a[diff] == b[i] && a[i] == b[diff]` it means that they values are no swappable, so again we can just return `false`;\\n\\t* otherwise we are fine and just update `diff` to `-2`.\\n\\nOnce the loop is done, we will return `true` if we either:\\n* found 2 mismatches (`diff == -2`), which is the ideal case;\\n* or we found 0 mismatches (`diff == -1`), but only if we had at least 2 equal characters we might have swapped, so only if `lenA > 26` (since having only lower case letters would imply that a greater length has to repeat characters) or if `unordered_set(begin(a), end(a)).size() != lenA` - note that this option to check all the characters is more expensive, but it gets lazy evaluated only when the other condition for `diff == -1` fails, so it never runs for long strings :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool buddyStrings(string &a, string &b) {\\n        // support variables\\n        int lenA = a.size(), diff = -1;\\n        // edge cases, out: different sizes or too short\\n        if (lenA != b.size() || lenA < 2) return false; \\n        for (int i = 0; i < lenA; i++) {\\n            // acting only when a difference is found\\n            if (a[i] != b[i]) {\\n                // checking if it is the first difference we found and in case storing i\\n                if (diff == -1) {\\n                    diff = i;\\n                }\\n                // exiting if it was the third mismatch\\n                else if (diff == -2) return false;\\n                // checking if it is a valid or invalid second match\\n                else {\\n                    // valid match\\n                    if (a[diff] == b[i] && a[i] == b[diff]) diff = -2;\\n                    // invalid match\\n                    else return false;\\n                }\\n            }\\n        }\\n        // checking if we found only 2 mismatches or if we found 1 and the string was\\n        // long enough or not made of all different characters\\n        return diff == -2 || diff == -1 && (lenA > 26 || unordered_set(begin(a), end(a)).size() != lenA);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool buddyStrings(string &a, string &b) {\\n        // support variables\\n        int lenA = a.size(), diff = -1;\\n        // edge cases, out: different sizes or too short\\n        if (lenA != b.size() || lenA < 2) return false; \\n        for (int i = 0; i < lenA; i++) {\\n            // acting only when a difference is found\\n            if (a[i] != b[i]) {\\n                // checking if it is the first difference we found and in case storing i\\n                if (diff == -1) {\\n                    diff = i;\\n                }\\n                // exiting if it was the third mismatch\\n                else if (diff == -2) return false;\\n                // checking if it is a valid or invalid second match\\n                else {\\n                    // valid match\\n                    if (a[diff] == b[i] && a[i] == b[diff]) diff = -2;\\n                    // invalid match\\n                    else return false;\\n                }\\n            }\\n        }\\n        // checking if we found only 2 mismatches or if we found 1 and the string was\\n        // long enough or not made of all different characters\\n        return diff == -2 || diff == -1 && (lenA > 26 || unordered_set(begin(a), end(a)).size() != lenA);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890941,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //Base case\\n        if(A.length() != B.length()){\\n            return false;\\n        }\\n        //Two Cases :\\n        //Case 1: if both strings are same\\n        if(A.equals(B)){\\n            //get character count\\n            int[] count = new int[26];\\n            for(char c : A.toCharArray()){\\n                count[c - \\'a\\']++;\\n            }\\n            //check if there are characters of frequency greater than 1\\n            //Eg : A = aaaabc , B = aaaabc\\n            //since freq(a) > 1 , we can swap two a\\'s\\n            for(int freq : count){\\n                if(freq > 1){\\n                    return true;\\n                }\\n            }\\n            //no character has frequency greater than 1\\n            //Eg : A = abcd , B = abcd\\n            return false;\\n        }\\n        //Case 2 : if A and B are not equal\\n        else{\\n            //get pos of elements to swap\\n            int first = -1;\\n            int second = -1;\\n            for(int i=0;i<A.length();i++){\\n                if(A.charAt(i) != B.charAt(i)){\\n                    //check if we filled first index\\n                    if(first == -1){\\n                        first = i;\\n                    }\\n                    //check if we filled first index\\n                    else if(second == -1){\\n                        second = i;\\n                    }\\n                    //both first and second are filled and there exists a third diff\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            //check if second pos is not filled\\n            if(second == -1){\\n                return false;\\n            }\\n            //check id characters at pos are same\\n            return (A.charAt(first) == B.charAt(second)) && (A.charAt(second) == B.charAt(first));\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        //Base case\\n        if(A.length() != B.length()){\\n            return false;\\n        }\\n        //Two Cases :\\n        //Case 1: if both strings are same\\n        if(A.equals(B)){\\n            //get character count\\n            int[] count = new int[26];\\n            for(char c : A.toCharArray()){\\n                count[c - \\'a\\']++;\\n            }\\n            //check if there are characters of frequency greater than 1\\n            //Eg : A = aaaabc , B = aaaabc\\n            //since freq(a) > 1 , we can swap two a\\'s\\n            for(int freq : count){\\n                if(freq > 1){\\n                    return true;\\n                }\\n            }\\n            //no character has frequency greater than 1\\n            //Eg : A = abcd , B = abcd\\n            return false;\\n        }\\n        //Case 2 : if A and B are not equal\\n        else{\\n            //get pos of elements to swap\\n            int first = -1;\\n            int second = -1;\\n            for(int i=0;i<A.length();i++){\\n                if(A.charAt(i) != B.charAt(i)){\\n                    //check if we filled first index\\n                    if(first == -1){\\n                        first = i;\\n                    }\\n                    //check if we filled first index\\n                    else if(second == -1){\\n                        second = i;\\n                    }\\n                    //both first and second are filled and there exists a third diff\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            //check if second pos is not filled\\n            if(second == -1){\\n                return false;\\n            }\\n            //check id characters at pos are same\\n            return (A.charAt(first) == B.charAt(second)) && (A.charAt(second) == B.charAt(first));\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762258,
                "title": "java-solution-clear-explanation-simple-fast-directly-check-swap",
                "content": "```\\n/*\\nsituation1:A B different length\\nsituation2:same length&&A equals to B\\n    if A contains the duplicate letters,after swapping the duplicate letters,A and B are Buddy Strings.\\nsituation3: the rest: same length,A differ from B    \\n    the ONLY true situation here: A only have 2 different char,A equals to B after swap.                        \\n*/\\n\\nclass Solution {\\n     public boolean buddyStrings(String A, String B) {\\n        \\n        int A_length = A.length();\\n        char Achar[] = A.toCharArray();\\n         \\n        if (A_length != B.length())             //situation1\\n            return false;\\n        \\n        if(A.equals(B)){                        //situation2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tSet set1=new HashSet();                   \\n\\t\\t\\t\\tfor(int i=0;i < A_length ;i++){        \\n                if(set1.contains(Achar[i]))              \\n                    return true;                \\n                else\\n                    set1.add(Achar[i]);        \\n            }     \\n            return false;\\n        }\\n                                                \\n                                             // situation3: the rest :\\n        char Bchar[] = B.toCharArray();\\n        char A1=0,B1=0;                       // when the 1st Discrepancy happen,A1 is Achar[i], B1 is Bchar[i]\\n        int j=0;                              //j :count the number of Achar[i]!=Bchar[i]\\n        for(int i=0; i< A_length &&j<3;i++){                \\n           if(Achar[i]!=Bchar[i]){                   \\n                j++;                                           \\n               if(j==1){\\n                    A1=Achar[i];               // record Achar[i] and Bchar[i] in A1, B1.\\n                    B1=Bchar[i];                             \\n               }                                                                             \\n               if(j==2 && (Achar[i]!=B1 || Bchar[i]!=A1) )  //when the 2st Discrepancy happen :            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                        //the only false situation here when j==2\\n\\t\\t\\t\\t\\treturn false;\\t\\t       \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t          \\n           }            \\n        }                       \\n        return j==2;      //the rest situation:\\n\\t\\t\\t\\t\\t\\t\\t    //all the other j==2 situation is true after loop,\\n\\t\\t\\t\\t\\t\\t\\t\\t//j=1 false, because unable to swap.\\n                                //j>2 false, because we can swap only 2 letters.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nsituation1:A B different length\\nsituation2:same length&&A equals to B\\n    if A contains the duplicate letters,after swapping the duplicate letters,A and B are Buddy Strings.\\nsituation3: the rest: same length,A differ from B    \\n    the ONLY true situation here: A only have 2 different char,A equals to B after swap.                        \\n*/\\n\\nclass Solution {\\n     public boolean buddyStrings(String A, String B) {\\n        \\n        int A_length = A.length();\\n        char Achar[] = A.toCharArray();\\n         \\n        if (A_length != B.length())             //situation1\\n            return false;\\n        \\n        if(A.equals(B)){                        //situation2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tSet set1=new HashSet();                   \\n\\t\\t\\t\\tfor(int i=0;i < A_length ;i++){        \\n                if(set1.contains(Achar[i]))              \\n                    return true;                \\n                else\\n                    set1.add(Achar[i]);        \\n            }     \\n            return false;\\n        }\\n                                                \\n                                             // situation3: the rest :\\n        char Bchar[] = B.toCharArray();\\n        char A1=0,B1=0;                       // when the 1st Discrepancy happen,A1 is Achar[i], B1 is Bchar[i]\\n        int j=0;                              //j :count the number of Achar[i]!=Bchar[i]\\n        for(int i=0; i< A_length &&j<3;i++){                \\n           if(Achar[i]!=Bchar[i]){                   \\n                j++;                                           \\n               if(j==1){\\n                    A1=Achar[i];               // record Achar[i] and Bchar[i] in A1, B1.\\n                    B1=Bchar[i];                             \\n               }                                                                             \\n               if(j==2 && (Achar[i]!=B1 || Bchar[i]!=A1) )  //when the 2st Discrepancy happen :            \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                        //the only false situation here when j==2\\n\\t\\t\\t\\t\\treturn false;\\t\\t       \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t          \\n           }            \\n        }                       \\n        return j==2;      //the rest situation:\\n\\t\\t\\t\\t\\t\\t\\t    //all the other j==2 situation is true after loop,\\n\\t\\t\\t\\t\\t\\t\\t\\t//j=1 false, because unable to swap.\\n                                //j>2 false, because we can swap only 2 letters.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456125,
                "title": "java-another-solution-with-explanation",
                "content": "2 cases for String to be buddy\\n-> only 2 unequal pairs in String which are inverted.\\n-> all equal pairs and a atleast a char with freq > 2 which we can swap\\n```\\npublic boolean buddyStrings(String A, String B) {\\n\\n\\tif(A.length()!=B.length()) return false;            //if length not equal Strings ain\\'t buddy\\n\\n\\tHashMap<Character, Character> hm = new HashMap();   //stores unequal char pairs\\n\\tint counts[] = new int[26], count = 0;              //counts will store frequency, count stores unequal char freq\\n\\n\\tfor(int i=0; i<A.length(); i++) {\\n\\t\\tchar a = A.charAt(i), b = B.charAt(i);\\n\\t\\tcounts[a-\\'a\\']++;                                //store counts of all characters in A (we just need a char with freq >2)\\n\\t\\tif(a!=b) {\\n\\t\\t\\tif(++count>2)                               //if count of unequal chars > 2 strings ain\\'t buddy\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\thm.put(a,b);    \\n\\t\\t}\\n\\t}\\n\\n\\tfor(Map.Entry<Character, Character> e : hm.entrySet()) \\n\\t\\treturn hm.get(e.getValue())==e.getKey();        //check if unequal pairs are inverted\\n\\n\\tboolean flag = false;\\n\\tfor(int i : counts)\\n\\t\\tif(i>=2) {                                      //check if any char occurs more than twice\\n\\t\\t\\tflag = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\treturn count==0 && flag;                            //check if no unequal pair and atleast a char with freq>2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean buddyStrings(String A, String B) {\\n\\n\\tif(A.length()!=B.length()) return false;            //if length not equal Strings ain\\'t buddy\\n\\n\\tHashMap<Character, Character> hm = new HashMap();   //stores unequal char pairs\\n\\tint counts[] = new int[26], count = 0;              //counts will store frequency, count stores unequal char freq\\n\\n\\tfor(int i=0; i<A.length(); i++) {\\n\\t\\tchar a = A.charAt(i), b = B.charAt(i);\\n\\t\\tcounts[a-\\'a\\']++;                                //store counts of all characters in A (we just need a char with freq >2)\\n\\t\\tif(a!=b) {\\n\\t\\t\\tif(++count>2)                               //if count of unequal chars > 2 strings ain\\'t buddy\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\thm.put(a,b);    \\n\\t\\t}\\n\\t}\\n\\n\\tfor(Map.Entry<Character, Character> e : hm.entrySet()) \\n\\t\\treturn hm.get(e.getValue())==e.getKey();        //check if unequal pairs are inverted\\n\\n\\tboolean flag = false;\\n\\tfor(int i : counts)\\n\\t\\tif(i>=2) {                                      //check if any char occurs more than twice\\n\\t\\t\\tflag = true;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\treturn count==0 && flag;                            //check if no unequal pair and atleast a char with freq>2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713901,
                "title": "set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(goal.size() != n) return false;\\n\\n       if(s == goal) {\\n           unordered_set<char> seen;\\n           for(char c : s) {\\n               if(seen.find(c) != seen.end()) return true;\\n               seen.insert(c);\\n           }\\n           return false;\\n       }\\n\\n       vector<int> idx;\\n       for(int i=0; i<n; i++) {\\n           if(s[i] != goal[i]) idx.push_back(i);\\n       }\\n\\n       if(idx.size() == 2) {\\n           if(s[idx[0]] == goal[idx[1]] && s[idx[1]] == goal[idx[0]]) return true;\\n       }\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(goal.size() != n) return false;\\n\\n       if(s == goal) {\\n           unordered_set<char> seen;\\n           for(char c : s) {\\n               if(seen.find(c) != seen.end()) return true;\\n               seen.insert(c);\\n           }\\n           return false;\\n       }\\n\\n       vector<int> idx;\\n       for(int i=0; i<n; i++) {\\n           if(s[i] != goal[i]) idx.push_back(i);\\n       }\\n\\n       if(idx.size() == 2) {\\n           if(s[idx[0]] == goal[idx[1]] && s[idx[1]] == goal[idx[0]]) return true;\\n       }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713851,
                "title": "potd-buddy-strings-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlways try to solve by brute force approach and then go for optimal solution but in this case test case is so high so it causes TLE.\\nSo I try with help of Set and then a vector to solve this question.\\nI hope you will love it.\\nAny Suggestion will be appreciated. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // TLE SOLUTION:\\n        // for(int i=0;i<s.size();i++){\\n        //     for(int j=i+1;j<s.size();j++){\\n        //         swap(s[i],s[j]);\\n        //         if(s==goal) return true;\\n        //         else swap(s[i],s[j]);\\n        //     }\\n        // }\\n        // return false;\\n\\n      if(s.size()!=goal.size() || s.size()<=1) {\\n          return false;\\n      }\\n      if(s==goal){\\n      set<char>st(s.begin(),s.end());\\n      return  st.size()<s.size();\\n      }\\n      vector<int>v;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]!=goal[i]){\\n              v.push_back(i);\\n          }\\n      }\\n      if(v.size()!=2) {\\n      return false;\\n      }\\n        swap(s[v[0]],s[v[1]]);\\n        return s==goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // TLE SOLUTION:\\n        // for(int i=0;i<s.size();i++){\\n        //     for(int j=i+1;j<s.size();j++){\\n        //         swap(s[i],s[j]);\\n        //         if(s==goal) return true;\\n        //         else swap(s[i],s[j]);\\n        //     }\\n        // }\\n        // return false;\\n\\n      if(s.size()!=goal.size() || s.size()<=1) {\\n          return false;\\n      }\\n      if(s==goal){\\n      set<char>st(s.begin(),s.end());\\n      return  st.size()<s.size();\\n      }\\n      vector<int>v;\\n      for(int i=0;i<s.size();i++){\\n          if(s[i]!=goal[i]){\\n              v.push_back(i);\\n          }\\n      }\\n      if(v.size()!=2) {\\n      return false;\\n      }\\n        swap(s[v[0]],s[v[1]]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713803,
                "title": "simple-self-explanatory-code",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the size of the string is not same return false and if the strings are exactly same make a map and store all the characters if you find the same character which means one letter occurs two times so simply return true other wise return false and if the strings are same size and not equal maintain a counter and two strings a and b in which not same characters of s and goal will be appended then at end check if counter is 2 and string a is equal of reverse of b, if so return true..otherwise return false\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n       if(s==goal){\\n           unordered_map<char,int>mp;\\n           for(int i=0;i<s.size();i++){\\n               if(mp.find(s[i])!=mp.end()){\\n                   return true;\\n               }\\n               mp[s[i]]++;\\n           }\\n           return false;\\n       }\\n       int mini = min(s.size(),goal.size());\\n       int ct = 0;\\n       int ct1=0;\\n       string a=\"\";\\n       string b=\"\";\\n       for(int i=0;i<mini;i++){\\n           if(s[i]!=goal[i]){\\n               a=a+s[i];\\n               b=b+goal[i];\\n               ct++;\\n           }\\n\\n       }\\n       reverse(b.begin(),b.end());\\n       if(ct==2 && a==b) return true;\\n       return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n       if(s==goal){\\n           unordered_map<char,int>mp;\\n           for(int i=0;i<s.size();i++){\\n               if(mp.find(s[i])!=mp.end()){\\n                   return true;\\n               }\\n               mp[s[i]]++;\\n           }\\n           return false;\\n       }\\n       int mini = min(s.size(),goal.size());\\n       int ct = 0;\\n       int ct1=0;\\n       string a=\"\";\\n       string b=\"\";\\n       for(int i=0;i<mini;i++){\\n           if(s[i]!=goal[i]){\\n               a=a+s[i];\\n               b=b+goal[i];\\n               ct++;\\n           }\\n\\n       }\\n       reverse(b.begin(),b.end());\\n       if(ct==2 && a==b) return true;\\n       return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713261,
                "title": "python-solution-beats-70",
                "content": "# Intuition\\nWhen the problem mentions swapping two characters in a string to make it equal to another string, it\\'s clear that the two strings must have almost the same characters. There are two scenarios where this is possible: \\n1. The strings are already equal, and there is at least one character that occurs more than once (so that we can swap it with itself).\\n2. The strings have exactly two characters at different positions, and swapping them makes the strings equal.\\n\\n# Approach\\n1. If the lengths of `s` and `goal` are different, we can immediately return `False` because it\\'s impossible for them to be equal.\\n2. If `s` is equal to `goal`, check if there is at least one character that occurs more than once in `s`. If so, return `True`; otherwise, return `False`.\\n3. If `s` is not equal to `goal`, iterate through the characters in `s` and `goal` and keep track of the indices where the characters are different.\\n4. If there are exactly two indices where the characters are different, check if swapping the characters at these indices in `s` would make `s` equal to `goal`. If so, return `True`; otherwise, return `False`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the length of the input strings. This is because we iterate through each character in the strings once.\\n- Space complexity: $$O(1)$$, because the extra space used by the `diff_indices` list is constant (it can have at most 2 elements) and the set creation in the case where `s` is equal to `goal` also takes constant space.\\n\\n# Code\\n```python\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n        \\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        \\n        diff_indices = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diff_indices.append(i)\\n                if len(diff_indices) > 2:\\n                    return False\\n        \\n        return len(diff_indices) == 2 and s[diff_indices[0]] == goal[diff_indices[1]] and s[diff_indices[1]] == goal[diff_indices[0]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def buddyStrings(self, s, goal):\\n        if len(s) != len(goal):\\n            return False\\n        \\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        \\n        diff_indices = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diff_indices.append(i)\\n                if len(diff_indices) > 2:\\n                    return False\\n        \\n        return len(diff_indices) == 2 and s[diff_indices[0]] == goal[diff_indices[1]] and s[diff_indices[1]] == goal[diff_indices[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712774,
                "title": "no-map-and-no-vector-o-1-space-complexity-o-n-time-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy and Basic case making.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n       int n = s.size();\\n       if(s.size()!=goal.size()) return false;\\n       int s1=-1, s2=-1, cnt=0;\\n       for(int i = 0; i < s.size(); i++){\\n           if(s[i]!=goal[i] and s1==-1){\\n               s1=i;\\n               cnt++;\\n           }\\n           if(s[i]!=goal[i] and s1!=-1){\\n               s2=i;\\n               cnt++;\\n           }\\n       }\\n       if(cnt>3) return false;\\n       if(s==goal){\\n           sort(s.begin(),s.end());\\n           bool f = 0;\\n           for(int i = 1; i < n; i++) if(s[i]==s[i-1]){f=1;break;}\\n           return f;\\n       }\\n       if(s1==-1 and s2==-1) return true;\\n       cout<<cnt<<endl;\\n       cout<<s[s1]<<\" \"<<goal[s2]<<endl<<s[s2]<<\" \"<<goal[s1]<<endl;\\n       if(s[s1]==goal[s2] and s[s2]==goal[s1]) return true;\\n       return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n       int n = s.size();\\n       if(s.size()!=goal.size()) return false;\\n       int s1=-1, s2=-1, cnt=0;\\n       for(int i = 0; i < s.size(); i++){\\n           if(s[i]!=goal[i] and s1==-1){\\n               s1=i;\\n               cnt++;\\n           }\\n           if(s[i]!=goal[i] and s1!=-1){\\n               s2=i;\\n               cnt++;\\n           }\\n       }\\n       if(cnt>3) return false;\\n       if(s==goal){\\n           sort(s.begin(),s.end());\\n           bool f = 0;\\n           for(int i = 1; i < n; i++) if(s[i]==s[i-1]){f=1;break;}\\n           return f;\\n       }\\n       if(s1==-1 and s2==-1) return true;\\n       cout<<cnt<<endl;\\n       cout<<s[s1]<<\" \"<<goal[s2]<<endl<<s[s2]<<\" \"<<goal[s1]<<endl;\\n       if(s[s1]==goal[s2] and s[s2]==goal[s1]) return true;\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3712367,
                "title": "no-hashing-unique-and-simple-approach",
                "content": "# Intuition\\nJUST CHECK IN WHICH CASES WE CAN GET FALSE . HERE DIVIDE IT IN 4 PARTS . \\nIT BECOME SO EASY TO UNDERSTAND. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n First We can simply check the S and Goal if they have different size then return false.\\n1. PART : Store both The strings in 2 different strings thensort them and check whether they are Equal or Not .\\n    - Since IF they are not equal after sorting simply \\'S\\' Can Never change in \\'Goal\\' .\\n    - SO Return false if Not equal simply.\\n 1. PART : In this I am checking whether is there are any Repeating character.\\n     - If they have then simply make \\'flag=1\\' and break it will used further\\n>      - Eg : S= \"abba\" -- Goal= \"abba\" ; then this is TRUE\\n>      - But  S= \"abcd\" -- Goal= \"abcd\" ; then this is FALSE   \\n-  this Example will used to explain further.\\n\\n3. PART: In this Part we check with the original strings i.e How much character they differ.\\n    - If they differn more than 2 character then we cant Achieve our goal.\\n    - So make a count nd if > 2 then return False immediately.\\n1. Final Check : Sinc they all surpasses These Parts Means having .\\n - Same size , same characters  and Either 0 OR 2 characters are differing.\\n - If `cnt=2` means True simply and IF `cnt=0` then have to check **\\n>   Take  above eg: S= \"abba\" -- Goal= \"abba\"; Here `Cnt=0 but flag=1` So this is true becoz we can change indx(0,3) or index(1,2) we can achive goal.\\nBUT... S= \"abcd\" -- Goal= \"abcd\" ; `Cnt=0 but flag=0` so this is false since we cant change any indexes.\\n- Thts why i am mark a flag to to check whether have repeating char or not simply .\\n\\nDRY RUN WITH FEW MORE U WILL GET IT.\\n\\n**TIP : In comments**\\n   \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // if both have different size \\n        if(s.size()!=goal.size()) return false; \\n\\n        //---PART_1-------------------------------------------------------//\\n        string str1= s;\\n        string str2 = goal;\\n        sort(str1.begin(),str1.end());\\n        sort(str2.begin(),str2.end());\\n        if(str1 != str2) return false;\\n\\n        //---PART_2------------------------------------------------------//\\n        int flag=0;\\n        for(int i =0; i<str1.size()-1;i++)\\n        {\\n            if(str1[i]==str1[i+1])\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n\\n        //---PART3-------------------------------------------------------//\\n        int cnt=0;\\n        for(int i =0 ; i < s.size();i++)\\n        {\\n            if(s[i]!=goal[i])cnt++;\\n            if(cnt>2) return false;\\n        }\\n\\n        //---FINAL_CHECK----------------------------------------------------//\\n        if(cnt==0 && flag==0) return false;\\n\\n        return true;\\n    }\\n};\\n```\\n# **UPVOTE !**\\n![Screenshot 2023-07-23 001111.png](https://assets.leetcode.com/users/images/689f6326-8b12-4bda-a126-6a170b08225b_1690052016.6477008.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        // if both have different size \\n        if(s.size()!=goal.size()) return false; \\n\\n        //---PART_1-------------------------------------------------------//\\n        string str1= s;\\n        string str2 = goal;\\n        sort(str1.begin(),str1.end());\\n        sort(str2.begin(),str2.end());\\n        if(str1 != str2) return false;\\n\\n        //---PART_2------------------------------------------------------//\\n        int flag=0;\\n        for(int i =0; i<str1.size()-1;i++)\\n        {\\n            if(str1[i]==str1[i+1])\\n            {\\n                flag=1;\\n                break;\\n            }\\n        }\\n\\n        //---PART3-------------------------------------------------------//\\n        int cnt=0;\\n        for(int i =0 ; i < s.size();i++)\\n        {\\n            if(s[i]!=goal[i])cnt++;\\n            if(cnt>2) return false;\\n        }\\n\\n        //---FINAL_CHECK----------------------------------------------------//\\n        if(cnt==0 && flag==0) return false;\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712176,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.length() != goal.length() || s.length() <= 1) {\\n            return false;\\n        }\\n\\n        if (s == goal) {\\n            unordered_set<char> distinctChars(s.begin(), s.end());\\n            return distinctChars.size() < s.length();\\n        }\\n\\n        vector<int> index;\\n        for (int i=0;i<s.length();i++) {\\n            if (s[i] != goal[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n\\n        if (index.size() != 2) {\\n            return false;\\n        }\\n\\n        swap(s[index[0]], s[index[1]]);\\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711727,
                "title": "simple-kotlin-tc-o-n-sc-o-1",
                "content": "# Intuition\\nTo determine if two strings `s` and `goal` can be made equal by swapping two characters, we need to consider various cases. If `s` and `goal` are equal, we can swap two occurrences of the same character in `s` to make the strings equal. If `s` and `goal` have exactly two differing characters, we can check if swapping them would make the strings equal. By analyzing these cases, we can devise an approach to solve the problem efficiently.\\n\\n# Approach\\n1. If the lengths of `s` and `goal` are not equal or if they have fewer than two differing characters, return `false` immediately.\\n2. If `s` is equal to `goal`, check if there are any duplicate characters in `s` by converting it to a set. If the size of the set is smaller than the length of `s`, return `true` since we can swap two occurrences of the same character.\\n3. Find the indices of the differing characters in `s` and `goal` and store them in `diffIndices`.\\n4. If `diffIndices` has more than two or fewer than two elements, return `false`.\\n5. Check if swapping the characters at `diffIndices[0]` and `diffIndices[1]` in `s` would make it equal to `goal`. If the characters can be swapped successfully, return `true`; otherwise, return `false`.\\n\\n# Edge Cases\\nThe solution handles the following edge cases:\\n- If `s` and `goal` have lengths that are not equal, the function returns `false` immediately.\\n- If `s` and `goal` have lengths less than 2, the function returns `false` since we need at least two differing characters to swap.\\n- If `s` is equal to `goal`, the function checks if there are duplicate characters in `s` and returns `true` if there are since we can swap two occurrences of the same character.\\n\\n# Algorithm\\n1. Check the lengths of `s` and `goal` and return `false` if they are not equal or if the length is less than 2.\\n2. If `s` is equal to `goal`, convert `s` to a set and return `true` if the size of the set is smaller than the length of `s`.\\n3. Initialize an array `diffIndices` of size 2 to store the indices of the differing characters.\\n4. Iterate through the characters of `s` and `goal` simultaneously.\\n    - If the characters at the current index differ, store the index in `diffIndices` and increment `diffCount`.\\n    - If `diffCount` exceeds 2, return `false`.\\n5. If `diffCount` is not equal to 2, return `false`.\\n6. Get the values at indices 0 and 1 from `diffIndices` as `index1` and `index2`.\\n7. Return `true` if swapping the characters at `index1` and `index2` in `s` would make it equal to `goal`; otherwise, return `false`.\\n\\n\\n# Complexity\\n**Time Complexity:** $$O(n)$$\\nThe time complexity of this solution is $$O(n)$$, where n is the length of the input strings `s` and `goal`. This is because we iterate through the strings once to find differing characters and perform constant-time operations for comparisons.\\n\\n**Space Complexity:** $$O(1)$$\\nThe space complexity is $$O(1)$$ since we use a fixed-size array and a constant amount of extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length || s.length < 2) {\\n            return false\\n        }\\n\\n        if (s == goal) {\\n            val charSet = s.toSet()\\n            return charSet.size < s.length\\n        }\\n\\n        val diffIndices = IntArray(2)\\n        var diffCount = 0\\n\\n        for (i in s.indices) {\\n            if (s[i] != goal[i]) {\\n                if (diffCount >= 2) {\\n                    return false\\n                }\\n                diffIndices[diffCount] = i\\n                diffCount++\\n            }\\n        }\\n\\n        if (diffCount != 2) {\\n            return false\\n        }\\n\\n        val (index1, index2) = diffIndices\\n\\n        return s[index1] == goal[index2] && s[index2] == goal[index1]\\n    }\\n}\\n\\n```\\n\\n# Conclusion:\\nThe solution uses a systematic approach to determine if two strings can be made equal by swapping two characters. It handles different cases efficiently and has a linear time complexity. By following the provided algorithm and code, the `buddyStrings` problem can be solved effectively.\\n\\n\\n## \\uD83D\\uDC4D Please upvote this solution on LeetCode if you found it helpful! \\uD83D\\uDE4C\\uD83D\\uDCAF\\uD83D\\uDD25",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length || s.length < 2) {\\n            return false\\n        }\\n\\n        if (s == goal) {\\n            val charSet = s.toSet()\\n            return charSet.size < s.length\\n        }\\n\\n        val diffIndices = IntArray(2)\\n        var diffCount = 0\\n\\n        for (i in s.indices) {\\n            if (s[i] != goal[i]) {\\n                if (diffCount >= 2) {\\n                    return false\\n                }\\n                diffIndices[diffCount] = i\\n                diffCount++\\n            }\\n        }\\n\\n        if (diffCount != 2) {\\n            return false\\n        }\\n\\n        val (index1, index2) = diffIndices\\n\\n        return s[index1] == goal[index2] && s[index2] == goal[index1]\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711591,
                "title": "kotlin-use-pair",
                "content": "# Intuition\\n1. Compares two strings and stores the different characters in the Pair List.\\n2. Check size of Pair List\\n2.1 if size is 0 then Checks if a string has the same character.\\n2.2 if size is 1 then impossible.\\n2.3 if size is 2 then Cross compare first and second of two pairs.\\n\\n# Code\\n```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if(s.length != goal.length) return false\\n        \\n        var list = mutableListOf<Pair<Char,Char>>()\\n        for(i in s.indices){\\n            if(s[i]!=goal[i]){\\n                list.add(Pair(s[i],goal[i]))\\n                if(list.size > 2) return false\\n            }\\n        }\\n        when(list.size){\\n            0-> {\\n                return (s.length != s.toSet().size)\\n                }\\n            1->{\\n                return false\\n            }\\n            2->{\\n                return (list[0].first == list[1].second && list[0].second == list[1].first)\\n            }\\n            \\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if(s.length != goal.length) return false\\n        \\n        var list = mutableListOf<Pair<Char,Char>>()\\n        for(i in s.indices){\\n            if(s[i]!=goal[i]){\\n                list.add(Pair(s[i],goal[i]))\\n                if(list.size > 2) return false\\n            }\\n        }\\n        when(list.size){\\n            0-> {\\n                return (s.length != s.toSet().size)\\n                }\\n            1->{\\n                return false\\n            }\\n            2->{\\n                return (list[0].first == list[1].second && list[0].second == list[1].first)\\n            }\\n            \\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711435,
                "title": "java-bitmask-o-1-space-o-n-time",
                "content": "# Explanation\\n\\nIt is a straight forward problem. This problem only has three cases:\\n\\n1. If the `lengths` of the strings are `unequal`, answer is `no`.\\n2. If the strings are already `equal` and all the `characters` are `unique` then answer is `no`, otherwise it is `yes`.\\n3. If the strings are `not equal` then we just have to check they `differ` at `exactly two indices` `i` and `j` such that :\\n\\n                    s[i] == goal[j] and s[j] == goal[i]\\n\\n    if this is `true`, answer is `yes` otherwise answer is `no`.\\n\\n\\nWe can use `bit masking` to check the above conditions efficiently without need of frequency array. Here is how :\\n\\n1. For checking if all characters are unique or not, we can take an `integer` and assign its `bits` to each `character`. We can assign the $1_{st}$ bit of the integer to `a`, the $2_{nd}$ bit to `b` and so on. If while assigning, if a bit was already set, this implies that we have found a duplicate.\\n\\n2. For checking the swap condition mentioned above, we can take `two integer`, one for string `s` and other for string `goal`. Also, we will need a `count` variable. Whenever the characters of both strings are `unequal` at an `index`, `increment` the `count` and also `set` the `bit` corresponding to the `characters` in the respective `integers`. Then we just have to check the `XOR` of these two integers. If it is `0` then answer is `yes`, else it is `no`.\\n\\n\\n\\n---\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)) {\\n            int mask = 0;\\n            for(int i = 0; i < s.length(); i ++) {\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask & ind) != 0) return true;\\n                mask |= ind;\\n            }\\n            return false;\\n        }\\n        int ct = 0;\\n        int mask1 = 0;\\n        int mask2 = 0;\\n        for(int i = 0; i < goal.length(); i ++) {\\n            if(goal.charAt(i) != s.charAt(i)) {\\n                ct ++;\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask1 & ind) != 0) return false;\\n                mask1 += ind;\\n                ind = 1 << (goal.charAt(i) - \\'a\\');\\n                if((mask2 & ind) != 0) return false;\\n                mask2 += ind;\\n            }\\n            if(ct > 2) return false;\\n        }\\n        if(ct != 2) return false;\\n        return (mask1 ^ mask2) == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)) {\\n            int mask = 0;\\n            for(int i = 0; i < s.length(); i ++) {\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask & ind) != 0) return true;\\n                mask |= ind;\\n            }\\n            return false;\\n        }\\n        int ct = 0;\\n        int mask1 = 0;\\n        int mask2 = 0;\\n        for(int i = 0; i < goal.length(); i ++) {\\n            if(goal.charAt(i) != s.charAt(i)) {\\n                ct ++;\\n                int ind = 1 << (s.charAt(i) - \\'a\\');\\n                if((mask1 & ind) != 0) return false;\\n                mask1 += ind;\\n                ind = 1 << (goal.charAt(i) - \\'a\\');\\n                if((mask2 & ind) != 0) return false;\\n                mask2 += ind;\\n            }\\n            if(ct > 2) return false;\\n        }\\n        if(ct != 2) return false;\\n        return (mask1 ^ mask2) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711122,
                "title": "easy-c-explained",
                "content": "If the strings are of different size then direct NO\\nFrom example 2 and 3, it\\'s clear that from equal strings you need atleast one repeating elements as swap operation is mandatory. \\nThen we count the number of different characters in a string. If the diffcount is equal to 2, then we can do a potential swap else the answer is direct NO.\\nIf difcount is 2, then you have to do operation such that after swapping they become equal, so to avoid complex solution, I directly store in two string and sorted them and if they are equal then answer is YES else NO.\\nEg: ab and ba, after sorting both strings become ab and they should be equal.\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string t) {\\n        int n=s.size(),m=t.size();\\n        if(m-n) return 0;\\n        if(s==t) {\\n            map<int,int> mp;\\n            for(auto x:s) mp[x]++;\\n            for(auto x:mp) if(x.second>1) return 1;\\n            return 0;\\n        }\\n        int dif=0;\\n        string s1,t1;\\n        for(auto i=0;i<n;i++) if(s[i]-t[i]) {\\n            dif++; s1+=s[i], t1+=t[i];\\n        }\\n        if(dif!=2) return 0;\\n        sort(s1.begin(),s1.end());\\n        sort(t1.begin(),t1.end());\\n        if(s1==t1) return 1;\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool buddyStrings(string s, string t) {\\n        int n=s.size(),m=t.size();\\n        if(m-n) return 0;\\n        if(s==t) {\\n            map<int,int> mp;\\n            for(auto x:s) mp[x]++;\\n            for(auto x:mp) if(x.second>1) return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3710746,
                "title": "c-solution-for-buddy-strings-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to identify whether it is possible to swap two letters in string s to obtain string goal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the lengths of s and goal are not equal or they are shorter than 2 characters, it is not possible to swap two letters, so the function returns false.\\n- If s is already equal to goal, we check if there are any repeated characters in s. If there are, we can swap them to obtain goal, so the function returns true.\\n- We iterate through s and goal simultaneously and keep track of the differing indices in the diffIndices list.\\n- If the number of differing indices is not exactly 2, it means that more than two letters need to be swapped, which is not allowed. So, the function returns false.\\n- Finally, we check if swapping the characters at the differing indices in s results in s being equal to goal. If it does, the function returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the input strings s and goal. This is because we iterate through the strings once to compare the characters and find the differing indices.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1), as it uses a constant amount of extra space to store the differing indices and the unique characters in s. The space used does not depend on the input size.\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if (s.Length != goal.Length || s.Length < 2 || goal.Length < 2)\\n        return false;\\n\\n        if (s.Equals(goal)) {\\n            // Check if there are any repeated characters in s\\n            HashSet<char> uniqueChars = new HashSet<char>(s);\\n            return uniqueChars.Count < s.Length;\\n        }\\n\\n        List<int> diffIndices = new List<int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (s[i] != goal[i])\\n                diffIndices.Add(i);\\n            if (diffIndices.Count > 2)\\n                return false;\\n        }\\n\\n        if (diffIndices.Count != 2)\\n            return false;\\n\\n        return s[diffIndices[0]] == goal[diffIndices[1]] && s[diffIndices[1]] == goal[diffIndices[0]];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if (s.Length != goal.Length || s.Length < 2 || goal.Length < 2)\\n        return false;\\n\\n        if (s.Equals(goal)) {\\n            // Check if there are any repeated characters in s\\n            HashSet<char> uniqueChars = new HashSet<char>(s);\\n            return uniqueChars.Count < s.Length;\\n        }\\n\\n        List<int> diffIndices = new List<int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            if (s[i] != goal[i])\\n                diffIndices.Add(i);\\n            if (diffIndices.Count > 2)\\n                return false;\\n        }\\n\\n        if (diffIndices.Count != 2)\\n            return false;\\n\\n        return s[diffIndices[0]] == goal[diffIndices[1]] && s[diffIndices[1]] == goal[diffIndices[0]];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710481,
                "title": "simple-approach-with-explaination-using-frequency-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere we calculate the frequency of both strings. \\n1. If there is difference in frequency then simply its not possible to form goal string. \\nexample s=\"aabc\" goal=\"abbc\"  -> false\\n2. now if frequencies are same, we must ensure that there is atleast one freq of char which is greater than 2 and the diff in string is 0.\\nexample s=\"abca\" goal=\"aacb\" -> true( diff==2 )\\nexample s=\"aabc\" goal=\"aabc\" -> true(diff==0 and cnt=true)\\n\\n\\n# Complexity\\n- Time complexity: O(N) Traversing the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) we use 2 constant size array so space complexity is constant.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        int diff=0;\\n        vector<int> freq1(26,0);\\n        vector<int> freq2(26,0);\\n\\n        for(int i=0;i<s.size();i++){\\n            char ch1= s[i];\\n            char ch2= goal[i];\\n            freq1[ch1-\\'a\\']++;\\n            freq2[ch2-\\'a\\']++;\\n        }\\n        \\n        bool cnt=false;\\n        for(int i=0;i<26;i++){\\n            if(freq1[i]!=freq2[i]) return false;\\n            if(freq1[i]>=2) cnt=true;\\n        }\\n\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) diff++;\\n        }\\n        return (diff==2  ||  (cnt==true && diff==0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()) return false;\\n        int diff=0;\\n        vector<int> freq1(26,0);\\n        vector<int> freq2(26,0);\\n\\n        for(int i=0;i<s.size();i++){\\n            char ch1= s[i];\\n            char ch2= goal[i];\\n            freq1[ch1-\\'a\\']++;\\n            freq2[ch2-\\'a\\']++;\\n        }\\n        \\n        bool cnt=false;\\n        for(int i=0;i<26;i++){\\n            if(freq1[i]!=freq2[i]) return false;\\n            if(freq1[i]>=2) cnt=true;\\n        }\\n\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]) diff++;\\n        }\\n        return (diff==2  ||  (cnt==true && diff==0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710459,
                "title": "set-approach-python-js-solution",
                "content": "Hello **Tenno Leetcoders**,\\n\\nFor this problem, we are given two strings `s` and `goal`, return `true` if you can swap `two letters` in `s` so the result is `equal` to `goal`, otherwise, return `false`.\\n\\n### Explanation\\n\\nThe problem wants us to determine whether it is possible to swap two letters in string `s` such that it will become equal to string `goal`. \\n\\nThere are three base cases we need to consider:\\n\\n 1) If the length of s and goal string are not equal, we can immediately return False/false as this will be impossible to make two unique strings equal by swapping their character\\n       \\n  2) If s is already equal to goal, like in example 2. We need to check if at least one character appears more than once in s That is because swapping two identical strings will not change their values. Therefore, we will be using Hashset to help us to compare the length of set characters in s with the length of s. If length of this set is less than the length of s, then there is at least one character that appears more than once in s.\\n  \\n      - Once we find at least one repeating character in s, it will return True/true as we can still perform a swap by choosing any two occurrences of the repeated characters. The result of s will remain the same, but it will satisfy the condition of being able to swap two letters\\n      \\n      - If there are no repeating characters is s, it will return False/false as it will be impossible to make a non-repeated string any different from itself by swapping the two letters \\n       \\n  3) Next we check if there are exactly two differing positions as swapping the characters at those positions will make s equal to goal. \\n  \\n      - IFF the first differing character position of `differences[0]` is equal to second differing character position `differences[1]` in reverse it will return True/true. Otherwise False/false\\n\\n\\n\\n# Code\\n**Python**\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i] ]\\n    \\n        if len(s) != len(goal): return\\n\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n\\n        if len(differences) == 2:\\n            return differences[0] == differences[1][::-1]\\n        \\n        return False\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {string} s\\n * @param {string} goal\\n * @return {boolean}\\n */\\nvar buddyStrings = function(s, goal) {\\n    let differences = []\\n    let sSet = new Set(s)\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] !== goal[i]) differences.push([s[i], goal[i]])\\n    }\\n\\n    if(s.length !== goal.length) return false\\n\\n    if(s === goal) return sSet.size < s.length\\n \\n    if(differences.length === 2) return differences[0].toString() === differences[1].reverse().toString()\\n    \\n    return false\\n};\\n```\\n### Time Complexity: O(n)\\n### Space Complexity: O(n)\\n\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i] ]\\n    \\n        if len(s) != len(goal): return\\n\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n\\n        if len(differences) == 2:\\n            return differences[0] == differences[1][::-1]\\n        \\n        return False\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string} goal\\n * @return {boolean}\\n */\\nvar buddyStrings = function(s, goal) {\\n    let differences = []\\n    let sSet = new Set(s)\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] !== goal[i]) differences.push([s[i], goal[i]])\\n    }\\n\\n    if(s.length !== goal.length) return false\\n\\n    if(s === goal) return sSet.size < s.length\\n \\n    if(differences.length === 2) return differences[0].toString() === differences[1].reverse().toString()\\n    \\n    return false\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710401,
                "title": "swift-explained-solution",
                "content": "# Approach\\n\\nFirst, if the strings lengths are not equal, no swap can help with that, return false.\\n\\nNext, find all differences between the strings.\\n\\nIf there are exactly two positions with non-matching symbols, check whether swapping characters on these two positions will make them equal.\\n\\nIf it turns out that there are no differences, it means that the strings are already equal\\u2026 but by the problem conditions we have to perform a swap. So we check if there are any repeating characters in `s`, so we can swap them without changing the string.\\n\\nThese are all cases where it\\'s possible to obtain equality by a single swap. For the rest, the answer is false.\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n## Code\\n```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs = s.indices.filter { s[$0] != goal[$0] }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\n```\\n\\n# Optimization of the above approach\\n\\nIt can be noted that if during the process of locating the differences their number exceeds 2, further search is not necessary, the answer is already unambiguously false.\\nSo, let\\'s implement the early termination for that case.\\nThe simplest would be just fill the `diffs` array in a loop, but let\\'s do it a little differently.\\nJust to show how one can break out of the execution of such functions as `map`, `filter`, `reduce`, where normally is no way to stop, we\\'ll calculate the differences with the `reduce` function using *exceptions* for early termination.\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\nGenerally speaking, the space complexity is $O(c)$, where $c$ is the amount of allowed symbols. As in our case the number of lowercase letters is limited to 26, we consider it a constant.\\n\\n```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs: [String.Index]\\n        do {\\n            diffs = try s.indices.reduce(into: [])\\n            {\\n                diffsArray, index in\\n                if s[index] != goal[index] { diffsArray.append(index) }\\n                if diffsArray.count > 2 { throw \"Too many diffs\" }\\n            }\\n        }\\n        catch { return false }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\nextension String: Error {}\\n```",
                "solutionTags": [
                    "Swift",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs = s.indices.filter { s[$0] != goal[$0] }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func buddyStrings(_ s: String, _ goal: String) -> Bool\\n    {\\n        if s.count != goal.count { return false }\\n\\n        let diffs: [String.Index]\\n        do {\\n            diffs = try s.indices.reduce(into: [])\\n            {\\n                diffsArray, index in\\n                if s[index] != goal[index] { diffsArray.append(index) }\\n                if diffsArray.count > 2 { throw \"Too many diffs\" }\\n            }\\n        }\\n        catch { return false }\\n        \\n        if diffs.count == 2 // try swap these two\\n        {\\n            return s[diffs[0]] == goal[diffs[1]] \\n                && s[diffs[1]] == goal[diffs[0]]\\n        }\\n        else if diffs.count == 0 // check if there are any repeats in s  \\n        {                        // that could be swapped with each other\\n            var charSet: Set<Character> = []\\n            return s.contains { !charSet.insert($0).inserted }\\n        }\\n        else { return false }\\n    }\\n}\\nextension String: Error {}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688377,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        cnt=0\\n        if (len(goal)!=len(s)) or len(s)==1:\\n            return 0\\n        a,b=list(s),list(goal)\\n        a.sort()\\n        b.sort()\\n        if a!=b:\\n            return 0\\n        if s==s[::-1]:\\n            return 1\\n        dic=dict()\\n        for i in s:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n    \\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                cnt+=1\\n        if cnt==0:\\n            for i in dic:\\n                if dic[i]>=2:\\n                    return 1\\n        if cnt==2:\\n            return 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        cnt=0\\n        if (len(goal)!=len(s)) or len(s)==1:\\n            return 0\\n        a,b=list(s),list(goal)\\n        a.sort()\\n        b.sort()\\n        if a!=b:\\n            return 0\\n        if s==s[::-1]:\\n            return 1\\n        dic=dict()\\n        for i in s:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n    \\n        for i in range(len(s)):\\n            if s[i]!=goal[i]:\\n                cnt+=1\\n        if cnt==0:\\n            for i in dic:\\n                if dic[i]>=2:\\n                    return 1\\n        if cnt==2:\\n            return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495376,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n\\n        vector<int> count1(26, 0), count2(26, 0);\\n        int temp = 0;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) temp++;\\n\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n        return ((temp == 2) || (temp == 0 && !allUniqueChars));\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal):\\n            return False\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        diffs = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diffs.append((s[i], goal[i]))\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s == null || goal == null || s.length() != goal.length() || s.length() < 2){\\n            return false;\\n        }\\n        if(s.equals(goal)){\\n            int[] map = new int[26];\\n            for(int i = 0; i < s.length(); i++){\\n                if(map[s.charAt(i) - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    map[s.charAt(i) - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        char[] s1 = s.toCharArray();\\n        char[] s2 = goal.toCharArray();\\n        char s1_1 = \\'1\\', s1_2 = \\'2\\', s2_1 = \\'3\\', s2_2 = \\'4\\';\\n        boolean found1stDiff = false;\\n        boolean found2ndDiff = false;\\n\\n        for(int i = 0; i < s1.length; i++){\\n            if(s1[i] != s2[i]){\\n                if(!found1stDiff){\\n                    found1stDiff = true;\\n                    s1_1 = s1[i];\\n                    s2_1 = s2[i];\\n                }else if(!found2ndDiff){\\n                    found2ndDiff = true;\\n                    s1_2 = s1[i];\\n                    s2_2 = s2[i];\\n                    if(s1_2 != s2_1 || s1_1 != s2_2){\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return found1stDiff && found2ndDiff;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n\\n        vector<int> count1(26, 0), count2(26, 0);\\n        int temp = 0;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) temp++;\\n\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n        return ((temp == 2) || (temp == 0 && !allUniqueChars));\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal):\\n            return False\\n        if s == goal:\\n            return len(set(s)) < len(s)\\n        diffs = []\\n        for i in range(len(s)):\\n            if s[i] != goal[i]:\\n                diffs.append((s[i], goal[i]))\\n        return len(diffs) == 2 and diffs[0] == diffs[1][::-1]\\n```\n```Java []\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s == null || goal == null || s.length() != goal.length() || s.length() < 2){\\n            return false;\\n        }\\n        if(s.equals(goal)){\\n            int[] map = new int[26];\\n            for(int i = 0; i < s.length(); i++){\\n                if(map[s.charAt(i) - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    map[s.charAt(i) - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        char[] s1 = s.toCharArray();\\n        char[] s2 = goal.toCharArray();\\n        char s1_1 = \\'1\\', s1_2 = \\'2\\', s2_1 = \\'3\\', s2_2 = \\'4\\';\\n        boolean found1stDiff = false;\\n        boolean found2ndDiff = false;\\n\\n        for(int i = 0; i < s1.length; i++){\\n            if(s1[i] != s2[i]){\\n                if(!found1stDiff){\\n                    found1stDiff = true;\\n                    s1_1 = s1[i];\\n                    s2_1 = s2[i];\\n                }else if(!found2ndDiff){\\n                    found2ndDiff = true;\\n                    s1_2 = s1[i];\\n                    s2_2 = s2[i];\\n                    if(s1_2 != s2_1 || s1_1 != s2_2){\\n                        return false;\\n                    }\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return found1stDiff && found2ndDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871114,
                "title": "c-o-n-easy-to-understand-with-explanation",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n    - [Example 1 - Strings Equal](#example-1---strings-equal)\\n    - [Example 2 - Strings Not Equal](#example-2---strings-not-equal)\\n\\n# TL;DR\\n\\nBreak the problem into its individual cases and solve each one:\\n\\n* If the strings are not equal length, return `false`\\n* If the string are the same: check if there is a character with a frequency >1 so that we can just swap those\\n* If the strings aren\\'t the same: check to see if they differ in AT MOST 2 locations\\n\\n## Code\\n\\n```c++\\n#define LOWERCASE_TO_INDEX(c) (c - \\'a\\')\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        const int n = s.size();\\n        if (n != goal.size()) return false;\\n\\n        if (s == goal) {\\n            vector<int> char_freq(26, 0);\\n\\n            for (int i = 0; i < n; i++)\\n                if (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n                    return true;\\n\\n            return false;\\n        }\\n\\n        int first_diff_idx = -1, second_diff_idx = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] != goal[i]) {\\n                if (first_diff_idx == -1)\\n                    first_diff_idx = i;\\n                else if (second_diff_idx == -1)\\n                    second_diff_idx = i;\\n                else \\n                    return false;\\n            }\\n        }\\n\\n        return second_diff_idx != -1 && \\n               s[first_diff_idx] == goal[second_diff_idx] && \\n               s[second_diff_idx] == goal[first_diff_idx];\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$ where $$N$$ is the length of the string\\n**Space Complexity:** $$O(1)$$ since the frequency array is the only thing initialized and it has a constant size\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nThe basic idea that I followed is breaking it up into 2 cases:\\n1. If the strings aren\\'t the same length\\n2. If the strings are equal\\n3. If the strings aren\\'t equal\\n\\n### Case 1: Not Equal Length <!-- omit from toc -->\\nIf the strings aren\\'t equal, there is no way to get a buddy strings using the swap operation, so we just return false\\n\\n### Case 2: Equal Strings <!-- omit from toc -->\\nIf the strings are equal, then we need to determine if there is a character with a frequency of >1. If that is the case, then we can swap the same character and still have buddy strings.\\n\\nFor example, if s = \"aba\" and goal = \"aba\", then you could swap the two \\'a\\' characters to then have buddy strings. Remember that you MUST swap at least once\\n\\n### Case 3: Not Equal Strings <!-- omit from toc -->\\nIf the strings aren\\'t equal, we want to figure out if they differ in only 2 locations and where those locations are. If they differ in more than 2 locations, then they can\\'t be buddy strings. If they only differ in two locations, we need to ensure that if we swap those characters that the strings would be equal.\\n\\n## Approach \\n\\nWe want to break it up by checking if the strings are equal since we need two different approaches for those two cases.\\n\\nIf the strings are equal, then I used a frequency array to keep track of the frequency of letters. If I encounter a character that has occured more than once, then I return true since we could just swap those characters. If we do not find any character with a frequency of more than 1, then return false.\\n\\nIf the strings aren\\'t equal, then I want to find the locations where the two strings differ using 2 pointers. The first time that they differ, I store the index in the first pointer. The second time that they differ, I store the index in the second pointer. If they differ more than that, I know that the strings cannot be equal by swapping only 2 characters, so I return false. At the end of the iteration, I have to see if there were two differences (`second_diff_idx != -1`) and that the locations where they differ have\\nthe same character in each of them so the swap could be done and have equal strings afterwards (`s[first_diff_idx] == goal[second_diff_idx] && s[second_diff_idx] == goal[first_diff_idx]`)\\n\\n### Tricky Portion of Code <!-- omit from toc -->\\n\\n```c++\\nif (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n```\\n\\nOn line 13, I used this to shorter my code. Notice that I am using a macro named `LOWERCASE_TO_INDEX` to convert the lowercase letter to an index in the frequency array. Also, since I am using the pre-pended `++` operator, it adds 1 to the value prior to doing the comparison. That way, if the character has been seen before, it must have a value of 1 before this statement. Then, it will be increamented to 2 prior to the comparison, which is exactly what we want. Please follow up below if this was confusing to you!\\n\\n## Example\\n\\nLets do 2 different examples since there are 2 cases to consider:\\n\\n### Example 1 - Strings Equal\\n\\nLets use an example where `s = \"aba\"` and `t = \"aba\"`. Since `s == t`, we enter the equal case.\\n\\nWe find the frequency of all the characters in one of the strings since they are the same. In our case, we have `\\'a\\' = 2` and `\\'b\\' = 1`.  Since the frequency of `\\'a\\'` is >1, we could swap those characters to keep them buddy strings so we return `true`\\n\\n### Example 2 - Strings Not Equal\\n\\nLets use an example where `s = \"abb\"` and `t = \"bba\"`. We must iterate through all the characters.\\n\\n* i = 0\\n\\n`s[i] != goal[i]`, so we update `first_index = 0`\\n\\n* i = 1\\n\\n`s[i] == goal[i]` so we don\\'t do anything and continue\\n\\n* i = 2\\n\\n`s[i] != goal[i]` so we update `second_index = 2` since `first_index` was already mapped\\n\\n* Aftermath\\n\\nWe know that they only differ in two locations, so we need to check if `s[0] == t[2]` and `s[2] == t[0]`: `s[0] = t[2] = \\'a\\'` and `s[2] = t[0] = \\'b\\'`, so we return `true`\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```c++\\n#define LOWERCASE_TO_INDEX(c) (c - \\'a\\')\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        const int n = s.size();\\n        if (n != goal.size()) return false;\\n\\n        if (s == goal) {\\n            vector<int> char_freq(26, 0);\\n\\n            for (int i = 0; i < n; i++)\\n                if (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n                    return true;\\n\\n            return false;\\n        }\\n\\n        int first_diff_idx = -1, second_diff_idx = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] != goal[i]) {\\n                if (first_diff_idx == -1)\\n                    first_diff_idx = i;\\n                else if (second_diff_idx == -1)\\n                    second_diff_idx = i;\\n                else \\n                    return false;\\n            }\\n        }\\n\\n        return second_diff_idx != -1 && \\n               s[first_diff_idx] == goal[second_diff_idx] && \\n               s[second_diff_idx] == goal[first_diff_idx];\\n    }\\n};\\n```\n```c++\\nif (++char_freq[LOWERCASE_TO_INDEX(s[i])] > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683789,
                "title": "clean-concise-one-pass-o-n-c",
                "content": "**Please upvote! Thank you!**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n};\\n```\\n**Please upvote! Thank you!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if (s.size() != goal.size()) return false;\\n        vector<int> count1(26, 0);\\n        vector<int> count2(26, 0);\\n        int diffs = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != goal[i]) diffs++;\\n            count1[s[i] - \\'a\\']++;\\n            count2[goal[i] - \\'a\\']++;\\n        }\\n\\n        int allUniqueChars = true;\\n        for (int i = 0; i < count1.size(); i++) {\\n            if (count1[i] != count2[i]) return false;\\n            if (count1[i] > 1) allUniqueChars = false;\\n        }\\n\\n        return diffs == 2 || (diffs == 0 && !allUniqueChars);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585565,
                "title": "java-o-n-99-faster-two-pointer-solution",
                "content": "```\\n        // Lengths do not match, they will never be equal\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        char[] sArray = s.toCharArray();\\n        char[] goalArray = goal.toCharArray();\\n        int[] count = new int[26];\\n        int l = 0, r = s.length() - 1;\\n\\n        // If s and goal are equal and there is even a single duplicate in s, return true. \\n\\t\\t// We can just swap the duplicates to achieve the goal.\\n        if (s.equals(goal)) {\\n            for (int i = 0; i < s.length(); i++) {\\n                count[sArray[i] - \\'a\\']++;\\n                if (count[sArray[i] - \\'a\\'] > 1) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        // If s and goal are not equal, use the two pointers l and r to find the mismatch and swap.\\n        while (sArray[l] == goalArray[l] && l < r) {\\n            l++;\\n        }\\n\\n        while (sArray[r] == goalArray[r] && l < r) {\\n            r--;\\n        }\\n\\n        // Swap contents of l and r\\n        char temp = sArray[l];\\n        sArray[l] = sArray[r];\\n        sArray[r] = temp;\\n\\n        // If after swapping, the goal and s characters  do not match, return false\\n        if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n            return false;\\n        }\\n\\n        // Keep going to ensure that there are no more mismatches after swapping.\\n        while (l < r) {\\n            l++;\\n            r--;\\n\\n            if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        // Lengths do not match, they will never be equal\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        char[] sArray = s.toCharArray();\\n        char[] goalArray = goal.toCharArray();\\n        int[] count = new int[26];\\n        int l = 0, r = s.length() - 1;\\n\\n        // If s and goal are equal and there is even a single duplicate in s, return true. \\n\\t\\t// We can just swap the duplicates to achieve the goal.\\n        if (s.equals(goal)) {\\n            for (int i = 0; i < s.length(); i++) {\\n                count[sArray[i] - \\'a\\']++;\\n                if (count[sArray[i] - \\'a\\'] > 1) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        // If s and goal are not equal, use the two pointers l and r to find the mismatch and swap.\\n        while (sArray[l] == goalArray[l] && l < r) {\\n            l++;\\n        }\\n\\n        while (sArray[r] == goalArray[r] && l < r) {\\n            r--;\\n        }\\n\\n        // Swap contents of l and r\\n        char temp = sArray[l];\\n        sArray[l] = sArray[r];\\n        sArray[r] = temp;\\n\\n        // If after swapping, the goal and s characters  do not match, return false\\n        if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n            return false;\\n        }\\n\\n        // Keep going to ensure that there are no more mismatches after swapping.\\n        while (l < r) {\\n            l++;\\n            r--;\\n\\n            if (sArray[l] != goalArray[l] || sArray[r] != goalArray[r]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557094,
                "title": "js-best-solution-with-o-n-100",
                "content": "```\\nvar buddyStrings = function(s, goal) {   \\n    const hashmap = {};\\n    let indexOfFirstWrong;\\n    let output = false;\\n    let hasDuplicate = false;\\n    let numberOfWrongCharacter = 0;\\n    \\n    for (let i = 0; i < goal.length; i++) {\\n        if (goal[i] !== s[i] && indexOfFirstWrong === undefined) {\\n            indexOfFirstWrong = i;\\n            numberOfWrongCharacter++;\\n        } else if (goal[i] !== s[i] && indexOfFirstWrong !== undefined) {\\n            output = goal[i] === s[indexOfFirstWrong] && goal[indexOfFirstWrong] === s[i];\\n            numberOfWrongCharacter++;\\n            if (numberOfWrongCharacter > 2) return false;\\n        }\\n        \\n        if (hashmap[s[i]]) hasDuplicate = true;\\n        \\n        hashmap[s[i]] = 1;\\n    }\\n    \\n    if (!numberOfWrongCharacter && hasDuplicate) return true;\\n\\n     return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buddyStrings = function(s, goal) {   \\n    const hashmap = {};\\n    let indexOfFirstWrong;\\n    let output = false;\\n    let hasDuplicate = false;\\n    let numberOfWrongCharacter = 0;\\n    \\n    for (let i = 0; i < goal.length; i++) {\\n        if (goal[i] !== s[i] && indexOfFirstWrong === undefined) {\\n            indexOfFirstWrong = i;\\n            numberOfWrongCharacter++;\\n        } else if (goal[i] !== s[i] && indexOfFirstWrong !== undefined) {\\n            output = goal[i] === s[indexOfFirstWrong] && goal[indexOfFirstWrong] === s[i];\\n            numberOfWrongCharacter++;\\n            if (numberOfWrongCharacter > 2) return false;\\n        }\\n        \\n        if (hashmap[s[i]]) hasDuplicate = true;\\n        \\n        hashmap[s[i]] = 1;\\n    }\\n    \\n    if (!numberOfWrongCharacter && hasDuplicate) return true;\\n\\n     return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186221,
                "title": "python3-o-n-o-26-runtime-40ms-78-04-memory-14-2mb-60-39",
                "content": "```\\nclass Solution:\\n#     O(n) || O(26)\\n# Runtime: 40ms 78.04% memory: 14.2mb 60.39%\\n    def buddyStrings(self, string: str, goal: str) -> bool:\\n        left, right = 0, len(string) - 1\\n\\n        if len(string) != len(goal):\\n            return False\\n\\n        if string == goal and len(set(string)) < len(string):\\n            return True\\n\\n\\n        difference = []\\n\\n        for i in range(len(string)):\\n            if string[i] != goal[i]:\\n                difference.append((string[i], goal[i]))\\n\\n\\n        if len(difference) == 2 and difference[0] == difference[-1][::-1]: \\n            return True\\n\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(26)\\n# Runtime: 40ms 78.04% memory: 14.2mb 60.39%\\n    def buddyStrings(self, string: str, goal: str) -> bool:\\n        left, right = 0, len(string) - 1\\n\\n        if len(string) != len(goal):\\n            return False\\n\\n        if string == goal and len(set(string)) < len(string):\\n            return True\\n\\n\\n        difference = []\\n\\n        for i in range(len(string)):\\n            if string[i] != goal[i]:\\n                difference.append((string[i], goal[i]))\\n\\n\\n        if len(difference) == 2 and difference[0] == difference[-1][::-1]: \\n            return True\\n\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094840,
                "title": "clean-simple-cpp-solution",
                "content": "```\\nbool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length())\\n            return false;\\n        int temp=-1;\\n        unordered_set<char> uset;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] != goal[i] && temp == -1)\\n                temp = i;\\n            else if(s[i] != goal[i])\\n            {\\n                char ch = s[i];\\n                s[i] = s[temp];\\n                s[temp] = ch;\\n                return s == goal;\\n            }\\n            uset.insert(s[i]);\\n        }\\n        if(s==goal)\\n            return uset.size()<s.length();\\n        return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length())\\n            return false;\\n        int temp=-1;\\n        unordered_set<char> uset;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] != goal[i] && temp == -1)\\n                temp = i;\\n            else if(s[i] != goal[i])\\n            {\\n                char ch = s[i];\\n                s[i] = s[temp];\\n                s[temp] = ch;\\n                return s == goal;\\n            }\\n            uset.insert(s[i]);\\n        }\\n        if(s==goal)\\n            return uset.size()<s.length();\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2047315,
                "title": "3ms-simple-and-fastest-java-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())return false;\\n        int f[]=new int[26];\\n       List<Integer>list=new ArrayList<>();\\n       for(int i=0;i<s.length();i++){\\n           if(s.charAt(i)!=goal.charAt(i))list.add(i);\\n           if(list.size()>2)return false;\\n           f[s.charAt(i)-\\'a\\']++;\\n       }\\n       if(list.size()==0){\\n         for(int i=0;i<26;i++)if(f[i]>=2)return true;\\n           return false;\\n       }\\n       return list.size()==2&&s.charAt(list.get(0))==goal.charAt(list.get(1))&&s.charAt(list.get(1))==goal.charAt(list.get(0)); \\n           \\n    }\\n}\\n# ```\\n# Time : O(n) linear\\n# Space : O(1) constant extra space\\n# \\n# Please Upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length())return false;\\n        int f[]=new int[26];\\n       List<Integer>list=new ArrayList<>();\\n       for(int i=0;i<s.length();i++){\\n           if(s.charAt(i)!=goal.charAt(i))list.add(i);\\n           if(list.size()>2)return false;\\n           f[s.charAt(i)-\\'a\\']++;\\n       }\\n       if(list.size()==0){\\n         for(int i=0;i<26;i++)if(f[i]>=2)return true;\\n           return false;\\n       }\\n       return list.size()==2&&s.charAt(list.get(0))==goal.charAt(list.get(1))&&s.charAt(list.get(1))==goal.charAt(list.get(0)); \\n           \\n    }\\n}\\n# ```",
                "codeTag": "Java"
            },
            {
                "id": 1844958,
                "title": "c-o-n-two-pointer",
                "content": "```\\nclass Solution {\\npublic: \\n    bool buddyStrings(string s, string goal) {\\n        \\n        //Creating Hashmaps\\n        unordered_map<char, int> smp; \\n        unordered_map<char, int>  gmp;  \\n        \\n        //Initializing each key with frequencies\\n        for(char c : s) { \\n            smp[c]++;\\n        }     \\n        \\n        for (char c : goal) { \\n            gmp[c]++;\\n        } \\n        \\n        //If they don\\'t have same chars and frequencies return false\\n        if (smp != gmp) {   \\n            return false;\\n        } \\n        \\n        //If strings are equal and has a duplicate char then return true\\n        if (s == goal) { \\n            for (auto c : smp) { \\n                if (c.second >= 2) {  \\n                    return true;\\n                }\\n            }    \\n            \\n            //if all chars are unique return false\\n            return false;\\n        }\\n        \\n        //Two pointerapproach we have to just swap two chars not more than 2\\n        int i = 0; \\n        int j = 0; \\n        int ctr = 0;\\n        \\n        while (i < s.length()) { \\n            if (ctr > 2) { \\n                return false;\\n            } \\n            \\n            if (s[i] != goal[j]) { \\n                ctr++;\\n            } \\n            \\n            i++; \\n            j++;\\n        } \\n        \\n        return (ctr > 2) ? false : true; \\n   }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool buddyStrings(string s, string goal) {\\n        \\n        //Creating Hashmaps\\n        unordered_map<char, int> smp; \\n        unordered_map<char, int>  gmp;  \\n        \\n        //Initializing each key with frequencies\\n        for(char c : s) { \\n            smp[c]++;\\n        }     \\n        \\n        for (char c : goal) { \\n            gmp[c]++;\\n        } \\n        \\n        //If they don\\'t have same chars and frequencies return false\\n        if (smp != gmp) {   \\n            return false;\\n        } \\n        \\n        //If strings are equal and has a duplicate char then return true\\n        if (s == goal) { \\n            for (auto c : smp) { \\n                if (c.second >= 2) {  \\n                    return true;\\n                }\\n            }    \\n            \\n            //if all chars are unique return false\\n            return false;\\n        }\\n        \\n        //Two pointerapproach we have to just swap two chars not more than 2\\n        int i = 0; \\n        int j = 0; \\n        int ctr = 0;\\n        \\n        while (i < s.length()) { \\n            if (ctr > 2) { \\n                return false;\\n            } \\n            \\n            if (s[i] != goal[j]) { \\n                ctr++;\\n            } \\n            \\n            i++; \\n            j++;\\n        } \\n        \\n        return (ctr > 2) ? false : true; \\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675326,
                "title": "c-easy-logic-hashmap",
                "content": "**Upvote if you found solution helpful**\\n```C++\\nclass Solution\\n{\\npublic:\\n    bool buddyStrings(string s, string goal)\\n    {\\n        if (s.length() != goal.length())\\n            return false;\\n        if (s == goal)\\n        {\\n            unordered_map<char, int> m;\\n            for (auto x : s)\\n            {\\n                m[x]++;\\n            }\\n            for (auto x : m)\\n            {\\n                if (x.second > 1)\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else\\n        {\\n            int first = -1, second = -1;\\n            for (int i = 0; i < s.length(); ++i)\\n            {\\n                if (s[i] != goal[i])\\n                {\\n                    if (first == -1)\\n                        first = i;\\n                    else if (second == -1)\\n                        second = i;\\n                    else\\n                        return false;\\n                }\\n            }\\n\\n            return (second != -1 && s[first] == goal[second] &&\\n                    s[second] == goal[first]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    bool buddyStrings(string s, string goal)\\n    {\\n        if (s.length() != goal.length())\\n            return false;\\n        if (s == goal)\\n        {\\n            unordered_map<char, int> m;\\n            for (auto x : s)\\n            {\\n                m[x]++;\\n            }\\n            for (auto x : m)\\n            {\\n                if (x.second > 1)\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else\\n        {\\n            int first = -1, second = -1;\\n            for (int i = 0; i < s.length(); ++i)\\n            {\\n                if (s[i] != goal[i])\\n                {\\n                    if (first == -1)\\n                        first = i;\\n                    else if (second == -1)\\n                        second = i;\\n                    else\\n                        return false;\\n                }\\n            }\\n\\n            return (second != -1 && s[first] == goal[second] &&\\n                    s[second] == goal[first]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595770,
                "title": "python-o-n-3-rules",
                "content": "```\\nclass Solution:\\n    def can_be_replaced(self, s1, s2):        \\n        diff_chars = []                        \\n        for i in range(len(s1)):\\n            if s1[i] != s2[i]:\\n                diff_chars.append((s1[i], s2[i]))\\n        \\n        if len(diff_chars) != 2: return False\\n                        \\n        return diff_chars[0][0] == diff_chars[1][1] and diff_chars[0][1] == diff_chars[1][0]\\n        ## alternative\\n        #return diff_chars[0] == diff_chars[1][::-1]\\n        \\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        \\n        if s == goal:  return max(Counter(s).values()) > 1        \\n        \\n        return self.can_be_replaced(s, goal)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def can_be_replaced(self, s1, s2):        \\n        diff_chars = []                        \\n        for i in range(len(s1)):\\n            if s1[i] != s2[i]:\\n                diff_chars.append((s1[i], s2[i]))\\n        \\n        if len(diff_chars) != 2: return False\\n                        \\n        return diff_chars[0][0] == diff_chars[1][1] and diff_chars[0][1] == diff_chars[1][0]\\n        ## alternative\\n        #return diff_chars[0] == diff_chars[1][::-1]\\n        \\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        \\n        if s == goal:  return max(Counter(s).values()) > 1        \\n        \\n        return self.can_be_replaced(s, goal)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553216,
                "title": "fast-python-solution-using-list-comprehension",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal): return False\\n        \\n        comparisson = [i for i in range(len(s)) if s[i]!=goal[i]]\\n        \\n        if len(comparisson) > 2:\\n            return False\\n        if len(comparisson) == 2 and s[comparisson[0]]==goal[comparisson[1]] and s[comparisson[1]]==goal[comparisson[0]]: \\n            return True\\n        if len(comparisson) == 0 and len(s) > len(set(list(s))): #check if there are duplicate characters for swap\\n            return True\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        \\n        if len(s) != len(goal): return False\\n        \\n        comparisson = [i for i in range(len(s)) if s[i]!=goal[i]]\\n        \\n        if len(comparisson) > 2:\\n            return False\\n        if len(comparisson) == 2 and s[comparisson[0]]==goal[comparisson[1]] and s[comparisson[1]]==goal[comparisson[0]]: \\n            return True\\n        if len(comparisson) == 0 and len(s) > len(set(list(s))): #check if there are duplicate characters for swap\\n            return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497715,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n\\tpublic boolean buddyStrings(String s, String goal) {\\n        if (s.length() < 2 ) return false;\\n\\t\\telse if (s.replace(String.valueOf(s.charAt(0)), \"\").length() == 0) return true;\\n\\t\\telse if (s.equals(goal)) return Arrays.stream(s.toLowerCase().split(\"\")).distinct().count() != s.length();\\n\\t\\telse if (countDiff(s,goal) != 2 ) return false;\\n\\t\\telse {\\n\\t\\t\\tint[] arr = new int[2];\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) {\\n\\t\\t\\t\\t\\tarr[count] = j;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\tchar[] c = s.toCharArray();\\n\\t\\t\\tchar temp = c[arr[0]];\\n\\t\\t\\tc[arr[0]] = c[arr[1]];\\n\\t\\t\\tc[arr[1]] = temp;\\n\\t\\t\\treturn new String(c).equals(goal);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int countDiff(String s, String goal) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) count++;\\n\\t\\treturn count;\\n\\t}\\n}\\n```\\nif you want to get it more clear DM me on insta (im_krgs)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic boolean buddyStrings(String s, String goal) {\\n        if (s.length() < 2 ) return false;\\n\\t\\telse if (s.replace(String.valueOf(s.charAt(0)), \"\").length() == 0) return true;\\n\\t\\telse if (s.equals(goal)) return Arrays.stream(s.toLowerCase().split(\"\")).distinct().count() != s.length();\\n\\t\\telse if (countDiff(s,goal) != 2 ) return false;\\n\\t\\telse {\\n\\t\\t\\tint[] arr = new int[2];\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) {\\n\\t\\t\\t\\t\\tarr[count] = j;\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\tchar[] c = s.toCharArray();\\n\\t\\t\\tchar temp = c[arr[0]];\\n\\t\\t\\tc[arr[0]] = c[arr[1]];\\n\\t\\t\\tc[arr[1]] = temp;\\n\\t\\t\\treturn new String(c).equals(goal);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int countDiff(String s, String goal) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int j = 0; j < s.length(); j++)\\n\\t\\t\\tif (s.charAt(j) != goal.charAt(j)) count++;\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364580,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        if(s == goal){\\n            return ((set<char>(s.begin(),s.end())).size() < s.size());\\n        }\\n        \\n        int n = s.size();\\n        int i=0;\\n        int j=n-1;\\n        while(i<n&& s[i]==goal[i]){\\n            i++;\\n        }\\n        while(j>0 && s[j] == goal[j]){\\n            j--;\\n        }\\n        \\n        if(i<j){\\n            swap(s[i],s[j]);\\n        }\\n        \\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358742,
                "title": "c",
                "content": "```\\n bool buddyStrings(string s, string goal) {\\n        \\n        \\n        if(s.length()!=goal.length()){\\n            return false;\\n        }\\n        \\n        map<char,int>M;\\n        vector<int>V;\\n        for(int i=0;i<s.length();i++){\\n            M[s[i]]++;\\n            if(s[i]!=goal[i]){\\n                V.push_back(i);\\n                if(V.size()==2){\\n                    swap(s[V[0]],s[V[1]]);\\n                    if(s==goal){\\n                       return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        for(auto it:M){\\n            if(it.second>=2&&s==goal){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool buddyStrings(string s, string goal) {\\n        \\n        \\n        if(s.length()!=goal.length()){\\n            return false;\\n        }\\n        \\n        map<char,int>M;\\n        vector<int>V;\\n        for(int i=0;i<s.length();i++){\\n            M[s[i]]++;\\n            if(s[i]!=goal[i]){\\n                V.push_back(i);\\n                if(V.size()==2){\\n                    swap(s[V[0]],s[V[1]]);\\n                    if(s==goal){\\n                       return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        for(auto it:M){\\n            if(it.second>=2&&s==goal){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305422,
                "title": "100-faster-c-solution",
                "content": "**If you like it then please upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        if(s==goal){\\n            unordered_map<char,int> m;\\n            for(auto i:s){\\n                m[i]++;\\n            }\\n            for(auto itr=m.begin(); itr!=m.end();itr++){\\n                if(itr->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        vector<int> v;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=goal[i]){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==2){\\n            if(s[v[0]]==goal[v[1]]&&s[v[1]]==goal[v[0]]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        if(s==goal){\\n            unordered_map<char,int> m;\\n            for(auto i:s){\\n                m[i]++;\\n            }\\n            for(auto itr=m.begin(); itr!=m.end();itr++){\\n                if(itr->second>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        vector<int> v;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]!=goal[i]){\\n                v.push_back(i);\\n            }\\n        }\\n        if(v.size()==2){\\n            if(s[v[0]]==goal[v[1]]&&s[v[1]]==goal[v[0]]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1174190,
                "title": "simple-python-straight-forward-solution",
                "content": "Stats- Runtime: 28 ms, faster than 91.80% of Python3 online submissions for Buddy Strings.\\nMemory Usage: 14.4 MB, less than 72.02% of Python3 online submissions for Buddy Strings.\\n\\n```\\ndef buddyStrings(a, b):\\n\\t#compare length, if lenght is different, there is no way strings could be similar\\n\\tif len(a) != len(b):\\n\\t\\treturn False\\n\\t\\t\\n\\t#lists for elements different in string a and string b\\n\\tnotSimilarA = []\\n\\tnotSimilarB = []\\n\\t\\n\\t#pull out different character in both strings\\n\\tfor swi in range(len(a)):\\n\\t\\tif a[swi] != b[swi]:\\n\\t\\t\\tnotSimilarA.append(a[swi])\\n\\t\\t\\tnotSimilarB.append(b[swi])\\n\\t\\t\\t\\n\\t#print(f\"notSimilarA: {notSimilarA}\")\\n\\t#print(f\"notSimilarB: {notSimilarB}\")\\n\\t\\n\\t#if more than 2 characters are different then swapping one pair wont be suffice\\n\\tif len(notSimilarA) > 2:\\n\\t\\treturn False\\n\\t\\n\\t#if both strings are similar, then check if there is any pair of similar characters that can be swapped without changing string literally\\n\\tif not notSimilarA:\\n\\t\\tif len(set(a)) == len(a):\\n\\t\\t\\treturn False\\n\\telse:\\n\\t\\tfor swi in range(len(notSimilarA)):\\n\\t\\t\\tif notSimilarA[swi] not in notSimilarB:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef buddyStrings(a, b):\\n\\t#compare length, if lenght is different, there is no way strings could be similar\\n\\tif len(a) != len(b):\\n\\t\\treturn False\\n\\t\\t\\n\\t#lists for elements different in string a and string b\\n\\tnotSimilarA = []\\n\\tnotSimilarB = []\\n\\t\\n\\t#pull out different character in both strings\\n\\tfor swi in range(len(a)):\\n\\t\\tif a[swi] != b[swi]:\\n\\t\\t\\tnotSimilarA.append(a[swi])\\n\\t\\t\\tnotSimilarB.append(b[swi])\\n\\t\\t\\t\\n\\t#print(f\"notSimilarA: {notSimilarA}\")\\n\\t#print(f\"notSimilarB: {notSimilarB}\")\\n\\t\\n\\t#if more than 2 characters are different then swapping one pair wont be suffice\\n\\tif len(notSimilarA) > 2:\\n\\t\\treturn False\\n\\t\\n\\t#if both strings are similar, then check if there is any pair of similar characters that can be swapped without changing string literally\\n\\tif not notSimilarA:\\n\\t\\tif len(set(a)) == len(a):\\n\\t\\t\\treturn False\\n\\telse:\\n\\t\\tfor swi in range(len(notSimilarA)):\\n\\t\\t\\tif notSimilarA[swi] not in notSimilarB:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1164321,
                "title": "java-string-one-pass-beats-99-1ms-t-c-o-n-s-c-o-1",
                "content": "\\n    public boolean buddyStrings(String a, String b) {\\n        int len1 = a.length(), len2 = b.length();\\n\\t\\tif (len1 != len2)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint count = 0;\\n\\t\\tchar ch1 = \\'\\\\0\\', ch2 = \\'\\\\0\\', ch3 = \\'\\\\0\\', ch4 = \\'\\\\0\\';\\n\\t\\tboolean flag = false;\\n\\t\\tboolean[] map = new boolean[26];\\n\\t\\tfor (int i = 0; i < len1; i++) {\\n\\t\\t\\tchar ch11 = a.charAt(i), ch22 = b.charAt(i);\\n\\t\\t\\tif (ch11 != ch22) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif (count == 1) {\\n\\t\\t\\t\\t\\tch1 = ch11;\\n\\t\\t\\t\\t\\tch2 = ch22;\\n\\t\\t\\t\\t} else if (count == 2) {\\n\\t\\t\\t\\t\\tch3 = ch11;\\n\\t\\t\\t\\t\\tch4 = ch22;\\n\\t\\t\\t\\t}\\n                else\\n                    return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (map[ch11 - \\'a\\'])\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\tmap[ch11 - \\'a\\'] = true;\\n\\t\\t}\\n\\n\\t\\tif (count == 0 && flag)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (count == 2 && ch1 == ch4 && ch2 == ch3)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean buddyStrings(String a, String b) {\\n        int len1 = a.length(), len2 = b.length();\\n\\t\\tif (len1 != len2)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint count = 0;\\n\\t\\tchar ch1 = \\'\\\\0\\', ch2 = \\'\\\\0\\', ch3 = \\'\\\\0\\', ch4 = \\'\\\\0\\';\\n\\t\\tboolean flag = false;\\n\\t\\tboolean[] map = new boolean[26];\\n\\t\\tfor (int i = 0; i < len1; i++) {\\n\\t\\t\\tchar ch11 = a.charAt(i), ch22 = b.charAt(i);\\n\\t\\t\\tif (ch11 != ch22) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif (count == 1) {\\n\\t\\t\\t\\t\\tch1 = ch11;\\n\\t\\t\\t\\t\\tch2 = ch22;\\n\\t\\t\\t\\t} else if (count == 2) {\\n\\t\\t\\t\\t\\tch3 = ch11;\\n\\t\\t\\t\\t\\tch4 = ch22;\\n\\t\\t\\t\\t}\\n                else\\n                    return false;\\n\\t\\t\\t}\\n\\t\\t\\tif (map[ch11 - \\'a\\'])\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\tmap[ch11 - \\'a\\'] = true;\\n\\t\\t}\\n\\n\\t\\tif (count == 0 && flag)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (count == 2 && ch1 == ch4 && ch2 == ch3)\\n\\t\\t\\treturn true;\\n\\n\\t\\treturn false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 906614,
                "title": "c-beats-100",
                "content": "**Explanation**\\nMy first thought process was to build an O(N^2) solution, by creating all possible strings from A by swapping any two characters. However, I noticed that if I compare each position in two Buddy Strings A and B, then (N-2) positions will correspond, and exactly 2 will be unequal. If the 2 positions which have different characters in A and B be i and j respectively, then further we must have A[i] = B[j] & A[j] = B[i].\\n\\nFor eg. ABCDBA and ADCBBA. Here i = 1, j = 3. All the remaining indices are such that A[k] = B[k].\\n\\nAlso if we have two equal strings, then we won\\'t have any indices i such that A[i] != B[i]. Two equal strings will be buddy strings, only if I have atleast one duplicate character, because I could then swap the duplicate characters.\\nFor eg. ABCDBA and ABCDBA, we can swap (A, A) or (B, B).\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) {\\n            return false;\\n        }\\n        \\n\\t\\t// Stores i  and j.\\n        vector<int> index;\\n\\n\\t\\t// To count for Duplicate Character.\\n        vector<int> freq(26, 0);\\n\\n\\t\\t// Stores whether Duplicate Character Exists.\\n        bool dup = false;\\n        \\n        for (int i=0; i<A.length(); ++i) {\\n\\t\\t\\t// Found the Duplicate. \\n            if (++freq[A[i]-\\'a\\'] > 1) {\\n                dup = true;\\n            }\\n\\n            if (A[i] != B[i]) {\\n                index.push_back(i);\\n\\t\\t\\t\\t// More than 2 Different Characters.\\n                if (index.size() > 2)\\n                    return false;\\n            }\\n        }\\n        \\n        if (index.size() < 2) {\\n            if (index.size() == 1)\\n                return false;\\n        \\n            // 0 means identical, if i have duplicates, then True.\\n            return dup;\\n        }\\n        \\n        return (A[index[0]] == B[index[1]] && A[index[1]] == B[index[0]]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.length() != B.length()) {\\n            return false;\\n        }\\n        \\n\\t\\t// Stores i  and j.\\n        vector<int> index;\\n\\n\\t\\t// To count for Duplicate Character.\\n        vector<int> freq(26, 0);\\n\\n\\t\\t// Stores whether Duplicate Character Exists.\\n        bool dup = false;\\n        \\n        for (int i=0; i<A.length(); ++i) {\\n\\t\\t\\t// Found the Duplicate. \\n            if (++freq[A[i]-\\'a\\'] > 1) {\\n                dup = true;\\n            }\\n\\n            if (A[i] != B[i]) {\\n                index.push_back(i);\\n\\t\\t\\t\\t// More than 2 Different Characters.\\n                if (index.size() > 2)\\n                    return false;\\n            }\\n        }\\n        \\n        if (index.size() < 2) {\\n            if (index.size() == 1)\\n                return false;\\n        \\n            // 0 means identical, if i have duplicates, then True.\\n            return dup;\\n        }\\n        \\n        return (A[index[0]] == B[index[1]] && A[index[1]] == B[index[0]]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891512,
                "title": "swift-solution",
                "content": "**Solution**\\n```swift\\nfunc buddyStrings(_ A: String, _ B: String) -> Bool {\\n\\tguard A.count == B.count else { return false }\\n\\n\\t// 1. Strings are equal. Is there a duplicate we can swap? \\n\\tif A == B {\\n\\t\\tvar set = Set<Character>() \\n\\t\\tfor char in A {\\n\\t\\t\\tif set.contains(char)  {\\n\\t\\t\\t\\treturn true \\n\\t\\t\\t}\\n\\t\\t\\tset.insert(char)\\n\\t\\t}\\n\\t\\treturn false \\n\\t}\\n\\n\\t// 2. Strings are different. Ensure swapping maintains equality.\\n\\tvar pairs = [[Character]]()\\n\\tfor (a, b) in zip(A, B) {\\n\\t\\tif a != b {\\n\\t\\t\\tpairs.append([a, b])\\n\\t\\t}\\n\\t\\tif pairs.count > 2 {\\n\\t\\t\\treturn false \\n\\t\\t}\\n\\t}\\n\\n\\treturn pairs.count == 2 && pairs[0] == pairs[1].reversed()\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc buddyStrings(_ A: String, _ B: String) -> Bool {\\n\\tguard A.count == B.count else { return false }\\n\\n\\t// 1. Strings are equal. Is there a duplicate we can swap? \\n\\tif A == B {\\n\\t\\tvar set = Set<Character>() \\n\\t\\tfor char in A {\\n\\t\\t\\tif set.contains(char)  {\\n\\t\\t\\t\\treturn true \\n\\t\\t\\t}\\n\\t\\t\\tset.insert(char)\\n\\t\\t}\\n\\t\\treturn false \\n\\t}\\n\\n\\t// 2. Strings are different. Ensure swapping maintains equality.\\n\\tvar pairs = [[Character]]()\\n\\tfor (a, b) in zip(A, B) {\\n\\t\\tif a != b {\\n\\t\\t\\tpairs.append([a, b])\\n\\t\\t}\\n\\t\\tif pairs.count > 2 {\\n\\t\\t\\treturn false \\n\\t\\t}\\n\\t}\\n\\n\\treturn pairs.count == 2 && pairs[0] == pairs[1].reversed()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891486,
                "title": "clear-c-solution-with-comments-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        \\n        int n=A.length(),m=B.length();\\n        \\n        if(n!=m)              // if both length is not equal then it is not a buddy string \\n            return false;\\n        else\\n        {\\n            int f1[26]={0};\\n            int f2[26]={0};\\n            int count=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                if(A[i]!=B[i])  //check the number of unequal characters\\n                    count++;\\n                f1[A[i]-\\'a\\']++; //frequency of characters in A\\n                f2[B[i]-\\'a\\']++; //frequency of characters in B\\n            }\\n            \\n            if(count==0) // if string A is equal to string B\\n            {\\n                for(int i=0;i<26;i++)  // if frequency of any character is greater than 1\\n                {                      // then we can swap between them\\n                    if(f1[i]>=2)\\n                        return true;\\n                }    \\n                return false;\\n            }\\n            else if(count==2)         //if different characters in both strings are 2  \\n            {\\n                for(int i=0;i<26;i++) // then if frequency of each characters in both string is equal then \\n                {\\n                    if(f1[i]!=f2[i])  // is acceptable or unacceptable \\n                        return false;       \\n                }\\n                return true;\\n            }\\n            else                     // else in any case the string is unacceptable\\n                return false;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        \\n        int n=A.length(),m=B.length();\\n        \\n        if(n!=m)              // if both length is not equal then it is not a buddy string \\n            return false;\\n        else\\n        {\\n            int f1[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 891172,
                "title": "efficient-scala-solution",
                "content": "```scala\\n  def buddyStrings(A: String, B: String): Boolean =\\n    if (A.length != B.length) false\\n    else {\\n      val diff = A.indices.filter(i => A(i) != B(i))\\n      (diff.isEmpty && A.length > A.toSet.size) || (diff.length == 2 && diff.map(A(_)) == diff.map(B(_)).reverse)\\n    }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\n  def buddyStrings(A: String, B: String): Boolean =\\n    if (A.length != B.length) false\\n    else {\\n      val diff = A.indices.filter(i => A(i) != B(i))\\n      (diff.isEmpty && A.length > A.toSet.size) || (diff.length == 2 && diff.map(A(_)) == diff.map(B(_)).reverse)\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 890987,
                "title": "c-solution-100-fast-explained",
                "content": "EXPLANATION\\n1.  if string lenght is different -> return false;\\n2.  iterate strings and count the occurencies of each char and memorize if a duplicate is found;\\n3.  Count the differencesies, if bigger than 2 -> return false\\n4.  Compare occurencies arrays and if they are different -> return false\\n5.  If occurencies are the same and differencies (count) == 2 -> return true\\n6.  if count == 0 but there is a duplicate letter to swap with no effect -> return true;\\n\\n```\\nbool buddyStrings(char * A, char * B){\\n    int lenA = strlen(A), count=0, alphabetA[26] = {0},alphabetB[26] = {0}, duplicate = 0,i;\\n    int lenB = strlen(B);\\n    if(lenA != lenB) return false;\\n    for(i =0; i<lenA; i++){\\n        alphabetA[A[i]-\\'a\\']++;\\n        alphabetB[B[i]-\\'a\\']++;\\n        if(alphabetA[A[i]-\\'a\\']>1)\\n            duplicate = 1;\\n        if(A[i] != B[i]) \\n            count++;\\n        if(count >2) return false;\\n    }\\n    for(i=0;i<26;i++){\\n        if(alphabetA[i] != alphabetB[i])\\n            return false;\\n    }\\n    if(count == 2) return true;\\n    \\n    if(count == 0 && duplicate == 1) return true;\\n    return false;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "EXPLANATION\\n1.  if string lenght is different -> return false;\\n2.  iterate strings and count the occurencies of each char and memorize if a duplicate is found;\\n3.  Count the differencesies, if bigger than 2 -> return false\\n4.  Compare occurencies arrays and if they are different -> return false\\n5.  If occurencies are the same and differencies (count) == 2 -> return true\\n6.  if count == 0 but there is a duplicate letter to swap with no effect -> return true;\\n\\n```\\nbool buddyStrings(char * A, char * B){\\n    int lenA = strlen(A), count=0, alphabetA[26] = {0},alphabetB[26] = {0}, duplicate = 0,i;\\n    int lenB = strlen(B);\\n    if(lenA != lenB) return false;\\n    for(i =0; i<lenA; i++){\\n        alphabetA[A[i]-\\'a\\']++;\\n        alphabetB[B[i]-\\'a\\']++;\\n        if(alphabetA[A[i]-\\'a\\']>1)\\n            duplicate = 1;\\n        if(A[i] != B[i]) \\n            count++;\\n        if(count >2) return false;\\n    }\\n    for(i=0;i<26;i++){\\n        if(alphabetA[i] != alphabetB[i])\\n            return false;\\n    }\\n    if(count == 2) return true;\\n    \\n    if(count == 0 && duplicate == 1) return true;\\n    return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 872736,
                "title": "ruby-o-n-56ms-70-easy-to-understand",
                "content": "```\\ndef buddy_strings(a, b)\\n  # Obviously, the answer is no if strings have different lengths\\n  return false if a.length != b.length\\n  \\n  # Let\\'s find all indices where a[i] != b[i]\\n  incorrect_indices = (0..a.length - 1).select {|i| a[i] != b[i]}\\n  \\n  # How many mismatching indices do we have?\\n  case incorrect_indices.length\\n    # If it\\'s 0, then strings are identical. \\n\\t# In this case, we need to have two same characters in the string to be able to swap them without changing the string\\n\\t# For example, in string \\'aa\\' we can swap the characters and it will still be \\'aa\\'\\n\\t# Let\\'s just check if there are any duplicate characters using .uniq \\n    when 0\\n      a.split(\\'\\').uniq.length < a.length\\n    \\n\\t# If it\\'s 2, then there are two mismatching characters. Let\\'s check if they are actually two swapped characters\\n    when 2\\n      ind1, ind2 = incorrect_indices\\n      a[ind1] == b[ind2] && a[ind2] == b[ind1]\\n    \\n\\t# Otherwise, the answer is no\\n    else\\n      false\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef buddy_strings(a, b)\\n  # Obviously, the answer is no if strings have different lengths\\n  return false if a.length != b.length\\n  \\n  # Let\\'s find all indices where a[i] != b[i]\\n  incorrect_indices = (0..a.length - 1).select {|i| a[i] != b[i]}\\n  \\n  # How many mismatching indices do we have?\\n  case incorrect_indices.length\\n    # If it\\'s 0, then strings are identical. \\n\\t# In this case, we need to have two same characters in the string to be able to swap them without changing the string\\n\\t# For example, in string \\'aa\\' we can swap the characters and it will still be \\'aa\\'\\n\\t# Let\\'s just check if there are any duplicate characters using .uniq \\n    when 0\\n      a.split(\\'\\').uniq.length < a.length\\n    \\n\\t# If it\\'s 2, then there are two mismatching characters. Let\\'s check if they are actually two swapped characters\\n    when 2\\n      ind1, ind2 = incorrect_indices\\n      a[ind1] == b[ind2] && a[ind2] == b[ind1]\\n    \\n\\t# Otherwise, the answer is no\\n    else\\n      false\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 832817,
                "title": "c-two-solutions",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        unordered_map<char, int> aFreq, bFreq;\\n        for (int i = 0; i < A.size(); i++) {\\n            aFreq[A[i]]++;\\n            bFreq[B[i]]++;\\n        }\\n        if (aFreq != bFreq) {\\n            return false;\\n        }\\n        int misCnt = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                misCnt++;\\n            }\\n            if (misCnt > 2) {\\n                return false;\\n            }\\n        }\\n        if (misCnt == 2) {\\n            return true;\\n        }\\n        if (misCnt == 1 || !consecutiveLetterCheck(aFreq)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool consecutiveLetterCheck(unordered_map<char, int> mp) {\\n        for (auto elem : mp) {\\n            if (elem.second > 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Solution 2 (Better)**\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        \\n        // If A & B are equal and A has duplicates -> A = \"aba\", B = \"aba\", we can swap a\\'s\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) {\\n            return true;\\n        }\\n        \\n        // Save indices where letters are different\\n        vector<int> diff;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n            }\\n        }\\n        return (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        unordered_map<char, int> aFreq, bFreq;\\n        for (int i = 0; i < A.size(); i++) {\\n            aFreq[A[i]]++;\\n            bFreq[B[i]]++;\\n        }\\n        if (aFreq != bFreq) {\\n            return false;\\n        }\\n        int misCnt = 0;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                misCnt++;\\n            }\\n            if (misCnt > 2) {\\n                return false;\\n            }\\n        }\\n        if (misCnt == 2) {\\n            return true;\\n        }\\n        if (misCnt == 1 || !consecutiveLetterCheck(aFreq)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool consecutiveLetterCheck(unordered_map<char, int> mp) {\\n        for (auto elem : mp) {\\n            if (elem.second > 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string A, string B) {\\n        if (A.size() != B.size()) {\\n            return false;\\n        }\\n        \\n        // If A & B are equal and A has duplicates -> A = \"aba\", B = \"aba\", we can swap a\\'s\\n        if (A == B && set<char>(A.begin(), A.end()).size() < A.size()) {\\n            return true;\\n        }\\n        \\n        // Save indices where letters are different\\n        vector<int> diff;\\n        for (int i = 0; i < A.size(); i++) {\\n            if (A[i] != B[i]) {\\n                diff.push_back(i);\\n            }\\n        }\\n        return (diff.size() == 2 && A[diff[0]] == B[diff[1]] && A[diff[1]] == B[diff[0]]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804174,
                "title": "clean-and-understandable-java-solution-in-o-n",
                "content": "```\\nimport java.util.Set;\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        \\n        // Idea: find indices where charAt\\'s are different\\n        int diffIndex1 = -1;\\n        int diffIndex2 = -1;\\n        \\n        int length = A.length();\\n        for (int i = 0; i < length; i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                if (diffIndex1 == -1) diffIndex1 = i;\\n                else if (diffIndex2 == -1) diffIndex2 = i;\\n                else return false;  // More than two differences\\n            }\\n        }\\n        \\n        // No differences: return true only if some letter has frequency > 1\\n        //     since we can just swap that letter with itself\\n        if (diffIndex1 == -1) {\\n            final Set<Character> charsSeen = new HashSet<>();\\n            for (char c : A.toCharArray()) {\\n                if (charsSeen.add(c) == false) return true;\\n            }\\n            return false;\\n        }\\n        \\n        // Exactly one difference\\n        if (diffIndex2 == -1) return false;\\n        \\n        // Exactly two differences, see if it can be swapped\\n        return (A.charAt(diffIndex1) == B.charAt(diffIndex2) && \\n                A.charAt(diffIndex2) == B.charAt(diffIndex1));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Set;\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length()) return false;\\n        \\n        // Idea: find indices where charAt\\'s are different\\n        int diffIndex1 = -1;\\n        int diffIndex2 = -1;\\n        \\n        int length = A.length();\\n        for (int i = 0; i < length; i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                if (diffIndex1 == -1) diffIndex1 = i;\\n                else if (diffIndex2 == -1) diffIndex2 = i;\\n                else return false;  // More than two differences\\n            }\\n        }\\n        \\n        // No differences: return true only if some letter has frequency > 1\\n        //     since we can just swap that letter with itself\\n        if (diffIndex1 == -1) {\\n            final Set<Character> charsSeen = new HashSet<>();\\n            for (char c : A.toCharArray()) {\\n                if (charsSeen.add(c) == false) return true;\\n            }\\n            return false;\\n        }\\n        \\n        // Exactly one difference\\n        if (diffIndex2 == -1) return false;\\n        \\n        // Exactly two differences, see if it can be swapped\\n        return (A.charAt(diffIndex1) == B.charAt(diffIndex2) && \\n                A.charAt(diffIndex2) == B.charAt(diffIndex1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742068,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        \\n        if(A.length()!=B.length())\\n          return false;\\n        \\n        int i,count=0;;\\n        \\n        if(A.equals(B))\\n        {\\n            Set<Character> hs = new HashSet<>();\\n            for(i=0;i<A.length();i++)\\n               hs.add(A.charAt(i));\\n            \\n            if(hs.size()==A.length())\\n                return false;\\n        }\\n        \\n         \\n        List<Character> arr = new ArrayList<>();\\n     \\n        for(i=0;i<A.length();i++)\\n            if(A.charAt(i)!=B.charAt(i))\\n            {\\n                 arr.add(A.charAt(i));\\n                 arr.add(B.charAt(i));\\n                 count++;\\n            }\\n        \\n        if(count==0)\\n            return true;\\n        \\n        if(count==2 && arr.get(0).equals(arr.get(3)) && arr.get(1).equals(arr.get(2)))\\n           return true;\\n                                         \\n        return false;                                 \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        \\n        if(A.length()!=B.length())\\n          return false;\\n        \\n        int i,count=0;;\\n        \\n        if(A.equals(B))\\n        {\\n            Set<Character> hs = new HashSet<>();\\n            for(i=0;i<A.length();i++)\\n               hs.add(A.charAt(i));\\n            \\n            if(hs.size()==A.length())\\n                return false;\\n        }\\n        \\n         \\n        List<Character> arr = new ArrayList<>();\\n     \\n        for(i=0;i<A.length();i++)\\n            if(A.charAt(i)!=B.charAt(i))\\n            {\\n                 arr.add(A.charAt(i));\\n                 arr.add(B.charAt(i));\\n                 count++;\\n            }\\n        \\n        if(count==0)\\n            return true;\\n        \\n        if(count==2 && arr.get(0).equals(arr.get(3)) && arr.get(1).equals(arr.get(2)))\\n           return true;\\n                                         \\n        return false;                                 \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662260,
                "title": "java-o-n",
                "content": "```\\npublic boolean buddyStrings(String A, String B) {\\n\\tint[] aFreq = new int[26], bFreq = new int[26];\\n\\tint count = 0;\\n\\tfor (int i=0;i<A.length();i++) {\\n\\t\\tif(A.charAt(i) != B.charAt(i)) count ++;\\n\\t\\taFreq[A.charAt(i) - \\'a\\']++;\\n\\t\\tbFreq[B.charAt(i) - \\'a\\']++;\\n\\t}\\n\\tboolean hasDuplicates = false;\\n\\tfor (int i=0;i<26;i++) {\\n\\t\\tif(aFreq[i] != bFreq[i]) return false;\\n\\t\\tif(aFreq[i] > 1) hasDuplicates = true;\\n\\t}\\n\\tif(count != 2 && (count != 0 || !hasDuplicates)) return false;\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean buddyStrings(String A, String B) {\\n\\tint[] aFreq = new int[26], bFreq = new int[26];\\n\\tint count = 0;\\n\\tfor (int i=0;i<A.length();i++) {\\n\\t\\tif(A.charAt(i) != B.charAt(i)) count ++;\\n\\t\\taFreq[A.charAt(i) - \\'a\\']++;\\n\\t\\tbFreq[B.charAt(i) - \\'a\\']++;\\n\\t}\\n\\tboolean hasDuplicates = false;\\n\\tfor (int i=0;i<26;i++) {\\n\\t\\tif(aFreq[i] != bFreq[i]) return false;\\n\\t\\tif(aFreq[i] > 1) hasDuplicates = true;\\n\\t}\\n\\tif(count != 2 && (count != 0 || !hasDuplicates)) return false;\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638400,
                "title": "rust-more-functional-style",
                "content": "``` rust\\nimpl Solution{\\n    pub fn buddy_strings(a: String, b: String) -> bool {\\n        if a.len() != b.len() {\\n            return false;\\n        }\\n        let diff = a\\n            .chars()\\n            .zip(b.chars())\\n            .filter(|(c, d)| c != d)\\n            .collect::<Vec<(char, char)>>();\\n        if diff.len() == 0 {\\n            let mut set = std::collections::HashSet::new();\\n            for i in 0..a.len() {\\n                if set.contains(&a[i..(i + 1)]) {\\n                    return true;\\n                }\\n                set.insert(&a[i..(i + 1)]);\\n            }\\n            false\\n        } else if diff.len() == 2 {\\n            let diff_a = diff[0];\\n            let diff_b = diff[1];\\n            diff_a.0 == diff_b.1 && diff_a.1 == diff_b.0 && diff_b.0 != diff_a.0\\n        } else {\\n            false\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` rust\\nimpl Solution{\\n    pub fn buddy_strings(a: String, b: String) -> bool {\\n        if a.len() != b.len() {\\n            return false;\\n        }\\n        let diff = a\\n            .chars()\\n            .zip(b.chars())\\n            .filter(|(c, d)| c != d)\\n            .collect::<Vec<(char, char)>>();\\n        if diff.len() == 0 {\\n            let mut set = std::collections::HashSet::new();\\n            for i in 0..a.len() {\\n                if set.contains(&a[i..(i + 1)]) {\\n                    return true;\\n                }\\n                set.insert(&a[i..(i + 1)]);\\n            }\\n            false\\n        } else if diff.len() == 2 {\\n            let diff_a = diff[0];\\n            let diff_b = diff[1];\\n            diff_a.0 == diff_b.1 && diff_a.1 == diff_b.0 && diff_b.0 != diff_a.0\\n        } else {\\n            false\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488637,
                "title": "4-liner",
                "content": "```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tunordered_set<char> s;\\n\\tint bad_swaps{0}, difs{0}; \\n\\tfor(int i{0}; i<min(size(A), size(B)); bad_swaps+=A[i]-B[i], difs+=A[i]!=B[i], s.insert(A[i++]));        \\n\\treturn A.size()==B.size() and difs==2 and !bad_swaps or !difs and size(s)<size(A);\\n}\\n```\\n```\\n||\\n```\\n```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tint mem[256] = {0,};\\n\\tint reps(0), misses(0), delta(0);\\n\\tfor(int i{0}; i<size(A) and size(A)==size(B); misses+=A[i]!=B[i], delta+=A[i]-B[i++])\\n\\t\\treps = reps or exchange(mem[A[i]], 1);\\n\\treturn misses==2 and !delta or !misses and reps; \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tunordered_set<char> s;\\n\\tint bad_swaps{0}, difs{0}; \\n\\tfor(int i{0}; i<min(size(A), size(B)); bad_swaps+=A[i]-B[i], difs+=A[i]!=B[i], s.insert(A[i++]));        \\n\\treturn A.size()==B.size() and difs==2 and !bad_swaps or !difs and size(s)<size(A);\\n}\\n```\n```\\n||\\n```\n```\\nbool buddyStrings(string A, string B) \\n{            \\n\\tint mem[256] = {0,};\\n\\tint reps(0), misses(0), delta(0);\\n\\tfor(int i{0}; i<size(A) and size(A)==size(B); misses+=A[i]!=B[i], delta+=A[i]-B[i++])\\n\\t\\treps = reps or exchange(mem[A[i]], 1);\\n\\treturn misses==2 and !delta or !misses and reps; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 280680,
                "title": "multiple-python-solutions-longest-to-shortest",
                "content": "```\\ndef buddyStrings(self, A, B):\\n        if not A or not B:\\n            return False\\n        n, m = len(A), len(B)\\n        if n < m:\\n            return False\\n        if A == B:\\n            if len(A) % 2 != 0:\\n                return A[:int(n / 2)] == A[int(n / 2) + 1::]\\n            else:\\n                return A[:int(n / 2)] == A[int(n / 2)::]\\n        for i in range(n):\\n            if A[i] == B[i]:\\n                i += 1\\n            else:\\n                j = A[i + 1:].find(B[i])\\n                if j < 0:\\n                    return False\\n                else:\\n                    s = A[i + 1:][j] + A[i + 1:i + j + 1] + A[i] + A[i + j + 2:]\\n                    if s == B[i:]:\\n                        return True\\n                    return False\\n\\n        return True\\n\\ndef buddyStringsSol2(self, A, B):\\n\\tif not A or not B:\\n\\t\\treturn False\\n\\tn, m = len(A), len(B)\\n\\tif n != m:\\n\\t\\treturn False\\n\\tif A == B:\\n\\t\\tj = int(n / 2) + (1 if len(A) % 2 != 0 else 0)\\n\\t\\treturn A[:int(n / 2)] == A[j::]\\n\\tdiffPairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\tif len(diffPairs) > 2:\\n\\t\\treturn False\\n\\treturn diffPairs[0] == diffPairs[1][::-1]\\n\\ndef buddyStringsSol3(self, A, B):\\n\\tif len(A) != len(B):\\n\\t\\treturn False\\n\\tif A == B and len(set(A)) < len(A):\\n\\t\\treturn True\\n\\tpairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\treturn len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef buddyStrings(self, A, B):\\n        if not A or not B:\\n            return False\\n        n, m = len(A), len(B)\\n        if n < m:\\n            return False\\n        if A == B:\\n            if len(A) % 2 != 0:\\n                return A[:int(n / 2)] == A[int(n / 2) + 1::]\\n            else:\\n                return A[:int(n / 2)] == A[int(n / 2)::]\\n        for i in range(n):\\n            if A[i] == B[i]:\\n                i += 1\\n            else:\\n                j = A[i + 1:].find(B[i])\\n                if j < 0:\\n                    return False\\n                else:\\n                    s = A[i + 1:][j] + A[i + 1:i + j + 1] + A[i] + A[i + j + 2:]\\n                    if s == B[i:]:\\n                        return True\\n                    return False\\n\\n        return True\\n\\ndef buddyStringsSol2(self, A, B):\\n\\tif not A or not B:\\n\\t\\treturn False\\n\\tn, m = len(A), len(B)\\n\\tif n != m:\\n\\t\\treturn False\\n\\tif A == B:\\n\\t\\tj = int(n / 2) + (1 if len(A) % 2 != 0 else 0)\\n\\t\\treturn A[:int(n / 2)] == A[j::]\\n\\tdiffPairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\tif len(diffPairs) > 2:\\n\\t\\treturn False\\n\\treturn diffPairs[0] == diffPairs[1][::-1]\\n\\ndef buddyStringsSol3(self, A, B):\\n\\tif len(A) != len(B):\\n\\t\\treturn False\\n\\tif A == B and len(set(A)) < len(A):\\n\\t\\treturn True\\n\\tpairs = [(a, b) for a, b in zip(A, B) if a != b]\\n\\treturn len(pairs) == 2 and pairs[0] == pairs[1][::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 259780,
                "title": "c-using-dictionary-and-list",
                "content": "All my leetcode solution with C#(.NetCore) is at [Github](https://github.com/user3301/leetcodesln)\\n\\n```\\n public bool BuddyStringsSln(string A, string B)\\n        {\\n            if (A.Length != B.Length) return false;\\n\\n            if (A == B && A.Length >= 2)\\n            {\\n                var dict = new Dictionary<char, int>();\\n                foreach (var chr in A)\\n                {\\n                    if (dict.ContainsKey(chr))\\n                    {\\n                        return true;\\n                    }\\n                    else dict.Add(chr, 1);\\n                }\\n                return false;\\n\\n            }\\n            else\\n            {\\n                var list = new List<char>();\\n\\n                for (int i = 0; i < A.Length; i++)\\n                {\\n                    if (A[i] != B[i])\\n                    {\\n                        list.Add(A[i]);\\n                        list.Add(B[i]);\\n                    }\\n                }\\n                return list.Count == 4 && list[1] == list[2] && list[0] == list[3];\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public bool BuddyStringsSln(string A, string B)\\n        {\\n            if (A.Length != B.Length) return false;\\n\\n            if (A == B && A.Length >= 2)\\n            {\\n                var dict = new Dictionary<char, int>();\\n                foreach (var chr in A)\\n                {\\n                    if (dict.ContainsKey(chr))\\n                    {\\n                        return true;\\n                    }\\n                    else dict.Add(chr, 1);\\n                }\\n                return false;\\n\\n            }\\n            else\\n            {\\n                var list = new List<char>();\\n\\n                for (int i = 0; i < A.Length; i++)\\n                {\\n                    if (A[i] != B[i])\\n                    {\\n                        list.Add(A[i]);\\n                        list.Add(B[i]);\\n                    }\\n                }\\n                return list.Count == 4 && list[1] == list[2] && list[0] == list[3];\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215149,
                "title": "c-straightforward-solution",
                "content": "```\\nbool buddyStrings(string A, string B) {\\n        set<char> s;\\n        bool du=false;\\n        int i,j,size_A=A.size(),size_B=B.size();\\n        if(size_A<2||size_B<2||size_A!=size_B)return false;\\n        for(auto i:A) if(s.count(i)){du=true;break;} else s.insert(i);\\n        if(!du&&A==B)return false;\\n        else if(du&&A==B) return true;\\n        for(i=0;i<size_A;i++) if(A[i]!=B[i])break;\\n        for(j=size_A-1;j>-1;j--) if(A[j]!=B[j])break;\\n        swap(A[i],A[j]);\\n        return A==B;     \\n    }\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool buddyStrings(string A, string B) {\\n        set<char> s;\\n        bool du=false;\\n        int i,j,size_A=A.size(),size_B=B.size();\\n        if(size_A<2||size_B<2||size_A!=size_B)return false;\\n        for(auto i:A) if(s.count(i)){du=true;break;} else s.insert(i);\\n        if(!du&&A==B)return false;\\n        else if(du&&A==B) return true;\\n        for(i=0;i<size_A;i++) if(A[i]!=B[i])break;\\n        for(j=size_A-1;j>-1;j--) if(A[j]!=B[j])break;\\n        swap(A[i],A[j]);\\n        return A==B;     \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 206701,
                "title": "easy-to-understand-python-solution-with-44ms",
                "content": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B):\\n            return False\\n        a=b=\\'\\'\\n        if A==B:\\n            return len(set(A))<len(A)\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                a = a+A[i]\\n                b = b+B[i]\\n        \\n        if len(a) != 2 or a != b[::-1]:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, A, B):\\n        if len(A) != len(B):\\n            return False\\n        a=b=\\'\\'\\n        if A==B:\\n            return len(set(A))<len(A)\\n        for i in range(len(A)):\\n            if A[i] != B[i]:\\n                a = a+A[i]\\n                b = b+B[i]\\n        \\n        if len(a) != 2 or a != b[::-1]:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173578,
                "title": "a-simple-c-solution-runtime-beats-100-00-accepted",
                "content": "```\\nbool buddyStrings(char* A, char* B) {\\n    int Alen=strlen(A);\\n    int Blen=strlen(B);\\n    int map[26]={0};\\n    if(Alen!=Blen||Alen<2||Blen<2){\\n        return false;\\n    }\\n    char array[2][2]={0};\\n    int count=0;\\n    for(int i=0;i<Alen;i++){\\n        map[A[i]-\\'a\\']++;\\n        if(A[i]!=B[i]){\\n            if(count>=2){\\n                return false;\\n            }\\n            array[count][0]=A[i];\\n            array[count][1]=B[i];\\n            count++;\\n        }\\n    }\\n    if(count==0){\\n        for(int i=0;i<26;i++){\\n            if(map[i]>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    if(array[0][0]==array[1][1]&&array[1][0]==array[0][1]){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool buddyStrings(char* A, char* B) {\\n    int Alen=strlen(A);\\n    int Blen=strlen(B);\\n    int map[26]={0};\\n    if(Alen!=Blen||Alen<2||Blen<2){\\n        return false;\\n    }\\n    char array[2][2]={0};\\n    int count=0;\\n    for(int i=0;i<Alen;i++){\\n        map[A[i]-\\'a\\']++;\\n        if(A[i]!=B[i]){\\n            if(count>=2){\\n                return false;\\n            }\\n            array[count][0]=A[i];\\n            array[count][1]=B[i];\\n            count++;\\n        }\\n    }\\n    if(count==0){\\n        for(int i=0;i<26;i++){\\n            if(map[i]>1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    if(array[0][0]==array[1][1]&&array[1][0]==array[0][1]){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165597,
                "title": "2-line-scala-solution",
                "content": "```\\ndef buddyStrings(A: String, B: String): Boolean = {\\n    val abDiff = A.zip(B).filter(ab => ab._1 != ab._2).map(ab => ab._1.toString + ab._2).mkString(\"\")\\n    (abDiff.isEmpty && A != A.distinct) || (abDiff.size == 4 && abDiff == abDiff.reverse)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef buddyStrings(A: String, B: String): Boolean = {\\n    val abDiff = A.zip(B).filter(ab => ab._1 != ab._2).map(ab => ab._1.toString + ab._2).mkString(\"\")\\n    (abDiff.isEmpty && A != A.distinct) || (abDiff.size == 4 && abDiff == abDiff.reverse)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 142089,
                "title": "naive-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())   return false;\\n        \\n        if (A.equals(B)) {\\n            Set<Character> set = new HashSet();\\n            for (char ch : A.toCharArray()) set.add(ch);\\n            return set.size() < A.length();\\n        }\\n        \\n        List<Integer> diff = new ArrayList();\\n        \\n        for (int i = 0; i < A.length(); i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                diff.add(i);\\n                if (diff.size() > 2)    return false;\\n            }\\n        }\\n        \\n        return diff.size() == 2 && \\n            A.charAt(diff.get(0)) == B.charAt(diff.get(1)) && \\n            A.charAt(diff.get(1)) == B.charAt(diff.get(0));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String A, String B) {\\n        if (A.length() != B.length())   return false;\\n        \\n        if (A.equals(B)) {\\n            Set<Character> set = new HashSet();\\n            for (char ch : A.toCharArray()) set.add(ch);\\n            return set.size() < A.length();\\n        }\\n        \\n        List<Integer> diff = new ArrayList();\\n        \\n        for (int i = 0; i < A.length(); i++) {\\n            if (A.charAt(i) != B.charAt(i)) {\\n                diff.add(i);\\n                if (diff.size() > 2)    return false;\\n            }\\n        }\\n        \\n        return diff.size() == 2 && \\n            A.charAt(diff.get(0)) == B.charAt(diff.get(1)) && \\n            A.charAt(diff.get(1)) == B.charAt(diff.get(0));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141992,
                "title": "python",
                "content": "\\u601D\\u8DEF\\u662F\\u627E\\u5230\\u5BF9\\u5E94Index\\u7684mismatch\\uFF0C\\u7136\\u540E\\u5BF9Str1\\u6362\\u4F4D\\u7F6E\\uFF0C\\u5728\\u548CStr2\\u8FDB\\u884C\\u6BD4\\u8F83\\u3002\\u76F8\\u7B49\\u5219\\u8FD4\\u56DETrue\\n\\n\\u9700\\u8981\\u6CE8\\u610F\\u7684Edge Case\\u6BD4\\u5982\\uFF1A\\n```\\nstr1 = \\'ab\\' \\nstr2 = \\'ab\\'\\n```\\n\\u8FD9\\u79CD\\u867D\\u7136str1\\u548Cstr2\\u5BF9\\u7B49\\uFF0C\\u7136\\u5E76\\u6CA1\\u5375\\uFF0C\\u56E0\\u4E3A\\u5B9E\\u9645\\u4E0A\\u5E76\\u6CA1\\u6709\\u79FB\\u4F4D\\uFF0C\\u518D\\u770B\\u770B\\u4E0B\\u9762\\u53E6\\u4E00\\u4E2AEdge Case\\n\\n```\\nstr1 = \\'abab\\'\\nstr2 = \\'abab\\'\\n```\\n\\u8FD9\\u79CD\\u4E24\\u4E2AString\\u5BF9\\u7B49\\uFF0C\\u4F46\\u5176\\u4E2D\\u5982\\u679C\\u4E24\\u4E2Aa\\u7684\\u4F4D\\u7F6E\\u5BF9\\u8C03\\uFF0C\\u7B54\\u6848\\u4E5F\\u6210\\u7ACB\\u5E76\\u8FD4\\u56DETrue\\n\\n\\u6700\\u7EC8\\u7528\\u4E86\\u4E00\\u4E2A\\u7EFC\\u5408\\u65B9\\u6CD5\\u5904\\u7406\\u4E86\\u4E0A\\u8FF0\\u4E24\\u79CD\\u7684Edge\\uFF0C\\u8FD0\\u7528Python\\u91CC\\u9762\\u7684Set\\n```\\nif str1 == str2: \\n    return len(set(str1)) < len(str1)\\n```\\n1. \\u5982\\u679CSet\\u957F\\u5EA6\\u5BF9\\u7B49String\\u539F\\u957F\\u5EA6\\uFF0C\\u5219\\u8868\\u660EString\\u91CC\\u9762\\u6CA1\\u6709\\u91CD\\u590D\\u5B57\\u7B26\\uFF0C\\u5C31\\u5982Edge Case\\u91CC\\u9762\\u7684ab\\uFF0C\\u8FD9\\u79CD\\u65F6\\u5019\\u8FD4\\u56DEFalse\\n2. \\u5982\\u679CSet\\u957F\\u5EA6\\u5C0F\\u4E8EString\\u5143\\u957F\\u5EA6\\uFF0C\\u90A3\\u5C31\\u662FEdge Case2\\u8FD9\\u79CD\\uFF0C\\u8FD4\\u56DETrue\\n\\n\\u5269\\u4E0B\\u7684\\u5C31\\u662F\\u6362\\u6362\\u4F4D\\u7F6E\\uFF0C\\u4E0D\\u591A\\u8BB2\\u4E86\\u3002\\n\\n\\n```\\nclass Solution:\\n    def buddyStrings(self, str1, str2):\\n        \"\"\"\\n        Grab index where there is a mismatch, return the string comparison after reversing\\n        Time O(N)\\n        Space O(1) \\n        :rtype: bool\\n        \"\"\"\\n        if len(str1) != len(str2):\\n            return False\\n        if str1 == str2:\\n            return len(set(str1)) < len(str1)\\n\\n        arr = []\\n        for i, char in enumerate(str1):\\n            if char != str2[i]:\\n                arr.append(i)\\n        \\n        l = list(str1)\\n        l[arr[0]], l[arr[1]] = l[arr[1]], l[arr[0]]\\n        return \\'\\'.join(l) == str2\\n```",
                "solutionTags": [],
                "code": "```\\nstr1 = \\'ab\\' \\nstr2 = \\'ab\\'\\n```\n```\\nstr1 = \\'abab\\'\\nstr2 = \\'abab\\'\\n```\n```\\nif str1 == str2: \\n    return len(set(str1)) < len(str1)\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, str1, str2):\\n        \"\"\"\\n        Grab index where there is a mismatch, return the string comparison after reversing\\n        Time O(N)\\n        Space O(1) \\n        :rtype: bool\\n        \"\"\"\\n        if len(str1) != len(str2):\\n            return False\\n        if str1 == str2:\\n            return len(set(str1)) < len(str1)\\n\\n        arr = []\\n        for i, char in enumerate(str1):\\n            if char != str2[i]:\\n                arr.append(i)\\n        \\n        l = list(str1)\\n        l[arr[0]], l[arr[1]] = l[arr[1]], l[arr[0]]\\n        return \\'\\'.join(l) == str2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141769,
                "title": "a-few-solutions",
                "content": "If `|s| != |t|` (ie. the cardinality of `s` != the cardinality of `t`), then it is *impossible* for `s == t` with one swap, thus we return `false` immediately.\\n\\nIf `s == t`, then we *must* have an \"auxillary\" (same character) we can swap, thus we return `true` if-and-only-if the cardinality of the **set** of characters from each input string is *strictly less-than* the cardinality of characters from each input string correspondingly.\\n\\nOtherwise, we perform a linear scan of the input strings source `s` and target `t` using the array `I` to store each index `i` where `s[i] != t[i]`.  Return `true` if-and-only-if there are two indices `i`which can be swapped such that `s == t`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun buddyStrings(s: String, t: String): Boolean {\\n        if (s.length != t.length)\\n            return false\\n        if (s == t)\\n            return s.toCharArray().toSet().size < s.length && t.toCharArray().toSet().size < t.length\\n        var I = mutableListOf<Int>()\\n        for (i in 0 until s.length)\\n            if (s[i] != t[i])\\n                I.add(i)\\n        return I.size == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet buddyStrings = (s, t) => {\\n    if (s.length != t.length)\\n        return false;\\n    s = s.split(\\'\\');\\n    t = t.split(\\'\\');\\n    if (s.join(\\'\\') == t.join(\\'\\'))\\n        return new Set(s).size < s.length && new Set(t).size < t.length;\\n    let I = _.zip((s, t)).map((_, i) => s[i] != t[i] ? i : -1).filter(i => 0 <= i);\\n    return I.length == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return len(set(s)) < len(s) and len(set(t)) < len(t)\\n        I = [i for i in range(len(s)) if s[i] != t[i]]\\n        return len(I) == 2 and s[I[0]] == t[I[1]] and s[I[1]] == t[I[0]]\\n```\\n\\n*Rust*\\n```\\ntype VC = Vec<char>;\\nuse std::collections::HashSet;\\ntype Set = HashSet<char>;\\nimpl Solution {\\n    pub fn buddy_strings(s: String, t: String) -> bool {\\n        let s = s.chars().collect::<VC>();\\n        let t = t.chars().collect::<VC>();\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        if s == t {\\n            return s.clone().into_iter().collect::<Set>().len() < s.len() && t.clone().into_iter().collect::<Set>().len() < t.len();\\n        }\\n        let mut I = vec![];\\n        for i in 0..s.len() {\\n            if s[i] != t[i] {\\n                I.push(i);\\n            }\\n        }\\n        I.len() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<char>;\\n    bool buddyStrings(string s, string t, VI I = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        if (s == t)\\n            return Set{ s.begin(), s.end() }.size() < s.size() && Set{ t.begin(), t.end() }.size() < t.size();\\n        for (auto i{ 0 }; i < s.size(); ++i)\\n            if (s[i] != t[i])\\n                I.push_back(i);\\n        return I.size() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun buddyStrings(s: String, t: String): Boolean {\\n        if (s.length != t.length)\\n            return false\\n        if (s == t)\\n            return s.toCharArray().toSet().size < s.length && t.toCharArray().toSet().size < t.length\\n        var I = mutableListOf<Int>()\\n        for (i in 0 until s.length)\\n            if (s[i] != t[i])\\n                I.add(i)\\n        return I.size == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\n```\\nlet buddyStrings = (s, t) => {\\n    if (s.length != t.length)\\n        return false;\\n    s = s.split(\\'\\');\\n    t = t.split(\\'\\');\\n    if (s.join(\\'\\') == t.join(\\'\\'))\\n        return new Set(s).size < s.length && new Set(t).size < t.length;\\n    let I = _.zip((s, t)).map((_, i) => s[i] != t[i] ? i : -1).filter(i => 0 <= i);\\n    return I.length == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n};\\n```\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, t: str) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return len(set(s)) < len(s) and len(set(t)) < len(t)\\n        I = [i for i in range(len(s)) if s[i] != t[i]]\\n        return len(I) == 2 and s[I[0]] == t[I[1]] and s[I[1]] == t[I[0]]\\n```\n```\\ntype VC = Vec<char>;\\nuse std::collections::HashSet;\\ntype Set = HashSet<char>;\\nimpl Solution {\\n    pub fn buddy_strings(s: String, t: String) -> bool {\\n        let s = s.chars().collect::<VC>();\\n        let t = t.chars().collect::<VC>();\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        if s == t {\\n            return s.clone().into_iter().collect::<Set>().len() < s.len() && t.clone().into_iter().collect::<Set>().len() < t.len();\\n        }\\n        let mut I = vec![];\\n        for i in 0..s.len() {\\n            if s[i] != t[i] {\\n                I.push(i);\\n            }\\n        }\\n        I.len() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]]\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<char>;\\n    bool buddyStrings(string s, string t, VI I = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        if (s == t)\\n            return Set{ s.begin(), s.end() }.size() < s.size() && Set{ t.begin(), t.end() }.size() < t.size();\\n        for (auto i{ 0 }; i < s.size(); ++i)\\n            if (s[i] != t[i])\\n                I.push_back(i);\\n        return I.size() == 2 && s[I[0]] == t[I[1]] && s[I[1]] == t[I[0]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045040,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n\\n        int diff = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) != goal.charAt(i)) diff++;\\n        }\\n\\n        System.out.print(diff);\\n        if(diff == 2) {\\n            int firstIndex = 0;\\n            int secondIndex = 0;\\n\\n            for(int i = 0; i < s.length(); i++) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    firstIndex = i; break;\\n                } \\n            }\\n\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    secondIndex = i; break;\\n                } \\n            }\\n\\n            if(s.charAt(secondIndex) == goal.charAt(firstIndex) && s.charAt(firstIndex) == goal.charAt(secondIndex)) {\\n                System.out.print(\"first\");\\n                return true;\\n            } \\n        }\\n\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) set.add(s.charAt(i));\\n\\n        if(diff == 0 && s.length() != set.size()) {\\n            System.out.print(\"second\");\\n            return true;\\n        }\\n\\n        System.out.print(\"third\");\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n\\n        int diff = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s.charAt(i) != goal.charAt(i)) diff++;\\n        }\\n\\n        System.out.print(diff);\\n        if(diff == 2) {\\n            int firstIndex = 0;\\n            int secondIndex = 0;\\n\\n            for(int i = 0; i < s.length(); i++) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    firstIndex = i; break;\\n                } \\n            }\\n\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                if(s.charAt(i) != goal.charAt(i)) {\\n                    secondIndex = i; break;\\n                } \\n            }\\n\\n            if(s.charAt(secondIndex) == goal.charAt(firstIndex) && s.charAt(firstIndex) == goal.charAt(secondIndex)) {\\n                System.out.print(\"first\");\\n                return true;\\n            } \\n        }\\n\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < s.length(); i++) set.add(s.charAt(i));\\n\\n        if(diff == 0 && s.length() != set.size()) {\\n            System.out.print(\"second\");\\n            return true;\\n        }\\n\\n        System.out.print(\"third\");\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722422,
                "title": "no-map-just-simple-logic",
                "content": "\\n# Approach\\nThere is only **ONE** main approach which will solve the entire question that is ***If there is any duplicate in string \"s\" then check for that ,*** otherwise ***Use two pointer in a simple manner***.\\n\\n# Explained the Code with comments!\\n\\n\\n```\\nclass Solution {\\npublic:\\nbool checkDuplicate(string &s)\\n{\\n    int CountOfEachCharacter[26] = {0}; // let count of all element is 0\\n    for(auto &it : s)\\n    {\\n        CountOfEachCharacter[it-\\'a\\']++; // Add the count of each character\\n        if(CountOfEachCharacter[it-\\'a\\'] > 1) // If any element have more than one count, it implies we have a duplicate\\n            return true;\\n    }\\n    return false; // No duplicate found\\n}\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return false; // If the length of both strings are not same , then fasle;\\n\\n        if(s == goal){  // if both strings are identical i.e abab and abab\\n            return checkDuplicate(s);\\n        }\\n        vector<int> index; // To contain the index of elements to be swapped \\n        int count = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s[i] != goal[i])\\n                index.push_back(i),count++;  // Store the index of element where ele are not same like s= abc and goal= acb\\n                                        // now element at index at 1 and 2 are not same , so we will store them \\n            if(count > 2)\\n                break;\\n        }\\n        if(index.size() != 2)  // If there are more than 2 elements to swap we will return false,as only 1 swap is allowed     \\n            return false; \\n        swap(s[index[0]],s[index[1]]); // Swap those elements .. i.e s = acb ( swapped b and c)\\n        return s == goal; // check if s == goal  i.e acb == acb , return true. if not same then return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool checkDuplicate(string &s)\\n{\\n    int CountOfEachCharacter[26] = {0}; // let count of all element is 0\\n    for(auto &it : s)\\n    {\\n        CountOfEachCharacter[it-\\'a\\']++; // Add the count of each character\\n        if(CountOfEachCharacter[it-\\'a\\'] > 1) // If any element have more than one count, it implies we have a duplicate\\n            return true;\\n    }\\n    return false; // No duplicate found\\n}\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.length()) return false; // If the length of both strings are not same , then fasle;\\n\\n        if(s == goal){  // if both strings are identical i.e abab and abab\\n            return checkDuplicate(s);\\n        }\\n        vector<int> index; // To contain the index of elements to be swapped \\n        int count = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s[i] != goal[i])\\n                index.push_back(i),count++;  // Store the index of element where ele are not same like s= abc and goal= acb\\n                                        // now element at index at 1 and 2 are not same , so we will store them \\n            if(count > 2)\\n                break;\\n        }\\n        if(index.size() != 2)  // If there are more than 2 elements to swap we will return false,as only 1 swap is allowed     \\n            return false; \\n        swap(s[index[0]],s[index[1]]); // Swap those elements .. i.e s = acb ( swapped b and c)\\n        return s == goal; // check if s == goal  i.e acb == acb , return true. if not same then return false\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720425,
                "title": "python-solution",
                "content": "# Approach\\nIn the question, the condition was that only two letters will be swapped to get the goal string.\\n\\nFirst step is to get the index positions where the string \\'s\\' is not equal to \\'goal\\' string.\\n\\nIf the no.of index positions received was greater than 1, then we should swap those positions in s and compare the result with the goal. If they were equal we should return True, else False.\\neg: s=\"abcd\", goal=\"cbad\", index pos = [0,2]\\n\\nIf only letter in \\'s\\' is not equal to \\'goal\\', then there\\'s no possibility to swap. So we should return False.\\neg: s=\"abcd\", goal=\"abce\", index pos = [3]\\n\\nIf \\'s\\' is equal to \\'goal\\' and if one of the letters in \\'s\\' is repeated more than once, then there\\'s a possibility for swapping those same letters. So we should return True.\\neg: s=\"abad\", goal=\"abad\", s[0] & s[2] can be swapped\\n\\nIf \\'s\\' is equal to \\'goal\\' and there is no characters repeated in \\'s\\', then we should return False.\\neg: s=\"abcd\", goal=\"abcd\", result = False\\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        ind = []\\n\\n        for x in range(len(s)):\\n            if s[x]!=goal[x]:\\n                ind.append(x)\\n\\n        if ind:\\n            s = list(s)\\n            \\n            if len(ind)>1:\\n                s[ind[0]],s[ind[1]]=s[ind[1]],s[ind[0]]\\n                s = \"\".join(s)\\n                \\n                if s==goal:\\n                    return (True)\\n                else:\\n                    return False\\n            else:\\n                return False\\n\\n        elif s==goal:\\n            for x in s:\\n                if s.count(x)>1:\\n                    return (True)\\n            else:\\n                return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        ind = []\\n\\n        for x in range(len(s)):\\n            if s[x]!=goal[x]:\\n                ind.append(x)\\n\\n        if ind:\\n            s = list(s)\\n            \\n            if len(ind)>1:\\n                s[ind[0]],s[ind[1]]=s[ind[1]],s[ind[0]]\\n                s = \"\".join(s)\\n                \\n                if s==goal:\\n                    return (True)\\n                else:\\n                    return False\\n            else:\\n                return False\\n\\n        elif s==goal:\\n            for x in s:\\n                if s.count(x)>1:\\n                    return (True)\\n            else:\\n                return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714750,
                "title": "java-solution-of-naresh-gupta-sir",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)){\\n            Set<Character> st = new HashSet<>();\\n            for(char c : s.toCharArray()){\\n                if(st.contains(c)) return true;\\n                st.add(c);\\n            }\\n            return false;\\n        }\\n        else {\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0; i<s.length();i++){\\n                if(s.charAt(i) != goal.charAt(i)) al.add(i);\\n            }\\n            return al.size() == 2 && s.charAt(al.get(0)) == goal.charAt(al.get(1)) && s.charAt(al.get(1)) == goal.charAt(al.get(0));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length() != goal.length()) return false;\\n        if(s.equals(goal)){\\n            Set<Character> st = new HashSet<>();\\n            for(char c : s.toCharArray()){\\n                if(st.contains(c)) return true;\\n                st.add(c);\\n            }\\n            return false;\\n        }\\n        else {\\n            List<Integer> al = new ArrayList<>();\\n            for(int i = 0; i<s.length();i++){\\n                if(s.charAt(i) != goal.charAt(i)) al.add(i);\\n            }\\n            return al.size() == 2 && s.charAt(al.get(0)) == goal.charAt(al.get(1)) && s.charAt(al.get(1)) == goal.charAt(al.get(0));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714714,
                "title": "99-98-java-easiest-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        if (s.equals(goal)) {\\n            HashSet<Character> set = new HashSet<>();\\n            for (char c: s.toCharArray()) {\\n                if (!set.add(c)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        int dif = 0;\\n        Character swapS = null;\\n        Character swapG = null;\\n        for (int i = 0; i < s.length(); i++) {\\n            char sChar = s.charAt(i);\\n            char gChar = goal.charAt(i);\\n            if (sChar != gChar) {\\n                if (dif == 2 || (dif == 1 && (swapS != gChar || swapG != sChar))) {\\n                    return false;\\n                }\\n                swapS = sChar;\\n                swapG = gChar;\\n                dif++;\\n            }\\n        }\\n        return dif == 2;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/427827f8-4195-4cf2-b126-469d43f1d508_1688420417.250366.png)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length()) {\\n            return false;\\n        }\\n\\n        if (s.equals(goal)) {\\n            HashSet<Character> set = new HashSet<>();\\n            for (char c: s.toCharArray()) {\\n                if (!set.add(c)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        int dif = 0;\\n        Character swapS = null;\\n        Character swapG = null;\\n        for (int i = 0; i < s.length(); i++) {\\n            char sChar = s.charAt(i);\\n            char gChar = goal.charAt(i);\\n            if (sChar != gChar) {\\n                if (dif == 2 || (dif == 1 && (swapS != gChar || swapG != sChar))) {\\n                    return false;\\n                }\\n                swapS = sChar;\\n                swapG = gChar;\\n                dif++;\\n            }\\n        }\\n        return dif == 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714671,
                "title": "asked-by-google-microsoft-simple-approach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        \\n        if(s.equals(goal)){\\n            HashMap<Character,Integer> hm = new HashMap<>();\\n            for(char ch : s.toCharArray()){\\n                hm.put(ch,hm.getOrDefault(ch,0)+1);\\n            }\\n            for(char ch:hm.keySet()){\\n                if(hm.get(ch)>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            ArrayList<Integer> in = new ArrayList<>();\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                char ch1 = goal.charAt(i);\\n                if(ch!= ch1 && hm.containsKey(ch1)) in.add(i);\\n            }\\n            if(in.size()==2){\\n                    //Checking by Swapping\\n                    StringBuilder s1 = new StringBuilder(s);\\n                    char ch2 = s1.charAt(in.get(0));\\n                    s1.setCharAt(in.get(0),s1.charAt(in.get(1)));\\n                    s1.setCharAt(in.get(1),ch2);\\n                    System.out.print(s1);\\n                    if(s1.toString().equals(goal)) return true;\\n            } \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if(s.length()!=goal.length()) return false;\\n        \\n        if(s.equals(goal)){\\n            HashMap<Character,Integer> hm = new HashMap<>();\\n            for(char ch : s.toCharArray()){\\n                hm.put(ch,hm.getOrDefault(ch,0)+1);\\n            }\\n            for(char ch:hm.keySet()){\\n                if(hm.get(ch)>1){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n        else{\\n            ArrayList<Integer> in = new ArrayList<>();\\n            for(int i=0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                char ch1 = goal.charAt(i);\\n                if(ch!= ch1 && hm.containsKey(ch1)) in.add(i);\\n            }\\n            if(in.size()==2){\\n                    //Checking by Swapping\\n                    StringBuilder s1 = new StringBuilder(s);\\n                    char ch2 = s1.charAt(in.get(0));\\n                    s1.setCharAt(in.get(0),s1.charAt(in.get(1)));\\n                    s1.setCharAt(in.get(1),ch2);\\n                    System.out.print(s1);\\n                    if(s1.toString().equals(goal)) return true;\\n            } \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714161,
                "title": "c-explanation-comments-in-code-beats-100",
                "content": "# \\u2728Approach\\n- We know it should return true if there is only one mismatch and can should be resolved by swapping the elements.\\n- and also if both string are same but have repeating characters in them.\\n\\n# \\u2728Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n       if(s.length()!=goal.length())\\n       return false; // not possible if lengths are not same\\n\\n       unordered_map<char,int> freq; // for counting frequency of char in strings\\n       vector<char> index; // \\n       int count = 0;\\n\\n       for(int i=0;i<s.length();i++)\\n       {\\n            freq[s[i]]++;\\n            freq[goal[i]]++;\\n           if(s[i]!=goal[i])\\n           {\\n            count++;\\n            if(count>2)\\n            return false;\\n            index.push_back(s[i]);\\n            index.push_back(goal[i]);\\n           }\\n       }\\n            if(index.size() >= 4 && index[0]==index[3] && index[1]==index[2]) // if 1st occurence in 1st string is same as 2nd occurence in 2nd string and if 2nd occurence in first string is same as 1st occurence in 2nd string\\n            return true;\\n            \\n            if(index.size() >= 4 && (index[0]!=index[3] || index[1]!=index[2] ))\\n            return false; // if there are more than equal to 2 mismatches but cannot be resolved by swapping\\n            \\n            int flag = 0;\\n            for(auto i:freq)\\n            {\\n                if(i.second%2!=0) // if occurence is not even means there is presence in and not the other\\n                return false;\\n\\n                if(i.second >= 4) // if there is repeating chars in string \\n                flag = 1;   \\n            }\\n\\n            if(flag==1)\\n            return true;\\n\\n       return false;\\n       }       \\n};\\n```\\n![tu2.gif](https://assets.leetcode.com/users/images/9c8afe91-6e0f-4e58-b9de-2004b92a3c3a_1688407815.1381857.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n       if(s.length()!=goal.length())\\n       return false; // not possible if lengths are not same\\n\\n       unordered_map<char,int> freq; // for counting frequency of char in strings\\n       vector<char> index; // \\n       int count = 0;\\n\\n       for(int i=0;i<s.length();i++)\\n       {\\n            freq[s[i]]++;\\n            freq[goal[i]]++;\\n           if(s[i]!=goal[i])\\n           {\\n            count++;\\n            if(count>2)\\n            return false;\\n            index.push_back(s[i]);\\n            index.push_back(goal[i]);\\n           }\\n       }\\n            if(index.size() >= 4 && index[0]==index[3] && index[1]==index[2]) // if 1st occurence in 1st string is same as 2nd occurence in 2nd string and if 2nd occurence in first string is same as 1st occurence in 2nd string\\n            return true;\\n            \\n            if(index.size() >= 4 && (index[0]!=index[3] || index[1]!=index[2] ))\\n            return false; // if there are more than equal to 2 mismatches but cannot be resolved by swapping\\n            \\n            int flag = 0;\\n            for(auto i:freq)\\n            {\\n                if(i.second%2!=0) // if occurence is not even means there is presence in and not the other\\n                return false;\\n\\n                if(i.second >= 4) // if there is repeating chars in string \\n                flag = 1;   \\n            }\\n\\n            if(flag==1)\\n            return true;\\n\\n       return false;\\n       }       \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714157,
                "title": "different-approach-easy-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.size())return false;\\n        // now traversing the whole string and count the unmatched elements\\n        // if that count is eqauls to 2 then true otherwise false\\n        int count=0, trav=0;\\n        vector<int> v(26,0), g(26,0);\\n        set<char> ss;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] != goal[i]) trav++;\\n            v[s[i]-\\'a\\']++;\\n            g[goal[i]-\\'a\\']++;\\n            ss.insert(s[i]);\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i] != g[i])\\n            count += abs(v[i]-g[i]);\\n        }\\n        if(count!=0)return false; // means all elements having same frequency\\n        if(s==goal){\\n            if(ss.size()<s.size())return true; // duplicate present\\n            return false;\\n        }\\n        else if(trav==2 || trav==0) return true; // exactly 2 swaps needed\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() != goal.size())return false;\\n        // now traversing the whole string and count the unmatched elements\\n        // if that count is eqauls to 2 then true otherwise false\\n        int count=0, trav=0;\\n        vector<int> v(26,0), g(26,0);\\n        set<char> ss;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] != goal[i]) trav++;\\n            v[s[i]-\\'a\\']++;\\n            g[goal[i]-\\'a\\']++;\\n            ss.insert(s[i]);\\n        }\\n        for(int i=0;i<26;i++){\\n            if(v[i] != g[i])\\n            count += abs(v[i]-g[i]);\\n        }\\n        if(count!=0)return false; // means all elements having same frequency\\n        if(s==goal){\\n            if(ss.size()<s.size())return true; // duplicate present\\n            return false;\\n        }\\n        else if(trav==2 || trav==0) return true; // exactly 2 swaps needed\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714125,
                "title": "python-short-and-clean-match-statement-functional-programming",
                "content": "# Approach\\n1. Iterate simultaneously through `s` and `goal` and select (`filter`) non matching pairs.\\n\\n2. If there are no such pairs, we can\\'t swap. Unless there is atleast one repeated character in the strings. This can be done by returning `len(set(s)) != len(s)`.\\n\\n3. If not any of the above case, return `False`.\\n\\n# Complexity\\n- Time complexity: $$O(max(n, m))$$\\n\\n- Space complexity: $$O(max(n, m))$$\\n\\nwhere,\\n`n is length of s`,\\n`m is length of goal`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        match tuple(filter(lambda pair: ne(*pair), zip_longest(s, goal))):\\n            case (): return len(set(s)) != len(s)\\n            case ((a1, b1), (a2, b2)): return (a1, b1) == (b2, a2)\\n            case other: return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714055,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n\\n        if (s.equals(goal)) {\\n            \\n            HashMap<Character, Integer> frequency = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                frequency.put(c, frequency.getOrDefault(c, 0) + 1);\\n            }\\n\\n            for (int count : frequency.values()) {\\n                if (count >= 2)\\n                    return true;\\n            }\\n        }\\n\\n        int mismatchCount = 0;\\n        int firstIndex = -1;\\n        int secondIndex = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n                mismatchCount++;\\n\\n                if (mismatchCount > 2)\\n                    return false;\\n\\n                if (firstIndex == -1) {\\n                    firstIndex = i;\\n                } else {\\n                    secondIndex = i;\\n                }\\n            }\\n        }\\n\\n        if (mismatchCount == 2) {\\n            return (s.charAt(firstIndex) == goal.charAt(secondIndex))\\n                    && (s.charAt(secondIndex) == goal.charAt(firstIndex));\\n        }\\n\\n        return false;\\n    }\\n}\\n        \\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean buddyStrings(String s, String goal) {\\n        if (s.length() != goal.length())\\n            return false;\\n\\n        if (s.equals(goal)) {\\n            \\n            HashMap<Character, Integer> frequency = new HashMap<>();\\n            for (char c : s.toCharArray()) {\\n                frequency.put(c, frequency.getOrDefault(c, 0) + 1);\\n            }\\n\\n            for (int count : frequency.values()) {\\n                if (count >= 2)\\n                    return true;\\n            }\\n        }\\n\\n        int mismatchCount = 0;\\n        int firstIndex = -1;\\n        int secondIndex = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) != goal.charAt(i)) {\\n                mismatchCount++;\\n\\n                if (mismatchCount > 2)\\n                    return false;\\n\\n                if (firstIndex == -1) {\\n                    firstIndex = i;\\n                } else {\\n                    secondIndex = i;\\n                }\\n            }\\n        }\\n\\n        if (mismatchCount == 2) {\\n            return (s.charAt(firstIndex) == goal.charAt(secondIndex))\\n                    && (s.charAt(secondIndex) == goal.charAt(firstIndex));\\n        }\\n\\n        return false;\\n    }\\n}\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713961,
                "title": "python3-o-n-time-o-1-space-3-line-solution-short-and-dense",
                "content": "# Intuition\\nIt is as in the editorial, just condensed\\n\\n# Approach\\nExactly the same concept as editorial, but with slight changes in order and execution.\\nIf the lengths are different it must be false.\\nWe collect differences first instead of comparing string equivalence.\\n\\nAnother way to test equivalence is checking that differences equal 0. When that is true, the answer depends on duplicate letters. Instead of iterating, comparing to dictonary and storing, we compare set length to string length. Since sets don\\'t store duplicates, if duplicates are present it will be shorter. Credit to @RottenDoom for the set suggestion.\\n\\nThe only condition left to test for is that there are exactly 2 differences, and they are the reverse of each other. We test for this using slice with -1 increment to reverse one of them and check equivalence.\\n\\nJob done.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i]]\\n        return (len(differences) == 0 and len(set(s)) < len(s)) or (len(differences) == 2 and differences[0] ==  differences[1][::-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if len(s) != len(goal): return False\\n        differences = [(s[i], goal[i]) for i in range(len(s)) if s[i] != goal[i]]\\n        return (len(differences) == 0 and len(set(s)) < len(s)) or (len(differences) == 2 and differences[0] ==  differences[1][::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713951,
                "title": "c-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size() != goal.size()) return false;\\n        if(s == goal && unordered_set<char>(s.begin(), s.end()).size() < s.size()) {\\n            return true;\\n        }\\n        unordered_map<char, int> a, b;\\n        for(auto i : s) a[i]++;\\n        for(auto i : goal) b[i]++;\\n\\n        int count = 0; // not_equal count\\n        for(int i = 0; i < s.size(); i++) {\\n            if(a[goal[i]] == 0 || b[s[i]] == 0) {\\n                return false;\\n            }\\n            if(s[i] != goal[i]) {\\n                count++;\\n                a[goal[i]]--;\\n                b[s[i]]--;\\n            }\\n            if(count > 2) return false;\\n        }\\n        return count == 2 ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size() != goal.size()) return false;\\n        if(s == goal && unordered_set<char>(s.begin(), s.end()).size() < s.size()) {\\n            return true;\\n        }\\n        unordered_map<char, int> a, b;\\n        for(auto i : s) a[i]++;\\n        for(auto i : goal) b[i]++;\\n\\n        int count = 0; // not_equal count\\n        for(int i = 0; i < s.size(); i++) {\\n            if(a[goal[i]] == 0 || b[s[i]] == 0) {\\n                return false;\\n            }\\n            if(s[i] != goal[i]) {\\n                count++;\\n                a[goal[i]]--;\\n                b[s[i]]--;\\n            }\\n            if(count > 2) return false;\\n        }\\n        return count == 2 ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713906,
                "title": "buddy-strings",
                "content": "**Approach I**\\n*Brute-Force: O(N^2)*\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n=s.length();\\n        // if(s==goal) return true;\\n        for(int i=0;i<n;i++)\\n        {\\n            string ss=s;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                swap(ss[i],ss[j]);\\n                if(ss==goal) return true; \\n                swap(ss[i],ss[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Approach II**\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int n = s.length();\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n=s.length();\\n        // if(s==goal) return true;\\n        for(int i=0;i<n;i++)\\n        {\\n            string ss=s;\\n            for(int j=i+1;j<n;j++)\\n            {\\n                swap(ss[i],ss[j]);\\n                if(ss==goal) return true; \\n                swap(ss[i],ss[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n         int n = s.length();\\n        if(s == goal){\\n            set<char> temp(s.begin(), s.end());\\n            return temp.size() < goal.size(); // Swapping same characters\\n        }\\n\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i]){\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j]){\\n            j--;\\n        }\\n\\n        if(i < j){\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713903,
                "title": "keeping-track-of-previous-occurrences-of-goal-s-char-c-map-stack-tc-o-n-sc-o-n",
                "content": "# Intuition\\nThe problem requires checking whether two strings can be made equal by swapping two characters. To solve this, we can iterate over the strings and compare the characters at each position. If we find two positions i and j such that s[i] != goal[i] and s[j] != goal[j], and s[i] == goal[j] and s[j] == goal[i], then it is possible to swap two letters to make the strings equal.\\n\\n# Approach\\n1. Initialize an unordered map mp to store the characters of string s as keys and a stack of indices where each character occurs as values.\\n2. Initialize variables n and i to store the size of string s and initialize i as 0.\\n3. Iterate over the string s using a while loop until i reaches n.\\n4. If s[i] is not equal to goal[i], check if goal[i] exists in the map mp.\\n5. If it exists, swap s[i] with s[mp[goal[i]].top()] to perform the character swap.\\n6. Create a stack st and assign the stack of indices for the character goal[i] from the map mp.\\n7. While the stack st is not empty and s is still not equal to goal, perform the character swap by swapping s[i] with s[st.top()] and pop the top element of st.\\n8. Push the index i onto the stack for the character s[i] in the map mp.\\n9. Increment i by 1.\\n10. After the loop, check if s is equal to goal and the size of the map mp is less than n.\\n11. If both conditions are satisfied, return true; otherwise, return false.\\n\\n# Complexity\\n- Time complexity: The while loop iterates over the string s, resulting in a time complexity of O(n), where n is the length of the string.\\n- Space complexity: The space complexity is O(n), where n is the length of the string s, as we are using a map to store the characters and their indices.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        unordered_map<char,stack<int>> mp ;\\n        int n = s.size();\\n        int i=0;\\n        \\n        while(i<n){                \\n            if(s[i]!=goal[i]){\\n                if(mp.find(goal[i])!=mp.end()){\\n                    swap(s[i],s[mp[goal[i]].top()]);\\n                    stack<int> st = mp[goal[i]];\\n                    while(!st.empty() and s!=goal){\\n                        swap(s[i],s[st.top()]);\\n                        st.pop();\\n                    }\\n                }\\n            }\\n            mp[s[i]].push(i);\\n            i++;\\n        }\\n        if(s==goal and mp.size()<n) return true;\\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        unordered_map<char,stack<int>> mp ;\\n        int n = s.size();\\n        int i=0;\\n        \\n        while(i<n){                \\n            if(s[i]!=goal[i]){\\n                if(mp.find(goal[i])!=mp.end()){\\n                    swap(s[i],s[mp[goal[i]].top()]);\\n                    stack<int> st = mp[goal[i]];\\n                    while(!st.empty() and s!=goal){\\n                        swap(s[i],s[st.top()]);\\n                        st.pop();\\n                    }\\n                }\\n            }\\n            mp[s[i]].push(i);\\n            i++;\\n        }\\n        if(s==goal and mp.size()<n) return true;\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713656,
                "title": "c-super-easy-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(n != goal.size()) return false;\\n\\n        if(s == goal){\\n            int freq[26] = {0};\\n            for(int i=0; i<n; i++){\\n                freq[s[i]-\\'a\\']++;\\n            }\\n            for(int i=0; i<26; i++){\\n                if(freq[i] > 1) return true;\\n            }\\n            return false;\\n        }\\n\\n        int first = -1;\\n        int second = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i] != goal[i]){\\n                second = first;\\n                first = i;\\n            }\\n            if(second > -1){\\n                swap(s[first],s[second]);\\n                break;\\n            }\\n        }\\n        if(first == -1 || second == -1) return false;\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int n = s.size();\\n        if(n != goal.size()) return false;\\n\\n        if(s == goal){\\n            int freq[26] = {0};\\n            for(int i=0; i<n; i++){\\n                freq[s[i]-\\'a\\']++;\\n            }\\n            for(int i=0; i<26; i++){\\n                if(freq[i] > 1) return true;\\n            }\\n            return false;\\n        }\\n\\n        int first = -1;\\n        int second = -1;\\n\\n        for(int i=0; i<n; i++){\\n            if(s[i] != goal[i]){\\n                second = first;\\n                first = i;\\n            }\\n            if(second > -1){\\n                swap(s[first],s[second]);\\n                break;\\n            }\\n        }\\n        if(first == -1 || second == -1) return false;\\n\\n        return s == goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713530,
                "title": "solution-python-easy-to-understand",
                "content": "# Intuition\\nThe problem description states that you need to swap exactly two characters in s to make it equal to goal.\\n\\n# Approach\\nIn the modified code, we handle the case where s and goal are equal separately. We also check for the condition where the lengths of s and goal are not equal, in which case it is not possible to make them equal through swaps.\\n\\nIf there are exactly two differing indices, we check if swapping the characters at those indices will make s equal to goal. If it does, we return True; otherwise, we return False.\\n\\n# Complexity\\n- Time complexity:\\nThe overall time complexity of the solution is O(n).\\n\\n- Space complexity:\\nThe space complexity of the solution is O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        if s == goal:\\n            # Check if s and goal are equal\\n            # If they are, check if there are any repeated characters in s\\n            # If there are, we can swap two of them to make s equal to goal\\n            # Otherwise, we cannot make any swaps, so return False\\n            return len(set(s)) < len(s)\\n\\n        if len(s) != len(goal):\\n            # If the lengths of s and goal are not equal, we cannot make them equal through swaps\\n            return False\\n\\n        # Find the indices where s and goal differ\\n        indices = [i for i in range(len(s)) if s[i] != goal[i]]\\n\\n        # If there are exactly two differing indices, we can swap the characters at those indices\\n        if len(indices) == 2:\\n            i, j = indices\\n            if s[i] == goal[j] and s[j] == goal[i]:\\n                return True\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buddyStrings(self, s, goal):\\n        if s == goal:\\n            # Check if s and goal are equal\\n            # If they are, check if there are any repeated characters in s\\n            # If there are, we can swap two of them to make s equal to goal\\n            # Otherwise, we cannot make any swaps, so return False\\n            return len(set(s)) < len(s)\\n\\n        if len(s) != len(goal):\\n            # If the lengths of s and goal are not equal, we cannot make them equal through swaps\\n            return False\\n\\n        # Find the indices where s and goal differ\\n        indices = [i for i in range(len(s)) if s[i] != goal[i]]\\n\\n        # If there are exactly two differing indices, we can swap the characters at those indices\\n        if len(indices) == 2:\\n            i, j = indices\\n            if s[i] == goal[j] and s[j] == goal[i]:\\n                return True\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713504,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if(s.Length!=goal.Length)\\n            return false;\\n        // iterate over s\\n        // if diff put in dict\\n        // if dict is empty by the end check if there is repeated letters using hashset\\n        Dictionary<char,char> dict=new();\\n        HashSet<char> set=new();\\n        bool duplicates=false;\\n        for(int i=0;i<s.Length;i++){\\n            if(s[i]!=goal[i]){\\n                if(dict.Count>1)\\n                    return false;\\n                else if (dict.Count==1){\\n                    if(!dict.ContainsKey(s[i]))\\n                        return false;\\n                    if(dict[s[i]]!=goal[i])\\n                        return false;\\n                    dict[goal[i]]=s[i];\\n                }\\n                else{\\n                    dict[goal[i]]=s[i];\\n                }\\n            }\\n            if(set.Contains(s[i])){\\n                duplicates=true;\\n            }\\n            set.Add(s[i]);\\n        }\\n        return (dict.Count!=1) && (dict.Count>0 || duplicates) ? true:false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool BuddyStrings(string s, string goal) {\\n        if(s.Length!=goal.Length)\\n            return false;\\n        // iterate over s\\n        // if diff put in dict\\n        // if dict is empty by the end check if there is repeated letters using hashset\\n        Dictionary<char,char> dict=new();\\n        HashSet<char> set=new();\\n        bool duplicates=false;\\n        for(int i=0;i<s.Length;i++){\\n            if(s[i]!=goal[i]){\\n                if(dict.Count>1)\\n                    return false;\\n                else if (dict.Count==1){\\n                    if(!dict.ContainsKey(s[i]))\\n                        return false;\\n                    if(dict[s[i]]!=goal[i])\\n                        return false;\\n                    dict[goal[i]]=s[i];\\n                }\\n                else{\\n                    dict[goal[i]]=s[i];\\n                }\\n            }\\n            if(set.Contains(s[i])){\\n                duplicates=true;\\n            }\\n            set.Add(s[i]);\\n        }\\n        return (dict.Count!=1) && (dict.Count>0 || duplicates) ? true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713434,
                "title": "beats-100-easy-explanation-explained-line-by-line-comments",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        int count = 0; //counts the number of different characters\\n        int f_ind = -1, s_ind = -1; //stores first index and second index of different characters\\n        \\n        if(s.size()!=goal.size()) return false; //if the two strings are of unequal length, then no swapping can make them equal\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])\\n            {\\n                count++;\\n                if(count>2) return false; //more than two different characters are present\\n                if(f_ind==-1) f_ind=i;\\n                else s_ind=i;\\n            }\\n        }\\n        \\n        if(count == 0){ //equal strings\\n            int freq[26] = {0};\\n            for(int i=0;i<s.size();i++){\\n                freq[s[i]-\\'a\\']++;\\n                if(freq[s[i]-\\'a\\']==2){\\n                    return true; //since we found two same elements which can be swapped\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        //only one unequal character is present which cannot be swapped with any other\\n        else if(count==1) \\n            return false;\\n        \\n        swap(s[f_ind], s[s_ind]);\\n        if(s==goal) return true;\\n        else return false;\\n        \\n    }\\n};\\n```\\n\\n\\n**P.S: Do give it an upvote if this helped! Feel free to comment below in case of any queries or suggestions :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        \\n        int count = 0; //counts the number of different characters\\n        int f_ind = -1, s_ind = -1; //stores first index and second index of different characters\\n        \\n        if(s.size()!=goal.size()) return false; //if the two strings are of unequal length, then no swapping can make them equal\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i])\\n            {\\n                count++;\\n                if(count>2) return false; //more than two different characters are present\\n                if(f_ind==-1) f_ind=i;\\n                else s_ind=i;\\n            }\\n        }\\n        \\n        if(count == 0){ //equal strings\\n            int freq[26] = {0};\\n            for(int i=0;i<s.size();i++){\\n                freq[s[i]-\\'a\\']++;\\n                if(freq[s[i]-\\'a\\']==2){\\n                    return true; //since we found two same elements which can be swapped\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        //only one unequal character is present which cannot be swapped with any other\\n        else if(count==1) \\n            return false;\\n        \\n        swap(s[f_ind], s[s_ind]);\\n        if(s==goal) return true;\\n        else return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713399,
                "title": "simple-c-solution-using-constant-space",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int count =  0;\\n        unordered_map<int,int>m1, m2;\\n        if(s.length() != goal.length())\\n            return 0;\\n        if(s == goal)\\n        {\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                m1[s[i]]++;\\n                if(m1[s[i]] >=2)\\n                    return 1;\\n            }\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0 ; i < s.length(); i++)\\n            {\\n                if(s[i] != goal[i])\\n                {\\n                    count++;\\n                    if(count > 2)\\n                        return 0;\\n                    m2[goal[i]]++;\\n                    m1[s[i]]++;\\n                }\\n            }\\n            for(auto i = m1.begin() ; i != m1.end() ; i++)\\n            {\\n                if(m2.find(i->first) == m2.end())\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        int count =  0;\\n        unordered_map<int,int>m1, m2;\\n        if(s.length() != goal.length())\\n            return 0;\\n        if(s == goal)\\n        {\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                m1[s[i]]++;\\n                if(m1[s[i]] >=2)\\n                    return 1;\\n            }\\n            return 0;\\n        }\\n        else\\n        {\\n            for(int i = 0 ; i < s.length(); i++)\\n            {\\n                if(s[i] != goal[i])\\n                {\\n                    count++;\\n                    if(count > 2)\\n                        return 0;\\n                    m2[goal[i]]++;\\n                    m1[s[i]]++;\\n                }\\n            }\\n            for(auto i = m1.begin() ; i != m1.end() ; i++)\\n            {\\n                if(m2.find(i->first) == m2.end())\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713283,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n        if(s.size()!=goal.size())\\n        {\\n            return false;\\n        }\\n\\n        if(s==goal)\\n        {\\n            sort(s.begin(),s.end());\\n            for(int i=0;i<s.size()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    \\n        int n=s.size();\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i])\\n        {\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j])\\n        {\\n            j--;\\n        }\\n\\n        if(i < j)\\n        {\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) \\n    {\\n        if(s.size()!=goal.size())\\n        {\\n            return false;\\n        }\\n\\n        if(s==goal)\\n        {\\n            sort(s.begin(),s.end());\\n            for(int i=0;i<s.size()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    \\n        int n=s.size();\\n        int i = 0;\\n        int j = n - 1;\\n\\n        while(i < j && s[i] == goal[i])\\n        {\\n            i++;\\n        }\\n\\n        while(j >= 0 && s[j] == goal[j])\\n        {\\n            j--;\\n        }\\n\\n        if(i < j)\\n        {\\n            swap(s[i], s[j]);\\n        }\\n\\n        return s == goal;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713059,
                "title": "simple-c-solution-string-easy-to-understand-video-solution",
                "content": "# Video solution \\n\\nhttps://youtu.be/5FzWI6avR-A\\n\\n# Intuition\\nWe have to check for some cases which can give us correct answer.\\n\\n# Approach\\n1. Case 1: **If both string s and goal are equal**\\n    Answer is possible only when any character in s or goal is repeated. So for this we inserted all character in set of char and if the size of set is less than size of string then we will get our answer as true. Else answer is false.\\n\\n2. Case 2: **Size of both string different**:\\n    In this case answer is not possible. So return false;\\n3. Case 3: **Rest cases:**\\n    There should be only two posistions such that char at both the position is different. If we have more than two such positions or less than two position answer will be ```false``` else ```true```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n**Please upvote if you liked!!!**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s==goal){\\n            set<char>st;\\n            for(auto ele:s){\\n                st.insert(ele);\\n            }\\n            return (st.size()!=s.size());\\n        }\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            cnt+=(s[i]!=goal[i]);\\n        }\\n        if(cnt!=2){\\n            return false;\\n        }\\n        int ind1=-1,ind2=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        for(int i=ind1+1;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        swap(s[ind1],s[ind2]);\\n        return s==goal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```false```\n```true```\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s==goal){\\n            set<char>st;\\n            for(auto ele:s){\\n                st.insert(ele);\\n            }\\n            return (st.size()!=s.size());\\n        }\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            cnt+=(s[i]!=goal[i]);\\n        }\\n        if(cnt!=2){\\n            return false;\\n        }\\n        int ind1=-1,ind2=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        for(int i=ind1+1;i<s.size();i++){\\n            if(s[i]!=goal[i]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        swap(s[ind1],s[ind2]);\\n        return s==goal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712949,
                "title": "kotlin-simple-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThere are 4 cases.\\n\\n1. When string s and goal has different length -> We cannot make string s like goal with just swap, return false.\\n\\n2. When s and goal has more than 2 diffrence -> We cannot make string s like goal with just swap, return false.\\n\\n3. When s and goal is same string -> If there are more than one duplicate char in s, we can swap them. so, return duplicate or not.\\n\\n4. When s and goal has only one diffrence -> swap it. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length) {\\n            return false\\n        }\\n\\n        val charSet = HashSet<Char>(26)\\n\\n        var diffIndex = -1\\n        var hasDuplicate = false\\n\\n        var i = 0\\n\\n        while (i < s.length) {\\n            if (s[i] != goal[i]) {\\n                if (diffIndex == -1) {\\n                    diffIndex = i\\n                } else {\\n                    if (s[diffIndex] == goal[i] && s[i] == goal[diffIndex]) {\\n                        i++\\n                        return s.substring(i) == goal.substring(i)\\n                    }\\n                    return false\\n                }\\n            }\\n            if (!charSet.add(s[i])) {\\n                hasDuplicate = true\\n            }\\n            i++\\n        }\\n\\n        return diffIndex == -1 && hasDuplicate\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    \\n    fun buddyStrings(s: String, goal: String): Boolean {\\n        if (s.length != goal.length) {\\n            return false\\n        }\\n\\n        val charSet = HashSet<Char>(26)\\n\\n        var diffIndex = -1\\n        var hasDuplicate = false\\n\\n        var i = 0\\n\\n        while (i < s.length) {\\n            if (s[i] != goal[i]) {\\n                if (diffIndex == -1) {\\n                    diffIndex = i\\n                } else {\\n                    if (s[diffIndex] == goal[i] && s[i] == goal[diffIndex]) {\\n                        i++\\n                        return s.substring(i) == goal.substring(i)\\n                    }\\n                    return false\\n                }\\n            }\\n            if (!charSet.add(s[i])) {\\n                hasDuplicate = true\\n            }\\n            i++\\n        }\\n\\n        return diffIndex == -1 && hasDuplicate\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712865,
                "title": "simple-c-solution-best-for-beginners-beats-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We can only swap two elements (Not less not more).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the length of s is smaller than 2 return false.\\n- If the lengths of the s and the goal are not same return false.\\n- If s and goal are same check whether the s has any character that repeats. So that we can swap the same characters. If yes, return true else return false.\\n- If s and goal are not same count the number of characters (var nod in code) that are not same in s and goal at position i.\\n- If nod is not 2, return false.\\n- If nod is 2, then swap the characters and check whether it becomes equal to goal or not.\\n\\n\\n**Upvote** **if** **Useful**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n        if(s == goal){\\n            vector<int> alpha(26, 0);\\n            for(int i = 0; i < s.length(); i++){\\n                char cur = s[i];\\n                if(alpha[cur - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    alpha[cur - \\'a\\']++;\\n                }\\n            }\\n            return false;\\n        }else{\\n            int j, k;\\n            int nod = 0;\\n            for(int i = 0; i < s.length(); i++){\\n                if(s[i] != goal[i]){\\n                    if(nod < 2){\\n                        nod++;\\n                        if(nod == 1){\\n                            j = i;\\n                        }else{\\n                            k = i;\\n                        }\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            if(nod == 1){\\n                return false;\\n            }\\n            char temp = s[j];\\n            s[j] = s[k];\\n            s[k] = temp;\\n            return s == goal;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.length() == 1){\\n            return false;\\n        }\\n        if(s.length() != goal.length()){\\n            return false;\\n        }\\n        if(s == goal){\\n            vector<int> alpha(26, 0);\\n            for(int i = 0; i < s.length(); i++){\\n                char cur = s[i];\\n                if(alpha[cur - \\'a\\'] == 1){\\n                    return true;\\n                }else{\\n                    alpha[cur - \\'a\\']++;\\n                }\\n            }\\n            return false;\\n        }else{\\n            int j, k;\\n            int nod = 0;\\n            for(int i = 0; i < s.length(); i++){\\n                if(s[i] != goal[i]){\\n                    if(nod < 2){\\n                        nod++;\\n                        if(nod == 1){\\n                            j = i;\\n                        }else{\\n                            k = i;\\n                        }\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n            }\\n            if(nod == 1){\\n                return false;\\n            }\\n            char temp = s[j];\\n            s[j] = s[k];\\n            s[k] = temp;\\n            return s == goal;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1954003,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1686093,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1897609,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953963,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1950987,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953996,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954034,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1566551,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953972,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953975,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954003,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1686093,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1897609,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953963,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1950987,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953996,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954034,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1566551,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953972,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1953975,
                "content": [
                    {
                        "username": "Celestial_Coder",
                        "content": "Finally!!\\nA 365 days streak."
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@Celestial_Coder](/Celestial_Coder) Thanks a lot for response! Appreciated!"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "[@manraj_singh_16447](/manraj_singh_16447) A year ago, could only manage the easy ones taking 30+ minutes, but I stick through it, learning everyday something thanks to the daily problems and 4-5 other questions, slowly got used to patterns(yet a long way to go) , still the tough ones take times, Don\\'t spend more than 60 mins in a question, if not editorial helps or any video.All the best Keep Grinding, you will eventually get better!!!!"
                    },
                    {
                        "username": "rhymes17",
                        "content": "Congratulations! Happy Coding."
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Great work [@Hkjkj](/Celestial_Coder)"
                    },
                    {
                        "username": "KaumilPatni",
                        "content": "happy new year broo!!"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "Congratulations! Would you like to share your journey in response please, I would love to listen to it, like what inspires you to follow through and what you do when questions are hard or you are not able to solve them. I would highly appreciate your response!"
                    },
                    {
                        "username": "sudianskyi",
                        "content": "Happy New Year!"
                    },
                    {
                        "username": "RayanYI",
                        "content": "Well done ! the way to follow :)"
                    },
                    {
                        "username": "ramankumar1",
                        "content": "Inspiring !"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats [@Hkjkj](/Celestial_Coder)! That is surely some dedication. One more thing to notice is the time of your comment : Very near to 12 AM UTC. I think you try to solve the daily question as soon as it drops and that is another proof of the Zeal. Keep going Buddy! Make that 365 -> 730"
                    },
                    {
                        "username": "PhilippovDev",
                        "content": "Wow, what a milestone - Congratulations on that\\uD83C\\uDF89!!!\\nNicely done!"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Awesome!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The example test cases should also include strings with length > 2. Also, I think its just me, but difficulty is not easy for this one. :]"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Yeah, it\\'s not so easy but it\\'s pretty straightforward to solve if you consider all the edge cases. Not as easy as most easys but not as difficult as most mediums. "
                    },
                    {
                        "username": "gyanesh09",
                        "content": "This should be medium"
                    },
                    {
                        "username": "AntonKrug",
                        "content": "[@GenisisRaiden](/GenisisRaiden) More examples would have helped, but other easy ones felt trivial compared to this easy one"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "[@g0atsss](/g0atsss) bruteforce does pass"
                    },
                    {
                        "username": "goatsctl",
                        "content": "Considering that brute force does not pass, I have to agree"
                    },
                    {
                        "username": "kshzz24",
                        "content": "Nah, it is easy , but with poor sample cases"
                    },
                    {
                        "username": "bharatchandra01",
                        "content": "This problem is an annoying one for sure, but honestly this problem is very similar to many interview questions I have dealt with in the past. \\n\\nIn reality, you will be lucky if you get a problem that is solvable by just applying a well known pattern. You need to be able to consider all potential input cases / edge cases and determine what the output should be. \\n\\nEdge case heavy problems are common in interviews and the interviewer wants to see can you account for and consider every edge case in a clean way or do you write hacky over-engineered code. \\n\\nHope this helps!"
                    },
                    {
                        "username": "tliu0c",
                        "content": "If an interviewer asks you this in real interview and expects you to cover all the edge cases, he doesn\\'t want to hire you and I honestly think he\\'s an ahole for asking this."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I think this is a good problem, but definitely not an easy one."
                    },
                    {
                        "username": "lchelloroad",
                        "content": "the problem itself seems not difficult, but there are some edge cases could be missed"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute Force gives Tle. Should be marked as medium!"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "[@kaushikankitsharma05](/kaushikankitsharma05) Sure , below is my code for brute force \\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string goal) {\\n        if(s.size()!=goal.size()){\\n            return false;\\n        }\\n        int n = s.size();\\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                swap(s[i],s[j]);\\n                if(s == goal){\\n                    return true;\\n                }\\n                swap(s[i],s[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I don\\'t think brute force should give TLE as does not require nested loop and also the constraints are 10 to power 4 only ,in medium it would have been minimum 10 to power 5.Can you give provide your code please , i wish to have a look."
                    },
                    {
                        "username": "c410n",
                        "content": "Why does\\n\\n\"abab\"\\n\"abab\"\\n\\nis considered should return True??? The submit fails with this test-case. But it does seem to fit exactly the case when it\\'s False."
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "Many problems on this platform have poor description. The tests cases in the description of this problem can\\'t make you understand clearly what you\\'re supposed to code."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "Because you can switch the two \\'b\\'s or the two \\'a\\'s."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "if strings are equal create a hashmap and if key of any char>1 return true as those 2 characters can be swapped and it wouldn\\'t change the string"
                    },
                    {
                        "username": "Tharun49",
                        "content": "You can swap one \\'a\\' with other \\'a\\' in the given string. Which constitutes for one swap. Conversely we can do the same for \\'b\\' and end up with goal string in one swap. So the expected answer is True. Let me know if you want further clarity."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Oh thank god, finally an easy. Its over. its finally over. "
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Is it tho?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Definitely not easy, but just a lot of corner cases to consider.\n\nHint: if length of s and length of goal aren't equal, return false. If s == goal but none of the characters in S occur more than once, return false. Else return true.\n\nif s[i] != goals[i] at more than 2 different places, return false."
                    },
                    {
                        "username": "keithdtyler",
                        "content": "This is a great simplification of the base case.\\nThe problem is, this whole exercise is silly and nonsensical and has no applicable purpose, and the number of criteria lends itself to having more than one method to handle all those scenarios.\\n\\nBesides, the only reason we have to do this is because of a completely arbitrary time limit. The brute force method works correctly; the test parameters have set an unexplained time limitation for no reason but to defeat brute force, which is algorithmically the simplest and most straightforward solution, and works more than adequately in anything other than \"attack vector\" cases. "
                    },
                    {
                        "username": "sweetcaro",
                        "content": "thanks"
                    },
                    {
                        "username": "abhisaxena",
                        "content": "if s[i] != goals[i] at more than 2 different places, return false. - this fails in the test case - s=\"abcaa\", goal=\"abcbb\" OR s=\"abcad\", goal=\"abcbb\"."
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@Cocamo1337](/Cocamo1337) That \"if s[i] != goals[i] at more than 2 different places, return false\" is an saver man.Thanks!!"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This still misses this testcase.\\ns = \"abcaa\"\\ngoal = \"abcbb\""
                    }
                ]
            },
            {
                "id": 1954030,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954253,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954162,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954345,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1567403,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954015,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1953967,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1953956,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954143,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1955119,
                "content": [
                    {
                        "username": "anwendeng",
                        "content": "It is an easy question, but not so easy, unless you find a tricky way! There are some different cases need to check:\ncheck the lengths of both s & goal\nSet some variables, for example variable denotes the number for different places, frequency table for characters etc.\nProceed the iteration and check\nAccording to each different case to determine whether s is convertible to goal or not."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "The guy who wrote the description for this problem deserves a hard spank in the butt"
                    },
                    {
                        "username": "gray_yarg",
                        "content": "sounds hot"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "SPANKBANG \\uD83D\\uDE09"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Haha, did I just completed it in one go.\\nToday is nice day."
                    },
                    {
                        "username": "y-not",
                        "content": "Java Video Solution - \\nhttps://www.youtube.com/watch?v=MzjGv9fQtM4"
                    },
                    {
                        "username": "bourne29",
                        "content": "![image](https://assets.leetcode.com/users/bourne29/image_1565367656.png)\\nAs per LeetCode testcases, A = \"abab\"  and B = \"abab\".\\nI can swap \"a\" at index 0 and index 2 --> That gives me B\\nBut I can also swap \"b\" at index 1 and index 3 --> That gives me B as well.\\n\\nWhen the questions says: \"if and only if we can swap two letters in A so that the result equals B\", it seems like only one swapping should be allowed. As per which the above test case should return : False\\n\\nPlease let me know if I am missing something."
                    },
                    {
                        "username": "serkora",
                        "content": "I don't think even the original quoted description can be understood the way you did. The word \"only\" refers to the ability/necessity to swap, not to \"only two letters\". Yes, only one swap is allowed to make the string in any single solution, but not \"only one possible swap\" / \"only one possible solution\"."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "YOU CAN SWAP ANY TWO letters like we can replace a at 0 with a at 2 or b at 0 or b at 3 it will return true."
                    },
                    {
                        "username": "Tharun49",
                        "content": "Updated description of the question goes this way \\n\"Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\"\\nI think this should help you!"
                    },
                    {
                        "username": "as9vd2",
                        "content": "There\\'s no way this is an easy."
                    },
                    {
                        "username": "cionx",
                        "content": "Another test case that hasn\\u2019t been mentioned yet:\\n```text\\n\"abcaa\"\\n\"abcbb\"\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "false"
                    },
                    {
                        "username": "CoolBud",
                        "content": "Run it. Encounter an edge case correct it. Same cycle till u pass all the test cases xD"
                    },
                    {
                        "username": "_drigger",
                        "content": " beware of the test case `aabssdf` and `aassbdf`, this is last one and my code fails in this as i didn\\'t consider when char occur more than once like `s` in this case, i am replacing with first `s` i found but we need to traverse complete string to see others also...it\\'s like backtracking."
                    },
                    {
                        "username": "user7478F",
                        "content": "Dear Leetcode, you don\\'t need to disguise questions\\n"
                    }
                ]
            },
            {
                "id": 1954730,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954459,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1953995,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1955371,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1955249,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954914,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954267,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954215,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954133,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1954095,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "Its a trick boys, Its the calm before the storm of hard questions."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "This is definitely not an easy problem.\nYou have to look at all three examples very carefully. They explain all possible scenarios.\n<hr>\n\n**-If s and goal are not equal then you have to find number of index whose character are not same in s and goal.**\n <p>For example s = \"ab\", goal = \"ba\"\nHere at 0th index, there is different character in s and goal , also same for 1st index , so we are having exactly 2 index , which can can be swap and if after swapping if s and goal are equal return true else return false.</p>\n\n\n**-If s and goal are equal then you just have to store the frequency of each character in s and look out for character whose frequency is greater than 1.**\n<div>For example s = \"ab\", goal = \"ab\"  here none of the characters of s has  the frequency greater then 1. which mean there is no way we can achieve the goal by swapping characters in s so we return false other return true (Example-3).</div>\n<hr>\n\nSolutions --> https://leetcode.com/problems/buddy-strings/submissions/985169070/"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Ashish_4k](/Ashish_4k)  Yup, I thought there no need to mention here that\\'s why. Otherwise that\\'s the first thing we need check\\uD83D\\uDE00"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "one more scenario if lengths are unequal"
                    },
                    {
                        "username": "Ultron03",
                        "content": "Finally an easy question "
                    },
                    {
                        "username": "lovely08",
                        "content": "Did this question on my own after getting 7 times TLE. Feeling okay.\\n"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "This problem seems piece of cake but edge cases sucks "
                    },
                    {
                        "username": "fahad_sait",
                        "content": "WTF!!!!!!! is wrong with test case 24/34??? My code was so simple and efficient. The test cases always fucks up!!\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Even I got headache I thought the testcases are not that bad."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "it\\'s just that we have lot of corner cases to handle hint: 1) lengths 2) duplicates and 3) is the problem wheather swap is possible that is no. of unequal places"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "HR: \\n\\\\- Of course we have a lot of interesting tasks for you!\\nTeamlead:\\n\\\\- Okay, man, here is the deal..."
                    },
                    {
                        "username": "ross8888",
                        "content": "You should celebrate a little if done this in one go!!\\n"
                    },
                    {
                        "username": "dumb_me",
                        "content": "easy but tricky one \\uD83E\\uDD74\\uD83E\\uDD74"
                    },
                    {
                        "username": "psionl0",
                        "content": "Cool. I got all of the edge cases before submitting my code. At first I suspected that I was over-engineering my solution by checking for unequal string lengths (the description doesn\\'t say that the strings must have the same length) but it is gratifying to see that in some test cases, the strings do indeed have unequal lengths.\\n\\nHad the requirement been that there could be more than 1 swap needed to make the strings equal then this might have been a more interesting challenge."
                    }
                ]
            },
            {
                "id": 1953961,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1779804,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1703322,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1572155,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1950110,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 2068882,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 2034906,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 2010200,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1986372,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1985664,
                "content": [
                    {
                        "username": "Shi-Yueyang",
                        "content": "I hate this type of problem"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "Be careful with the test case \"ab\" and \"babbb\".\\n\\nIn my humble opinion, adding test cases for inputs with different lengths does not add any value to this problem because it is extremely easy to solve but it is quite annoying to see submission failing because of this \\uD83E\\uDD37\\u200D\\u2642\\uFE0F"
                    },
                    {
                        "username": "sheikh_abir_ali",
                        "content": "**Working Fine Everywhere but giving false in TC 15 :!**\\n```\\nclass Solution:\\n    def buddyStrings(self, s: str, goal: str) -> bool:\\n        if s == goal[::-1]:\\n            return \"true\"\\n        else:\\n            return \"false\"\\n```"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "You are simply checking if `s` and `goal` are palindrome or not. How does that check for buddy condition?"
                    },
                    {
                        "username": "Carlosx7",
                        "content": "could you post which is the input for TC 15??"
                    },
                    {
                        "username": "cracy",
                        "content": "For example \"aa\", \"ab\". My first submission didn\\'t check for that but still got accepted."
                    },
                    {
                        "username": "ursachu",
                        "content": "I dont like this question. It seems irrelevant"
                    },
                    {
                        "username": "user5400vw",
                        "content": "holy nuts, this problem was asshole"
                    },
                    {
                        "username": "kiduse0911",
                        "content": "man, this is a confusing question. Plus the test cases are not that helpful"
                    },
                    {
                        "username": "woofer_employ_0r",
                        "content": "are we allowed to swap letters more than once?\\nit\\'s confusing"
                    },
                    {
                        "username": "user7784PS",
                        "content": "Cringe."
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "A pretty decent question\\nReally forced me to think about many edge cases that I initially missed."
                    }
                ]
            },
            {
                "id": 1984496,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1961057,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1958339,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1956134,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955523,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955246,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955208,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955162,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1955108,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1954987,
                "content": [
                    {
                        "username": "steuxnet",
                        "content": "This is a good Question and surely doesn\\'t qualify for easy, it is medium."
                    },
                    {
                        "username": "subhamdudheria",
                        "content": "Anyone having issue with aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
                    },
                    {
                        "username": "keithdtyler",
                        "content": "There is zero algorithmic reason for the arbitrary time limit on execution time. This is just a hackishly designed exercise criteria -- UNSTATED mind you -- to stymie the obvious solution.\\n\\nThere is no reason why the obvious solution is not suitable. It\\'s a cheap, dirty, unnecessary, and unrealistic trap. If the target system was expected to handle large strings with large similarities, the system would be designed accordingly. The \"gotcha\" test is hidden until submission.\\n\\nJust plain dirty pool and the creator of the exercise should be ashamed, but probably thinks they\\'re clever."
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "This questions has lot of edge cases"
                    },
                    {
                        "username": "sandthorn",
                        "content": "I find that the submission profiling inconsistent in both speed and memory measures. Is that normal?"
                    },
                    {
                        "username": "Bhaskybaba",
                        "content": "I do not understand why my solution is failing in leetcode but working fine in ide:\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Because leetcode have Time and memory constraints "
                    },
                    {
                        "username": "aftab0711",
                        "content": "I solved this question in one my first attempt only, but this question should me marked as medium level."
                    },
                    {
                        "username": "Belyua",
                        "content": "why Input: s = \"ab\", goal = \"ab\" should give False, but s =\"abab\" goal = \"abab\" should give true???"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Ashish_4k](/Ashish_4k)  since we need to do one swap and in 2nd string you can swap a with a which is not possible in 1st string "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "Because we need at least one char to swap so for no duplicate string it will always return false "
                    },
                    {
                        "username": "t_Mz",
                        "content": "finally submitted in 4th attempt.... lesssgoooo"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "what should be the optimial run time complexity?"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I guess linear"
                    }
                ]
            },
            {
                "id": 1954982,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954956,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954890,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954760,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954744,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954704,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954647,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954594,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954541,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954537,
                "content": [
                    {
                        "username": "qwsazi",
                        "content": "this submit testcases are torture"
                    },
                    {
                        "username": "kaushikankitsharma05",
                        "content": "I think its a easy question simply because of test cases . They are small to its easy to find error .\\nYou just have to take care of following condition:-\\n1. If strings are of different length return False\\n2. If string are exactly equal and all character are unique then return false, if there are repeating character then return True\\n3.If string are of same length but not equal than cheak if the number of different element is other than  2 , return False.\\nElse if it is 2 then cheak if swapping makes the two the string equal or not .\\nThanks and have a error free day."
                    },
                    {
                        "username": "patrickallard",
                        "content": "Do not let the Easy label fool you. Although the problem is accurately graded, it will require more thought and patience than what you might expect an easy problem to require. It took me awhile to come up with a solution--it ended up being more involved than I had anticipated. My issue was that I kept switching between two different methods, only until the end realizing that the solution required the use of both. "
                    },
                    {
                        "username": "ogcooke",
                        "content": "I got really confused about the output format in Python. Some type hints would be nice"
                    },
                    {
                        "username": "kareena29",
                        "content": "Calling it easy? Actuallyy? "
                    },
                    {
                        "username": "im-naime",
                        "content": "WOW, I cracked it on my initial try!"
                    },
                    {
                        "username": "mmtemel",
                        "content": "By the way it is not easy, not even closer!"
                    },
                    {
                        "username": "eduard92",
                        "content": "Why the text tells me this is a DP problem.."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "not really a dp but more corner cases to handle genrally we see problems with pre handled cases here it\\'s not there that\\'s why tricky."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "get ready for dp and graph questions. :)"
                    },
                    {
                        "username": "ulalit_2728",
                        "content": "We have to swap two letters at a time, so is swapping only allowed once or can swap multiple times?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "only once "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "only once"
                    }
                ]
            },
            {
                "id": 1954521,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954509,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954496,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954435,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954362,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954358,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954347,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954316,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954315,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954300,
                "content": [
                    {
                        "username": "_vishalverma",
                        "content": "Input : \"abcd\"\ngoal : \"badc\"\nWhy this is not true, we can swap 'a' with 'b' and 'c' with 'd' to achieve this?\nCan anyone help me with it?\n"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "we can swap only once that\\'s why"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can swap only once  not twice"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "Too Many edge cases...  T - T"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "You have to perform swap operation exactly once.\\neg: s = \"abcd\" goal = \"abcd\" |  output : false (because you cannot swap any character here)\\n\\neg: s = \"aabb\" goal = \"aabb\" | output: true (because you can swap either \"aa\" or \"bb\"\\n\\neg: s = \"abc\" goal = \"ab\" | output: false (because sizes are not equal)\\n\\neg : \"abcd\" goal = \"abed\" | output: false (because \"c\" is not present in goal)\\n\\neg : s = \"abdcgf\" goal = \"abcdfg\" | output: false (cannot perform swap operation two times)\\n\\nHandle these cases. "
                    },
                    {
                        "username": "tliu0c",
                        "content": "s =\"abab\"\\ngoal =\"baba\" \\n\\nOMG"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "its a wierd problem :["
                    },
                    {
                        "username": "201132",
                        "content": "Easy not really easy :)\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "nice problem ! nice test cases ! nice headache !\\n"
                    },
                    {
                        "username": "kiyomaru_28",
                        "content": "abcd\\nbadc\\nhow is it false should it be true as we can swap two times and get it?"
                    },
                    {
                        "username": "rohanny_",
                        "content": "they should atleast mention, \"u cant swap more than once\""
                    },
                    {
                        "username": "Brindha_A",
                        "content": "[@kumaraashish118](/kumaraashish118)  How to do that? \\n"
                    },
                    {
                        "username": "Brindha_A",
                        "content": "same doubt... \\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "You will need to swap more than 2 letters i.e a with b and c with d to make the strings equal. It should require exactly 2 letters to be swapped to return true."
                    },
                    {
                        "username": "rahulkottak",
                        "content": "s =\\n\"aaaaaaabc\"\\ngoal =\\n\"aaaaaaacb\"... lol how is this returning true!"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "you can swap b and c to get goal and it\\'s done only once"
                    },
                    {
                        "username": "rahulkottak",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar) [@kumaraashish118](/kumaraashish118) got it now ! thanks\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "Swap b and c in the string and they become equal.\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Just swap bc in 2nd string it will become eaual"
                    },
                    {
                        "username": "ddivyassingh",
                        "content": "https://leetcode.com/problems/buddy-strings/solutions/3711580/daily-challenge-solution-3rd-july/\\nsolution"
                    }
                ]
            },
            {
                "id": 1954294,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954284,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954272,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954255,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954223,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954194,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954163,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954146,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954145,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954116,
                "content": [
                    {
                        "username": "wusi2cool",
                        "content": "should have made it clear we could only do a single swap and multiple swap is not allowed."
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "HINT ALERT\\n\\n- check lengths and counts of each character in  `s` and `goal`\\n- check if a character has a `copy`, so if the strings are equal, its still possible.\\n- if counts don\\'t line up, return.\\n- if `difference` then its possible.\\n- if no `difference` but `copy` is true, its still possible."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "After being destoryed by pre hard problems, it is easy..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "such a vague description"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "s =\"aaaaaaabc\" goal=\"aaaaaaacb\" \\nshould return false or true.\\nATQ => it should return false.\\ntestcase expecting true. \\nAny solution why is it happening?"
                    },
                    {
                        "username": "nikhileshdb",
                        "content": "[@abukafq](/abukafq) Yes I got it, I was only swaping the first two characters."
                    },
                    {
                        "username": "abukafq",
                        "content": "last 2 position can be swap.\\nHence, true"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**This string is  bad buddy .**"
                    },
                    {
                        "username": "Hariom51",
                        "content": "what is a sense of having a string of length 1 ? "
                    },
                    {
                        "username": "programmer0073",
                        "content": "Finally easy with 30% Acceptance Rate. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Easy with the lower acceptance are the worst ones!"
                    },
                    {
                        "username": "ag_ressive",
                        "content": "Edge Cases\\n1) The length of s and goal can be different. (In this case return false)\\n2) If the two strings are identical return true only if they contain a repeated letter. Eg: s = aab, goal =aab ,Here index of 0 and 1 can be swapped to get goal."
                    },
                    {
                        "username": "Aditya-Naresh",
                        "content": "This is actually a simple counting problem :) . Count the difference of alphabets if it\\'s 2 easy swap and if it\\'s more require multiple swap and if there is no difference between s and goal check for repeating alphabet in s"
                    }
                ]
            },
            {
                "id": 1954112,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954105,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954088,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954086,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954081,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954067,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954059,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954057,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1954009,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            },
            {
                "id": 1849542,
                "content": [
                    {
                        "username": "aDDyy",
                        "content": "So stupid type question!!!!\\uD83D\\uDE44\\uD83D\\uDE2B"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Almost a medium I think. Almost."
                    },
                    {
                        "username": "Prajju22",
                        "content": "finally a streak of 260! after struggling the whole weeek."
                    },
                    {
                        "username": "Aadil42",
                        "content": "The edge cases are such a bitch!"
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "This is not easy for me !!"
                    },
                    {
                        "username": "letrung",
                        "content": "This is not a really easy one, we have to cover a few of edge cases that are not shown in the description example."
                    },
                    {
                        "username": "utkarsh_2237",
                        "content": "finally, an easy one"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Who\\'s gonna mention, how many times we can do this operation\\uD83D\\uDE44"
                    },
                    {
                        "username": "omkarsase",
                        "content": "for s = \"ccaa\" and goal = \"aacc\"\\n\\nwe can convert \\'s\\' to \\'goal\\' by swapping characters present at (0, 2) and (1,3).\\nthen why it expects answer to be false ?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Swapping `s[0]` with `goal[2]` is one operation, swapping `s[1]` with `goal[3]` is another operation.  \\nBut you must perform exactly one operation."
                    },
                    {
                        "username": "anupamkolay6",
                        "content": "Can anyone explain why test case 30 is like this :\\ns = \"abcd\"\\ngoal = \"badc\"\\n\\nthe expected result is false. Shouldn\\'t it be true??"
                    },
                    {
                        "username": "anjali_01p",
                        "content": "question says to have only one swap, here to get the goal, it will need two swaps (one between 0th and 1st index and other between 2nd and 3rd index), so that\\'s why it\\'s false"
                    }
                ]
            }
        ]
    }
]