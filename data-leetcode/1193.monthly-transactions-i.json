[
    {
        "title": "Friends Of Appropriate Ages",
        "question_content": "There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person.\nA Person x will not send a friend request to a person y (x != y) if any of the following conditions is true:\n\n\tage[y] <= 0.5 * age[x] + 7\n\tage[y] > age[x]\n\tage[y] > 100 && age[x] < 100\n\nOtherwise, x will send a friend request to y.\nNote that if x sends a request to y, y will not necessarily send a request to x. Also, a person will not send a friend request to themself.\nReturn the total number of friend requests made.\n&nbsp;\nExample 1:\n\nInput: ages = [16,16]\nOutput: 2\nExplanation: 2 people friend request each other.\n\nExample 2:\n\nInput: ages = [16,17,18]\nOutput: 2\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\n\nExample 3:\n\nInput: ages = [20,30,100,110,120]\nOutput: 3\nExplanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\n&nbsp;\nConstraints:\n\n\tn == ages.length\n\t1 <= n <= 2 * 104\n\t1 <= ages[i] <= 120",
        "solutions": [
            {
                "id": 127029,
                "title": "c-java-python-easy-and-straight-forward",
                "content": "## **Explanation**\\n1. Write a sub function `request(a, b)` to check if age `a` will friend requests age `b`.\\nI just copy it from description:\\n`return !(condition1 || condition2 || condition3)`\\n\\n2. Count nunmber of all ages to a `map`.\\nBecause we have at most 20000 ages but only in range [1, 120].\\n3. For each age `a` and each age `b != a`, if request(a, b), we will make count[a] * count[b] requests.\\n4. For each age `a`, if request(a, a), we will make `count[a] * (count[a] - 1)` requests.\\n\\n**C++:**\\n```cpp\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int numFriendRequests(int[] ages) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int age : ages)\\n            count.put(age, count.getOrDefault(age, 0) + 1);\\n        int res = 0;\\n        for (Integer a : count.keySet())\\n            for (Integer b : count.keySet())\\n                if (request(a, b)) res += count.get(a) * (count.get(b) - (a == b ? 1 : 0));\\n        return res;\\n    }\\n\\n    private boolean request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numFriendRequests(self, ages):\\n        def request(a, b):\\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\\n        c = collections.Counter(ages)\\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\n```java\\n    public int numFriendRequests(int[] ages) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int age : ages)\\n            count.put(age, count.getOrDefault(age, 0) + 1);\\n        int res = 0;\\n        for (Integer a : count.keySet())\\n            for (Integer b : count.keySet())\\n                if (request(a, b)) res += count.get(a) * (count.get(b) - (a == b ? 1 : 0));\\n        return res;\\n    }\\n\\n    private boolean request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n```\n```py\\n    def numFriendRequests(self, ages):\\n        def request(a, b):\\n            return not (b <= 0.5 * a + 7 or b > a or b > 100 and a < 100)\\n        c = collections.Counter(ages)\\n        return sum(request(a, b) * c[a] * (c[b] - (a == b)) for a in c for b in c)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 127341,
                "title": "10ms-concise-java-solution-o-n-time-and-o-1-space",
                "content": "Three conditions could be merged to one: \\nThe Person with age A can request person with age B if\\n* B is in range **(** 0.5 * A + 7, A **]** \\n```\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        \\n        for(int i : ages) \\n            numInAge[i] ++;\\n        \\n        for(int i = 1; i <= 120; ++i) \\n            sumInAge[i] = numInAge[i] + sumInAge[i - 1];\\n        \\n        for(int i = 15; i <= 120; ++i) {\\n            if(numInAge[i] == 0) continue;\\n            int count = sumInAge[i] - sumInAge[i / 2 + 7];\\n            res += count * numInAge[i] - numInAge[i]; //people will not friend request themselves, so  - numInAge[i]\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        \\n        for(int i : ages) \\n            numInAge[i] ++;\\n        \\n        for(int i = 1; i <= 120; ++i) \\n            sumInAge[i] = numInAge[i] + sumInAge[i - 1];\\n        \\n        for(int i = 15; i <= 120; ++i) {\\n            if(numInAge[i] == 0) continue;\\n            int count = sumInAge[i] - sumInAge[i / 2 + 7];\\n            res += count * numInAge[i] - numInAge[i]; //people will not friend request themselves, so  - numInAge[i]\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126930,
                "title": "c-5-lines-o-n-sliding-sum",
                "content": "Since the age range is limited to [1..120], we can count number of people of each age and store in the array. Then we can use that array to count friend requests:\\n* People younger than 15 cannot make requests due to the first rule.\\n* From the age of 15, people can make requests to the same age: ```a[i] * (a[i] - 1)``` requests.\\n* People can make requests to younger people older than 0.5 * i + 7: ```a[j] * a[i]``` requests.\\n    * The third rule is redundant as the condition is already covered by the second rule.\\n\\nThe complexity is O(n) as we need to count ages in the input array. Counting requests is O(1) as it always takes 2862 operations precisely. \\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15; i <= 120; ++i)\\n    for (int j = 0.5 * i + 8; j <= i; ++j) res += a[j] * (a[i] - (i == j));\\n  return res;\\n}\\n```\\nWe can optimize the counting by using a sliding sum of friend requests. Note that the sum starts at the minimum age (```0.5 * i + 7```), per the first rule.\\n\\nThe complexity of optimized solution is O(n + m) vs. O(n + m * m), where m is the age range. In our case, we need only 159 operations for [1..120] range. I did not see much of a difference in the OJ runtime, though, probably because of the tight constraint. The second solution will shine if we need, for example, use days instead of years to compare ages.\\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15, minAge = 15, sSum = 0; i <= 120; sSum += a[i], res += a[i++] * (sSum - 1))\\n    while (minAge <= 0.5 * i + 7) sSum -= a[minAge++];\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```a[i] * (a[i] - 1)```\n```a[j] * a[i]```\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15; i <= 120; ++i)\\n    for (int j = 0.5 * i + 8; j <= i; ++j) res += a[j] * (a[i] - (i == j));\\n  return res;\\n}\\n```\n```0.5 * i + 7```\n```\\nint numFriendRequests(vector<int>& ages) {\\n  int a[121] = {}, res = 0;\\n  for (auto age : ages) ++a[age];\\n  for (auto i = 15, minAge = 15, sSum = 0; i <= 120; sSum += a[i], res += a[i++] * (sSum - 1))\\n    while (minAge <= 0.5 * i + 7) sSum -= a[minAge++];\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231649,
                "title": "java-i-think-this-is-the-solution-interviewers-would-like-to-see",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i = 0; i < ages.length; ++i) {\\n            int age = ages[i];\\n            int lower = firstIdx(ages, age/2+7);\\n            int upper = firstIdx(ages, age);\\n            res += Math.max(upper-lower-1, 0);\\n        }\\n        return res;\\n    }\\n    \\n    private static int firstIdx(int[] ages, int target) {\\n        int beg = 0;\\n        int end = ages.length-1;\\n        while (beg <= end) {\\n            int mid = beg + (end-beg)/2;\\n            if (ages[mid] <= target) beg = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return beg;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i = 0; i < ages.length; ++i) {\\n            int age = ages[i];\\n            int lower = firstIdx(ages, age/2+7);\\n            int upper = firstIdx(ages, age);\\n            res += Math.max(upper-lower-1, 0);\\n        }\\n        return res;\\n    }\\n    \\n    private static int firstIdx(int[] ages, int target) {\\n        int beg = 0;\\n        int end = ages.length-1;\\n        while (beg <= end) {\\n            int mid = beg + (end-beg)/2;\\n            if (ages[mid] <= target) beg = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return beg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129665,
                "title": "super-clear-explanation-on-both-o-nlgn-and-o-n-solution-step-by-step",
                "content": "The NAIVE solution should be comparing each pair and has O(N^2) time complexity. However, after careful consideration, we can easily find that for every person, there\\'s a range of ages that he will make request to. As a result, it is not hard to think of an O(NlgN) solution, where we sort the array first, and for each person, we calculate the expected range, and use binary search to find the number of elements in ages[] that sit in that range. Note that,\\nage[B] > 100 && age[A] < 100 is an useless condition which is fully convered by the second one. Here is the code:\\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            auto low_it = lower_bound(ages.begin(), ages.end(), low_bound);\\n            auto high_it = upper_bound(ages.begin(), ages.end(), ages[i]);\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\\nlow_bound is the inclusive left bound for the range. the \"-1\" in the cacluation of request is getting rid of making request to himself/herself . However, it is not necessary that his own age is in the expected result (and also it is not necessary that low_it is before high_it), so in the end, we make sure that for every person, the minimum request he/she will make is 0 (get rid of negative values).\\nAfter this, I was thinking if we can get faster? I observerd that low_it and hight_it is always proceeding, which makes sense as the age of the person cannot decrease (after sort), the left and right bound of his/her expected range should also not decrease. So, we don\\'t need to apply the binary search for low_it and high_it in every step.\\nHere comes the code:\\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        auto low_it = lower_bound(ages.begin(), ages.end(), ages[0]/2 + 8);\\n        auto high_it = upper_bound(ages.begin(), ages.end(), ages[0]);\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            while (*low_it < low_bound) ++low_it;\\n            while (high_it != ages.end() && *high_it <= ages[i]) ++high_it;\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\\nWe can find the expected range for the first element and then increase its boundaries when possible. In the for loop, low_it, high_it, and index i cannot decrease, so the time complexity for the for loop is only O(N). Someone may argue that, the sort takes O(NlgN) and that is right! However, please remember the range of of age : 1 <= ages[i] <= 120. We can definitely apply an O(N) bucket sort if we want.\\nThe code is not optmized for the smallest xx ms on the test cases but should elaborate my idea for you!",
                "solutionTags": [],
                "code": "```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            auto low_it = lower_bound(ages.begin(), ages.end(), low_bound);\\n            auto high_it = upper_bound(ages.begin(), ages.end(), ages[i]);\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```\n```\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        auto low_it = lower_bound(ages.begin(), ages.end(), ages[0]/2 + 8);\\n        auto high_it = upper_bound(ages.begin(), ages.end(), ages[0]);\\n        int res = 0;\\n        for (int i = 0; i < ages.size(); ++i) {\\n            int low_bound = ages[i]/2 + 8;\\n            while (*low_it < low_bound) ++low_it;\\n            while (high_it != ages.end() && *high_it <= ages[i]) ++high_it;\\n            int request = distance(low_it, high_it) - 1;\\n            res += max(request, 0);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166776,
                "title": "2-solutions-both-with-o-n-time-and-o-1-space-chinese-explaination",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] map = new int[121]; //\\u6BCF\\u4E2A\\u5E74\\u9F84\\u6709\\u591A\\u5C11\\u4EBA, \\u4F18\\u53161 \\u4E0D\\u7528map\\u7528\\u5E38\\u6570\\u5927\\u5C0F\\u6570\\u7EC4\\uFF0C\\u8FD9\\u6837\\u65F6\\u95F4\\u548C\\u7A7A\\u95F4\\u90FD\\u662FO\\uFF081\\uFF09\\n        for (int age : ages) map[age]++;\\n        int count = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            for (int j = 0; j <= 120; j++) {\\n                if (valid(i, j)) count += map[i] * (i == j ? map[j] - 1 : map[j]); //\\u6CE8\\u610Fi,j\\u76F8\\u7B49\\u4E0D\\u80FDskip\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u591A\\u4E2A\\u76F8\\u7B49\\u5E74\\u9F84\\n            }\\n        }\\n        return count;\\n    }\\n    public boolean valid(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100)); //\\u5176\\u5B9E\\u6761\\u4EF62\\u548C3\\u91CD\\u590D\\u4E86\\n    }\\n}\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { //\\u4F18\\u53162\\uFF0C\\u53E6\\u4E00\\u6570\\u7EC4sums\\u8BB0\\u5F55\\u8303\\u56F4\\uFF0C\\u8FD9\\u6837\\u8BA1\\u7B97count\\u4E0D\\u75282 for\\uFF0C\\u76F4\\u63A5\\u627E\\u8303\\u56F4\\u5185\\u4E2A\\u6570\\u5373\\u53EF\\n        int[] nums = new int[121], sums = new int[121];\\n        for (int age : ages) nums[age]++; //\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5E74\\u9F84\\u591A\\u5C11\\u4EBA\\n        for (int i = 1; i < sums.length; i++) sums[i] = sums[i - 1] + nums[i]; //\\u76F8\\u5F53\\u4E8E\\u8BB0\\u5F55\\u5C0F\\u4E8Ei\\u7684\\u6709\\u591A\\u5C11\\u4EBA\\n        int res = 0;\\n        for (int i = 15; i < sums.length; i++) { //i / 2 + 7 < i -> i>14\\n            if (nums[i] == 0) continue; //0\\u4E00\\u5B9A\\u8981\\u8DF3\\u8FC7\\uFF0C\\u5426\\u5219\\u540E\\u9762\\u662F\\u8D1F\\u6570\\n            int count = sums[i] - sums[i / 2 + 7]; //(i/2+7, i] \\u6709\\u591A\\u5C11\\u4E2A\\n            res += (count - 1) * nums[i]; //\\u4E0D\\u80FD\\u548C\\u81EA\\u8EABrequest\\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] map = new int[121]; //\\u6BCF\\u4E2A\\u5E74\\u9F84\\u6709\\u591A\\u5C11\\u4EBA, \\u4F18\\u53161 \\u4E0D\\u7528map\\u7528\\u5E38\\u6570\\u5927\\u5C0F\\u6570\\u7EC4\\uFF0C\\u8FD9\\u6837\\u65F6\\u95F4\\u548C\\u7A7A\\u95F4\\u90FD\\u662FO\\uFF081\\uFF09\\n        for (int age : ages) map[age]++;\\n        int count = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            for (int j = 0; j <= 120; j++) {\\n                if (valid(i, j)) count += map[i] * (i == j ? map[j] - 1 : map[j]); //\\u6CE8\\u610Fi,j\\u76F8\\u7B49\\u4E0D\\u80FDskip\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u591A\\u4E2A\\u76F8\\u7B49\\u5E74\\u9F84\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 744947,
                "title": "c-binary-search",
                "content": "A will friend B only if: \\n\\ni) B\\'s age is <= A and if, \\nii) B\\'s age is > 0.5*age[A]+7.\\n\\nAlgorithm: \\n\\n1) Sort the ages. \\n2) In the sorted array for any  j<sup>th</sup> index, we have to find all indexes which satisfy condition (i) and (ii). We do that using a binary search on the array to the left of the j<sup>th</sup> index. We terminate the search when we find the smallest index which satisfies the condition ages[mid] > 0.5*age[j]+7. Return the length of the array between j-1 and mid. \\n3) Keep a hash-map to store age and calculated friend-requests. That way if we have already found the number of friend requests that can be sent for a particular age, we can re-use it (since the array has duplicate ages). \\n4) **Traverse the age array from right to left** in the main function to compute step 2 for each index in the ages array.  \\n\\n**There is an important benefit to traverse the array from right to left (from ages.size()-1 to 0). It lets us compute the number of people of the same age as the j<sup>th</sup> person and the ones less than the j<sup>th</sup> person satisfying condition (ii), in the same binary search function.**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map <int,int> map; // key: age, val: FriendRequestCount. \\n    \\n    int findRequests (vector<int> & ages, int index) {\\n        \\n        if (map.find(ages[index]) != map.end()) {\\n            return map[ages[index]];\\n        }\\n        \\n        int left = 0;\\n        int right = index-1;\\n        double target = (double) (0.5*ages[index]) + 7; // find ages >= target.\\n        \\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (ages[mid] <= target) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        \\n        map[ages[index]] = index-left;\\n        return index-left; // len between index-1 and left. \\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        sort (ages.begin(), ages.end());\\n        \\n        int count = 0;\\n        \\n        for (int i = ages.size()-1; i >= 0 ; i--) {\\n            count += findRequests (ages, i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map <int,int> map; // key: age, val: FriendRequestCount. \\n    \\n    int findRequests (vector<int> & ages, int index) {\\n        \\n        if (map.find(ages[index]) != map.end()) {\\n            return map[ages[index]];\\n        }\\n        \\n        int left = 0;\\n        int right = index-1;\\n        double target = (double) (0.5*ages[index]) + 7; // find ages >= target.\\n        \\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (ages[mid] <= target) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        \\n        map[ages[index]] = index-left;\\n        return index-left; // len between index-1 and left. \\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        sort (ages.begin(), ages.end());\\n        \\n        int count = 0;\\n        \\n        for (int i = ages.size()-1; i >= 0 ; i--) {\\n            count += findRequests (ages, i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126944,
                "title": "python-easy-solution-using-binary-search",
                "content": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        if not ages: return 0\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            if a<=14: continue\\n            idx1 = bisect.bisect(ages, a)\\n            x = 0.5*a+7\\n            idx2 = bisect.bisect(ages, x)\\n            while idx2<N and ages[idx2]==x:\\n                idx2 += 1\\n            cnt += max(0, idx1-idx2+(-1 if idx2<=i<=idx1 else 0)) \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        if not ages: return 0\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            if a<=14: continue\\n            idx1 = bisect.bisect(ages, a)\\n            x = 0.5*a+7\\n            idx2 = bisect.bisect(ages, x)\\n            while idx2<N and ages[idx2]==x:\\n                idx2 += 1\\n            cnt += max(0, idx1-idx2+(-1 if idx2<=i<=idx1 else 0)) \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558722,
                "title": "java-2-ms-short-and-simple",
                "content": "Many posts have already mentioned the conditions can be summed up as:\\n> Person A will friend request B iif \\n> **0.5 * age[A] + 7 < age[B] <= age[A]**\\n\\nSo just iterate over the possible values of B\\'s age.\\nSum how many people there are in each age year to make calculations more efficient.\\n\\n```\\n    public int numFriendRequests(int[] ages) {\\n        int[] ageCounts = new int[121];\\n        int friendReqCount = 0;\\n        \\n        // Count how many people there are for each age\\n        for(int age : ages) {\\n            ageCounts[age]++;\\n        }\\n        \\n        for(int a=0; a<=120; a++) {\\n            // Iterate over the allowed range for B\\'s age\\n            for(int b=(int)(0.5*a)+7+1; b<=a; b++) {\\n                friendReqCount += ageCounts[a] * ageCounts[b];\\n                \\n                if(a==b) {\\n                    // A will not friend request him/herself\\n                    friendReqCount -= ageCounts[a];\\n                }\\n            }\\n        }\\n        \\n        return friendReqCount;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int[] ageCounts = new int[121];\\n        int friendReqCount = 0;\\n        \\n        // Count how many people there are for each age\\n        for(int age : ages) {\\n            ageCounts[age]++;\\n        }\\n        \\n        for(int a=0; a<=120; a++) {\\n            // Iterate over the allowed range for B\\'s age\\n            for(int b=(int)(0.5*a)+7+1; b<=a; b++) {\\n                friendReqCount += ageCounts[a] * ageCounts[b];\\n                \\n                if(a==b) {\\n                    // A will not friend request him/herself\\n                    friendReqCount -= ageCounts[a];\\n                }\\n            }\\n        }\\n        \\n        return friendReqCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704499,
                "title": "python-bucket-sorting-o-n-time",
                "content": "```\\ndef numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smaller_eq = [0] * 121\\n        for age in ages:\\n          smaller_eq[age] += 1\\n        for i in range(1, 121):\\n          smaller_eq[i] += smaller_eq[i-1]\\n\\n        res = 0\\n        for age in ages:\\n            res += max(0, smaller_eq[age] - smaller_eq[int(0.5*age)+7]-1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        smaller_eq = [0] * 121\\n        for age in ages:\\n          smaller_eq[age] += 1\\n        for i in range(1, 121):\\n          smaller_eq[i] += smaller_eq[i-1]\\n\\n        res = 0\\n        for age in ages:\\n            res += max(0, smaller_eq[age] - smaller_eq[int(0.5*age)+7]-1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 737217,
                "title": "python-simple-solution-using-counters-beats-85",
                "content": "### Algorithm\\n**Step 1**: construct a dictionary with age as key and number of members in that age group as values. This can be done using Counter in collections module.\\n**Step 2**: iterate for every age group (not every person!!) say \"me\"\\n**Step 3**: for every age group check condition take (\"age\",\"me\") pair and check if the conditions asked are satisfied with \\n* age<= 0.5 * me +7\\n* age>me\\n* 3rd condition is always false so we can omit it.\\n\\n**Step 4**:\\nHere we have 2 cases.\\n* **case(a): if your age is different from the other age**\\nfor example 16,15,15 then 15->16 and 15->16\\n\\t\\tie 2\\\\*1 which is `age_count * me_count`\\n* **case(b): if your age is same as other age**\\nfor example 16,16 then 16<->16 ie 2. \\nThis would be same as number of edges in a graph with n vertices where each edge considered 2 times which is 2\\\\*nC2 which would be `me_count*(me_count-1)`\\n### Python code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count=0\\n\\t\\t# Step 1\\n        dicto=Counter(ages)\\n\\t\\t# Step 2\\n        for me in dicto:\\n            my_age_count=dicto[me]\\n\\t\\t\\t# Step 3\\n            for age in dicto:\\n                if not (age<= 0.5 * me +7 or age>me):\\n\\t\\t\\t\\t\\t# Step 4 case (a)\\n                    if age!=me :\\n                        count+=dicto[age]*my_age_count\\n\\t\\t\\t\\t\\t# Step 4 case (b)\\n                    else:\\n                        count+=int(my_age_count*(my_age_count-1))\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count=0\\n\\t\\t# Step 1\\n        dicto=Counter(ages)\\n\\t\\t# Step 2\\n        for me in dicto:\\n            my_age_count=dicto[me]\\n\\t\\t\\t# Step 3\\n            for age in dicto:\\n                if not (age<= 0.5 * me +7 or age>me):\\n\\t\\t\\t\\t\\t# Step 4 case (a)\\n                    if age!=me :\\n                        count+=dicto[age]*my_age_count\\n\\t\\t\\t\\t\\t# Step 4 case (b)\\n                    else:\\n                        count+=int(my_age_count*(my_age_count-1))\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141466,
                "title": "python-3-with-counter",
                "content": "The third contion is redundant. \\n```python\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        cnt = collections.Counter(ages)\\n        for k1, v1 in cnt.items():\\n            for k2, v2 in cnt.items():\\n                if (k2 > 0.5*k1 + 7 and\\n                    k2 <= k1):\\n                    # if both conditions met\\n                    ans += v1 * v2\\n                    if k1 == k2:\\n                        ans -= v1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        cnt = collections.Counter(ages)\\n        for k1, v1 in cnt.items():\\n            for k2, v2 in cnt.items():\\n                if (k2 > 0.5*k1 + 7 and\\n                    k2 <= k1):\\n                    # if both conditions met\\n                    ans += v1 * v2\\n                    if k1 == k2:\\n                        ans -= v1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074946,
                "title": "python-3-three-methods-binary-search-counter-hashmap-math-explanation",
                "content": "### Approach 1. Binary Search + Math\\n- Time Complexity: `O(NlogN), N = len(ages)`\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()                                   # sort the `ages`\\n        ans = 0\\n        n = len(ages)\\n        for idx, age in enumerate(ages):              # for each age\\n            lb = age                                  # lower bound\\n            ub = (age - 7) * 2                        # upper bound\\n            i = bisect.bisect_left(ages, lb)          # binary search lower bound\\n            j = bisect.bisect_left(ages, ub)          # binary search upper bound\\n            if j - i <= 0: continue\\n            ans += j - i                              # count number of potential friends\\n            if lb <= age < ub:                        # ignore itself\\n                ans -= 1\\n        return ans\\n```\\n### Approach 2. Counter + Nested loop\\n- Time complexity: `max(O(121*121), N), N = len(ages)`\\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                           # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        ans = 0\\n        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward\\n            for ageB, countB in enumerate(count):\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                if ageA < 100 < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans    \\n```\\t\\t\\n### Approach 3. Counter + Binary Search + Math\\n- Time complexity: `max(O(121*log(121)), N), N = len(ages)`\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()                                   # sort the `ages`\\n        ans = 0\\n        n = len(ages)\\n        for idx, age in enumerate(ages):              # for each age\\n            lb = age                                  # lower bound\\n            ub = (age - 7) * 2                        # upper bound\\n            i = bisect.bisect_left(ages, lb)          # binary search lower bound\\n            j = bisect.bisect_left(ages, ub)          # binary search upper bound\\n            if j - i <= 0: continue\\n            ans += j - i                              # count number of potential friends\\n            if lb <= age < ub:                        # ignore itself\\n                ans -= 1\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                           # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        ans = 0\\n        for ageA, countA in enumerate(count):       # nested loop, pretty straightforward\\n            for ageB, countB in enumerate(count):\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                if ageA < 100 < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans    \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547711,
                "title": "binary-search-c-very-easy-solution",
                "content": "->First We will Sort the array \\n->now for all element i we have to find range of ind which satisfy the condition of friendship\\n->condition for friendship\\nlet x and y be 2 person and x want to be friend of y then\\n->x>y/2+7 &&x<=y \\n->or we can say   (y/2+7<x<=y)\\n\\n->now to find val >y/2+7 we can apply binary search \\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n       sort(ages.begin(),ages.end());\\n        int count =0;\\n        for(int i=0;i<ages.size();i++)\\n        {\\n             int val=ages[i]/2+7;\\n            if(ages[i]<=val) //invalid condition\\n                continue;\\n            \\n            int ind1=upper_bound(ages.begin(),ages.end(),val)-ages.begin();\\n            int ind2=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n            \\n            ind2--;         //because upper bound will give val greater than ages[i] soo we need to decrement ind2 to get \\n            if(ind2>=ind1)    // val<=ages[i]\\n                count+=ind2-ind1;\\n            \\n         }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n       sort(ages.begin(),ages.end());\\n        int count =0;\\n        for(int i=0;i<ages.size();i++)\\n        {\\n             int val=ages[i]/2+7;\\n            if(ages[i]<=val) //invalid condition\\n                continue;\\n            \\n            int ind1=upper_bound(ages.begin(),ages.end(),val)-ages.begin();\\n            int ind2=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n            \\n            ind2--;         //because upper bound will give val greater than ages[i] soo we need to decrement ind2 to get \\n            if(ind2>=ind1)    // val<=ages[i]\\n                count+=ind2-ind1;\\n            \\n         }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152040,
                "title": "cpp-100-easy-to-understand-and-elegant",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int map[121] = { 0 };\\n        int minage = 0, ans = 0, group = 0;\\n        \\n        for (auto a : ages)\\n            map[a]++;\\n        \\n        for (int i = 1; i < 121; ++i)\\n            map[i] += map[i-1];\\n        \\n        for (int i = 15; i < 121; ++i) {\\n            minage = (i/2 + 7);\\n            group = map[i]-map[i-1];\\n            ans += group * (map[i] - map[minage] - 1); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int map[121] = { 0 };\\n        int minage = 0, ans = 0, group = 0;\\n        \\n        for (auto a : ages)\\n            map[a]++;\\n        \\n        for (int i = 1; i < 121; ++i)\\n            map[i] += map[i-1];\\n        \\n        for (int i = 15; i < 121; ++i) {\\n            minage = (i/2 + 7);\\n            group = map[i]-map[i-1];\\n            ans += group * (map[i] - map[minage] - 1); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225554,
                "title": "o-n-solution-with-explanation",
                "content": "```\\n public int NumFriendRequests(int[] ages) {\\n        //we can see that condition age[B] > 100 && age[A] < 100 are redunant just \\n        //because of condition age[B] > age[A], the condition is actually that B should be in         //a range of (0.5 * age[A] + 7, A]\\n        // We would solve it with commulative sum approach solution:\\n        // Max age is set as 120\\n        // We would mark how many people in each age exists;\\n        var peopleInAge = new int[121];\\n        for (int i = 0; i < ages.Length; i++) {\\n            peopleInAge[ages[i]]++;\\n        }\\n        //here we count how many people bellow their age, using commulative sum approach.\\n        var countYongestPeople = new int[121];\\n        for (int  i = 1; i < 121; i++) {\\n           countYongestPeople[i] = peopleInAge[i] + countYongestPeople[i-1];\\n        }\\n        \\n        var result = 0;\\n        //there is conditions:\\n        // (1) B < A;\\n        // (2) B >= 0.5*A + 7;\\n        // if B is greater than or equal to (0.5*A + 7) then from (1), A is greater than (0.5)*A + 7;\\n        // A > 0.5*A + 7;\\n        // A - 0.5*A > 7;\\n        // 0.5*A > 7;\\n        // A > 15;\\n        for (int i = 15; i < 121; i++) {\\n            //if we don\\'t have such people, just skip it\\n            if (peopleInAge[i] == 0) continue;\\n            \\n            //calculate how many people between range (0.5 * age[A] + 7, A];\\n            var suitablePeople = countYongestPeople[i] - countYongestPeople[i/2 + 7];\\n            var suitableWithoutThemSelf = suitablePeople*peopleInAge[i] - peopleInAge[i];\\n            result += suitableWithoutThemSelf;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int NumFriendRequests(int[] ages) {\\n        //we can see that condition age[B] > 100 && age[A] < 100 are redunant just \\n        //because of condition age[B] > age[A], the condition is actually that B should be in         //a range of (0.5 * age[A] + 7, A]\\n        // We would solve it with commulative sum approach solution:\\n        // Max age is set as 120\\n        // We would mark how many people in each age exists;\\n        var peopleInAge = new int[121];\\n        for (int i = 0; i < ages.Length; i++) {\\n            peopleInAge[ages[i]]++;\\n        }\\n        //here we count how many people bellow their age, using commulative sum approach.\\n        var countYongestPeople = new int[121];\\n        for (int  i = 1; i < 121; i++) {\\n           countYongestPeople[i] = peopleInAge[i] + countYongestPeople[i-1];\\n        }\\n        \\n        var result = 0;\\n        //there is conditions:\\n        // (1) B < A;\\n        // (2) B >= 0.5*A + 7;\\n        // if B is greater than or equal to (0.5*A + 7) then from (1), A is greater than (0.5)*A + 7;\\n        // A > 0.5*A + 7;\\n        // A - 0.5*A > 7;\\n        // 0.5*A > 7;\\n        // A > 15;\\n        for (int i = 15; i < 121; i++) {\\n            //if we don\\'t have such people, just skip it\\n            if (peopleInAge[i] == 0) continue;\\n            \\n            //calculate how many people between range (0.5 * age[A] + 7, A];\\n            var suitablePeople = countYongestPeople[i] - countYongestPeople[i/2 + 7];\\n            var suitableWithoutThemSelf = suitablePeople*peopleInAge[i] - peopleInAge[i];\\n            result += suitableWithoutThemSelf;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000595,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int n = ages.size(), count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = 0.5 * ages[i] + 7;\\n            int index = upper_bound(ages.begin(), ages.end(), val) - ages.begin();\\n            int c = 1, prev = i;\\n            while (i - 1 >= 0 && ages[i] == ages[i - 1]) {\\n                c++;\\n                i--;\\n            }\\n            if (index >= prev) continue;\\n            count += (prev - index) * c;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int n = ages.size(), count = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = 0.5 * ages[i] + 7;\\n            int index = upper_bound(ages.begin(), ages.end(), val) - ages.begin();\\n            int c = 1, prev = i;\\n            while (i - 1 >= 0 && ages[i] == ages[i - 1]) {\\n                c++;\\n                i--;\\n            }\\n            if (index >= prev) continue;\\n            count += (prev - index) * c;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707318,
                "title": "python-2-solutions-binary-search-and-using-counter",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH  : BINARY SEARCH ##\\n        ## 1. Sort by age\\n        ## 2. index i person will not send friend request to ages[i]+1, ages[i]+2 ....\\n        ## 3. index i person will not send friend request to elements whose age is less than (0.5 * ages[i] + 7)\\n        ## 4. Using binary search we can find upper and lower limit, persons which fall in this range, can send friend requests (remove 1, ith person itself)\\n        \\n        ages.sort()\\n        count = 0\\n        for i in range(len(ages)):\\n            left = bisect.bisect_right( ages, (0.5 * ages[i]) + 7 )\\n            right = bisect.bisect_right( ages, ages[i])\\n            count += max(0, right - left - 1)                       # you cannot have negative count\\n        return count\\n    \\n        ## APPROACH : COUNTER ##\\n        ages = collections.Counter(ages)\\n        ans = 0\\n        for ageA, countA in ages.items():\\n            for ageB, countB in ages.items():\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH  : BINARY SEARCH ##\\n        ## 1. Sort by age\\n        ## 2. index i person will not send friend request to ages[i]+1, ages[i]+2 ....\\n        ## 3. index i person will not send friend request to elements whose age is less than (0.5 * ages[i] + 7)\\n        ## 4. Using binary search we can find upper and lower limit, persons which fall in this range, can send friend requests (remove 1, ith person itself)\\n        \\n        ages.sort()\\n        count = 0\\n        for i in range(len(ages)):\\n            left = bisect.bisect_right( ages, (0.5 * ages[i]) + 7 )\\n            right = bisect.bisect_right( ages, ages[i])\\n            count += max(0, right - left - 1)                       # you cannot have negative count\\n        return count\\n    \\n        ## APPROACH : COUNTER ##\\n        ages = collections.Counter(ages)\\n        ans = 0\\n        for ageA, countA in ages.items():\\n            for ageB, countB in ages.items():\\n                if ageA * 0.5 + 7 >= ageB: continue\\n                if ageA < ageB: continue\\n                ans += countA * countB\\n                if ageA == ageB: ans -= countA\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 212431,
                "title": "o-n-counting-dp-c",
                "content": "Since we have the condition 1 <= age <= 120, we can do something similar to counting sort. Then for every age, `a`, we want to count the number of ages within (a,b] (specifically `(a/2+7, a]`). To do this we can simply use the accumulation of the counts (i.e. first we preprocess our count array via modifying it such that it is a cumulative sum array, i.e. `count[i] = count[i] + count[i-1]`), and then we simply have: # people between `(a/2+7, a]` = `count[a] - count[a/2+7] - 1` (using `-1` to remove counting ourself).\\n\\n```\\nint counts[121] = {};\\nfor(int age : ages) {\\n\\tcounts[age]++;\\n}\\n\\nfor(int i = 1; i < 121; ++i) {\\n\\tcounts[i] += counts[i - 1];\\n}\\n\\nint total = 0;\\nfor(int age : ages) {\\n\\tint lower = age/2 + 7;\\n\\tif(lower >= age) continue;\\n\\ttotal += (counts[age] - counts[lower] - 1);\\n}\\n\\nreturn total;\\n```",
                "solutionTags": [],
                "code": "```\\nint counts[121] = {};\\nfor(int age : ages) {\\n\\tcounts[age]++;\\n}\\n\\nfor(int i = 1; i < 121; ++i) {\\n\\tcounts[i] += counts[i - 1];\\n}\\n\\nint total = 0;\\nfor(int age : ages) {\\n\\tint lower = age/2 + 7;\\n\\tif(lower >= age) continue;\\n\\ttotal += (counts[age] - counts[lower] - 1);\\n}\\n\\nreturn total;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128010,
                "title": "java-o-n-solution",
                "content": "    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int x : ages) count[x]++;\\n        int ans = 0;\\n        for(int i = 1; i <= 120; i++) {\\n            if (i > 14)\\n                ans += count[i] * (count[i]-1 + count[i-1] - count[i/2 + 7]);\\n            count[i] += count[i-1];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int x : ages) count[x]++;\\n        int ans = 0;\\n        for(int i = 1; i <= 120; i++) {\\n            if (i > 14)\\n                ans += count[i] * (count[i]-1 + count[i-1] - count[i/2 + 7]);\\n            count[i] += count[i-1];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3185944,
                "title": "java-o-nlogn-easy-to-understand-highly-commented-for-beginners",
                "content": "```\\n//     the basic intution of this code is to sort the array\\n//     and for each element we must search the first index where the condition age[y]>0.5*age[x]+7 is satisified \\n//     after that we just need to subtract the index of the array and the starting index to get no of pairs\\n//     but there is  a trick here as array contains duplicate elements if we calculate ans for ages=[16,16]\\n//     we will get wrong ans \\n//     so we maintain hashmap named index which contains last index of the element\\n//     we also maintain an hashmap named count which contains count of each element\\n//     we must now just iterate through keys of hashmap named index and search the first index satisfiying the given\\n//     condition and keep the count of no of pairs\\nclass Solution {\\n    private int solve(int ages[],int start,int end,int num){\\n        int flag=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(ages[mid]>(.5*num+7)){\\n                flag=1;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n//         this flag is the check whether there is any element which satisfies the conndition \\n//          if no such element is found we return -1 \\n        if(flag==-1){\\n            return -1;\\n        }\\n        return start;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n//         to apply binary search we are sorting \\n        Arrays.sort(ages); \\n        int c=0;\\n        HashMap<Integer,Integer>index=new HashMap<>();\\n        HashMap<Integer,Integer>count=new HashMap<>();\\n//         storing the count of each element as well as the last index of each element\\n        for(int i=0;i<ages.length;i++){\\n            index.put(ages[i],i);\\n            count.put(ages[i],count.getOrDefault(ages[i],0)+1);\\n        }\\n// iterating through the hashmap keys and find the first index where the condition age[y]>0.5*age[x]+7 is satisfied\\n//  the function will returen index subtract start current index from start index  add 1 to include that index and add the final result to c\\n        for(int x:index.keySet()){\\n            int k=solve(ages,0,index.get(x)-1,x);\\n          \\n            if(k!=-1){\\n            c+=((index.get(x)-k)*count.get(x));\\n            }\\n          \\n        }\\n        return c;\\n    }\\n}\\n// Pls do Upvote if you like :)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n//     the basic intution of this code is to sort the array\\n//     and for each element we must search the first index where the condition age[y]>0.5*age[x]+7 is satisified \\n//     after that we just need to subtract the index of the array and the starting index to get no of pairs\\n//     but there is  a trick here as array contains duplicate elements if we calculate ans for ages=[16,16]\\n//     we will get wrong ans \\n//     so we maintain hashmap named index which contains last index of the element\\n//     we also maintain an hashmap named count which contains count of each element\\n//     we must now just iterate through keys of hashmap named index and search the first index satisfiying the given\\n//     condition and keep the count of no of pairs\\nclass Solution {\\n    private int solve(int ages[],int start,int end,int num){\\n        int flag=-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(ages[mid]>(.5*num+7)){\\n                flag=1;\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n//         this flag is the check whether there is any element which satisfies the conndition \\n//          if no such element is found we return -1 \\n        if(flag==-1){\\n            return -1;\\n        }\\n        return start;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n//         to apply binary search we are sorting \\n        Arrays.sort(ages); \\n        int c=0;\\n        HashMap<Integer,Integer>index=new HashMap<>();\\n        HashMap<Integer,Integer>count=new HashMap<>();\\n//         storing the count of each element as well as the last index of each element\\n        for(int i=0;i<ages.length;i++){\\n            index.put(ages[i],i);\\n            count.put(ages[i],count.getOrDefault(ages[i],0)+1);\\n        }\\n// iterating through the hashmap keys and find the first index where the condition age[y]>0.5*age[x]+7 is satisfied\\n//  the function will returen index subtract start current index from start index  add 1 to include that index and add the final result to c\\n        for(int x:index.keySet()){\\n            int k=solve(ages,0,index.get(x)-1,x);\\n          \\n            if(k!=-1){\\n            c+=((index.get(x)-k)*count.get(x));\\n            }\\n          \\n        }\\n        return c;\\n    }\\n}\\n// Pls do Upvote if you like :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886317,
                "title": "c-self-explained-simple-code-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint numFriendRequests(vector<int>& ages) {\\n        int n=ages.size(), ages_count[121]={0};\\n        for(int i=0;i<n;++i) ages_count[ages[i]]++;\\n        \\n        int friend_request=0;\\n        for(int i=1;i<=120;i++){\\n            for(int j=1;j<=120;++j){\\n                if(i<=0.5*double(j)+7 ||  i>j || (i>100 && j<100)) continue;\\n                if(i==j) friend_request+=(ages_count[i]-1)*(ages_count[i]);\\n                else friend_request+=(ages_count[i])*(ages_count[j]);\\n            }\\n        }\\n        \\n        return friend_request;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint numFriendRequests(vector<int>& ages) {\\n        int n=ages.size(), ages_count[121]={0};\\n        for(int i=0;i<n;++i) ages_count[ages[i]]++;\\n        \\n        int friend_request=0;\\n        for(int i=1;i<=120;i++){\\n            for(int j=1;j<=120;++j){\\n                if(i<=0.5*double(j)+7 ||  i>j || (i>100 && j<100)) continue;\\n                if(i==j) friend_request+=(ages_count[i]-1)*(ages_count[i]);\\n                else friend_request+=(ages_count[i])*(ages_count[j]);\\n            }\\n        }\\n        \\n        return friend_request;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881256,
                "title": "prefix-sum",
                "content": "`age_count[i]` is a accumulative number of people with age up to ` i`.\\nExample:\\n`age_count[1]` is the number of people of age 1\\n`age_count[2]` is the number of people of age 1,2\\n`age_count[3]` is the number of people of age 1,2,3\\n...\\n`age_count[120]` is the number of people of age 1,2,3,...,120\\n\\nTo find the requests a person can make, we find the age lower bound and upper bound according to the rules. Let\\'s say the current person of the `age`.\\n\\nage[y] <= 0.5 * age[x] + 7            => discard any one with age <= `0.5 * age + 7`\\nage[y] > age[x]                              => discard any one with age > `age`\\nage[y] > 100 && age[x] < 100     => this rule is satisfied if the second one is satisfied.\\n\\nThe firsst rule will form the lower bound and the second rule will form the upper bound.\\nLet\\'s recall how sum range works with prefix sum. Suppose we have the following prefix sum:\\n```\\n0      l         r\\n.......a.........b\\n```\\nwhere \\n`l` stands for running sum from source array [0..l],\\n`r` stands for running sum from source array [0..r],\\n\\nthen, `prefix[r] - prefix[l]` is the running sum from source array [l+1..r].\\n\\nThis fits perfectly into our scenario. Here \\n`l` will be `0.5 * age + 7`\\n`r` will be `age` of the current person.\\n\\nOne edge case if when `0.5 * age + 7 > age`, there is no requests can be made.\\nIt happens when age is < 14.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        // age_count[i] means the number of people with age <= i\\n        vector<int> age_count(121, 0);\\n        for(int age: ages)\\n            age_count[age]++;\\n        for(int i=2; i<=120; i++) {\\n            age_count[i] += age_count[i-1];\\n        }\\n        \\n        int requests = 0;\\n        for(int age: ages) {\\n            int left = age*0.5+7; \\n            int right = age;\\n            if(left < right) {\\n                // -1 to excluse self\\n                requests += age_count[right] - age_count[left] - 1; \\n            }\\n        }\\n        \\n        return requests;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0      l         r\\n.......a.........b\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        // age_count[i] means the number of people with age <= i\\n        vector<int> age_count(121, 0);\\n        for(int age: ages)\\n            age_count[age]++;\\n        for(int i=2; i<=120; i++) {\\n            age_count[i] += age_count[i-1];\\n        }\\n        \\n        int requests = 0;\\n        for(int age: ages) {\\n            int left = age*0.5+7; \\n            int right = age;\\n            if(left < right) {\\n                // -1 to excluse self\\n                requests += age_count[right] - age_count[left] - 1; \\n            }\\n        }\\n        \\n        return requests;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621896,
                "title": "java-sorting-binary-search-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int n = ages.length, ans = 0;\\n        int [] cnt = new int[121];\\n        for (int i = 0; i<n; i++) {\\n            int lo = 0, hi = i-1, res = -1;\\n            // lower bound\\n            while (lo<=hi) {\\n                int mid = (lo+hi)/2;\\n                if (0.5*ages[i]+7.0>=ages[mid]) {\\n                    lo = mid+1;\\n                }\\n                else {\\n                    hi = mid-1;\\n                    res = mid;\\n                }\\n            }\\n            if (res!=-1) {\\n                ans+=(i-res); \\n                ans+=cnt[ages[i]];\\n            }\\n            cnt[ages[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int n = ages.length, ans = 0;\\n        int [] cnt = new int[121];\\n        for (int i = 0; i<n; i++) {\\n            int lo = 0, hi = i-1, res = -1;\\n            // lower bound\\n            while (lo<=hi) {\\n                int mid = (lo+hi)/2;\\n                if (0.5*ages[i]+7.0>=ages[mid]) {\\n                    lo = mid+1;\\n                }\\n                else {\\n                    hi = mid-1;\\n                    res = mid;\\n                }\\n            }\\n            if (res!=-1) {\\n                ans+=(i-res); \\n                ans+=cnt[ages[i]];\\n            }\\n            cnt[ages[i]]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761812,
                "title": "python-easy-solution-with-sort-and-sliding-window",
                "content": "I think the intuition is pretty simple. Once we look at the rules carefully, we realize that each person wants to Add others who are younger or at the same age at them, but also, not too young.\\nWe use a dict to store the rightmost index of each age at the array. This is to make sure we consider people of the same age.\\nWe also keep a counter at the left side of the array too keep track of ages that are too young to befriend.\\nSo basically, this will end up being very much similar to a typical sliding window approach where we expand the window at each step and shrink it when it starts to become invalid.\\n\\n```\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        right_most = {}\\n        for ix,x in enumerate(ages):\\n            right_most[x] = ix\\n        \\n        l = 0\\n        count = 0\\n        for ix,x in enumerate(ages):\\n            while ages[l]<= (x/2 + 7) and l<right_most[x]:\\n                l+=1\\n            count+= right_most[x] - l\\n        return count\\n",
                "solutionTags": [],
                "code": "I think the intuition is pretty simple. Once we look at the rules carefully, we realize that each person wants to Add others who are younger or at the same age at them, but also, not too young.\\nWe use a dict to store the rightmost index of each age at the array. This is to make sure we consider people of the same age.\\nWe also keep a counter at the left side of the array too keep track of ages that are too young to befriend.\\nSo basically, this will end up being very much similar to a typical sliding window approach where we expand the window at each step and shrink it when it starts to become invalid.\\n\\n```\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        right_most = {}\\n        for ix,x in enumerate(ages):\\n            right_most[x] = ix\\n        \\n        l = 0\\n        count = 0\\n        for ix,x in enumerate(ages):\\n            while ages[l]<= (x/2 + 7) and l<right_most[x]:\\n                l+=1\\n            count+= right_most[x] - l\\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 565958,
                "title": "python-counting-and-then-one-pass",
                "content": "Calculate the min idx (age) for every age to be considered as friend\\n```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        cnts = [0] * 121\\n        for age in ages:\\n            cnts[age] += 1\\n        count = cnts\\n        res = 0\\n        for i in range(1,121):\\n            if cnts[i]:\\n                k = int(i* 0.5 + 7)\\n                res += cnts[i]*sum(cnts[k+1:i])\\n                if i>k:\\n                    res += cnts[i]*(cnts[i]-1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        cnts = [0] * 121\\n        for age in ages:\\n            cnts[age] += 1\\n        count = cnts\\n        res = 0\\n        for i in range(1,121):\\n            if cnts[i]:\\n                k = int(i* 0.5 + 7)\\n                res += cnts[i]*sum(cnts[k+1:i])\\n                if i>k:\\n                    res += cnts[i]*(cnts[i]-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148918,
                "title": "binary-search-upper-and-lower-bound-solution-java",
                "content": "```\\nclass Solution {\\n     public int numFriendRequests(int[] ages) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i : ages) {\\n\\n            int lowerBound = (int )(0.5*i + 8);\\n            int upperBound = i > 100 ? i :  Math.min(100, i);\\n            int index = lower(ages, lowerBound);\\n            int index2 = upper(ages, upperBound);\\n            if (index != -1 && index2 != -1 && index2 >= index) {\\n                res += index2 - index + 1;\\n                if ( i <= upperBound && i >= lowerBound) {\\n                    res--;\\n                }\\n            }\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    public int lower(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target <= ages[0]) {\\n            return 0;\\n        }\\n        if (target > ages[r]) {\\n            return -1;\\n        }\\n        while (l  <  r) {\\n            int m = l + (r - l ) / 2 ;\\n\\n            if (ages[m] >= target) {\\n                r = m;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public int upper(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target < ages[0]) {\\n            return -1;\\n        }\\n        if (target >= ages[r]) {\\n            return r;\\n        }\\n        while (l  <  r - 1) {\\n            int m = l + (r - l ) / 2 ;\\n            if (ages[m] <= target) {\\n                l = m;\\n            }else {\\n                r = m - 1;\\n            }\\n        }\\n        return ages[r] <= target ? r : l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int numFriendRequests(int[] ages) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int res = 0;\\n        Arrays.sort(ages);\\n        for (int i : ages) {\\n\\n            int lowerBound = (int )(0.5*i + 8);\\n            int upperBound = i > 100 ? i :  Math.min(100, i);\\n            int index = lower(ages, lowerBound);\\n            int index2 = upper(ages, upperBound);\\n            if (index != -1 && index2 != -1 && index2 >= index) {\\n                res += index2 - index + 1;\\n                if ( i <= upperBound && i >= lowerBound) {\\n                    res--;\\n                }\\n            }\\n\\n        }\\n\\n        return res;\\n\\n    }\\n\\n    public int lower(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target <= ages[0]) {\\n            return 0;\\n        }\\n        if (target > ages[r]) {\\n            return -1;\\n        }\\n        while (l  <  r) {\\n            int m = l + (r - l ) / 2 ;\\n\\n            if (ages[m] >= target) {\\n                r = m;\\n            }else {\\n                l = m + 1;\\n            }\\n        }\\n        return r;\\n    }\\n\\n    public int upper(int[] ages, int target) {\\n        if (ages == null || ages.length == 0) {\\n            return 0;\\n        }\\n        int l = 0;\\n        int r = ages.length - 1;\\n        if (target < ages[0]) {\\n            return -1;\\n        }\\n        if (target >= ages[r]) {\\n            return r;\\n        }\\n        while (l  <  r - 1) {\\n            int m = l + (r - l ) / 2 ;\\n            if (ages[m] <= target) {\\n                l = m;\\n            }else {\\n                r = m - 1;\\n            }\\n        }\\n        return ages[r] <= target ? r : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127303,
                "title": "java-two-pointer-o-1-space-solution",
                "content": "ages[A] >= ages[B] > ages[A] * 0.5 +7,\\nB has to be older than 14 to make the above equation valid.\\n\\nThere are two possible directions of requests after we sort ages int[]:\\n1. From upstream bigger or equal number to all people with age bigger than ages[A] * 0.5 +7.\\n2. From downstream to all people with same age upwards in the array\\n\\nFor No.1, one way to is to use binary search to find the lower bound, then add to result, but we can also just keep a pointer j to current upstream number, then keep going down. Since ages are sorted, and the lower bounder if a linear function of ages[A], before we process the higher ages[A] lower bound, we won\\'t have to worry about missing other friend requests from other people with lower ages than A.\\nFor No.2, we keep a state variable ageSame. Each time we find a j, lower j by 1, we compare and see if it has same age as last one, if same, sameAge++, if not, we reset it to 0. \\nLastly, after we break out of for loop, j needs to keep going down until it hits the end or someone with age under 15, with same logic as the for loop.\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int res = 0;\\n        int sameAge = 0;\\n        int curLowerBound = (int) (ages[ages.length - 1]/2) + 7;\\n        int j = ages.length - 1;\\n        int i = 0;\\n        for (i = ages.length - 2; i >= 0; i--) {\\n            if (ages[i] < 15) break;\\n            while (ages[i] <= curLowerBound) {\\n                res += j - i - 1;\\n                j--;\\n                curLowerBound = (int)(ages[j]/2) + 7;\\n                if (ages[j] == ages[j+1]) {\\n                    sameAge++;\\n                    res += sameAge;\\n                } else sameAge = 0;\\n            }\\n        }\\n\\n        while (j > 0 && ages[j] > 14) {        \\n            res += j - i - 1;\\n            j--;\\n            if (ages[j] == ages[j+1]) {\\n                sameAge++;\\n                res += sameAge;\\n            } else sameAge = 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int res = 0;\\n        int sameAge = 0;\\n        int curLowerBound = (int) (ages[ages.length - 1]/2) + 7;\\n        int j = ages.length - 1;\\n        int i = 0;\\n        for (i = ages.length - 2; i >= 0; i--) {\\n            if (ages[i] < 15) break;\\n            while (ages[i] <= curLowerBound) {\\n                res += j - i - 1;\\n                j--;\\n                curLowerBound = (int)(ages[j]/2) + 7;\\n                if (ages[j] == ages[j+1]) {\\n                    sameAge++;\\n                    res += sameAge;\\n                } else sameAge = 0;\\n            }\\n        }\\n\\n        while (j > 0 && ages[j] > 14) {        \\n            res += j - i - 1;\\n            j--;\\n            if (ages[j] == ages[j+1]) {\\n                sameAge++;\\n                res += sameAge;\\n            } else sameAge = 0;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748863,
                "title": "python-o-n-2-o-nlogn-easy-to-understand",
                "content": "## **1. BRUTE FORCE - O(N^2)**\\n\\nThe Brute Force Solution is pretty simple. For every age, find every other age to which friend request can be sent.\\n\\n\\tIt is given that, \"x\" cannot send a friend request to \"y\" if - \\n\\t\\n\\t\\tage[y] <= 0.5 * age[x] + 7\\n\\t\\tage[y] > age[x]\\n\\t\\tage[y] > 100 && age[x] < 100\\n\\t\\t\\nWe can rewrite these conditions such that,\\n\\n\\t\"x\" can send a friend request to \"y\" if - \\n\\t\\n\\t\\tage[y] > 0.5 * age[x] + 7\\n\\t\\tage[y] <= age[x]\\n\\t\\t\\nWe do not need to care about third condition as that will be covered in the above two because in the above two, we are checking that age of \"y\" should be at most equal to age of \"x\", not more than that. \\n\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # For every person, we need to find how many friend requests he/she can make\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                \\n                if i != j:\\n                    # A person \"x\" can send a request to \"y if\\n                    # age[y] > 0.5 * age[x] + 7\\n                    # and age[y] <= age[x]\\n                    \\n                    condition1 = ages[j] > 0.5 * ages[i] + 7\\n                    condition2 = ages[j] <= ages[i]\\n                \\n                    if (condition1 and condition2): requestCount += 1\\n\\n        return requestCount\\n\\t\\t\\n## **2. BINARY SEARCH - O(NLogN)**\\t\\t\\n\\nTake a look at the conditions carefully -\\n\\n\\t\\tage[y] > 0.5 * age[x] + 7\\n\\t\\tage[y] <= age[x]\\n\\t\\t\\n\\nThis means, the range of valid values of age[y] for any age[x] is from -> 0.5 * age[x] + 7 to age[x]\\n\\nHence, for any age[x], we can try to find the smallest possible value in the array that is  > 0.5 * age[x] + 7\\nAnd also, we can try to find the largest possible value that is =<= age[x]\\n\\nAnd then, the number of values in between will be the number of friend requests that x can send.\\n\\nWe can do that using Binary Search but for that, we also need to sort the list first.\\n\\n\\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        for i in range(n):\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            requestCount += count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\\n\\n\\n## **3. OPTIMIZED BINARY SEARCH FOR DUPLICATE AGES - O(NLogN)**\\t\\t\\n\\nSince ages may be duplicate, why do the same process for an age if we have done it before? \\n\\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        # Since there can be duplicate ages\\n        # We can avoid doing same work again for same age\\n        dict = {}\\n        \\n        for i in range(n):\\n            \\n            # Avoid running below code if we have already have the count availabl\\n            # This is for duplicate ages\\n            if ages[i] in dict: \\n                requestCount += dict[ages[i]]\\n                continue\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            \\n            requestCount += count if count > 0 else 0\\n            \\n            # For this age value, how many friend requests can we send?\\n            dict[ages[i]] = count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n                \\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        for i in range(n):\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            requestCount += count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```\n```\\ndef numFriendRequests(self, ages: List[int]) -> int:\\n        requestCount = 0\\n        \\n        # Sort the list before applying Binary Search on it\\n        ages.sort()\\n        \\n        n = len(ages)\\n        \\n        # Since there can be duplicate ages\\n        # We can avoid doing same work again for same age\\n        dict = {}\\n        \\n        for i in range(n):\\n            \\n            # Avoid running below code if we have already have the count availabl\\n            # This is for duplicate ages\\n            if ages[i] in dict: \\n                requestCount += dict[ages[i]]\\n                continue\\n\\n            # First, find the index of smallest possible value of \"y\"\\n            # That is, the smallest value in the array that is > 0.5 * age[x] + 7\\n            \\n            leftmostValidIndex = -1\\n            \\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] > 0.5 * ages[i] + 7:\\n                    leftmostValidIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n                    \\n            # If we couldn\\'t find any valid value that is > 0.5 * age[x] + 7\\n            if leftmostValidIndex < 0: continue\\n                    \\n            # Now, find the index of largest possible value of \"y\"\\n            # That is, the largest value in the array that is <= x\\n            \\n            rightmostValidIndex = -1\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if ages[mid] <= ages[i]:\\n                    rightmostValidIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n                    \\n            # How many ages are there to which we can send friend request?\\n            count = rightmostValidIndex - leftmostValidIndex\\n            \\n            requestCount += count if count > 0 else 0\\n            \\n            # For this age value, how many friend requests can we send?\\n            dict[ages[i]] = count if count > 0 else 0\\n            \\n        \\n        return requestCount\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2635031,
                "title": "java-8-feature-s-more-concise-code-3-lines-most-voted",
                "content": "```\\n**UPVOTE PLEASE**\\n\\npublic int numFriendRequests(int[] ages) {\\nvar count = new HashMap<Integer,Integer>();\\n    BiPredicate<Integer,Integer> p=(a,b)->!(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    Arrays.stream(ages).boxed().forEach(age->count.put(age, count.getOrDefault(age,0)+1));\\n    var res = new AtomicInteger(0);\\n    count.keySet().forEach(a->count.keySet().forEach(b->{if (p.test(a, b)){res.set(count.get(a) * (count.get(b) - (a == b ? 1 : 0))+res.get());}}));\\n    return res.get();    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n**UPVOTE PLEASE**\\n\\npublic int numFriendRequests(int[] ages) {\\nvar count = new HashMap<Integer,Integer>();\\n    BiPredicate<Integer,Integer> p=(a,b)->!(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    Arrays.stream(ages).boxed().forEach(age->count.put(age, count.getOrDefault(age,0)+1));\\n    var res = new AtomicInteger(0);\\n    count.keySet().forEach(a->count.keySet().forEach(b->{if (p.test(a, b)){res.set(count.get(a) * (count.get(b) - (a == b ? 1 : 0))+res.get());}}));\\n    return res.get();    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043130,
                "title": "simple-python-solution-beats-88",
                "content": "\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\t    # send request or not\\n        def request(x,y):\\n            if y <= 0.5 * x + 7 or y > x or (y > 100 and x < 100):\\n                return False\\n            return True\\n        \\n\\t\\t# Construct a dictionary that the keys are ages and the values are the frequency of the age in the list. \\n        ages_map = collections.Counter(ages)\\n\\t\\t\\n\\t\\t# Sort age list\\n        ages = list(ages_map.keys())\\n        ages.sort(reverse=True)\\n\\n        count = 0\\n        for i in range(len(ages)):\\n            for j in range(i+1,len(ages)):\\n\\t\\t\\t# Different age: {a:2, b:3}\\n\\t\\t\\t# a --> b :  number of a * number of b\\n                if request(ages[i],ages[j]):\\n                    count += ages_map[ages[i]]* ages_map[ages[j]]\\n            # Same age: {a:2}\\n\\t\\t\\t# a --> a: n * (n -1)\\n\\t\\t\\t\\t# example1 : [16, 16, 16]: request --> True --> 3 * (3-1) = 6\\n\\t\\t\\t\\t# example2: [6,6] : request --> False \\n            if request(ages[i],ages[i]):\\n                count += ages_map[ages[i]]*(ages_map[ages[i]]-1)\\n        return count\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\t    # send request or not\\n        def request(x,y):\\n            if y <= 0.5 * x + 7 or y > x or (y > 100 and x < 100):\\n                return False\\n            return True\\n        \\n\\t\\t# Construct a dictionary that the keys are ages and the values are the frequency of the age in the list. \\n        ages_map = collections.Counter(ages)\\n\\t\\t\\n\\t\\t# Sort age list\\n        ages = list(ages_map.keys())\\n        ages.sort(reverse=True)\\n\\n        count = 0\\n        for i in range(len(ages)):\\n            for j in range(i+1,len(ages)):\\n\\t\\t\\t# Different age: {a:2, b:3}\\n\\t\\t\\t# a --> b :  number of a * number of b\\n                if request(ages[i],ages[j]):\\n                    count += ages_map[ages[i]]* ages_map[ages[j]]\\n            # Same age: {a:2}\\n\\t\\t\\t# a --> a: n * (n -1)\\n\\t\\t\\t\\t# example1 : [16, 16, 16]: request --> True --> 3 * (3-1) = 6\\n\\t\\t\\t\\t# example2: [6,6] : request --> False \\n            if request(ages[i],ages[i]):\\n                count += ages_map[ages[i]]*(ages_map[ages[i]]-1)\\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1999119,
                "title": "the-actual-facebook-interview-question-java",
                "content": "Thanks to @connect2grp for pointing out an error in my initial solution :)\\n```\\n/*\\nA group of centaurs (mythical half-human, half-horse creatures) all sign up for Facebook accounts at the same time. They immediately start sending each other friend requests, in accordance with the ancient rules that have governed centaur friendship since the dawn of time:\\n\\n1. A centaur will only send a friend request to another centaur if the recipient is at least (X/2 + 7) of the sender\\'s age. For example, a 200-year old centaur can only send friend requests to centaurs that are at least 107 years old.\\n2. A centaur will not send a friend request to another centaur that is older than it is.\\n3. A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n4. If any of the conditions for sending a friend request are not met, no friend request will be sent.\\nWrite a function that, given an array of centaur ages, returns an integer of the total number of friend requests that the group of centaurs will send to each other.\\n*/\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] test1 = new int[]{120, 110}; // => 1\\n        int[] test2 = new int[]{120,110,99}; // => 1\\n        int[] test3 = new int[]{120,45,230,400,88,300,101}; // => 4\\n        int[] test4 = new int[]{120,45,55,230,400,88,300,101}; // => 6\\n        int[] test5 = new int[]{100,110,120};\\n    }\\n\\n    public static int numFriendRequests(int[] ages) {\\n        if (ages.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(ages);\\n        int requests = 0;\\n        \\n        for (int i = 0; i < ages.length; i++) {\\n            int curr_age = ages[i];\\n            int left = findIndex(ages, curr_age, curr_age / 2 + 7);\\n            int right = findIndex(ages, curr_age, curr_age);\\n            requests += Math.max(0, right - left);\\n        }\\n        return requests;\\n    }\\n    \\n    public static int findIndex(int[] ages, int curr_age, int target) {\\n        if (curr_age >= 100) {\\n            target = Math.max(target, 100);\\n        }\\n        \\n        int left = 0;\\n        int right = ages.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ages[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nA group of centaurs (mythical half-human, half-horse creatures) all sign up for Facebook accounts at the same time. They immediately start sending each other friend requests, in accordance with the ancient rules that have governed centaur friendship since the dawn of time:\\n\\n1. A centaur will only send a friend request to another centaur if the recipient is at least (X/2 + 7) of the sender\\'s age. For example, a 200-year old centaur can only send friend requests to centaurs that are at least 107 years old.\\n2. A centaur will not send a friend request to another centaur that is older than it is.\\n3. A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n4. If any of the conditions for sending a friend request are not met, no friend request will be sent.\\nWrite a function that, given an array of centaur ages, returns an integer of the total number of friend requests that the group of centaurs will send to each other.\\n*/\\npublic class Main {\\n    public static void main(String[] args) {\\n        int[] test1 = new int[]{120, 110}; // => 1\\n        int[] test2 = new int[]{120,110,99}; // => 1\\n        int[] test3 = new int[]{120,45,230,400,88,300,101}; // => 4\\n        int[] test4 = new int[]{120,45,55,230,400,88,300,101}; // => 6\\n        int[] test5 = new int[]{100,110,120};\\n    }\\n\\n    public static int numFriendRequests(int[] ages) {\\n        if (ages.length == 0) {\\n            return 0;\\n        }\\n        \\n        Arrays.sort(ages);\\n        int requests = 0;\\n        \\n        for (int i = 0; i < ages.length; i++) {\\n            int curr_age = ages[i];\\n            int left = findIndex(ages, curr_age, curr_age / 2 + 7);\\n            int right = findIndex(ages, curr_age, curr_age);\\n            requests += Math.max(0, right - left);\\n        }\\n        return requests;\\n    }\\n    \\n    public static int findIndex(int[] ages, int curr_age, int target) {\\n        if (curr_age >= 100) {\\n            target = Math.max(target, 100);\\n        }\\n        \\n        int left = 0;\\n        int right = ages.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ages[mid] >= target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973990,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121,0);\\n        int n=ages.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v[ages[i]]++;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=15;i<=120;i++)\\n        {\\n            ans+=v[i]*(v[i]-1);\\n        }\\n        \\n        for(int i=1;i<=120;i++)\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(j>(i/2)+7)\\n                {\\n                    ans+=v[i]*v[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121,0);\\n        int n=ages.size();\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v[ages[i]]++;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=15;i<=120;i++)\\n        {\\n            ans+=v[i]*(v[i]-1);\\n        }\\n        \\n        for(int i=1;i<=120;i++)\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(j>(i/2)+7)\\n                {\\n                    ans+=v[i]*v[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855680,
                "title": "javascript-cumulative-sum-o-n",
                "content": "This approach uses multiple O(Max(N, 120)) passes and O(Max(N, 120)) auxiliary space.\\nPlease let me know if you have suggestions for improvement or if my time / space analysis is off.\\n\\nGeneral Approach:\\nAnother way to rephrase the requirements is that, for each age X, there is an acceptable age interval [Y1, Y2]  to which we can send friend requests.\\nLower boundary (Y1): Y must be > 7 + 0.5 * X\\nUpper boundary (Y2): Y must be <= X\\nThe last condition described in the problem (\"no request sent if X < 100 and Y > 100\") is essentially covered by our upper bound, so the problem can really be reduced to dealing with the interval described above.\\n\\n\\n```\\nvar numFriendRequests = function(ages) {\\n    let count = 0;\\n    \\n    const ageCountMap = new Map(); // S: O(N)\\n    const ageCountArr = [0]; // S: O(120)\\n    \\n    // Count how many people have a certain age.\\n    for (let age of ages) { // T: O(N)\\n        let currCount = ageCountMap.get(age) || 0;\\n        ageCountMap.set(age, currCount + 1);\\n    }\\n    // Count how many people have up to (and including) a certain age\\n    for (let i = 1; i <= 120; i++) { // T: O(120)\\n        let ageCount = ageCountMap.get(i) || 0;\\n        ageCountArr.push(ageCount + ageCountArr[i - 1]);\\n    }\\n    \\n    for (let age of ages) { // T: O(N)\\n        let lowerBound = Math.floor((age * 0.5)) + 7 + 1; // Inclusive\\n        let upperBound = age; // Inclusive\\n\\t\\t// Calculate requests by subtracting cumulative sum up to the lower bound from the cumulative sum up to the upper bound\\n\\t\\t// Need \"-1\" to deduct a given person from the request, since we can\\'t send requests to ourselves\\n        let requests = ageCountArr[upperBound] - ageCountArr[lowerBound - 1] - 1; \\n        if (requests < 0) continue;\\n        count += requests;\\n    }\\n    return count;\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "This approach uses multiple O(Max(N, 120)) passes and O(Max(N, 120)) auxiliary space.\\nPlease let me know if you have suggestions for improvement or if my time / space analysis is off.\\n\\nGeneral Approach:\\nAnother way to rephrase the requirements is that, for each age X, there is an acceptable age interval [Y1, Y2]  to which we can send friend requests.\\nLower boundary (Y1): Y must be > 7 + 0.5 * X\\nUpper boundary (Y2): Y must be <= X\\nThe last condition described in the problem (\"no request sent if X < 100 and Y > 100\") is essentially covered by our upper bound, so the problem can really be reduced to dealing with the interval described above.\\n\\n\\n```\\nvar numFriendRequests = function(ages) {\\n    let count = 0;\\n    \\n    const ageCountMap = new Map(); // S: O(N)\\n    const ageCountArr = [0]; // S: O(120)\\n    \\n    // Count how many people have a certain age.\\n    for (let age of ages) { // T: O(N)\\n        let currCount = ageCountMap.get(age) || 0;\\n        ageCountMap.set(age, currCount + 1);\\n    }\\n    // Count how many people have up to (and including) a certain age\\n    for (let i = 1; i <= 120; i++) { // T: O(120)\\n        let ageCount = ageCountMap.get(i) || 0;\\n        ageCountArr.push(ageCount + ageCountArr[i - 1]);\\n    }\\n    \\n    for (let age of ages) { // T: O(N)\\n        let lowerBound = Math.floor((age * 0.5)) + 7 + 1; // Inclusive\\n        let upperBound = age; // Inclusive\\n\\t\\t// Calculate requests by subtracting cumulative sum up to the lower bound from the cumulative sum up to the upper bound\\n\\t\\t// Need \"-1\" to deduct a given person from the request, since we can\\'t send requests to ourselves\\n        let requests = ageCountArr[upperBound] - ageCountArr[lowerBound - 1] - 1; \\n        if (requests < 0) continue;\\n        count += requests;\\n    }\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1397398,
                "title": "java-easy-map",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n         Map<Integer,Integer> mp = new HashMap<>();\\n      \\n         for(int age : ages){\\n            mp.put(age,mp.getOrDefault(age,0) + 1);\\n         }\\n        int count = 0; //count of friend requests\\n        for(int a : mp.keySet()){\\n           for(int b : mp.keySet()){\\n              if(canSendFReq(a,b) == true){\\n                  int AsF = mp.get(a); //A\\'s Friends\\n                  int BsF = mp.get(b); //B\\'s Friends\\n                //As a person cannot send req to himself\\n                  if(a == b){\\n                     BsF--;   //Reduce B\\'s friends by one as B is iterating inside the inner loop\\n                  }\\n\\t\\t\\t   //As both of them gonna sent req to each other (also persons with same ages will be doing same thing)\\n                 count = count + AsF * BsF;\\n              }\\n           }\\n        }\\n      return count;\\n    }\\n    public boolean canSendFReq(int x,int y){\\n        return !(y <= 0.5 * x + 7 || y > x || (y > 100 && x < 100));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n         Map<Integer,Integer> mp = new HashMap<>();\\n      \\n         for(int age : ages){\\n            mp.put(age,mp.getOrDefault(age,0) + 1);\\n         }\\n        int count = 0; //count of friend requests\\n        for(int a : mp.keySet()){\\n           for(int b : mp.keySet()){\\n              if(canSendFReq(a,b) == true){\\n                  int AsF = mp.get(a); //A\\'s Friends\\n                  int BsF = mp.get(b); //B\\'s Friends\\n                //As a person cannot send req to himself\\n                  if(a == b){\\n                     BsF--;   //Reduce B\\'s friends by one as B is iterating inside the inner loop\\n                  }\\n\\t\\t\\t   //As both of them gonna sent req to each other (also persons with same ages will be doing same thing)\\n                 count = count + AsF * BsF;\\n              }\\n           }\\n        }\\n      return count;\\n    }\\n    public boolean canSendFReq(int x,int y){\\n        return !(y <= 0.5 * x + 7 || y > x || (y > 100 && x < 100));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297207,
                "title": "javascript-solution-cumulative-sum-and-sliding-window",
                "content": "```\\nvar numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    \\n    ages.forEach((age) => count[age]++);\\n\\n    let res = 0; // total friend request sent\\n    let tot = 0;  // cumulative count of people so far\\n    \\n    for (let i = 0; i <= 120; i++) {\\n\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n\\n            res += (count[i] * rest); // current age group send friend request to other people who are within their limit\\n            res += (count[i] * (count[i] - 1)); // current age group send friend request to each other\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar numFriendRequests = function(ages) {\\n    const count = new Array(121).fill(0);\\n    \\n    ages.forEach((age) => count[age]++);\\n\\n    let res = 0; // total friend request sent\\n    let tot = 0;  // cumulative count of people so far\\n    \\n    for (let i = 0; i <= 120; i++) {\\n\\n        if (i > 14 && count[i] != 0) {\\n            const limit = Math.floor(0.5 * i) + 7;\\n            const rest = tot - count[limit];\\n\\n            res += (count[i] * rest); // current age group send friend request to other people who are within their limit\\n            res += (count[i] * (count[i] - 1)); // current age group send friend request to each other\\n        }\\n\\n        tot += count[i];\\n        count[i] = tot; \\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216308,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n            int k , count=0;\\n               sort(ages.begin(),ages.end());\\n        for(int i=ages.size()-1;i>0;i--)\\n        {\\n                  k=upper_bound(ages.begin(),ages.begin()+i,((ages[i]/2)+7))-ages.begin(); \\n\\t\\t\\t\\t       // it returns the index that is greater than (ages[i]/2+7) \\n             \\n                     if(k<=i)  \\n                      {\\n\\t\\t\\t\\t\\t       count+=i-k;   // i-k gives the no of requests can ages[i] can send \\n\\t\\t\\t\\t\\t  }   \\n\\t\\t\\t\\t\\t     // k is greater than i if upper_bound of (ages[i]/2+7)  is not found\\n              \\n\\t\\t\\t      k=i-1;\\n               while(k>=0&&ages[k]==ages[i]&&ages[k]>((ages[i]/2)+7))\\n               {\\n                   count++;\\n                   k--;\\n               }\\n\\t\\t\\t   // to check if there are any equal ages and also satisfy (ages[i]/2+7)  condition\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n            int k , count=0;\\n               sort(ages.begin(),ages.end());\\n        for(int i=ages.size()-1;i>0;i--)\\n        {\\n                  k=upper_bound(ages.begin(),ages.begin()+i,((ages[i]/2)+7))-ages.begin(); \\n\\t\\t\\t\\t       // it returns the index that is greater than (ages[i]/2+7) \\n             \\n                     if(k<=i)  \\n                      {\\n\\t\\t\\t\\t\\t       count+=i-k;   // i-k gives the no of requests can ages[i] can send \\n\\t\\t\\t\\t\\t  }   \\n\\t\\t\\t\\t\\t     // k is greater than i if upper_bound of (ages[i]/2+7)  is not found\\n              \\n\\t\\t\\t      k=i-1;\\n               while(k>=0&&ages[k]==ages[i]&&ages[k]>((ages[i]/2)+7))\\n               {\\n                   count++;\\n                   k--;\\n               }\\n\\t\\t\\t   // to check if there are any equal ages and also satisfy (ages[i]/2+7)  condition\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066096,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "1. Brute force O(n^2)\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int num=0,n =ages.length;\\n        for(int i=0;i<n-1;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(canMakeRequest(ages[i],ages[j])) {\\n                    num++;\\n                }\\n                if(canMakeRequest(ages[j],ages[i])) {\\n                    num++;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n    private boolean canMakeRequest(int from, int to) {\\n        return to<=from && to>0.5*from+7;\\n    }\\n```\\n2. Binary search O(nlogn). B is in (0.5A+7, A]. We can sort the array and compute number of Bs for each A.\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int num=0;\\n        for(int i=0;i<ages.length;i++) {\\n            int left = leftBound(ages[i]/2+8,ages), right = rightBound(ages[i], ages);\\n            num+=Math.max(right-left,0);   \\n        }\\n        return num;\\n    }\\n    private int leftBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(ages[mid]<target) {\\n                l = mid+1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n    private int rightBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r+1)/2;\\n            if(ages[mid]<=target) {\\n                l = mid;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n```\\n3. Bucket sort O(n)\\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int age:ages) {\\n            count[age]++;\\n        }\\n        int num=0;\\n        for(int i=1;i<=120;i++) {\\n            for(int j=i/2+8;j<=i;j++) {\\n                if(i == j) {\\n                    num += count[i]*(count[i]-1);\\n                } else {\\n                    num += count[i]*count[j];   \\n                }\\n            }\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int num=0,n =ages.length;\\n        for(int i=0;i<n-1;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if(canMakeRequest(ages[i],ages[j])) {\\n                    num++;\\n                }\\n                if(canMakeRequest(ages[j],ages[i])) {\\n                    num++;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n    private boolean canMakeRequest(int from, int to) {\\n        return to<=from && to>0.5*from+7;\\n    }\\n```\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int num=0;\\n        for(int i=0;i<ages.length;i++) {\\n            int left = leftBound(ages[i]/2+8,ages), right = rightBound(ages[i], ages);\\n            num+=Math.max(right-left,0);   \\n        }\\n        return num;\\n    }\\n    private int leftBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r)/2;\\n            if(ages[mid]<target) {\\n                l = mid+1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return r;\\n    }\\n    private int rightBound(int target, int[] ages) {\\n        int l=0, r=ages.length-1;\\n        while(l<r) {\\n            int mid = (l+r+1)/2;\\n            if(ages[mid]<=target) {\\n                l = mid;\\n            } else {\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n```\n```\\n\\tpublic int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        for(int age:ages) {\\n            count[age]++;\\n        }\\n        int num=0;\\n        for(int i=1;i<=120;i++) {\\n            for(int j=i/2+8;j<=i;j++) {\\n                if(i == j) {\\n                    num += count[i]*(count[i]-1);\\n                } else {\\n                    num += count[i]*count[j];   \\n                }\\n            }\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022078,
                "title": "python-3-sliding-window-beats-99-6",
                "content": "Nothing fancy, I just applied counter to speed up processing same agers.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages = sorted(Counter(ages).items(), key=lambda x: x[0])\\n\\n        def calc(arr):\\n            total = 0\\n            window = 0\\n            left = 0\\n            for right, (age, count) in enumerate(arr):\\n                while left < right and arr[left][0] <= 0.5 * age + 7:\\n                    window -= arr[left][1]\\n                    left += 1\\n                total += window * count\\n                if count > 1 and age > 0.5 * age + 7:\\n                    total += (count - 1) * count\\n                window += count\\n            return total\\n\\n        return calc(ages)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages = sorted(Counter(ages).items(), key=lambda x: x[0])\\n\\n        def calc(arr):\\n            total = 0\\n            window = 0\\n            left = 0\\n            for right, (age, count) in enumerate(arr):\\n                while left < right and arr[left][0] <= 0.5 * age + 7:\\n                    window -= arr[left][1]\\n                    left += 1\\n                total += window * count\\n                if count > 1 and age > 0.5 * age + 7:\\n                    total += (count - 1) * count\\n                window += count\\n            return total\\n\\n        return calc(ages)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923906,
                "title": "java-1-ms-faster-than-100-00-40-9-mb-less-than-7-93",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] cnts = new int[121];\\n        int[] sums = new int[121];\\n        for (int age : ages) {\\n            ++cnts[age];\\n        }\\n        for (int i = 1; i <= 120; ++i) {\\n            sums[i] = sums[i - 1] + cnts[i];\\n        }\\n        int sum = 0;\\n        for (int i = 15; i <= 120; ++i) {\\n            if (cnts[i] <= 0) {\\n                continue;\\n            }\\n            int cnt = sums[i] - sums[i / 2 + 7];\\n            sum += (cnt - 1) * cnts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] cnts = new int[121];\\n        int[] sums = new int[121];\\n        for (int age : ages) {\\n            ++cnts[age];\\n        }\\n        for (int i = 1; i <= 120; ++i) {\\n            sums[i] = sums[i - 1] + cnts[i];\\n        }\\n        int sum = 0;\\n        for (int i = 15; i <= 120; ++i) {\\n            if (cnts[i] <= 0) {\\n                continue;\\n            }\\n            int cnt = sums[i] - sums[i / 2 + 7];\\n            sum += (cnt - 1) * cnts[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388169,
                "title": "wrong-test-case",
                "content": "```\\nInput: [16,17,18]\\nOutput: 2\\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\\n```\\n\\nIn this given test case, how come ages[2] doesn\\'t friend request ages[0]? (i.e. why is 18 -> 16 invalid?)",
                "solutionTags": [],
                "code": "```\\nInput: [16,17,18]\\nOutput: 2\\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330880,
                "title": "python-sliding-window-one-pass",
                "content": "I use `L` and `R` to maintain a sliding window to calculate the requests made from the current element to elements in the window.\\nAnd I also use the varible `n` to calculate the request made from within the window to the current element ( Since we have sorted the array, the elements which made requests from within the window must have the same value with the current element).\\n```python\\ndef numFriendRequests(self, ages):\\n    ages.sort()\\n    L = res = n = 0\\n    for R, V in enumerate(ages):\\n        limit = V/2 + 7\\n        while L < R and ages[L] <= limit:\\n            L += 1\\n        n = n+1 if R and ages[R] == ages[R-1] and ages[R] > 14 else 0\\n        res += R-L+n\\n    return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef numFriendRequests(self, ages):\\n    ages.sort()\\n    L = res = n = 0\\n    for R, V in enumerate(ages):\\n        limit = V/2 + 7\\n        while L < R and ages[L] <= limit:\\n            L += 1\\n        n = n+1 if R and ages[R] == ages[R-1] and ages[R] > 14 else 0\\n        res += R-L+n\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 282361,
                "title": "o-n-high-school-logic-a-2-7-b-a",
                "content": "A cannot send B request if (B<=A/2+7) || (B>A) || (B>100&&A<100). Then\\nA can send B request if ![(B<=A/2+7) || (B>A) || (B>100&&A<100)], which is equivalent to\\nA/2+7<B<=A && (B<=100 || A>=100).\\nLastly, we can see that (B<=100 || A>=100) is redundant, this is because (1) if A >= 100, we don\\'t need to consider B, since the boolean expression is already true. (2) if A <100, then by B<=A, B has to be less than 100, hence B<=100 is true. Hence, the restriction can be reduced to A/2+7<B<=A. By simple algebra, we can see that A/2+7<A, A>14.\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        //A send request to B if A/2+7<B<=A && (B<=100 || A >=100)\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            for(int B=A/2+8; B<=A; B++) {\\n                if(B < A) ret += count[B]*count[A];\\n                else if(B == A) ret += count[A] * (count[A]-1);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\nThe above time complexity is O(N^2), however If we watch the second loop carefully, we can see that it is actually the **count[A]\\\\*(range sum of count[A/2+8 : A] - 1)**, hence we can use prefix sum to handle it quickly in O(N). The optimization is shown below.\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        for(int i=1; i<=120; i++) count[i] += count[i-1];\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            int B = A/2+8;\\n            ret += (count[A]-count[A-1]) * (count[A] - count[B-1] - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        //A send request to B if A/2+7<B<=A && (B<=100 || A >=100)\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            for(int B=A/2+8; B<=A; B++) {\\n                if(B < A) ret += count[B]*count[A];\\n                else if(B == A) ret += count[A] * (count[A]-1);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n        for(auto age : ages) count[age] += 1;\\n        for(int i=1; i<=120; i++) count[i] += count[i-1];\\n        int ret = 0;\\n        for(int A=15; A<=120; A++) {\\n            int B = A/2+8;\\n            ret += (count[A]-count[A-1]) * (count[A] - count[B-1] - 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126969,
                "title": "python-collections-counter-ac-solution",
                "content": "```\\nfrom collections import Counter\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr=Counter(ages)\\n        res=0\\n        for A in cntr:\\n            for B in cntr:\\n                if A==B:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=(cntr[A]*(cntr[A]-1))\\n                else:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=cntr[A]*cntr[B]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cntr=Counter(ages)\\n        res=0\\n        for A in cntr:\\n            for B in cntr:\\n                if A==B:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=(cntr[A]*(cntr[A]-1))\\n                else:\\n                    if B<=0.5*A+7 or B>A or (B>100 and A<100): continue\\n                    res+=cntr[A]*cntr[B]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126943,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        if(ages.length < 2) return 0;\\n        int[] cnt = new int[125];\\n        for(int n:ages){\\n            cnt[n]++;\\n        }\\n        int res = 0;\\n        for(int i=2;i<=120;i++){\\n            if(cnt[i] == 0) continue;\\n            int total = 0;\\n            int start = (int)(0.5 * i) + 8;    \\n            if(start > i) continue;// violates this rule age[B] <= 0.5 * age[A] + 7...so skip this i\\n            for(int j=start;j<i;j++){\\n                total += cnt[j];\\n            }            \\n            if(cnt[i] > 1)\\n                total += (cnt[i] - 1);            \\n            res += (total * cnt[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\nNote: Please see comments for explanation",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        if(ages.length < 2) return 0;\\n        int[] cnt = new int[125];\\n        for(int n:ages){\\n            cnt[n]++;\\n        }\\n        int res = 0;\\n        for(int i=2;i<=120;i++){\\n            if(cnt[i] == 0) continue;\\n            int total = 0;\\n            int start = (int)(0.5 * i) + 8;    \\n            if(start > i) continue;// violates this rule age[B] <= 0.5 * age[A] + 7...so skip this i\\n            for(int j=start;j<i;j++){\\n                total += cnt[j];\\n            }            \\n            if(cnt[i] > 1)\\n                total += (cnt[i] - 1);            \\n            res += (total * cnt[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126935,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int freq [] = new int [121];\\n        int ret = 0;\\n        \\n        for(int i = 0; i < ages.length; i++){\\n            freq[ages[i]]++;\\n        }\\n        \\n        for(int i = 1; i <= 120; i++){\\n            for(int j = 1; j <= 120; j++){\\n                if(!((j <= 0.5 * i + 7) || (j > i) || (j > 100 && i < 100))){\\n                    if(i == j) {\\n                        ret = ret + ((freq[i] * (freq[i] - 1)));\\n                    } else {\\n                        ret = ret + (freq[i] * freq[j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int freq [] = new int [121];\\n        int ret = 0;\\n        \\n        for(int i = 0; i < ages.length; i++){\\n            freq[ages[i]]++;\\n        }\\n        \\n        for(int i = 1; i <= 120; i++){\\n            for(int j = 1; j <= 120; j++){\\n                if(!((j <= 0.5 * i + 7) || (j > i) || (j > 100 && i < 100))){\\n                    if(i == j) {\\n                        ret = ret + ((freq[i] * (freq[i] - 1)));\\n                    } else {\\n                        ret = ret + (freq[i] * freq[j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034801,
                "title": "best-java-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481569,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121, 0);\\n        for(auto it: ages)\\n            v[it]++;\\n        int ans=0;\\n        for(int i=1; i<121; i++)\\n        {\\n            if(v[i]==0) continue;\\n            int tmp =0;\\n            for(int j=1; j<121; j++)\\n            {\\n                if(v[j]==0) continue;\\n                if(i==j)\\n                {\\n                    if(j>(i*0.5+7))\\n                        tmp+=(v[i]-1);\\n                }\\n                else\\n                {\\n                    bool flag= true;\\n                    if(j<=(i*0.5+7)) flag= false;\\n                    if(j>i) flag= false;\\n                    if(i<100 && j>100) flag= false;\\n                    if(flag)\\n                        tmp+=v[j];\\n                }\\n            }\\n            ans= ans + v[i]*tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass FriendRequest:\\n    def _binarySearch(self, ages, target):\\n        lo = 0\\n        hi = len(ages) - 1\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if ages[mid] <= target:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return lo\\n    \\n    def numOfRequests(self, ages):\\n        requests = 0\\n        ages.sort()\\n        for age in ages:\\n            left = self._binarySearch(ages, age // 2 + 7)\\n            right = self._binarySearch(ages, age) - 1\\n            requests += max(0, right - left)\\n        return requests\\n\\nclass FriendRequest2:\\n    def _bucketSort(self, ages):\\n        buckets = [0] * 121\\n        for age in ages:\\n            buckets[age] += 1\\n        return buckets\\n    \\n    def _buildPrefixSum(self, buckets):\\n        prefix = [0] * 121\\n        for i in range(1, 121):\\n            prefix[i] += prefix[i - 1] + buckets[i]\\n        return prefix\\n    \\n    def numOfRequests(self, ages):\\n        buckets = self._bucketSort(ages)\\n        prefix = self._buildPrefixSum(buckets)\\n        requests = 0\\n        for age in range(15, 121):\\n            if buckets[age] == 0:\\n                continue\\n            cur_requests = prefix[age] - prefix[age // 2 + 7]\\n            requests += buckets[age] * cur_requests - buckets[age]\\n        return requests\\n\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        return FriendRequest2().numOfRequests(ages)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        for(int a : ages) {\\n            numInAge[a]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            sumInAge[i] = numInAge[i] + sumInAge[i-1];\\n        }\\n        for(int i = 15; i <= 120; i++) {\\n            if (numInAge[i] == 0)   continue;\\n            int c = sumInAge[i] - sumInAge[i/2 + 7];\\n            res += c * numInAge[i] - numInAge[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121, 0);\\n        for(auto it: ages)\\n            v[it]++;\\n        int ans=0;\\n        for(int i=1; i<121; i++)\\n        {\\n            if(v[i]==0) continue;\\n            int tmp =0;\\n            for(int j=1; j<121; j++)\\n            {\\n                if(v[j]==0) continue;\\n                if(i==j)\\n                {\\n                    if(j>(i*0.5+7))\\n                        tmp+=(v[i]-1);\\n                }\\n                else\\n                {\\n                    bool flag= true;\\n                    if(j<=(i*0.5+7)) flag= false;\\n                    if(j>i) flag= false;\\n                    if(i<100 && j>100) flag= false;\\n                    if(flag)\\n                        tmp+=v[j];\\n                }\\n            }\\n            ans= ans + v[i]*tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass FriendRequest:\\n    def _binarySearch(self, ages, target):\\n        lo = 0\\n        hi = len(ages) - 1\\n        while lo <= hi:\\n            mid = lo + (hi - lo) // 2\\n            if ages[mid] <= target:\\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return lo\\n    \\n    def numOfRequests(self, ages):\\n        requests = 0\\n        ages.sort()\\n        for age in ages:\\n            left = self._binarySearch(ages, age // 2 + 7)\\n            right = self._binarySearch(ages, age) - 1\\n            requests += max(0, right - left)\\n        return requests\\n\\nclass FriendRequest2:\\n    def _bucketSort(self, ages):\\n        buckets = [0] * 121\\n        for age in ages:\\n            buckets[age] += 1\\n        return buckets\\n    \\n    def _buildPrefixSum(self, buckets):\\n        prefix = [0] * 121\\n        for i in range(1, 121):\\n            prefix[i] += prefix[i - 1] + buckets[i]\\n        return prefix\\n    \\n    def numOfRequests(self, ages):\\n        buckets = self._bucketSort(ages)\\n        prefix = self._buildPrefixSum(buckets)\\n        requests = 0\\n        for age in range(15, 121):\\n            if buckets[age] == 0:\\n                continue\\n            cur_requests = prefix[age] - prefix[age // 2 + 7]\\n            requests += buckets[age] * cur_requests - buckets[age]\\n        return requests\\n\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        return FriendRequest2().numOfRequests(ages)\\n```\n```Java []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int res = 0;\\n        int[] numInAge = new int[121], sumInAge = new int[121];\\n        for(int a : ages) {\\n            numInAge[a]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            sumInAge[i] = numInAge[i] + sumInAge[i-1];\\n        }\\n        for(int i = 15; i <= 120; i++) {\\n            if (numInAge[i] == 0)   continue;\\n            int c = sumInAge[i] - sumInAge[i/2 + 7];\\n            res += c * numInAge[i] - numInAge[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230757,
                "title": "golang-two-pointers",
                "content": "It is a straightforward solution but took a bit of time to get it right for people with same ages.\\n\\n```go\\nfunc numFriendRequests(ages []int) int {\\n  // Let\\'s sort the ages in ascendig order\\n  sort.Ints(ages)\\n  counts := make(map[int]int)\\n  // Keep track of the first occurrence of each age in the sorted order\\n  // so that we can get the number of people that are below the current age\\n  // and the other same age people that we can send friend requests to.\\n  first := make(map[int]int)\\n  for i := 0; i < len(ages); i++ {\\n    counts[ages[i]]++\\n    if _, ok := first[ages[i]]; !ok {\\n      first[ages[i]] = i\\n    }\\n  }\\n  // We\\'re going to use a two pointers approach. Left is updated to point to the\\n  // person with the minimum age that follows the requirements for the current person.\\n  // Then the number of people the current person can send friend requests to is the\\n  // number of people between pointed by left and current person (excluding)\\n  left := 0\\n  var res int\\n  for right := 0; right < len(ages); right++ {\\n    minAge := float64(ages[right]) * 0.5 + 7.0\\n    for left < right && float64(ages[left]) <= minAge {\\n      left++\\n    }\\n    // left can move forward when we have the same age repeated\\n    res += first[ages[right]] - min(first[ages[right]], left)\\n    if float64(ages[right]) > minAge {\\n      res += counts[ages[right]]-1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```go\\nfunc numFriendRequests(ages []int) int {\\n  // Let\\'s sort the ages in ascendig order\\n  sort.Ints(ages)\\n  counts := make(map[int]int)\\n  // Keep track of the first occurrence of each age in the sorted order\\n  // so that we can get the number of people that are below the current age\\n  // and the other same age people that we can send friend requests to.\\n  first := make(map[int]int)\\n  for i := 0; i < len(ages); i++ {\\n    counts[ages[i]]++\\n    if _, ok := first[ages[i]]; !ok {\\n      first[ages[i]] = i\\n    }\\n  }\\n  // We\\'re going to use a two pointers approach. Left is updated to point to the\\n  // person with the minimum age that follows the requirements for the current person.\\n  // Then the number of people the current person can send friend requests to is the\\n  // number of people between pointed by left and current person (excluding)\\n  left := 0\\n  var res int\\n  for right := 0; right < len(ages); right++ {\\n    minAge := float64(ages[right]) * 0.5 + 7.0\\n    for left < right && float64(ages[left]) <= minAge {\\n      left++\\n    }\\n    // left can move forward when we have the same age repeated\\n    res += first[ages[right]] - min(first[ages[right]], left)\\n    if float64(ages[right]) > minAge {\\n      res += counts[ages[right]]-1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648164,
                "title": "cpp-easy-solution",
                "content": "Any person of age x will send request to every person of age from 0.5x + 7(not including) to x(including). The minus sign is because we are also adding the person itself and acccording to the question the person himself cannot send request to himself. \\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int* temp = new int[122]{0};\\n        for (int i = 0;i <  ages.size();i++)\\n        {\\n            temp[ages[i]]++;\\n        }\\n        \\n        for (int i = 1;i < 122;i++)\\n        {\\n            temp[i] = temp[i] + temp[i - 1];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0;i < ages.size(); i++)\\n        {\\n            if (ages[i] > 14)\\n                res += (temp[ages[i]] - temp[(int)(0.5*ages[i]) + 7]) - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int* temp = new int[122]{0};\\n        for (int i = 0;i <  ages.size();i++)\\n        {\\n            temp[ages[i]]++;\\n        }\\n        \\n        for (int i = 1;i < 122;i++)\\n        {\\n            temp[i] = temp[i] + temp[i - 1];\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0;i < ages.size(); i++)\\n        {\\n            if (ages[i] > 14)\\n                res += (temp[ages[i]] - temp[(int)(0.5*ages[i]) + 7]) - 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505228,
                "title": "python-time-o-max-n-120-space-o-1-prefixsum-and-numbersort-solution",
                "content": "The ages is restricted to be between 1 and 120 so we can make an array with 120 slots to count all persons with a certain age.\\n\\nWe can then compute the prefix sum for every age by passing through the 120-slot array one time and summing up.\\n\\nNow we can compute all the values needed for our result by differencing prefix sums.\\n\\nALSO: The last restriction (age[y] > 100 && age[x] < 100) can be ignored, as it is covered by age[y] > age[x].\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \\n        # make a number sort\\n        sort_ages = [0]*120\\n        \\n        # sort the ages\\n        for age in ages:\\n            sort_ages[age-1] += 1\\n            \\n        # make prefix sum\\n        for age in range(2,121):\\n            sort_ages[age-1] = sort_ages[age-1] + sort_ages[age-2]\\n            \\n        # make a sliding window through the array\\n        result = 0\\n        for age in ages:\\n            \\n            # these ages fall out due to the first restriction\\n            # 14//2 + 7 = 14 -> 14 <= 14 -> falls out\\n            if age <= 14:\\n                continue\\n            \\n            # calculate the index of persons we don\\'t want\\n            dox = age//2 + 7\\n            \\n            # this is the amount of persons younger than ourselves\\n            # but older than age//2 + 7\\n            result += sort_ages[age-2] - sort_ages[dox-1]\\n            \\n            # this is the amount of persons the same age as us but\\n            # without ourselves as we don\\'t send a request to ourself\\n            result += (sort_ages[age-1] - sort_ages[age-2]) - 1\\n        \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \\n        # make a number sort\\n        sort_ages = [0]*120\\n        \\n        # sort the ages\\n        for age in ages:\\n            sort_ages[age-1] += 1\\n            \\n        # make prefix sum\\n        for age in range(2,121):\\n            sort_ages[age-1] = sort_ages[age-1] + sort_ages[age-2]\\n            \\n        # make a sliding window through the array\\n        result = 0\\n        for age in ages:\\n            \\n            # these ages fall out due to the first restriction\\n            # 14//2 + 7 = 14 -> 14 <= 14 -> falls out\\n            if age <= 14:\\n                continue\\n            \\n            # calculate the index of persons we don\\'t want\\n            dox = age//2 + 7\\n            \\n            # this is the amount of persons younger than ourselves\\n            # but older than age//2 + 7\\n            result += sort_ages[age-2] - sort_ages[dox-1]\\n            \\n            # this is the amount of persons the same age as us but\\n            # without ourselves as we don\\'t send a request to ourself\\n            result += (sort_ages[age-1] - sort_ages[age-2]) - 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469842,
                "title": "simple-c-solution-binary-search",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int ans = 0;\\n        // 2 check \\n        // 1. ->  y > x/2 + 7 ;\\n        // 2. ->  y <= x;\\n        for(int i=0;i<ages.size();i++){\\n            int x = ages[i];\\n            int y = x/2 + 7;\\n\\t\\t\\t// condition check\\n            if(y >= x) continue;\\n            auto it = upper_bound(ages.begin() , ages.end() , y) - ages.begin();\\n            auto it2 = upper_bound(ages.begin(), ages.end() , x) - ages.begin();\\n            if(it < i){ans += (i - it);}\\n            if(it2 > i) ans += (it2 - i - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int ans = 0;\\n        // 2 check \\n        // 1. ->  y > x/2 + 7 ;\\n        // 2. ->  y <= x;\\n        for(int i=0;i<ages.size();i++){\\n            int x = ages[i];\\n            int y = x/2 + 7;\\n\\t\\t\\t// condition check\\n            if(y >= x) continue;\\n            auto it = upper_bound(ages.begin() , ages.end() , y) - ages.begin();\\n            auto it2 = upper_bound(ages.begin(), ages.end() , x) - ages.begin();\\n            if(it < i){ans += (i - it);}\\n            if(it2 > i) ans += (it2 - i - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290506,
                "title": "python-counter-simple-iterative-approach-using-ifs",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ct = {}     # counter\\n        for n in ages:\\n            if n not in ct:\\n                ct[n] = ages.count(n)\\n        mreq = 0\\n        for x in ct:\\n            for y in ct:\\n                if y <= (0.5*x) + 7 or y > x or (y > 100 and x < 100):\\n                    continue\\n                if x == y:\\n                    mreq += ct[x] * (ct[x] - 1)     # send reqs except itself\\n                else:\\n                    mreq += ct[x] * ct[y]                \\n        return mreq\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ct = {}     # counter\\n        for n in ages:\\n            if n not in ct:\\n                ct[n] = ages.count(n)\\n        mreq = 0\\n        for x in ct:\\n            for y in ct:\\n                if y <= (0.5*x) + 7 or y > x or (y > 100 and x < 100):\\n                    continue\\n                if x == y:\\n                    mreq += ct[x] * (ct[x] - 1)     # send reqs except itself\\n                else:\\n                    mreq += ct[x] * ct[y]                \\n        return mreq\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257939,
                "title": "simple-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            idx1 = bisect.bisect(ages, a)\\n            idx2 = bisect.bisect(ages, 0.5 * a + 7)\\n            cnt += max(0, idx1 - idx2 - 1) \\n        return cnt\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        cnt = 0\\n        N = len(ages)\\n        ages.sort()\\n        for i in range(N):\\n            a = ages[i]\\n            idx1 = bisect.bisect(ages, a)\\n            idx2 = bisect.bisect(ages, 0.5 * a + 7)\\n            cnt += max(0, idx1 - idx2 - 1) \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166214,
                "title": "well-explained-c-easy-code-don-t-worry-have-fun",
                "content": "# intution:-\\nThese are ***the 3 conditions which must not follow to if we want to send a friend request according to the question.***\\n```\\nage[y] <= 0.5 * age[x] + 7\\nage[y] > age[x]\\nage[y] > 100 && age[x] < 100\\n```\\n\\nThink of something, yes take all the cases diffently what must not occur\\n  after thinking you know we need to do sorting because:-\\n  1. age[y] <= age[x]  so to do so  do sorting \\n  2.     age[y] > 100 than we must find age[x] >= 100  **** hint no.2****\\n  3.     age[x] must be =>     age[x] < 2*(age[y]-7)   so to find this index we need to apply lower_bound function **(so do sorting** \\n\\n---------age[y]-------------------------age[x]-------- -----    sorted array\\n            index = i                                  index = j\\n\\nso all the element which follow age[y] <= age[x]  it will be    j-i-1\\n\\nLet\\'s talk about why we need map here\\nso take example no.1 =>     *[16,16]*     each of them can send friend request to each other. but we have sorted the array so we need their first occurence that\\'s why we are using map.\\n\\n**second condition will be automatically followed no need to worrrrrry because of sorting**\\n\\n**Here is the code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        sort(ages.begin(), ages.end());\\n        \\n        \\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < ages.size(); i++) {\\n            if(!mp.count(ages[i])) mp[ages[i]] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i < ages.size(); i++) {\\n            int x= lower_bound(ages.begin(), ages.end(), 2*(ages[i]-7)) - ages.begin();\\n            if(x <= i) continue;\\n            ans += x-mp[ages[i]]-1; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nT.C. => O(nlonn)   n = ages.size()\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nage[y] <= 0.5 * age[x] + 7\\nage[y] > age[x]\\nage[y] > 100 && age[x] < 100\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        sort(ages.begin(), ages.end());\\n        \\n        \\n        unordered_map<int,int> mp;\\n        for(int i = 0; i < ages.size(); i++) {\\n            if(!mp.count(ages[i])) mp[ages[i]] = i;\\n        }\\n        \\n        \\n        for(int i = 0; i < ages.size(); i++) {\\n            int x= lower_bound(ages.begin(), ages.end(), 2*(ages[i]-7)) - ages.begin();\\n            if(x <= i) continue;\\n            ans += x-mp[ages[i]]-1; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970058,
                "title": "the-question-is-wrong-the-100-years-condition-should-be-reversed",
                "content": "This question comes from Facebook tech screening: https://leetcode.com/discuss/interview-question/469422/facebook-phone-count-all-friend-requests\\n\\nBut note that in there it says \\n> A centaur over 100 years old will not send a friend request to a recipient under 100 years old. But centaurs under 100 years old can friend each other.\\n\\nwhereas in Leetcode, it says\\n> \"A Person x will not send a friend request to a person y if age[y] > 100 && age[x] < 100\". \\n\\nWhich is the opposite. So much so, that Leetcode also says that: \\n> \"A Person x will not send a friend request to a person y if age[y] > age[x]\"\\n\\nwhich is a generalization of the previous one. This makes this solution pass:\\n\\n```\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int invites = 0;\\n        for (int x = ages.length - 1 ; x >= 0 ; x--) {\\n            boolean shouldContinue = true;\\n            for (int y = x-1 ; y >= 0 && shouldContinue ; y--) {\\n                if (ages[y] <= 0.5 * ages[x] + 7) {\\n                    shouldContinue = false;\\n                    break;\\n                }\\n                if (ages[x] == ages[y]) invites++;\\n                invites++;\\n            }\\n        }\\n        return invites;\\n    }\\n```\\n\\neven if it\\'s totally ignoring the 100 years condition.",
                "solutionTags": [],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        int invites = 0;\\n        for (int x = ages.length - 1 ; x >= 0 ; x--) {\\n            boolean shouldContinue = true;\\n            for (int y = x-1 ; y >= 0 && shouldContinue ; y--) {\\n                if (ages[y] <= 0.5 * ages[x] + 7) {\\n                    shouldContinue = false;\\n                    break;\\n                }\\n                if (ages[x] == ages[y]) invites++;\\n                invites++;\\n            }\\n        }\\n        return invites;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958434,
                "title": "c-set-counting-prefix-sum-binary-search-solution-o-n-logn",
                "content": "Runtime: 70 ms, faster than 63.12% of C++ online submissions for Friends Of Appropriate Ages.\\nMemory Usage: 37.7 MB, less than 6.74% of C++ online submissions for Friends Of Appropriate Ages.\\n\\n\\n```\\n1. Sort ages on descending order and track all unique ages\\n2. Count the frequency of ages and do prefix sum on frequency count array on descending order\\n3. Loop through age array in descending order and check if current age > target => age/2 + 7\\n4. Then do binary search on right elements and find last index where age > target and get the count of\\nages until last index using prefix sum array. Total request  => current age count * other valid age count\\n5. In case of same age meet condition age > target request count => current age count * (current age count -1)\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& persons) {\\n        \\n        // count freq of the ages\\n        int freq[121] = {0};\\n        \\n        // track the descending order of age\\n        set<int,greater<int>>uniqueAges;\\n        \\n        int n = persons.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            uniqueAges.insert(persons[i]);\\n            freq[persons[i]]++;\\n        }\\n        \\n        // add unique age from set in descending order and update the prefix sum larger to smaller age\\n        vector<int>ages;\\n        for(auto iter=uniqueAges.begin();iter!=uniqueAges.end();iter++)\\n        {\\n            ages.push_back(*iter);\\n            if(next(iter)!=uniqueAges.end())\\n                freq[*next(iter)] += freq[*iter];\\n        }\\n\\n        // total request count\\n        int count = 0;\\n        \\n        int fcount; // current age freq\\n\\n        int left,right,mid,target,index;\\n        int ageLen = ages.size();\\n        \\n        for(int i=0;i<ageLen;i++)\\n        {\\n            // get current age count from prefix sum \\n            fcount = freq[ages[i]] - (i > 0 ? freq[ages[i-1]] : 0);\\n            \\n            // target age for sending request\\n            target = ages[i]/2 + 7;\\n             \\n            // if current age meets condition then search further\\n            if(ages[i] > target)\\n            {\\n                // send same age request count => n * (n-1) \\n                // as every n person can send request to other n-1 persons \\n                count += (fcount-1) * fcount;\\n                \\n                // check if next age meets condition then do binary search in the right elements\\n                if(i+1 < ageLen && ages[i+1] > target)\\n                {\\n                    left = i+1;\\n                    right = ages.size()-1;\\n                    index = i+1;\\n                    \\n                    // find the last index which meets the condition\\n                    while(left <= right)\\n                    {\\n                        mid = left + (right-left)/2;\\n\\n                        if(ages[mid] > target)left=mid+1,index=mid;\\n                        else right = mid-1,index=mid-1;\\n                    }\\n\\n                    // get freq count K from next of current age to last index age using prefix sum array\\n                    // then request count => fcount * K\\n                    if(index< ageLen && ages[index] > target)\\n                        count+= fcount * (freq[ages[index]] - freq[ages[i]]);                    \\n                }\\n            }    \\n        }\\n        \\n        return count;\\n            \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n1. Sort ages on descending order and track all unique ages\\n2. Count the frequency of ages and do prefix sum on frequency count array on descending order\\n3. Loop through age array in descending order and check if current age > target => age/2 + 7\\n4. Then do binary search on right elements and find last index where age > target and get the count of\\nages until last index using prefix sum array. Total request  => current age count * other valid age count\\n5. In case of same age meet condition age > target request count => current age count * (current age count -1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& persons) {\\n        \\n        // count freq of the ages\\n        int freq[121] = {0};\\n        \\n        // track the descending order of age\\n        set<int,greater<int>>uniqueAges;\\n        \\n        int n = persons.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            uniqueAges.insert(persons[i]);\\n            freq[persons[i]]++;\\n        }\\n        \\n        // add unique age from set in descending order and update the prefix sum larger to smaller age\\n        vector<int>ages;\\n        for(auto iter=uniqueAges.begin();iter!=uniqueAges.end();iter++)\\n        {\\n            ages.push_back(*iter);\\n            if(next(iter)!=uniqueAges.end())\\n                freq[*next(iter)] += freq[*iter];\\n        }\\n\\n        // total request count\\n        int count = 0;\\n        \\n        int fcount; // current age freq\\n\\n        int left,right,mid,target,index;\\n        int ageLen = ages.size();\\n        \\n        for(int i=0;i<ageLen;i++)\\n        {\\n            // get current age count from prefix sum \\n            fcount = freq[ages[i]] - (i > 0 ? freq[ages[i-1]] : 0);\\n            \\n            // target age for sending request\\n            target = ages[i]/2 + 7;\\n             \\n            // if current age meets condition then search further\\n            if(ages[i] > target)\\n            {\\n                // send same age request count => n * (n-1) \\n                // as every n person can send request to other n-1 persons \\n                count += (fcount-1) * fcount;\\n                \\n                // check if next age meets condition then do binary search in the right elements\\n                if(i+1 < ageLen && ages[i+1] > target)\\n                {\\n                    left = i+1;\\n                    right = ages.size()-1;\\n                    index = i+1;\\n                    \\n                    // find the last index which meets the condition\\n                    while(left <= right)\\n                    {\\n                        mid = left + (right-left)/2;\\n\\n                        if(ages[mid] > target)left=mid+1,index=mid;\\n                        else right = mid-1,index=mid-1;\\n                    }\\n\\n                    // get freq count K from next of current age to last index age using prefix sum array\\n                    // then request count => fcount * K\\n                    if(index< ageLen && ages[index] > target)\\n                        count+= fcount * (freq[ages[index]] - freq[ages[i]]);                    \\n                }\\n            }    \\n        }\\n        \\n        return count;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900650,
                "title": "a-c-solution-using-binary-search",
                "content": "First, we need to analyze these rules given from the problem. If any condition happens, x **won\\'t** send the friend request to y.\\n1. `age[y] <= 0.5 * age[x] + 7`\\n2. `age[y] > age[x]`\\n3. `age[y] > 100 && age[x] < 100`\\n\\nRule 2 is easy to understand. From this rule, we know that x may send the request to y if `y <= x`. And from rule 1, we know that x may send the request to y if `y > 0.5x + 7`. Based on rule 1 and 2, we can get the range of ages of y which fits x\\'s favor: `(0.5x + 7, x]`. \\n\\nNow, let\\'s deal with rule 3. And you will see that rule 3 never happens because in rule 3, y is greater than x which is out of the range of x\\' favor. So, we just need to focus on `0.5x + 7 < y <= x`.\\n\\nTime complexity : sorting is O(nlog(n)). Per-user checking is O(n). Binary search is O(log(n)). Overall will be O(nlog(n)).\\nSpace complexity: O(1)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        int l, u;\\n        \\n\\t\\t// Sorting ages, and then we can do binary search.\\n        sort(ages.begin(), ages.end());\\n        \\n\\t\\t// Find the range of each user.\\n        for (int i = 0; i < ages.size(); ++i) {\\n            \\n\\t\\t\\t// 0.5x + 7 may be greater than x. We can skip this loop if it happens.\\n            if (0.5 * ages[i] + 7 >= ages[i]) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Search the smallest y in the range (0.5x + 7, x].\\n\\t\\t\\t// A trick is that passing right hand side to limit the searching range\\n\\t\\t\\t// which can improve its speed a little.\\n            l = searchLowerBound(ages, 0.5 * ages[i] + 7, i);\\n            \\n\\t\\t\\t// Search the largest y. Because we need to consider the duplicated values of x.\\n\\t\\t\\t// The index of largest y may be greater than i.\\n\\t\\t\\t// Minusing 1 at the end is to exclude self.\\n            u = upper_bound(\\n                ages.begin() + i, ages.end(), ages[i]) - ages.begin() - 1;\\n            \\n            ans += u - l;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n\\t// This function searchs the index of the smallest value greater than `val`\\n    int searchLowerBound(vector<int>& ages, int val, int r) {\\n        int l = 0;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            \\n            if (ages[m] <= val) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ans = 0;\\n        int l, u;\\n        \\n\\t\\t// Sorting ages, and then we can do binary search.\\n        sort(ages.begin(), ages.end());\\n        \\n\\t\\t// Find the range of each user.\\n        for (int i = 0; i < ages.size(); ++i) {\\n            \\n\\t\\t\\t// 0.5x + 7 may be greater than x. We can skip this loop if it happens.\\n            if (0.5 * ages[i] + 7 >= ages[i]) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Search the smallest y in the range (0.5x + 7, x].\\n\\t\\t\\t// A trick is that passing right hand side to limit the searching range\\n\\t\\t\\t// which can improve its speed a little.\\n            l = searchLowerBound(ages, 0.5 * ages[i] + 7, i);\\n            \\n\\t\\t\\t// Search the largest y. Because we need to consider the duplicated values of x.\\n\\t\\t\\t// The index of largest y may be greater than i.\\n\\t\\t\\t// Minusing 1 at the end is to exclude self.\\n            u = upper_bound(\\n                ages.begin() + i, ages.end(), ages[i]) - ages.begin() - 1;\\n            \\n            ans += u - l;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n\\t// This function searchs the index of the smallest value greater than `val`\\n    int searchLowerBound(vector<int>& ages, int val, int r) {\\n        int l = 0;\\n        \\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            \\n            if (ages[m] <= val) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876627,
                "title": "python-o-n-faster-99-5-cumulative-sum-and-age-buckets",
                "content": "I have seen a few solutions that do a sum in the main loop over the age buckets. To avoid this, we can precalculate the cumulative sums and use them instead to make the main logic loop highly efficient.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # in a sense: \"bucket sort\"\\n        ageMax = max(ages)\\n        ageBuckets = [0]*(ageMax+1)\\n        for age in ages:\\n            ageBuckets[age] += 1\\n        \\n        # build cumulative sum\\n        ageCum = [ageBuckets[0]]*(ageMax+1)\\n        for i in range(1,len(ageBuckets)):\\n            ageCum[i] = ageCum[i-1] + ageBuckets[i]\\n            \\n        # main logic\\n        ans = 0\\n        for age in range(1,len(ageBuckets)):\\n            if ageBuckets[age]:\\n                k = int(age * 0.5 + 7)\\n                if k < age:\\n                    ans += ageBuckets[age] * (ageCum[age-1] - ageCum[k])\\n                if age > k:\\n                    ans += ageBuckets[age]*(ageBuckets[age]-1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # in a sense: \"bucket sort\"\\n        ageMax = max(ages)\\n        ageBuckets = [0]*(ageMax+1)\\n        for age in ages:\\n            ageBuckets[age] += 1\\n        \\n        # build cumulative sum\\n        ageCum = [ageBuckets[0]]*(ageMax+1)\\n        for i in range(1,len(ageBuckets)):\\n            ageCum[i] = ageCum[i-1] + ageBuckets[i]\\n            \\n        # main logic\\n        ans = 0\\n        for age in range(1,len(ageBuckets)):\\n            if ageBuckets[age]:\\n                k = int(age * 0.5 + 7)\\n                if k < age:\\n                    ans += ageBuckets[age] * (ageCum[age-1] - ageCum[k])\\n                if age > k:\\n                    ans += ageBuckets[age]*(ageBuckets[age]-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853310,
                "title": "python-o-nlogn-bisect",
                "content": "There are cleaner implementations that include all ages when bisecting. This takes a slightly different approach and instead dedupes all ages and keeps counts.\\n```\\nimport bisect\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        new_ages = []\\n        counts = []\\n        for a in ages:\\n            if new_ages and new_ages[-1] == a:\\n                counts[-1] += 1\\n            else:\\n                new_ages.append(a)\\n                counts.append(1)\\n        prefix = [0]\\n        for c in counts:\\n            prefix.append(prefix[-1]+c)\\n        ages = new_ages\\n        total_requests = 0\\n        for i, age in enumerate(ages):\\n            min_age = age / 2 + 7\\n            j = bisect.bisect_right(ages, min_age)\\n            # we can\\'t friend someone older than us\\n            if j > i:\\n                continue\\n            # get number of people younger than `age` multiplied by number of people with `age`\\n            total_requests += (prefix[i]-prefix[j])*counts[i]\\n        # for any ages with more than 1 person, sum all possible requests n*(n-1)\\n        # but make sure that the age requirement is met (which is really only for young kids)\\n        # 6 < (6/2+7=10)\\n        # 16 > (16/2+7=15)\\n        total_requests += sum(n*(n-1) for a, n in zip(ages, counts) if a > (a / 2 + 7))\\n        return total_requests\\n```\\n\\nHere\\'s a cleaner solution:\\n```\\nimport bisect\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        counts = Counter(ages)\\n        total = 0\\n        for age in counts:\\n            min_age = age / 2 + 7\\n            left = bisect.bisect_right(ages, min_age)\\n            right = bisect.bisect_right(ages, age)\\n            total += max(right - left - 1, 0)*counts[age]\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        new_ages = []\\n        counts = []\\n        for a in ages:\\n            if new_ages and new_ages[-1] == a:\\n                counts[-1] += 1\\n            else:\\n                new_ages.append(a)\\n                counts.append(1)\\n        prefix = [0]\\n        for c in counts:\\n            prefix.append(prefix[-1]+c)\\n        ages = new_ages\\n        total_requests = 0\\n        for i, age in enumerate(ages):\\n            min_age = age / 2 + 7\\n            j = bisect.bisect_right(ages, min_age)\\n            # we can\\'t friend someone older than us\\n            if j > i:\\n                continue\\n            # get number of people younger than `age` multiplied by number of people with `age`\\n            total_requests += (prefix[i]-prefix[j])*counts[i]\\n        # for any ages with more than 1 person, sum all possible requests n*(n-1)\\n        # but make sure that the age requirement is met (which is really only for young kids)\\n        # 6 < (6/2+7=10)\\n        # 16 > (16/2+7=15)\\n        total_requests += sum(n*(n-1) for a, n in zip(ages, counts) if a > (a / 2 + 7))\\n        return total_requests\\n```\n```\\nimport bisect\\nfrom collections import Counter\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        counts = Counter(ages)\\n        total = 0\\n        for age in counts:\\n            min_age = age / 2 + 7\\n            left = bisect.bisect_right(ages, min_age)\\n            right = bisect.bisect_right(ages, age)\\n            total += max(right - left - 1, 0)*counts[age]\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847580,
                "title": "python-3-two-solutions",
                "content": "sorting + deque solution\\nO(nlogn) time\\nO(n) space\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        deque = collections.deque()\\n        ages.sort(reverse=True)\\n        res = 0\\n        curSame = 0\\n        \\n        for i, age in enumerate(ages):\\n            if i and age >= 15 and age == ages[i-1]:\\n                curSame += 1\\n            else:\\n                curSame = 0\\n\\n            while deque and age <= deque[0]:\\n                deque.popleft()\\n                \\n            res += len(deque) + curSame\\n            deque.append(0.5*age + 7)\\n        \\n        return res\\n```\\nprefix sum solution\\nO(n) time\\nO(1) space\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        prefixSum = collections.Counter(ages)\\n        for i in range(2, 121):\\n            prefixSum[i] += prefixSum[i-1]\\n        \\n        res = 0\\n        for age in ages:\\n            left = int(0.5*age + 7)\\n            if age > left:\\n                res += prefixSum[age] - prefixSum[left] - 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        deque = collections.deque()\\n        ages.sort(reverse=True)\\n        res = 0\\n        curSame = 0\\n        \\n        for i, age in enumerate(ages):\\n            if i and age >= 15 and age == ages[i-1]:\\n                curSame += 1\\n            else:\\n                curSame = 0\\n\\n            while deque and age <= deque[0]:\\n                deque.popleft()\\n                \\n            res += len(deque) + curSame\\n            deque.append(0.5*age + 7)\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        prefixSum = collections.Counter(ages)\\n        for i in range(2, 121):\\n            prefixSum[i] += prefixSum[i-1]\\n        \\n        res = 0\\n        for age in ages:\\n            left = int(0.5*age + 7)\\n            if age > left:\\n                res += prefixSum[age] - prefixSum[left] - 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831668,
                "title": "java-solution-with-prefixsum-o-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        int[] prefixSum = new int[121];\\n        for (int age : ages) {\\n            prefixSum[age]++;\\n        }\\n        for (int i = 1; i < prefixSum.length; i++) {\\n            prefixSum[i] += prefixSum[i-1];\\n        }\\n        for (int age : ages) {\\n            int left = (int)(0.5 * age) + 7;\\n            if (left < age) {\\n                ans += prefixSum[age] - prefixSum[left] - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nThe last for loop could be optimized.\\n```\\nfor (int age = 1; age < 121; age++) {\\n\\tint left = (int)(0.5 * age) + 7;\\n\\tif (left < age) {\\n\\t\\tans += (prefixSum[age] - prefixSum[left] - 1) * (prefixSum[age] - prefixSum[age - 1]);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        int[] prefixSum = new int[121];\\n        for (int age : ages) {\\n            prefixSum[age]++;\\n        }\\n        for (int i = 1; i < prefixSum.length; i++) {\\n            prefixSum[i] += prefixSum[i-1];\\n        }\\n        for (int age : ages) {\\n            int left = (int)(0.5 * age) + 7;\\n            if (left < age) {\\n                ans += prefixSum[age] - prefixSum[left] - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nfor (int age = 1; age < 121; age++) {\\n\\tint left = (int)(0.5 * age) + 7;\\n\\tif (left < age) {\\n\\t\\tans += (prefixSum[age] - prefixSum[left] - 1) * (prefixSum[age] - prefixSum[age - 1]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734617,
                "title": "c-short",
                "content": "Using @votrubac solution\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121,0);\\n        for(int x : ages) {\\n            count[x]++;\\n        }\\n        int ans = 0;\\n        for(int i = 15;i<121;i++) {\\n            for(int j = 0.5*i + 8;j<=i;j++) {\\n                ans+= count[j] * (count[i]- (i==j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121,0);\\n        for(int x : ages) {\\n            count[x]++;\\n        }\\n        int ans = 0;\\n        for(int i = 15;i<121;i++) {\\n            for(int j = 0.5*i + 8;j<=i;j++) {\\n                ans+= count[j] * (count[i]- (i==j));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698046,
                "title": "python-two-pointers-after-sorting",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        if not ages:\\n            return 0\\n        \\n        ages.sort()\\n        \\n        count = 0\\n        left, right = 0, 0\\n        for age in ages:\\n            while left < len(ages) and ages[left] <= 0.5 * age + 7:\\n                left += 1\\n            while right < len(ages) and ages[right] <= age:\\n                right += 1\\n            if right - 1 >= left:\\n                count += right - left - 1\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        if not ages:\\n            return 0\\n        \\n        ages.sort()\\n        \\n        count = 0\\n        left, right = 0, 0\\n        for age in ages:\\n            while left < len(ages) and ages[left] <= 0.5 * age + 7:\\n                left += 1\\n            while right < len(ages) and ages[right] <= age:\\n                right += 1\\n            if right - 1 >= left:\\n                count += right - left - 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690666,
                "title": "ruby-o-n-and-o-1-space",
                "content": "The difficult part of this problem is avoiding the easy TLE. The first solution bellow results in it:\\n\\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    ages.each.with_index do |age1, idx1|\\n        ages.each.with_index do |age2, idx2|\\n            next if idx1 == idx2\\n            count += 1 if possible_friend(age1, age2)\\n        end\\n    end\\n    count\\nend\\n\\ndef possible_friend(x, y)\\n    !((y <= 0.5*x + 7) || (y > x) || (y > 100 && x < 100))\\nend\\n```\\n\\nThere are some improvements that may be performed:\\n- as only 0 <= age <= 120 is valid, every number doesn\\'t need to be verified against every other element in the array. Counting how many occurrences of every number happens and then verifying it against every other number turns the total solution from O(n^2) into O(n + 121 * 121) = O(n). Space is O(121) = O(1);\\n\\n- instead of comparing every number with every other number, simply add to the total number of friend requests the product of count(age X) * count(age Y) for (age Y) that is valid. If age Y == age X, substract age X from the total number of friend requests. That is still a O(n) for time and O(1) for space,;\\n\\nBear in mind that the restriction age[y] > 100 && age[x] < 100 does not mean anything, as it is already taken care of by age[y] > age[x]. The other restriction, age[x] * 0.5 + 7 >= age[y] results in age[x] / 2 + 8 < age[y] for a friend request to happen.\\n\\nThe final solution is:\\n\\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    age_count = Array.new(121) { 0 }\\n    ages.each { |age| age_count[age] += 1 }\\n    age_count.each.with_index do |curr_count, age|\\n        intervals = [age / 2 + 8, age]\\n        for i in intervals[0]..intervals[1]\\n            count += (age_count[i] * curr_count)\\n            count -= curr_count if i == age\\n        end\\n    end\\n    count\\nend\\n```\\n\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    ages.each.with_index do |age1, idx1|\\n        ages.each.with_index do |age2, idx2|\\n            next if idx1 == idx2\\n            count += 1 if possible_friend(age1, age2)\\n        end\\n    end\\n    count\\nend\\n\\ndef possible_friend(x, y)\\n    !((y <= 0.5*x + 7) || (y > x) || (y > 100 && x < 100))\\nend\\n```\n```ruby\\n# @param {Integer[]} ages\\n# @return {Integer}\\ndef num_friend_requests(ages)\\n    count = 0\\n    age_count = Array.new(121) { 0 }\\n    ages.each { |age| age_count[age] += 1 }\\n    age_count.each.with_index do |curr_count, age|\\n        intervals = [age / 2 + 8, age]\\n        for i in intervals[0]..intervals[1]\\n            count += (age_count[i] * curr_count)\\n            count -= curr_count if i == age\\n        end\\n    end\\n    count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1686736,
                "title": "python-o-n-solution-beats-90-of-the-solution",
                "content": "Might be a bit redundant code, but I came up with this solution.\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646281,
                "title": "python-easy-solution-best-approach",
                "content": "**Condition 1:**  If your age is different from the other age\\n*E.g.* 16, 15, 15 then 15 ->16 and 15 ->16\\nie 2*1 which is **xCount** * **yCount**.\\n\\n**Condition 2:** If your age is the same.\\n*E.g.* 16, 16 then 16 <-> 16 *i.e.* 2 which is **xCount** * **(xCount-1)** or **yCount** * **(yCount-1)**\\n\\n\\tclass Solution:\\n\\t\\tdef numFriendRequests(self, ages: List[int]) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tages = Counter(ages)\\n\\t\\t\\tfor x in ages:\\n\\t\\t\\t\\txCount = ages[x]\\n\\t\\t\\t\\tfor y in ages:\\n\\t\\t\\t\\t\\tif not (y <= 0.5*x+7 or y > x):\\n\\t\\t\\t\\t\\t\\tyCount = ages[y]\\n\\t\\t\\t\\t\\t\\tif x != y:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*yCount\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*(xCount-1)\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "**Condition 1:**  If your age is different from the other age\\n*E.g.* 16, 15, 15 then 15 ->16 and 15 ->16\\nie 2*1 which is **xCount** * **yCount**.\\n\\n**Condition 2:** If your age is the same.\\n*E.g.* 16, 16 then 16 <-> 16 *i.e.* 2 which is **xCount** * **(xCount-1)** or **yCount** * **(yCount-1)**\\n\\n\\tclass Solution:\\n\\t\\tdef numFriendRequests(self, ages: List[int]) -> int:\\n\\t\\t\\tcount = 0\\n\\t\\t\\tages = Counter(ages)\\n\\t\\t\\tfor x in ages:\\n\\t\\t\\t\\txCount = ages[x]\\n\\t\\t\\t\\tfor y in ages:\\n\\t\\t\\t\\t\\tif not (y <= 0.5*x+7 or y > x):\\n\\t\\t\\t\\t\\t\\tyCount = ages[y]\\n\\t\\t\\t\\t\\t\\tif x != y:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*yCount\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tcount += xCount*(xCount-1)\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 1560590,
                "title": "simple-to-understand-using-map-binary-search-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nIn this solution, we sort the ages and use a map that keeps track of the ages, and the total friend request count that age can recieve.\\n\\nBinary search is used to get the age range in the array that satisfies the friend request conditions.\\n\\n```\\npublic class Solution {\\n    public int NumFriendRequests(int[] ages) {\\n        var result = 0;\\n        \\n        // Sort ages\\n        Array.Sort(ages);\\n        \\n        // Keep track of results calculated\\n        var seen = new Dictionary<int, int>();\\n        \\n        // Iterate array backwards\\n        for (int index = ages.Length - 1; index >= 0; --index) { \\n            // Check if we already calculated result for age\\n            if (!seen.ContainsKey(ages[index])) {\\n                // Binary search\\n                var lo = 0;\\n                var hi = index;\\n                while (lo < hi) {\\n                    var mid = lo + (hi - lo) / 2;\\n\\n                    // Check if friends can be made in this range\\n                    if (!CanFriend(ages[index], ages[mid])) {\\n                        lo = mid + 1;\\n                    } else {\\n                        hi = mid;\\n                    }\\n                }\\n                // Get distance between index and hi. This is the friend count for the age\\n                seen[ages[index]] = index - hi; \\n            }\\n            // Update result count\\n            result += seen[ages[index]];\\n        }        \\n        return result;\\n    }\\n    \\n    private bool CanFriend(int x, int y) {\\n        return !((y > x) || (y > 100 && x < 100) || (y <= 0.5 * x + 7));\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumFriendRequests(int[] ages) {\\n        var result = 0;\\n        \\n        // Sort ages\\n        Array.Sort(ages);\\n        \\n        // Keep track of results calculated\\n        var seen = new Dictionary<int, int>();\\n        \\n        // Iterate array backwards\\n        for (int index = ages.Length - 1; index >= 0; --index) { \\n            // Check if we already calculated result for age\\n            if (!seen.ContainsKey(ages[index])) {\\n                // Binary search\\n                var lo = 0;\\n                var hi = index;\\n                while (lo < hi) {\\n                    var mid = lo + (hi - lo) / 2;\\n\\n                    // Check if friends can be made in this range\\n                    if (!CanFriend(ages[index], ages[mid])) {\\n                        lo = mid + 1;\\n                    } else {\\n                        hi = mid;\\n                    }\\n                }\\n                // Get distance between index and hi. This is the friend count for the age\\n                seen[ages[index]] = index - hi; \\n            }\\n            // Update result count\\n            result += seen[ages[index]];\\n        }        \\n        return result;\\n    }\\n    \\n    private bool CanFriend(int x, int y) {\\n        return !((y > x) || (y > 100 && x < 100) || (y <= 0.5 * x + 7));\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223329,
                "title": "easy-c-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int a,int b) {\\n         float A=a;\\n         float B=b;\\n         if(B<=(0.5*A)+7 || B>A || (B>100 && A<100)) return false;\\n         return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++) mp[ages[i]]++;\\n        for(pair<int,int> p : mp) {\\n            for(pair<int,int> q : mp) {\\n                if(isvalid(p.first,q.first)) {\\n                   if(p.first==q.first) ans+=p.second*(p.second-1);\\n                   else ans+=p.second*q.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int a,int b) {\\n         float A=a;\\n         float B=b;\\n         if(B<=(0.5*A)+7 || B>A || (B>100 && A<100)) return false;\\n         return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> mp;\\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++) mp[ages[i]]++;\\n        for(pair<int,int> p : mp) {\\n            for(pair<int,int> q : mp) {\\n                if(isvalid(p.first,q.first)) {\\n                   if(p.first==q.first) ans+=p.second*(p.second-1);\\n                   else ans+=p.second*q.second;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169867,
                "title": "1ms-simple-java-solution-loop-with-window-o-1-space-o-n-time",
                "content": "Java 1ms, beats 100% time. Simple moving window loop over 120 ages starting age 15 with lower range as age/2+7. Linear time `O(n)` and constant space `O(1)` complexity.\\n\\n```java\\n\\n/**\\n* A will friend request B iff\\n* age: A/2+7 < B < A but for some  A /2+7 >=A -> A/2<=7 A<=14\\n* So anyone under 15 cannot friend request\\n* Solution: store people in age buckets and loop over it with window starting form age 15\\n**/\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleByAge = new int[121];\\n        for(int i = 0; i < ages.length; i++)\\n            peopleByAge[ages[i]]++;\\n        int result = 0, peopleCount = 0, lowerAgeRange = 15;\\n        for(int i = 15; i <= 120; i++) {\\n            if (i % 2 == 0)\\n                peopleCount -= peopleByAge[lowerAgeRange++];\\n            peopleCount += peopleByAge[i];\\n            result += peopleByAge[i] * (peopleCount-1);  // we can all befriend each other. -1 is to exclude ourselves\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n\\n/**\\n* A will friend request B iff\\n* age: A/2+7 < B < A but for some  A /2+7 >=A -> A/2<=7 A<=14\\n* So anyone under 15 cannot friend request\\n* Solution: store people in age buckets and loop over it with window starting form age 15\\n**/\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleByAge = new int[121];\\n        for(int i = 0; i < ages.length; i++)\\n            peopleByAge[ages[i]]++;\\n        int result = 0, peopleCount = 0, lowerAgeRange = 15;\\n        for(int i = 15; i <= 120; i++) {\\n            if (i % 2 == 0)\\n                peopleCount -= peopleByAge[lowerAgeRange++];\\n            peopleCount += peopleByAge[i];\\n            result += peopleByAge[i] * (peopleCount-1);  // we can all befriend each other. -1 is to exclude ourselves\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100755,
                "title": "greedy-beats-90-time-and-space",
                "content": "O(N ^ 2) time, O(N) space\\n\\nSort and Filter out lower ages from earlier iterations\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        res = 0\\n        ages = sorted(Counter(ages).items())\\n\\n        left = 0\\n        for i, (ownAge, count) in enumerate(ages):\\n            if count > 1 and ownAge > 0.5 * ownAge + 7: res += count * (count - 1)\\n\\n            for j in range(left, i):\\n                if ages[j][0] > 0.5 * ownAge + 7: res += ages[j][1] * count\\n                else: left += 1\\n                    \\n        return res",
                "solutionTags": [],
                "code": "O(N ^ 2) time, O(N) space\\n\\nSort and Filter out lower ages from earlier iterations\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        res = 0\\n        ages = sorted(Counter(ages).items())\\n\\n        left = 0\\n        for i, (ownAge, count) in enumerate(ages):\\n            if count > 1 and ownAge > 0.5 * ownAge + 7: res += count * (count - 1)\\n\\n            for j in range(left, i):\\n                if ages[j][0] > 0.5 * ownAge + 7: res += ages[j][1] * count\\n                else: left += 1\\n                    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1067229,
                "title": "javascript-easy-and-simple-solution",
                "content": "```javascript\\nvar numFriendRequests = function(ages) {\\n    const range = [];\\n    const freq = {}\\n    let count = 0;\\n    \\n    for(let n of ages) {\\n        freq[n] = (freq[n] || 0) + 1;\\n        const min = Math.floor(n/2 + 8);\\n        range.push([min, n]);\\n    }\\n    \\n    for(let i = 0; i < range.length; i++) {\\n        const [min, max] = range[i];\\n        \\n        for(let j = min; j <= max; j++) {\\n            if(!freq[j]) continue;\\n            count += freq[j];\\n            if(j === max) count--;\\n        }\\n    }\\n    return count;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar numFriendRequests = function(ages) {\\n    const range = [];\\n    const freq = {}\\n    let count = 0;\\n    \\n    for(let n of ages) {\\n        freq[n] = (freq[n] || 0) + 1;\\n        const min = Math.floor(n/2 + 8);\\n        range.push([min, n]);\\n    }\\n    \\n    for(let i = 0; i < range.length; i++) {\\n        const [min, max] = range[i];\\n        \\n        for(let j = min; j <= max; j++) {\\n            if(!freq[j]) continue;\\n            count += freq[j];\\n            if(j === max) count--;\\n        }\\n    }\\n    return count;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1062882,
                "title": "simple-o-n-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        ages = ages == null ? new int[0] : ages;\\n        \\n        int[] count = new int[121];\\n        int requests = 0;\\n        \\n        for (int age : ages)\\n            count[age]++;\\n        \\n        for (int a = 1; a <= 120; a++) {\\n            for (int b = 1; b <= 120; b++) {\\n                if (count[a] + count[b] <= 1 || aCannotRequestB(a, b))\\n                    continue; //not enough people or any of the rule violates\\n                \\n                int numAgesOfA = count[a], numAgesOfB = count[b];\\n                if (a == b) //special case if both a and b are pointing to the same age slot\\n                    numAgesOfB--;\\n                \\n                requests += numAgesOfA * numAgesOfB;\\n            }\\n        }\\n        \\n        return requests;\\n    }\\n    \\n    private boolean aCannotRequestB(int a, int b) {\\n        return b <= (a / 2 + 7) || b > a || b > 100 && a < 100;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        ages = ages == null ? new int[0] : ages;\\n        \\n        int[] count = new int[121];\\n        int requests = 0;\\n        \\n        for (int age : ages)\\n            count[age]++;\\n        \\n        for (int a = 1; a <= 120; a++) {\\n            for (int b = 1; b <= 120; b++) {\\n                if (count[a] + count[b] <= 1 || aCannotRequestB(a, b))\\n                    continue; //not enough people or any of the rule violates\\n                \\n                int numAgesOfA = count[a], numAgesOfB = count[b];\\n                if (a == b) //special case if both a and b are pointing to the same age slot\\n                    numAgesOfB--;\\n                \\n                requests += numAgesOfA * numAgesOfB;\\n            }\\n        }\\n        \\n        return requests;\\n    }\\n    \\n    private boolean aCannotRequestB(int a, int b) {\\n        return b <= (a / 2 + 7) || b > a || b > 100 && a < 100;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958504,
                "title": "5-ms-concise-java",
                "content": "```\\nclass Solution {\\n    /*\\n    Valid conditions for A to friend req. B\\n    0.5 * age[A] + 7 < age[B] <= age[A]\\n    \\n    1 <= ages.length <= 20000.\\n    1 <= ages[i] <= 120.\\n    */\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int ans = 0;\\n        for(int age : ages){\\n            count[age]++;\\n        }\\n        // i -> age[A] ------ j -> age[B]\\n        for(int i=0; i<=120; i++){\\n            for(int j=0; j<=120; j++){\\n                if((0.5 * i + 7) < j && j <= i){\\n                    ans += count[i]*count[j];\\n                    if(i == j) {\\n                        ans -= count[i];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n    Valid conditions for A to friend req. B\\n    0.5 * age[A] + 7 < age[B] <= age[A]\\n    \\n    1 <= ages.length <= 20000.\\n    1 <= ages[i] <= 120.\\n    */\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int ans = 0;\\n        for(int age : ages){\\n            count[age]++;\\n        }\\n        // i -> age[A] ------ j -> age[B]\\n        for(int i=0; i<=120; i++){\\n            for(int j=0; j<=120; j++){\\n                if((0.5 * i + 7) < j && j <= i){\\n                    ans += count[i]*count[j];\\n                    if(i == j) {\\n                        ans -= count[i];\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934783,
                "title": "python3-two-approaches",
                "content": "**Approach 1 - sliding window**\\nSort `ages`. For each age, find the range of ages to make request based on \"no friend\" rule, i.e. given `x` requests friends whose ages fall in range `(0.5*x+7, x]`.  The range can be found via sliding window. \\n\\nImplementation (384ms, 34.85%)\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = lo = hi = 0 \\n        for x in ages: \\n            while hi < len(ages) and x == ages[hi]: hi += 1\\n            while lo+1 < hi and ages[lo] <= x//2 + 7: lo += 1\\n            ans += hi - lo - 1\\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(NlogN)`\\nSpace complexity `O(1)`\\n\\nApproach 2 - frequency table \\nAlthough the length of `ages` can go all the way up to `20000` there are only up to `120` distinct values. So we leverage on frequency table. \\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        freq = {}\\n        for x in ages: freq[x] = 1 + freq.get(x, 0)\\n        \\n        ans = 0 \\n        for x in freq: \\n            for y in freq: \\n                if 0.5*x + 7 < y <= x: \\n                    ans += freq[x] * freq[y]\\n                    if x == y: ans -= freq[x]\\n        return ans \\n```\\n\\nAnalysis \\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = lo = hi = 0 \\n        for x in ages: \\n            while hi < len(ages) and x == ages[hi]: hi += 1\\n            while lo+1 < hi and ages[lo] <= x//2 + 7: lo += 1\\n            ans += hi - lo - 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        freq = {}\\n        for x in ages: freq[x] = 1 + freq.get(x, 0)\\n        \\n        ans = 0 \\n        for x in freq: \\n            for y in freq: \\n                if 0.5*x + 7 < y <= x: \\n                    ans += freq[x] * freq[y]\\n                    if x == y: ans -= freq[x]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 857963,
                "title": "java-solution-using-binary-search",
                "content": "We can use binary search to find the range of ages (age[A]*0.5 +7) where friend requests can be sent.\\n\\n\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        Arrays.sort(ages);\\n        for(int i = 0; i < ages.length; i++) {\\n            int age = ages[i];\\n            //upper can be i but in same ages upper change\\n            //so need to find upper index also\\n            int upper = findIndex(ages, age);\\n            //lower index is from where all the ages comes in\\n            //range age[A]*.5 + 7 \\n            int lower = findIndex(ages, ((age/2)+7));\\n            ans += Math.max(upper-lower-1, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    //binary search\\n    public static int findIndex(int[] ages, int target) {\\n        int start = 0;\\n        int end = ages.length-1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(ages[mid] <= target) start = mid + 1;\\n            else end = mid-1;\\n        }\\n        return start;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int ans = 0;\\n        Arrays.sort(ages);\\n        for(int i = 0; i < ages.length; i++) {\\n            int age = ages[i];\\n            //upper can be i but in same ages upper change\\n            //so need to find upper index also\\n            int upper = findIndex(ages, age);\\n            //lower index is from where all the ages comes in\\n            //range age[A]*.5 + 7 \\n            int lower = findIndex(ages, ((age/2)+7));\\n            ans += Math.max(upper-lower-1, 0);\\n        }\\n        return ans;\\n    }\\n    \\n    //binary search\\n    public static int findIndex(int[] ages, int target) {\\n        int start = 0;\\n        int end = ages.length-1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(ages[mid] <= target) start = mid + 1;\\n            else end = mid-1;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848515,
                "title": "java-1ms-solution-beats-100-time-o-n",
                "content": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int[] ageSum = new int[121];\\n        for (int age : ages)\\n            count[age]++;\\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 15; i <= 120; i++) {\\n            sum += count[i];\\n            ageSum[i] = sum;\\n            if (count[i] > 0)\\n                ans += ((ageSum[i] - ageSum[i / 2 + 7] - 1) * count[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] count = new int[121];\\n        int[] ageSum = new int[121];\\n        for (int age : ages)\\n            count[age]++;\\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 15; i <= 120; i++) {\\n            sum += count[i];\\n            ageSum[i] = sum;\\n            if (count[i] > 0)\\n                ans += ((ageSum[i] - ageSum[i / 2 + 7] - 1) * count[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815506,
                "title": "javascript-solution-o-1-space-o-n-time",
                "content": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var nums = new Array(121).fill(0)\\n\\t//O(n) loop here\\n    for(let i of ages){ nums[i]++ }\\n        var ans = 0\\n    for(let i = 0 ;i <= 120; i++){\\n        let countA = nums[i]\\n        for(let j = 0; j <= 120; j++){\\n            let countB = nums[j]\\n            if((i * 0.5 + 7 >= j) || (i < j)) continue\\n            ans += countA * countB\\n            if(i === j) ans -= countA\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var nums = new Array(121).fill(0)\\n\\t//O(n) loop here\\n    for(let i of ages){ nums[i]++ }\\n        var ans = 0\\n    for(let i = 0 ;i <= 120; i++){\\n        let countA = nums[i]\\n        for(let j = 0; j <= 120; j++){\\n            let countB = nums[j]\\n            if((i * 0.5 + 7 >= j) || (i < j)) continue\\n            ans += countA * countB\\n            if(i === j) ans -= countA\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738407,
                "title": "javascript-two-pointer",
                "content": "```\\nconst numFriendRequests = (ages) => {\\n    ages.sort((a, b) => a - b);\\n    let cnt = 0;\\n    let i = 0;\\n    while (i < ages.length) {\\n        let j = i + 1;\\n        let A = ages[i];\\n        while (j < ages.length) {\\n            let B = ages[j];\\n            if ((B > 0.5 * A + 7) && (B <= 100 || A >= 100) && (B == A)) {\\n                cnt++;\\n            }\\n            if ((A > 0.5 * B + 7) && (A <= 100 || B >= 100)) {\\n                cnt++;\\n            }\\n            j++;\\n        }\\n        i++;\\n    }\\n    return cnt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numFriendRequests = (ages) => {\\n    ages.sort((a, b) => a - b);\\n    let cnt = 0;\\n    let i = 0;\\n    while (i < ages.length) {\\n        let j = i + 1;\\n        let A = ages[i];\\n        while (j < ages.length) {\\n            let B = ages[j];\\n            if ((B > 0.5 * A + 7) && (B <= 100 || A >= 100) && (B == A)) {\\n                cnt++;\\n            }\\n            if ((A > 0.5 * B + 7) && (A <= 100 || B >= 100)) {\\n                cnt++;\\n            }\\n            j++;\\n        }\\n        i++;\\n    }\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 658569,
                "title": "the-easiest-way",
                "content": "```\\n/*\\u5B98\\u89E3\\u6CD5\\n *2020\\u5E745\\u670829\\u65E5 20:01\\n *\\u6267\\u884C\\u7528\\u65F6 :7 ms, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8653.67%\\u7684\\u7528\\u6237\\n *\\u5185\\u5B58\\u6D88\\u8017 :42.3 MB, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8611.11%\\u7684\\u7528\\u6237\\n *\\u4F5C\\u8005@v7fgg\\n */\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int nianling[]=new int[121];\\n        int ans=0;\\n        for(int a:ages){\\n            nianling[a]++;\\n        }\\n        for(int i=1;i<121;i++){\\n            for(int j=1;j<121;j++){\\n                int a=nianling[i];\\n                int b=nianling[j];\\n                if(j>0.5*i+7&&i>=j&&(j<=100||i>=100)){\\n                    ans+=i==j?a*b-a:a*b;\\n                }                \\n            }\\n        }return ans;\\n    }\\n}\\n//on leetcode.com\\n//Runtime: 6 ms, faster than 50.67% of Java online submissions for Friends Of Appropriate Ages.\\n//Memory Usage: 41.4 MB, less than 20.00% of Java online submissions for Friends Of Appropriate Ages.\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\u5B98\\u89E3\\u6CD5\\n *2020\\u5E745\\u670829\\u65E5 20:01\\n *\\u6267\\u884C\\u7528\\u65F6 :7 ms, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8653.67%\\u7684\\u7528\\u6237\\n *\\u5185\\u5B58\\u6D88\\u8017 :42.3 MB, \\u5728\\u6240\\u6709 Java \\u63D0\\u4EA4\\u4E2D\\u51FB\\u8D25\\u4E8611.11%\\u7684\\u7528\\u6237\\n *\\u4F5C\\u8005@v7fgg\\n */\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int nianling[]=new int[121];\\n        int ans=0;\\n        for(int a:ages){\\n            nianling[a]++;\\n        }\\n        for(int i=1;i<121;i++){\\n            for(int j=1;j<121;j++){\\n                int a=nianling[i];\\n                int b=nianling[j];\\n                if(j>0.5*i+7&&i>=j&&(j<=100||i>=100)){\\n                    ans+=i==j?a*b-a:a*b;\\n                }                \\n            }\\n        }return ans;\\n    }\\n}\\n//on leetcode.com\\n//Runtime: 6 ms, faster than 50.67% of Java online submissions for Friends Of Appropriate Ages.\\n//Memory Usage: 41.4 MB, less than 20.00% of Java online submissions for Friends Of Appropriate Ages.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656218,
                "title": "pretty-fast-c-solution-using-hash-table-and-some-pruning-of-age-range",
                "content": "```\\nint numFriendRequests(int* ages, int agesSize){\\nint count=0;\\nint i, j;\\nint min_age;\\nint max_age;\\nint age_hash[150];\\n// Initialize a hash table of ages, 0 to 149, and hash all ages into it\\nfor (i=0; i<150; i++) age_hash[i]=0;\\nfor (i=0; i<agesSize; i++) age_hash[ages[i]]++;\\n\\n// Reduce the work by finding youngest and oldest ages\\nfor (i=0; i<150; i++) if (age_hash[i]!=0) { min_age=i; break; }\\nfor (i=149; i>0; i--) if (age_hash[i]!=0) { max_age=i; break; }\\n\\n// Check friending status of each pair of ages, and multiply by how\\n// many of each we have; if ages are same, remember you can\\'t friend\\n// yourself!\\nfor (i=min_age; i<=max_age; i++)\\n    for (j=min_age; j<=max_age; j++) {\\n        if ((age_hash[i]!=0) && (age_hash[j]!=0)) {\\n          if ((j>0.5*i+7) && (j<=i) && \\n              ((j<=100) || (i>=100)))\\n            if (i==j) count += age_hash[i] * (age_hash[i]-1);\\n              else count += age_hash[i] * age_hash[j];\\n        }\\n    }\\n        \\nreturn count;\\n}\\n",
                "solutionTags": [],
                "code": "```\\nint numFriendRequests(int* ages, int agesSize){\\nint count=0;\\nint i, j;\\nint min_age;\\nint max_age;\\nint age_hash[150];\\n// Initialize a hash table of ages, 0 to 149, and hash all ages into it\\nfor (i=0; i<150; i++) age_hash[i]=0;\\nfor (i=0; i<agesSize; i++) age_hash[ages[i]]++;\\n\\n// Reduce the work by finding youngest and oldest ages\\nfor (i=0; i<150; i++) if (age_hash[i]!=0) { min_age=i; break; }\\nfor (i=149; i>0; i--) if (age_hash[i]!=0) { max_age=i; break; }\\n\\n// Check friending status of each pair of ages, and multiply by how\\n// many of each we have; if ages are same, remember you can\\'t friend\\n// yourself!\\nfor (i=min_age; i<=max_age; i++)\\n    for (j=min_age; j<=max_age; j++) {\\n        if ((age_hash[i]!=0) && (age_hash[j]!=0)) {\\n          if ((j>0.5*i+7) && (j<=i) && \\n              ((j<=100) || (i>=100)))\\n            if (i==j) count += age_hash[i] * (age_hash[i]-1);\\n              else count += age_hash[i] * age_hash[j];\\n        }\\n    }\\n        \\nreturn count;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 620199,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\n    bool isReq(int ageA, int ageB) {\\n        \\n        if (ageB <= 0.5*ageA + 7) return false;\\n        if (ageB > ageA) return false;\\n        return true;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        int n = ages.size();\\n        \\n        unordered_map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[ages[i]]++;\\n        \\n        int ans = 0;\\n        for (auto a = hm.begin(); a != hm.end(); a++) {\\n            for (auto b = hm.begin(); b != hm.end(); b++) {\\n                if (isReq(a->first, b->first))\\n                    ans += a->second * (b->second - (a->first == b->first ? 1 : 0));\\n            } \\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isReq(int ageA, int ageB) {\\n        \\n        if (ageB <= 0.5*ageA + 7) return false;\\n        if (ageB > ageA) return false;\\n        return true;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        \\n        int n = ages.size();\\n        \\n        unordered_map<int, int>hm;\\n        for (int i = 0; i < n; i++)\\n            hm[ages[i]]++;\\n        \\n        int ans = 0;\\n        for (auto a = hm.begin(); a != hm.end(); a++) {\\n            for (auto b = hm.begin(); b != hm.end(); b++) {\\n                if (isReq(a->first, b->first))\\n                    ans += a->second * (b->second - (a->first == b->first ? 1 : 0));\\n            } \\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609380,
                "title": "java-o-n-with-explanation",
                "content": "```   /**\\n     * O(n) solution\\n     * Thought: From  nlogn solution, the thing that cost most is the binary search to find the count of ages between lowerBound and upperBound\\n     * so the idea is to see whether we can reduce find counts from O(nlogn) O(1)\\n     *\\n     * since the total ages are between [1, 120]\\n     * so we can first use an array count the number of each ages O(n)\\n     *\\n     * for each age, we know there\\'s a lowerBound and higherBound that ages[i] will send request\\n     * lowerBound = ages[i] / 2 + 8, upperBound = ages[i]\\n     * \\n     * To calculate the count of ages between lowerBound and highBound in O(1), \\n     * we use a prefixCount array\\n     * The count between age[upperBound] and age[lowerBound] will be\\n     * int count = prefixCount[i] - prefixCount[i / 2 + 7]; (prefixCount[i / 2 + 7] is exclusive)\\n     * then we can calcute the res for ages[i] by \\n     * res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n     *\\n     * @param ages\\n     * @return\\n     */\\n    public int numFriendRequestsII(int[] ages) {\\n\\n        // total 120 possible ages in this question, use + 1 avoid overflow\\n        int[] countAges = new int[121];\\n       // prefixSum used to easy find out count of ages between lowerBound and higherBound\\n        int[] prefixCount = new int[121];\\n        for (int i : ages) {\\n            countAges[i]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            prefixCount[i] = countAges[i] + prefixCount[i - 1];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            if(countAges[i] == 0) {\\n                continue;\\n            }\\n            if(i / 2 + 7 >= i) {\\n                continue;\\n            }\\n            int count = prefixCount[i] - prefixCount[i / 2 + 7];\\n            res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   /**\\n     * O(n) solution\\n     * Thought: From  nlogn solution, the thing that cost most is the binary search to find the count of ages between lowerBound and upperBound\\n     * so the idea is to see whether we can reduce find counts from O(nlogn) O(1)\\n     *\\n     * since the total ages are between [1, 120]\\n     * so we can first use an array count the number of each ages O(n)\\n     *\\n     * for each age, we know there\\'s a lowerBound and higherBound that ages[i] will send request\\n     * lowerBound = ages[i] / 2 + 8, upperBound = ages[i]\\n     * \\n     * To calculate the count of ages between lowerBound and highBound in O(1), \\n     * we use a prefixCount array\\n     * The count between age[upperBound] and age[lowerBound] will be\\n     * int count = prefixCount[i] - prefixCount[i / 2 + 7]; (prefixCount[i / 2 + 7] is exclusive)\\n     * then we can calcute the res for ages[i] by \\n     * res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n     *\\n     * @param ages\\n     * @return\\n     */\\n    public int numFriendRequestsII(int[] ages) {\\n\\n        // total 120 possible ages in this question, use + 1 avoid overflow\\n        int[] countAges = new int[121];\\n       // prefixSum used to easy find out count of ages between lowerBound and higherBound\\n        int[] prefixCount = new int[121];\\n        for (int i : ages) {\\n            countAges[i]++;\\n        }\\n        for(int i = 1; i <= 120; i++) {\\n            prefixCount[i] = countAges[i] + prefixCount[i - 1];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i <= 120; i++) {\\n            if(countAges[i] == 0) {\\n                continue;\\n            }\\n            if(i / 2 + 7 >= i) {\\n                continue;\\n            }\\n            int count = prefixCount[i] - prefixCount[i / 2 + 7];\\n            res += count * countAges[i] - countAges[i]; // people wont friend themselves\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534421,
                "title": "cpp-beats-100-submissions-in-time-and-space",
                "content": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        int ans=0;\\n        int freq[121]={0};\\n        for(int age : ages)\\n            freq[age]++;\\n        int vec[121];\\n        vec[0]=freq[0];\\n        for(int i=1;i<=120;i++)\\n            vec[i]=vec[i-1]+freq[i];\\n        //persons with age from 1 to 14 will not be able to make friend requests\\n        for(int i=15;i<=120;i++)\\n        {\\n            int t=i/2+7;\\n            int val=vec[i]-vec[t]-1;\\n            ans+=freq[i]*val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto fast=[]{ios_base::sync_with_stdio(false);cin.tie(nullptr);return 0;}();\\n#define mod 1000000007\\nclass Solution \\n{\\npublic:\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        int ans=0;\\n        int freq[121]={0};\\n        for(int age : ages)\\n            freq[age]++;\\n        int vec[121];\\n        vec[0]=freq[0];\\n        for(int i=1;i<=120;i++)\\n            vec[i]=vec[i-1]+freq[i];\\n        //persons with age from 1 to 14 will not be able to make friend requests\\n        for(int i=15;i<=120;i++)\\n        {\\n            int t=i/2+7;\\n            int val=vec[i]-vec[t]-1;\\n            ans+=freq[i]*val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499670,
                "title": "why-doesn-t-this-work",
                "content": "```\\n public int numFriendRequests(int[] ages) { \\n        \\n        int[] counts = new int[121];\\n        for(int age : ages) {\\n            counts[age]++;\\n        }\\n        int result = 0;\\n        for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               \\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                    if(canRequest(i, j)){\\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t\\n\\tand if I make the logic change as follows it works\\n\\t  for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               if(!canRequest(i,j)) continue;\\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                  \\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n    \\n    private boolean canRequest(int A, int B) {\\n        if((B <= 0.5 * A + 7) ||  B > A || (B > 100 && A < 100 )) return false;\\n         \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) { \\n        \\n        int[] counts = new int[121];\\n        for(int age : ages) {\\n            counts[age]++;\\n        }\\n        int result = 0;\\n        for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               \\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                    if(canRequest(i, j)){\\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t\\n\\tand if I make the logic change as follows it works\\n\\t  for(int i = 1; i < 121; i++) {\\n            for(int j = 1; j < 121; j++) {\\n               if(!canRequest(i,j)) continue;\\n                if(i == j) {\\n                    result += counts[i]*(counts[i]  - 1);\\n                } else {\\n                  \\n                      result += counts[i]*(counts[j]);\\n                    }\\n                  \\n                }\\n              \\n            }\\n        }\\n        \\n    \\n    private boolean canRequest(int A, int B) {\\n        if((B <= 0.5 * A + 7) ||  B > A || (B > 100 && A < 100 )) return false;\\n         \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 478473,
                "title": "concise-solution-for-interviews-simpler-than-official-solution",
                "content": "\\tpublic int numFriendRequests(int[] ages) {\\n\\t\\tint[] freq = new int[121];\\n\\t\\tfor (int age : ages) {\\n\\t\\t  freq[age]++;\\n\\t\\t}\\n\\n\\t\\tint req = 0;\\n\\n\\t\\tfor (int a = 1; a <= 120; a++) {\\n\\t\\t  for (int b = 1; b <= 120; b++) {\\n\\t\\t\\tif (b > a || b <= 0.5 * a + 7) {\\n\\t\\t\\t  continue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a == b) {\\n\\t\\t\\t  req += freq[a] * (freq[a] - 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t  req += freq[a] * freq[b];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn req;\\n\\t  }",
                "solutionTags": [
                    "Array"
                ],
                "code": "\\tpublic int numFriendRequests(int[] ages) {\\n\\t\\tint[] freq = new int[121];\\n\\t\\tfor (int age : ages) {\\n\\t\\t  freq[age]++;\\n\\t\\t}\\n\\n\\t\\tint req = 0;\\n\\n\\t\\tfor (int a = 1; a <= 120; a++) {\\n\\t\\t  for (int b = 1; b <= 120; b++) {\\n\\t\\t\\tif (b > a || b <= 0.5 * a + 7) {\\n\\t\\t\\t  continue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (a == b) {\\n\\t\\t\\t  req += freq[a] * (freq[a] - 1);\\n\\t\\t\\t} else {\\n\\t\\t\\t  req += freq[a] * freq[b];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn req;\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 447775,
                "title": "javascript-solution",
                "content": "```\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var friendships = 0;\\n    var nums = {};\\n    ages.forEach(function(age){\\n        if(age >= 15) nums[age] = age in nums ? nums[age] + 1: 1;\\n    });\\n    var ages = Object.keys(nums).sort((a,b) => b - a);\\n    for(var i = 0; i < ages.length; i++){\\n        for(var j = i + 1; j < ages.length; j++){\\n            if(ages[j] > 0.5 * ages[i] + 7){\\n                friendships += nums[ages[i]] * nums[ages[j]];\\n            }\\n        }\\n        friendships += ((nums[ages[i]] - 1) * nums[ages[i]]);\\n    }\\n    return friendships;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numFriendRequests = function(ages) {\\n    if(ages.length <= 1) return 0;\\n    var friendships = 0;\\n    var nums = {};\\n    ages.forEach(function(age){\\n        if(age >= 15) nums[age] = age in nums ? nums[age] + 1: 1;\\n    });\\n    var ages = Object.keys(nums).sort((a,b) => b - a);\\n    for(var i = 0; i < ages.length; i++){\\n        for(var j = i + 1; j < ages.length; j++){\\n            if(ages[j] > 0.5 * ages[i] + 7){\\n                friendships += nums[ages[i]] * nums[ages[j]];\\n            }\\n        }\\n        friendships += ((nums[ages[i]] - 1) * nums[ages[i]]);\\n    }\\n    return friendships;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401164,
                "title": "short-simple-python-binary-search-solution",
                "content": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = 0\\n        ages.sort()\\n        for n in ages:\\n            l, r = n//2 + 8, n \\n            ll = bisect_left(ages,l)\\n            rr = bisect_right(ages,r)\\n            val = rr - ll - 1\\n            count += val if val > 0  else 0\\n        return count\\n            ```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = 0\\n        ages.sort()\\n        for n in ages:\\n            l, r = n//2 + 8, n \\n            ll = bisect_left(ages,l)\\n            rr = bisect_right(ages,r)\\n            val = rr - ll - 1\\n            count += val if val > 0  else 0\\n        return count\\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 342382,
                "title": "python-easy-to-understand-o-n-log-n-o-1-space",
                "content": "1. Sort the ages\\n2. Have a left pointer and right pointer\\n3. The pointers indicate which people can be friended\\n\\t- left pointer is increased until 0.5 * A + 7 is false\\n\\t- right pointer is the current age (people don\\'t friend people older than them)\\n4. Special handling is needed for the case where we have multiple people of the same age\\n\\t- to handle this keep track of the duplicates `sameAge` and add them to our ans\\n\\t- for example we have 3 people of age 30\\n\\t\\t- for first guy, sameAge = 0\\n\\t\\t- for second guy, sameAge = 1. ans += 1 - first guy making friends with the second guy\\n\\t\\t- for third guy, sameAge = 2. ans += 2  - first and second guy making friends with the third guy\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages): \\n        ages.sort()\\n        ans = 0\\n        l = 0\\n        \\n        sameAge = 0\\n        \\n        for r, A in enumerate(ages):\\n            if r and ages[r] == ages[r - 1]:\\n                sameAge += 1\\n            else:\\n                sameAge = 0\\n            \\n            while l < len(ages) and ages[l] <= 0.5 * A + 7:\\n                l += 1\\n        \\n            if l <= r:\\n                ans += r - l + sameAge     \\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages): \\n        ages.sort()\\n        ans = 0\\n        l = 0\\n        \\n        sameAge = 0\\n        \\n        for r, A in enumerate(ages):\\n            if r and ages[r] == ages[r - 1]:\\n                sameAge += 1\\n            else:\\n                sameAge = 0\\n            \\n            while l < len(ages) and ages[l] <= 0.5 * A + 7:\\n                l += 1\\n        \\n            if l <= r:\\n                ans += r - l + sameAge     \\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146319,
                "title": "logical-thinking-with-java-code",
                "content": "**Logical Thinking**\\n```\\nNotes:\\n1 <= ages.length <= 20000.\\n1 <= ages[i] <= 120.\\n```\\nThe notes above is the key to solve the problem.\\nThe `value range of ages` is far smaller than the `number of ages`. Thus, we loop through all possible values for age rather than ages of all possible candidates, i.e.,  `[1, 120] rather than [1, 20000]`.\\nPlease note that, if A1 = ageA, A2 = ageA, B1 = ageB, B2 = ageB, B3 = ageB, then total requests made by ageA and ageB is 2 x 3 = 6, that is, `map[ageA] x map[ageB]`. What if ageA equals to ageB? The the result shoulD minus `map[ageA/ageB] `for people cannot make friend requests to himself.\\n\\n**Clear Java Code**\\n```\\n    public int numFriendRequests(int[] ages) {\\n        int cntFriendRequests = 0;\\n        int[] map = new int[121]; // 1 ~ 120;\\n        for (int age : ages) {\\n            map[age]++;\\n        }\\n        for (int A = 1; A <= 120; A++) {\\n            for (int B = 1; B <= 120; B++) {\\n                if (B <= 0.5 * A + 7) continue;\\n                if (B > A) continue;\\n                if (B > 100 && A < 100) continue;\\n                cntFriendRequests += map[A] * map[B];\\n                if (A == B) {\\n                    cntFriendRequests -= map[A];\\n                }\\n            }\\n        }\\n        return cntFriendRequests;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nNotes:\\n1 <= ages.length <= 20000.\\n1 <= ages[i] <= 120.\\n```\n```\\n    public int numFriendRequests(int[] ages) {\\n        int cntFriendRequests = 0;\\n        int[] map = new int[121]; // 1 ~ 120;\\n        for (int age : ages) {\\n            map[age]++;\\n        }\\n        for (int A = 1; A <= 120; A++) {\\n            for (int B = 1; B <= 120; B++) {\\n                if (B <= 0.5 * A + 7) continue;\\n                if (B > A) continue;\\n                if (B > 100 && A < 100) continue;\\n                cntFriendRequests += map[A] * map[B];\\n                if (A == B) {\\n                    cntFriendRequests -= map[A];\\n                }\\n            }\\n        }\\n        return cntFriendRequests;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135447,
                "title": "concise-c-code",
                "content": "```\\nint\\nnumFriendRequests(const int *const ages, const int agesSize)\\n{\\n\\tstatic int cnt[121];\\n\\tint a, b, sum;\\n\\n\\t(void)memset(cnt, 0, sizeof(cnt));\\n\\tfor (a = 0; a < agesSize; ++a)\\n\\t\\t++cnt[ages[a]];\\n\\tsum = 0;\\n\\tfor (a = 15; a <= 120; ++a)\\n\\t\\tif (cnt[a] != 0)\\n\\t\\t\\tfor (b = a / 2 + 8; b <= a; ++b)\\n\\t\\t\\t\\tif (cnt[b] != 0)\\n\\t\\t\\t\\t\\tsum += (cnt[a] - (a == b)) * cnt[b];\\n\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint\\nnumFriendRequests(const int *const ages, const int agesSize)\\n{\\n\\tstatic int cnt[121];\\n\\tint a, b, sum;\\n\\n\\t(void)memset(cnt, 0, sizeof(cnt));\\n\\tfor (a = 0; a < agesSize; ++a)\\n\\t\\t++cnt[ages[a]];\\n\\tsum = 0;\\n\\tfor (a = 15; a <= 120; ++a)\\n\\t\\tif (cnt[a] != 0)\\n\\t\\t\\tfor (b = a / 2 + 8; b <= a; ++b)\\n\\t\\t\\t\\tif (cnt[b] != 0)\\n\\t\\t\\t\\t\\tsum += (cnt[a] - (a == b)) * cnt[b];\\n\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 127885,
                "title": "c-hash-map",
                "content": "I first have some difficulty to understand the problem.\\nThe three condition is C1, C2 and C3\\nA not friend request B: C1||C2||C3\\nA friend request B: !(C1||C2||C3)=!C1&&!C2&&!C3\\n!C1: B>0.5A+7. If B=A, B>14\\n!C2: B<=A\\n!C3: B<=100 || A>=100, this always is true\\nWe build a hash map (using a vector is simpler) and check the !C1 and !C2.\\nsame age friend request if met condition: N*(N-1)\\ndifferent age friend request if met condition: N*M\\n\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int va[121]={0};\\n        for(int i=0;i<ages.size();i++) va[ages[i]]++;\\n        //larger age friend request smaller age\\n        //age difference\\n        //can use binary search\\n        int total=0;\\n        for(int i=1;i<=120;i++)\\n        {\\n            if(i>14 && va[i]>1) total+=va[i]*(va[i]-1); //C1 condition\\n            if(i>1 && va[i]) //2nd condition, only friend request with smaller age\\n            {\\n                int smallest_age=i/2+7+1;//>age C1 condition\\n                //cout<<smallest_age<<endl;\\n                for(int j=smallest_age;j<i;j++) total+=va[j]*va[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int va[121]={0};\\n        for(int i=0;i<ages.size();i++) va[ages[i]]++;\\n        //larger age friend request smaller age\\n        //age difference\\n        //can use binary search\\n        int total=0;\\n        for(int i=1;i<=120;i++)\\n        {\\n            if(i>14 && va[i]>1) total+=va[i]*(va[i]-1); //C1 condition\\n            if(i>1 && va[i]) //2nd condition, only friend request with smaller age\\n            {\\n                int smallest_age=i/2+7+1;//>age C1 condition\\n                //cout<<smallest_age<<endl;\\n                for(int j=smallest_age;j<i;j++) total+=va[j]*va[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 127109,
                "title": "simple-java-solution",
                "content": "```\\n public int numFriendRequests(int[] ages) {\\n       int[] map =  new int[121];\\n       for(int n : ages)\\n           map[n]++;  // frequency count\\n       \\n       int req = 0;\\n        for(int i = 120; i>0 ;--i){\\n            if( map[i]  > 0){\\n                int k = i + 14;  // ages[j] must be > 0.5*ages[i] + 7  =>  ages[j]*2 > ages[i] + 14 \\n                for(int j = i-1; 2*j > k  ;--j){\\n                    if(map[j] > 0) req+=map[i]*map[j]; // ways A can make friend requests to B\\n                }\\n                if( 2*i > k)  req+=map[i]*(map[i]-1);  // friend requests made to each other (same age)\\n            }\\n        }\\n       return req;\\n   }",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) {\\n       int[] map =  new int[121];\\n       for(int n : ages)\\n           map[n]++;  // frequency count\\n       \\n       int req = 0;\\n        for(int i = 120; i>0 ;--i){\\n            if( map[i]  > 0){\\n                int k = i + 14;  // ages[j] must be > 0.5*ages[i] + 7  =>  ages[j]*2 > ages[i] + 14 \\n                for(int j = i-1; 2*j > k  ;--j){\\n                    if(map[j] > 0) req+=map[i]*map[j]; // ways A can make friend requests to B\\n                }\\n                if( 2*i > k)  req+=map[i]*(map[i]-1);  // friend requests made to each other (same age)\\n            }\\n        }\\n       return req;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 127038,
                "title": "easy-and-simple-c-o-nlogn-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int ans = 0;\\n        for(int i = 0; i < ages.size(); i++){\\n            int j = i+1;\\n            while(j<ages.size() && ages[i]==ages[j]) j++;\\n            j--;\\n            auto itr = upper_bound(ages.begin(), ages.end(), 0.5*ages[i] + 7);\\n            if(itr != ages.end() && (itr-ages.begin())<j) {\\n                ans += j - (itr-ages.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end());\\n        int ans = 0;\\n        for(int i = 0; i < ages.size(); i++){\\n            int j = i+1;\\n            while(j<ages.size() && ages[i]==ages[j]) j++;\\n            j--;\\n            auto itr = upper_bound(ages.begin(), ages.end(), 0.5*ages[i] + 7);\\n            if(itr != ages.end() && (itr-ages.begin())<j) {\\n                ans += j - (itr-ages.begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126971,
                "title": "python-solution",
                "content": "```\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from bisect import bisect_left, bisect_right\\n        total=0\\n        ages.sort()\\n\\n        for i in xrange(len(ages)-1, -1, -1):\\n            a = ages[i]\\n            r = bisect_right(ages, a) - 1\\n            l = bisect_right(ages, a/2 + 7)\\n            if r-l >= 0:\\n                total += (r-l)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\n    def numFriendRequests(self, ages):\\n        \"\"\"\\n        :type ages: List[int]\\n        :rtype: int\\n        \"\"\"\\n        from bisect import bisect_left, bisect_right\\n        total=0\\n        ages.sort()\\n\\n        for i in xrange(len(ages)-1, -1, -1):\\n            a = ages[i]\\n            r = bisect_right(ages, a) - 1\\n            l = bisect_right(ages, a/2 + 7)\\n            if r-l >= 0:\\n                total += (r-l)\\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4090663,
                "title": "go-simple",
                "content": "```\\nfunc numFriendRequests(ages []int) int {\\n    people := make([]int, 121)\\n\\n    for _, age := range ages {\\n        people[age]++\\n    }\\n\\n    res := 0\\n\\n    for i := 1; i <= 120; i++ {\\n        if people[i] == 0 { continue }\\n\\n        limit := (i / 2) + 7\\n\\n        for j := limit + 1; j < i; j++ {\\n            res += people[i] * people[j]\\n        }\\n\\n        if i > limit {\\n            res += people[i] * (people[i] - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFriendRequests(ages []int) int {\\n    people := make([]int, 121)\\n\\n    for _, age := range ages {\\n        people[age]++\\n    }\\n\\n    res := 0\\n\\n    for i := 1; i <= 120; i++ {\\n        if people[i] == 0 { continue }\\n\\n        limit := (i / 2) + 7\\n\\n        for j := limit + 1; j < i; j++ {\\n            res += people[i] * people[j]\\n        }\\n\\n        if i > limit {\\n            res += people[i] * (people[i] - 1)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024957,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java  []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```java  []\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = Counter(ages)\\n        s = sorted(counter.keys())\\n        prefix = []\\n        sum_total = 0\\n        for i in s:\\n            sum_total += counter[i]\\n            prefix.append(sum_total)\\n            \\n        \\n        j = 0\\n        count = 0\\n        for i, age in enumerate(s):\\n            while j < i and (s[j] <= 0.5*age + 7):\\n                j += 1\\n            if j == i and s[j] <= 0.5*age + 7:\\n                continue\\n            if counter[s[i]] > 1:\\n                count += (counter[s[i]] * (counter[s[i]]-1))\\n            count += (counter[s[i]] * ((prefix[i-1] if i > 0 else 0) - (prefix[j-1] if j > 0 else 0)))\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934494,
                "title": "java-code",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean check(int x, int y) {\\n        return !((y <= (0.5*x)+7) || (y > x) || (y > 100 && x<100));\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int el : ages) {\\n            map.put(el, map.getOrDefault(el, 0)+1);\\n        }\\n\\n        int count = 0;\\n\\n        for(int a : map.keySet()) {\\n            for(int b : map.keySet()) {\\n                if(check(a,b)) {\\n                    count += map.get(a)*(map.get(b) - ((a == b)? 1 : 0));\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean check(int x, int y) {\\n        return !((y <= (0.5*x)+7) || (y > x) || (y > 100 && x<100));\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int el : ages) {\\n            map.put(el, map.getOrDefault(el, 0)+1);\\n        }\\n\\n        int count = 0;\\n\\n        for(int a : map.keySet()) {\\n            for(int b : map.keySet()) {\\n                if(check(a,b)) {\\n                    count += map.get(a)*(map.get(b) - ((a == b)? 1 : 0));\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891045,
                "title": "brute-force-and-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(N2) and O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// || (b>100 and a<100)\\n    bool cond(int a,int b){\\n        if(b>a || b<=((0.5*a)+7))return false;\\n        return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        // unordered_map<int,int>mp;\\n        // for(auto it:ages)mp[it]++;\\n        // int ans=0;\\n        // for(auto &it1:mp){\\n        //     for(auto &it2:mp){\\n        //         if(cond(it1.first,it2.first)){\\n        //         if(it1.first==it2.first)ans+=it1.second*(it2.second-1);\\n        //          else ans+=it1.second*it2.second;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int n=ages.size();\\n\\n        sort(ages.begin(),ages.end());\\n        unordered_map<int,int>dict;\\n        int ans=0;\\n        for(auto it:ages){\\n            if(dict.find(it)!=dict.end()){\\n                ans+=dict[it];\\n                continue;\\n            }\\n            int leftmost=-1;\\n            int start=0;\\n            int end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]>0.5*it+7){\\n                    leftmost=mid;\\n                    end=mid-1;\\n                }else start=mid+1;\\n                               \\n            }\\n            if(leftmost<0)continue;\\n            int rightmost=-1;\\n           start=0,end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]<=it){\\n                    rightmost=mid;\\n                    start=mid+1;\\n                }else end=mid-1;\\n\\n            }\\n            int count=rightmost-leftmost;\\n            if(count>0){\\n                ans+=count;\\n            }\\n            if(count>0){\\n                dict[it]=count;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// || (b>100 and a<100)\\n    bool cond(int a,int b){\\n        if(b>a || b<=((0.5*a)+7))return false;\\n        return true;\\n    }\\n    int numFriendRequests(vector<int>& ages) {\\n        // unordered_map<int,int>mp;\\n        // for(auto it:ages)mp[it]++;\\n        // int ans=0;\\n        // for(auto &it1:mp){\\n        //     for(auto &it2:mp){\\n        //         if(cond(it1.first,it2.first)){\\n        //         if(it1.first==it2.first)ans+=it1.second*(it2.second-1);\\n        //          else ans+=it1.second*it2.second;\\n        //         }\\n                \\n        //     }\\n        // }\\n        // return ans;\\n        int n=ages.size();\\n\\n        sort(ages.begin(),ages.end());\\n        unordered_map<int,int>dict;\\n        int ans=0;\\n        for(auto it:ages){\\n            if(dict.find(it)!=dict.end()){\\n                ans+=dict[it];\\n                continue;\\n            }\\n            int leftmost=-1;\\n            int start=0;\\n            int end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]>0.5*it+7){\\n                    leftmost=mid;\\n                    end=mid-1;\\n                }else start=mid+1;\\n                               \\n            }\\n            if(leftmost<0)continue;\\n            int rightmost=-1;\\n           start=0,end=n-1;\\n            while(start<=end){\\n                int mid=start+(end-start)/2;\\n                if(ages[mid]<=it){\\n                    rightmost=mid;\\n                    start=mid+1;\\n                }else end=mid-1;\\n\\n            }\\n            int count=rightmost-leftmost;\\n            if(count>0){\\n                ans+=count;\\n            }\\n            if(count>0){\\n                dict[it]=count;\\n            }\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840372,
                "title": "100-in-time-100-in-space-why-no-idea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI think the problem was somewhat poorly phrased since condition 2 is essentially condition 3, where you don\\'t friend people older than you. With that in mind, we can sort the array first and essentially eliminate needing to check 2/3 of conditions (since anyone before you in age won\\'t friend you back).\\n\\nAfter that it\\'s just a matter of checking for the calculated age condition, with a small statement to handle when people are the same age.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numFriendRequests(ages: number[]): number {\\n\\n    let requests = 0\\n    ages.sort((a, b) => b - a)\\n\\n    for (let i = 0; i < ages.length - 1; i++) {\\n        const mylimit = Math.floor(ages[i] / 2) + 7\\n        inner: for (let k = i + 1; k < ages.length; k++) {\\n            if (ages[k] > mylimit) {\\n                requests++\\n                if (ages[k] === ages[i]) {\\n                    requests++\\n                }\\n            } else {\\n                break inner\\n\\n            }\\n        }\\n    }\\n    return requests\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numFriendRequests(ages: number[]): number {\\n\\n    let requests = 0\\n    ages.sort((a, b) => b - a)\\n\\n    for (let i = 0; i < ages.length - 1; i++) {\\n        const mylimit = Math.floor(ages[i] / 2) + 7\\n        inner: for (let k = i + 1; k < ages.length; k++) {\\n            if (ages[k] > mylimit) {\\n                requests++\\n                if (ages[k] === ages[i]) {\\n                    requests++\\n                }\\n            } else {\\n                break inner\\n\\n            }\\n        }\\n    }\\n    return requests\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825943,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe workflow of the code is as follows:\\n\\ncount is a list whose index represents age and whose value represents the number of people with that age. For example, if there are three people with age 15, count[15] = 3. This step is done in a for age in ages: count[age] += 1 loop.\\n\\nThe code then checks all possible age pairs (a,b) with two nested loops, where ageA and ageB represent the ages of a and b, respectively, and countA and countB represent the number of people of ages a and b, respectively.\\n\\nFor each age pair, if the age of b does not satisfy the condition for sending a friend request (i.e., ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100)), then continue to the next age pair.\\n\\nOtherwise, the person with ageA can send friend requests to all people with ageB, so add countA * countB to the result.\\n\\nHowever, if a and b have the same age (i.e. ageA == ageB), then the person of age a cannot send a friend request to himself. Therefore, we need to subtract countA, which is the number of people of age a, from the result.\\n\\nFinally, return the result res, which is the total number of friend requests that satisfy the condition.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0] * 121  # \\u5E74\\u9F84\\u5230\\u9891\\u7387\\u7684\\u6620\\u5C04,121\\u662F\\u56E0\\u4E3A\\u6700\\u5927\\u5E74\\u9F84\\u662F120\\n        for age in ages:\\n            count[age] += 1\\n\\n        res = 0\\n        for ageA, countA in enumerate(count):\\n            for ageB, countB in enumerate(count):\\n                if ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100):\\n                    continue\\n                res += countA * countB\\n                if ageA == ageB:  # \\u5E74\\u9F84\\u76F8\\u540C\\u7684\\u4EBA\\u4E0D\\u80FD\\u5411\\u81EA\\u5DF1\\u53D1\\u9001\\u8BF7\\u6C42\\n                    res -= countA\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0] * 121  # \\u5E74\\u9F84\\u5230\\u9891\\u7387\\u7684\\u6620\\u5C04,121\\u662F\\u56E0\\u4E3A\\u6700\\u5927\\u5E74\\u9F84\\u662F120\\n        for age in ages:\\n            count[age] += 1\\n\\n        res = 0\\n        for ageA, countA in enumerate(count):\\n            for ageB, countB in enumerate(count):\\n                if ageB <= ageA * 0.5 + 7 or ageB > ageA or (ageB > 100 and ageA < 100):\\n                    continue\\n                res += countA * countB\\n                if ageA == ageB:  # \\u5E74\\u9F84\\u76F8\\u540C\\u7684\\u4EBA\\u4E0D\\u80FD\\u5411\\u81EA\\u5DF1\\u53D1\\u9001\\u8BF7\\u6C42\\n                    res -= countA\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803257,
                "title": "faster-than-100-python3-binary-search-prefix-sum-hash-table",
                "content": "# Intuition\\nUse a counter to count how many times an age is in array and work with all the distinct values.\\n# Approach\\nSort the list with different ages and for every age use binary search or use a last pointer approach to find the youngest one for a request. All the values beetwen this and current age will verify the conditions, and use a prefix sum to compute the sum of them faster.\\n\\n# Complexity\\n- Time complexity:\\nO( n + mlog(m)), m  = the number of distinct values\\n\\n# Code Approach 1: Binary Search\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n            start = 0\\n            end = i-1\\n            last = -1\\n            while start <= end:\\n                m = (start + end) //2\\n                if l[m] <= 0.5*l[i]+7:\\n                    start = m+1\\n\\n                else:\\n                    last = m\\n                    end = m-1\\n\\n            if last>=0:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n\\n        \\n```\\n\\n# Code Approach 2: Two Pointers\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        last = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n        \\n            while last <= i-2 and l[last] <= 0.5 * age + 7:\\n                last += 1\\n\\n            if last <= i-1 and l[last] > 0.5 * age + 7:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n            start = 0\\n            end = i-1\\n            last = -1\\n            while start <= end:\\n                m = (start + end) //2\\n                if l[m] <= 0.5*l[i]+7:\\n                    start = m+1\\n\\n                else:\\n                    last = m\\n                    end = m-1\\n\\n            if last>=0:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n\\n        \\n```\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        c = Counter(ages)\\n        l = [age for age in c.keys()]\\n        l.sort()\\n        prefixSum = []\\n        for age in l:\\n            if not prefixSum:\\n                prefixSum.append(c[age])\\n\\n            else:\\n                prefixSum.append(c[age]+prefixSum[-1])\\n\\n        \\n        ans = 0\\n        last = 0\\n        for i in range(len(l)):\\n            age = l[i]\\n        \\n            while last <= i-2 and l[last] <= 0.5 * age + 7:\\n                last += 1\\n\\n            if last <= i-1 and l[last] > 0.5 * age + 7:\\n                if last == 0:\\n                    s = prefixSum[i-1]\\n                \\n                else:\\n                    s = prefixSum[i-1] - prefixSum[last-1]\\n\\n                ans += c[age] * s\\n\\n            if age > 14:\\n                ans += c[age] * (c[age]-1)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751261,
                "title": "c-best-approach-and-easy-to-understand-t-c-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nfind all the age less then age[i] and find minimum age[j] (j<i) such that it follows the condition of friend request and all the ages after jth age till age[i] will follow the condition to send request.\\nso add (i-j) to count.\\n\\nAlong with the upper approach here is one catch.\\n\\nif we have same elements like [16,16,16]\\nnow as per the above example all the three 16 will be able to make friends with other two 16 so total requests sent is 3*(2 each)=6\\nso in such repeating ages what we will do is to count the number of repeating ages and find the requests for last most repeated age and multiply that answer with total number of repeated ages....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNlog(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLowerBound(vector<int>& a,int n,int x)\\n    {\\n        int l=0;\\n        int r=n-1;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(a[mid]>x/2+7)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int numFriendRequests(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int j=i;\\n            int sameOccurences=0;\\n            while(j<n && a[i]==a[j])\\n            {\\n                j++;\\n                sameOccurences++;\\n            }\\n            int lowerBound=findLowerBound(a,j-1,a[i]);\\n            //cout<<\"i:\"<<i<<\"LB\"<<lowerBound<<endl;\\n            if(lowerBound!=-1)\\n            {\\n                count+=(j-1-lowerBound)*sameOccurences;\\n            }\\n            i=j-1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLowerBound(vector<int>& a,int n,int x)\\n    {\\n        int l=0;\\n        int r=n-1;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(a[mid]>x/2+7)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int numFriendRequests(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        int count=0;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n\\n            int j=i;\\n            int sameOccurences=0;\\n            while(j<n && a[i]==a[j])\\n            {\\n                j++;\\n                sameOccurences++;\\n            }\\n            int lowerBound=findLowerBound(a,j-1,a[i]);\\n            //cout<<\"i:\"<<i<<\"LB\"<<lowerBound<<endl;\\n            if(lowerBound!=-1)\\n            {\\n                count+=(j-1-lowerBound)*sameOccurences;\\n            }\\n            i=j-1;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3733163,
                "title": "c-upper-bound-start-and-end-of-range",
                "content": "1. Sort the Ages array\\n2. Find a range of appropriate ages to send requests to. Use *upper bound* flavor of binary search to place a pointer 1 after the first acceptable ages[i], and a pointer 1 position after the current ages[i]\\n3. Count the size of this range.\\n\\n```\\nclass Solution {\\npublic:\\n  int numFriendRequests(vector<int>& ages) {\\n    std::sort(ages.begin(), ages.end());\\n    int n = ages.size(), count = 0;\\n\\n    for (int i = 0; i < n; ++i) {\\n      int low_index = std::upper_bound(ages.begin(), ages.end(), (ages[i] / 2) + 7) - ages.begin();\\n      int high_index = std::upper_bound(ages.begin(), ages.end(), ages[i]) - ages.begin();\\n      count += std::max(high_index - low_index - 1, 0);\\n    }\\n\\n    return count;\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numFriendRequests(vector<int>& ages) {\\n    std::sort(ages.begin(), ages.end());\\n    int n = ages.size(), count = 0;\\n\\n    for (int i = 0; i < n; ++i) {\\n      int low_index = std::upper_bound(ages.begin(), ages.end(), (ages[i] / 2) + 7) - ages.begin();\\n      int high_index = std::upper_bound(ages.begin(), ages.end(), ages[i]) - ages.begin();\\n      count += std::max(high_index - low_index - 1, 0);\\n    }\\n\\n    return count;\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690755,
                "title": "array",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the negation of the second condition is True, then the negation of the third condition is True.(suppose age[y] <= age[x] and age[y] > 100 --> age[x] > 100 --> thus age[x] >= 100) Hence we could discard the third condition.\\n\\nSince range of age is relative small to the input size, DAA may come in handy.\\n\\nFrom the negation of the second condition we could realize that we might overcount someone who sends a friend request to themself and suppose his/her age is x. As the negation of the first condition is met, 2x > x + 14 --> x > 14.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(121)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ret = 0\\n        L = [0 for _ in range(121)]\\n        \\n        for age in ages:\\n            L[age] += 1\\n        \\n        for age_x in range(1, 121):\\n            for age_y in range(age_x//2+8, age_x+1):\\n                ret += L[age_x] * L[age_y]\\n            \\n            if age_x > 14:\\n                ret -= L[age_x]\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ret = 0\\n        L = [0 for _ in range(121)]\\n        \\n        for age in ages:\\n            L[age] += 1\\n        \\n        for age_x in range(1, 121):\\n            for age_y in range(age_x//2+8, age_x+1):\\n                ret += L[age_x] * L[age_y]\\n            \\n            if age_x > 14:\\n                ret -= L[age_x]\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689143,
                "title": "swift-easy-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   func numFriendRequests(_ ages: [Int]) -> Int {\\n    var requestCount = 0\\n    var ages = ages.sorted()\\n    var length = ages.count\\n    for i in 0..<length{\\n        var leftMostValidIndex = -1\\n        var start1 = 0\\n        var end1 = length-1\\n        while start1 <= end1{\\n            var mid = start1 + (end1 - start1)/2\\n            if Double(ages[mid]) > Double(0.5) * Double(ages[i]) + 7{\\n                leftMostValidIndex = mid\\n                end1 = mid-1\\n            } else {\\n                start1 = mid+1\\n            }\\n        }\\n        if leftMostValidIndex < 0{\\n            continue\\n        }\\n        var rightmostValidIndex = -1\\n        var start = 0\\n        var end = length-1\\n        while start <= end{\\n            var mid = start + (end - start)/2\\n            if ages[mid] <= ages[i]{\\n                rightmostValidIndex = mid\\n                start = mid + 1\\n            }else{\\n                end = mid-1\\n            }\\n        }\\n        var count = rightmostValidIndex - leftMostValidIndex\\n        if count > 0{\\n            requestCount += count\\n        }else{\\n            requestCount += 0\\n        }\\n       \\n    }\\n    return requestCount\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func numFriendRequests(_ ages: [Int]) -> Int {\\n    var requestCount = 0\\n    var ages = ages.sorted()\\n    var length = ages.count\\n    for i in 0..<length{\\n        var leftMostValidIndex = -1\\n        var start1 = 0\\n        var end1 = length-1\\n        while start1 <= end1{\\n            var mid = start1 + (end1 - start1)/2\\n            if Double(ages[mid]) > Double(0.5) * Double(ages[i]) + 7{\\n                leftMostValidIndex = mid\\n                end1 = mid-1\\n            } else {\\n                start1 = mid+1\\n            }\\n        }\\n        if leftMostValidIndex < 0{\\n            continue\\n        }\\n        var rightmostValidIndex = -1\\n        var start = 0\\n        var end = length-1\\n        while start <= end{\\n            var mid = start + (end - start)/2\\n            if ages[mid] <= ages[i]{\\n                rightmostValidIndex = mid\\n                start = mid + 1\\n            }else{\\n                end = mid-1\\n            }\\n        }\\n        var count = rightmostValidIndex - leftMostValidIndex\\n        if count > 0{\\n            requestCount += count\\n        }else{\\n            requestCount += 0\\n        }\\n       \\n    }\\n    return requestCount\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683837,
                "title": "easy-solution-from-byte-benders",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n    \\n        int[] agecount = new int[121];\\n        for(int age : ages)\\n        {\\n            agecount[age]++;\\n        }\\n    int cnt=0;\\n    for(int i=1;i<=120;i++)\\n    {\\n        for(int j=i/2+8;j<=i;j++)\\n        {\\n            cnt+=agecount[i] * (agecount[j]-(i==j?1:0));\\n        }\\n    }\\n    return cnt;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    /*class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n*/}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n    \\n        int[] agecount = new int[121];\\n        for(int age : ages)\\n        {\\n            agecount[age]++;\\n        }\\n    int cnt=0;\\n    for(int i=1;i<=120;i++)\\n    {\\n        for(int j=i/2+8;j<=i;j++)\\n        {\\n            cnt+=agecount[i] * (agecount[j]-(i==j?1:0));\\n        }\\n    }\\n    return cnt;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    /*class Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n*/}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615441,
                "title": "c-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121);\\n        for (auto& n : ages) if (n > 14) ++v[n];\\n        int ans = 0, c = 0;\\n        for (int i = 15; i <= 120; ++i){\\n            c += v[i] - v[i / 2 + 7];\\n            v[i / 2 + 7] = 0;\\n            ans += v[i] * (c - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> v(121);\\n        for (auto& n : ages) if (n > 14) ++v[n];\\n        int ans = 0, c = 0;\\n        for (int i = 15; i <= 120; ++i){\\n            c += v[i] - v[i / 2 + 7];\\n            v[i / 2 + 7] = 0;\\n            ans += v[i] * (c - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614765,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counts = [0]*121\\n        \\n        for a in ages:\\n            counts[a]+=1\\n        ans = 0\\n        \\n        for i in ages:\\n            for j in range(i, 0, -1):\\n                if i==j and counts[i]==1: continue\\n                if counts[j]==0: continue\\n                if j<=0.5*i+7: continue\\n                if i==j:\\n                    ans += counts[j]-1\\n                else:\\n                    ans += counts[j]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counts = [0]*121\\n        \\n        for a in ages:\\n            counts[a]+=1\\n        ans = 0\\n        \\n        for i in ages:\\n            for j in range(i, 0, -1):\\n                if i==j and counts[i]==1: continue\\n                if counts[j]==0: continue\\n                if j<=0.5*i+7: continue\\n                if i==j:\\n                    ans += counts[j]-1\\n                else:\\n                    ans += counts[j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522862,
                "title": "friends-of-appropriate-ages-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int, int> count;\\n        for (int &age : ages)\\n            count[age]++;\\n        int res = 0;\\n        for (auto &a : count)\\n            for (auto &b : count)\\n                if (request(a.first, b.first))\\n                    res += a.second * (b.second - (a.first == b.first ? 1 : 0));\\n        return res;\\n    }\\n\\n    bool request(int a, int b) {\\n        return !(b <= 0.5 * a + 7 || b > a || (b > 100 && a < 100));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497884,
                "title": "counting-the-number-of-people-in-different-age-using-list-no-binary-search",
                "content": "# Intuition\\nIf age i can send request to age j, the number of request is #i*#j if i!=j, else #i*(#i-1) because it wont send request to it self.\\nThus, we can group the number of people in different ages.\\nFor any age i, we need to find its bounrdary of age for sending request. There are two conditions: j<=0.5*i+7 or j>i. **Note** the first condition, event though j>0.5*i+7 but j>i, i won\\'t sent request! \\n\\n# Approach\\nGroup the people in differnt ages. Note that, if a dictionary or a Counters is used for this purpose, every time we find the lower bound of i (j>0.5*i+7, and j<i), we need to go through the age list again, which takes O(N) (binary search cost O(logN)).\\nBecause the age range is fixed, we can use a list for this purpose c = [0]*121 to indicate the age (0,120).\\nIf i>0.5*i+7, the number of request within the age group i is c\\\\[i\\\\]*(c\\\\[i\\\\]-1)\\nIf j=0.5*i+7, and j<i, j!=i, the request between age i and ages (j+1,i-1) is sum(cc\\\\[j+1:i\\\\])*c\\\\[i\\\\]\\n\\n# Complexity\\n- Time complexity:\\nGroup the ages takes O(N), loop to calculate the request O(#age), so total O(N+#age)=O(N)\\n\\n- Space complexity:\\nO(121) to store the number of people in different age\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0]*121\\n        age = set()\\n        print(sorted(ages))\\n        for i in ages:\\n            count[i]+=1\\n            age.add(i)\\n\\n        res = 0\\n        for i in age:\\n            b = i//2+7\\n            \\n            if b<i:\\n                res += (count[i]-1)*count[i]\\n            \\n            if b<=i:\\n                s = sum(count[b+1:i])\\n            else:\\n                s=0\\n            \\n            res +=s*count[i]\\n            print(i,b,s,res)\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        count = [0]*121\\n        age = set()\\n        print(sorted(ages))\\n        for i in ages:\\n            count[i]+=1\\n            age.add(i)\\n\\n        res = 0\\n        for i in age:\\n            b = i//2+7\\n            \\n            if b<i:\\n                res += (count[i]-1)*count[i]\\n            \\n            if b<=i:\\n                s = sum(count[b+1:i])\\n            else:\\n                s=0\\n            \\n            res +=s*count[i]\\n            print(i,b,s,res)\\n        return res\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475843,
                "title": "ez-understand-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven that the total number of age cohorts is predetermined, a prudent approach would involve a preliminary enumeration of each cohort, followed by a systematic examination of each group.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. To effectively analyze the data, we can compile a comprehensive list of each age and its corresponding population count, denoted as (x, y).\\n2. Next, we can systematically examine each entry in the counter list and evaluate the specified conditions.\\n3. For each instance where the condition is met, we can compute the product of the relevant figures and accumulate the results in a variable named \\'res\\'.\\n4. In the event that we need to assess the number of individuals within the same age group, we can multiply the population count of that age by the count of individuals in the same group minus one, since it is possible for each person to have a friend who is not themselves.\\n# Complexity\\n- Time complexity: O(max(N, 120)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # counter list (x, y) where x is the age and y is the number of people at that age\\n        counter = []\\n        for age in ages:\\n            new = True\\n            for i in range(len(counter)):\\n                if counter[i][0] == age:\\n                    counter[i][1] += 1\\n                    new = False\\n            if new:\\n                counter.append([age, 1])\\n        # go through the counter list and check the condition\\n        res = 0\\n        for i in range(len(counter)):\\n            for j in range(len(counter)):\\n                # check condition\\n                if counter[j][0] <= 0.5 * counter[i][0] + 7 or counter[j][0] > counter[i][0]:\\n                    continue\\n                else:\\n                    if i != j:\\n                        res += counter[j][1] * counter[i][1]\\n                    else:\\n                        if counter[j][1] > 1:\\n                            res += counter[j][1] * (counter[i][1] - 1)\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        # counter list (x, y) where x is the age and y is the number of people at that age\\n        counter = []\\n        for age in ages:\\n            new = True\\n            for i in range(len(counter)):\\n                if counter[i][0] == age:\\n                    counter[i][1] += 1\\n                    new = False\\n            if new:\\n                counter.append([age, 1])\\n        # go through the counter list and check the condition\\n        res = 0\\n        for i in range(len(counter)):\\n            for j in range(len(counter)):\\n                # check condition\\n                if counter[j][0] <= 0.5 * counter[i][0] + 7 or counter[j][0] > counter[i][0]:\\n                    continue\\n                else:\\n                    if i != j:\\n                        res += counter[j][1] * counter[i][1]\\n                    else:\\n                        if counter[j][1] > 1:\\n                            res += counter[j][1] * (counter[i][1] - 1)\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457445,
                "title": "c-binary-search-63ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int n=ages.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ages[i]>13){\\n                int x=lower_bound(ages.begin(),ages.end(),ages[i]/2 + 8)-ages.begin();\\n                int y=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n                // while(y<n && ages[y]==ages[i]) y++;\\n                if(x<y) ans+=(y-i)*(y-x-1);\\n                i=y;\\n                if(y<n) i--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(),ages.end());\\n        int n=ages.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(ages[i]>13){\\n                int x=lower_bound(ages.begin(),ages.end(),ages[i]/2 + 8)-ages.begin();\\n                int y=upper_bound(ages.begin(),ages.end(),ages[i])-ages.begin();\\n                // while(y<n && ages[y]==ages[i]) y++;\\n                if(x<y) ans+=(y-i)*(y-x-1);\\n                i=y;\\n                if(y<n) i--;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361480,
                "title": "simple-binary-search-python-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            idx1 = bisect_right(ages, ages[i])\\n            idx2 = bisect_right(ages, ages[i]*0.5+7)\\n            ans+=max(0,idx1-idx2-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            idx1 = bisect_right(ages, ages[i])\\n            idx2 = bisect_right(ages, ages[i]*0.5+7)\\n            ans+=max(0,idx1-idx2-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345251,
                "title": "javascript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount amount of people for each age. Go through hash array and check conditions for `x` and `y`. Get amount of requests by multiplying `arr[x]` and `arr[y]`. If `x` equals `y` we subtract `1` as a person will not send a friend request to themself.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    let arr = new Array(121).fill(0);\\n    let result = 0;\\n\\n    for (let i = 0; i < ages.length; i++) {\\n        arr[ages[i]]++;\\n    }\\n\\n    for (let x = 0; x < arr.length; x++) {\\n        for (let y = 0; y <= x; y++) {\\n            if (y <= (0.5 * x + 7)) {\\n                continue;\\n            } else {\\n                if (x === y) {\\n                    result += (arr[x] - 1) * arr[y];\\n                } else {\\n                    result += arr[x] * arr[y];\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\nUpdated version: one of conditions `y > (0.5 * x + 7)` so we can start `for` from this value + 1 to reduce iterations and make it really shorter.\\n\\n```\\n/* Hide the same code... */\\n\\nfor (let x = 0; x < arr.length; x++) {\\n    for (let y = Math.floor(0.5 * x + 7) + 1; y <= x; y++) {\\n        result += (arr[x] - (x === y)) * arr[y];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    let arr = new Array(121).fill(0);\\n    let result = 0;\\n\\n    for (let i = 0; i < ages.length; i++) {\\n        arr[ages[i]]++;\\n    }\\n\\n    for (let x = 0; x < arr.length; x++) {\\n        for (let y = 0; y <= x; y++) {\\n            if (y <= (0.5 * x + 7)) {\\n                continue;\\n            } else {\\n                if (x === y) {\\n                    result += (arr[x] - 1) * arr[y];\\n                } else {\\n                    result += arr[x] * arr[y];\\n                }\\n            }\\n        }\\n    }\\n\\n    return result;\\n};\\n```\n```\\n/* Hide the same code... */\\n\\nfor (let x = 0; x < arr.length; x++) {\\n    for (let y = Math.floor(0.5 * x + 7) + 1; y <= x; y++) {\\n        result += (arr[x] - (x === y)) * arr[y];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341362,
                "title": "no-need-to-sort-o-n-solution",
                "content": "# Intuition\\nAge constraint is very less(<=120). Bucket map can be created to hold count of people by age\\n\\n# Approach\\nWith given condition, friend request can be sent to only people with age greater than ages[i]/2+7 and lesser than ages[i]. \\nAnd map[ages[i]]-map[cond]-1 will give us total no of people that can be friend listed\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(121)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int map[]=new int[121];\\n        for(int j=0;j<ages.length;j++){\\n            map[ages[j]]++;\\n        }\\n\\n        for(int i=1;i<=120;i++){\\n            map[i]+=map[i-1];\\n        }\\n        int totalFriend=0;\\n        for(int i=0;i<ages.length;i++){\\n            int cond=ages[i]/2+7;\\n            if(cond>=ages[i]){\\n                continue;\\n            }\\n            totalFriend+=map[ages[i]]-map[cond]-1;\\n        }\\n        return totalFriend;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299954,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool check(int A, int B){\\n        if(B <= 0.5 * A + 7 )\\n            return false ;\\n        if(B > A)\\n            return false ;\\n        if(B > 100 && A < 100)\\n            return false ;\\n        return true ;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ret = 0 ;\\n        unordered_map<int, int>Map ; //{age, count}  \\n        for(auto& a : ages)\\n            Map[a]++ ;\\n        \\n        for(auto& [ageA, numA] : Map)\\n        {\\n            for(auto& [ageB, numB] : Map)\\n            {\\n                if(check(ageA, ageB)){\\n                    if(ageA == ageB)\\n                        ret += numA * (numA - 1) ; \\n                    else\\n                        ret += numA * numB ;\\n                }\\n            }\\n        }    \\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool check(int A, int B){\\n        if(B <= 0.5 * A + 7 )\\n            return false ;\\n        if(B > A)\\n            return false ;\\n        if(B > 100 && A < 100)\\n            return false ;\\n        return true ;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int ret = 0 ;\\n        unordered_map<int, int>Map ; //{age, count}  \\n        for(auto& a : ages)\\n            Map[a]++ ;\\n        \\n        for(auto& [ageA, numA] : Map)\\n        {\\n            for(auto& [ageB, numB] : Map)\\n            {\\n                if(check(ageA, ageB)){\\n                    if(ageA == ageB)\\n                        ret += numA * (numA - 1) ; \\n                    else\\n                        ret += numA * numB ;\\n                }\\n            }\\n        }    \\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232791,
                "title": "c-solution-time-o-n-space-o-1-hashmap-and-prefix-sum",
                "content": "# Intuition\\nMake a prefix array to store the count of people till the age (age == index).\\nTo make prefix array first we will make a hashmap to store count of people of particular age (without sorting);\\n\\n# Approach\\n- Make a **count** array to store the count of people of particular age.\\n- Make a **prefixSum** array to store the count of people less than or equal to the current age (index).\\n- Traverse the **prefixSum** array and add the number of people satisfy the condition given in question in contant time.\\n- Please **upvote** if you find approach helpful.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n\\n        for(auto it: ages) {\\n            count[it]++;\\n        }\\n\\n        vector<int> prefixSum(121, 0);\\n        for(int i=1; i<121; i++) {\\n            prefixSum[i] = prefixSum[i-1] + count[i];\\n        }\\n\\n        int res = 0;\\n        for(int i=1; i<121; i++) {\\n            int min = (i/2) + 7;\\n            if(min >= i) {\\n                continue;\\n            }\\n\\n            res += (count[i] * (count[i] - 1));\\n            res += (prefixSum[i-1] - prefixSum[min]) * count[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        vector<int> count(121, 0);\\n\\n        for(auto it: ages) {\\n            count[it]++;\\n        }\\n\\n        vector<int> prefixSum(121, 0);\\n        for(int i=1; i<121; i++) {\\n            prefixSum[i] = prefixSum[i-1] + count[i];\\n        }\\n\\n        int res = 0;\\n        for(int i=1; i<121; i++) {\\n            int min = (i/2) + 7;\\n            if(min >= i) {\\n                continue;\\n            }\\n\\n            res += (count[i] * (count[i] - 1));\\n            res += (prefixSum[i-1] - prefixSum[min]) * count[i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228546,
                "title": "c-solution-using-map-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> temp;\\n        int req=0;\\n        for(int i:ages)   //storing value and its frequency in map\\n            temp[i]++;\\n        for(auto &a:temp)\\n            for(auto &b:temp)\\n            {\\n                if(checkt(a.first,b.first))  //checking for the conditions for friends request\\n                {\\n                    if(a.first==b.first)  //if frequency of that age is more than one\\n                        req+=(a.second)*(b.second-1);\\n                    else                 //if it occured only once in map\\n                        req+=(a.second)*(b.second);\\n                }\\n            }\\n        return req;   //returning the request\\n    }\\n    bool checkt(int a,int b)\\n    {\\n        return !(b <= 0.5 * a + 7 || b > a );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        unordered_map<int,int> temp;\\n        int req=0;\\n        for(int i:ages)   //storing value and its frequency in map\\n            temp[i]++;\\n        for(auto &a:temp)\\n            for(auto &b:temp)\\n            {\\n                if(checkt(a.first,b.first))  //checking for the conditions for friends request\\n                {\\n                    if(a.first==b.first)  //if frequency of that age is more than one\\n                        req+=(a.second)*(b.second-1);\\n                    else                 //if it occured only once in map\\n                        req+=(a.second)*(b.second);\\n                }\\n            }\\n        return req;   //returning the request\\n    }\\n    bool checkt(int a,int b)\\n    {\\n        return !(b <= 0.5 * a + 7 || b > a );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202645,
                "title": "java-group-by-age-and-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Looking at the input data, the ages are between 1 and 120. \\nIf person of age X can send a friend request to person of age Y, it means ALL people of age X can sent requests to ALL people of age Y.\\nThis means it makes more sense to COUNT each age in an int[121]\\n2. Looking at the criteria age[y] > age[x], we see a younger person cannot befriend an older person.\\nSo we have to traverse this array from right to left, checking if person of age 120 can befriend age 120, 119..1.\\n3. If can yes, if i == j (same group) add the permutation (n! / (n-2)!) which is n * (n-1).\\nif i !=j, then add their multiplication. (group[i] * group[j]).\\n\\n# Complexity\\n- Time complexity:$$O(n + 120 * 120)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(121)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleAges = new int[121];\\n        int requests = 0;\\n        for (int age : ages) {\\n            peopleAges[age]++;\\n        }\\n        for (int i = peopleAges.length -1; i>= 1; i--) {\\n            if (peopleAges[i] > 0) {\\n                boolean canBefriend = true;\\n                for (int j = i; j >= 1 && canBefriend; j--) {\\n                    if (peopleAges[j] > 0 && (canBefriend = canBefriend(i, j))) {\\n                        requests += (i == j ? peopleAges[i] * (peopleAges[i]-1) : peopleAges[i] * peopleAges[j]);   \\n                    }\\n                }\\n            }\\n        }\\n        return requests;\\n    }\\n\\n    private boolean canBefriend(int i, int j) {\\n        return !(j <= 0.5 * i + 7 || j > 100 && i < 100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        int[] peopleAges = new int[121];\\n        int requests = 0;\\n        for (int age : ages) {\\n            peopleAges[age]++;\\n        }\\n        for (int i = peopleAges.length -1; i>= 1; i--) {\\n            if (peopleAges[i] > 0) {\\n                boolean canBefriend = true;\\n                for (int j = i; j >= 1 && canBefriend; j--) {\\n                    if (peopleAges[j] > 0 && (canBefriend = canBefriend(i, j))) {\\n                        requests += (i == j ? peopleAges[i] * (peopleAges[i]-1) : peopleAges[i] * peopleAges[j]);   \\n                    }\\n                }\\n            }\\n        }\\n        return requests;\\n    }\\n\\n    private boolean canBefriend(int i, int j) {\\n        return !(j <= 0.5 * i + 7 || j > 100 && i < 100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159901,
                "title": "python-binary-search-solution-92-faster",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = dict()\\n\\n        for age in ages:\\n            if age in counter:\\n                counter[age] += 1\\n            else:\\n                counter[age] = 1\\n\\n        res = 0\\n        keys = sorted(list(counter.keys()))\\n        val = [counter[key] for key in keys]\\n        prefix = [val[0]]\\n        for i in range(1,len(keys)):prefix.append(prefix[-1] + val[i])\\n\\n        x = (0.5 * keys[0])+ 7\\n        if keys[0] > x:res += (counter[keys[0]] - 1) * counter[keys[0]]\\n\\n        for i in range(1,len(keys)):\\n            x = (0.5 * keys[i])+ 7\\n\\n            if keys[i] > x:res += (counter[keys[i]] - 1) * counter[keys[i]]\\n\\n            index = bisect.bisect_right(keys,x)\\n            \\n            cur = prefix[i-1]\\n            if index > 0:cur -= prefix[index-1]\\n            cur *= counter[keys[i]]\\n            res += max(0,cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        counter = dict()\\n\\n        for age in ages:\\n            if age in counter:\\n                counter[age] += 1\\n            else:\\n                counter[age] = 1\\n\\n        res = 0\\n        keys = sorted(list(counter.keys()))\\n        val = [counter[key] for key in keys]\\n        prefix = [val[0]]\\n        for i in range(1,len(keys)):prefix.append(prefix[-1] + val[i])\\n\\n        x = (0.5 * keys[0])+ 7\\n        if keys[0] > x:res += (counter[keys[0]] - 1) * counter[keys[0]]\\n\\n        for i in range(1,len(keys)):\\n            x = (0.5 * keys[i])+ 7\\n\\n            if keys[i] > x:res += (counter[keys[i]] - 1) * counter[keys[i]]\\n\\n            index = bisect.bisect_right(keys,x)\\n            \\n            cur = prefix[i-1]\\n            if index > 0:cur -= prefix[index-1]\\n            cur *= counter[keys[i]]\\n            res += max(0,cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141346,
                "title": "java-solution-with-seperate-int-array",
                "content": "# Intuition/Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly I looked at the lowest number that can send/recieve friend requests. This turns out to be 15 as 15*0.5+7=14.5, which is lower than 15. Additionally 15 is not larger than 15.\\n\\nWith every other n (1<=n<=14) this won\\'t work. \\nI.e. 14*0.5+7 =14 which is equal to 14 and therefore wont work according to the first rule (age[y] <= 0.5 * age[x] + 7 =>will not send a friend request );\\n\\nAfter this one can add up every number with equal value in a seperate int[] Array with the length of 121 as 1<=n<=120. \\n\\nNext one can add up every possible friend Request between certain ages. \\nWithin the same age>=15 every person of that age can send every other person of the same age a friend request. \\nfriendRequests+=(sameNumbers-1)*sameNumbers; \\nHere numbers are the individual ages.\\n\\nEvery person of a certain age can send friend requests to people of lower ages who are equal to age/2+7+1.\\nThe total amount of people of lower ages which a specific age can send friend requests to are summed up in a loop.\\nFinally the total amount of people of a certain age send friend requests to people of lower ages up to the lower bound (age/2+7+1).\\n\\nfriendRequests+=validLowerNumbers*sameNumbers;\\n\\nFinally this can be done for every age individually and summed up and returned.\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int friendRequests=0;\\n    int[] totalCount= new int[121];\\n\\n    public int numFriendRequests(int[] ages) {\\n        \\n        for(int a=0;a<ages.length;a++)\\n        {\\n            totalCount[ages[a]]+=1;\\n        }\\n\\n        int sameNumbers;\\n        int validLowerNumbers=0;\\n        \\n        for(int a=15; a<121;a++)\\n        {\\n            int lowestAccepted= a/2+7+1;\\n            sameNumbers=totalCount[a];\\n\\n            validLowerNumbers=0;\\n\\n            for(int b=lowestAccepted; b<a;b++)\\n            {\\n                validLowerNumbers+=totalCount[b];\\n            }\\n            friendRequests+=(sameNumbers-1)*sameNumbers;\\n            friendRequests+=validLowerNumbers*sameNumbers;\\n        }\\n        \\n        return friendRequests;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int friendRequests=0;\\n    int[] totalCount= new int[121];\\n\\n    public int numFriendRequests(int[] ages) {\\n        \\n        for(int a=0;a<ages.length;a++)\\n        {\\n            totalCount[ages[a]]+=1;\\n        }\\n\\n        int sameNumbers;\\n        int validLowerNumbers=0;\\n        \\n        for(int a=15; a<121;a++)\\n        {\\n            int lowestAccepted= a/2+7+1;\\n            sameNumbers=totalCount[a];\\n\\n            validLowerNumbers=0;\\n\\n            for(int b=lowestAccepted; b<a;b++)\\n            {\\n                validLowerNumbers+=totalCount[b];\\n            }\\n            friendRequests+=(sameNumbers-1)*sameNumbers;\\n            friendRequests+=validLowerNumbers*sameNumbers;\\n        }\\n        \\n        return friendRequests;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116814,
                "title": "functional-o-n-69ms-runtime-nice",
                "content": "# Intuition\\n\\n* People below age 15 are not able to request or be requested by anyone, because of the first condition.\\n* The third condition is a red herring.\\n* To solve for just the second condition, we can iterate through a mapping of the number of people by age, and add to a running total of requests as well as a running total of lower aged people.\\n  * The running total of lower aged people is used to compute how many people someone at the current age would request, which can then be multiplied by how many people have that current age and added into the running total of requests.\\n  * To extend this to account for the first condition as well, we change our running total of lower aged people into the number of people who should still be requested.\\n    * We update the running total of lower aged people to still request as people \\'age out\\', which happens at every other age we visit because of the `0.5`(aka `1 / 2`) in the first condition.\\n\\n# Approach\\nMake a mapping of the number of people by age, and then reduce it to the total requests, utilizing an appropriate running number of people who should still be requested, as we compute all the requests happening at or below each age. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction numFriendRequests(ages: number[]): number {\\n    const numOfPeopleByAge = new Array(120 + 1).fill(0, 15, 120 + 1) ; ages.forEach(age => {\\n        if (age >= 15)\\n            numOfPeopleByAge[age]++\\n    })\\n    const [_, totalRequests] = numOfPeopleByAge.reduce(\\n        ([lowerAgedPeopleToRequest, totalRequests], numOfPeopleWithCurrentAge, currentAge, numOfPeopleByAge) => {\\n            if (currentAge % 2 == 0)\\n                lowerAgedPeopleToRequest -= numOfPeopleByAge[0.5 * currentAge + 7]\\n            const numOfPeopleToRequestAtCurrentAge = (numOfPeopleWithCurrentAge - 1 + lowerAgedPeopleToRequest)\\n            totalRequests += numOfPeopleToRequestAtCurrentAge * numOfPeopleWithCurrentAge\\n            lowerAgedPeopleToRequest += numOfPeopleWithCurrentAge\\n            return [lowerAgedPeopleToRequest, totalRequests]\\n        }, [0, 0])\\n    return totalRequests\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numFriendRequests(ages: number[]): number {\\n    const numOfPeopleByAge = new Array(120 + 1).fill(0, 15, 120 + 1) ; ages.forEach(age => {\\n        if (age >= 15)\\n            numOfPeopleByAge[age]++\\n    })\\n    const [_, totalRequests] = numOfPeopleByAge.reduce(\\n        ([lowerAgedPeopleToRequest, totalRequests], numOfPeopleWithCurrentAge, currentAge, numOfPeopleByAge) => {\\n            if (currentAge % 2 == 0)\\n                lowerAgedPeopleToRequest -= numOfPeopleByAge[0.5 * currentAge + 7]\\n            const numOfPeopleToRequestAtCurrentAge = (numOfPeopleWithCurrentAge - 1 + lowerAgedPeopleToRequest)\\n            totalRequests += numOfPeopleToRequestAtCurrentAge * numOfPeopleWithCurrentAge\\n            lowerAgedPeopleToRequest += numOfPeopleWithCurrentAge\\n            return [lowerAgedPeopleToRequest, totalRequests]\\n        }, [0, 0])\\n    return totalRequests\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3060571,
                "title": "fast-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a counting sort to store the number of people for each age. Then, for each person, we can check the number of people with age greater than the person\\'s age and less than the person\\'s age times 0.5 + 7. We need to exclude the case when age i equals age j.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a count array of length 121 to store the number of people for each age.\\n2. For each age in the given ages array, increment the corresponding count array index.\\n3. For each age i in the range 15 to 120:\\n   1. For each age j in the range 15 to 120:\\n      1. If age i is less than or equal to age j times 0.5 + 7, skip this iteration.\\n      2. If age i is less than age j, skip this iteration.\\n      3. If age i is greater than 100 and age j is less than 100, skip this iteration.\\n      4. Add the number of people with age i to the result multiplied by the number of people with age j, excluding the cases when i and j are the same age.\\n4. Return the result.\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n * m), where n and m are the maximum ages in the given array. This is because we need to loop through the entire array of ages, and for each age, we need to loop through every age from 15 to 120.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is O(1), as we only use a count array of fixed size 121.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int res = 0;\\n        vector<int> count(121);\\n        for (int age : ages) ++count[age];\\n        for (int i = 15; i <= 120; ++i)\\n            for (int j = 15; j <= 120; ++j) {\\n                if (i * 0.5 + 7 >= j) continue;\\n                if (i < j) continue;\\n                if (i < 100 && 100 < j) continue;\\n                res += count[i] * (count[j] - (i == j));\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        int res = 0;\\n        vector<int> count(121);\\n        for (int age : ages) ++count[age];\\n        for (int i = 15; i <= 120; ++i)\\n            for (int j = 15; j <= 120; ++j) {\\n                if (i * 0.5 + 7 >= j) continue;\\n                if (i < j) continue;\\n                if (i < 100 && 100 < j) continue;\\n                res += count[i] * (count[j] - (i == j));\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054171,
                "title": "basic-solution-using-maps-cpp",
                "content": "# Explanation :\\n```\\npush all the ages into a hash map \\n\\nmaintaining the count of each age\\nwe will check for each age number(key) in map to which age group can\\nthey send an request \\n\\nmake a function to check all the constraints by sending two ages :\\none fixed by first for loop \\nsecond will be traversing the whole map one by one ;\\n\\nwhen ages will be same in the both loops \\neach person can send **(count-1)** requests to this same group \\n```\\n# Code\\n```\\nclass Solution {\\n\\n    bool canNotBeFriends(int x,int y){\\n            if(y<=0.5*x+7)\\n                return true;\\n            if(y>x)\\n                return true;\\n            if(y>100 && x<100)\\n                return true;\\n            return false;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        map<int,int> mp;\\n        int x,y,total=0;\\n        for(auto val: ages)\\n            mp[val]++;\\n        for(auto it1: mp){\\n            x=it1.first;\\n            for(auto it2: mp){\\n                y=it2.first;\\n                if(canNotBeFriends(x,y)){\\n                    continue;\\n                }\\n                if(x==y)\\n                    total+=(mp[x]-1)*mp[x];\\n                else\\n                    total+=mp[x]*mp[y];\\n\\n            }\\n        }\\n        return total ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npush all the ages into a hash map \\n\\nmaintaining the count of each age\\nwe will check for each age number(key) in map to which age group can\\nthey send an request \\n\\nmake a function to check all the constraints by sending two ages :\\none fixed by first for loop \\nsecond will be traversing the whole map one by one ;\\n\\nwhen ages will be same in the both loops \\neach person can send **(count-1)** requests to this same group \\n```\n```\\nclass Solution {\\n\\n    bool canNotBeFriends(int x,int y){\\n            if(y<=0.5*x+7)\\n                return true;\\n            if(y>x)\\n                return true;\\n            if(y>100 && x<100)\\n                return true;\\n            return false;\\n    }\\npublic:\\n    int numFriendRequests(vector<int>& ages) {\\n        map<int,int> mp;\\n        int x,y,total=0;\\n        for(auto val: ages)\\n            mp[val]++;\\n        for(auto it1: mp){\\n            x=it1.first;\\n            for(auto it2: mp){\\n                y=it2.first;\\n                if(canNotBeFriends(x,y)){\\n                    continue;\\n                }\\n                if(x==y)\\n                    total+=(mp[x]-1)*mp[x];\\n                else\\n                    total+=mp[x]*mp[y];\\n\\n            }\\n        }\\n        return total ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047636,
                "title": "beats-100-time-and-space",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    // initiate 0 filled array for hash\\n    let hash = new Array(122).fill(0);\\n    \\n    // makes a normal hash of ages\\n    for(let i = 0; i < ages.length; i++) {\\n        const currAge = ages[i];\\n        hash[currAge]++;\\n    }\\n\\n    // turns hash into \"running hash\" that keeps total number so far\\n    let count = 0;\\n    for(let i = 0; i < hash.length - 1; i++) {\\n        hash[i] = count;\\n        count += hash[i + 1];\\n    }\\n\\n    // loops through ages and checks how many friends each person will have\\n    // add each persons friends to total\\n    let total = 0;\\n    for(let i = 0; i < ages.length; i++) {\\n        const age = ages[i];\\n\\n        // bottom cutoff for friends\\n        let index = Math.floor(age / 2 + 7);\\n        let bottom = hash[index];\\n        // top cutoff for friends\\n        let top = hash[age] - 1;\\n        // subtract top from bottom since hash uses running total;\\n        let addToTotal = (top - bottom);\\n\\n        // cannot subtract friends\\n        if(addToTotal > 0) total += addToTotal;\\n    }\\n\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} ages\\n * @return {number}\\n */\\nvar numFriendRequests = function(ages) {\\n    // initiate 0 filled array for hash\\n    let hash = new Array(122).fill(0);\\n    \\n    // makes a normal hash of ages\\n    for(let i = 0; i < ages.length; i++) {\\n        const currAge = ages[i];\\n        hash[currAge]++;\\n    }\\n\\n    // turns hash into \"running hash\" that keeps total number so far\\n    let count = 0;\\n    for(let i = 0; i < hash.length - 1; i++) {\\n        hash[i] = count;\\n        count += hash[i + 1];\\n    }\\n\\n    // loops through ages and checks how many friends each person will have\\n    // add each persons friends to total\\n    let total = 0;\\n    for(let i = 0; i < ages.length; i++) {\\n        const age = ages[i];\\n\\n        // bottom cutoff for friends\\n        let index = Math.floor(age / 2 + 7);\\n        let bottom = hash[index];\\n        // top cutoff for friends\\n        let top = hash[age] - 1;\\n        // subtract top from bottom since hash uses running total;\\n        let addToTotal = (top - bottom);\\n\\n        // cannot subtract friends\\n        if(addToTotal > 0) total += addToTotal;\\n    }\\n\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3044407,
                "title": "easy-c-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint helper(vector<int>&ages,int target)\\n{\\n    int low=0;\\n    int high=ages.size()-1;\\n    while(low<=high)\\n    {\\n        int mid=low+(high-low)/2;\\n        if (ages[mid]<=target)\\n        low=mid+1;\\n        else high=mid-1;\\n    }\\n    return low;\\n}\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        sort(ages.begin(),ages.end());\\n        int ans=0;\\n        for (int i=0;i<ages.size();i++)\\n        {\\n            int lower=helper(ages,ages[i]*0.5+7);\\n            int higher=helper(ages,ages[i]);\\n            ans+=max(higher-lower-1,0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint helper(vector<int>&ages,int target)\\n{\\n    int low=0;\\n    int high=ages.size()-1;\\n    while(low<=high)\\n    {\\n        int mid=low+(high-low)/2;\\n        if (ages[mid]<=target)\\n        low=mid+1;\\n        else high=mid-1;\\n    }\\n    return low;\\n}\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        sort(ages.begin(),ages.end());\\n        int ans=0;\\n        for (int i=0;i<ages.size();i++)\\n        {\\n            int lower=helper(ages,ages[i]*0.5+7);\\n            int higher=helper(ages,ages[i]);\\n            ans+=max(higher-lower-1,0);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028823,
                "title": "python-binary-search",
                "content": "# Complexity\\n- Time complexity: $O(n\\\\log n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        def get_candidates(i):\\n            if i == 0: return 0\\n            if ages[i]<=14: return 0\\n\\n            if ages[i-1]<=0.5*ages[i]+7: return 0\\n\\n            l, r = 0, i-1\\n            while l<=r:\\n                mid = (l+r)//2\\n                if ages[mid]<=0.5*ages[i]+7:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n            if ages[mid]<=0.5*ages[i]+7:\\n                mid  += 1\\n\\n            return i-mid\\n        \\n\\n        ages.sort()\\n        n = len(ages)\\n        res = 0\\n\\n        prev = 0\\n        prev_cnt = 0\\n        for i in range(n):\\n            if ages[i]<=14: continue\\n\\n            if i>=1 and ages[i] == ages[i-1]:\\n                prev_cnt += 1\\n                prev = prev + 1\\n                res += prev + prev_cnt\\n                continue\\n\\n\\n            candidates = get_candidates(i)\\n            res += candidates\\n\\n            prev = candidates\\n            prev_cnt = 0\\n\\n\\n        return res\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        def get_candidates(i):\\n            if i == 0: return 0\\n            if ages[i]<=14: return 0\\n\\n            if ages[i-1]<=0.5*ages[i]+7: return 0\\n\\n            l, r = 0, i-1\\n            while l<=r:\\n                mid = (l+r)//2\\n                if ages[mid]<=0.5*ages[i]+7:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n\\n            if ages[mid]<=0.5*ages[i]+7:\\n                mid  += 1\\n\\n            return i-mid\\n        \\n\\n        ages.sort()\\n        n = len(ages)\\n        res = 0\\n\\n        prev = 0\\n        prev_cnt = 0\\n        for i in range(n):\\n            if ages[i]<=14: continue\\n\\n            if i>=1 and ages[i] == ages[i-1]:\\n                prev_cnt += 1\\n                prev = prev + 1\\n                res += prev + prev_cnt\\n                continue\\n\\n\\n            candidates = get_candidates(i)\\n            res += candidates\\n\\n            prev = candidates\\n            prev_cnt = 0\\n\\n\\n        return res\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993868,
                "title": "c-tricky-problem-detail-explanation-with-comment",
                "content": "**NOTE :** Start reading solution from ```numFriendRequests``` function. I have explained my approach and thought process in the code itself.\\n```\\nclass Solution {\\npublic:\\n    \\n    int binarySearch1(vector<int>& arr, int start, int end, double tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(1.0*arr[mid]<=tgt){\\n                end= mid-1;\\n            }\\n            else if(1.0*arr[mid]>tgt){\\n                potCand=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return potCand;\\n    }\\n    \\n    int binarySearch3(vector<int>& arr, int start, int end, int tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(arr[mid]<=tgt){\\n                potCand=mid;\\n                end= mid-1;\\n            }\\n            else if(arr[mid]>tgt){\\n                start= mid+1;\\n            }\\n        }\\n        return potCand;\\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end(), greater<int>()); // Non-increasingly sort\\n        \\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++){\\n            double tgt= 1.0*ages[i];  // target\\n            \\n            /*\\n                1. (arr[y] > arr[x]/2 +7) &&\\n                2. (arr[y] <= arr[x]) &&\\n                3. (arr[x]>=100 || arr[y]<=100)\\n            */\\n            \\n            int idx1= binarySearch1(ages, i, ages.size()-1, 0.5*tgt+7); // cond 1 : arr[y] > arr[x]/2 +7\\n            // valid positions are [i-idx1]\\n            if(idx1==-1){ continue; }\\n            \\n            int idx2= ages.size()-1; // cond 2 : arr[y] <= arr[x]\\n            // valid positions are [i-idx2]\\n            \\n            int idx3;\\n            if(ages[i]>=100){ idx3= i; } // all index of y are valid\\n            else{\\n                idx3= binarySearch3(ages, i, ages.size()-1, 100); // cond 3: arr[y] <=100\\n                if(idx3==-1){ continue; }\\n            }\\n            // valid positions are [idx3-ages.size()-1]\\n            \\n            // cout<<idx1<<\" \"<<idx2<<\" \"<<idx3<<endl;\\n            \\n            // Now we need intersection of all 3 conditions.\\n            int finalIdxHigh= min(idx1, idx2);\\n            int finalIdxLow= max(i, idx3);\\n            \\n            ans+=(finalIdxHigh-finalIdxLow);\\n            if(finalIdxLow>i){ ans++; }   \\n        }\\n        \\n        /*\\n            \\uD83D\\uDC49 Now here is a catch : assume [16,16] (repeating case).\\n            \\uD83D\\uDC49 Now when we are at i(here x), we are taking care of all index in [i,size-1]. So, when we are at 0th idx, we are taking care of indexes from [0,1], \\n            and we get at pair ( 0-->1 ), but in this case ( 1-->0 ) is also a valid pair which we are missing.\\n            \\uD83D\\uDC49 For this reason we are storing freq of each element and handling repeating case separately below.\\n\\n            \\uD83D\\uDC49 For eg: assume [16,16,16]\\n            \\uD83D\\uDC49 Above process will handle cases like (0->1), (0->2), (1->2); so ans=3. But we are missing cases like (1->0), (2->1), (2->0). \\n            \\uD83D\\uDC49 From hashmap, we know m[16]=3 (freq). So we just add ans+=((3-1)*3)/2;\\n        */\\n        \\n        unordered_map<int, int> m; // {element, freq}\\n        for(auto it: ages){  m[it]++;  }\\n        \\n        for(auto it: m){\\n            int num= it.first; int n= it.second;\\n            bool flag= 1.0*num > 0.5*num +7;\\n            if(n>1 && flag==true){\\n                ans+=((n-1)*n)/2; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThanks !",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```numFriendRequests```\n```\\nclass Solution {\\npublic:\\n    \\n    int binarySearch1(vector<int>& arr, int start, int end, double tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(1.0*arr[mid]<=tgt){\\n                end= mid-1;\\n            }\\n            else if(1.0*arr[mid]>tgt){\\n                potCand=mid;\\n                start=mid+1;\\n            }\\n        }\\n        \\n        return potCand;\\n    }\\n    \\n    int binarySearch3(vector<int>& arr, int start, int end, int tgt){\\n        int potCand=-1;\\n        while(start<=end){\\n            int mid= start + (end-start)/2;\\n            \\n            if(arr[mid]<=tgt){\\n                potCand=mid;\\n                end= mid-1;\\n            }\\n            else if(arr[mid]>tgt){\\n                start= mid+1;\\n            }\\n        }\\n        return potCand;\\n    }\\n    \\n    int numFriendRequests(vector<int>& ages) {\\n        sort(ages.begin(), ages.end(), greater<int>()); // Non-increasingly sort\\n        \\n        int ans=0;\\n        for(int i=0; i<ages.size(); i++){\\n            double tgt= 1.0*ages[i];  // target\\n            \\n            /*\\n                1. (arr[y] > arr[x]/2 +7) &&\\n                2. (arr[y] <= arr[x]) &&\\n                3. (arr[x]>=100 || arr[y]<=100)\\n            */\\n            \\n            int idx1= binarySearch1(ages, i, ages.size()-1, 0.5*tgt+7); // cond 1 : arr[y] > arr[x]/2 +7\\n            // valid positions are [i-idx1]\\n            if(idx1==-1){ continue; }\\n            \\n            int idx2= ages.size()-1; // cond 2 : arr[y] <= arr[x]\\n            // valid positions are [i-idx2]\\n            \\n            int idx3;\\n            if(ages[i]>=100){ idx3= i; } // all index of y are valid\\n            else{\\n                idx3= binarySearch3(ages, i, ages.size()-1, 100); // cond 3: arr[y] <=100\\n                if(idx3==-1){ continue; }\\n            }\\n            // valid positions are [idx3-ages.size()-1]\\n            \\n            // cout<<idx1<<\" \"<<idx2<<\" \"<<idx3<<endl;\\n            \\n            // Now we need intersection of all 3 conditions.\\n            int finalIdxHigh= min(idx1, idx2);\\n            int finalIdxLow= max(i, idx3);\\n            \\n            ans+=(finalIdxHigh-finalIdxLow);\\n            if(finalIdxLow>i){ ans++; }   \\n        }\\n        \\n        /*\\n            \\uD83D\\uDC49 Now here is a catch : assume [16,16] (repeating case).\\n            \\uD83D\\uDC49 Now when we are at i(here x), we are taking care of all index in [i,size-1]. So, when we are at 0th idx, we are taking care of indexes from [0,1], \\n            and we get at pair ( 0-->1 ), but in this case ( 1-->0 ) is also a valid pair which we are missing.\\n            \\uD83D\\uDC49 For this reason we are storing freq of each element and handling repeating case separately below.\\n\\n            \\uD83D\\uDC49 For eg: assume [16,16,16]\\n            \\uD83D\\uDC49 Above process will handle cases like (0->1), (0->2), (1->2); so ans=3. But we are missing cases like (1->0), (2->1), (2->0). \\n            \\uD83D\\uDC49 From hashmap, we know m[16]=3 (freq). So we just add ans+=((3-1)*3)/2;\\n        */\\n        \\n        unordered_map<int, int> m; // {element, freq}\\n        for(auto it: ages){  m[it]++;  }\\n        \\n        for(auto it: m){\\n            int num= it.first; int n= it.second;\\n            bool flag= 1.0*num > 0.5*num +7;\\n            if(n>1 && flag==true){\\n                ans+=((n-1)*n)/2; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2945359,
                "title": "python3-concise-solution-beats-99",
                "content": "# Counter + Binary Search + Math\\n# Time complexity: \\nmax(O(121*log(121)), N), N = len(ages)\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages):\\n        count = [0] * 121                               # counter: count frequency of each age\\n        for age in ages:\\n            count[age] += 1\\n        prefix = [0] * 121                              # prefix-sum: prefix sum of frequency, we will use this for range subtraction\\n        for i in range(1, 121):\\n            prefix[i] = prefix[i-1] + count[i]\\n        nums = [i for i in range(121)]                  # a dummy age list, which will be used in binary search\\n        ans = 0\\n        for age, cnt in enumerate(count):\\n            if not cnt: continue\\n            lb = age                                    # lower bound\\n            ub = (age - 7) * 2                          # upper bound\\n            i = bisect.bisect_left(nums, lb)            # binary search on lower bound, O(log(121))\\n            j = bisect.bisect_left(nums, ub)            # binary search on upper bound, O(log(121))\\n            if j - i <= 0: continue\\n            total = prefix[j-1] - prefix[i-1]           # range subtraction - how many ages in total can be considered as friend, including current age itself\\n            if lb <= age < ub:                          # considering itself, e.g. [17, 17, 17]\\n                # total -= cnt                          # minus itself\\n                # total = (cnt - 1) * cnt + total * cnt # make friends with other at same age `(cnt-1) * cnt`; with other at different age `total * cnt`\\n                total = cnt * (total - 1)               # a cleaner presentation of above two lines\\n            ans += total    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931880,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut count = vec![0; 121];\\n        for age in ages {\\n            count[age as usize] += 1;\\n        }\\n        let mut result = 0;\\n        for age in 1..=120 {\\n            if count[age] == 0 {\\n                continue;\\n            }\\n            for other in (age / 2 + 8)..=age {\\n                if count[other] == 0 {\\n                    continue;\\n                }\\n                if age == other {\\n                    result += count[age] * (count[age] - 1);\\n                } else {\\n                    result += count[age] * count[other];\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut count = vec![0; 121];\\n        for age in ages {\\n            count[age as usize] += 1;\\n        }\\n        let mut result = 0;\\n        for age in 1..=120 {\\n            if count[age] == 0 {\\n                continue;\\n            }\\n            for other in (age / 2 + 8)..=age {\\n                if count[other] == 0 {\\n                    continue;\\n                }\\n                if age == other {\\n                    result += count[age] * (count[age] - 1);\\n                } else {\\n                    result += count[age] * count[other];\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2913512,
                "title": "java-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numFriendRequests(int[] ages) {\\n        Arrays.sort(ages);\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:ages){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int count=0;\\n        for(int i1:map.keySet())\\n        {\\n            for(int i2:map.keySet()){\\n                if(help(i1,i2)){\\n                    count+=map.get(i1)*map.get(i2);\\n                    if(i1==i2)count-=map.get(i1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public static boolean help(int i1,int i2)\\n    {\\n        return i1<=(int)((i2/2)+7) || i1>i2?false:true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895031,
                "title": "o-120-2-python-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def doSend(x, y):\\n            if 0.5 * x + 7 >= y:\\n                return False\\n\\n            if x < y:\\n                return False\\n\\n            if x < 100 and y > 100:\\n                return False\\n\\n            return True\\n\\n        counter = collections.Counter(ages)\\n        ans = 0\\n        ages = sorted(counter.keys())\\n        print(ages)\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                isSent = doSend(ages[i], ages[j])\\n                if ages[i] == ages[j]:\\n                    if isSent:\\n                        ans += ((counter[ages[i]] - 1) * counter[ages[i]])\\n                        \\n                else:\\n                    if isSent:\\n                        ans += (counter[ages[i]] * counter[ages[j]])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def doSend(x, y):\\n            if 0.5 * x + 7 >= y:\\n                return False\\n\\n            if x < y:\\n                return False\\n\\n            if x < 100 and y > 100:\\n                return False\\n\\n            return True\\n\\n        counter = collections.Counter(ages)\\n        ans = 0\\n        ages = sorted(counter.keys())\\n        print(ages)\\n        for i in range(len(ages)):\\n            for j in range(len(ages)):\\n                isSent = doSend(ages[i], ages[j])\\n                if ages[i] == ages[j]:\\n                    if isSent:\\n                        ans += ((counter[ages[i]] - 1) * counter[ages[i]])\\n                        \\n                else:\\n                    if isSent:\\n                        ans += (counter[ages[i]] * counter[ages[j]])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861540,
                "title": "basic-rust-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut sum = 0;\\n        for (i, &x) in ages.iter().enumerate() {\\n            for &y in &ages[i as usize + 1..] {\\n                if sends_request(x, y) {\\n                    sum += 1;\\n                }\\n                if sends_request(y, x) {\\n                    sum += 1;\\n                }\\n            }\\n        }\\n        sum\\n    }\\n}\\n\\nfn sends_request(x: i32, y: i32) -> bool {\\n    y > x / 2 + 7 && y <= x\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_friend_requests(ages: Vec<i32>) -> i32 {\\n        let mut sum = 0;\\n        for (i, &x) in ages.iter().enumerate() {\\n            for &y in &ages[i as usize + 1..] {\\n                if sends_request(x, y) {\\n                    sum += 1;\\n                }\\n                if sends_request(y, x) {\\n                    sum += 1;\\n                }\\n            }\\n        }\\n        sum\\n    }\\n}\\n\\nfn sends_request(x: i32, y: i32) -> bool {\\n    y > x / 2 + 7 && y <= x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2829948,
                "title": "python-bisect-3rd-condition-is-redundant",
                "content": "3rd condition is redundant because according to condition 2 we already know `age[y] > age[x]`\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            ans += max(0, bisect.bisect(ages, ages[i]) - bisect.bisect(ages, ages[i] * 0.5 + 7) - 1)\\n        return ans",
                "solutionTags": [],
                "code": "3rd condition is redundant because according to condition 2 we already know `age[y] > age[x]`\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        ans = 0\\n        for i in range(len(ages)):\\n            ans += max(0, bisect.bisect(ages, ages[i]) - bisect.bisect(ages, ages[i] * 0.5 + 7) - 1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2803994,
                "title": "java-solution",
                "content": "```\\n    public int numFriendRequests(int[] ages) {\\n        int n = ages.length, sum = 0;\\n        Arrays.sort(ages);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = i-1; j >= 0; j--){\\n               if(ages[i] >= 2 * (ages[j] - 7))\\n                   break;\\n                else \\n                    sum++;\\n            }\\n            \\n            int k = i;\\n            while(k < n-1 && ages[++k] == ages[i])\\n                if(ages[i]< 2 * (ages[k]-7))\\n                sum++;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n    public int numFriendRequests(int[] ages) {\\n        int n = ages.length, sum = 0;\\n        Arrays.sort(ages);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = i-1; j >= 0; j--){\\n               if(ages[i] >= 2 * (ages[j] - 7))\\n                   break;\\n                else \\n                    sum++;\\n            }\\n            \\n            int k = i;\\n            while(k < n-1 && ages[++k] == ages[i])\\n                if(ages[i]< 2 * (ages[k]-7))\\n                sum++;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2720987,
                "title": "o-n-solution-easily-updated-to-o-120-solution-or-constant-time-for-any-input",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        age_count = [0] * 121\\n        summ = 0\\n        dic = {}\\n        \\n        # count ages frpom 0 to 120\\n        for age in ages:\\n            age_count[age] += 1\\n            \\n        # range sum, helps in calculating number of friend requests to be sent \\n        # without binary search\\n        for i in range (121):\\n            summ += age_count[i]\\n            dic[i] = summ\\n\\n        \\n        total_count = 0\\n        # loop through all the ages\\n        # Alternately, You can even loop through 0 to 120 and still be able to calculate\\n        # that will reduce time complexity to O(120) basically almost constant time for inputs of any sizes\\n        \\n        for age in ages:\\n            lower_age = (age * 0.5) + 7\\n            rem = lower_age % 1.0\\n            lower_age = int(lower_age-0.5) if rem>0 else int(lower_age)\\n            higher_age = int(min(age, 100) if age < 100 else age)\\n                        \\n            if lower_age>higher_age:\\n                continue\\n            \\n            if lower_age<age<=higher_age:\\n                decrease_count=1\\n            else:\\n                decrease_count = 0\\n            if higher_age==lower_age:\\n                increase_count = 0\\n            else:\\n                increase_count = dic[higher_age] - dic[lower_age]\\n                \\n            total_count += increase_count - decrease_count\\n            \\n        return total_count\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n\\n        age_count = [0] * 121\\n        summ = 0\\n        dic = {}\\n        \\n        # count ages frpom 0 to 120\\n        for age in ages:\\n            age_count[age] += 1\\n            \\n        # range sum, helps in calculating number of friend requests to be sent \\n        # without binary search\\n        for i in range (121):\\n            summ += age_count[i]\\n            dic[i] = summ\\n\\n        \\n        total_count = 0\\n        # loop through all the ages\\n        # Alternately, You can even loop through 0 to 120 and still be able to calculate\\n        # that will reduce time complexity to O(120) basically almost constant time for inputs of any sizes\\n        \\n        for age in ages:\\n            lower_age = (age * 0.5) + 7\\n            rem = lower_age % 1.0\\n            lower_age = int(lower_age-0.5) if rem>0 else int(lower_age)\\n            higher_age = int(min(age, 100) if age < 100 else age)\\n                        \\n            if lower_age>higher_age:\\n                continue\\n            \\n            if lower_age<age<=higher_age:\\n                decrease_count=1\\n            else:\\n                decrease_count = 0\\n            if higher_age==lower_age:\\n                increase_count = 0\\n            else:\\n                increase_count = dic[higher_age] - dic[lower_age]\\n                \\n            total_count += increase_count - decrease_count\\n            \\n        return total_count\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675263,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar numFriendRequests = function(ages) {\\n\\t\\tconst agesMap = new Map();\\n\\t\\tconst agesSum = Array(121).fill(0);\\n\\n\\t\\tages.forEach(age => {\\n\\t\\t\\tconst count = agesMap.get(age) ?? 0;\\n\\t\\t\\tagesMap.set(age, count + 1);\\n\\t\\t});\\n\\n\\t\\tfor (let age = 1; age < 121; age++) {\\n\\t\\t\\tagesSum[age] = (agesMap.get(age) ?? 0) + agesSum[age - 1];\\n\\t\\t}\\n\\n\\t\\treturn [...new Set(ages)].reduce((result, age) => {\\n\\t\\t\\tconst validAge = (age * 0.5 | 0) + 7;\\n\\t\\t\\tif (validAge >= age) return result;\\n\\t\\t\\tconst multiple = agesSum[age] - agesSum[validAge];\\n\\t\\t\\treturn result + (multiple - 1) * agesMap.get(age);\\n\\t\\t}, 0);\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar numFriendRequests = function(ages) {\\n\\t\\tconst agesMap = new Map();\\n\\t\\tconst agesSum = Array(121).fill(0);\\n\\n\\t\\tages.forEach(age => {\\n\\t\\t\\tconst count = agesMap.get(age) ?? 0;\\n\\t\\t\\tagesMap.set(age, count + 1);\\n\\t\\t});\\n\\n\\t\\tfor (let age = 1; age < 121; age++) {\\n\\t\\t\\tagesSum[age] = (agesMap.get(age) ?? 0) + agesSum[age - 1];\\n\\t\\t}\\n\\n\\t\\treturn [...new Set(ages)].reduce((result, age) => {\\n\\t\\t\\tconst validAge = (age * 0.5 | 0) + 7;\\n\\t\\t\\tif (validAge >= age) return result;\\n\\t\\t\\tconst multiple = agesSum[age] - agesSum[validAge];\\n\\t\\t\\treturn result + (multiple - 1) * agesMap.get(age);\\n\\t\\t}, 0);\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2668841,
                "title": "pyton-binary-search",
                "content": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        res = 0\\n        for i, x in enumerate(ages):\\n            if x < 100:\\n                r = bisect_right(ages, min(x,100))\\n            else:\\n                r = bisect_right(ages, x)\\n            l = bisect_right(ages, 0.5*x + 7)\\n            if l < r:\\n                res += r - l - 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        ages.sort()\\n        res = 0\\n        for i, x in enumerate(ages):\\n            if x < 100:\\n                r = bisect_right(ages, min(x,100))\\n            else:\\n                r = bisect_right(ages, x)\\n            l = bisect_right(ages, 0.5*x + 7)\\n            if l < r:\\n                res += r - l - 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2661724,
                "title": "simple-java-solution-space-o-1-time-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { \\n        int[] numPerAge = new int[150];\\n        \\n        for(int i : ages)\\n            numPerAge[i] += 1;\\n        \\n        int sum = 0;\\n        for(int currentAge = 0; currentAge <150; currentAge++) {\\n            //if perf\\n            if(numPerAge[currentAge] == 0)\\n                continue;\\n            \\n            // To be elibigle to receive request\\n            // Y person should be greater than or equal to \\'startAge\\'. (+1 is for equal and greater than)\\n            int startAge = (int)(currentAge * 0.5) + 7 + 1;\\n            \\n            // If Eligible age is greater than current age, \\n            // Person of currentAge wont be able to send any request due to rule#2.\\n            if(startAge > currentAge)\\n                continue;\\n            \\n            // Get count of all person whoes age starts with startAge and currentAge-1;\\n            int eligiblePeopleCount = getCount(numPerAge, startAge, currentAge-1);\\n            \\n            // Persons of Same age (as currentAge) will send request to each of the eligible people.\\n            sum += (eligiblePeopleCount * numPerAge[currentAge]);\\n\\n            // X Person can send request to the other presons who is of same age of X.\\n            sum += (numPerAge[currentAge] * (numPerAge[currentAge] -1));\\n        }\\n        return sum;\\n    }\\n    private int getCount(int[] numPerAge, int startAge, int currentAge) {\\n        if(currentAge < startAge)\\n            return 0;\\n\\n        int sum = 0;\\n        for(int i = startAge; i <= currentAge; i++) {\\n            sum += numPerAge[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int numFriendRequests(int[] ages) { \\n        int[] numPerAge = new int[150];\\n        \\n        for(int i : ages)\\n            numPerAge[i] += 1;\\n        \\n        int sum = 0;\\n        for(int currentAge = 0; currentAge <150; currentAge++) {\\n            //if perf\\n            if(numPerAge[currentAge] == 0)\\n                continue;\\n            \\n            // To be elibigle to receive request\\n            // Y person should be greater than or equal to \\'startAge\\'. (+1 is for equal and greater than)\\n            int startAge = (int)(currentAge * 0.5) + 7 + 1;\\n            \\n            // If Eligible age is greater than current age, \\n            // Person of currentAge wont be able to send any request due to rule#2.\\n            if(startAge > currentAge)\\n                continue;\\n            \\n            // Get count of all person whoes age starts with startAge and currentAge-1;\\n            int eligiblePeopleCount = getCount(numPerAge, startAge, currentAge-1);\\n            \\n            // Persons of Same age (as currentAge) will send request to each of the eligible people.\\n            sum += (eligiblePeopleCount * numPerAge[currentAge]);\\n\\n            // X Person can send request to the other presons who is of same age of X.\\n            sum += (numPerAge[currentAge] * (numPerAge[currentAge] -1));\\n        }\\n        return sum;\\n    }\\n    private int getCount(int[] numPerAge, int startAge, int currentAge) {\\n        if(currentAge < startAge)\\n            return 0;\\n\\n        int sum = 0;\\n        for(int i = startAge; i <= currentAge; i++) {\\n            sum += numPerAge[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653687,
                "title": "golang-o-n-2",
                "content": "```\\nfunc numFriendRequests(ages []int) int {\\n    requestCount := 0\\n    \\n    ageToCount := make(map[int]int)\\n    for i := 0; i < len(ages); i++ {\\n        ageToCount[ages[i]]++\\n    }\\n    \\n    uniqueAges := make([]int, 0, len(ageToCount))\\n    for age, _ := range ageToCount {\\n        uniqueAges = append(uniqueAges, age)\\n    }\\n    \\n    sort.Ints(uniqueAges)\\n    \\n    n := len(uniqueAges)\\n    for i := 0; i < n; i ++ {\\n        for j := 0; j < n; j++ {\\n            if sendRequest(uniqueAges[i], uniqueAges[j]) {\\n                if i == j {\\n                    requestCount += ageToCount[uniqueAges[i]] * (ageToCount[uniqueAges[i]] - 1) \\n                } else {\\n                    requestCount += (ageToCount[uniqueAges[i]] * ageToCount[uniqueAges[j]])\\n                }\\n            }\\n        }\\n    }\\n    \\n    return requestCount\\n}\\n\\nfunc sendRequest(a int, b int) bool {\\n    return !((2 * b - 14 <= a) || b > a)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numFriendRequests(ages []int) int {\\n    requestCount := 0\\n    \\n    ageToCount := make(map[int]int)\\n    for i := 0; i < len(ages); i++ {\\n        ageToCount[ages[i]]++\\n    }\\n    \\n    uniqueAges := make([]int, 0, len(ageToCount))\\n    for age, _ := range ageToCount {\\n        uniqueAges = append(uniqueAges, age)\\n    }\\n    \\n    sort.Ints(uniqueAges)\\n    \\n    n := len(uniqueAges)\\n    for i := 0; i < n; i ++ {\\n        for j := 0; j < n; j++ {\\n            if sendRequest(uniqueAges[i], uniqueAges[j]) {\\n                if i == j {\\n                    requestCount += ageToCount[uniqueAges[i]] * (ageToCount[uniqueAges[i]] - 1) \\n                } else {\\n                    requestCount += (ageToCount[uniqueAges[i]] * ageToCount[uniqueAges[j]])\\n                }\\n            }\\n        }\\n    }\\n    \\n    return requestCount\\n}\\n\\nfunc sendRequest(a int, b int) bool {\\n    return !((2 * b - 14 <= a) || b > a)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617352,
                "title": "my-solutions",
                "content": "**1. Use the binary search**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(vector<int> &ages) {\\n    const int n = static_cast<int>(ages.size());\\n    sort(ages.begin(), ages.end());\\n    int ret = 0;\\n    for (int x = 0; x < n; ++x) {\\n      int upper_y = ages[x];\\n      if (ages[x] < 100) {\\n        upper_y = min(upper_y, 100);\\n      }\\n\\n      const int lower_y = ages[x] / 2 + 7;\\n      ret += static_cast<int>(max(0L,\\n                                  upper_bound(ages.begin(), ages.end(), upper_y) -\\n                                  upper_bound(ages.begin(), ages.end(), lower_y) -\\n                                  (ages[x] <= upper_y && ages[x] >= lower_y ? 1 : 0)));\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the unordered map**\\n```\\n/**\\n * Time Complexity: O(n_ages * a_ages)\\n * Space Complexity: O(n_ages)\\n * where `n_ages` is the number of distinct values (ages) of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(const vector<int> &ages) {\\n    unordered_map<int, int> age_to_persons;\\n    for (const int age : ages) {\\n      ++age_to_persons[age];\\n    }\\n   \\n    int ret = 0;\\n    for (const auto [x, x_persons] : age_to_persons) {\\n      for (const auto [y, y_persons] : age_to_persons) {\\n        if (can_make_friend_request(x, y)) {\\n          ret += x_persons * (y_persons + (x == y ? -1 : 0));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool can_make_friend_request(const int x, const int y) {\\n    return !(y <= x / 2 + 7 || y > x || (y > 100 && x < 100));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(vector<int> &ages) {\\n    const int n = static_cast<int>(ages.size());\\n    sort(ages.begin(), ages.end());\\n    int ret = 0;\\n    for (int x = 0; x < n; ++x) {\\n      int upper_y = ages[x];\\n      if (ages[x] < 100) {\\n        upper_y = min(upper_y, 100);\\n      }\\n\\n      const int lower_y = ages[x] / 2 + 7;\\n      ret += static_cast<int>(max(0L,\\n                                  upper_bound(ages.begin(), ages.end(), upper_y) -\\n                                  upper_bound(ages.begin(), ages.end(), lower_y) -\\n                                  (ages[x] <= upper_y && ages[x] >= lower_y ? 1 : 0)));\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n_ages * a_ages)\\n * Space Complexity: O(n_ages)\\n * where `n_ages` is the number of distinct values (ages) of the vector `ages`\\n */\\nclass Solution {\\n public:\\n  int numFriendRequests(const vector<int> &ages) {\\n    unordered_map<int, int> age_to_persons;\\n    for (const int age : ages) {\\n      ++age_to_persons[age];\\n    }\\n   \\n    int ret = 0;\\n    for (const auto [x, x_persons] : age_to_persons) {\\n      for (const auto [y, y_persons] : age_to_persons) {\\n        if (can_make_friend_request(x, y)) {\\n          ret += x_persons * (y_persons + (x == y ? -1 : 0));\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  bool can_make_friend_request(const int x, const int y) {\\n    return !(y <= x / 2 + 7 || y > x || (y > 100 && x < 100));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611773,
                "title": "python-o-nlgn-binary-search-easy-solution",
                "content": "import bisect\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \\n        x, result = 0, 0\\n        \\n        ages.sort()\\n        \\n        while(x < len(ages)):\\n            x1 = bisect.bisect_right(ages, ages[x])\\n            y1 = bisect.bisect_right(ages, ages[x] * 0.5 + 7)\\n            result += max(0, x1 - y1 - 1)\\n            x += 1\\n \\n        return result\\n",
                "solutionTags": [],
                "code": "import bisect\\nclass Solution(object):\\n    def numFriendRequests(self, ages):\\n        \\n        x, result = 0, 0\\n        \\n        ages.sort()\\n        \\n        while(x < len(ages)):\\n            x1 = bisect.bisect_right(ages, ages[x])\\n            y1 = bisect.bisect_right(ages, ages[x] * 0.5 + 7)\\n            result += max(0, x1 - y1 - 1)\\n            x += 1\\n \\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 2568904,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func numFriendRequests(_ ages: [Int]) -> Int {\\n        var req: Int = 0, map: [Int:Int] = [:]\\n        for age in ages {\\n            map[age, default: 0] += 1\\n        }\\n        for y in 1 ... 120 {\\n            for x in 1 ... 120 {\\n                if (Double(y) <= (Double(x) * 0.5 + 7)) || (y > x) || (y > 100 && x < 100) {\\n                    continue\\n                }\\n                req += map[y, default: 0] * map[x, default: 0]\\n                if x == y { req -= map[y, default: 0] }\\n            }\\n        }\\n        return req\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numFriendRequests(_ ages: [Int]) -> Int {\\n        var req: Int = 0, map: [Int:Int] = [:]\\n        for age in ages {\\n            map[age, default: 0] += 1\\n        }\\n        for y in 1 ... 120 {\\n            for x in 1 ... 120 {\\n                if (Double(y) <= (Double(x) * 0.5 + 7)) || (y > x) || (y > 100 && x < 100) {\\n                    continue\\n                }\\n                req += map[y, default: 0] * map[x, default: 0]\\n                if x == y { req -= map[y, default: 0] }\\n            }\\n        }\\n        return req\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568688,
                "title": "o-n-120-solution",
                "content": "inspired by the solution here  https://leetcode.com/problems/friends-of-appropriate-ages/discuss/2505228/Python-Time%3A-O(max(N-120))-Space-O(1)-Prefixsum-and-Numbersort-Solution\\nI have a different one\\n\\n```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        num_person_by_age = [0 for i in range(121)]\\n        for age in ages:\\n            num_person_by_age[age] += 1\\n        \\n        count = 0\\n        num_person_by_age_presum = [0 for i in range(121)]\\n        for age in range(15, 121):\\n            num_person_by_age_presum[age] = num_person_by_age[age]+num_person_by_age_presum[age-1]\\n            \\n        for age in range(15, 121):\\n            if num_person_by_age[age] == 0:\\n                continue\\n            limit = age // 2 + 7\\n            num_request = (num_person_by_age_presum[age-1] - num_person_by_age_presum[limit] )*num_person_by_age[age]\\n            count += num_request + num_person_by_age[age] * (num_person_by_age[age]-1)\\n         \\n        return count\\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        num_person_by_age = [0 for i in range(121)]\\n        for age in ages:\\n            num_person_by_age[age] += 1\\n        \\n        count = 0\\n        num_person_by_age_presum = [0 for i in range(121)]\\n        for age in range(15, 121):\\n            num_person_by_age_presum[age] = num_person_by_age[age]+num_person_by_age_presum[age-1]\\n            \\n        for age in range(15, 121):\\n            if num_person_by_age[age] == 0:\\n                continue\\n            limit = age // 2 + 7\\n            num_request = (num_person_by_age_presum[age-1] - num_person_by_age_presum[limit] )*num_person_by_age[age]\\n            count += num_request + num_person_by_age[age] * (num_person_by_age[age]-1)\\n         \\n        return count\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2567097,
                "title": "friends-of-appropiate-ages",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def  friendRequest(a, b):\\n            if b <=  .5 * a + 7:\\n                return False\\n            if b > a:\\n                return False\\n            return True\\n        \\n        age_groups = collections.Counter(ages)\\n        total_request =  0\\n        for a, num_a in age_groups.items():\\n            for b, num_b in age_groups.items():\\n                if friendRequest(a, b):\\n                    total_request += num_a * num_b\\n                    if a == b :\\n                        total_request -= num_a\\n        return total_request\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        def  friendRequest(a, b):\\n            if b <=  .5 * a + 7:\\n                return False\\n            if b > a:\\n                return False\\n            return True\\n        \\n        age_groups = collections.Counter(ages)\\n        total_request =  0\\n        for a, num_a in age_groups.items():\\n            for b, num_b in age_groups.items():\\n                if friendRequest(a, b):\\n                    total_request += num_a * num_b\\n                    if a == b :\\n                        total_request -= num_a\\n        return total_request\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562864,
                "title": "python-prefix-sum-deque-easy-understanding",
                "content": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \"\"\"\\n        1. age[y] <= 0.5 * age[x] + 7: set the left bound\\n        2. age[y] > age[x]: check smaller prefix sum\\n        3. age[y] > 100 && age[x] < 100: no need if we check smaller prefix sum\\n        \"\"\"\\n        c = collections.Counter(ages)\\n        inPresum = deque() # the window that \"key\" will send request to\\n        preSum = 0 # count of people of inPresum\\n        ans = 0\\n        for key in sorted(c):\\n            # check left bound\\n            while inPresum and inPresum[0] <= 0.5 * key + 7:\\n                preSum -= c[inPresum.popleft()]\\n            \\n            currCount = c[key]\\n            # request between same ages\\n\\t\\t\\t# note: also need to check condition 1 here\\n            if currCount > 1 and key > (0.5 * key + 7):\\n                combination = math.factorial(currCount) // (2 * math.factorial(currCount-2) ) \\n                ans += combination * 2\\n            ans += currCount * preSum\\n            \\n            preSum += currCount\\n            inPresum.append(key)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numFriendRequests(self, ages: List[int]) -> int:\\n        \"\"\"\\n        1. age[y] <= 0.5 * age[x] + 7: set the left bound\\n        2. age[y] > age[x]: check smaller prefix sum\\n        3. age[y] > 100 && age[x] < 100: no need if we check smaller prefix sum\\n        \"\"\"\\n        c = collections.Counter(ages)\\n        inPresum = deque() # the window that \"key\" will send request to\\n        preSum = 0 # count of people of inPresum\\n        ans = 0\\n        for key in sorted(c):\\n            # check left bound\\n            while inPresum and inPresum[0] <= 0.5 * key + 7:\\n                preSum -= c[inPresum.popleft()]\\n            \\n            currCount = c[key]\\n            # request between same ages\\n\\t\\t\\t# note: also need to check condition 1 here\\n            if currCount > 1 and key > (0.5 * key + 7):\\n                combination = math.factorial(currCount) // (2 * math.factorial(currCount-2) ) \\n                ans += combination * 2\\n            ans += currCount * preSum\\n            \\n            preSum += currCount\\n            inPresum.append(key)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531829,
                "title": "c-hashing-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool request(int a,int b)\\n    {\\n        return !(a<=0.5*b+7||a>b||a>100&&b<100);\\n    }\\n    int numFriendRequests(vector<int>& ages) \\n    {\\n        unordered_map<int,int> m;\\n        int ans=0;\\n        for(auto &a:ages)\\n        {\\n            m[a]++;\\n        }\\n        for(auto &a:m)\\n        {\\n            for(auto &b:m)\\n            {\\n                if(request(a.first,b.first))\\n                {\\n                    ans+=a.second*(b.second-(a.first==b.first?1:0));\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool request(int a,int b)\\n    {\\n        return !(a<=0.5*b+7||a>b||a>100&&b<100);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2459938,
                "title": "clean-o-n-solution-beat-100",
                "content": "```\\n public int numFriendRequests(int[] ages) {\\n    int[] cnt = new int[121];\\n    for(int age: ages){\\n      cnt[age]++;\\n    }\\n    int[] presum = new int[cnt.length];\\n    for(int i=1; i< presum.length; i++){\\n      presum[i] = presum[i-1] + cnt[i];\\n    }\\n    int sum  =0;\\n    for(int age =1 ; age< cnt.length; age++){\\n      int c = cnt[age];\\n      if(c ==0 ) continue;\\n      int left = age/2 +7 , right = age; //(left, right]\\n      if(left >= right) continue;\\n      sum +=(presum[right]-1 - presum[left]) * c;\\n    }\\n    return sum;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n public int numFriendRequests(int[] ages) {\\n    int[] cnt = new int[121];\\n    for(int age: ages){\\n      cnt[age]++;\\n    }\\n    int[] presum = new int[cnt.length];\\n    for(int i=1; i< presum.length; i++){\\n      presum[i] = presum[i-1] + cnt[i];\\n    }\\n    int sum  =0;\\n    for(int age =1 ; age< cnt.length; age++){\\n      int c = cnt[age];\\n      if(c ==0 ) continue;\\n      int left = age/2 +7 , right = age; //(left, right]\\n      if(left >= right) continue;\\n      sum +=(presum[right]-1 - presum[left]) * c;\\n    }\\n    return sum;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2367237,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    static int upperBound(int arr[], int target) {\\n        int l = 0, h = arr.length - 1;\\n        for (; l <= h;) {\\n            int mid = (l + h) >> 1;\\n            if (arr[mid] <= target)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        return l;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        long ans = 0;\\n        Arrays.sort(ages);\\n\\t\\t// traversing order doesn\\'t matter as we are doing binary-search in whole array\\n\\t\\t// you can traverse from left side also\\n        for(int i = ages.length - 1;i >= 0;--i){\\n            int k = upperBound(ages,ages[i] / 2 + 7);\\n            int t = upperBound(ages,ages[i]);\\n            ans += Math.max(0,t - k - 1);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    static int upperBound(int arr[], int target) {\\n        int l = 0, h = arr.length - 1;\\n        for (; l <= h;) {\\n            int mid = (l + h) >> 1;\\n            if (arr[mid] <= target)\\n                l = mid + 1;\\n            else\\n                h = mid - 1;\\n        }\\n        return l;\\n    }\\n    public int numFriendRequests(int[] ages) {\\n        long ans = 0;\\n        Arrays.sort(ages);\\n\\t\\t// traversing order doesn\\'t matter as we are doing binary-search in whole array\\n\\t\\t// you can traverse from left side also\\n        for(int i = ages.length - 1;i >= 0;--i){\\n            int k = upperBound(ages,ages[i] / 2 + 7);\\n            int t = upperBound(ages,ages[i]);\\n            ans += Math.max(0,t - k - 1);\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564622,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1564837,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1565764,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1570680,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 2014524,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1574850,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 1573685,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            },
            {
                "id": 2070855,
                "content": [
                    {
                        "username": "elvinyang",
                        "content": "age[B] > age[A] and age[B] > 100 && age[A] < 100, isn\\'t the latter redundant?"
                    },
                    {
                        "username": "zpcore",
                        "content": "How can all the people in the world only love the younger people? No couple will love each other in this way."
                    },
                    {
                        "username": "sima",
                        "content": "I can find 69->56, 69->48, 56->48\\n\\n101 cannot make friend requests to anyone\\n\\nNo one make friend request to 30, 69*0.5+7 > 30, 48*0.5+7 > 30, 56 * 0.5 + 7 > 30\\n\\nI can only find 3. where is the 4th one?"
                    },
                    {
                        "username": "ianpan870102",
                        "content": "As titled, the third condition is useless. The second condition completely overrides it."
                    },
                    {
                        "username": "BiggestChungus",
                        "content": "`age[y] <= 0.5 * age[x] + 7`\\n\\nlol this was a meme from about 15 years ago right??"
                    },
                    {
                        "username": "Engineerr",
                        "content": "Just to see if you fit in the company culture, never make friends with new hire, stay away from VP/director."
                    },
                    {
                        "username": "parag_meshram",
                        "content": "Imho, theoretically, time complexity should be O(No. of Ages) = O(No. of Person) as loops are always running for constant no. of times i.e.120 * 120 times and space complexity is always O(121) = O(1) for the counting array size. \\uD83E\\uDD14"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Using a sliding window this can be done in O(n). You need to iterate through the input at least once, there is no getting around that, therefore at a minimum its O(n). An O(1) solution requires you dont need to process input, and thats not possible for this problem. "
                    },
                    {
                        "username": "OrestKlymko",
                        "content": "[16,17,18] - Friend requests are made 17 -> 16, 18 -> 17, but why don\\'t 18 -> 16???"
                    }
                ]
            }
        ]
    },
    {
        "title": "Monthly Transactions I",
        "question_content": "<p>Table: <code>Transactions</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| country       | varchar |\n| state         | enum    |\n| amount        | int     |\n| trans_date    | date    |\n+---------------+---------+\nid is the primary key of this table.\nThe table has information about incoming transactions.\nThe state column is an enum of type [&quot;approved&quot;, &quot;declined&quot;].\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The query result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTransactions table:\n+------+---------+----------+--------+------------+\n| id   | country | state    | amount | trans_date |\n+------+---------+----------+--------+------------+\n| 121  | US      | approved | 1000   | 2018-12-18 |\n| 122  | US      | declined | 2000   | 2018-12-19 |\n| 123  | US      | approved | 2000   | 2019-01-01 |\n| 124  | DE      | approved | 2000   | 2019-01-07 |\n+------+---------+----------+--------+------------+\n<strong>Output:</strong> \n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| month    | country | trans_count | approved_count | trans_total_amount | approved_total_amount |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n| 2018-12  | US      | 2           | 1              | 3000               | 1000                  |\n| 2019-01  | US      | 1           | 1              | 2000               | 2000                  |\n| 2019-01  | DE      | 1           | 1              | 2000               | 2000                  |\n+----------+---------+-------------+----------------+--------------------+-----------------------+\n</pre>\n",
        "solutions": [
            {
                "id": 396359,
                "title": "simple-sql",
                "content": "```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756098,
                "title": "step-by-step-detailed-solution-easy-to-understand-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA beginner friendly answer is written by following basic concepts step by step.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLooking at the result table we write the basic select statement\\nSELECT ___ as month, country, __ as trans_count, __ as approved_count, ___ as trans_total_amount,___ as approved_total_amount\\nFROM Transactions\\n\\nNow we form the solution column by column, starting from month.\\nAs the month column contains only a part (year and month) from trans_date column in Transactions, we use SUBSTR() function to select a substring of trans_date starting from index 1 and going upto 7th index: SUBSTR(trans_date,1,7) as month.\\nWe modify the select statement as\\nSELECT SUBSTR(trans_date,1,7) as month, country, __ as trans_count, __ as approved_count, ___ as trans_total_amount,___ as approved_total_amount\\nFROM Transactions\\n\\nNow, we go for trans_count column (as country column is as it is taken from table Transactions), looking at the result table, we need to count the number of transections per month in a country so, we count transaction ids and GROUP them by month and country.\\nThe code will look like this now\\nSELECT SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, __ as approved_count, ___ as trans_total_amount,___ as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n\\nNow for next approved_count column, we need to check if the state of transection is \"approved\" if yes then we count else we don\\'t. For this here we used CASE statement along with SUM() function as follows:\\nSUM(CASE WHEN state = \\'approved\\' then 1 else 0 END).\\nLastly, modify the select statement by adding: \\nSUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count\\n\\nNow for trans_total_amount, as we have already grouped transactions based on month and country so, we can directly write trans_total_amount column as SUM(amount). \\nNow updated select statement will look like this:\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, ___ as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n\\nAs we wrote the condition for approved_count column similarly, we \\ncan write for approved_total_amount. The only difference is instead of adding 1, in case the state = \\'approved\\', we add transaction amount: SUM(CASE WHEN state = \\'approved\\' then amount else 0 END).\\n\\nThus the final code becomes\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' then amount else 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n\\n# Complexity\\n- Runtime: 927 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Beats: 92.67%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' then amount else 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```\\nIf you like my explanation kindly upvote for me :)",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  SUBSTR(trans_date,1,7) as month, country, count(id) as trans_count, SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' then amount else 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386961,
                "title": "simple-mysql",
                "content": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(id) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(id) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671116,
                "title": "easy-approach-explained-sql",
                "content": "\\n\\n# Intuition\\n \\uD83D\\uDCA1To solve this problem, we can use SQL aggregation functions like COUNT and SUM to calculate the desired values. We need to group the transactions by month and country to perform the necessary calculations.\\n\\n# Approach\\n \\uD83D\\uDD0D Here is the step-by-step approach to solve the problem:\\n\\n1. Write a SELECT statement to specify the desired columns.\\n2. Use the DATE_FORMAT function to extract the month from the `trans_date` column and assign it an alias.\\n3. Include the country column.\\n4. Use COUNT(*) to calculate the total number of transactions for each group.\\n5. Use SUM and an IF statement to calculate the number of approved transactions for each group.\\n6. Use SUM to calculate the total amount of transactions for each group.\\n7. Use SUM and an IF statement to calculate the total amount of approved transactions for each group.\\n8. Specify the table name in the FROM clause.\\n9. Use the GROUP BY clause to group the data by month and country.\\n\\n# SQL Solution\\n\\n\\n\\uD83D\\uDCBBThe SQL code implementing the above approach is as follows:\\n\\n> Feel free to post your doubts in the comment section :)\\n\\n```sql\\nSELECT\\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n  country,\\n  COUNT(*) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```\\n\\n\\u2728 This solution efficiently calculates the required information by utilizing SQL aggregation functions and grouping the data appropriately. The use of conditional statements within the SUM function allows us to selectively include transactions based on their state (approved or declined).\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT\\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n  country,\\n  COUNT(*) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540365,
                "title": "mysql-solution-for-monthly-transactions-i-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given SQL query aims to retrieve aggregated information about transactions, including the count and total amount, grouped by month and country. It also calculates the count and total amount specifically for transactions with the \\'approved\\' state. The DATE_FORMAT function is used to extract the month from the trans_date column.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The query selects the formatted month (month), country, and calculates several aggregates: trans_count, approved_count, trans_total_amount, and approved_total_amount.\\n1. The trans_count represents the count of transactions in each month and country.\\n1. The approved_count represents the count of transactions with the \\'approved\\' state in each month and country.\\n1. The trans_total_amount represents the sum of all transaction amounts in each month and country.\\n1. The approved_total_amount represents the sum of transaction amounts with the \\'approved\\' state in each month and country.\\n1. The query groups the rows by the formatted month and country using the GROUP BY clause.\\n1. The result is a set of rows, where each row represents a unique combination of formatted month and country, along with the corresponding counts and total amounts.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the query depends on the size of the \"Transactions\" table, the number of distinct months and countries, and the efficiency of the database\\'s query execution plan. The query requires scanning the entire \"Transactions\" table, grouping the rows by formatted month and country, and calculating the aggregates. The time complexity can vary, but it typically ranges from linear to quadratic based on the number of rows and the efficiency of index usage.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the query depends on the size of the result set, which is determined by the number of distinct month and country combinations in the \"Transactions\" table. The space required to store the result grows linearly with the number of combinations.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect date_format(trans_date, \\'%Y-%m\\') as month, country, count(*) as trans_count,\\nsum(if(state = \\'approved\\', 1, 0)) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect date_format(trans_date, \\'%Y-%m\\') as month, country, count(*) as trans_count,\\nsum(if(state = \\'approved\\', 1, 0)) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2940817,
                "title": "simple-mssql-using-case-when-no-join-needed",
                "content": "\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    FORMAT(trans_date, \\'yyyy-MM\\') as month, \\n    country, \\n    count(id) as trans_count,\\n    sum(case when state =\\'approved\\' then 1 else 0 end) approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by FORMAT(trans_date, \\'yyyy-MM\\'), country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nselect \\n    FORMAT(trans_date, \\'yyyy-MM\\') as month, \\n    country, \\n    count(id) as trans_count,\\n    sum(case when state =\\'approved\\' then 1 else 0 end) approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by FORMAT(trans_date, \\'yyyy-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913013,
                "title": "91-21-faster-solution-using-simple-case-statement",
                "content": "```\\nselect\\n      DATE_FORMAT(trans_date,\"%Y-%m\") as month,\\n      country,\\n      count(id) as trans_count,\\n      sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n      sum(amount) as trans_total_amount,\\n      sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\n       group by country, month",
                "solutionTags": [],
                "code": "```\\nselect\\n      DATE_FORMAT(trans_date,\"%Y-%m\") as month,\\n      country,\\n      count(id) as trans_count,\\n      sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n      sum(amount) as trans_total_amount,\\n      sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\n       group by country, month",
                "codeTag": "Unknown"
            },
            {
                "id": 2181398,
                "title": "mysql-properly-styled-count-if-sum-if-group-by",
                "content": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(iF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(iF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(iF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(iF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719103,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date ,\\'%Y-%m\\') as month,country ,count(state) as trans_count , SUM(CASE WHEN state=\\'approved \\' then 1 else 0 END) as approved_count   ,sum(amount)as trans_total_amount , sum(Case when state=\\'approved \\' then amount else 0 end ) as approved_total_amount \\n\\nfrom Transactions \\ngroup by DATE_FORMAT(trans_date ,\\'%Y-%m\\'),country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date ,\\'%Y-%m\\') as month,country ,count(state) as trans_count , SUM(CASE WHEN state=\\'approved \\' then 1 else 0 END) as approved_count   ,sum(amount)as trans_total_amount , sum(Case when state=\\'approved \\' then amount else 0 end ) as approved_total_amount \\n\\nfrom Transactions \\ngroup by DATE_FORMAT(trans_date ,\\'%Y-%m\\'),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037097,
                "title": "easy-mysql-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n\\nFormatting Date: It uses the LEFT(trans_date, 7) function to format the trans_date column, extracting the year and month portion in the format \"YYYY-MM.\"\\n\\nGrouping: The GROUP BY 1, 2 clause groups the rows by the formatted date (month) and the country column. This grouping ensures that we get results for each month and country combination.\\n\\nCounting Total Transactions: COUNT(id) calculates the total number of transactions for each group, giving us the trans_count column.\\n\\nCounting Approved Transactions: SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) is used to count the number of approved transactions within each group. It effectively counts 1 for each row where state is \\'approved\\' and 0 otherwise. This gives us the approved_count column.\\n\\nSumming Total Transaction Amounts: SUM(amount) calculates the total transaction amount for each group, providing the trans_total_amount column.\\n\\nSumming Approved Transaction Amounts: SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) is used to sum the transaction amounts for approved transactions within each group. It adds the amount for each row where state is \\'approved\\' and 0 otherwise, giving us the approved_total_amount column.\\n\\nBy performing these operations within the SELECT statement and properly grouping the results with GROUP BY, the query effectively calculates the number of transactions, the number of approved transactions, and their respective total amounts for each month and country combination in the Transactions table.<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nSELECT LEFT(trans_date, 7) AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT LEFT(trans_date, 7) AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY 1, 2;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871182,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT TO_CHAR(trans_date, \\'YYYY-MM\\') month, country, count(*)\\n\\ntrans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END)\\n\\napproved_count, SUM(amount)  trans_total_amount, \\n\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) as\\n\\napproved_total_amount FROM Transactions\\n\\nGROUP BY TO_CHAR(trans_date, \\'YYYY-MM\\'), country\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/521f5128-b504-4f64-96e0-0b6ec1cb5b1e_1691311275.1776528.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT TO_CHAR(trans_date, \\'YYYY-MM\\') month, country, count(*)\\n\\ntrans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END)\\n\\napproved_count, SUM(amount)  trans_total_amount, \\n\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) as\\n\\napproved_total_amount FROM Transactions\\n\\nGROUP BY TO_CHAR(trans_date, \\'YYYY-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2353063,
                "title": "easy-case-when-and-date-format",
                "content": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, count(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by country, month",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, count(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by country, month",
                "codeTag": "Unknown"
            },
            {
                "id": 1113755,
                "title": "straightforward-mysql",
                "content": "```sql\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(state=\"approved\") AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(state=\"approved\") AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632161,
                "title": "simple-sql-solution-javith-sadham-hussain",
                "content": "# Code\\n```\\nSelect left(trans_date, 7) as month, \\n    country,\\n    count(id) as trans_count,\\n    sum(state = \\'approved\\') as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n            when state = \\'approved\\' then amount \\n            else 0\\n        end) as approved_total_amount\\nfrom Transactions \\ngroup by month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect left(trans_date, 7) as month, \\n    country,\\n    count(id) as trans_count,\\n    sum(state = \\'approved\\') as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n            when state = \\'approved\\' then amount \\n            else 0\\n        end) as approved_total_amount\\nfrom Transactions \\ngroup by month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644038,
                "title": "mysql-using-case-when-beats-93",
                "content": "select \\n    date_format(trans_date, \"%Y-%m\") as month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case when state = \"approved\" then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state = \"approved\" then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by date_format(trans_date, \"%Y-%m\"), country;",
                "solutionTags": [],
                "code": "select \\n    date_format(trans_date, \"%Y-%m\") as month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case when state = \"approved\" then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state = \"approved\" then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by date_format(trans_date, \"%Y-%m\"), country;",
                "codeTag": "Unknown"
            },
            {
                "id": 3695557,
                "title": "simple-oracle-code-with-a-tip",
                "content": "# Code\\n```\\nselect to_char(trans_date, \\'YYYY-MM\\') as month, country, count(*) as trans_count, \\nsum(case \\n    when state=\\'approved\\' then 1\\n    else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case\\n    when state=\\'approved\\' then amount\\n    else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by to_char(trans_date, \\'YYYY-MM\\'), country\\n```\\n\\nJust as me, you might have used the `group by` statement as i did, which is: writing `month` in there and wondering why the code is showing run-time error.\\n\\nThis is a problem, and if you have made the same mistake, then remember to write the whole expression and not the alias.\\n** It is a problem in `Oracle` only. `MySQL` donot have this.\\n\\nHope it Helps \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n![image.png](https://assets.leetcode.com/users/images/21da4b20-aba4-4ca8-a33d-8fd87ab71822_1688022940.395717.png)\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect to_char(trans_date, \\'YYYY-MM\\') as month, country, count(*) as trans_count, \\nsum(case \\n    when state=\\'approved\\' then 1\\n    else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case\\n    when state=\\'approved\\' then amount\\n    else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by to_char(trans_date, \\'YYYY-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589803,
                "title": "optimum-solution-with-step-by-step-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe goal is to obtain aggregated information from the \"Transactions\" table based on the formatted month and country. This includes the total count of transactions, the count of approved transactions, the total transaction amount, and the total amount of approved transactions.\\n\\n# Approach\\n1. Use the **DATE_FORMAT** function in SQL to format the \"trans_date\" column into the desired month format, **\\'%Y-%m\\'**.\\n1. Select the formatted month **(DATE_FORMAT(trans_date, \\'%Y-%m\\'))**, country, and apply various aggregate functions to calculate the desired statistics:\\n1. **count(*)** is used to count the total number of transactions.\\n1. **sum(if(state=\\'approved\\',1,0))** is used to count the number of approved transactions by evaluating a conditional statement.\\n1. **sum(amount)** is used to calculate the total transaction amount.\\n1. **sum(if(state=\\'approved\\',amount,0))** is used to calculate the total amount of approved transactions by evaluating a conditional statement.\\n1. Group the results by the formatted month and country using the GROUP BY clause.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the query depends on the size of the \"Transactions\" table and the efficiency of the database engine. In general, the time complexity is influenced by the performance of indexing, data retrieval, and aggregation operations. Assuming the table is properly indexed, the time complexity can be considered as linear, $$O(n)$$, where n is the number of rows in the \"Transactions\" table.\\n\\n- Space complexity:\\nThe space complexity is determined by the memory required to store the result set of the query. It also depends on the number of distinct formatted month and country combinations present in the \"Transactions\" table. Assuming the result set is stored in memory, the space complexity can be considered linear, $$O(n)$$, where n is the number of distinct formatted month and country combinations in the \"Transactions\" table.\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n  country, count(*) as trans_count, \\n  sum(if(state=\\'approved\\',1,0)) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(if(state=\\'approved\\',amount,0)) as approved_total_amount \\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/ceb8c03d-74fc-41ae-abd2-c82ba3d36790_1685716714.292304.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n  country, count(*) as trans_count, \\n  sum(if(state=\\'approved\\',1,0)) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(if(state=\\'approved\\',amount,0)) as approved_total_amount \\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2338360,
                "title": "mysql-solution-with-case-date-fromat-explaination",
                "content": "#create a query that:\\n#extract the yy-mm from transdate\\n#count the number of trans\\n#approved count using case-aggreagate\\n#total amount using sum\\n#total_trans_amount using case-aggregate\\n#and approved total\\n\\n```\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country, count(id) as trans_count, \\nsum(case when state =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state =\\'approved\\' then amount else 0 end) as \\'approved_total_amount\\'\\nfrom Transactions\\ngroup by 1,2\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country, count(id) as trans_count, \\nsum(case when state =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state =\\'approved\\' then amount else 0 end) as \\'approved_total_amount\\'\\nfrom Transactions\\ngroup by 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914061,
                "title": "easy-solution-using-decode",
                "content": "# Code\\n```\\nSELECT TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\') AS month,\\n       country,\\n       COUNT(*) AS trans_count,\\n       SUM(DECODE(state, \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(DECODE(state, \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM transactions\\nGROUP BY TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\'),\\n         country\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\') AS month,\\n       country,\\n       COUNT(*) AS trans_count,\\n       SUM(DECODE(state, \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(DECODE(state, \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM transactions\\nGROUP BY TO_CHAR(TO_DATE(trans_date, \\'YYYY-MM-DD\\'), \\'YYYY-MM\\'),\\n         country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590732,
                "title": "simple-solution-for-oracle-or-postgres",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We could apply built-in function - `TO_CHAR` so as to etract the necessary month. After this we just need to aggregate our records by the appropriate functions in each column.\\n2. In order to obtain the right `SUM` it\\'s common to use `CASE - THEN` statements.\\n\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\n\\nSELECT\\n    TO_CHAR(trans_date, \\'YYYY-MM\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END\\n    ) AS approved_total_amount\\n\\nFROM \\n    Transactions\\nGROUP BY \\n    TO_CHAR(trans_date, \\'YYYY-MM\\'),\\n    country;\\n\\n```",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\n\\nSELECT\\n    TO_CHAR(trans_date, \\'YYYY-MM\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END\\n    ) AS approved_total_amount\\n\\nFROM \\n    Transactions\\nGROUP BY \\n    TO_CHAR(trans_date, \\'YYYY-MM\\'),\\n    country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564645,
                "title": "sql-left-count-coalesce-sum-case-when-group-by-easy-to-understand",
                "content": "# Intuition\\nThe main task is to use the count and sum functions to create columns\\n\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/a7a60aac-46bc-4c11-8d47-aac2563f4389_1685096810.5151806.png)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\nleft(trans_date,7) as month,\\ncountry,\\ncount(state) as trans_count,\\ncoalesce(sum(case when state = \\'approved\\'then 1 end),0)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions \\ngroup by left(trans_date,7),country\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\nleft(trans_date,7) as month,\\ncountry,\\ncount(state) as trans_count,\\ncoalesce(sum(case when state = \\'approved\\'then 1 end),0)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions \\ngroup by left(trans_date,7),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432044,
                "title": "solution-with-window-function-sql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT distinct\\n\\tleft(convert(nvarchar(100),trans_date,121),7) [Month],\\n\\tcountry,\\n\\tISNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tISNULL(COUNT(IIF(state = \\'approved\\' , id , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tISNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tISNULL(SUM(IIF(state = \\'approved\\' , amount , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT distinct\\n\\tleft(convert(nvarchar(100),trans_date,121),7) [Month],\\n\\tcountry,\\n\\tISNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tISNULL(COUNT(IIF(state = \\'approved\\' , id , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tISNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tISNULL(SUM(IIF(state = \\'approved\\' , amount , null)) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454062,
                "title": "this-is-the-simplest-and-straightforward-you-will-see",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') month,\\n       country,\\n       COUNT(state) trans_count,\\n       SUM(state = \\'approved\\') approved_count,\\n       SUM(amount) trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') month,\\n       country,\\n       COUNT(state) trans_count,\\n       SUM(state = \\'approved\\') approved_count,\\n       SUM(amount) trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947615,
                "title": "mysql-solution-using-group-by-faster-than-92-89",
                "content": "```\\nselect\\n    substring(trans_date,1,7) month\\n    ,country\\n    ,count(*) trans_count\\n    ,sum(if(state=\\'approved\\',1,0)) approved_count\\n    ,sum(amount) trans_total_amount\\n    ,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    substring(trans_date,1,7) month\\n    ,country\\n    ,count(*) trans_count\\n    ,sum(if(state=\\'approved\\',1,0)) approved_count\\n    ,sum(amount) trans_total_amount\\n    ,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384354,
                "title": "mysql-100-faster",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count, SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count, SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count, SUM(amount) as trans_total_amount, SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100744,
                "title": "sql-easy-to-understand-solution",
                "content": "\\uD83D\\uDE4F\\uD83D\\uDE4F PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```\\nselect\\ndate_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, \\ncount(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\nfrom \\ntransactions\\n\\ngroup by \\ndate_format(trans_date, \\'%Y-%m\\'), country\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\ndate_format(trans_date, \\'%Y-%m\\') as month, \\ncountry, \\ncount(id) as trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, \\nsum(amount) as trans_total_amount, \\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\nfrom \\ntransactions\\n\\ngroup by \\ndate_format(trans_date, \\'%Y-%m\\'), country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612652,
                "title": "all-3-db-query-using-switch-case-and-group-by-and-substring",
                "content": "Idea is to use substring to get first 7 characters of date. rest of the logic is pretty simple by using switch case we can count only approved transactions.\\n\\n# Oracle\\n```\\nselect substr(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by substr(trans_date,1,7), country;\\n```\\n\\n# MySql\\n```\\nselect SUBSTRING(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by SUBSTRING(trans_date,1,7), country;\\n```\\n\\n# MSSql server\\nHere SUBSTRING method does not support date type as argument and hence formatting needed\\n```\\nselect SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions \\ngroup by SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7), country;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect substr(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by substr(trans_date,1,7), country;\\n```\n```\\nselect SUBSTRING(trans_date,1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount \\nfrom Transactions \\ngroup by SUBSTRING(trans_date,1,7), country;\\n```\n```\\nselect SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7) as month,\\ncountry,\\ncount(*) trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions \\ngroup by SUBSTRING(format(trans_date,\\'yyyy-MM-dd hh:mm:ss tt\\'),1,7), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611657,
                "title": "solution-with-simple-query-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT distinct\\n\\tleft(trans_date,7) Month,\\n\\tcountry,\\n\\tIFNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tIFNULL(COUNT(CASE WHEN state = \\'approved\\' THEN id ELSE  null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tIFNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tIFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT distinct\\n\\tleft(trans_date,7) Month,\\n\\tcountry,\\n\\tIFNULL(COUNT(id) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ),0) trans_count,\\n\\tIFNULL(COUNT(CASE WHEN state = \\'approved\\' THEN id ELSE  null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_count,\\n\\tIFNULL(SUM(amount) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)trans_total_amount,\\n\\tIFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE null END ) OVER(PARTITION BY country,Month(trans_date),Year(trans_date) ) ,0)approved_total_amount\\nFROM\\t\\n\\tTransactions\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282348,
                "title": "simple-mysql-solution-using-case-when-statement",
                "content": "```\\nSELECT LEFT(trans_date ,7) as month,country,\\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 else 0 end) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount else 0 end) as approved_total_amount\\nfrom Transactions GROUP BY month,country\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT LEFT(trans_date ,7) as month,country,\\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 else 0 end) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount else 0 end) as approved_total_amount\\nfrom Transactions GROUP BY month,country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200214,
                "title": "simple-case-when-solution-sql-server",
                "content": "select left(trans_date,7) as month, country,count(id) as trans_count,\\nCount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount ,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by left(trans_date,7), country",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select left(trans_date,7) as month, country,count(id) as trans_count,\\nCount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount ,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by left(trans_date,7), country",
                "codeTag": "Unknown"
            },
            {
                "id": 2143037,
                "title": "simple-mysql-case-and-date-format",
                "content": "```\\nselect date_format(trans_date, \"%Y-%m\") month,\\n       country,\\n       count(id) trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n       sum(amount) trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \"%Y-%m\"), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_format(trans_date, \"%Y-%m\") month,\\n       country,\\n       count(id) trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\n       sum(amount) trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date, \"%Y-%m\"), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068821,
                "title": "mysql-case-when-simple-faster-that-85",
                "content": "```\\nSELECT      DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, # NOTE m IS NOT CAPITAL\\n            country,\\n            COUNT(amount) AS trans_count,\\n            COUNT(CASE WHEN state = \\'approved\\' THEN amount END) AS approved_count,\\n            IFNULL(SUM(amount),0) AS trans_total_amount,\\n            IFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount END),0) AS approved_total_amount\\nFROM        Transactions \\nGROUP BY    MONTH(trans_date), country\\n            \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT      DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, # NOTE m IS NOT CAPITAL\\n            country,\\n            COUNT(amount) AS trans_count,\\n            COUNT(CASE WHEN state = \\'approved\\' THEN amount END) AS approved_count,\\n            IFNULL(SUM(amount),0) AS trans_total_amount,\\n            IFNULL(SUM(CASE WHEN state = \\'approved\\' THEN amount END),0) AS approved_total_amount\\nFROM        Transactions \\nGROUP BY    MONTH(trans_date), country\\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1982834,
                "title": "mysql-multiple-solutions-using-date-format-count-sum-and-if",
                "content": "1. We first select from the `Transactions` table.\\n\\n```\\nSELECT *\\nFROM Transactions\\n```\\n\\n2. We need to group by month and country. We can use `DATE_FORMAT` to extract both the year and month. I have also seen someone use `LEFT(trans_date, 7)` in place of `DATE_FORMAT`.\\n\\n```\\nSELECT\\n\\tDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```\\n\\n3. We use `COUNT`, `SUM` and `IF` to do computations per group for the remaining columns:\\n\\t* **The number of transactions**: We count rows with `COUNT` and label this `trans_count`.\\n\\t* **The total amount**: We sum the amount column with `SUM` and label this `trans_total_amount`.\\n\\t* **The number of approved transactions**: We label this `approved_count`. As for the computation, we have some options:\\n\\t\\t1. `COUNT(IF(state = \\'approved\\', 1, NULL))` \\n\\t\\t\\t- We have to use `NULL` instead of 0 here, since `COUNT` will count everything except for `NULL`. `COUNT(1)` would achieve the same as `COUNT(0)`, or even `COUNT(\\'insert anything here\\')`.\\n\\t\\t2. `SUM(IF(state = \\'approved\\', 1, 0))` \\n\\t\\t\\t- If you want to use 0 instead of `NULL` like described above, you can do so but wrap the `IF` statement with `SUM` instead of `COUNT`.\\n\\t\\t3. `SUM(state = \\'approved\\')` \\n\\t\\t\\t- Since `state=\\'approved\\'` is of type Boolean, we either have true or false values, or in computation, 1 or 0 respectively. So in essense we a summing a bunch of 1s and 0s like the option right above this one.\\n\\t\\t4. `IF` statements above can also be replaced with `CASE WHEN THEN ELSE END`.\\n\\t* **The total amount for approved transactions**: We label this `approved_total_amount`. As for the computation, we have some options:\\n\\t\\t1. `SUM(IF(state = \\'approved\\', amount, 0))`\\n\\t\\t\\t- We only want to include the amount in the sum of amounts if the transaction state is approved. Otherwise its value should be 0 in the sum.\\n\\t\\t2. `SUM((state = \\'approved\\') * amount)`\\n\\t\\t\\t- We can also include or exclude the amount in the sum by multiplying it by 1 if it is approved or 0 if not approved, which means we can multiple by `state = \\'approved\\'`. \\n\\t\\t3. `IF` statements above can also be replaced with `CASE WHEN THEN ELSE END`.\\n\\n```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n\\tSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT *\\nFROM Transactions\\n```\n```\\nSELECT\\n\\tDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```\n```\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    COUNT(IF(state = \\'approved\\', 1, NULL)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n\\tSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532891,
                "title": "mysql-solution-straight-forward-using-groupby-and-case-faster-than-93",
                "content": "```\\nSELECT\\n    LEFT(trans_date, 7) as month,\\n    country,\\n    COUNT(*) as trans_count,\\n    COUNT(CASE WHEN state = \\'approved\\' THEN 1 ELSE NULL END) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY 1,2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    LEFT(trans_date, 7) as month,\\n    country,\\n    COUNT(*) as trans_count,\\n    COUNT(CASE WHEN state = \\'approved\\' THEN 1 ELSE NULL END) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517408,
                "title": "dateformat-sum-count-year-month",
                "content": "Similar to other answers\\n```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    COUNT(amount) AS trans_count,\\n    SUM(state = \\'approved\\') AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(amount * (state = \\'approved\\')) AS approved_total_amount\\nFROM transactions\\nGROUP BY YEAR(trans_date), MONTH(trans_date), country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    COUNT(amount) AS trans_count,\\n    SUM(state = \\'approved\\') AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(amount * (state = \\'approved\\')) AS approved_total_amount\\nFROM transactions\\nGROUP BY YEAR(trans_date), MONTH(trans_date), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007814,
                "title": "beats-90-08-of-users-with-ms-sql-server",
                "content": "# Code\\n```\\n\\nselect\\n  LEFT(t.trans_date, \\'7\\') month,\\n  t.country country,\\n  count(*) trans_count,\\n  sum(t.amount) trans_total_amount,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\n\\nfrom [Transactions] t\\ngroup by LEFT(t.trans_date, \\'7\\'), t.country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n\\nselect\\n  LEFT(t.trans_date, \\'7\\') month,\\n  t.country country,\\n  count(*) trans_count,\\n  sum(t.amount) trans_total_amount,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\n\\nfrom [Transactions] t\\ngroup by LEFT(t.trans_date, \\'7\\'), t.country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876760,
                "title": "easy-sql-solution",
                "content": "\\n# Code\\n```\\nSELECT TO_CHAR(TRANS_DATE, \\'YYYY-MM\\') AS MONTH, \\nCOUNTRY, COUNT(*) AS TRANS_COUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT, \\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT FROM TRANSACTIONS GROUP BY TO_CHAR(TRANS_DATE, \\'YYYY-MM\\'), COUNTRY;\\n```",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nSELECT TO_CHAR(TRANS_DATE, \\'YYYY-MM\\') AS MONTH, \\nCOUNTRY, COUNT(*) AS TRANS_COUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT, \\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT, \\nSUM(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT FROM TRANSACTIONS GROUP BY TO_CHAR(TRANS_DATE, \\'YYYY-MM\\'), COUNTRY;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601114,
                "title": "easiest-solution-with-explanation-best-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly, we format the date in the required format by using **DATE_FORMAT()** function and giving the format **\\'%Y-%m\\'** as argument.\\n- We use **if() conditional statement** to sum the **number of times the transaction is approved** and then again to find the **total_approved_amount**.\\n- We group the output by the format of month we obtained and also the country because the **question asks us to find the output for each month and country**.\\nP.S : It is very important to understand GROUP BY clause and its application as it is used very often in SQL.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the required columns by solving them as described in the intuition section.\\n2. In the FROM statement, we write the table name **Transactions**.\\n3. The GROUP BY clause groups the output by **month and country** because the question asks us to find the output for each month and country.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count,\\n    SUM(if(state=\\'approved\\',1,0)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```\\n# Note\\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, COUNT(*) as trans_count,\\n    SUM(if(state=\\'approved\\',1,0)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733904,
                "title": "two-cte-tables-solution",
                "content": "Originally had this two CTE tables solution, it turned out to be not that efficient...\\n\\n```\\nWITH approve_table AS(\\n    SELECT\\n        DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country,\\n    COUNT(state=\\'approved\\') AS approved_count,\\n    sum(amount) AS approved_total_amount\\n    FROM Transactions\\n    WHERE state = \\'approved\\'\\n    GROUP BY country, month\\n),\\ntotal_table AS (\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n    country,\\n    COUNT(*) AS trans_count,\\n    sum(amount) AS trans_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n)\\nSELECT\\n    a.month,\\n    a.country,\\n    t.trans_count,\\n    a.approved_count,\\n    t.trans_total_amount,\\n    a.approved_total_amount\\nFROM \\n    approve_table a\\nJOIN \\n    total_table t\\nON \\n    a.month = t.month\\nAND\\n    a.country = t.country\\n```",
                "solutionTags": [],
                "code": "```\\nWITH approve_table AS(\\n    SELECT\\n        DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country,\\n    COUNT(state=\\'approved\\') AS approved_count,\\n    sum(amount) AS approved_total_amount\\n    FROM Transactions\\n    WHERE state = \\'approved\\'\\n    GROUP BY country, month\\n),\\ntotal_table AS (\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n    country,\\n    COUNT(*) AS trans_count,\\n    sum(amount) AS trans_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n)\\nSELECT\\n    a.month,\\n    a.country,\\n    t.trans_count,\\n    a.approved_count,\\n    t.trans_total_amount,\\n    a.approved_total_amount\\nFROM \\n    approve_table a\\nJOIN \\n    total_table t\\nON \\n    a.month = t.month\\nAND\\n    a.country = t.country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540887,
                "title": "my-sql-solution",
                "content": "select SUBSTRING(trans_date,1,7) as month,country,count(id) as trans_count,sum(if(state = \\'approved\\', 1, 0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state = \\'approved\\', amount, 0)) as approved_total_amount from Transactions group by month, country",
                "solutionTags": [],
                "code": "select SUBSTRING(trans_date,1,7) as month,country,count(id) as trans_count,sum(if(state = \\'approved\\', 1, 0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state = \\'approved\\', amount, 0)) as approved_total_amount from Transactions group by month, country",
                "codeTag": "Unknown"
            },
            {
                "id": 2482941,
                "title": "monthly-transactions",
                "content": "\\nselect a.month,a.country,a.trans_count,ifnull(b.approved_count,0) approved_count  ,a.trans_total_amount,ifnull(b.approved_total_amount,0) approved_total_amount\\nfrom\\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, sum(amount) as \\'trans_total_amount\\' ,count(1) as\\' trans_count\\' from Transactions  \\ngroup by substring(trans_date,1,7),country\\n) a\\nLEFT JOIN  \\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, ifnull(sum(amount),0) as \\'approved_total_amount\\',count(1) as \\'approved_count\\' from Transactions \\nwhere state     = \\'approved\\' \\ngroup by substring(trans_date,1,7),country\\n) b\\n\\non \\na.month = b.month \\nand  a.country = b.country \\n",
                "solutionTags": [],
                "code": "\\nselect a.month,a.country,a.trans_count,ifnull(b.approved_count,0) approved_count  ,a.trans_total_amount,ifnull(b.approved_total_amount,0) approved_total_amount\\nfrom\\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, sum(amount) as \\'trans_total_amount\\' ,count(1) as\\' trans_count\\' from Transactions  \\ngroup by substring(trans_date,1,7),country\\n) a\\nLEFT JOIN  \\n(\\nselect substring(trans_date,1,7) as \\'month\\' , country, ifnull(sum(amount),0) as \\'approved_total_amount\\',count(1) as \\'approved_count\\' from Transactions \\nwhere state     = \\'approved\\' \\ngroup by substring(trans_date,1,7),country\\n) b\\n\\non \\na.month = b.month \\nand  a.country = b.country \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2376501,
                "title": "simple-mysql-using-sum-and-if",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n       country, \\n       COUNT(*) AS trans_count,\\n       SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \"%Y-%m\"), country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \"%Y-%m\") AS month, \\n       country, \\n       COUNT(*) AS trans_count,\\n       SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \"%Y-%m\"), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310655,
                "title": "mysql-solution",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, SUM(1) AS trans_count,\\n    SUM(IF(state = \"approved\", 1, 0)) AS approved_count,\\n    SUM(amount) as trans_total_amount , SUM(IF(state = \"approved\", amount, 0)) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, SUM(1) AS trans_count,\\n    SUM(IF(state = \"approved\", 1, 0)) AS approved_count,\\n    SUM(amount) as trans_total_amount , SUM(IF(state = \"approved\", amount, 0)) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248311,
                "title": "oracle-count-sum-decode-group-by-faster-than-100",
                "content": "/* Write your PL/SQL query statement below */\\nselect to_char(trans_date,\\'YYYY-MM\\') as month,\\n    country,\\n    count(*) as trans_count,\\n    count(decode(state,\\'approved\\',state,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(decode(state,\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),\\n    country\\norder by 1,2;",
                "solutionTags": [],
                "code": "/* Write your PL/SQL query statement below */\\nselect to_char(trans_date,\\'YYYY-MM\\') as month,\\n    country,\\n    count(*) as trans_count,\\n    count(decode(state,\\'approved\\',state,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(decode(state,\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),\\n    country\\norder by 1,2;",
                "codeTag": "Unknown"
            },
            {
                "id": 2128104,
                "title": "combining-aggregate-with-conditional",
                "content": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\n    country,\\n    count(id) as \\'trans_count\\',\\n    count(if(state=\\'approved\\',id,null)) as \\'approved_count\\',\\n    sum(amount) as \\'trans_total_amount\\',\\n    sum(if(state=\\'approved\\', amount, 0)) as \\'approved_total_amount\\'\\nfrom transactions\\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, \\n    country,\\n    count(id) as \\'trans_count\\',\\n    count(if(state=\\'approved\\',id,null)) as \\'approved_count\\',\\n    sum(amount) as \\'trans_total_amount\\',\\n    sum(if(state=\\'approved\\', amount, 0)) as \\'approved_total_amount\\'\\nfrom transactions\\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060906,
                "title": "mysql-group-by-and-join",
                "content": "WITH tx_month_table AS\\n(\\nSELECT country, state, amount, DATE_FORMAT(trans_date, \"%Y-%m\") AS month_year\\nFROM Transactions\\n),\\n\\napproved_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS approved_total_amount, COUNT(*) AS approved_count\\nFROM tx_month_table\\nWHERE state = \"approved\"\\nGROUP BY month_year, country\\n),\\n\\nall_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS trans_total_amount, COUNT(*) AS trans_count\\nFROM tx_month_table \\nGROUP BY month_year, country\\n)\\n\\nSELECT a.month_year AS month, a.country, trans_count, \\n(CASE WHEN approved_count IS NULL THEN 0 ELSE approved_count END) AS approved_count,\\ntrans_total_amount, \\n(CASE WHEN approved_total_amount IS NULL THEN 0 ELSE approved_total_amount END) AS approved_total_amount\\nFROM all_transactions a\\nLEFT JOIN approved_transactions  b\\nON a.month_year=b.month_year AND a.country=b.country;\\n",
                "solutionTags": [],
                "code": "WITH tx_month_table AS\\n(\\nSELECT country, state, amount, DATE_FORMAT(trans_date, \"%Y-%m\") AS month_year\\nFROM Transactions\\n),\\n\\napproved_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS approved_total_amount, COUNT(*) AS approved_count\\nFROM tx_month_table\\nWHERE state = \"approved\"\\nGROUP BY month_year, country\\n),\\n\\nall_transactions AS\\n(\\nSELECT month_year, country, SUM(amount) AS trans_total_amount, COUNT(*) AS trans_count\\nFROM tx_month_table \\nGROUP BY month_year, country\\n)\\n\\nSELECT a.month_year AS month, a.country, trans_count, \\n(CASE WHEN approved_count IS NULL THEN 0 ELSE approved_count END) AS approved_count,\\ntrans_total_amount, \\n(CASE WHEN approved_total_amount IS NULL THEN 0 ELSE approved_total_amount END) AS approved_total_amount\\nFROM all_transactions a\\nLEFT JOIN approved_transactions  b\\nON a.month_year=b.month_year AND a.country=b.country;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2036361,
                "title": "runtime-1445-ms-faster-than-98-80-of-ms-sql-server",
                "content": "\\n```\\nSelect \\n    month = CONVERT(char(7), trans_date,126)\\n    ,country\\n    ,trans_count = count(id)\\n    ,approved_count = SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END)\\n    ,trans_total_amount = SUM(amount)\\n    ,approved_total_amount = SUM(CASE WHEN state = \\'approved\\' then amount else 0 END)\\nFROM Transactions\\nGroup By CONVERT(char(7), trans_date,126), country\\n```",
                "solutionTags": [],
                "code": "```\\nSelect \\n    month = CONVERT(char(7), trans_date,126)\\n    ,country\\n    ,trans_count = count(id)\\n    ,approved_count = SUM(CASE WHEN state = \\'approved\\' then 1 else 0 END)\\n    ,trans_total_amount = SUM(amount)\\n    ,approved_total_amount = SUM(CASE WHEN state = \\'approved\\' then amount else 0 END)\\nFROM Transactions\\nGroup By CONVERT(char(7), trans_date,126), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015003,
                "title": "accepted-mysql-if-solution",
                "content": "```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month\\n        , country\\n        , count(*) as trans_count\\n        , sum(IF(state = \\'approved\\', 1, 0)) as approved_count\\n        , SUM(amount) as trans_total_amount\\n        , sum(IF(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by \\n        DATE_FORMAT(trans_date, \\'%Y-%m\\')\\n        , country\\nORDER BY month\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month\\n        , country\\n        , count(*) as trans_count\\n        , sum(IF(state = \\'approved\\', 1, 0)) as approved_count\\n        , SUM(amount) as trans_total_amount\\n        , sum(IF(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by \\n        DATE_FORMAT(trans_date, \\'%Y-%m\\')\\n        , country\\nORDER BY month\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972318,
                "title": "accepted-solution-for-mysql-very-easy-code",
                "content": "```\\nSELECT DATE_FORMAT(trans_date,\"%Y-%m\") AS month,country, COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(trans_date,\"%Y-%m\") AS month,country, COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959726,
                "title": "simple-and-easiest-mysql-solution",
                "content": "```\\nselect LEFT(trans_date, 7) as month, country, \\nCOUNT(*) as trans_count,\\nSUM(state = \"approved\") as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(IF(state = \"approved\", amount, 0)) as approved_total_amount\\nfrom transactions\\ngroup by LEFT(trans_date, 7), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect LEFT(trans_date, 7) as month, country, \\nCOUNT(*) as trans_count,\\nSUM(state = \"approved\") as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(IF(state = \"approved\", amount, 0)) as approved_total_amount\\nfrom transactions\\ngroup by LEFT(trans_date, 7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933488,
                "title": "why-it-is-wrong",
                "content": "select date_format (trans_date,\\'%Y-%m\\') as month,country,\\ncount(id)as trans_count,*count(state=\\'approved\\')as approved_count,*sum(amount) as trans_total_amount,sum((state=\\'approved\\')*amount)as approved_total_amount\\nfrom transactions\\n\\nwhy we cannot use count(state=\\'approved\\') as approved_account to get the same answer???",
                "solutionTags": [],
                "code": "select date_format (trans_date,\\'%Y-%m\\') as month,country,\\ncount(id)as trans_count,*count(state=\\'approved\\')as approved_count,*sum(amount) as trans_total_amount,sum((state=\\'approved\\')*amount)as approved_total_amount\\nfrom transactions\\n\\nwhy we cannot use count(state=\\'approved\\') as approved_account to get the same answer???",
                "codeTag": "Unknown"
            },
            {
                "id": 1926531,
                "title": "simple-solution-with-date-format-99-1-faster",
                "content": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, country,\\ncount(amount) as trans_count, sum(state=\\'approved\\') as approved_count, \\nsum(amount) as trans_total_amount, sum((state=\\'approved\\')*amount) as approved_total_amount  \\nfrom Transactions\\ngroup by month, country\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nselect date_format(trans_date, \\'%Y-%m\\') as month, country,\\ncount(amount) as trans_count, sum(state=\\'approved\\') as approved_count, \\nsum(amount) as trans_total_amount, sum((state=\\'approved\\')*amount) as approved_total_amount  \\nfrom Transactions\\ngroup by month, country\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897469,
                "title": "mysql-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(1) as trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(1) as trans_count,\\n       sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891920,
                "title": "mysql-sum-with-case-when",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\', \\n        country,\\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\', \\n        country,\\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788571,
                "title": "mssql-simple-solution",
                "content": "```\\nselect \\n    left(trans_date, 7) as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(iif(state = \\'approved\\', 1, 0)) as approved_count, \\n    sum(amount) as trans_total_amount, \\n    sum(iif(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    left(trans_date, 7) as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(iif(state = \\'approved\\', 1, 0)) as approved_count, \\n    sum(amount) as trans_total_amount, \\n    sum(iif(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747607,
                "title": "mysql",
                "content": "select left(trans_date,7) as month,country,count(id) as trans_count,sum(case when state=\\'approved\\' then 1 else 0 END) as approved_count,sum(amount) as trans_total_amount,sum(case when state=\\'approved\\' then amount else 0 END) as approved_total_amount\\nfrom Transactions\\ngroup by month,country",
                "solutionTags": [],
                "code": "select left(trans_date,7) as month,country,count(id) as trans_count,sum(case when state=\\'approved\\' then 1 else 0 END) as approved_count,sum(amount) as trans_total_amount,sum(case when state=\\'approved\\' then amount else 0 END) as approved_total_amount\\nfrom Transactions\\ngroup by month,country",
                "codeTag": "Unknown"
            },
            {
                "id": 1740850,
                "title": "sumif-dateformat-solution",
                "content": "```\\n\\nselect DATE_FORMAT(trans_date, \"%Y-%m\") as month, country, \\ncount(*) as trans_count,\\nsum(if(state=\\'approved\\',1,0)) as approved_count, \\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by month, country\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect DATE_FORMAT(trans_date, \"%Y-%m\") as month, country, \\ncount(*) as trans_count,\\nsum(if(state=\\'approved\\',1,0)) as approved_count, \\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1671849,
                "title": "solution-oracle-sum-case-statement-group-by",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nSELECT to_char(trans_date, \\'YYYY-MM\\') as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(CASE WHEN state=\\'approved\\' then 1 ELSE 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(CASE WHEN state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFROM Transactions GROUP BY to_char(trans_date, \\'YYYY-MM\\'), country;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT to_char(trans_date, \\'YYYY-MM\\') as month, \\n    country, \\n    count(id) as trans_count, \\n    sum(CASE WHEN state=\\'approved\\' then 1 ELSE 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(CASE WHEN state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFROM Transactions GROUP BY to_char(trans_date, \\'YYYY-MM\\'), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595900,
                "title": "simple-oracle-solution",
                "content": "```\\nselect to_char(trans_date, \\'YYYY-MM\\')       month\\n      ,country\\n      ,count(1)         trans_count \\n      ,sum(case when state = \\'approved\\' then 1 else 0 end) approved_count \\n      ,sum(amount)      trans_total_amount \\n      ,sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount \\n  from Transactions\\n  group by to_char(trans_date, \\'YYYY-MM\\'), country\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect to_char(trans_date, \\'YYYY-MM\\')       month\\n      ,country\\n      ,count(1)         trans_count \\n      ,sum(case when state = \\'approved\\' then 1 else 0 end) approved_count \\n      ,sum(amount)      trans_total_amount \\n      ,sum(case when state = \\'approved\\' then amount else 0 end) approved_total_amount \\n  from Transactions\\n  group by to_char(trans_date, \\'YYYY-MM\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524892,
                "title": "92-faster-mysql-sum-case-when",
                "content": "```\\nselect month, country, trans_count,\\n    approved_count,\\n    trans_total_amount,\\n    approved_total_amount\\nfrom (\\n    select date_format(trans_date,\\'%Y-%m\\') as month, country, \\n         count(id) as trans_count,\\n         sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,  \\n         sum(amount) as trans_total_amount,\\n         sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by month, country) tmp\\n\\t```",
                "solutionTags": [],
                "code": "```\\nselect month, country, trans_count,\\n    approved_count,\\n    trans_total_amount,\\n    approved_total_amount\\nfrom (\\n    select date_format(trans_date,\\'%Y-%m\\') as month, country, \\n         count(id) as trans_count,\\n         sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,  \\n         sum(amount) as trans_total_amount,\\n         sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\n    from Transactions\\n    group by month, country) tmp\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499668,
                "title": "simple-mysql-using-sum-and-case",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country, \\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY 1,2\\nORDER BY 1, 2",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS \\'month\\',\\n        country, \\n        COUNT(id) AS \\'trans_count\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS \\'approved_count\\',\\n        SUM(amount) AS \\'trans_total_amount\\',\\n        SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY 1,2\\nORDER BY 1, 2",
                "codeTag": "Unknown"
            },
            {
                "id": 1489504,
                "title": "mysql-solution",
                "content": "select date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(case when state  = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state  = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2",
                "solutionTags": [],
                "code": "select date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(case when state  = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state  = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2",
                "codeTag": "Unknown"
            },
            {
                "id": 1370095,
                "title": "mssql-subquery",
                "content": "```\\nSELECT month, country, COUNT(*) as trans_count, SUM(approved) as approved_count, SUM(amount) as trans_total_amount, SUM(approved_amount) as approved_total_amount\\nFROM (SELECT id, country, amount, LEFT(trans_date, 7) as month,\\n        CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END AS \\'approved\\',\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END AS \\'approved_amount\\'\\n      FROM Transactions) data\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT month, country, COUNT(*) as trans_count, SUM(approved) as approved_count, SUM(amount) as trans_total_amount, SUM(approved_amount) as approved_total_amount\\nFROM (SELECT id, country, amount, LEFT(trans_date, 7) as month,\\n        CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END AS \\'approved\\',\\n        CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END AS \\'approved_amount\\'\\n      FROM Transactions) data\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295093,
                "title": "mysql",
                "content": "```\\nwith temp as\\n(\\nselect *, case when state=\\'approved\\' then 1 else 0 end as approved_count,\\n    case when state=\\'approved\\' then amount else 0 end as approved_amount\\nfrom transactions\\n)\\n\\nselect substr(trans_date,1,7) as month, country, count(id) as trans_count,\\n    sum(approved_count) as approved_count, \\n    sum(amount) as trans_total_amount, sum(approved_amount) as approved_total_amount\\nfrom temp\\ngroup by country, substr(trans_date,1,7)\\n```",
                "solutionTags": [],
                "code": "```\\nwith temp as\\n(\\nselect *, case when state=\\'approved\\' then 1 else 0 end as approved_count,\\n    case when state=\\'approved\\' then amount else 0 end as approved_amount\\nfrom transactions\\n)\\n\\nselect substr(trans_date,1,7) as month, country, count(id) as trans_count,\\n    sum(approved_count) as approved_count, \\n    sum(amount) as trans_total_amount, sum(approved_amount) as approved_total_amount\\nfrom temp\\ngroup by country, substr(trans_date,1,7)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1226352,
                "title": "simple-mysql-solution",
                "content": "```\\nSELECT\\n    LEFT(trans_date, 7) AS month,\\n    country,\\n    COUNT(*) as trans_count,\\n    SUM(state = \\'approved\\') as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions t\\nGROUP BY month, country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    LEFT(trans_date, 7) AS month,\\n    country,\\n    COUNT(*) as trans_count,\\n    SUM(state = \\'approved\\') as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions t\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168824,
                "title": "easy-sum-combine-case-when",
                "content": "select \\n        date_format(trans_date,\"%Y-%m\") month, \\n        country,\\n        count(*) trans_count,\\n        sum(case when state=\\'approved\\' then 1 else 0 end) approved_count, \\n        sum(amount) trans_total_amount,\\n        sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date,\"%Y-%m\") , country\\n\\n",
                "solutionTags": [],
                "code": "select \\n        date_format(trans_date,\"%Y-%m\") month, \\n        country,\\n        count(*) trans_count,\\n        sum(case when state=\\'approved\\' then 1 else 0 end) approved_count, \\n        sum(amount) trans_total_amount,\\n        sum(case when state=\\'approved\\' then amount else 0 end) approved_total_amount\\nfrom Transactions\\ngroup by date_format(trans_date,\"%Y-%m\") , country\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1087544,
                "title": "easy-mysql-solution",
                "content": "```\\nselect left(trans_date,7) as month, \\ncountry, \\ncount(id) as trans_count,\\n sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n sum(amount) as trans_total_amount,\\n sum(case when state= \"approved\" then amount else 0 end) as approved_total_amount\\n from Transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect left(trans_date,7) as month, \\ncountry, \\ncount(id) as trans_count,\\n sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\n sum(amount) as trans_total_amount,\\n sum(case when state= \"approved\" then amount else 0 end) as approved_total_amount\\n from Transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1078472,
                "title": "bit-99-82",
                "content": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(*) AS trans_count, SUM(state = \\'approved\\') AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(*) AS trans_count, SUM(state = \\'approved\\') AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1050009,
                "title": "mysql",
                "content": "```\\nSELECT SUBSTR(TRANS_DATE,1,7) AS MONTH,\\n       COUNTRY,\\n\\t   COUNT(*) AS TRANS_COUNT,\\n\\t   SUM(CASE\\n           WHEN STATE=\\'approved\\'\\n           THEN 1\\n           ELSE 0 \\n           END)AS APPROVED_COUNT,\\n\\t   SUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\n\\t   SUM(CASE\\n\\t       WHEN STATE = \\'approved\\'\\n\\t\\t   THEN AMOUNT\\n\\t\\t   ELSE 0\\n\\t\\t   END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY SUBSTR(TRANS_DATE,1,7),\\n       COUNTRY\\nORDER BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SUBSTR(TRANS_DATE,1,7) AS MONTH,\\n       COUNTRY,\\n\\t   COUNT(*) AS TRANS_COUNT,\\n\\t   SUM(CASE\\n           WHEN STATE=\\'approved\\'\\n           THEN 1\\n           ELSE 0 \\n           END)AS APPROVED_COUNT,\\n\\t   SUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\n\\t   SUM(CASE\\n\\t       WHEN STATE = \\'approved\\'\\n\\t\\t   THEN AMOUNT\\n\\t\\t   ELSE 0\\n\\t\\t   END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY SUBSTR(TRANS_DATE,1,7),\\n       COUNTRY\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039880,
                "title": "sum-if",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT\\n    LEFT(trans_date, 7) AS \\'month\\',\\n    country, \\n    SUM(IF(state=\\'approved\\', 1, 1)) AS trans_count,\\n    SUM(IF(state=\\'approved\\', 1, 0)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount,0)) AS approved_total_amount\\nFROM \\n    transactions\\nGROUP BY\\n    1, 2\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    LEFT(trans_date, 7) AS \\'month\\',\\n    country, \\n    SUM(IF(state=\\'approved\\', 1, 1)) AS trans_count,\\n    SUM(IF(state=\\'approved\\', 1, 0)) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(IF(state=\\'approved\\', amount,0)) AS approved_total_amount\\nFROM \\n    transactions\\nGROUP BY\\n    1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981279,
                "title": "faster-than-90-57",
                "content": "```\\n\\nselect date_format(trans_date,\"%Y-%m\") as month, country, \\ncount(id) as trans_count,\\nsum(case when state=\\'approved\\' then 1  else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount  else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1,2;\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect date_format(trans_date,\"%Y-%m\") as month, country, \\ncount(id) as trans_count,\\nsum(case when state=\\'approved\\' then 1  else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount  else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by 1,2;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880930,
                "title": "simple-mysql-solution",
                "content": "Simple solution using case statement \\n\\n```\\nselect DATE_FORMAT(trans_date,\"%Y-%m\") as month,country, \\ncount(*) as trans_count, \\nsum(CASE WHEN state=\\'approved\\' then 1 else 0 end) as approved_count,sum(amount) as trans_total_amount,\\nsum(CASE WHEN state=\\'approved\\' then amount else 0 end)as approved_total_amount \\nfrom Transactions \\ngroup by MONTH(trans_date),country\\n```",
                "solutionTags": [],
                "code": "```\\nselect DATE_FORMAT(trans_date,\"%Y-%m\") as month,country, \\ncount(*) as trans_count, \\nsum(CASE WHEN state=\\'approved\\' then 1 else 0 end) as approved_count,sum(amount) as trans_total_amount,\\nsum(CASE WHEN state=\\'approved\\' then amount else 0 end)as approved_total_amount \\nfrom Transactions \\ngroup by MONTH(trans_date),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879493,
                "title": "simple-mssql-solution",
                "content": "```\\nselect convert(varchar(7), trans_date, 126) as month, country,\\ncount(trans_date) as trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by convert(varchar(7), trans_date, 126), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect convert(varchar(7), trans_date, 126) as month, country,\\ncount(trans_date) as trans_count,\\nsum(case when state=\\'approved\\' then 1 else 0 end)as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by convert(varchar(7), trans_date, 126), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870063,
                "title": "simple-mysql-solution-using-if",
                "content": "```sql\\nselect\\n    left(trans_date,7) as \\'month\\',\\n    country,\\n    count(id) as trans_count,\\n    sum(if(state = \\'approved\\',1,0)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) as approved_total_amount \\nfrom transactions\\ngroup by 1,2\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect\\n    left(trans_date,7) as \\'month\\',\\n    country,\\n    count(id) as trans_count,\\n    sum(if(state = \\'approved\\',1,0)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) as approved_total_amount \\nfrom transactions\\ngroup by 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868620,
                "title": "mssql-sum-case-when",
                "content": "```\\n-- solution: using case when statements\\nselect\\nleft(trans_date,7) as month,\\ncountry,\\nsum(case when state is not null then 1 else 0 end) as trans_count,\\nsum(case when lower(state) =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state is not null then amount else 0 end) as trans_total_amount,\\nsum(case when lower(state) =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by left(trans_date,7), country\\norder by sum(case when state is not null then 1 else 0 end) desc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n-- solution: using case when statements\\nselect\\nleft(trans_date,7) as month,\\ncountry,\\nsum(case when state is not null then 1 else 0 end) as trans_count,\\nsum(case when lower(state) =\\'approved\\' then 1 else 0 end) as approved_count,\\nsum(case when state is not null then amount else 0 end) as trans_total_amount,\\nsum(case when lower(state) =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by left(trans_date,7), country\\norder by sum(case when state is not null then 1 else 0 end) desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815288,
                "title": "super-easy-faster-than-90",
                "content": "select to_char(trans_date, \\'YYYY-MM\\') month,\\ncountry, \\ncount(state) trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\ncoalesce(sum(case when state = \\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions \\ngroup by to_char(trans_date, \\'YYYY-MM\\'),country\\norder by to_char(trans_date, \\'YYYY-MM\\')",
                "solutionTags": [],
                "code": "select to_char(trans_date, \\'YYYY-MM\\') month,\\ncountry, \\ncount(state) trans_count, \\nsum(case when state = \\'approved\\' then 1 else 0 end) approved_count,\\nsum(amount) trans_total_amount,\\ncoalesce(sum(case when state = \\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions \\ngroup by to_char(trans_date, \\'YYYY-MM\\'),country\\norder by to_char(trans_date, \\'YYYY-MM\\')",
                "codeTag": "Unknown"
            },
            {
                "id": 776688,
                "title": "simple-mysql",
                "content": "```\\nselect  month, \\ncountry, \\ncount(state) as trans_count, \\nsum(approve_state)  as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(approve_amount) as approved_total_amount\\nfrom\\n(select country, amount, state, left(trans_date, 7) as month,\\ncase when state = \\'approved\\' then 1 else 0 end as approve_state,\\ncase when state = \\'approved\\' then amount else 0 end as approve_amount\\nfrom Transactions)t\\ngroup by 1, 2\\norder by 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect  month, \\ncountry, \\ncount(state) as trans_count, \\nsum(approve_state)  as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(approve_amount) as approved_total_amount\\nfrom\\n(select country, amount, state, left(trans_date, 7) as month,\\ncase when state = \\'approved\\' then 1 else 0 end as approve_state,\\ncase when state = \\'approved\\' then amount else 0 end as approve_amount\\nfrom Transactions)t\\ngroup by 1, 2\\norder by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750131,
                "title": "simple-solution",
                "content": "```\\nSELECT month, country, \\n       COUNT(state) AS trans_count, \\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount, \\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM (SELECT *, DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month FROM Transactions) tm\\nGROUP BY month, country;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT month, country, \\n       COUNT(state) AS trans_count, \\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount, \\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM (SELECT *, DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month FROM Transactions) tm\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 577620,
                "title": "very-easy-mysql-solution",
                "content": "```\\nselect\\n    left(trans_date,7) as month\\n    ,country\\n    ,count(*) as trans_count\\n    ,sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count\\n    ,sum(amount) as trans_total_amount\\n    ,sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom\\n    Transactions\\ngroup by\\n    left(trans_date,7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    left(trans_date,7) as month\\n    ,country\\n    ,count(*) as trans_count\\n    ,sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count\\n    ,sum(amount) as trans_total_amount\\n    ,sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom\\n    Transactions\\ngroup by\\n    left(trans_date,7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512749,
                "title": "mysql-simple-solution",
                "content": "```\\nSELECT LEFT(trans_date, 7) AS month, country,\\n       COUNT(state) AS trans_count,\\n       SUM(state=\\'approved\\') AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT LEFT(trans_date, 7) AS month, country,\\n       COUNT(state) AS trans_count,\\n       SUM(state=\\'approved\\') AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488576,
                "title": "simple-oracle-solution",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nselect to_char(t.trans_date,\\'YYYY-MM\\') month, t.country, COUNT(t.id) trans_count, \\nSUM(case when t.state = \\'approved\\' then 1 else 0 end) approved_count,SUM(amount) trans_total_amount,\\nSUM(case when t.state = \\'approved\\' then t.amount else 0 end) approved_total_amount\\nfrom Transactions t\\ngroup by to_char(t.trans_date,\\'YYYY-MM\\'),t.country\\norder by 1 asc\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect to_char(t.trans_date,\\'YYYY-MM\\') month, t.country, COUNT(t.id) trans_count, \\nSUM(case when t.state = \\'approved\\' then 1 else 0 end) approved_count,SUM(amount) trans_total_amount,\\nSUM(case when t.state = \\'approved\\' then t.amount else 0 end) approved_total_amount\\nfrom Transactions t\\ngroup by to_char(t.trans_date,\\'YYYY-MM\\'),t.country\\norder by 1 asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470306,
                "title": "mysql-simple",
                "content": "```\\nselect \\nDATE_FORMAT(trans_date, \"%Y-%m\") as month,\\ncountry ,\\ncount(*) as trans_count,\\nsum(state=\\'approved\\') as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n\\nfrom Transactions\\ngroup by\\n DATE_FORMAT(trans_date, \"%Y-%m\"),country\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\nDATE_FORMAT(trans_date, \"%Y-%m\") as month,\\ncountry ,\\ncount(*) as trans_count,\\nsum(state=\\'approved\\') as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n\\nfrom Transactions\\ngroup by\\n DATE_FORMAT(trans_date, \"%Y-%m\"),country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 450723,
                "title": "simple-ms-sql-no-sub-query-no-join",
                "content": "```\\nselect left(trans_date,7) as \\'month\\',\\n\\tcountry,\\n\\tcount(id) as trans_count,\\n\\tsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n\\tsum(amount) as trans_total_amount,\\n\\tsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect left(trans_date,7) as \\'month\\',\\n\\tcountry,\\n\\tcount(id) as trans_count,\\n\\tsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n\\tsum(amount) as trans_total_amount,\\n\\tsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 445041,
                "title": "simple-mysql-with-date-format-function",
                "content": "```\\nSELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,\\ncountry,\\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1,2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,\\ncountry,\\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 430904,
                "title": "mysql-easy-understanding-only-use-case-when",
                "content": "\\n    select month,\\n\\t\\tcountry,\\n\\t\\tcount(*) as trans_count,\\n\\t\\tsum(case state when \\'approved\\' then 1 else 0 end) as approved_count,\\n\\t\\tsum(amount) as trans_total_amount,\\n\\t\\tsum(case state when \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\tfrom \\n\\t\\t(\\n\\t\\tselect country,state,amount,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month\\n\\t\\tfrom transactions\\n\\t\\t) a\\n\\t\\tgroup by month, country",
                "solutionTags": [],
                "code": "\\n    select month,\\n\\t\\tcountry,\\n\\t\\tcount(*) as trans_count,\\n\\t\\tsum(case state when \\'approved\\' then 1 else 0 end) as approved_count,\\n\\t\\tsum(amount) as trans_total_amount,\\n\\t\\tsum(case state when \\'approved\\' then amount else 0 end) as approved_total_amount\\n\\tfrom \\n\\t\\t(\\n\\t\\tselect country,state,amount,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month\\n\\t\\tfrom transactions\\n\\t\\t) a\\n\\t\\tgroup by month, country",
                "codeTag": "Unknown"
            },
            {
                "id": 401938,
                "title": "simple-mysql-solution",
                "content": "```\\nselect left(trans_date, 7) as \"month\",\\n       country, \\n       count(id) as \"trans_count\",\\n       sum(case when state=\"approved\" then 1 else 0 end) as \"approved_count\",\\n       sum(amount) as \"trans_total_amount\",\\n       sum(case when state=\"approved\" then amount else 0 end) as \"approved_total_amount\"\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "solutionTags": [],
                "code": "```\\nselect left(trans_date, 7) as \"month\",\\n       country, \\n       count(id) as \"trans_count\",\\n       sum(case when state=\"approved\" then 1 else 0 end) as \"approved_count\",\\n       sum(amount) as \"trans_total_amount\",\\n       sum(case when state=\"approved\" then amount else 0 end) as \"approved_total_amount\"\\nfrom Transactions\\ngroup by left(trans_date, 7), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392625,
                "title": "mysql-solution-w-grouping-and-aggregation",
                "content": "```\\nselect \\n    date_format(trans_date, \\'%Y-%m\\') \\'month\\',\\n    country,\\n    count(*) \\'trans_count\\',\\n    sum(state = \\'approved\\') \\'approved_count\\',\\n    sum(amount) \\'trans_total_amount\\',\\n    sum(case when state = \\'approved\\' then amount else 0 end) \\'approved_total_amount\\'\\nfrom \\n    Transactions\\ngroup by \\n    month, country\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n    date_format(trans_date, \\'%Y-%m\\') \\'month\\',\\n    country,\\n    count(*) \\'trans_count\\',\\n    sum(state = \\'approved\\') \\'approved_count\\',\\n    sum(amount) \\'trans_total_amount\\',\\n    sum(case when state = \\'approved\\' then amount else 0 end) \\'approved_total_amount\\'\\nfrom \\n    Transactions\\ngroup by \\n    month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383992,
                "title": "mysql-solution-using-case-when-and-group-by",
                "content": "SELECT \\n  DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month, \\n  country, \\n  COUNT(id) AS trans_count, \\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country",
                "solutionTags": [],
                "code": "SELECT \\n  DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month, \\n  country, \\n  COUNT(id) AS trans_count, \\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country",
                "codeTag": "Unknown"
            },
            {
                "id": 383931,
                "title": "simple-mysql-solution-without-using-join",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date,1,7) as month,\\ncountry,\\nCOUNT(*) as trans_count,\\nSUM(CASE WHEN state=\"approved\" THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date,1,7) as month,\\ncountry,\\nCOUNT(*) as trans_count,\\nSUM(CASE WHEN state=\"approved\" THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGROUP BY month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106568,
                "title": "using-case-and-sum-basic-aggregate-functions-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\nUsing CASE() and SUM()\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country;\\n\\n```\\n\\n# Explanation\\n**SELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,**\\n\\n-- This line of code specifies that we want to format the \\'trans_date\\' column as \\'%Y-%m\\' to get the year and month.\\n-- It also aliases the result as \\'month\\'.\\n    \\n-- In the next part of the query, we\\'re performing calculations on the grouped data.\\n\\n---\\n\\n**COUNT( * ) AS trans_count,**\\n-- count(*) as trans_count:\\n-- This part counts the number of rows (transactions) in each group (month and country).\\n\\n\\n---\\n\\n**SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,**\\n-- sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count:\\n-- Here, we use a conditional statement to count the number of rows with \\'state\\' equal to \\'approved\\'.\\n    \\n\\n---\\n\\n**SUM(amount) AS trans_total_amount,**\\n-- 3. sum(amount) as trans_total_amount:\\n-- This sums up the \\'amount\\' column for all rows in each group, giving the total transaction amount.\\n    \\n\\n---\\n\\n **SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount**\\n-- 4. sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount:\\n-- Similar to the second calculation, this sums up the \\'amount\\' column for rows where \\'state\\' is \\'approved\\'.\\n   \\n\\n---\\n\\n\\n\\n# Please Upvote the Solution!",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102417,
                "title": "better-than-80-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect CONCAT(YEAR(trans_date), \\'-\\', LPAD(MONTH(trans_date), 2, \\'0\\')) as month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count,\\nsum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by year(trans_date), Month(trans_date), country\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect CONCAT(YEAR(trans_date), \\'-\\', LPAD(MONTH(trans_date), 2, \\'0\\')) as month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count,\\nsum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\nfrom transactions\\ngroup by year(trans_date), Month(trans_date), country\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100737,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country, month\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100216,
                "title": "beats-85-users-sum-if-with-sub-query",
                "content": "# Complexity\\n- Time complexity: 1001 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0.00 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  a.`month`\\n       ,a.country\\n       ,count(*) as trans_count\\n       ,sum(a.approved_count) as approved_count\\n       ,sum(a.amount) as trans_total_amount\\n       ,sum(a.approved_amount) as approved_total_amount\\nfrom (\\n    select DATE_FORMAT(trans_date,\\'%Y-%m\\') as `month`\\n       ,country\\n       ,if(state = \\'approved\\', 1, 0) as approved_count\\n       ,amount\\n       ,if(state = \\'approved\\', amount, 0) as approved_amount\\n    from Transactions\\n) a\\ngroup by a.`month`\\n         ,a.country\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  a.`month`\\n       ,a.country\\n       ,count(*) as trans_count\\n       ,sum(a.approved_count) as approved_count\\n       ,sum(a.amount) as trans_total_amount\\n       ,sum(a.approved_amount) as approved_total_amount\\nfrom (\\n    select DATE_FORMAT(trans_date,\\'%Y-%m\\') as `month`\\n       ,country\\n       ,if(state = \\'approved\\', 1, 0) as approved_count\\n       ,amount\\n       ,if(state = \\'approved\\', amount, 0) as approved_amount\\n    from Transactions\\n) a\\ngroup by a.`month`\\n         ,a.country\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097803,
                "title": "monthly-transactions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\n#elect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count , SUM(amount) AS trans_total_amount , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount FROM Transactions GROUP BY month, country\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount from transactions group by month,country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\n#elect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count , SUM(amount) AS trans_total_amount , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount FROM Transactions GROUP BY month, country\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, count(*) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state=\\'approved\\',amount,0)) as approved_total_amount from transactions group by month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097620,
                "title": "go-with-asking-statement-for-beginners-mysql",
                "content": "\\n# Code\\n```\\nselect date_format(trans_date , \\'%Y-%m\\') as month , country , \\ncount(state) as  trans_count , \\nSum(case when state = \\'approved\\' then 1 else 0 end) as approved_count , \\nsum(amount) as trans_total_amount , \\nSUM(case when state = \\'approved\\' then amount else 0 end ) as approved_total_amount\\n\\nfrom Transactions \\ngroup by date_format(trans_date , \\'%Y-%m\\') , country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect date_format(trans_date , \\'%Y-%m\\') as month , country , \\ncount(state) as  trans_count , \\nSum(case when state = \\'approved\\' then 1 else 0 end) as approved_count , \\nsum(amount) as trans_total_amount , \\nSUM(case when state = \\'approved\\' then amount else 0 end ) as approved_total_amount\\n\\nfrom Transactions \\ngroup by date_format(trans_date , \\'%Y-%m\\') , country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097459,
                "title": "step-by-step-easy-mysql-solution-with-date-format",
                "content": "# Intuition\\nMonthly Transactions I\\n# Approach\\nUse DATE_FORMAT(col_name,\\'%Y-%m\\') to find month of the year. Use if condition alonfg with sum to find approved state count.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date,\\'%Y-%m\\') \\'month\\',country,count(state) \\'trans_count\\',sum(if(state=\\'approved\\',1,0)) \\'approved_count\\', sum(amount) \\'trans_total_amount\\', sum(if(state=\\'approved\\',amount,0)) \\'approved_total_amount\\' from Transactions group by month,country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date,\\'%Y-%m\\') \\'month\\',country,count(state) \\'trans_count\\',sum(if(state=\\'approved\\',1,0)) \\'approved_count\\', sum(amount) \\'trans_total_amount\\', sum(if(state=\\'approved\\',amount,0)) \\'approved_total_amount\\' from Transactions group by month,country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096584,
                "title": "sql-server-simple-solution-using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,format(trans_date,\\'yyyy-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,format(trans_date,\\'yyyy-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096580,
                "title": "mysql-simple-solution-using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,DATE_FORMAT(trans_date,\\'%Y-%m\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096575,
                "title": "oracle-simple-solution-using-cte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,to_char(trans_date,\\'YYYY-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith t as (\\n  SELECT id,country,state,amount,trans_date,to_char(trans_date,\\'YYYY-MM\\') as month,\\n  case when state = \\'approved\\' then 1 else 0 end as coef\\n  FROM Transactions\\n)\\nSELECT month, country,count(*) as trans_count, sum(coef) as approved_count, sum(amount) as trans_total_amount , sum(amount*coef) as approved_total_amount \\nFROM t\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095939,
                "title": "clean-single-select",
                "content": "# CLEAN SINGLE SELECT\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') \"month\", \\n        country,\\n        COUNT(state) \"trans_count\",\\n        SUM(IF(state = \"approved\", 1, 0)) \\'approved_count\\',\\n        SUM(amount) \"trans_total_amount\",\\n        SUM(IF(state= \"approved\", amount, 0)) \\'approved_total_amount\\'\\nFROM Transactions t\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') \"month\", \\n        country,\\n        COUNT(state) \"trans_count\",\\n        SUM(IF(state = \"approved\", 1, 0)) \\'approved_count\\',\\n        SUM(amount) \"trans_total_amount\",\\n        SUM(IF(state= \"approved\", amount, 0)) \\'approved_total_amount\\'\\nFROM Transactions t\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095863,
                "title": "faster-than-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n  country, \\n  count(*) as trans_count, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then 1 else 0 end\\n  ) as approved_count, \\n  sum(Transactions.amount) as trans_total_amount, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then Transactions.amount else 0 end\\n  ) as approved_total_amount \\nfrom \\n  Transactions \\ngroup by \\n  country, \\n  month\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n  DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n  country, \\n  count(*) as trans_count, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then 1 else 0 end\\n  ) as approved_count, \\n  sum(Transactions.amount) as trans_total_amount, \\n  sum(\\n    case when Transactions.state = \\'approved\\' then Transactions.amount else 0 end\\n  ) as approved_total_amount \\nfrom \\n  Transactions \\ngroup by \\n  country, \\n  month\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095393,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSelect \\n    LEFT(trans_date, char_length(trans_date) - 3) as month,\\n    country,\\n    count(*) as  trans_count,\\n    SUM(if(state = \\'approved\\', 1, 0)) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions trx\\ngroup by month, country;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSelect \\n    LEFT(trans_date, char_length(trans_date) - 3) as month,\\n    country,\\n    count(*) as  trans_count,\\n    SUM(if(state = \\'approved\\', 1, 0)) as approved_count,\\n    SUM(amount) as trans_total_amount,\\n    SUM(if(state = \\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions trx\\ngroup by month, country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094934,
                "title": "remember-to-sum-after-using-case-when",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n    country, \\n    COUNT(*) as trans_count, \\n    SUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM((CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END)) as approved_total_amount\\nFROM Transactions \\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, \\n    country, \\n    COUNT(*) as trans_count, \\n    SUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)) as approved_count, \\n    SUM(amount) as trans_total_amount, \\n    SUM((CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END)) as approved_total_amount\\nFROM Transactions \\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093298,
                "title": "easy-and-fun",
                "content": "Simple use case of aggregate functions with filters\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    count(1) trans_count,\\n    sum(if(state = \\'approved\\',1,0)) approved_count,\\n    sum(amount) trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) approved_total_amount\\n  from transactions\\n  group by 1, 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n    country,\\n    count(1) trans_count,\\n    sum(if(state = \\'approved\\',1,0)) approved_count,\\n    sum(amount) trans_total_amount,\\n    sum(if(state = \\'approved\\',amount,0)) approved_total_amount\\n  from transactions\\n  group by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091721,
                "title": "beats-81-users-in-time-and-100-users-in-memory-simple-approach-using-group-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry, count(1) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect date_format(trans_date, \\'%Y-%m\\') as month,\\ncountry, count(1) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom Transactions\\ngroup by 1, 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091609,
                "title": "good-but-complex-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect concat(\\'20\\',r.da) as month,r.country,trans_count,coalesce(approved_count,0) as approved_count,trans_total_amount,coalesce(approved_total_amount,0) as approved_total_amount\\nfrom (select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as trans_count,sum(amount) as trans_total_amount from transactions group by country,month(trans_date),year(trans_date)) as r\\nleft join\\n(select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as approved_count,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by country,month(trans_date),year(trans_date)) as rp\\non r.da=rp.da and r.country=rp.country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect concat(\\'20\\',r.da) as month,r.country,trans_count,coalesce(approved_count,0) as approved_count,trans_total_amount,coalesce(approved_total_amount,0) as approved_total_amount\\nfrom (select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as trans_count,sum(amount) as trans_total_amount from transactions group by country,month(trans_date),year(trans_date)) as r\\nleft join\\n(select date_format(trans_date,\"%y-%m\") as da,country,count(amount) as approved_count,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by country,month(trans_date),year(trans_date)) as rp\\non r.da=rp.da and r.country=rp.country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090780,
                "title": "mysql-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nSelect date_format(trans_date, \\'%Y-%m\\') as month\\n, country\\n, count(id) as trans_count\\n, count(if(state = \\'approved\\', 1, null) ) as approved_count\\n, sum(amount) as trans_total_amount\\n, sum(if(state=\\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions t\\nGroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nSelect date_format(trans_date, \\'%Y-%m\\') as month\\n, country\\n, count(id) as trans_count\\n, count(if(state = \\'approved\\', 1, null) ) as approved_count\\n, sum(amount) as trans_total_amount\\n, sum(if(state=\\'approved\\', amount, 0)) as approved_total_amount\\nfrom Transactions t\\nGroup by date_format(trans_date, \\'%Y-%m\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090174,
                "title": "please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect *\\nfrom Transactions t\\nwhere state = \\'approved\\'\\n)\\nselect DATE_FORMAT(t.trans_date,  \\'%Y-%m\\') as month,\\nt.country,\\ncount(t.id) as trans_count,\\nsum(t.state = \\'approved\\') as approved_count,\\nsum(t.amount) as trans_total_amount,\\nCOALESCE(sum(cte.amount), 0) as approved_total_amount \\nfrom Transactions t\\nleft outer join cte on cte.id = t.id\\ngroup by country, DATE_FORMAT(trans_date,  \\'%Y-%m\\')\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect *\\nfrom Transactions t\\nwhere state = \\'approved\\'\\n)\\nselect DATE_FORMAT(t.trans_date,  \\'%Y-%m\\') as month,\\nt.country,\\ncount(t.id) as trans_count,\\nsum(t.state = \\'approved\\') as approved_count,\\nsum(t.amount) as trans_total_amount,\\nCOALESCE(sum(cte.amount), 0) as approved_total_amount \\nfrom Transactions t\\nleft outer join cte on cte.id = t.id\\ngroup by country, DATE_FORMAT(trans_date,  \\'%Y-%m\\')\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087156,
                "title": "sql-simple-solution",
                "content": "# Code\\n``` mysql []\\n# Write your MySQL query statement below\\n\\nSELECT\\n    date_format(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```\\n``` mssql []\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    format(min(trans_date), \\'yyyy-MM\\') AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "``` mysql []\\n# Write your MySQL query statement below\\n\\nSELECT\\n    date_format(trans_date, \"%Y-%m\") AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```\n``` mssql []\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    format(min(trans_date), \\'yyyy-MM\\') AS month,\\n    country,\\n    count(*) AS trans_count,\\n    sum(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n    sum(amount) AS trans_total_amount,\\n    sum(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY year(trans_date), month(trans_date), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086364,
                "title": "two-solutions-one-large-and-a-bit-complex-and-one-short-and-easy",
                "content": "# 1. Code\\n```\\nSELECT trans.month, trans.country, COALESCE(trans_count, 0) AS trans_count, COALESCE(approved_count, 0) AS approved_count, COALESCE(trans_total_amount, 0) AS trans_total_amount, COALESCE(approved_total_amount, 0) AS approved_total_amount FROM\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS trans_count, SUM(amount) AS trans_total_amount\\nFROM transactions\\nGROUP BY month, country) AS trans\\nLEFT JOIN\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS approved_count, SUM(amount) AS approved_total_amount\\nFROM transactions\\nWHERE state = \"approved\"\\nGROUP BY month, country) AS approved\\nON trans.month = approved.month AND trans.country = approved.country \\n\\n```\\n\\n# 2. Code\\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(state) AS trans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, SUM(amount) AS trans_total_amount, SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT trans.month, trans.country, COALESCE(trans_count, 0) AS trans_count, COALESCE(approved_count, 0) AS approved_count, COALESCE(trans_total_amount, 0) AS trans_total_amount, COALESCE(approved_total_amount, 0) AS approved_total_amount FROM\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS trans_count, SUM(amount) AS trans_total_amount\\nFROM transactions\\nGROUP BY month, country) AS trans\\nLEFT JOIN\\n(SELECT DISTINCT(DATE_FORMAT(trans_date, \\'%Y-%m\\')) AS month, country, COUNT(state) AS approved_count, SUM(amount) AS approved_total_amount\\nFROM transactions\\nWHERE state = \"approved\"\\nGROUP BY month, country) AS approved\\nON trans.month = approved.month AND trans.country = approved.country \\n\\n```\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, country, COUNT(state) AS trans_count, SUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, SUM(amount) AS trans_total_amount, SUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY month, country \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085563,
                "title": "easy-sql",
                "content": "\\n\\n# Code\\n```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\nLEFT(trans_date, 7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084890,
                "title": "beats-100-in-memory-usage-simple-group-by-case",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country,count(id) as trans_count,\\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by DATE_FORMAT(trans_date, \\'%Y-%m\\'),country;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect date_format(trans_date, \\'%Y-%m\\') as month,country,count(id) as trans_count,\\nsum(case when state = \\'approved\\' then 1 else 0 end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions\\ngroup by DATE_FORMAT(trans_date, \\'%Y-%m\\'),country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082703,
                "title": "single-query-solving-using-if-condition",
                "content": "# Intuition\\nShould be performed in 1 single query without using subqueries\\n\\n# Approach\\nTry going 1 column at a time satisfying the conditions as you move left to right. Using simple if conditions can ensure the approved transactions to be considered accordingly and use 0 in the else block to avoid counting the invalid ones\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) month, country,count(id) trans_count,sum(if(state=\\'approved\\',1,0))  approved_count,sum(amount) trans_total_amount,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions \\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) month, country,count(id) trans_count,sum(if(state=\\'approved\\',1,0))  approved_count,sum(amount) trans_total_amount,sum(if(state=\\'approved\\',amount,0)) approved_total_amount\\nfrom transactions \\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082679,
                "title": "top-99-solution-using-if",
                "content": "# Explanation\\nThis code uses SUBSTR() on the trans date to get the date for each month. We then get the count for the dates to figure out what the total count of transactions was on each date. Then using if statements we get the number of approved transactions. And we get the sum of amount as the total amount of money. Then we get the total approved amount by only summing up the transaction amounts that were approved. We group by month and country to get a row for each month, as well as for each country. **Like if this was useful please**.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date, 1, 7) AS month, country, COUNT(trans_date) AS trans_count,\\nSUM(IF(state = \\'approved\\', 1, 0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT SUBSTR(trans_date, 1, 7) AS month, country, COUNT(trans_date) AS trans_count,\\nSUM(IF(state = \\'approved\\', 1, 0)) AS approved_count, SUM(amount) AS trans_total_amount,\\nSUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082313,
                "title": "easy-solution-using-aggregation",
                "content": "# Code\\n```\\nSELECT \\nsubstr(trans_date, 1,7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\nsubstr(trans_date, 1,7) AS month, country, \\nCOUNT(id) AS trans_count, \\nSUM(state = \\'approved\\') AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE \\n    WHEN state = \\'approved\\' THEN amount \\n    ELSE 0 \\n    END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081829,
                "title": "built-using-basics",
                "content": "with table1 as(\\nselect id,country,amount,date_format(trans_date,\\'%Y-%m\\') as month , case\\nwhen state = \\'approved\\' then 1\\nelse 0 end as state from transactions),\\ntable2 as(\\nselect distinct month ,country , sum((if(state = 1,amount,0))) over(partition by country,month) as approved_total_amount from table1)\\nselect distinct t1.month , t1.country , count(state) over(partition by t1.country,t1.month) as trans_count, sum(state) over(partition by t1.country,t1.month) as approved_count , sum(amount) over(partition by t1.country,t1.month) as trans_total_amount , approved_total_amount \\nfrom table1 t1 join table2 t2\\non t1.month = t2.month and t1.country=t2.country\\norder by t1.country desc;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with table1 as(\\nselect id,country,amount,date_format(trans_date,\\'%Y-%m\\') as month , case\\nwhen state = \\'approved\\' then 1\\nelse 0 end as state from transactions),\\ntable2 as(\\nselect distinct month ,country , sum((if(state = 1,amount,0))) over(partition by country,month) as approved_total_amount from table1)\\nselect distinct t1.month , t1.country , count(state) over(partition by t1.country,t1.month) as trans_count, sum(state) over(partition by t1.country,t1.month) as approved_count , sum(amount) over(partition by t1.country,t1.month) as trans_total_amount , approved_total_amount \\nfrom table1 t1 join table2 t2\\non t1.month = t2.month and t1.country=t2.country\\norder by t1.country desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 4081065,
                "title": "simple-code",
                "content": "SubStr() is used to convert the date to yyyy-mm, if statement is used to get approved count and case statement is used tto get approved total count and then group by month and country\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect substr(trans_date,1,7) as month, country,count(id) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(CASE when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by month,country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect substr(trans_date,1,7) as month, country,count(id) as trans_count, sum(if(state=\\'approved\\',1,0)) as approved_count, sum(amount) as trans_total_amount, sum(CASE when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by month,country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080342,
                "title": "simple-clean-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month ,\\ncountry,count(id) as trans_count, \\nsum(case state when \\'approved\\' then 1 else 0 end)  as approved_count ,\\nsum(amount) as trans_total_amount , \\nsum(case WHEN state = \\'approved\\' then amount else 0 END)  as approved_total_amount\\nfrom Transactions\\nGROUP BY month, country\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month ,\\ncountry,count(id) as trans_count, \\nsum(case state when \\'approved\\' then 1 else 0 end)  as approved_count ,\\nsum(amount) as trans_total_amount , \\nsum(case WHEN state = \\'approved\\' then amount else 0 END)  as approved_total_amount\\nfrom Transactions\\nGROUP BY month, country\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080319,
                "title": "easy-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, COUNTRY,\\nCOUNT(ID) AS TRANS_COUNT,\\nSUM(IF(STATE = \\'approved\\',1,0)) AS APPROVED_COUNT,\\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\nSUM(IF(STATE = \\'approved\\',AMOUNT,0)) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY MONTH, COUNTRY;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, COUNTRY,\\nCOUNT(ID) AS TRANS_COUNT,\\nSUM(IF(STATE = \\'approved\\',1,0)) AS APPROVED_COUNT,\\nSUM(AMOUNT) AS TRANS_TOTAL_AMOUNT,\\nSUM(IF(STATE = \\'approved\\',AMOUNT,0)) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS\\nGROUP BY MONTH, COUNTRY;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079161,
                "title": "group-by-solution-with-aggregations-explained-in-details",
                "content": "# Intuition\\nFrom example we know the result has to be groupped by date and country, after that we just need to use aggregation opperations to get certain resulting columns.\\n\\n# Approach\\nFormatting Date: \\nThe DATE_FORMAT function is used to convert the trans_date field into the desired format.\\n\\nCounting Transactions:\\nCOUNT(trans_date): Counts the total number of transactions for each month and country.\\nCOUNT(CASE ...): Counts the number of approved transactions for each month and country.\\n\\nSumming Amounts:\\nSUM(amount): Calculates the total transaction amount for each month and country.\\nSUM(CASE ...): Calculates the total amount for approved transactions for each month and country.\\nGrouping and Aggregating: The data is then grouped by month and country, and aggregate functions are applied to calculate the desired metrics.\\n\\n# Complexity\\n- Time complexity:\\nOverall, the time complexity of the entire query is dominated by the GROUP BY operation, so it\\'s $$O(n log n)$$\\n\\n- Space complexity:\\n$$O(7)$$\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, count(trans_date) as trans_count,\\ncount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions \\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, count(trans_date) as trans_count,\\ncount(case when state = \\'approved\\' then 1 else null end) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions \\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078487,
                "title": "easy-solution-explanation-for-sum-state-approved",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n      DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n      country,\\n      COUNT(id) AS trans_count,\\n      SUM(state = \\'approved\\') AS approved_count,\\n      SUM(amount) AS trans_total_amount,\\n      SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country;\\n```\\n\\n**In case you are wondering why I have used ```SUM(state=\\'approved\\')``` instead of ```COUNT(state=\\'approved\\')``` to calculate  approved_count:**\\n\\n- ```SUM(state=\\'approved\\'):``` This expression is using the ```SUM``` function to count the number of rows where the ```state``` column equals \\'**approved**\\'. It works as expected because ```SUM``` is an aggregation function that counts the number of true values in the specified condition. In SQL, ```true``` is typically represented as **1**, and false as **0**. So, by summing up the ```true``` values, you effectively count the rows where the condition is met.\\n\\n- ```COUNT(state=\\'approved\\'):``` This expression is using the ```COUNT``` function to count the number of rows where the ```state``` column equals \\'approved\\'. However, ```COUNT``` is an aggregation function that counts the number of **non-null** values in a column. It doesn\\'t work as expected for conditions like ```state=\\'approved\\'``` because it doesn\\'t directly count ```true``` or ```false``` values. Instead, it counts the number of non-null rows, and in this case, it counts all rows, including those where ```state``` is \\'**declined**\\', because \\'**declined**\\' is also a non-null value.\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n      DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n      country,\\n      COUNT(id) AS trans_count,\\n      SUM(state = \\'approved\\') AS approved_count,\\n      SUM(amount) AS trans_total_amount,\\n      SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions\\nGROUP BY month, country;\\n```\n```SUM(state=\\'approved\\')```\n```COUNT(state=\\'approved\\')```\n```SUM(state=\\'approved\\'):```\n```SUM```\n```state```\n```SUM```\n```true```\n```true```\n```COUNT(state=\\'approved\\'):```\n```COUNT```\n```state```\n```COUNT```\n```state=\\'approved\\'```\n```true```\n```false```\n```state```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077553,
                "title": "pandas-3-lines",
                "content": "# Intuition\\nIt\\'s very simple solution with just 2 simple initial transformations:\\n1. full date to year-month\\n2. approved amount column - when state is \\'approved\\' we give amount, else `None`; this is important, becouse it\\'s ignored during summing and counting. Normally, if value is anything but `None`, it\\'s always counted as 1, no matter it\\'s value or dtype.\\n\\nFinally just create multiple required columns with one .agg() method.\\n\\n# Code\\n```\\nimport pandas as pd\\nimport numpy as np\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\"month\"] = transactions[\"trans_date\"].dt.strftime(\"%Y-%m\")\\n    transactions[\"appr_amnt\"] = np.where(transactions.state == \"approved\", transactions[\"amount\"], None)\\n    return transactions.groupby([\"month\",\"country\"], as_index = False).agg(trans_count=(\"amount\",\"count\"), approved_count =(\"appr_amnt\",\"count\"), trans_total_amount = (\"amount\",\"sum\"), approved_total_amount = (\"appr_amnt\",\"sum\"))\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\nimport numpy as np\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\"month\"] = transactions[\"trans_date\"].dt.strftime(\"%Y-%m\")\\n    transactions[\"appr_amnt\"] = np.where(transactions.state == \"approved\", transactions[\"amount\"], None)\\n    return transactions.groupby([\"month\",\"country\"], as_index = False).agg(trans_count=(\"amount\",\"count\"), approved_count =(\"appr_amnt\",\"count\"), trans_total_amount = (\"amount\",\"sum\"), approved_total_amount = (\"appr_amnt\",\"sum\"))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4076204,
                "title": "mssql",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    cast(trans_date as varchar(7)) as month, --actually this is hack\\n    country,\\n    count(*) as trans_count,\\n    sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by\\n    cast(trans_date as varchar(7)),\\n    country\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    cast(trans_date as varchar(7)) as month, --actually this is hack\\n    country,\\n    count(*) as trans_count,\\n    sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount \\nfrom Transactions\\ngroup by\\n    cast(trans_date as varchar(7)),\\n    country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074288,
                "title": "my-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as \\'month\\', \\n    country,\\n    COUNT(id) as \\'trans_count\\',\\n    SUM(CASE \\n            WHEN state = \\'approved\\'\\n            THEN 1\\n            ELSE 0\\n        END) as \\'approved_count\\',\\n    SUM(amount) as \\'trans_total_amount\\',\\n    SUM(CASE\\n            WHEN state = \\'approved\\'\\n            THEN amount\\n            ELSE 0\\n        END) as \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY country, month\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') as \\'month\\', \\n    country,\\n    COUNT(id) as \\'trans_count\\',\\n    SUM(CASE \\n            WHEN state = \\'approved\\'\\n            THEN 1\\n            ELSE 0\\n        END) as \\'approved_count\\',\\n    SUM(amount) as \\'trans_total_amount\\',\\n    SUM(CASE\\n            WHEN state = \\'approved\\'\\n            THEN amount\\n            ELSE 0\\n        END) as \\'approved_total_amount\\'\\nFROM Transactions\\nGROUP BY country, month\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074259,
                "title": "easy-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\nDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\nDATE_FORMAT(trans_date, \\'%Y-%m\\') AS month,\\n       country,\\n       COUNT(id) AS trans_count,\\n       SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n       SUM(amount) AS trans_total_amount,\\n       SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\'), country;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073968,
                "title": "case-mysql-solution",
                "content": "\\n# Approach\\nUsing DATE_FORMAT (DATE, \\'%Y-%m\\') you obtain the Month-Year format, that you have to use in the SELECT  and in the Group By.\\nFor the Trans_Count you can simply count the IDs, and for the Approved you can use SUM(CASE) with Approved being 1 and else being 0.\\nSame thing for the amount, but instead of 1 you use the amount value\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\') AS MONTH\\n, T.COUNTRY\\n, COUNT(T.ID) AS TRANS_COUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT\\n, SUM(T.AMOUNT)  AS TRANS_TOTAL_AMOUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN T.AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS T\\nGROUP BY DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\'), T.COUNTRY\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\') AS MONTH\\n, T.COUNTRY\\n, COUNT(T.ID) AS TRANS_COUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN 1 ELSE 0 END) AS APPROVED_COUNT\\n, SUM(T.AMOUNT)  AS TRANS_TOTAL_AMOUNT\\n, SUM(CASE WHEN T.STATE = \\'APPROVED\\' THEN T.AMOUNT ELSE 0 END) AS APPROVED_TOTAL_AMOUNT\\nFROM TRANSACTIONS T\\nGROUP BY DATE_FORMAT(T.TRANS_DATE, \\'%Y-%m\\'), T.COUNTRY\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072286,
                "title": "beats-97-57-of-users-with-mysql-using-date-format-group-by",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT\\n    DATE_FORMAT(trans_date,\"%Y-%m\") AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \"approved\" THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \"approved\" THEN amount ELSE 0 END) AS approved_total_amount \\nFROM transactions\\nGROUP BY 1,2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT\\n    DATE_FORMAT(trans_date,\"%Y-%m\") AS month,\\n    country,\\n    COUNT(*) AS trans_count,\\n    SUM(CASE WHEN state = \"approved\" THEN 1 ELSE 0 END) AS approved_count,\\n    SUM(amount) AS trans_total_amount,\\n    SUM(CASE WHEN state = \"approved\" THEN amount ELSE 0 END) AS approved_total_amount \\nFROM transactions\\nGROUP BY 1,2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070775,
                "title": "easy-solution",
                "content": "select date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount\\n, sum(case when state =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions group by country, date_format(trans_date,\\'%Y-%m\\');",
                "solutionTags": [],
                "code": "select date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount\\n, sum(case when state =\\'approved\\' then amount else 0 end) as approved_total_amount\\nfrom transactions group by country, date_format(trans_date,\\'%Y-%m\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 4070090,
                "title": "without-using-case",
                "content": "\\n# Code\\n```\\nSELECT DATE_FORMAT(t1.trans_date, \"%Y-%m\") AS month, \\n  t1.country,\\n  count(t1.id) AS trans_count,\\n  count(t2.id) AS approved_count,\\n  SUM(t1.amount) AS trans_total_amount,\\n  IFNULL(SUM(t2.amount),0) AS approved_total_amount\\nFROM Transactions t1 LEFT JOIN \\n(\\n  SELECT * \\n  FROM Transactions\\n  WHERE state = \\'approved\\'\\n)t2 \\nON t1.id = t2.id\\nGROUP BY country, DATE_FORMAT(trans_date, \"%Y-%m\")\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(t1.trans_date, \"%Y-%m\") AS month, \\n  t1.country,\\n  count(t1.id) AS trans_count,\\n  count(t2.id) AS approved_count,\\n  SUM(t1.amount) AS trans_total_amount,\\n  IFNULL(SUM(t2.amount),0) AS approved_total_amount\\nFROM Transactions t1 LEFT JOIN \\n(\\n  SELECT * \\n  FROM Transactions\\n  WHERE state = \\'approved\\'\\n)t2 \\nON t1.id = t2.id\\nGROUP BY country, DATE_FORMAT(trans_date, \"%Y-%m\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070008,
                "title": "simple-solution",
                "content": "# Common mistake\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUSE SUM ELSE YOU WILL GET THIS ERROR\\n[42000] [Microsoft][ODBC Driver 17 for SQL Server][SQL Server]Column \\'Transactions.state\\' is invalid in the select list because it is not contained in either an aggregate function or the GROUP BY clause. (8120) (SQLExecDirectW)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT \\nLEFT(t.trans_date, \\'7\\') month, \\nt.country country, \\nCOUNT(*) trans_count, \\nSUM(t.amount) trans_total_amount, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\nFROM [Transactions] t\\nGROUP BY LEFT(t.trans_date,\\'7\\'), t.country;\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT \\nLEFT(t.trans_date, \\'7\\') month, \\nt.country country, \\nCOUNT(*) trans_count, \\nSUM(t.amount) trans_total_amount, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(CASE WHEN t.state = \\'approved\\' THEN t.amount ELSE 0 END) AS approved_total_amount\\n\\nFROM [Transactions] t\\nGROUP BY LEFT(t.trans_date,\\'7\\'), t.country;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068243,
                "title": "monthly-transactions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect SUBSTR(trans_date, 1,7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067865,
                "title": "2-approach-provided-optimal-join-non-optimal-2-subqueries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n  DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,\\n  t.country,\\n  COUNT(t.trans_date) AS trans_count,\\n  COALESCE(approved_count, 0) AS approved_count,\\n  SUM(t.amount) AS trans_total_amount,\\n  COALESCE(approved_total_amount, 0) AS approved_total_amount\\nFROM\\n  Transactions AS t\\n  ## i made a table so i can left join with it ... i named the table subquery\\n  LEFT JOIN (\\n    SELECT\\n      DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') AS month1,\\n      t1.country,\\n      COUNT(t1.trans_date) AS approved_count,\\n      SUM(t1.amount) AS approved_total_amount\\n    FROM\\n      Transactions AS t1\\n    WHERE\\n      t1.state = \\'approved\\'\\n    GROUP BY\\n      month1,\\n      t1.country\\n  ) AS subquery ON subquery.month1 = DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AND subquery.country = t.country\\nGROUP BY\\n  month,\\n  t.country;\\n\\n## My non optimal solution 2 subqueries used\\n\\n# SELECT DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,t.country,COUNT(t.trans_date) as trans_count,\\n\\n# COALESCE(\\n# (SELECT COUNT(t1.trans_date) FROM Transactions as t1\\n# WHERE t1.state = \"approved\" and DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') = month and t1.country = t.country\\n# GROUP BY DATE_FORMAT(t1.trans_date, \\'%Y-%m\\'),t1.country\\n# ),0) AS approved_count,\\n\\n# SUM(t.amount) as trans_total_amount,\\n\\n# COALESCE(\\n# (SELECT SUM(t2.amount) FROM Transactions as t2\\n# WHERE t2.state = \"approved\" and DATE_FORMAT(t2.trans_date, \\'%Y-%m\\') = month and t2.country = t.country\\n# GROUP BY DATE_FORMAT(t2.trans_date, \\'%Y-%m\\'),t2.country\\n# ),0) AS approved_total_amount\\n\\n# FROM Transactions AS t\\n# GROUP BY month,t.country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n  DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,\\n  t.country,\\n  COUNT(t.trans_date) AS trans_count,\\n  COALESCE(approved_count, 0) AS approved_count,\\n  SUM(t.amount) AS trans_total_amount,\\n  COALESCE(approved_total_amount, 0) AS approved_total_amount\\nFROM\\n  Transactions AS t\\n  ## i made a table so i can left join with it ... i named the table subquery\\n  LEFT JOIN (\\n    SELECT\\n      DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') AS month1,\\n      t1.country,\\n      COUNT(t1.trans_date) AS approved_count,\\n      SUM(t1.amount) AS approved_total_amount\\n    FROM\\n      Transactions AS t1\\n    WHERE\\n      t1.state = \\'approved\\'\\n    GROUP BY\\n      month1,\\n      t1.country\\n  ) AS subquery ON subquery.month1 = DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AND subquery.country = t.country\\nGROUP BY\\n  month,\\n  t.country;\\n\\n## My non optimal solution 2 subqueries used\\n\\n# SELECT DATE_FORMAT(t.trans_date, \\'%Y-%m\\') AS month,t.country,COUNT(t.trans_date) as trans_count,\\n\\n# COALESCE(\\n# (SELECT COUNT(t1.trans_date) FROM Transactions as t1\\n# WHERE t1.state = \"approved\" and DATE_FORMAT(t1.trans_date, \\'%Y-%m\\') = month and t1.country = t.country\\n# GROUP BY DATE_FORMAT(t1.trans_date, \\'%Y-%m\\'),t1.country\\n# ),0) AS approved_count,\\n\\n# SUM(t.amount) as trans_total_amount,\\n\\n# COALESCE(\\n# (SELECT SUM(t2.amount) FROM Transactions as t2\\n# WHERE t2.state = \"approved\" and DATE_FORMAT(t2.trans_date, \\'%Y-%m\\') = month and t2.country = t.country\\n# GROUP BY DATE_FORMAT(t2.trans_date, \\'%Y-%m\\'),t2.country\\n# ),0) AS approved_total_amount\\n\\n# FROM Transactions AS t\\n# GROUP BY month,t.country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067738,
                "title": "ms-sql-solution-with-aggregate-functions-without-cte-and-joins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n2557 ms \\nBeats 70.01%of users with MS SQL Server\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT FORMAT(trans_date, \\'yyyy-MM\\') AS month, \\ncountry, \\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY FORMAT(trans_date, \\'yyyy-MM\\'), country\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT FORMAT(trans_date, \\'yyyy-MM\\') AS month, \\ncountry, \\nCOUNT(id) AS trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY FORMAT(trans_date, \\'yyyy-MM\\'), country\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065988,
                "title": "beats-89-64-of-users-with-mysql",
                "content": "\\n```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\ncountry, \\nCOUNT(id) as trans_count, \\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions \\nGROUP BY month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\ncountry, \\nCOUNT(id) as trans_count, \\nSUM(CASE WHEN state=\\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\nSUM(amount) AS trans_total_amount, \\nSUM(CASE WHEN state=\\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount \\nFROM Transactions \\nGROUP BY month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064490,
                "title": "pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\\'month\\'] = transactions[\\'trans_date\\'].apply(lambda x:str(x)[0:7])\\n    transactions[\\'trans_count\\'] = transactions[\\'trans_date\\']\\n    transactions[\\'approved_count\\'] = transactions[\\'state\\'].apply(lambda x:1 if x==\\'approved\\' else 0)\\n    transactions[\\'approved_total_amount\\'] = transactions.apply(lambda x:x[\\'amount\\'] if x[\\'approved_count\\']==1 else 0,axis=1)\\n    print(transactions)\\n    transactions = transactions.groupby([\\'month\\',\\'country\\'], as_index=False).agg(\\n      \\n        trans_count=pd.NamedAgg(column=\"trans_count\", aggfunc=\"count\"),\\n        approved_count=pd.NamedAgg(column=\"approved_count\", aggfunc=\"sum\"),\\n        trans_total_amount=pd.NamedAgg(column=\"amount\", aggfunc=\"sum\"),\\n        approved_total_amount=pd.NamedAgg(column=\"approved_total_amount\", aggfunc=\"sum\")\\n        \\n        )\\n    \\n    return transactions    \\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef monthly_transactions(transactions: pd.DataFrame) -> pd.DataFrame:\\n    transactions[\\'month\\'] = transactions[\\'trans_date\\'].apply(lambda x:str(x)[0:7])\\n    transactions[\\'trans_count\\'] = transactions[\\'trans_date\\']\\n    transactions[\\'approved_count\\'] = transactions[\\'state\\'].apply(lambda x:1 if x==\\'approved\\' else 0)\\n    transactions[\\'approved_total_amount\\'] = transactions.apply(lambda x:x[\\'amount\\'] if x[\\'approved_count\\']==1 else 0,axis=1)\\n    print(transactions)\\n    transactions = transactions.groupby([\\'month\\',\\'country\\'], as_index=False).agg(\\n      \\n        trans_count=pd.NamedAgg(column=\"trans_count\", aggfunc=\"count\"),\\n        approved_count=pd.NamedAgg(column=\"approved_count\", aggfunc=\"sum\"),\\n        trans_total_amount=pd.NamedAgg(column=\"amount\", aggfunc=\"sum\"),\\n        approved_total_amount=pd.NamedAgg(column=\"approved_total_amount\", aggfunc=\"sum\")\\n        \\n        )\\n    \\n    return transactions    \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4064447,
                "title": "super-easy-solution-dattebayo",
                "content": "# Intuition\\nThe problem looks straight forward and i believe will not take much time. A beginner friendly answer is written by following basic concepts step by step.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nThis SQL query extracts the month and country from the \"Transactions\" table, then groups the data by these columns. Within each group, it calculates several aggregates:\\n\\ncount(*) as trans_count: Counts the total number of transactions in each group.\\n\\nSUM(IF(state=\\'approved\\',1,0)) as approved_count: Counts the number of transactions with the \\'approved\\' state.\\n\\nSUM(amount) as trans_total_amount: Calculates the total transaction amount for all transactions in each group.\\n\\nSUM(IF(state=\\'approved\\',amount,0)) as approved_total_amount: Calculates the total transaction amount for transactions with the \\'approved\\' state.\\n\\nThis query provides a summary of transaction data, including counts and amounts, broken down by month and country. It\\'s useful for analyzing transaction activity and approvals in different regions and over time.\\n\\n# Complexity\\n- Time complexity: $$918ms$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$96.76%$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n LEFT(trans_date,7) AS month,\\n country,count(*) as trans_count ,\\n SUM(IF(state=\\'approved\\',1,0)) as approved_count,\\nSUM(amount) as trans_total_amount,\\n SUM(IF(state=\\'approved\\',amount,0)) as approved_total_amount\\n from Transactions group by month,country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n LEFT(trans_date,7) AS month,\\n country,count(*) as trans_count ,\\n SUM(IF(state=\\'approved\\',1,0)) as approved_count,\\nSUM(amount) as trans_total_amount,\\n SUM(IF(state=\\'approved\\',amount,0)) as approved_total_amount\\n from Transactions group by month,country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064359,
                "title": "beats-90-answers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month ,country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\n from Transactions\\n group by 1,2\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month ,country, count(*) as trans_count, \\nsum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, \\nsum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount\\n from Transactions\\n group by 1,2\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060986,
                "title": "easy-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPLEASE UPVOTE\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n    concat(YEAR(trans_date),\\'-\\',lpad(month(trans_date),2,\\'0\\')) as month,\\n    country,\\n    count(id) as trans_count,\\n    count(if(state=\\'approved\\',1,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n    from transactions\\n    GROUP BY YEAR(trans_date), MONTH(trans_date),country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    concat(YEAR(trans_date),\\'-\\',lpad(month(trans_date),2,\\'0\\')) as month,\\n    country,\\n    count(id) as trans_count,\\n    count(if(state=\\'approved\\',1,null)) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(if(state=\\'approved\\',amount,0)) as approved_total_amount\\n    from transactions\\n    GROUP BY YEAR(trans_date), MONTH(trans_date),country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056645,
                "title": "beats-98-87-single-query-using-aggregate-functions-and-case-statements",
                "content": "# Approach\\n- **Month**\\n    `left(trans_date,7)` to retrieve the year and month in yyyy-mm.\\n- **trans_count**\\n    A simple $$group\\\\ by$$ query with count on the $$id$$.\\n    ```\\n    select count(id) from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n- **approve_count**\\n    To get the count whenever the $$state$$ is $$approved$$, perform a case statement to count as 1.\\n    ```\\n    select\\n    sum(case \\n            when state = \\'approved\\' then 1 else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n- **trans_total_amount**\\n    A simple $$group\\\\ by$$ query with the $$sum()$$ on the $$id$$.\\n    ```\\n    select sum(amount) from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n- **approved_total_amount**\\n    To get the sum whenever the $$state$$ is $$approved$$, perform a case statement to cumulate the $$amount$$.\\n    ```\\n    select\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\\n\\n# Code\\n```\\nselect\\n    left(trans_date,7) as Month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case \\n        when state = \\'approved\\' then 1 else 0 \\n        end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7),country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n    select count(id) from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\n    select\\n    sum(case \\n            when state = \\'approved\\' then 1 else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\n    select sum(amount) from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\n    select\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end)\\n    from Transactions\\n    group by left(trans_date,7),country\\n    ```\n```\\nselect\\n    left(trans_date,7) as Month,\\n    country,\\n    count(id) as trans_count,\\n    sum(case \\n        when state = \\'approved\\' then 1 else 0 \\n        end) as approved_count,\\n    sum(amount) as trans_total_amount,\\n    sum(case \\n        when state = \\'approved\\' then amount else 0 \\n        end) as approved_total_amount\\nfrom Transactions\\ngroup by left(trans_date,7),country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054270,
                "title": "easy-approach-beats-99-03-sql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT LEFT(trans_date, 7) as month,\\ncountry, COUNT(*) AS trans_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)*amount) AS approved_total_amount\\nFROM Transactions\\nGROUP BY LEFT(trans_date, 7), country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT LEFT(trans_date, 7) as month,\\ncountry, COUNT(*) AS trans_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\nSUM((CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END)*amount) AS approved_total_amount\\nFROM Transactions\\nGROUP BY LEFT(trans_date, 7), country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053801,
                "title": "beats-93-33-easy-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect LEFT(CONVERT(varchar(10), trans_date, 120), 7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by LEFT(CONVERT(varchar(10), trans_date, 120), 7),country\\norder  by month asc, country\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect LEFT(CONVERT(varchar(10), trans_date, 120), 7) as month, country, count(id) as trans_count, sum(case when state = \\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state = \\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by LEFT(CONVERT(varchar(10), trans_date, 120), 7),country\\norder  by month asc, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053122,
                "title": "clean-and-simple-solution-using-basic-sql-commands",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT\\n     DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n     country, \\n     COUNT(id) AS trans_count,\\n     SUM(CASE WHEN state = \"approved\" Then 1 ELSE 0 END) AS approved_count,\\n     SUM(amount) AS trans_total_amount, \\n     SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM\\n    Transactions \\nGROUP BY\\n     MONTH,YEAR(trans_date), country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT\\n     DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n     country, \\n     COUNT(id) AS trans_count,\\n     SUM(CASE WHEN state = \"approved\" Then 1 ELSE 0 END) AS approved_count,\\n     SUM(amount) AS trans_total_amount, \\n     SUM(CASE WHEN state=\"approved\" THEN amount ELSE 0 END) AS approved_total_amount\\nFROM\\n    Transactions \\nGROUP BY\\n     MONTH,YEAR(trans_date), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052945,
                "title": "simple-mysql-solution-which-beats-98-incredibly-straight-forward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it was only one table first thing that comes to my mind is to join table to itself and then utilize if + count/sum to figure out differences \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStarted with each column at a time, figured out the group by in beginning and start configured select statement accordingly, just 1 column, focus on one column > make it right > move to next column > repeat.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect left(t1.trans_date, 7) as month, t1.country, count(t1.state) as trans_count ,\\n sum(if(t1.state=\\'approved\\', 1,0)) as approved_count, sum(t1.amount) as trans_total_amount, sum(if(t1.state=\\'approved\\', t1.amount,0)) as approved_total_amount from Transactions  t1\\n join transactions t2 on t1.id = t2.id\\ngroup by 1, country\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect left(t1.trans_date, 7) as month, t1.country, count(t1.state) as trans_count ,\\n sum(if(t1.state=\\'approved\\', 1,0)) as approved_count, sum(t1.amount) as trans_total_amount, sum(if(t1.state=\\'approved\\', t1.amount,0)) as approved_total_amount from Transactions  t1\\n join transactions t2 on t1.id = t2.id\\ngroup by 1, country\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052874,
                "title": "oracle-solution-with-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n  to_char(trunc(trans_date, \\'MONTH\\'), \\'YYYY-MM\\') as month,\\n  country, \\n  count(id) trans_count,\\n  sum(amount) trans_total_amount,\\n  sum(decode(state, \\'approved\\', 1, 0)) approved_count,\\n  sum(decode(state, \\'approved\\', 1, 0) * amount) approved_total_amount\\nfrom Transactions\\ngroup by trunc(trans_date, \\'MONTH\\'), country\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n  to_char(trunc(trans_date, \\'MONTH\\'), \\'YYYY-MM\\') as month,\\n  country, \\n  count(id) trans_count,\\n  sum(amount) trans_total_amount,\\n  sum(decode(state, \\'approved\\', 1, 0)) approved_count,\\n  sum(decode(state, \\'approved\\', 1, 0) * amount) approved_total_amount\\nfrom Transactions\\ngroup by trunc(trans_date, \\'MONTH\\'), country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049641,
                "title": "easy-solution-beats-98-18-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWith ttl as (Select\\nSubstring(trans_date,1,7) as month,\\ncountry,\\ncount(*) as trans_count, sum(amount) as trans_total_amount\\nFrom Transactions\\ngroup by country, month),\\n\\napp as (\\nSelect\\nsubstring(trans_date,1,7) as month,country,\\nSum(Case when state = \\'Approved\\' then 1 else 0 end)as approved_count, sum(Case when state = \\'Approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by country, month )\\n\\nSelect\\nttl.month, ttl.country, ttl.trans_count,app.approved_count, ttl.trans_total_amount, app.approved_total_amount\\nFrom ttl\\nleft join app\\non\\nttl.month = app.month \\nand\\nttl.country = app.country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWith ttl as (Select\\nSubstring(trans_date,1,7) as month,\\ncountry,\\ncount(*) as trans_count, sum(amount) as trans_total_amount\\nFrom Transactions\\ngroup by country, month),\\n\\napp as (\\nSelect\\nsubstring(trans_date,1,7) as month,country,\\nSum(Case when state = \\'Approved\\' then 1 else 0 end)as approved_count, sum(Case when state = \\'Approved\\' then amount else 0 end) as approved_total_amount\\nFrom Transactions\\ngroup by country, month )\\n\\nSelect\\nttl.month, ttl.country, ttl.trans_count,app.approved_count, ttl.trans_total_amount, app.approved_total_amount\\nFrom ttl\\nleft join app\\non\\nttl.month = app.month \\nand\\nttl.country = app.country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049249,
                "title": "1193-monthly-transactions-i-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(*) as trans_count,\\n       sum(state = \\'approved\\') as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum((state = \\'approved\\')*amount) as approved_total_amount\\nfrom transactions\\ngroup by month, country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,\\n       country,\\n       count(*) as trans_count,\\n       sum(state = \\'approved\\') as approved_count,\\n       sum(amount) as trans_total_amount,\\n       sum((state = \\'approved\\')*amount) as approved_total_amount\\nfrom transactions\\ngroup by month, country;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049124,
                "title": "easy-solution-beats-96",
                "content": "\\n\\n# Code\\n```\\nselect substr(trans_date, 1, 7) as month, country, count(id) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect substr(trans_date, 1, 7) as month, country, count(id) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end) as approved_count, sum(amount) as trans_total_amount, sum(case when state=\\'approved\\' then amount else 0 end) as approved_total_amount from Transactions\\ngroup by month, country\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049098,
                "title": "sql-advance-optimal-sol-beats-90-cte-join-aggregation-case-stmt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH base as(\\n  select \\n    id, \\n    concat (\\n      year(trans_date), \\n      \\'-\\', \\n      CASE \\n        WHEN month(trans_date) in (1, 2, 3, 4, 5, 6, 7, 8, 9) THEN concat(\\'0\\', month(trans_date)) \\n        ELSE month(trans_date) \\n      END\\n    ) as month \\n  from \\n    Transactions\\n) \\nselect \\n  b.month, \\n  t.country, \\n  count(t.id) as trans_count, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END\\n  ) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN amount ELSE 0 END\\n  ) as approved_total_amount \\nfrom \\n  Transactions t \\n  left outer join base b on b.id = t.id \\ngroup by \\n  month, \\n  country\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH base as(\\n  select \\n    id, \\n    concat (\\n      year(trans_date), \\n      \\'-\\', \\n      CASE \\n        WHEN month(trans_date) in (1, 2, 3, 4, 5, 6, 7, 8, 9) THEN concat(\\'0\\', month(trans_date)) \\n        ELSE month(trans_date) \\n      END\\n    ) as month \\n  from \\n    Transactions\\n) \\nselect \\n  b.month, \\n  t.country, \\n  count(t.id) as trans_count, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN 1 ELSE 0 END\\n  ) as approved_count, \\n  sum(amount) as trans_total_amount, \\n  sum(\\n    CASE WHEN t.state = \\'approved\\' THEN amount ELSE 0 END\\n  ) as approved_total_amount \\nfrom \\n  Transactions t \\n  left outer join base b on b.id = t.id \\ngroup by \\n  month, \\n  country\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049021,
                "title": "98-beat-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH NTRANS AS\\n(SELECT DATE_FORMAT(TRANS_DATE, \\'%Y-%m\\') MONTH,\\nCOUNTRY,\\nSTATE,\\nAMOUNT,\\n(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) APPROVED,\\n(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) APPROVED_AMOUNT\\nFROM TRANSACTIONS)\\n\\nSELECT MONTH,COUNTRY,COUNT(STATE) TRANS_COUNT,SUM(APPROVED) APPROVED_COUNT,SUM(AMOUNT) TRANS_TOTAL_AMOUNT,SUM(APPROVED_AMOUNT) APPROVED_TOTAL_AMOUNT FROM NTRANS GROUP BY MONTH,COUNTRY\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH NTRANS AS\\n(SELECT DATE_FORMAT(TRANS_DATE, \\'%Y-%m\\') MONTH,\\nCOUNTRY,\\nSTATE,\\nAMOUNT,\\n(CASE WHEN STATE=\\'approved\\' THEN 1 ELSE 0 END) APPROVED,\\n(CASE WHEN STATE=\\'approved\\' THEN AMOUNT ELSE 0 END) APPROVED_AMOUNT\\nFROM TRANSACTIONS)\\n\\nSELECT MONTH,COUNTRY,COUNT(STATE) TRANS_COUNT,SUM(APPROVED) APPROVED_COUNT,SUM(AMOUNT) TRANS_TOTAL_AMOUNT,SUM(APPROVED_AMOUNT) APPROVED_TOTAL_AMOUNT FROM NTRANS GROUP BY MONTH,COUNTRY\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046509,
                "title": "beast-s-99",
                "content": "# Intuition\\nused inbuit month and year function\\'s\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n  concat(YEAR(trans_date),\\'-\\',\\n  if(MONTH(trans_date)<10,concat(\\'0\\',MONTH(trans_date)),MONTH(trans_date))) as month,\\n  country,\\n  COUNT(state) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY YEAR(trans_date),MONTH(trans_date), country;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n  concat(YEAR(trans_date),\\'-\\',\\n  if(MONTH(trans_date)<10,concat(\\'0\\',MONTH(trans_date)),MONTH(trans_date))) as month,\\n  country,\\n  COUNT(state) AS trans_count,\\n  SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY YEAR(trans_date),MONTH(trans_date), country;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1872045,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1918001,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1975789,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1576235,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2076396,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2075164,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074236,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074128,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2063288,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2009187,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1872045,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1918001,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1975789,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1576235,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2076396,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2075164,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074236,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2074128,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2063288,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 2009187,
                "content": [
                    {
                        "username": "user9471tA",
                        "content": "```\\nSELECT \\n    DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month\\n    , country\\n    , COUNT(*) AS trans_count\\n    , SUM(IF(state = \\'approved\\', 1, 0)) AS approved_count\\n    , SUM(amount) AS trans_total_amount\\n    , SUM(IF(state = \\'approved\\', amount, 0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY month, country\\n```"
                    },
                    {
                        "username": "blahbalh",
                        "content": "This is written right above your post:\\n\"Please don\\'t post any solutions in this discussion.\"\\n\\nCAN YOU NOT READ?"
                    },
                    {
                        "username": "lex8390",
                        "content": "Use FORMAT for trans_date and SUM & CASE functions for the calculated fields and don\\'t forget to wrap them inside ISNULL to handle exceptions. Finally, GROUP BY accordingly with formatted fields"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Date_format() will help you truncate the date column to months\\n\\nhttps://devdocs.io/mariadb/date_format/index\\n\\n`date_format(trans_date, \\'%Y-%m\\')`"
                    },
                    {
                        "username": "ashleyzhangruibo",
                        "content": "WITH temp AS \\n(SELECT * ,\\nDATE_FORMAT(trans_date,\"%Y-%m\") AS month \\nFROM Transactions)\\n\\nSELECT temp.month, temp.country, \\nCOUNT(*) AS trans_count, \\nSUM(CASE WHEN temp.state = \"approved\" THEN 1 ELSE 0 END) AS approved_count, \\nSUM(temp.amount) AS trans_total_amount,\\nSUM(CASE WHEN temp.state = \"approved\" THEN amount ELSE 0 END ) as approved_total_amount\\nFROM temp \\nGROUP BY temp.month, temp.country"
                    },
                    {
                        "username": "WanyueD",
                        "content": "Anyone knows why it gives the \\'Runtime Error\\' result?? Thanks\\n\\n\\nSELECT DATE_FORMAT(trans_date, \\'%Y-%m\\') AS month, \\n    country, \\n    COUNT(*) AS trans_count, \\n    SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count, \\n    SUM(amount) AS trans_total_amount, \\n    SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM Transactions\\nGROUP BY DATE_FORMAT(trans_date, \\'%Y-%m\\')\\uFF0Ccountry"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "select to_char(trans_date,\\'YYYY-MM\\') as month, country, count(to_char(trans_date,\\'YYYY-MM\\')) as trans_count, sum(case when state=\\'approved\\' then 1 else 0 end)  approved_count,\\nsum(amount) as trans_total_amount, nvl(sum(case when state=\\'approved\\' then amount end),0) approved_total_amount\\nfrom transactions\\ngroup by to_char(trans_date,\\'YYYY-MM\\'),country;"
                    },
                    {
                        "username": "themg",
                        "content": "In PL/SQL, you can use \"TO_CHAR(trans_date, \\'YYYY-MM\\') AS month\" instead of EXTRACT function. Just a little tip ;)"
                    },
                    {
                        "username": "thethi_nav",
                        "content": "This is giving 0 rows when no transactions are approved. Can anyone have a look?\\n WITH T AS \\n( select *,\\nDATE_FORMAT(trans_date,\\'%Y-%m\\') AS ym\\nfrom transactions),\\nApprovedCnt as\\n(Select ym,country,\\nIFNULL(count(*),0) as cnt, IFNULL(sum(amount),0) as amt from T\\nwhere state=\\'approved\\'\\ngroup by ym,country),\\nTotalCnt as\\n(Select ym,country,COALESCE(count(*),0) as cnt,COALESCE(sum(amount),0) as amt from T group by ym,country\\n)\\n\\nSELECT a.ym as \"month\",a.country,\\nt.cnt as trans_count,\\na.cnt as approved_count,\\nt.amt as trans_total_amount,\\na.amt as approved_total_amount\\nFROM ApprovedCnt a,totalCnt t \\nwhere (a.ym,a.country)=(t.ym,t.country)"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "# Write your MySQL query statement below\\n\\nselect date_format(trans_date,\\'%Y-%m\\') as month, country, count(*) as trans_count, sum(case when t.state= \\'approved\\' then 1 else 0 end) as approved_count, sum(t.amount) as trans_total_amount, sum(case when t.state=\\'approved\\' then t.amount else 0 end) as approved_total_amount\\nfrom transactions t\\ngroup by month, country"
                    },
                    {
                        "username": "Dhanamedapati",
                        "content": "SELECT DATE_FORMAT(trans_date,\\'%Y-%m\\') AS month,country,COUNT(*) AS trans_count,\\nSUM(IF(state=\\'approved\\',1,0)) AS approved_count,\\nSUM(amount) AS trans_total_amount,\\nSUM(IF(state=\\'approved\\',amount,0)) AS approved_total_amount\\nFROM Transactions\\nGROUP BY country,YEAR(trans_date),MONTH(trans_date)"
                    }
                ]
            },
            {
                "id": 1995856,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1988090,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1977063,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1976292,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1967522,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1959964,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1958571,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1958557,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1952315,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            },
            {
                "id": 1907626,
                "content": [
                    {
                        "username": "AbhiBatra1999",
                        "content": "Select substring(trans_date,1,7) as month,\\ncountry,\\ncount(id) as trans_count,\\nsum(\\n    case\\n        when state=\\'approved\\' then 1\\n        else 0\\n    end\\n   ) as approved_count,\\nsum(amount) as trans_total_amount,\\nsum(\\n    case\\n        when state=\\'approved\\' then amount\\n        else 0\\n    end\\n    ) as approved_total_amount\\n\\n from Transactions\\n group by month,country"
                    },
                    {
                        "username": "ankush20386",
                        "content": "what is the problem with this solution?\\n\\n\\n# Write your MySQL query statement below\\nwith\\ncte1 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as trans_count from transactions group by Extract(month from trans_date),country),\\ncte2 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,count(state) as approved_count from transactions where state=\\'approved\\' group by Extract(month from trans_date),country),\\ncte3 as (select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as trans_total_amount from transactions group by Extract(month from trans_date),country),\\ncte4 as(select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month,country,sum(amount) as approved_total_amount from transactions where state=\\'approved\\' group by Extract(month from trans_date),country)\\n\\nselect a.month,a.country,a.trans_count,b.approved_count,c.trans_total_amount,d.approved_total_amount from cte1 a inner join cte2  b on a.month=b.month inner join cte3  c on b.month=c.month inner join cte4  d on c.month=d.month;\\n"
                    },
                    {
                        "username": "surajdumane0411",
                        "content": "Select DATE_FORMAT(trans_date, \\'%Y-%m\\') as month, country, \\nCOUNT(id) as trans_count,\\nSUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) as approved_count,\\nSUM(amount) as trans_total_amount,\\nSUM(CASE WHEN state =\\'approved\\' THEN amount ELSE 0 END) as approved_total_amount\\nFROM Transactions\\nGroup By month, country;"
                    },
                    {
                        "username": "kajal_k13",
                        "content": "why can\\'t we take count(state) as trans_count?"
                    },
                    {
                        "username": "jsjaramillo4",
                        "content": "/* Write your T-SQL query statement below */\\n\\nSELECT\\n  FORMAT(trans_date, \\'yyyy-MM\\') AS month,\\n  country,\\n  COUNT(id) as trans_count,\\n  SUM(CASE WHEN state = \\'approved\\' THEN 1 ELSE 0 END) AS approved_count,\\n  SUM(amount) AS trans_total_amount,\\n  SUM(CASE WHEN state = \\'approved\\' THEN amount ELSE 0 END) AS approved_total_amount\\nFROM transactions\\nGROUP BY \\n  FORMAT(trans_date, \\'yyyy-MM\\'), \\n  country"
                    },
                    {
                        "username": "valmeh1996",
                        "content": "What is wrong with the below query? It gives me the exact same output as expected but is still giving me wrong answer for the second test case. Is it because I used a window function?\n\nselect date_format(trans_date, '%Y-%m') as month, country, count(*) as trans_count, sum(state='approved') as approved_count, sum(amount) as trans_total_amount, sum(amount) over (partition by state='approved', country, extract(year_month from trans_date)) as approved_total_amount\nfrom Transactions\ngroup by 1, 2\norder by 1 asc, 2 desc"
                    },
                    {
                        "username": "user5498hm",
                        "content": "Select date_format(trans_date,\"%Y-%m\") as month,\\ncountry,count(trans_date) as trans_count,\\nsum(case when state=\"approved\" then 1 else 0 end ) as approved_count,\\nsum(amount) as trans_total_amount ,\\n sum(case when state=\"approved\" then amount else 0 end ) as approved_total_amount\\n from Transactions\\n group by date_format(trans_date,\"%Y-%c\"),country"
                    },
                    {
                        "username": "AhmedMahmoud1",
                        "content": "For example, LPAD(\\'9\\', 5, \\'0\\') will pad the string \\'9\\' with leading zeros until it reaches a length of 5:\\nResult: \\'00009\\'\\nIn the context of your query, LPAD(MONTH(trans_date), 2, \\'0\\') is used to pad the month value with a leading zero if it is a single-digit month. This ensures that the month is represented with two digits, as in \\'01\\' for January, \\'02\\' for February, and so on."
                    },
                    {
                        "username": "Swati0807",
                        "content": "With cte as (\n  select DATE_FORMAT(trans_date, '%Y-%m')  as month1\n, country, count(id) as trans_count, sum(amount) as amt from Transactions group by country, month1),\n cte1 as(\nselect DATE_FORMAT(trans_date, '%Y-%m')  as month2\n, country, count(id) as approved_count, sum(amount) as apamt from Transactions where state='approved' group by country, state, month2)\nselect c.month1 as month, c.country, trans_count , approved_count, amt as trans_total_amount , apamt as approved_total_amount  from cte c join cte1 c1 on c.month1=c1.month2 and c.country=c1.country\n\nif using cte is okay for such easy problems?\n"
                    },
                    {
                        "username": "Masterdemon123",
                        "content": "is it possible to create a tempt table and insert , update , drop as well as variable here in leetcode IDE ? I want to use some table to store my query for another select ."
                    },
                    {
                        "username": "siamBeginner",
                        "content": "***in mysql***\\nwith x as\\n(select id,country,state,amount,left(trans_date,7) as month,case when state=\\'approved\\' then 1 else 0 end as app,case when state=\\'approved\\' then amount\\nelse 0 end approved_total_amount\\nfrom transactions t)\\n\\nselect month,country,count(country) trans_count,sum(app) approved_count,sum(amount) trans_total_amount,sum(approved_total_amount)\\n approved_total_amount\\nfrom x \\ngroup by country,month"
                    }
                ]
            }
        ]
    }
]