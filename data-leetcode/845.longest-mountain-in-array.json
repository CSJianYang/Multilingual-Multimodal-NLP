[
    {
        "title": "Longest Mountain in Array",
        "question_content": "You may recall that an array arr is a mountain array if and only if:\n\n\tarr.length >= 3\n\tThere exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n\t\n\t\tarr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n\t\tarr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\t\n\t\n\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\n&nbsp;\nExample 1:\n\nInput: arr = [2,1,4,7,3,2,5]\nOutput: 5\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\nExample 2:\n\nInput: arr = [2,2,2]\nOutput: 0\nExplanation: There is no mountain.\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 104\n\t0 <= arr[i] <= 104\n\n&nbsp;\nFollow up:\n\n\tCan you solve it using only one pass?\n\tCan you solve it in O(1) space?",
        "solutions": [
            {
                "id": 135593,
                "title": "c-java-python-1-pass-and-o-1-space",
                "content": "**Intuition**:\\nWe have already many 2-pass or 3-pass problems, like 821. Shortest Distance to a Character.\\nThey have almost the same idea.\\nOne forward pass and one backward pass.\\nMaybe another pass to get the final result, or you can merge it in one previous pass.\\n\\n**Explanation**:\\nIn this problem, we take one forward pass to count up hill length (to every point).\\nWe take another backward pass to count down hill length (from every point).\\nFinally a pass to find max(up[i] + down[i] + 1) where up[i] and down[i] should be positives.\\n\\n\\n**Time Complexity**:\\nO(N)\\n\\n**C++:**\\n```\\n    int longestMountain(vector<int> A) {\\n        int N = A.size(), res = 0;\\n        vector<int> up(N, 0), down(N, 0);\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] && down[i]) res = max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int longestMountain(int[] A) {\\n        int N = A.length, res = 0;\\n        int[] up = new int[N], down = new int[N];\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] > 0 && down[i] > 0) res = Math.max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def longestMountain(self, A):\\n        up, down = [0] * len(A), [0] * len(A)\\n        for i in range(1, len(A)):\\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\\n        for i in range(len(A) - 1)[::-1]:\\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])\\n```\\n\\n**Follow up**\\n\\nCan you solve this problem with only one pass?\\nCan you solve this problem in O(1) space?\\n\\nIn this solution, I count up length and down length.\\nBoth up and down length are clear to 0 when `A[i - 1] == A[i]` or `down > 0 && A[i - 1] < A[i]`.\\n\\n**C++:**\\n```\\n    int longestMountain(vector<int> A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (down && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            up += A[i - 1] < A[i];\\n            down += A[i - 1] > A[i];\\n            if (up && down) res = max(res, up + down + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int longestMountain(int[] A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.length; ++i) {\\n            if (down > 0 && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            if (A[i - 1] < A[i]) up++;\\n            if (A[i - 1] > A[i]) down++;\\n            if (up > 0 && down > 0 && up + down + 1 > res) res = up + down + 1;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def longestMountain(self, A):\\n        res = up = down = 0\\n        for i in range(1, len(A)):\\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\\n            up += A[i - 1] < A[i]\\n            down += A[i - 1] > A[i]\\n            if up and down: res = max(res, up + down + 1)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    int longestMountain(vector<int> A) {\\n        int N = A.size(), res = 0;\\n        vector<int> up(N, 0), down(N, 0);\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] && down[i]) res = max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int longestMountain(int[] A) {\\n        int N = A.length, res = 0;\\n        int[] up = new int[N], down = new int[N];\\n        for (int i = N - 2; i >= 0; --i) if (A[i] > A[i + 1]) down[i] = down[i + 1] + 1;\\n        for (int i = 0; i < N; ++i) {\\n            if (i > 0 && A[i] > A[i - 1]) up[i] = up[i - 1] + 1;\\n            if (up[i] > 0 && down[i] > 0) res = Math.max(res, up[i] + down[i] + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    def longestMountain(self, A):\\n        up, down = [0] * len(A), [0] * len(A)\\n        for i in range(1, len(A)):\\n            if A[i] > A[i - 1]: up[i] = up[i - 1] + 1\\n        for i in range(len(A) - 1)[::-1]:\\n            if A[i] > A[i + 1]: down[i] = down[i + 1] + 1\\n        return max([u + d + 1 for u, d in zip(up, down) if u and d] or [0])\\n```\n```\\n    int longestMountain(vector<int> A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (down && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            up += A[i - 1] < A[i];\\n            down += A[i - 1] > A[i];\\n            if (up && down) res = max(res, up + down + 1);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int longestMountain(int[] A) {\\n        int res = 0, up = 0, down = 0;\\n        for (int i = 1; i < A.length; ++i) {\\n            if (down > 0 && A[i - 1] < A[i] || A[i - 1] == A[i]) up = down = 0;\\n            if (A[i - 1] < A[i]) up++;\\n            if (A[i - 1] > A[i]) down++;\\n            if (up > 0 && down > 0 && up + down + 1 > res) res = up + down + 1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def longestMountain(self, A):\\n        res = up = down = 0\\n        for i in range(1, len(A)):\\n            if down and A[i - 1] < A[i] or A[i - 1] == A[i]: up = down = 0\\n            up += A[i - 1] < A[i]\\n            down += A[i - 1] > A[i]\\n            if up and down: res = max(res, up + down + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 165667,
                "title": "1-pass-java-two-point-solution",
                "content": "```\\npublic int longestMountain(int[] A) {\\n        int n=A.length;\\n        if(n<3)return 0;\\n        \\n        int left=0;int right;int max=0;\\n        \\n        while(left<n-2){\\n            //skip decending and equal array\\n            while(left<n-1 && A[left]>=A[left+1]){\\n                left++;\\n            }\\n            right=left+1;\\n            //mountain up\\n            while(right<n-1 && A[right]<A[right+1]){\\n                right++;\\n            }\\n            //mountain down\\n            while(right<n-1 && A[right]>A[right+1]){\\n                right++;\\n                //update the max value\\n                max=Math.max(max,right-left+1);\\n            }\\n            left=right;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n        int n=A.length;\\n        if(n<3)return 0;\\n        \\n        int left=0;int right;int max=0;\\n        \\n        while(left<n-2){\\n            //skip decending and equal array\\n            while(left<n-1 && A[left]>=A[left+1]){\\n                left++;\\n            }\\n            right=left+1;\\n            //mountain up\\n            while(right<n-1 && A[right]<A[right+1]){\\n                right++;\\n            }\\n            //mountain down\\n            while(right<n-1 && A[right]>A[right+1]){\\n                right++;\\n                //update the max value\\n                max=Math.max(max,right-left+1);\\n            }\\n            left=right;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271110,
                "title": "easy-to-understand-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int maxLength = 0;\\n        int i = 1;\\n        \\n        while (i < A.size()) {\\n            int increasing = 0, decreasing = 0;\\n            \\n            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;\\n            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;\\n            \\n            if (increasing > 0 && decreasing > 0) maxLength = max(maxLength, increasing + decreasing + 1);\\n            \\n            while(i < A.size() && A[i - 1] == A[i]) i++;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int maxLength = 0;\\n        int i = 1;\\n        \\n        while (i < A.size()) {\\n            int increasing = 0, decreasing = 0;\\n            \\n            while(i < A.size() && A[i - 1] < A[i]) i++, increasing++;\\n            while(i < A.size() && A[i - 1] > A[i]) i++, decreasing++;\\n            \\n            if (increasing > 0 && decreasing > 0) maxLength = max(maxLength, increasing + decreasing + 1);\\n            \\n            while(i < A.size() && A[i - 1] == A[i]) i++;\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135631,
                "title": "python-7-lines-concise-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A, res = 0):\\n        for i in range(1, len(A) - 1):\\n            if A[i + 1] < A[i] > A[i - 1]:\\n                l = r = i\\n                while l and A[l] > A[l - 1]: l -= 1\\n                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1\\n                if r - l + 1 > res: res = r - l + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A, res = 0):\\n        for i in range(1, len(A) - 1):\\n            if A[i + 1] < A[i] > A[i - 1]:\\n                l = r = i\\n                while l and A[l] > A[l - 1]: l -= 1\\n                while r + 1 < len(A) and A[r] > A[r + 1]: r += 1\\n                if r - l + 1 > res: res = r - l + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215470,
                "title": "c-easy-solution-with-comments-and-algorithm",
                "content": "\\nREMEMBER TO UPVOTE THE ANSWER\\n\\nTime Complexity O(n)\\nSpace Complexity O(1)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        // 1. IDENTIFY PEAKS\\n        // 2. TRAVERSE BACKWARDS WHILE PREVIOUS ELEMENT -\\n        // - IS SMALLER THAT CURRENT (i.e. GO TO THE START ROOT OF THE MOUNTAIN)\\n        // 3. TRAVERSE FORWARD WHILE NEXT ELEMENT IS SMALLER THAN CURRENT \\n        // (i.e. GO TO THE END ROOT OF THE MOUNTAIN)\\n        // 4 . ADD THEM TO CALCULATE THE MOUNTAIN LENGTH\\n        int max_length = 0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) //PEAK CONDITION\\n            {\\n                int start_root = i;\\n                int end_root = i;\\n                while( start_root>0 && arr[start_root] > arr[start_root-1])\\n                {\\n                    start_root--; //getting start root\\n                    \\n                }\\n                while( end_root<n-1 && arr[end_root] > arr[end_root+1] )\\n                {\\n                    end_root++; //getting end root\\n                }\\n                max_length = max(max_length,(end_root-start_root+1));\\n                i = end_root;\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        // 1. IDENTIFY PEAKS\\n        // 2. TRAVERSE BACKWARDS WHILE PREVIOUS ELEMENT -\\n        // - IS SMALLER THAT CURRENT (i.e. GO TO THE START ROOT OF THE MOUNTAIN)\\n        // 3. TRAVERSE FORWARD WHILE NEXT ELEMENT IS SMALLER THAN CURRENT \\n        // (i.e. GO TO THE END ROOT OF THE MOUNTAIN)\\n        // 4 . ADD THEM TO CALCULATE THE MOUNTAIN LENGTH\\n        int max_length = 0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) //PEAK CONDITION\\n            {\\n                int start_root = i;\\n                int end_root = i;\\n                while( start_root>0 && arr[start_root] > arr[start_root-1])\\n                {\\n                    start_root--; //getting start root\\n                    \\n                }\\n                while( end_root<n-1 && arr[end_root] > arr[end_root+1] )\\n                {\\n                    end_root++; //getting end root\\n                }\\n                max_length = max(max_length,(end_root-start_root+1));\\n                i = end_root;\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937652,
                "title": "python-one-pass-o-1-space-explained",
                "content": "Let us traverse our numbers and keep two variables: `state` and `length`, where:\\n1. `state` is current state of our mountain: it is `0` in the beginning and also means that we can not start our mountain from given index. `state` equal to `1` means, that we are on increasing phase of our mountain and `state` equal `2` means, that we are on decreasing phase of our mountain.\\n2. `length` is current length of mountain built so far.\\n\\nNow, we need to carefully look at our states and see what we need to do in one or another situation:\\n1. If `state` is equal to `0` or `1` and next element is more than current, it means we can continue to build increasing phase of mountain: so, we put `state` equal to `1` and increase `length` by `1`.\\n2. If `state` is equal to `2` and next element is more then curren, it means, that previous mountain just finished and we are currently buildind next mountain, for examle in `0,1,0,2,0`: first mountain is `0,1,0` and second is `0,2,0`. In this case we already build `2` elements of new mountain (mountains have `1` common element), so we put `length = 2` and `state = 1`.\\n3. If `state` is equal to `1` or `2` and next element is less than current, it means that we are on the decreasing phase of mountain: we put `state = 2` and also increase `length` by `1`. Note, that only here we need to update `max_len`, because our mountain is legible on this stage.\\n4. Finally, if we have some other option: it is either next element is equal to current, or we have state `0` and next element is less than previous, we need put our `state` and `length` to values as we just started.\\n\\n**Complexity**: time complexity is `O(n)`, we make one pass over data, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def longestMountain(self, A):\\n        n, max_len = len(A), 0\\n        state, length = 0, 1\\n        for i in range(n-1):\\n            if state in [0, 1] and A[i+1] > A[i]:\\n                state, length = 1, length + 1\\n            elif state == 2 and A[i+1] > A[i]:\\n                state, length = 1, 2\\n            elif state in [1, 2] and A[i+1] < A[i]:\\n                state, length = 2, length + 1\\n                max_len = max(length, max_len)\\n            else:\\n                state, length = 0, 1\\n                \\n        return max_len\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A):\\n        n, max_len = len(A), 0\\n        state, length = 0, 1\\n        for i in range(n-1):\\n            if state in [0, 1] and A[i+1] > A[i]:\\n                state, length = 1, length + 1\\n            elif state == 2 and A[i+1] > A[i]:\\n                state, length = 1, 2\\n            elif state in [1, 2] and A[i+1] < A[i]:\\n                state, length = 2, length + 1\\n                max_len = max(length, max_len)\\n            else:\\n                state, length = 0, 1\\n                \\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244213,
                "title": "java-find-peak-and-stretch-easy-to-understand-o-2n",
                "content": "\\n```\\n\\npublic int longestMountain(int[] A) {\\n        if( A == null || A.length <3) \\n            return 0; \\n        int ans = 0; \\n        for(int i = 1; i < A.length - 1; i++ ) {\\n            if(A[i] > A[i-1] && A[i] > A[i+1]) {  // i is a peak\\n                int left = i -1;    // find leftmost of the peak\\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                \\n                int right= i+1;  // find rightmost of the peak\\n                while(right < A.length - 1 && A[right + 1] < A[right])\\n                    right++;\\n                \\n                ans = Math.max(ans, right - left +1);  // get the width using left and rightmost\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int longestMountain(int[] A) {\\n        if( A == null || A.length <3) \\n            return 0; \\n        int ans = 0; \\n        for(int i = 1; i < A.length - 1; i++ ) {\\n            if(A[i] > A[i-1] && A[i] > A[i+1]) {  // i is a peak\\n                int left = i -1;    // find leftmost of the peak\\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                \\n                int right= i+1;  // find rightmost of the peak\\n                while(right < A.length - 1 && A[right + 1] < A[right])\\n                    right++;\\n                \\n                ans = Math.max(ans, right - left +1);  // get the width using left and rightmost\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494992,
                "title": "easy-to-understand-c-o-n-time-o-1-space-beats-98-code-with-explanation",
                "content": "***If you like my approach,Please upvote this***\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        int i=1;\\n        int upper,lower;\\n        \\n        while(i<n)\\n       {    upper=0;lower=0;                  //Each time after traversing one mountain or not,we have to set upper & lower to 0\\n            while(i<n && arr[i-1]==arr[i])    //   for flat array,where elements are equal\\n              i++;                            //This also handles when we get same adjacent elements\\n            while(i<n && arr[i-1]<arr[i])     //Increasing part of mountain\\n            {  upper++;i++;\\n                \\n            }\\n                    \\n            \\n           while(i<n && arr[i-1]>arr[i])    //Decreasing part of mountain \\n           {\\n               lower++;\\n               i++;    \\n           } \\n          if(upper && lower)       //Mountain only exists if we have both incresing part and decreasing part adjacently\\n           { ans=max(ans,lower+upper+1);\\n           }\\n        \\n        }\\n        \\n        return ans;\\n     \\n    }\\n};\\n```\\n***Another Variation if we need to choose Subsequence not subarray***\\n***                                                                                                                         ***\\n***                                                                                                                         ***\\n```\\n class Solution\\n public:\\n   int longestMountain(vector<int>&arr){          //        This is valid if we are choosing subsequence not subarray.   //  \\n        vector<int> LIS(n,1);\\n        vector<int> LDS(n,1);\\n        for(int i=0;i<n;i++)\\n        {                                   //This is for longest increasing subsequence\\n            for(int j=i-1;j>=0;j--) \\n            {    if(arr[i]>arr[j] && LIS[j]+1>LIS[i])\\n                    LIS[i]=LIS[j]+1;\\n                \\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {                                     // This is for longest decreasing subsequence from start or Longest increasing from end \\n            for(int j=i+1;j<n;j++)\\n            {    if(arr[i]>arr[j] && LDS[j]+1>LDS[i])\\n                    LDS[i]=LDS[j]+1;\\n                \\n            }\\n        }\\n        int maxx=0;\\n        for(int i=0;i<n;i++)\\n        {  if(LIS[i]>1 && LDS[i]>1)\\n              maxx=max(maxx,LIS[i]+LDS[i]-1);    \\n        }\\n        if(maxx<3)                               // When length is less than 3 means no valid mountain \\n            return -1;\\n        return maxx;\\n  \\n  }\\n  };\\n  ```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=0;\\n        int i=1;\\n        int upper,lower;\\n        \\n        while(i<n)\\n       {    upper=0;lower=0;                  //Each time after traversing one mountain or not,we have to set upper & lower to 0\\n            while(i<n && arr[i-1]==arr[i])    //   for flat array,where elements are equal\\n              i++;                            //This also handles when we get same adjacent elements\\n            while(i<n && arr[i-1]<arr[i])     //Increasing part of mountain\\n            {  upper++;i++;\\n                \\n            }\\n                    \\n            \\n           while(i<n && arr[i-1]>arr[i])    //Decreasing part of mountain \\n           {\\n               lower++;\\n               i++;    \\n           } \\n          if(upper && lower)       //Mountain only exists if we have both incresing part and decreasing part adjacently\\n           { ans=max(ans,lower+upper+1);\\n           }\\n        \\n        }\\n        \\n        return ans;\\n     \\n    }\\n};\\n```\n```\\n class Solution\\n public:\\n   int longestMountain(vector<int>&arr){          //        This is valid if we are choosing subsequence not subarray.   //  \\n        vector<int> LIS(n,1);\\n        vector<int> LDS(n,1);\\n        for(int i=0;i<n;i++)\\n        {                                   //This is for longest increasing subsequence\\n            for(int j=i-1;j>=0;j--) \\n            {    if(arr[i]>arr[j] && LIS[j]+1>LIS[i])\\n                    LIS[i]=LIS[j]+1;\\n                \\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {                                     // This is for longest decreasing subsequence from start or Longest increasing from end \\n            for(int j=i+1;j<n;j++)\\n            {    if(arr[i]>arr[j] && LDS[j]+1>LDS[i])\\n                    LDS[i]=LDS[j]+1;\\n                \\n            }\\n        }\\n        int maxx=0;\\n        for(int i=0;i<n;i++)\\n        {  if(LIS[i]>1 && LDS[i]>1)\\n              maxx=max(maxx,LIS[i]+LDS[i]-1);    \\n        }\\n        if(maxx<3)                               // When length is less than 3 means no valid mountain \\n            return -1;\\n        return maxx;\\n  \\n  }\\n  };\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 937617,
                "title": "java-short-one-pass-o-n-time-o-1-space-with-comments",
                "content": "```\\n\\tpublic int longestMountain(int[] A) {\\n        int max = 0, inc = 0, dec = 0;\\n        \\n        for(int i=1; i<A.length; i++){\\n            if(A[i] > A[i-1]){       // Current number greater than the previous\\n                if(dec > 0) inc = 0; // Reset inc if we had a decreasing sequence until the previous\\n\\t\\t\\t\\tinc++;               // Increment inc\\n                dec = 0;             // Reset dec\\n            }\\n            else if(A[i] < A[i-1]){  // Current number smaller than the previous\\n                if(inc > 0){         // No need to do anything if we did not have an increasing sequence\\n                    dec++;           // Increment dec\\n                    max = Math.max(max, inc + dec + 1);  // Determine max for the current mountain\\n                }\\n            }\\n            else inc = dec = 0;      // Current number same as the previous, reset inc and dec\\n        }\\n        \\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int longestMountain(int[] A) {\\n        int max = 0, inc = 0, dec = 0;\\n        \\n        for(int i=1; i<A.length; i++){\\n            if(A[i] > A[i-1]){       // Current number greater than the previous\\n                if(dec > 0) inc = 0; // Reset inc if we had a decreasing sequence until the previous\\n\\t\\t\\t\\tinc++;               // Increment inc\\n                dec = 0;             // Reset dec\\n            }\\n            else if(A[i] < A[i-1]){  // Current number smaller than the previous\\n                if(inc > 0){         // No need to do anything if we did not have an increasing sequence\\n                    dec++;           // Increment dec\\n                    max = Math.max(max, inc + dec + 1);  // Determine max for the current mountain\\n                }\\n            }\\n            else inc = dec = 0;      // Current number same as the previous, reset inc and dec\\n        }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 637837,
                "title": "java-3-passes-o-n",
                "content": "`left[i]` means the length of the left part of the mountain whose peak is a[i]\\n`right[i]` means the length of the right part of the mountain whose peak is a[i]\\nIf `left[i]` or `right[i]` is 0, this means that a[i] can\\'t be the peak.\\nThen just traversing again to get the longest mountain length;\\n```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int[] left = new int[a.length]; \\n        for (int i = 0 ; i < a.length; i++) {\\n            if (i != 0) {\\n                if (a[i] > a[i - 1]) {\\n                    left[i] = left[i - 1] + 1;\\n                }\\n            }\\n        }\\n        int[] right = new int[a.length];\\n        for (int i = a.length - 1; i >= 0 ; i--) {\\n            if (i != a.length - 1) {\\n                if (a[i] > a[i + 1]) {\\n                    right[i] = right[i + 1] + 1;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0 ; i < a.length ; i++) {\\n            if (left[i] != 0 && right[i] != 0) {\\n                max = Math.max(left[i] + right[i] + 1, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int[] left = new int[a.length]; \\n        for (int i = 0 ; i < a.length; i++) {\\n            if (i != 0) {\\n                if (a[i] > a[i - 1]) {\\n                    left[i] = left[i - 1] + 1;\\n                }\\n            }\\n        }\\n        int[] right = new int[a.length];\\n        for (int i = a.length - 1; i >= 0 ; i--) {\\n            if (i != a.length - 1) {\\n                if (a[i] > a[i + 1]) {\\n                    right[i] = right[i + 1] + 1;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0 ; i < a.length ; i++) {\\n            if (left[i] != 0 && right[i] != 0) {\\n                max = Math.max(left[i] + right[i] + 1, max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937743,
                "title": "python-3-explained-solution-video-code",
                "content": "[](https://www.youtube.com/watch?v=FpO3fY-1mj8)\\nhttps://www.youtube.com/watch?v=FpO3fY-1mj8\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res = 0\\n        \\n        for indx in range(1, len(A) - 1):\\n            if A[indx - 1] < A[indx] > A[indx + 1]:\\n                \\n                l = r = indx\\n                \\n                while l > 0 and A[l] > A[l - 1]:\\n                    l -= 1\\n                \\n                while r + 1 < len(A) and A[r] > A[r + 1]:\\n                    r += 1\\n                \\n                res = max(res, (r - l + 1))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res = 0\\n        \\n        for indx in range(1, len(A) - 1):\\n            if A[indx - 1] < A[indx] > A[indx + 1]:\\n                \\n                l = r = indx\\n                \\n                while l > 0 and A[l] > A[l - 1]:\\n                    l -= 1\\n                \\n                while r + 1 < len(A) and A[r] > A[r + 1]:\\n                    r += 1\\n                \\n                res = max(res, (r - l + 1))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419003,
                "title": "easy-to-understand-c-solution-20ms-beats-91",
                "content": "Runtime: 20 ms, faster than 91.45% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Longest Mountain in Array.\\n\\n```\\nint longestMountain(vector<int>& A) {\\n        \\n        if(A.size() == 0)\\n            return 0;\\n        \\n        int maxLen = 0; \\n        for(int i=1; i<A.size()-1; i++)\\n        {\\n            if(A[i] > A[i+1] && A[i] > A[i-1])\\n            {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                while(right < A.size()-1 && A[right+1] < A[right])\\n                    right++;\\n                maxLen = max(maxLen, right-left+1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "Runtime: 20 ms, faster than 91.45% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Longest Mountain in Array.\\n\\n```\\nint longestMountain(vector<int>& A) {\\n        \\n        if(A.size() == 0)\\n            return 0;\\n        \\n        int maxLen = 0; \\n        for(int i=1; i<A.size()-1; i++)\\n        {\\n            if(A[i] > A[i+1] && A[i] > A[i-1])\\n            {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && A[left-1] < A[left])\\n                    left--;\\n                while(right < A.size()-1 && A[right+1] < A[right])\\n                    right++;\\n                maxLen = max(maxLen, right-left+1);\\n            }\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1107624,
                "title": "6-liner-c-peak-valley-approach",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        \\n        int maxl = 0, i = 1;\\n        \\n        while(i < arr.size()) {\\n            \\n            int peak = 0, valley = 0;\\n            while(i < arr.size() && arr[i] > arr[i - 1]) peak++, i++;\\n            while(i < arr.size() && arr[i] < arr[i - 1]) valley++, i++;\\n            if(peak > 0 && valley > 0) maxl = max(maxl, peak + valley + 1);\\n            else if(!peak && !valley) i++;\\n        }\\n        return maxl;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        \\n        int maxl = 0, i = 1;\\n        \\n        while(i < arr.size()) {\\n            \\n            int peak = 0, valley = 0;\\n            while(i < arr.size() && arr[i] > arr[i - 1]) peak++, i++;\\n            while(i < arr.size() && arr[i] < arr[i - 1]) valley++, i++;\\n            if(peak > 0 && valley > 0) maxl = max(maxl, peak + valley + 1);\\n            else if(!peak && !valley) i++;\\n        }\\n        return maxl;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135612,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        if (A.length < 3) return 0;\\n        int[] increase = new int[A.length];\\n        int[] decrease = new int[A.length];\\n        Arrays.fill(increase, 1);\\n        Arrays.fill(decrease, 1);\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i-1]) increase[i] = increase[i-1]+1;\\n        }\\n       \\n        \\n        for (int i = A.length-2; i >= 0; i--) {\\n            if (A[i] > A[i+1]) decrease[i] = decrease[i+1]+1;\\n        }\\n       \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (A[i] > A[i-1] && A[i] > A[i+1]) {\\n                res = Math.max(res, increase[i-1] + decrease[i+1] + 1);\\n            }\\n        }\\n        return res == Integer.MIN_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        if (A.length < 3) return 0;\\n        int[] increase = new int[A.length];\\n        int[] decrease = new int[A.length];\\n        Arrays.fill(increase, 1);\\n        Arrays.fill(decrease, 1);\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i-1]) increase[i] = increase[i-1]+1;\\n        }\\n       \\n        \\n        for (int i = A.length-2; i >= 0; i--) {\\n            if (A[i] > A[i+1]) decrease[i] = decrease[i+1]+1;\\n        }\\n       \\n        int res = Integer.MIN_VALUE;\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (A[i] > A[i-1] && A[i] > A[i+1]) {\\n                res = Math.max(res, increase[i-1] + decrease[i+1] + 1);\\n            }\\n        }\\n        return res == Integer.MIN_VALUE ? 0 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945774,
                "title": "c-linear-solution-explained-100-time-50-space",
                "content": "Nice one I took my time to polish a bit and I had fun thinking about how to optimise reducing the amount of conditions/states we would have to consider.\\n\\nTo solve it, first of all let\\'s get equipped with a few variables:\\n* `res` will store the value of the maximum mountain found so far;\\n* `curr` is the value of the ongoing mountain length;\\n* `len` is the length of the initial input;\\n* `isMountain` and `isDescending` are 2 booleans to store the state, precisely in the guise their name implies.\\n\\nWe will then start looping from index `i == 1` across the whole vector and:\\n* if we are descending we will:\\n\\t* check if we need to reset our range - if either `isDescending` was `true` or `isMountain` was `false` and, in that case, we:\\n\\t\\t* set `isDescending` to `false`;\\n\\t\\t* set `isMountain` to `true`;\\n\\t\\t* reset `curr` to `1` (note: not to `0`, since we count both extremes of the range in its length);\\n\\t* in any case, we increment `curr` by one step;\\n* if we are in a mountain already and only in that case, we will:\\n\\t* if we are descending we will:\\n\\t\\t* flag `isDescending` as `true`;\\n\\t\\t* update `res` to be the maximum between its current value and the incremented value of `curr`;\\n\\t* if instead we reached a plataue, we reset `isMountain` (which in turn will trigger other variables resetting as soon as we start ascending again and only in that case).\\n\\nOnce we are done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    res = max(++curr, res);\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) isMountain = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSlightly optimised version (I gained 4ms on average running this) in which we update `res` only when either we begin ascending again or we finished the loop while still descending:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    if (isDescending) res = max(curr, res);\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    curr++;\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) {\\n                    isMountain = false;\\n                }\\n            }\\n        }\\n        if (isDescending) res = max(curr, res);\\n        return res;\\n    }\\n};\\n```\\n\\nThe first version of my code, which for some reason I have not completely clarified went much slower, taking about double time:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        if (!arr.size()) return 0;\\n        int res = 0, prev = arr[0], len = arr.size() - 1, minPos = -2, maxPos = -1;\\n        for (int i = 0, n; i < len; i++) {\\n            n = arr[i];\\n            // checking for a new min\\n            if (minPos < maxPos && n < arr[i + 1]) {\\n                // updating res if we already met a max\\n                if (maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = i;\\n                maxPos = -1;\\n            }\\n            // checking for a new max, only after having met a min\\n            else if (n > arr[i + 1] && minPos > maxPos) maxPos = i;\\n            // checking if we encountered a plateau\\n            else if (n == arr[i + 1]) {\\n                // we update res only if we already encountered a max after the last min\\n                // followed by at least another decreasing number\\n                if (minPos < maxPos && minPos > -2 && maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = -2;\\n                maxPos = -1;\\n            }\\n        }\\n        // one final check to update res with the distance between minPos and the last index\\n        // provided we have encountered a local maximum before\\n        if (maxPos > -1 && arr[len - 1] > arr[len]) res = max(res, len - minPos + 1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    res = max(++curr, res);\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) isMountain = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // support variables\\n        int res = 0, curr = 0, len = arr.size();\\n        bool isMountain = false, isDescending = false;\\n        for (int i = 1; i < len; i++) {\\n            // checking if we are climbing\\n            if (arr[i] > arr[i - 1]) {\\n                // reset conditions: either we were descending or we were\\n                // not yet in a mountain\\n                if (isDescending || !isMountain) {\\n                    if (isDescending) res = max(curr, res);\\n                    isDescending = false;\\n                    isMountain = true;\\n                    curr = 1;\\n                }\\n                curr++;\\n            }\\n            // checking if we are already in a mountain\\n            else if (isMountain) {\\n                // if we start descending\\n                if  (arr[i] < arr[i - 1]) {\\n                    isDescending = true;\\n                    curr++;\\n                }\\n                // if we reach a plateau\\n                else if (arr[i] == arr[i - 1]) {\\n                    isMountain = false;\\n                }\\n            }\\n        }\\n        if (isDescending) res = max(curr, res);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        if (!arr.size()) return 0;\\n        int res = 0, prev = arr[0], len = arr.size() - 1, minPos = -2, maxPos = -1;\\n        for (int i = 0, n; i < len; i++) {\\n            n = arr[i];\\n            // checking for a new min\\n            if (minPos < maxPos && n < arr[i + 1]) {\\n                // updating res if we already met a max\\n                if (maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = i;\\n                maxPos = -1;\\n            }\\n            // checking for a new max, only after having met a min\\n            else if (n > arr[i + 1] && minPos > maxPos) maxPos = i;\\n            // checking if we encountered a plateau\\n            else if (n == arr[i + 1]) {\\n                // we update res only if we already encountered a max after the last min\\n                // followed by at least another decreasing number\\n                if (minPos < maxPos && minPos > -2 && maxPos > -1) res = max(res, i - minPos + 1);\\n                minPos = -2;\\n                maxPos = -1;\\n            }\\n        }\\n        // one final check to update res with the distance between minPos and the last index\\n        // provided we have encountered a local maximum before\\n        if (maxPos > -1 && arr[len - 1] > arr[len]) res = max(res, len - minPos + 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937951,
                "title": "c-dp-simplification-from-2pass-to-1-pass",
                "content": "```\\nclass Solution {// DP: two pass\\npublic://Time/Space: O(N); O(N)\\n    int longestMountain(vector<int>& A) {\\n        const int N = A.size();\\n        vector<int> ups(N, 0), downs(N, 0);\\n        for(int i = 1; i < N; i++) if(A[i] > A[i-1]) ups[i] = ups[i-1]+1;\\n        int ans = 0;\\n        for(int i = N - 1; i >= 0; i--){\\n            if(i < N - 1 && A[i] > A[i+1]) downs[i] = downs[i+1]+1;\\n            if(ups[i] && downs[i]) ans = max(ans, ups[i] + downs[i] + 1);            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIllustration with Example 1: \\n[2,1,4,7,3,2,5]\\n[1,4,7,3,2] \\n\\n\\nIn this solution, accumulate latest up length and down length.\\nBoth up and down length are reset to 0 when \\ni) A[i - 1] == A[i], which means we are in plateau\\nor\\nii) down > 0 && A[i - 1] < A[i], which means a new up trend begin like the middle point of \\'M\\'\\n\\n\\n```\\nclass Solution { // DP\\uFF1A One Pass\\npublic:// Time/Space: O(N); O(1)\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0, up = 0, down = 0;\\n        for(int i = 1; i < A.size(); i++){\\n            if(down && A[i-1]<A[i] || A[i-1] == A[i]) up = down = 0;\\n            up += A[i-1] < A[i];\\n            down += A[i-1] > A[i];\\n            if(up && down) ans = max(ans, up + down + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nReferece\\n[1]: https://leetcode.com/problems/longest-mountain-in-array/discuss/135593/C%2B%2BJavaPython-1-pass-and-O(1)-space\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {// DP: two pass\\npublic://Time/Space: O(N); O(N)\\n    int longestMountain(vector<int>& A) {\\n        const int N = A.size();\\n        vector<int> ups(N, 0), downs(N, 0);\\n        for(int i = 1; i < N; i++) if(A[i] > A[i-1]) ups[i] = ups[i-1]+1;\\n        int ans = 0;\\n        for(int i = N - 1; i >= 0; i--){\\n            if(i < N - 1 && A[i] > A[i+1]) downs[i] = downs[i+1]+1;\\n            if(ups[i] && downs[i]) ans = max(ans, ups[i] + downs[i] + 1);            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution { // DP\\uFF1A One Pass\\npublic:// Time/Space: O(N); O(1)\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0, up = 0, down = 0;\\n        for(int i = 1; i < A.size(); i++){\\n            if(down && A[i-1]<A[i] || A[i-1] == A[i]) up = down = 0;\\n            up += A[i-1] < A[i];\\n            down += A[i-1] > A[i];\\n            if(up && down) ans = max(ans, up + down + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406481,
                "title": "java-b-f-one-pass-dp-solutions-with-explanations-easy-understand",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/longest-mountain-in-array/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Let\\'s call any (contiguous) subarray B (of A) a mountain if the following properties hold:\\n\\n- B.length >= 3\\n- There exists some `0 < i < B.length - 1` such that `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`\\n\\n(Note that B could be any subarray of A, including the entire array A.)\\n\\n> Given an array A of integers, return the length of the longest mountain. \\n\\n> Return `0` if there is no mountain.\\n\\n**Note:** \\n\\n- 0 <= A.length <= 10000\\n  - Indicate that `O(N^2)` is not okay.\\n- 0 <= A[i] <= 10000\\n\\n**Example:** \\n\\n```java\\nInput: [2,2,2] or [1,2,2]\\nOutput: 0\\nExplanation: There is no mountain.\\n\\nInput: [1,2,3]\\nOutput: 0\\n\\nInput: [2,1,4,7,3,2,5]\\n          --------- 5\\nOutput: 5\\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\\n\\nInput: [2,1,4,7,3,2,3,7,6,5,1]\\n          --------- 5\\n                  ----------- 6\\nOutput: 6\\n```\\n\\n**Follow up:** \\n\\n- Can you solve it using only one pass?\\n- Can you solve it in O(1) space?\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nFor an array of size `n`, we compute the mountain lengths for every subarray from size at least `3` to `n`.\\n\\n**Note:** Be very careful about the index update.\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  for (int len = 3; len <= n; ++len) {\\n    for (int i = 0; i + len - 1 < n; ++i) {\\n      int end = i + len - 1;\\n      maxLen = Math.max(maxLen, mountainLen(A, i, end));\\n    }\\n  }\\n  return maxLen;\\n}\\n```\\n\\nIn terms of the mountain length calculation (the mountain should start from the first element), check out the examples in comments. The following code is similar to the one-pointer solution.\\n\\n```java\\nprivate int mountainLen(int[] A, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n < 3) {\\n    return 0;\\n  }\\n  // 5 4 3 2 1    -> no mountain\\n  //   i\\n  // 1 2 3 4 5    -> no mountain\\n  //   i       i\\n  // 1 2 3 2 1    -> returns i = n\\n  //   i   i   i\\n  // 1 2 3 2 1 2  -> returns i = n - 1 (not includes the last element)\\n  //   i   i   i \\n  int i = lo + 1;\\n  while (i <= hi && A[i - 1] < A[i]) {\\n    ++i;\\n  }\\n  if (i == lo + 1 || i == hi + 1) return 0; // no mountain\\n  // i now points to the first element that A[i - 1] > A[i]\\n  while (i <= hi && A[i - 1] > A[i]) {\\n    ++i;\\n  }\\n  return i - lo;\\n}\\n```\\n\\n**Time:** `O(N^3)` (unacceptable)\\n**Space:** `O(1)`\\n\\n\\n\\n### One-Pass (one pointer)\\n\\nBy observation of the example below, we can actually go through the array and get the maximum mountain length in one pass.\\n\\n```java\\n 0 1 2 3 4 5 6 7 8 9 10\\n[2,1,4,7,3,2,3,7,6,5,1]\\n   --------- 5\\n           ----------- 6\\n```\\n\\nIn order to do that, we have to simulate the `going-up` and `going-down` processes in order. For example, while going up, the start point is at `1`, the peek is at `3`, and the end point is at `5`. We cannot go further, so we have a mountain of length 5. We do that for the following mountain until we reach the end of the array.\\n\\nThe idea is not difficult, but the implementation is because of index manipulation and special/corner cases. Try to come up with some small examples and get some invariants.\\n\\n**Note:** \\n\\n- Since we check elements at `A[i]` and `A[i + 1]`, the condition is `i < n - 1`.\\n- Record the starting point in each process, reconstruct a new mountain if `i` does not move at all (which means invalidity).\\n- Go through your code for cases: `[1,2,2]`, `[2]`, `[1,2,3]`, `[3,2,1]`.\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  int i = 0;\\n  while (i < n - 1) {\\n    int upStart = i;\\n    // Go up\\n    while (i < n - 1 && A[i] < A[i + 1]) ++i;\\n    if (i == upStart) { // does not move\\n      ++i; continue;\\n    } // i stops the peek\\n    // Go down\\n    int downStart = i;\\n    while (i < n - 1 && A[i] > A[i + 1]) ++i;\\n    if (i == downStart) {\\n      ++i; continue;\\n    } // i stops at the last in the subarray\\n    // Update length\\n    int len = i - upStart + 1;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n### DP\\n\\nUse extra two arrays `inc[]` and `dec[]` to store information we need and then go through the array.\\n\\n- **inc[i]**: The maximum increasing length for the subarray ending at `i`. (constructed from left)\\n  - For example: `[1,2,3]` the `inc[i] = [0,1,2]`.\\n- **dec[i]**: The maximum decreasing length for the subarray starting at `i`. (constructed from right)\\n- Both `inc[]` and `dec[]` are initialized with `0`.\\n\\nThen we go through the array from `1` to `n - 1` for each possible peak. We calculate the peak only when `inc[i]` and `dec[i]` are both non-zero.\\n\\n**Note:** The length is `inc[i] + dec[i] + 1`.\\n\\n```java\\n// inc[] and inc[] are initialized with 0\\nindex    0   1   2   3   4   5   6   7   8   9   10\\n------------------------------------------------------\\n         2   1   4   7   3   2   3   7   6   5   1\\ninc[i]   0   0   1   2   0   0   1   2   0   0   0\\ndec[i]   0   0   0   2   1   0   0   3   2   1   0\\n------------------------------------------------------\\nlen          0   0 4+1=5 0   0   0 5+1=6 0   0   0\\n```\\n\\nHere is the code:\\n\\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int[] inc = new int[n]; // init with 0\\n  int[] dec = new int[n]; \\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    if (A[i - 1] < A[i]) inc[i] = inc[i - 1] + 1;\\n    if (A[j] > A[j + 1]) dec[j] = dec[j + 1] + 1;\\n    // otherwise, keep it 0\\n  }\\n  // for each possible peak\\n  int maxLen = 0;\\n  for (int i = 1; i < n - 1; ++i) {\\n    if (inc[i] > 0 && dec[i] > 0) {\\n      maxLen = Math.max(maxLen, inc[i] + dec[i] + 1);\\n    }\\n  }\\n  return maxLen;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: [2,2,2] or [1,2,2]\\nOutput: 0\\nExplanation: There is no mountain.\\n\\nInput: [1,2,3]\\nOutput: 0\\n\\nInput: [2,1,4,7,3,2,5]\\n          --------- 5\\nOutput: 5\\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\\n\\nInput: [2,1,4,7,3,2,3,7,6,5,1]\\n          --------- 5\\n                  ----------- 6\\nOutput: 6\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  for (int len = 3; len <= n; ++len) {\\n    for (int i = 0; i + len - 1 < n; ++i) {\\n      int end = i + len - 1;\\n      maxLen = Math.max(maxLen, mountainLen(A, i, end));\\n    }\\n  }\\n  return maxLen;\\n}\\n```\n```java\\nprivate int mountainLen(int[] A, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  if (n < 3) {\\n    return 0;\\n  }\\n  // 5 4 3 2 1    -> no mountain\\n  //   i\\n  // 1 2 3 4 5    -> no mountain\\n  //   i       i\\n  // 1 2 3 2 1    -> returns i = n\\n  //   i   i   i\\n  // 1 2 3 2 1 2  -> returns i = n - 1 (not includes the last element)\\n  //   i   i   i \\n  int i = lo + 1;\\n  while (i <= hi && A[i - 1] < A[i]) {\\n    ++i;\\n  }\\n  if (i == lo + 1 || i == hi + 1) return 0; // no mountain\\n  // i now points to the first element that A[i - 1] > A[i]\\n  while (i <= hi && A[i - 1] > A[i]) {\\n    ++i;\\n  }\\n  return i - lo;\\n}\\n```\n```java\\n 0 1 2 3 4 5 6 7 8 9 10\\n[2,1,4,7,3,2,3,7,6,5,1]\\n   --------- 5\\n           ----------- 6\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int maxLen = 0;\\n  int i = 0;\\n  while (i < n - 1) {\\n    int upStart = i;\\n    // Go up\\n    while (i < n - 1 && A[i] < A[i + 1]) ++i;\\n    if (i == upStart) { // does not move\\n      ++i; continue;\\n    } // i stops the peek\\n    // Go down\\n    int downStart = i;\\n    while (i < n - 1 && A[i] > A[i + 1]) ++i;\\n    if (i == downStart) {\\n      ++i; continue;\\n    } // i stops at the last in the subarray\\n    // Update length\\n    int len = i - upStart + 1;\\n    maxLen = Math.max(maxLen, len);\\n  }\\n  return maxLen;\\n}\\n```\n```java\\n// inc[] and inc[] are initialized with 0\\nindex    0   1   2   3   4   5   6   7   8   9   10\\n------------------------------------------------------\\n         2   1   4   7   3   2   3   7   6   5   1\\ninc[i]   0   0   1   2   0   0   1   2   0   0   0\\ndec[i]   0   0   0   2   1   0   0   3   2   1   0\\n------------------------------------------------------\\nlen          0   0 4+1=5 0   0   0 5+1=6 0   0   0\\n```\n```java\\npublic int longestMountain(int[] A) {\\n  int n = A.length;\\n  int[] inc = new int[n]; // init with 0\\n  int[] dec = new int[n]; \\n  for (int i = 1, j = n - 2; i < n; ++i, --j) {\\n    if (A[i - 1] < A[i]) inc[i] = inc[i - 1] + 1;\\n    if (A[j] > A[j + 1]) dec[j] = dec[j + 1] + 1;\\n    // otherwise, keep it 0\\n  }\\n  // for each possible peak\\n  int maxLen = 0;\\n  for (int i = 1; i < n - 1; ++i) {\\n    if (inc[i] > 0 && dec[i] > 0) {\\n      maxLen = Math.max(maxLen, inc[i] + dec[i] + 1);\\n    }\\n  }\\n  return maxLen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022776,
                "title": "java-100-faster-one-pass",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < arr.length-1; i++) {\\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && arr[left-1] < arr[left]) left--;\\n                while(right < arr.length-1 && arr[right] > arr[right+1]) right++;\\n                \\n                max = Math.max(max, right-left+1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int max = 0;\\n        \\n        for(int i = 1; i < arr.length-1; i++) {\\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                int left = i-1;\\n                int right = i+1;\\n                \\n                while(left > 0 && arr[left-1] < arr[left]) left--;\\n                while(right < arr.length-1 && arr[right] > arr[right+1]) right++;\\n                \\n                max = Math.max(max, right-left+1);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938030,
                "title": "longest-mountain-in-array-java",
                "content": "```\\nclass Solution \\n{\\n    /* First scan the array for peaks (i.e. a value where the previous and next value are both \\n     * lower.)  Once a peak is found scan foreword and back to determine how wide this particular\\n     * peak is.  Return the max of the values found.\\n     */\\n    \\n    public int longestMountain(int[] A) \\n    {\\n        int     ret = 0;\\n        int     n   = A.length - 1; \\n        \\n        for( int i = 1; i < n; i++ )\\n        {\\n            if( A[ i - 1 ] < A[ i ] && A[ i ] > A[ i + 1 ] )\\n            {\\n                int     l = i;\\n                \\n                while( l > 0 && A[ l - 1 ] < A[ l ] )       l--;\\n                while( i < n && A[ i + 1 ] < A[ i ] )       i++;\\n                \\n                ret = Math.max( ret, i - l + 1 );\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* First scan the array for peaks (i.e. a value where the previous and next value are both \\n     * lower.)  Once a peak is found scan foreword and back to determine how wide this particular\\n     * peak is.  Return the max of the values found.\\n     */\\n    \\n    public int longestMountain(int[] A) \\n    {\\n        int     ret = 0;\\n        int     n   = A.length - 1; \\n        \\n        for( int i = 1; i < n; i++ )\\n        {\\n            if( A[ i - 1 ] < A[ i ] && A[ i ] > A[ i + 1 ] )\\n            {\\n                int     l = i;\\n                \\n                while( l > 0 && A[ l - 1 ] < A[ l ] )       l--;\\n                while( i < n && A[ i + 1 ] < A[ i ] )       i++;\\n                \\n                ret = Math.max( ret, i - l + 1 );\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150136,
                "title": "simple-o-n-one-pass-o-1-space-java-ac-solution-beats-99-05",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int longestMountain = 0;\\n        for (int i = 1; i < A.length-1; i++) {\\n            if (A[i-1] < A[i] && A[i+1] < A[i]) {\\n                int l = i-1;\\n                int r = i+1;\\n                while(l > 0 && A[l-1] < A[l]) {\\n                    l--;\\n                }\\n                while(r < A.length-1 && A[r+1] < A[r]) {\\n                    r++;\\n                }\\n                longestMountain = Math.max(longestMountain, (r - l + 1));\\n            }\\n        }\\n        return longestMountain;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int longestMountain = 0;\\n        for (int i = 1; i < A.length-1; i++) {\\n            if (A[i-1] < A[i] && A[i+1] < A[i]) {\\n                int l = i-1;\\n                int r = i+1;\\n                while(l > 0 && A[l-1] < A[l]) {\\n                    l--;\\n                }\\n                while(r < A.length-1 && A[r+1] < A[r]) {\\n                    r++;\\n                }\\n                longestMountain = Math.max(longestMountain, (r - l + 1));\\n            }\\n        }\\n        return longestMountain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937867,
                "title": "longest-mountain-in-array-c-explained",
                "content": "The question is very similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ , I highly recommend you to solve first and give a try to this question before going though the solution.\\n\\nThe idea is simple, since a mountain has a rise(slope or upper_tail) and a fall(descent or lower_tail), we keep track of it.\\n\\nNote that if a mountain exists , it should definietly have a non zero upper_tail and a lower_tail.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int result = 0;\\n        int lower_tail, upper_tail;\\n        \\n        for(int i = 0 ; i < A.size();){\\n            lower_tail = upper_tail = 0;\\n            while(i + 1 < A.size() && A[i] < A[i + 1]){\\n                upper_tail++;\\n                i++;\\n            }\\n             while(upper_tail > 0 && i + 1 < A.size() && A[i] > A[i + 1]){\\n                lower_tail++;\\n                i++;\\n            }\\n            if(lower_tail > 0 && upper_tail > 0)\\n                result = max(result, lower_tail + upper_tail + 1);\\n            else if(lower_tail == 0)\\n                i++;\\n        }\\n        return result;\\n    }\\n};\\n```\\nThank you, Have a nice day",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int result = 0;\\n        int lower_tail, upper_tail;\\n        \\n        for(int i = 0 ; i < A.size();){\\n            lower_tail = upper_tail = 0;\\n            while(i + 1 < A.size() && A[i] < A[i + 1]){\\n                upper_tail++;\\n                i++;\\n            }\\n             while(upper_tail > 0 && i + 1 < A.size() && A[i] > A[i + 1]){\\n                lower_tail++;\\n                i++;\\n            }\\n            if(lower_tail > 0 && upper_tail > 0)\\n                result = max(result, lower_tail + upper_tail + 1);\\n            else if(lower_tail == 0)\\n                i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937588,
                "title": "c-one-pass-in-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int i,n=a.size(),res,l,h,ind,maxi=0;\\n        if(n==0) return 0;\\n        for(i=1;i<n-1;i++)\\n        {\\n            if(a[i-1]<a[i] && a[i]>a[i+1])\\n            {\\n                l=i-1; h=i+1;\\n                while(l>0 && a[l]>a[l-1]) l--;\\n                while(h<n-1 && a[h]>a[h+1]) h++;\\n                maxi=max(maxi,h-l+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int i,n=a.size(),res,l,h,ind,maxi=0;\\n        if(n==0) return 0;\\n        for(i=1;i<n-1;i++)\\n        {\\n            if(a[i-1]<a[i] && a[i]>a[i+1])\\n            {\\n                l=i-1; h=i+1;\\n                while(l>0 && a[l]>a[l-1]) l--;\\n                while(h<n-1 && a[h]>a[h+1]) h++;\\n                maxi=max(maxi,h-l+1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304129,
                "title": "c-fastest-solution-o-n-tc-sc-lis",
                "content": "TC: O(n)\\nSC: O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1)ans=max(ans,left[i]+right[i]-1);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1)ans=max(ans,left[i]+right[i]-1);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272599,
                "title": "c-java-python-very-easy-to-understand-one-pass-o-1-space-o-n-time",
                "content": "I would suggest a dry run on an example in order to better understand the code.\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int maxMountain = 0, n = arr.size(), idx = 1, up = 0, down = 0;\\n        while (idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            // start looking further in array for a possible mountain\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx])\\n                ++up, ++idx;\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx])\\n                ++down, ++idx;\\n            if(up && down)  \\n                // + 1 as we do add the peak itself\\n                maxMountain = max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n};\\n```\\n\\nJava: \\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxMountain = 0, idx = 1, up = 0, down = 0, n = arr.length;\\n        while(idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx]) {\\n                ++up;\\n                ++idx;\\n            }\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx]) {\\n                ++down;\\n                ++idx;\\n            }\\n            if(up > 0 && down > 0)\\n                maxMountain = Math.max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n}\\n```\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```\\n\\nThanks for reading, an upvote would be appreciated! ^_^",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int maxMountain = 0, n = arr.size(), idx = 1, up = 0, down = 0;\\n        while (idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            // start looking further in array for a possible mountain\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx])\\n                ++up, ++idx;\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx])\\n                ++down, ++idx;\\n            if(up && down)  \\n                // + 1 as we do add the peak itself\\n                maxMountain = max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxMountain = 0, idx = 1, up = 0, down = 0, n = arr.length;\\n        while(idx < n) {\\n            while(idx < n && arr[idx - 1] == arr[idx])\\n                ++idx;\\n            up = 0;\\n            while(idx < n && arr[idx - 1] < arr[idx]) {\\n                ++up;\\n                ++idx;\\n            }\\n            down = 0;\\n            while(idx < n && arr[idx - 1] > arr[idx]) {\\n                ++down;\\n                ++idx;\\n            }\\n            if(up > 0 && down > 0)\\n                maxMountain = Math.max(maxMountain, up + down + 1);\\n        }\\n        return maxMountain;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        idx = 1\\n        up = 0\\n        down = 0\\n        maxMountain = 0\\n        \\n        while idx < n:\\n            while idx < n and arr[idx - 1] == arr[idx]:\\n                idx += 1\\n            up = 0\\n            while idx < n and arr[idx - 1] < arr[idx]:\\n                up += 1\\n                idx += 1\\n            down = 0\\n            while idx < n and arr[idx - 1] > arr[idx]:\\n                down += 1\\n                idx += 1\\n            if up > 0 and down > 0:\\n                maxMountain = max(maxMountain, up + down + 1)\\n                \\n        return \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990230,
                "title": "java-two-pointers-o-n",
                "content": "For each qualified peak, i.e. greater than its left and right element, expand from it to left and right to find the mountain length\\n\\nEach number is visited at most twice because numbers on the slope of a mountain will never be visited twice (as points on the slope doesn\\'t qualify as a peak). Only points on the end of a mountain could be visited twice, since it could be part of the mountain on its left and the mountain on its right.\\n\\n```\\npublic int longestMountain(int[] arr) {\\n    if(arr.length < 3){\\n        return 0;\\n    }\\n    int longest = 0;\\n    for(int i = 1; i < arr.length - 1; i++){\\n        if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){\\n            int left = i;\\n            int right = i;\\n            while(left > 0 && arr[left - 1] < arr[left]){\\n                left--;\\n            }\\n            while(right < arr.length - 1 && arr[right + 1] < arr[right]){\\n                right++;\\n            }\\n            longest = Math.max(right - left + 1, longest);\\n        }\\n    }\\n    return longest;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic int longestMountain(int[] arr) {\\n    if(arr.length < 3){\\n        return 0;\\n    }\\n    int longest = 0;\\n    for(int i = 1; i < arr.length - 1; i++){\\n        if(arr[i] > arr[i - 1] && arr[i] > arr[i + 1]){\\n            int left = i;\\n            int right = i;\\n            while(left > 0 && arr[left - 1] < arr[left]){\\n                left--;\\n            }\\n            while(right < arr.length - 1 && arr[right + 1] < arr[right]){\\n                right++;\\n            }\\n            longest = Math.max(right - left + 1, longest);\\n        }\\n    }\\n    return longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436584,
                "title": "c-solution-o-n-easy-to-understand",
                "content": "```\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution\\n{\\npublic:\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int i = 1, n = arr.size(), max_mnt = 0;\\n        while (i < n)\\n        {\\n            int upper = 0, down = 0;\\n            while (i < n && arr[i] == arr[i - 1])\\n            {\\n                i++;\\n            }\\n\\n            // Going Up on Mountain\\n            while (i < n && arr[i] > arr[i - 1])\\n            {\\n                i++, upper++;\\n            }\\n\\n            // Going down on Mountain\\n            while (i < n && arr[i] < arr[i - 1])\\n            {\\n                down++, i++;\\n            }\\n\\n            if (upper && down)\\n            {\\n                max_mnt = max(max_mnt, upper + down + 1);\\n            }\\n        }\\n\\n        return max_mnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Time Complexity : O(N)\\n// Space Complexity : O(1)\\nclass Solution\\n{\\npublic:\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int i = 1, n = arr.size(), max_mnt = 0;\\n        while (i < n)\\n        {\\n            int upper = 0, down = 0;\\n            while (i < n && arr[i] == arr[i - 1])\\n            {\\n                i++;\\n            }\\n\\n            // Going Up on Mountain\\n            while (i < n && arr[i] > arr[i - 1])\\n            {\\n                i++, upper++;\\n            }\\n\\n            // Going down on Mountain\\n            while (i < n && arr[i] < arr[i - 1])\\n            {\\n                down++, i++;\\n            }\\n\\n            if (upper && down)\\n            {\\n                max_mnt = max(max_mnt, upper + down + 1);\\n            }\\n        }\\n\\n        return max_mnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283245,
                "title": "python-easy-to-understand-o-n-time-o-1-space",
                "content": "**Explanation:**\\nLets divide the problem into 2 parts:\\n1. Finding the peak value of the mountain\\n2. Finding the length of the mountain\\n\\n**1. Find peak value:**\\n*  A value is considered as a peak if the elements adjacent to the peak is strictly less than it\\n*  Keep on iterating through the list until a peak value is found\\n\\n**2. Find length of the mountain**\\n* Once we find the peak value, Iterate through left and right elements to find the length of mountain\\n* Increase rightindex/Decrease left index until the subsequent values are strictly less\\n* Current length of mountain = right index - left index -1\\n* compare it with max_length and assign if max_length<current length\\n\\nIterate through all the elements until list is exhausted to find the max length of the mountain\\n```\\n\\tmaxlength = 0\\n        i = 1\\n        while(i<len(arr)-1):\\n            peak = arr[i]>arr[i-1] and arr[i]>arr[i+1]\\n            if not peak:\\n                i += 1\\n                continue\\n\\n            leftidx = i-2\\n            while(leftidx >= 0 and arr[leftidx]<arr[leftidx+1]):\\n                leftidx -= 1\\n\\n            rightidx = i+2\\n            while(rightidx < len(arr) and arr[rightidx]<arr[rightidx-1]):\\n                rightidx += 1\\n\\n            length = rightidx-leftidx-1\\n            if(length>maxlength):\\n                maxlength = length\\n            i = rightidx\\n        return maxlength\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\n\\tmaxlength = 0\\n        i = 1\\n        while(i<len(arr)-1):\\n            peak = arr[i]>arr[i-1] and arr[i]>arr[i+1]\\n            if not peak:\\n                i += 1\\n                continue\\n\\n            leftidx = i-2\\n            while(leftidx >= 0 and arr[leftidx]<arr[leftidx+1]):\\n                leftidx -= 1\\n\\n            rightidx = i+2\\n            while(rightidx < len(arr) and arr[rightidx]<arr[rightidx-1]):\\n                rightidx += 1\\n\\n            length = rightidx-leftidx-1\\n            if(length>maxlength):\\n                maxlength = length\\n            i = rightidx\\n        return maxlength\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943750,
                "title": "java-very-simple-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {        \\n        int longest = 0;\\n        int startIndex = 0;\\n        int endIndex = arr.length - 1;\\n                \\n        for(int i = 1; i < endIndex; i++) {\\n            int topIndex = i;\\n            int leftIndex = i - 1;\\n            int rightIndex = i + 1;\\n            \\n            if(arr[leftIndex] >= arr[topIndex] || arr[rightIndex] >= arr[topIndex]) {\\n                continue;\\n            }\\n            \\n            while(leftIndex != startIndex && arr[leftIndex] > arr[leftIndex - 1]) {\\n                leftIndex--;\\n            }\\n            \\n            while(rightIndex != endIndex && arr[rightIndex] > arr[rightIndex + 1]) {\\n                rightIndex++;\\n            }\\n            \\n            longest = Math.max(longest, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {        \\n        int longest = 0;\\n        int startIndex = 0;\\n        int endIndex = arr.length - 1;\\n                \\n        for(int i = 1; i < endIndex; i++) {\\n            int topIndex = i;\\n            int leftIndex = i - 1;\\n            int rightIndex = i + 1;\\n            \\n            if(arr[leftIndex] >= arr[topIndex] || arr[rightIndex] >= arr[topIndex]) {\\n                continue;\\n            }\\n            \\n            while(leftIndex != startIndex && arr[leftIndex] > arr[leftIndex - 1]) {\\n                leftIndex--;\\n            }\\n            \\n            while(rightIndex != endIndex && arr[rightIndex] > arr[rightIndex + 1]) {\\n                rightIndex++;\\n            }\\n            \\n            longest = Math.max(longest, rightIndex - leftIndex + 1);\\n        }\\n        \\n        return longest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812564,
                "title": "python-time-o-n-space-o-1-faster-than-97-76-easy-to-understand-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/38ae550e-6c35-4a14-a449-ac0786dc2092_1646215938.7846613.png)\\n```\\n# time = O(N)/Space = O(1)\\nclass Solution(object):\\n    def longestMountain(self, arr):\\n        longestHeight = 0\\n        currHeight = 0\\n        \\n        # negelect very first and very last element as an not be peak at any cost\\n        currIdx = 1\\n        while currIdx < len(arr) -1:\\n            # search for peak \\n            isPeak = arr[currIdx] > arr[currIdx -1] and arr[currIdx] > arr[currIdx + 1]\\n            if not isPeak:\\n                #if not peak then continue\\n                currIdx += 1\\n                continue\\n            # if we found peak - now time to expand to left and right to measure height\\n            # start with second adjacent from left and right\\n            leftIdx = currIdx - 2\\n            rightIdx = currIdx + 2\\n            # check bounds\\n            while leftIdx >= 0 and arr[leftIdx] < arr[leftIdx + 1]:\\n                leftIdx -= 1\\n                \\n            while rightIdx < len(arr) and arr[rightIdx] < arr[rightIdx - 1]:\\n                rightIdx += 1\\n            # calculate current height    \\n            currHeight = rightIdx - leftIdx - 1 \\n            longestHeight = max(longestHeight, currHeight)\\n            \\n            currIdx =  rightIdx\\n        return longestHeight\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n# time = O(N)/Space = O(1)\\nclass Solution(object):\\n    def longestMountain(self, arr):\\n        longestHeight = 0\\n        currHeight = 0\\n        \\n        # negelect very first and very last element as an not be peak at any cost\\n        currIdx = 1\\n        while currIdx < len(arr) -1:\\n            # search for peak \\n            isPeak = arr[currIdx] > arr[currIdx -1] and arr[currIdx] > arr[currIdx + 1]\\n            if not isPeak:\\n                #if not peak then continue\\n                currIdx += 1\\n                continue\\n            # if we found peak - now time to expand to left and right to measure height\\n            # start with second adjacent from left and right\\n            leftIdx = currIdx - 2\\n            rightIdx = currIdx + 2\\n            # check bounds\\n            while leftIdx >= 0 and arr[leftIdx] < arr[leftIdx + 1]:\\n                leftIdx -= 1\\n                \\n            while rightIdx < len(arr) and arr[rightIdx] < arr[rightIdx - 1]:\\n                rightIdx += 1\\n            # calculate current height    \\n            currHeight = rightIdx - leftIdx - 1 \\n            longestHeight = max(longestHeight, currHeight)\\n            \\n            currIdx =  rightIdx\\n        return longestHeight\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234414,
                "title": "12-lines-c-o-n-dry-run",
                "content": "To understand the code just do dry run believe me just do dry run you will get the code at once otherwise just comment down below will help you to understand (^_^).\\n\\nDry run for these test cases to understand :\\n1. [2,1,4,7,3,2,5]\\n2. [1,2,3,4,5,6,7,8,9]\\n3. [2,3,1,2,3,4,5,6]\\n\\nThese cases are enough for u to understand the logic.\\n\\n``` \\n    int longestMountain(vector<int>& A) {\\n        int res = 0, count = 1; bool flag = 0;\\n        for(int i=1; i<A.size(); i++){\\n            if(A[i] > A[i-1]){\\n                if(flag == 1) flag = 0, count = 1;\\n                count++;\\n            }\\n            else if(count >= 2 and A[i] < A[i-1]){\\n                flag = 1;  count++;\\n                res = max(res, count);\\n            }\\n            else count = 1;\\n        }\\n        return res;\\n    }\\n```\\n\\nIf you liked it do click on the UPVOTE icon.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` \\n    int longestMountain(vector<int>& A) {\\n        int res = 0, count = 1; bool flag = 0;\\n        for(int i=1; i<A.size(); i++){\\n            if(A[i] > A[i-1]){\\n                if(flag == 1) flag = 0, count = 1;\\n                count++;\\n            }\\n            else if(count >= 2 and A[i] < A[i-1]){\\n                flag = 1;  count++;\\n                res = max(res, count);\\n            }\\n            else count = 1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937825,
                "title": "easy-to-understand-java-solution-beats-100",
                "content": "The logic behind this solution was very simple. We just need to traverse the array for uphill (ascending order) and downhill (descending order).  \\n\\n\\t//go uphill\\n\\twhile(i<A.length && A[i-1]<A[i]){\\n\\t\\tupHill=true;\\n\\t\\ti++;\\n\\t}\\n\\t//go downhill\\n\\twhile(i<A.length && A[i-1]>A[i]){\\n\\t\\tdownHill=true;\\n\\t\\ti++;\\n\\t}\\n\\n\\nIf we found both uphill and downhill, then get the total length from the start of uphill till now and update the maximum mountain.\\n\\n\\tif(upHill && downHill){\\n\\t\\t//only update when mountain size was equal or greater than 3\\n\\t\\tif(i-start>=3)result = Math.max(i-start,result);\\n\\t}\\n\\nIn case there was no uphill and/or downhill or either, then it wasn\\'t mountain (obviously). Then we just need to ensure that it neither be plain surface (same value). Then, just keep moving\\n\\n\\twhile(i<A.length && A[i-1]==A[i])i++;\\n\\nHere is complete solution with comment.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nCode Analysis :\\n\\n\\tTime complexity : O(n)\\n\\tSpace complexity : O(1)\\n\\nAny comments or suggestion are welcome. :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895623,
                "title": "python-solution-0-n-o-1-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        start = 0 # Ground from where the uphill starts.\\n        _maxPeak = 0\\n        reachedPeak = False\\n        for i in range(1, len(A)-1):\\n            # The uphill starts only if the current ground height is lower to the next ground height.\\n            # This condition is met at both the left side of the peak and the right side of the peak hence the variable reachedPeak to check if the peek has been reached.\\n            if A[i-1] >= A[i] <= A[i+1]:\\n                # if peak had been reached then we are now on the right side of the ground. We need to calucalte the lenght of the mountain.\\n                if reachedPeak:\\n                    reachedPeak = False\\n                    _maxPeak = max(_maxPeak, i - start + 1)\\n                start = i\\n            \\n            # Peak condition.\\n            elif A[i-1] < A[i] > A[i+1]:\\n                reachedPeak = True\\n        \\n        # This is to check if there is only downhill after the peak has been reached.\\n        if reachedPeak:\\n            _maxPeak = max(_maxPeak, len(A) - start)\\n        return _maxPeak\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        start = 0 # Ground from where the uphill starts.\\n        _maxPeak = 0\\n        reachedPeak = False\\n        for i in range(1, len(A)-1):\\n            # The uphill starts only if the current ground height is lower to the next ground height.\\n            # This condition is met at both the left side of the peak and the right side of the peak hence the variable reachedPeak to check if the peek has been reached.\\n            if A[i-1] >= A[i] <= A[i+1]:\\n                # if peak had been reached then we are now on the right side of the ground. We need to calucalte the lenght of the mountain.\\n                if reachedPeak:\\n                    reachedPeak = False\\n                    _maxPeak = max(_maxPeak, i - start + 1)\\n                start = i\\n            \\n            # Peak condition.\\n            elif A[i-1] < A[i] > A[i+1]:\\n                reachedPeak = True\\n        \\n        # This is to check if there is only downhill after the peak has been reached.\\n        if reachedPeak:\\n            _maxPeak = max(_maxPeak, len(A) - start)\\n        return _maxPeak\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 364764,
                "title": "count-points-of-the-mountain-on-both-up-and-down-slope-python",
                "content": "Keep counting points that form up and down slope. Reset when new mountain or flat is found. Record longest mountain for each point.\\n\\n```\\n    def longestMountain(self, A):\\n        increase, decrease, longest_mountain = 0, 0, 0\\n\\n        for i in range(len(A)):\\n            previous, current = A[i-1] if i > 0 else A[i], A[i]\\n \\n            if current == previous or (current > previous and decrease > 0):  \\n                increase, decrease = 1, 0  # reset when flat or new mountain is found\\n\\n            if current < previous: decrease += 1\\n            elif current > previous: increase += 1\\n            \\n            if increase > 1 and decrease > 0:\\n                longest_mountain = max(longest_mountain, increase + decrease)\\n\\n        return longest_mountain \\n```",
                "solutionTags": [],
                "code": "```\\n    def longestMountain(self, A):\\n        increase, decrease, longest_mountain = 0, 0, 0\\n\\n        for i in range(len(A)):\\n            previous, current = A[i-1] if i > 0 else A[i], A[i]\\n \\n            if current == previous or (current > previous and decrease > 0):  \\n                increase, decrease = 1, 0  # reset when flat or new mountain is found\\n\\n            if current < previous: decrease += 1\\n            elif current > previous: increase += 1\\n            \\n            if increase > 1 and decrease > 0:\\n                longest_mountain = max(longest_mountain, increase + decrease)\\n\\n        return longest_mountain \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 190888,
                "title": "one-pass-javascript-solution-without-nested-loops-o-n-time-o-1-space",
                "content": "Uses `dir` to track the trajectory of the \"terrain\", accounting for \"plateaus\" in the values (`1` is an incline, `0` is a plateau, `-1` is a decline). \\n```\\nvar longestMountain = function(A) {\\n    let longest = 0, start = 0, dir = 0\\n    \\n    // Note the <= here because we are doing comparisons with the previous value. Could swap it and do comparisons with the next value, but it\\'s more or less the same idea.\\n    for(var i = 0; i <= A.length; i++) {\\n        let val = A[i], prev = A[i-1]\\n        \\n        // On a decline and we\\'ve either reached the end, a plateau, or an incline\\n        if (dir === -1 && (i === A.length || !(val < prev))) {            \\n            longest = Math.max(i - start, longest)\\n            start = i - 1\\n            dir = val !== undefined && val > prev ? 1 : 0\\n        } else if (dir === 1 && val < prev) { // On an incline and we\\'ve crossed over the peak\\n            dir = -1\\n        } else if (val === prev) { // A plateau (in the case where we\\'re either on an incline or already a plateau\\n          dir = 0  \\n        } else if (val > prev && dir !== 1) { // Reached an incline when we weren\\'t already on one, so lets try to start a mountain\\n            start = i - 1\\n            dir = 1\\n        }\\n    }\\n    \\n    return longest\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestMountain = function(A) {\\n    let longest = 0, start = 0, dir = 0\\n    \\n    // Note the <= here because we are doing comparisons with the previous value. Could swap it and do comparisons with the next value, but it\\'s more or less the same idea.\\n    for(var i = 0; i <= A.length; i++) {\\n        let val = A[i], prev = A[i-1]\\n        \\n        // On a decline and we\\'ve either reached the end, a plateau, or an incline\\n        if (dir === -1 && (i === A.length || !(val < prev))) {            \\n            longest = Math.max(i - start, longest)\\n            start = i - 1\\n            dir = val !== undefined && val > prev ? 1 : 0\\n        } else if (dir === 1 && val < prev) { // On an incline and we\\'ve crossed over the peak\\n            dir = -1\\n        } else if (val === prev) { // A plateau (in the case where we\\'re either on an incline or already a plateau\\n          dir = 0  \\n        } else if (val > prev && dir !== 1) { // Reached an incline when we weren\\'t already on one, so lets try to start a mountain\\n            start = i - 1\\n            dir = 1\\n        }\\n    }\\n    \\n    return longest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 135632,
                "title": "easy-to-understand-find-peaks-and-then-find-max-length-mountain-o-n",
                "content": "**Peak** - A value which is greater than neighboring values. A[i]>A[i-1] and A[i]>A[i+1] for i>0\\nAfter finding all such peaks we go left and right from each peak till the following condition holds - \\nTo the left - A[i-m] .... A[i-2] < A[i-1] < A[i]\\nTo the right - A[i] > A[i+1] > A[i+2] ... A[i+n]\\nLength of the mountain at each peak = m+n+1\\nIn the end we return the mountain with maximum length.\\n\\n**Time Complexity** - \\nFor each peak we are moving in left and right direction which might look like that the algorithm has non-linear complexity. But, the execution is in fact linear. Consider the following example - \\n\\nA = [1,2,1,3,4,6,2,1]\\nPeaks at positions = [1,5]\\nFirst we will go left from peak at index 1 and farthest we can go is till index 0\\nThen we will go right from peak at index 1 and farthest we can go is till index 2 because after index 2 it again starts increasing i.e. A[2]<A[3].\\nSimilarly, we will go left and right from peak at position 5 and we will go till index 3 on left and 7 on right.\\n\\nWhile going left and right from all the peaks none of the indexes are traveresed multiple times  which means we will at most traverse whole array again  (when all mountains share the saddle point). Hence we can say we traversed the array at most 2 times (Finding peaks + Going left and right from each peak = N+N) i.e. 2N which means the algorithm runs in O(N) time complexity.\\n\\n**Space complexity** - \\nFor storing peaks we will need O(N) space.\\nOptimization - We can go left and right as soon as we find a peak and then in the end we return the maximum length.\\n\\n```\\nclass Solution(object):\\n    def longestMountain(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        peaks = []\\n        t = len(A)\\n        if t==0:\\n            return 0\\n        \\n        for i in xrange(1,t-1):\\n            if A[i-1]<A[i]>A[i+1]:\\n                peaks.append(i)\\n               \\n        maxLen = -1\\n        for i in peaks:        \\n            curLen=1\\n            j=i\\n            while j>0 and A[j-1]<A[j]:        \\n                j-=1\\n            curLen+=(i-j)\\n            \\n            j=i\\n            while j<t-1 and A[j+1]<A[j]:\\n                j+=1\\n            curLen+=(j-i)\\n            \\n            maxLen = max(curLen, maxLen)\\n        \\n        if maxLen==-1:\\n            return 0\\n        \\n        return maxLen\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestMountain(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"        \\n        peaks = []\\n        t = len(A)\\n        if t==0:\\n            return 0\\n        \\n        for i in xrange(1,t-1):\\n            if A[i-1]<A[i]>A[i+1]:\\n                peaks.append(i)\\n               \\n        maxLen = -1\\n        for i in peaks:        \\n            curLen=1\\n            j=i\\n            while j>0 and A[j-1]<A[j]:        \\n                j-=1\\n            curLen+=(i-j)\\n            \\n            j=i\\n            while j<t-1 and A[j+1]<A[j]:\\n                j+=1\\n            curLen+=(j-i)\\n            \\n            maxLen = max(curLen, maxLen)\\n        \\n        if maxLen==-1:\\n            return 0\\n        \\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629255,
                "title": "one-pass-solution-with-o-n-time-and-o-1-space",
                "content": "# Intuition\\nso the intution is  we have to form a mountain(which means that it should be a subarray which is strictly increasing and then strictly decreasing).\\n\\n# Approach\\nwe make variables like -->\\n. res--> stores the result to be return \\n\\n. answer--> temporary answer(which is temporay mountain length).\\n\\n. wasInc--> when we are goin down the hill it helps us to know that had we gone up_hill in this contiguous subarray. if we are on the down_hill side , we will update our res only if wasInc==true.\\n\\n. wasIncAndNowDcr--> help us when we are on the up_hill side , this tells that if we are comming from the down_hill side or not...if we are coming from the down hill side then we will have to do a fresh start in search of mountain...else we can continue on the up_hill side as it is as we have not seen down hill side in the contigous subarray\\n\\n**IMPORTANT**\\nwe have to do a fresh start if we encounter a case where (arr[i]==arr[i-1]) as we have to consider the case of strictly increasing or strictly decreasing..\\nif you still have any doubts do let me khow in the comment section.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size(),res=0,answer=0;\\n        bool wasInc=false;\\n        bool wasIncAndNowDcr=false;\\n        for(int i=1;i<n;i++){\\n            if(arr[i] > arr[i-1]){\\n                if(wasIncAndNowDcr==true){\\n                    answer=0;\\n                    wasIncAndNowDcr=false;\\n                }\\n                answer++;\\n                wasInc=true;\\n            } \\n            else if(arr[i] < arr[i-1] && (wasInc || wasIncAndNowDcr)){\\n                answer++;\\n                wasIncAndNowDcr=true;\\n                res=max(res,answer+1);\\n            }\\n            else if(arr[i]==arr[i-1]){\\n                answer=0;\\n                wasIncAndNowDcr=false;\\n                wasInc=false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n=arr.size(),res=0,answer=0;\\n        bool wasInc=false;\\n        bool wasIncAndNowDcr=false;\\n        for(int i=1;i<n;i++){\\n            if(arr[i] > arr[i-1]){\\n                if(wasIncAndNowDcr==true){\\n                    answer=0;\\n                    wasIncAndNowDcr=false;\\n                }\\n                answer++;\\n                wasInc=true;\\n            } \\n            else if(arr[i] < arr[i-1] && (wasInc || wasIncAndNowDcr)){\\n                answer++;\\n                wasIncAndNowDcr=true;\\n                res=max(res,answer+1);\\n            }\\n            else if(arr[i]==arr[i-1]){\\n                answer=0;\\n                wasIncAndNowDcr=false;\\n                wasInc=false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491500,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size(),ans=0,count;\\n        vector<int>peaks;\\n        for(int i=1;i<(n-1);i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                peaks.push_back(i);\\n            }\\n        }\\n        int m = peaks.size();\\n        for(int i=0;i<m;i++){\\n            count = 1;\\n            for(int j=peaks[i];j>0;j--){\\n                if(arr[j]>arr[j-1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            for(int j=peaks[i];j<(n-1);j++){\\n                if(arr[j]>arr[j+1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(ans<count){\\n                ans = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        longest_mountain = 0\\n        cur_mountain = 0\\n        NOTHING = 0\\n        GOING_UP = 1\\n        GOING_DOWN_AFTER_PEAK = 2\\n        state = NOTHING\\n        prev = arr[0]\\n        for a in arr[1:]:\\n            if a > prev:\\n                if state in (NOTHING, GOING_DOWN_AFTER_PEAK):\\n                    state = GOING_UP\\n                    cur_mountain = 1\\n                cur_mountain += 1\\n            elif a < prev:\\n                if state == GOING_UP:\\n                    state = GOING_DOWN_AFTER_PEAK\\n                if state == GOING_DOWN_AFTER_PEAK:\\n                    cur_mountain += 1\\n                    longest_mountain = max(cur_mountain, longest_mountain)\\n            elif a == prev:\\n                state = NOTHING\\n                cur_mountain = 0\\n            prev = a\\n        return longest_mountain\\n```\\n\\n```Java []\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n                uphill = downhill = false;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size(),ans=0,count;\\n        vector<int>peaks;\\n        for(int i=1;i<(n-1);i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                peaks.push_back(i);\\n            }\\n        }\\n        int m = peaks.size();\\n        for(int i=0;i<m;i++){\\n            count = 1;\\n            for(int j=peaks[i];j>0;j--){\\n                if(arr[j]>arr[j-1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            for(int j=peaks[i];j<(n-1);j++){\\n                if(arr[j]>arr[j+1]){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(ans<count){\\n                ans = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        longest_mountain = 0\\n        cur_mountain = 0\\n        NOTHING = 0\\n        GOING_UP = 1\\n        GOING_DOWN_AFTER_PEAK = 2\\n        state = NOTHING\\n        prev = arr[0]\\n        for a in arr[1:]:\\n            if a > prev:\\n                if state in (NOTHING, GOING_DOWN_AFTER_PEAK):\\n                    state = GOING_UP\\n                    cur_mountain = 1\\n                cur_mountain += 1\\n            elif a < prev:\\n                if state == GOING_UP:\\n                    state = GOING_DOWN_AFTER_PEAK\\n                if state == GOING_DOWN_AFTER_PEAK:\\n                    cur_mountain += 1\\n                    longest_mountain = max(cur_mountain, longest_mountain)\\n            elif a == prev:\\n                state = NOTHING\\n                cur_mountain = 0\\n            prev = a\\n        return longest_mountain\\n```\n```Java []\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n                uphill = downhill = false;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284831,
                "title": "c-longest-bitonic-sequence-lis-pattern-dp-striver",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=1; ind<n; ind++) {\\n            if (arr[ind] > arr[ind-1]) {\\n                dp[ind] = 1 + dp[ind-1];\\n            }\\n        }\\n        for (int ind=n-2; ind>=0; ind--) {\\n            if (arr[ind] > arr[ind+1]) {\\n                dp2[ind] = 1 + dp2[ind+1];\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=1; ind<n; ind++) {\\n            if (arr[ind] > arr[ind-1]) {\\n                dp[ind] = 1 + dp[ind-1];\\n            }\\n        }\\n        for (int ind=n-2; ind>=0; ind--) {\\n            if (arr[ind] > arr[ind+1]) {\\n                dp2[ind] = 1 + dp2[ind+1];\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768573,
                "title": "linear-time-constant-space-c-solution-with-explanation",
                "content": "# Intuition\\nWe just need to find the pattern of mountains.\\n\\n# Approach\\nFirst, find the length of the arr and see if the size if indeed > 3. Now after checking that start with index 0 and inside this for loop, we will go on traversing i, if we have a mountain patter. Hence, if arr[i+1]>arr[i], this is the condition essential for uphill, so we start counting left and also increment i. After we have reached a point that arr[i+1] is no longer > arr[i], meaning there can be 2 conditions arr[i+1]==arr[i] or arr[i+1]<arr[i]. Second condition is basically the start of downhill, I will discuss the first condition later. As we start going downhill, just increment rigth and i too. Now if right!=0 meaning that our bike never went downhill (meaning the first condition where arr[i+1] was arr[i]), we cant consider this as our answer as we ONLY have a mountain if both left and right are >0. So if right!=0, then count the answer, which is maximum of current answer and left+right+1. Why +1? because, notice that left and right are basically lenght of 2 arms of peak, we need to count peak in our answer too (through dry run we can see that left is still 1 when we process arr[1]>arr[0]). \\nNow, dont forget to do i-- here, as this will mean that we start from the next index, but it can happen that we need to start counting from current index and we are doing i++ anyways at the end of the loop, so do i--.\\nAtlast return the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n), some would be confused as there is while inside a for, but notice that in both the loops we just operate on i, hence, even if the while loop has incremented i, for loop will start from that point in future.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int ans = 0;\\n        int n = arr.size();\\n        if(n<3)\\n            return 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i+1<n && arr[i+1]>arr[i])\\n            {\\n                int left=0, right=0;\\n                while(i+1<n and arr[i+1]>arr[i])\\n                {\\n                    left++;\\n                    i++;\\n                }\\n                while(i+1<n and arr[i+1]<arr[i])\\n                {\\n                    right++;\\n                    i++;\\n                }\\n                if(right!=0){\\n                    ans = max(ans, right+left+1);\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int ans = 0;\\n        int n = arr.size();\\n        if(n<3)\\n            return 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(i+1<n && arr[i+1]>arr[i])\\n            {\\n                int left=0, right=0;\\n                while(i+1<n and arr[i+1]>arr[i])\\n                {\\n                    left++;\\n                    i++;\\n                }\\n                while(i+1<n and arr[i+1]<arr[i])\\n                {\\n                    right++;\\n                    i++;\\n                }\\n                if(right!=0){\\n                    ans = max(ans, right+left+1);\\n                    i--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340405,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n  int ans=0;\\n    int longestMountain(vector<int>& arr) {\\n     int n=arr.size();\\n      for(int i=1;i<n-1;i++)\\n      {\\n       if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) // condition for mountain\\n            {\\n                int left = i;\\n                int right = i;\\n                while( left>0 && arr[left] > arr[left-1]) left--; // for left movement\\n               while( right<n-1 && arr[right] > arr[right+1] )right++;// for right movement\\n              ans = max(ans,(right-left+1));\\n            }\\n     }return ans;\\n    }\\n \\n};\\n```\\n\\nat then end if you are here then you really liked my solution , other solution can be :-\\nintution :- traverse loop from 1 to n-1 and check for every element if it is mountain or not ,if yes then count no. which is smaller \\nin derection of left applying condtn arr[i]>arr[i-1]\\nand vice versa for right side  , than simply add them \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int ans=0;\\n    int longestMountain(vector<int>& arr) {\\n     int n=arr.size();\\n      for(int i=1;i<n-1;i++)\\n      {\\n       if((arr[i] > arr[i-1]) && (arr[i] > arr[i+1])) // condition for mountain\\n            {\\n                int left = i;\\n                int right = i;\\n                while( left>0 && arr[left] > arr[left-1]) left--; // for left movement\\n               while( right<n-1 && arr[right] > arr[right+1] )right++;// for right movement\\n              ans = max(ans,(right-left+1));\\n            }\\n     }return ans;\\n    }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113840,
                "title": "c-commented-solution-two-pointer-approach-easy-to-understand-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKE APPROACH AND COMMENT IF YOU HAVE ANY QUESTION**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int maxlength = 0;\\n            \\n        if(a.size() == 0)  return 0;\\n            \\n            for(int i = 1; i < a.size()-1; i++)\\n            {\\n                    if(a[i] > a[i-1] && a[i] > a[i+1])\\n                            //finding out the middle element or peak in an array/mountain.\\n                    {      \\n                            int left = i-1; //initialize left pointer towards left of peak \\n                     \\n                            int right = i+1; // initialize right pointer towards right to peak.\\n                            \\n                            while(left > 0 && a[left-1] < a[left] )\\n                                    // if next left is smaller then current left move forward;\\n                                    left--;\\n                            \\n                            while(right < a.size()-1 && a[right+1] < a[right])\\n                                    // if next right is smaller then current right move forward\\n                                    right++;\\n                            \\n                            maxlength = max(maxlength, right - left+1);\\n                            //return the maximum length between two pointers right and left.\\n                    }\\n            }\\n            \\n            return maxlength;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) \\n    {\\n        int maxlength = 0;\\n            \\n        if(a.size() == 0)  return 0;\\n            \\n            for(int i = 1; i < a.size()-1; i++)\\n            {\\n                    if(a[i] > a[i-1] && a[i] > a[i+1])\\n                            //finding out the middle element or peak in an array/mountain.\\n                    {      \\n                            int left = i-1; //initialize left pointer towards left of peak \\n                     \\n                            int right = i+1; // initialize right pointer towards right to peak.\\n                            \\n                            while(left > 0 && a[left-1] < a[left] )\\n                                    // if next left is smaller then current left move forward;\\n                                    left--;\\n                            \\n                            while(right < a.size()-1 && a[right+1] < a[right])\\n                                    // if next right is smaller then current right move forward\\n                                    right++;\\n                            \\n                            maxlength = max(maxlength, right - left+1);\\n                            //return the maximum length between two pointers right and left.\\n                    }\\n            }\\n            \\n            return maxlength;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884695,
                "title": "o-n-forward-traversal-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n       int s = 0;\\n       int maxA = 0;\\n        \\n       bool foundPeak = false;\\n        \\n       for (int i = 0; i < arr.size(); i++) {\\n           int prev = i - 1 < 0 ? arr[i] : arr[i - 1];\\n           int curr = arr[i];\\n           int next = i + 1 >= arr.size() ? arr[i] : arr[i + 1];\\n           \\n           if (foundPeak) {\\n               maxA = max(maxA, i - s + 1);\\n           }\\n           \\n           if ((next > curr and prev >= curr) or (prev > curr and next >= curr)) {\\n               s = i;\\n               foundPeak = false;\\n           }\\n           \\n           if (prev < curr and next < curr) {\\n               foundPeak = true;\\n           }\\n       }\\n       return maxA;\\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n       int s = 0;\\n       int maxA = 0;\\n        \\n       bool foundPeak = false;\\n        \\n       for (int i = 0; i < arr.size(); i++) {\\n           int prev = i - 1 < 0 ? arr[i] : arr[i - 1];\\n           int curr = arr[i];\\n           int next = i + 1 >= arr.size() ? arr[i] : arr[i + 1];\\n           \\n           if (foundPeak) {\\n               maxA = max(maxA, i - s + 1);\\n           }\\n           \\n           if ((next > curr and prev >= curr) or (prev > curr and next >= curr)) {\\n               s = i;\\n               foundPeak = false;\\n           }\\n           \\n           if (prev < curr and next < curr) {\\n               foundPeak = true;\\n           }\\n       }\\n       return maxA;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837098,
                "title": "python3-one-pass-o-1-auxiliary-space",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        increasing = False\\n        increased = False\\n        mx = -math.inf\\n        curr = -math.inf\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                if increasing:\\n                    curr += 1\\n                    increased = True\\n                else:\\n                    mx = max(curr, mx)\\n                    curr = 2\\n                    increased = True\\n                    increasing = True\\n            elif arr[i] < arr[i-1]:\\n                if increasing:\\n                    increasing = False\\n                curr += 1\\n            else:\\n                if increased and not increasing:\\n                    mx = max(mx, curr)\\n                curr = -math.inf\\n                increased = False\\n                increasing = False\\n        if not increasing and increased:\\n            mx = max(mx, curr)\\n        return 0 if mx == -math.inf else mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        increasing = False\\n        increased = False\\n        mx = -math.inf\\n        curr = -math.inf\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                if increasing:\\n                    curr += 1\\n                    increased = True\\n                else:\\n                    mx = max(curr, mx)\\n                    curr = 2\\n                    increased = True\\n                    increasing = True\\n            elif arr[i] < arr[i-1]:\\n                if increasing:\\n                    increasing = False\\n                curr += 1\\n            else:\\n                if increased and not increasing:\\n                    mx = max(mx, curr)\\n                curr = -math.inf\\n                increased = False\\n                increasing = False\\n        if not increasing and increased:\\n            mx = max(mx, curr)\\n        return 0 if mx == -math.inf else mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782728,
                "title": "longest-mountain-in-array",
                "content": "class Solution {\\npublic:\\n\\n    int longestMountain(vector<int>& arr)  \\n\\t{\\n        int i = 0, u = 0, d = 0, ml = 0;\\n        int n=arr.size();\\n    while (i < n)\\n    {\\n         u=0;\\n         d=0;\\n        while (i < n - 1 && arr[i] < arr[i + 1])\\n        {\\n            i++;\\n            u++;\\n        }\\n        while (i < n - 1 && arr[i] > arr[i + 1] && u)\\n        {\\n            i++;\\n            d++;\\n        }\\n        if (u && d)\\n            ml = max(ml, u + d + 1);\\n        else\\n            i++;\\n    }\\n        return ml;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestMountain(vector<int>& arr)  \\n\\t{\\n        int i = 0, u = 0, d = 0, ml = 0;\\n        int n=arr.size();\\n    while (i < n)\\n    {\\n         u=0;\\n         d=0;\\n        while (i < n - 1 && arr[i] < arr[i + 1])\\n        {\\n            i++;\\n            u++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1718783,
                "title": "python-2-approaches-complexity",
                "content": "\\t# Two Passes - Forward and Backward\\n\\t# Time: O(n)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tupSide = [0]*len(arr)\\n\\t\\t\\tdownSide = [0]*len(arr)\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i] > arr[i-1]:\\n\\t\\t\\t\\t\\tupSide[i] = upSide[i-1]+1\\n\\t\\t\\tfor i in range(len(arr)-1)[::-1]:\\n\\t\\t\\t\\tif arr[i] > arr[i+1]:\\n\\t\\t\\t\\t\\tdownSide[i] = downSide[i+1]+1\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, j in zip(upSide, downSide):\\n\\t\\t\\t\\tif i and j:\\n\\t\\t\\t\\t\\tres = max(res, i+j+1)\\n\\t\\t\\treturn res\\n\\n\\t# One Pass - Only Forward\\n\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tup=0\\n\\t\\t\\tdown=0\\n\\t\\t\\tres=0\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif down and arr[i]>arr[i-1] or arr[i-1]==arr[i]:\\n\\t\\t\\t\\t\\tup=down=0\\n\\t\\t\\t\\tup+=arr[i]>arr[i-1]\\n\\t\\t\\t\\tdown+=arr[i]<arr[i-1]\\n\\t\\t\\t\\tif up and down:\\n\\t\\t\\t\\t\\tres=max(res, up+down+1)\\n\\t\\t\\treturn res\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Two Passes - Forward and Backward\\n\\t# Time: O(n)\\n\\t# Space: O(n)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tupSide = [0]*len(arr)\\n\\t\\t\\tdownSide = [0]*len(arr)\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif arr[i] > arr[i-1]:\\n\\t\\t\\t\\t\\tupSide[i] = upSide[i-1]+1\\n\\t\\t\\tfor i in range(len(arr)-1)[::-1]:\\n\\t\\t\\t\\tif arr[i] > arr[i+1]:\\n\\t\\t\\t\\t\\tdownSide[i] = downSide[i+1]+1\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, j in zip(upSide, downSide):\\n\\t\\t\\t\\tif i and j:\\n\\t\\t\\t\\t\\tres = max(res, i+j+1)\\n\\t\\t\\treturn res\\n\\n\\t# One Pass - Only Forward\\n\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef longestMountain(self, arr: List[int]) -> int:\\n\\t\\t\\tup=0\\n\\t\\t\\tdown=0\\n\\t\\t\\tres=0\\n\\t\\t\\tfor i in range(1, len(arr)):\\n\\t\\t\\t\\tif down and arr[i]>arr[i-1] or arr[i-1]==arr[i]:\\n\\t\\t\\t\\t\\tup=down=0\\n\\t\\t\\t\\tup+=arr[i]>arr[i-1]\\n\\t\\t\\t\\tdown+=arr[i]<arr[i-1]\\n\\t\\t\\t\\tif up and down:\\n\\t\\t\\t\\t\\tres=max(res, up+down+1)\\n\\t\\t\\treturn res\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1697387,
                "title": "c-dynamic-programming-faster-than-96-online-submission",
                "content": "```\\n int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        int ans=0;\\n        vector<int>lis(n,1);\\n        vector<int>lds(n,1);\\n        //for lis\\n        for(int i=1;i<n;i++){\\n            if(arr[i]>arr[i-1]){\\n                lis[i]=lis[i-1]+1;\\n            }\\n        }\\n        //for lds\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                lds[i]=lds[i+1]+1;\\n            }\\n        }\\n        // cout<<\"LIS \"<<endl;\\n        // for(auto it:lis){\\n        //     cout<<it<<\" \";\\n        // }\\n        //  cout<<\"LDS \"<<endl;\\n        // for(auto it:lds){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(int i=1;i<n-1;i++){\\n            if(lis[i]==1||lds[i]==1){\\n                continue;\\n            }\\n            int temp=abs(lis[i]+lds[i]-1);\\n            ans=max(ans,temp);\\n        }\\n        return ans==1?0:ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1){\\n            return 0;\\n        }\\n        int ans=0;\\n        vector<int>lis(n,1);\\n        vector<int>lds(n,1);\\n        //for lis\\n        for(int i=1;i<n;i++){\\n            if(arr[i]>arr[i-1]){\\n                lis[i]=lis[i-1]+1;\\n            }\\n        }\\n        //for lds\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                lds[i]=lds[i+1]+1;\\n            }\\n        }\\n        // cout<<\"LIS \"<<endl;\\n        // for(auto it:lis){\\n        //     cout<<it<<\" \";\\n        // }\\n        //  cout<<\"LDS \"<<endl;\\n        // for(auto it:lds){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(int i=1;i<n-1;i++){\\n            if(lis[i]==1||lds[i]==1){\\n                continue;\\n            }\\n            int temp=abs(lis[i]+lds[i]-1);\\n            ans=max(ans,temp);\\n        }\\n        return ans==1?0:ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1691796,
                "title": "c-simple-and-short-o-n-time-complexity",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        int ans = 0, upLength = 0, downLength = 0;\\n\\t\\t\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if(arr[i - 1] == arr[i] || downLength && arr[i - 1] < arr[i])\\n                upLength = downLength = 0;\\n            \\n            upLength += arr[i - 1] < arr[i];\\n            downLength += arr[i - 1] > arr[i];\\n\\n            if(upLength && downLength)\\n                ans = max(ans, upLength + downLength + 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        int ans = 0, upLength = 0, downLength = 0;\\n\\t\\t\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if(arr[i - 1] == arr[i] || downLength && arr[i - 1] < arr[i])\\n                upLength = downLength = 0;\\n            \\n            upLength += arr[i - 1] < arr[i];\\n            downLength += arr[i - 1] > arr[i];\\n\\n            if(upLength && downLength)\\n                ans = max(ans, upLength + downLength + 1);\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1668119,
                "title": "c-o-n-o-1-100-fast-easy-soln",
                "content": "```\\n int longestMountain(vector<int>& a) {\\n        int i,ans=0,c=0,n=a.size();\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==a[i-1])  //If nos are same then we skip it\\n                c=0;            \\n            else if(a[i]>a[i-1]) //if next>prev we increase the count\\n                c++;\\n            //Else we first calculate count of next<prev and update the final ans\\n            else if(c>0)           \\n            {\\n                    while(i<n and a[i]<a[i-1])\\n                    {\\n                        c++; i++;\\n                    }\\n                    ans = max(ans,c+1);\\n                    c=0 ;i--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int longestMountain(vector<int>& a) {\\n        int i,ans=0,c=0,n=a.size();\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i]==a[i-1])  //If nos are same then we skip it\\n                c=0;            \\n            else if(a[i]>a[i-1]) //if next>prev we increase the count\\n                c++;\\n            //Else we first calculate count of next<prev and update the final ans\\n            else if(c>0)           \\n            {\\n                    while(i<n and a[i]<a[i-1])\\n                    {\\n                        c++; i++;\\n                    }\\n                    ans = max(ans,c+1);\\n                    c=0 ;i--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1468928,
                "title": "java-faster-than-100-do-checkout-for-detailed-explanation",
                "content": "**Do vote up if you like it :)**\\nTC : O(N), SC : O(1)\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int i = 0, start = -1, end = -1;\\n        boolean peak = false, valley = false;\\n        int largestMountain = 0;\\n        \\n        while(i < arr.length - 1){ \\n            //You expect a continous increase and then a continous decrease\\n            if(arr[i] < arr[i + 1]){                \\n                start = i;\\n                peak = true;\\n                \\n                //Continous increase\\n                while(i < arr.length - 1 && arr[i] < arr[i + 1]){\\n                    i++;\\n                }\\n                \\n                //Continous decrease\\n                while(i < arr.length - 1 && arr[i] > arr[i + 1]){\\n                    valley = true;\\n                    i++;\\n                    end = i;\\n                }\\n                \\n                //If there is continous increase and continous decrease then only it\\'s a mountain\\n                if(peak && valley) largestMountain = Math.max(largestMountain, end - start + 1);\\n                //NOTE: If all the elements would be continously increasing then also it\\'s not a mountain\\n                 \\n                peak = false; valley = false;\\n            }\\n            \\n            //Not a mountain if :\\n            //elements are not strictly increasing(parallel surface)\\n            //or decreasing continously\\n            else i++;\\n        }\\n        return largestMountain;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int i = 0, start = -1, end = -1;\\n        boolean peak = false, valley = false;\\n        int largestMountain = 0;\\n        \\n        while(i < arr.length - 1){ \\n            //You expect a continous increase and then a continous decrease\\n            if(arr[i] < arr[i + 1]){                \\n                start = i;\\n                peak = true;\\n                \\n                //Continous increase\\n                while(i < arr.length - 1 && arr[i] < arr[i + 1]){\\n                    i++;\\n                }\\n                \\n                //Continous decrease\\n                while(i < arr.length - 1 && arr[i] > arr[i + 1]){\\n                    valley = true;\\n                    i++;\\n                    end = i;\\n                }\\n                \\n                //If there is continous increase and continous decrease then only it\\'s a mountain\\n                if(peak && valley) largestMountain = Math.max(largestMountain, end - start + 1);\\n                //NOTE: If all the elements would be continously increasing then also it\\'s not a mountain\\n                 \\n                peak = false; valley = false;\\n            }\\n            \\n            //Not a mountain if :\\n            //elements are not strictly increasing(parallel surface)\\n            //or decreasing continously\\n            else i++;\\n        }\\n        return largestMountain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401310,
                "title": "java-array-single-pass-t-c-o-n-s-c-o-1",
                "content": "\\n    public int longestMountain(int[] arr) {\\n\\n\\t\\tint len = arr.length, up = 0, down = 0, omax = 0;\\n\\t\\tboolean flag = false;\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (arr[i] > arr[i - 1]) {\\n\\t\\t\\t\\tif (flag) {\\n\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\tup = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tup++;\\n                down = 0;\\n\\t\\t\\t} else if (arr[i] < arr[i - 1]) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\tif (up == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdown++;\\n\\t\\t\\t\\tif (up + down + 1 > omax)\\n\\t\\t\\t\\t\\tomax = up + down + 1;\\n\\t\\t\\t} else {\\n                up = 0;\\n                down = 0;\\n            }\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    public int longestMountain(int[] arr) {\\n\\n\\t\\tint len = arr.length, up = 0, down = 0, omax = 0;\\n\\t\\tboolean flag = false;\\n\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (arr[i] > arr[i - 1]) {\\n\\t\\t\\t\\tif (flag) {\\n\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\tup = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tup++;\\n                down = 0;\\n\\t\\t\\t} else if (arr[i] < arr[i - 1]) {\\n\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\tif (up == 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdown++;\\n\\t\\t\\t\\tif (up + down + 1 > omax)\\n\\t\\t\\t\\t\\tomax = up + down + 1;\\n\\t\\t\\t} else {\\n                up = 0;\\n                down = 0;\\n            }\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1271001,
                "title": "easy-to-understand-with-explanation-c-0-n-find-peak-and-stretch-left-and-right",
                "content": "You have to find the Peak ie (arr[i-1] < arr[i] && arr[i] > arr[i+1]) of the mountain , then just traverse to left side and right side to find the length. \\nCompare with maxlen  for every peak.\\n0(n+n) ~ 0(n)\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int maxLen = 0;\\n        \\n        if(n<3){\\n            return maxLen;\\n        }\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            if(arr[i-1] < arr[i] && arr[i] > arr[i+1]) {\\n                \\n                int lidx = i,ridx=i;\\n                int len = 1;\\n                \\n                while(lidx > 0 && arr[lidx] > arr[lidx-1]){\\n                    len++; lidx--;\\n                }\\n                while(ridx+1 < n && arr[ridx] > arr[ridx+1]){\\n                    len++; ridx++;\\n                }\\n                maxLen = max(maxLen,len);\\n            } \\n        }\\n        return maxLen;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int maxLen = 0;\\n        \\n        if(n<3){\\n            return maxLen;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1248472,
                "title": "easy-c-solution-o-n",
                "content": "int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int mountain_length =0;\\n        \\n        if(n<3) return 0;     // base case\\n        \\n        for(int i=1;i<n-1; ){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){    //To find peak of mountain\\n                int count = 1;\\n                int j = i;\\n                while(j>=1 && arr[j]>arr[j-1]){       // calculating backword length\\n                    j--;\\n                    count++;\\n                }\\n                while(i<n-1 && arr[i]>arr[i+1]){      // calculating forword length\\n                    i++;\\n                    count++;\\n                }\\n                 mountain_length = max(mountain_length,count);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return mountain_length;\\n    }\\n};",
                "solutionTags": [],
                "code": "int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int mountain_length =0;\\n        \\n        if(n<3) return 0;     // base case\\n        \\n        for(int i=1;i<n-1; ){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){    //To find peak of mountain\\n                int count = 1;\\n                int j = i;\\n                while(j>=1 && arr[j]>arr[j-1]){       // calculating backword length\\n                    j--;\\n                    count++;\\n                }\\n                while(i<n-1 && arr[i]>arr[i+1]){      // calculating forword length\\n                    i++;\\n                    count++;\\n                }\\n                 mountain_length = max(mountain_length,count);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return mountain_length;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1236452,
                "title": "c-1-pass-o-1-space-esay-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max_cnt = 0;\\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){\\n                //go backward\\n                int j = i-1, cnt = 3;\\n                while(j-1 >= 0 and arr[j-1] < arr[j]){\\n                    cnt++;\\n                    j--;\\n                }\\n                //go forward\\n                int k = i+1;\\n                while( k + 1 < arr.size() and arr[k+1] < arr[k]){\\n                    cnt++;\\n                    k++;\\n                }\\n                max_cnt = max(max_cnt, cnt);\\n            }\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max_cnt = 0;\\n        for(int i = 1; i < arr.size() - 1; i++){\\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){\\n                //go backward\\n                int j = i-1, cnt = 3;\\n                while(j-1 >= 0 and arr[j-1] < arr[j]){\\n                    cnt++;\\n                    j--;\\n                }\\n                //go forward\\n                int k = i+1;\\n                while( k + 1 < arr.size() and arr[k+1] < arr[k]){\\n                    cnt++;\\n                    k++;\\n                }\\n                max_cnt = max(max_cnt, cnt);\\n            }\\n        }\\n        return max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027675,
                "title": "c-simple-dp-apporach-with-runtime-96-40",
                "content": "**Bitonic Sequence Approach**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& elements) {\\n        int size=elements.size();\\n        vector<int> lis(size);\\n        lis[0]=1;\\n        \\n        for(int i=1;i<size;i++){\\n            int maxyet=0;\\n            if(elements[i-1]<elements[i]){\\n                maxyet=max(maxyet,lis[i-1]);\\n            }\\n            lis[i]=maxyet+1;\\n        }\\n        \\n        vector<int> ldp(size);\\n        ldp[size-1]=1;\\n        \\n        for(int i=size-2;i>=0;i--){\\n            if(elements[i+1]<elements[i]){\\n                ldp[i]=max(ldp[i],ldp[i+1]);\\n            }\\n            ldp[i]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<size;i++){\\n            if(lis[i]>1 && ldp[i]>1){\\n                ans=max(ans,(lis[i]+ldp[i]-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& elements) {\\n        int size=elements.size();\\n        vector<int> lis(size);\\n        lis[0]=1;\\n        \\n        for(int i=1;i<size;i++){\\n            int maxyet=0;\\n            if(elements[i-1]<elements[i]){\\n                maxyet=max(maxyet,lis[i-1]);\\n            }\\n            lis[i]=maxyet+1;\\n        }\\n        \\n        vector<int> ldp(size);\\n        ldp[size-1]=1;\\n        \\n        for(int i=size-2;i>=0;i--){\\n            if(elements[i+1]<elements[i]){\\n                ldp[i]=max(ldp[i],ldp[i+1]);\\n            }\\n            ldp[i]+=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<size;i++){\\n            if(lis[i]>1 && ldp[i]>1){\\n                ans=max(ans,(lis[i]+ldp[i]-1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938288,
                "title": "c-single-loop-o-n-time-o-1-space-explained-code-and-cases-in-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        // base case - mountain must be greater than 3, so there is no mountain\\n        if(A.size() < 3)\\n            return 0;\\n        \\n        int longestMountain = 1;        // current largest mountain in our list\\n        int previousNumber = A[0];      // current number we are looking at\\n        int currentMountain = 1;        // current size of our mountain \\n        bool isAscending = true;        // determine if we are ascending or descending in the mountain\\n        \\n        // There are potentially 4 cases that can occur within this problem\\n            // 1. We are ascending and we keep ascending - increment mountain and continue\\n            // 2. We are ascending, but the current number is smaller than previous - now we descend\\n                // 2a. Ascending, smaller number, but the current mountain is too small or the same\\n                // height, we do not swap to descending but instead reset the height\\n            // 3. We are descending and we keep descending - increment mountain and continue\\n            // 4. We are descending, but the current number is larger than previous - reset\\n            // to set our loop to the current (in case the tailend of this mountain is the start \\n            // to a bigger mountain i.e. [{4, 6, {3}, 4, 5, 7, 5, 3, 2}])\\n        \\n        for(int x = 1; x < A.size(); ++x)\\n        {\\n            if(isAscending)\\n            {\\n                // if the number is larger, then keep ascending\\n                if(A[x] > previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is smaller, and the current mountain is large enough\\n                    // to start a descent, and the previous number is not the same number,\\n                    // i.e. [2, 2, 2], then begin our descent (!ascending)\\n                    if(currentMountain >= 2 && A[x] != previousNumber)\\n                    {\\n                        isAscending = false;\\n                        ++currentMountain;\\n                        longestMountain = max(currentMountain, longestMountain);\\n                    }\\n                    else\\n                    {\\n                        // either the mountain is too small to descend, or we hit the same\\n                        // height so we never really ascended, so reset to height of 1\\n                        currentMountain = 1;\\n                    }\\n                }\\n                \\n                // move our previous pointer forward \\n                previousNumber = A[x];\\n            }\\n            else\\n            {\\n                // if the number is smaller, then keep descending\\n                if(A[x] < previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is larger, then we have reached the end of the descent\\n                    // and have finished this mountain, so reset to ascend, set the current height\\n                    // to 1 and move our current loop iterator back in case the end of this mountain\\n                    // is the start to a larger mountain\\n                    isAscending = true;\\n                    currentMountain = 1;\\n                    x--;\\n                }\\n                \\n                // set our max longest mountain each descent in case it grows to our current max\\n                longestMountain = max(currentMountain, longestMountain);\\n                \\n                // move our previous pointer forward\\n                previousNumber = A[x];\\n            }\\n        }\\n        \\n        // if our longest mountain is larger than or equal to 3 (valid mountain)\\n        // then return it\\'s height, else simply return 0 (no valid mountain)\\n        return longestMountain >= 3 ? longestMountain : 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        // base case - mountain must be greater than 3, so there is no mountain\\n        if(A.size() < 3)\\n            return 0;\\n        \\n        int longestMountain = 1;        // current largest mountain in our list\\n        int previousNumber = A[0];      // current number we are looking at\\n        int currentMountain = 1;        // current size of our mountain \\n        bool isAscending = true;        // determine if we are ascending or descending in the mountain\\n        \\n        // There are potentially 4 cases that can occur within this problem\\n            // 1. We are ascending and we keep ascending - increment mountain and continue\\n            // 2. We are ascending, but the current number is smaller than previous - now we descend\\n                // 2a. Ascending, smaller number, but the current mountain is too small or the same\\n                // height, we do not swap to descending but instead reset the height\\n            // 3. We are descending and we keep descending - increment mountain and continue\\n            // 4. We are descending, but the current number is larger than previous - reset\\n            // to set our loop to the current (in case the tailend of this mountain is the start \\n            // to a bigger mountain i.e. [{4, 6, {3}, 4, 5, 7, 5, 3, 2}])\\n        \\n        for(int x = 1; x < A.size(); ++x)\\n        {\\n            if(isAscending)\\n            {\\n                // if the number is larger, then keep ascending\\n                if(A[x] > previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is smaller, and the current mountain is large enough\\n                    // to start a descent, and the previous number is not the same number,\\n                    // i.e. [2, 2, 2], then begin our descent (!ascending)\\n                    if(currentMountain >= 2 && A[x] != previousNumber)\\n                    {\\n                        isAscending = false;\\n                        ++currentMountain;\\n                        longestMountain = max(currentMountain, longestMountain);\\n                    }\\n                    else\\n                    {\\n                        // either the mountain is too small to descend, or we hit the same\\n                        // height so we never really ascended, so reset to height of 1\\n                        currentMountain = 1;\\n                    }\\n                }\\n                \\n                // move our previous pointer forward \\n                previousNumber = A[x];\\n            }\\n            else\\n            {\\n                // if the number is smaller, then keep descending\\n                if(A[x] < previousNumber)\\n                {\\n                    ++currentMountain;\\n                }\\n                else\\n                {\\n                    // if the number is larger, then we have reached the end of the descent\\n                    // and have finished this mountain, so reset to ascend, set the current height\\n                    // to 1 and move our current loop iterator back in case the end of this mountain\\n                    // is the start to a larger mountain\\n                    isAscending = true;\\n                    currentMountain = 1;\\n                    x--;\\n                }\\n                \\n                // set our max longest mountain each descent in case it grows to our current max\\n                longestMountain = max(currentMountain, longestMountain);\\n                \\n                // move our previous pointer forward\\n                previousNumber = A[x];\\n            }\\n        }\\n        \\n        // if our longest mountain is larger than or equal to 3 (valid mountain)\\n        // then return it\\'s height, else simply return 0 (no valid mountain)\\n        return longestMountain >= 3 ? longestMountain : 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937703,
                "title": "python-remember-our-state-o-1",
                "content": "We need to remember what state we are in. It\\'s either plato, ascend or descend.\\n```\\ndef longestMountain(self, A: List[int]) -> int:\\n\\tif len(A) < 3: return 0\\n\\tmaxrange = 0\\n\\tleft = 0\\n\\tmode = \\'plato\\'\\n\\n\\tfor i in range(1, len(A)):\\n\\t\\tif A[i] == A[i-1]: mode = \\'plato\\'\\n\\t\\telif A[i] > A[i-1]:\\n\\t\\t\\tif mode in [\\'plato\\', \\'descend\\']:\\n\\t\\t\\t\\tleft = i - 1\\n\\t\\t\\t\\tmode = \\'ascend\\'\\n\\t\\telif mode in [\\'ascend\\', \\'descend\\']:\\n\\t\\t\\tmaxrange = max(maxrange, i + 1 - left)\\n\\t\\t\\tmode = \\'descend\\'\\n\\n\\treturn maxrange\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef longestMountain(self, A: List[int]) -> int:\\n\\tif len(A) < 3: return 0\\n\\tmaxrange = 0\\n\\tleft = 0\\n\\tmode = \\'plato\\'\\n\\n\\tfor i in range(1, len(A)):\\n\\t\\tif A[i] == A[i-1]: mode = \\'plato\\'\\n\\t\\telif A[i] > A[i-1]:\\n\\t\\t\\tif mode in [\\'plato\\', \\'descend\\']:\\n\\t\\t\\t\\tleft = i - 1\\n\\t\\t\\t\\tmode = \\'ascend\\'\\n\\t\\telif mode in [\\'ascend\\', \\'descend\\']:\\n\\t\\t\\tmaxrange = max(maxrange, i + 1 - left)\\n\\t\\t\\tmode = \\'descend\\'\\n\\n\\treturn maxrange\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 937660,
                "title": "c-two-solutions-o-n-time-o-n-o-1-space",
                "content": "**Approach 1**\\nThe idea is simple, we can maintain an `left[]` and `right[]` array to keep track of `How many elements are smaller than left[i] and right[i]`, going from left and right respectively.\\n\\nThen, we can simple iterate over the array and keep track of `possible peak` of mountain i.e we can check `from index=1 to index = arr.size()-2` which of the elements are `greater than both left and right elements from it`. \\n\\n**Solution 1**\\nTime complexity : O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){ //mountain cannot exist\\n            return 0;\\n        }\\n        \\n        vector<int> left(A.size(), 0);\\n        vector<int> right(A.size(), 0);\\n        //Build Left \\n        for(int i=1;i<A.size();i++){\\n            if(A[i] > A[i-1]){ \\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        //Build Right\\n        for(int i=A.size()-2;i>=0;i--){\\n            if(A[i] > A[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        \\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Keep track of the highest peak\\n                mountain = max(mountain, left[i]+right[i]+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\\n\\n**Approach 2 (Follow up)**\\nHere, we can observe from Solution 1 that we should only keep track of `possible peak` that occurs while traversing the array. This can be done by `expanding the size of mountain from a peak`. So, we can keep track of `peak` while traversing the array then we can expand on the peak and store the maximum of all those sizes.\\n\\n**Solution 2**\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){\\n            return 0;\\n        }\\n\\t\\t\\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Possible Peak\\n                \\n\\t\\t\\t\\t//Expanding on left\\n\\t\\t\\t\\tint j = i-1;\\n                int left = 0;\\n                int prev = A[i];\\n                while(j >= 0 && A[j] < prev){\\n                    prev = A[j];\\n                    j--;\\n                    left++;\\n                }\\n\\t\\t\\t\\t\\n                //Expanding on right\\n\\t\\t\\t\\tj = i+1;\\n                prev = A[i];\\n                int right = 0;\\n                while(j < A.size() && A[j] <  prev){\\n                    prev = A[j];\\n                    j++;\\n                    right++;\\n                }\\n                \\n\\t\\t\\t\\t//Store maximum in \\'mountain\\'\\n                mountain = max(mountain, left+right+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){ //mountain cannot exist\\n            return 0;\\n        }\\n        \\n        vector<int> left(A.size(), 0);\\n        vector<int> right(A.size(), 0);\\n        //Build Left \\n        for(int i=1;i<A.size();i++){\\n            if(A[i] > A[i-1]){ \\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        //Build Right\\n        for(int i=A.size()-2;i>=0;i--){\\n            if(A[i] > A[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        \\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Keep track of the highest peak\\n                mountain = max(mountain, left[i]+right[i]+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        \\n        if(A.size() < 3){\\n            return 0;\\n        }\\n\\t\\t\\n        int mountain = 0;\\n        \\n        for(int i=1;i<A.size()-1;i++){\\n            if(A[i] > A[i-1] && A[i] > A[i+1]){ //Possible Peak\\n                \\n\\t\\t\\t\\t//Expanding on left\\n\\t\\t\\t\\tint j = i-1;\\n                int left = 0;\\n                int prev = A[i];\\n                while(j >= 0 && A[j] < prev){\\n                    prev = A[j];\\n                    j--;\\n                    left++;\\n                }\\n\\t\\t\\t\\t\\n                //Expanding on right\\n\\t\\t\\t\\tj = i+1;\\n                prev = A[i];\\n                int right = 0;\\n                while(j < A.size() && A[j] <  prev){\\n                    prev = A[j];\\n                    j++;\\n                    right++;\\n                }\\n                \\n\\t\\t\\t\\t//Store maximum in \\'mountain\\'\\n                mountain = max(mountain, left+right+1);\\n            }\\n        }\\n        \\n        return mountain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937620,
                "title": "java-one-pass-o-n-easy-to-understand",
                "content": "```\\npublic int longestMountain(int[] A) {\\n\\tint result = 0, currentLength = 0;\\n\\tBoolean isIncreasing = null;\\n\\tfor(int i=1;i<A.length;i++)\\n\\t\\tif(A[i-1] < A[i]) {\\n\\t\\t\\tif(isIncreasing == null || !isIncreasing) {\\n\\t\\t\\t\\tisIncreasing = true;\\n\\t\\t\\t\\tcurrentLength = 1;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentLength++;\\n\\t\\t} else if(A[i-1] > A[i] && isIncreasing != null) {\\n\\t\\t\\tisIncreasing = false;\\n\\t\\t\\tcurrentLength++;\\n\\t\\t\\tresult = Math.max(result, currentLength);\\n\\t\\t} else isIncreasing = null;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n\\tint result = 0, currentLength = 0;\\n\\tBoolean isIncreasing = null;\\n\\tfor(int i=1;i<A.length;i++)\\n\\t\\tif(A[i-1] < A[i]) {\\n\\t\\t\\tif(isIncreasing == null || !isIncreasing) {\\n\\t\\t\\t\\tisIncreasing = true;\\n\\t\\t\\t\\tcurrentLength = 1;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentLength++;\\n\\t\\t} else if(A[i-1] > A[i] && isIncreasing != null) {\\n\\t\\t\\tisIncreasing = false;\\n\\t\\t\\tcurrentLength++;\\n\\t\\t\\tresult = Math.max(result, currentLength);\\n\\t\\t} else isIncreasing = null;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791031,
                "title": "845-longest-mountain-in-array",
                "content": "This question can be done by finding a peak at every point where there is possibility of a peak.\\nPossibility means that previous element is smaller than current element and next is also smaller than current element.At that point we will check the length of the left part and right part and return left+right+1.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\n//  We\\'ll check the left length and the right length and return 1+left+right which will give the length of the mountain.   \\n    int getPeaklength(vector<int> v,int i)\\n    {\\n        int j=i;\\n        int left_length=0,right_length=0;\\n        while(j-1>=0)\\n        {\\n            if(v[j-1]<v[j])\\n                ++left_length;\\n            else\\n                break;\\n            --j;\\n        }\\n        if(left_length==0)\\n            return 0;\\n        while(i+1<v.size())\\n        {\\n            if(v[i+1]<v[i])\\n                ++right_length; \\n            else\\n                break;\\n            ++i;\\n        }\\n        if(right_length==0)\\n            return 0;\\n        return left_length+right_length+1;\\n    }\\n    \\n    int longestMountain(vector<int>& A) {\\n        if(A.size()<3)\\n            return 0;\\n        int max_len=0;\\n        for(int i=1;i<A.size()-1;++i)\\n        {\\n//          If the left part is smaller and right is also smaller then there is a probability  for a peak.We\\'ll check it \\n            if(A[i+1]<A[i] && A[i-1]<A[i])\\n            {\\n                int cur_length=getPeaklength(A,i);\\n                max_len=max(cur_length,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n//  We\\'ll check the left length and the right length and return 1+left+right which will give the length of the mountain.   \\n    int getPeaklength(vector<int> v,int i)\\n    {\\n        int j=i;\\n        int left_length=0,right_length=0;\\n        while(j-1>=0)\\n        {\\n            if(v[j-1]<v[j])\\n                ++left_length;\\n            else\\n                break;\\n            --j;\\n        }\\n        if(left_length==0)\\n            return 0;\\n        while(i+1<v.size())\\n        {\\n            if(v[i+1]<v[i])\\n                ++right_length; \\n            else\\n                break;\\n            ++i;\\n        }\\n        if(right_length==0)\\n            return 0;\\n        return left_length+right_length+1;\\n    }\\n    \\n    int longestMountain(vector<int>& A) {\\n        if(A.size()<3)\\n            return 0;\\n        int max_len=0;\\n        for(int i=1;i<A.size()-1;++i)\\n        {\\n//          If the left part is smaller and right is also smaller then there is a probability  for a peak.We\\'ll check it \\n            if(A[i+1]<A[i] && A[i-1]<A[i])\\n            {\\n                int cur_length=getPeaklength(A,i);\\n                max_len=max(cur_length,max_len);\\n            }\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568903,
                "title": "simple-c-solution-with-explanation",
                "content": "1. A point can be a mountain peak, if its left value is lower and right is higher.\\n2. When such point is encountered, we traverse in both direction and find out the length.\\n3. once traverse is done, we update the max_len of mountain.\\n4. Now we can directly jump to right index to check again the peak condition.\\n\\nEach point will be traversed max 2 times. so Time = O(n)\\n\\n```\\n    int longestMountain(vector<int>& arr) {        \\n        int len = arr.size();        \\n        if(len < 3)\\n        {\\n            return 0;\\n        }        \\n        int max_len = 0;\\n        int i = 1;\\n        while(i < len-1)\\n        {\\n            // this is a mountain peak\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1])\\n            {\\n                int low = i-1, high = i+1;                \\n                while(low >= 0 && arr[low] < arr[low+1])\\n                {\\n                    low--;\\n                }                            \\n                while(high < len && arr[high] < arr[high-1])\\n                {\\n                    high++;\\n                }                            \\n                max_len = max(max_len, high-low-1);\\n                i = high;\\n            }\\n            else\\n            {\\n                i++;\\n            }                        \\n        }        \\n        return max_len;        \\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int longestMountain(vector<int>& arr) {        \\n        int len = arr.size();        \\n        if(len < 3)\\n        {\\n            return 0;\\n        }        \\n        int max_len = 0;\\n        int i = 1;\\n        while(i < len-1)\\n        {\\n            // this is a mountain peak\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1])\\n            {\\n                int low = i-1, high = i+1;                \\n                while(low >= 0 && arr[low] < arr[low+1])\\n                {\\n                    low--;\\n                }                            \\n                while(high < len && arr[high] < arr[high-1])\\n                {\\n                    high++;\\n                }                            \\n                max_len = max(max_len, high-low-1);\\n                i = high;\\n            }\\n            else\\n            {\\n                i++;\\n            }                        \\n        }        \\n        return max_len;        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540621,
                "title": "java-dp-solution-o-n-time-and-o-n-memory",
                "content": "1. An int array leftIncr: leftIncr[i] denotes length of consecutive increasing subarray and A[i] is not included.\\n2. An int array rightDecr: rightDecr[i] denotes the length of consecutive decreasing subarray starts from A[i + 1];\\n3. The longest mountain array = max of ```leftIncr[i] + rightDecr[i] + 1```. \\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int[] leftIncr = new int[A.length];\\n        int[] rightDecr = new int[A.length];\\n        \\n        for(int i = 1; i < A.length; ++i) {\\n            if(A[i] > A[i - 1]) {\\n                leftIncr[i] = leftIncr[i - 1] + 1;\\n            }\\n            if(A[A.length - 1 - i] > A[A.length - i]) {\\n                rightDecr[A.length - 1 - i] = rightDecr[A.length - i] + 1;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i < A.length - 1; ++i) {\\n            if(leftIncr[i] > 0 && rightDecr[i] > 0) {\\n                max = Math.max(max, leftIncr[i] + rightDecr[i] + 1);\\n            }\\n        }\\n        \\n        return max;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```leftIncr[i] + rightDecr[i] + 1```\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int[] leftIncr = new int[A.length];\\n        int[] rightDecr = new int[A.length];\\n        \\n        for(int i = 1; i < A.length; ++i) {\\n            if(A[i] > A[i - 1]) {\\n                leftIncr[i] = leftIncr[i - 1] + 1;\\n            }\\n            if(A[A.length - 1 - i] > A[A.length - i]) {\\n                rightDecr[A.length - 1 - i] = rightDecr[A.length - i] + 1;\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 1; i < A.length - 1; ++i) {\\n            if(leftIncr[i] > 0 && rightDecr[i] > 0) {\\n                max = Math.max(max, leftIncr[i] + rightDecr[i] + 1);\\n            }\\n        }\\n        \\n        return max;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484070,
                "title": "the-good-the-bad-and-the-ugly",
                "content": "All solutions use only one loop. I\\'ve pushed a value in the vector, but I pop it back at the end. This could be avoided with additional checks so I did it just for lulz.\\n\\n**Solution 1** (two auxillary variables)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(A.back());\\n        int v=0, m=0;\\n        \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if ((A[i-1] <= A[i] && A[i] >= A[i+1]) && !(A[i-1] < A[i] && A[i] > A[i+1]))\\n                v=i+1;\\n                \\n            if (A[i-1] >= A[i]  && A[i] <= A[i+1])\\n            {\\n                if (i>v && A[v+1] > A[v])\\n                    m = max(i-v+1, m);\\n                v = i;\\n            }\\n        }     \\n\\t\\tA.pop_back();\\n        return m;\\n       }\\n};\\n```\\n**Solution 2**(three auxillary variables)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(10001);\\n\\t\\tint p = 0, v = 0, m = 0;\\n\\t\\t\\n        for (int i=1; i<A.size()-1; ++i)\\n        {\\n            p = A[i-1] < A[i] && A[i] > A[i+1] ? i : p;\\n            if (A[i-1] >= A[i] && A[i] <= A[i+1])\\n            {\\n                if (v < p)\\n                    m = max(i - v + 1, m);\\n                v = i;\\n            }\\n        }\\n\\t\\tA.pop_back();\\n        return m;\\n\\t }\\n};\\n```\\n**Solution 3** (two auxillary variables + flag)\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        int p = 0, m = 0;\\n        bool asc = true;\\n                \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if (i == p+1 && A[i] <= A[i-1])\\n                p++;\\n            else if (asc) \\n            {\\n                if (A[i] == A[i-1]) \\n                    p=i;\\n                else if (A[i] < A[i-1])                  \\n                    asc = false; \\n            }\\n            else if (A[i] >= A[i-1])\\n            {\\n                asc = true;\\n                m = max(i-p, m);\\n                p = (A[i] >  A[i-1]) ? i-1: i;\\n            }\\n        }\\n            \\n        if (!asc) m = max(int(A.size())-p, m);     \\n        return m;\\n\\t }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(A.back());\\n        int v=0, m=0;\\n        \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if ((A[i-1] <= A[i] && A[i] >= A[i+1]) && !(A[i-1] < A[i] && A[i] > A[i+1]))\\n                v=i+1;\\n                \\n            if (A[i-1] >= A[i]  && A[i] <= A[i+1])\\n            {\\n                if (i>v && A[v+1] > A[v])\\n                    m = max(i-v+1, m);\\n                v = i;\\n            }\\n        }     \\n\\t\\tA.pop_back();\\n        return m;\\n       }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        if (A.size() < 3)\\n            return 0;        \\n        A.push_back(10001);\\n\\t\\tint p = 0, v = 0, m = 0;\\n\\t\\t\\n        for (int i=1; i<A.size()-1; ++i)\\n        {\\n            p = A[i-1] < A[i] && A[i] > A[i+1] ? i : p;\\n            if (A[i-1] >= A[i] && A[i] <= A[i+1])\\n            {\\n                if (v < p)\\n                    m = max(i - v + 1, m);\\n                v = i;\\n            }\\n        }\\n\\t\\tA.pop_back();\\n        return m;\\n\\t }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) \\n    {\\n        int p = 0, m = 0;\\n        bool asc = true;\\n                \\n        for (int i=1; i<A.size(); ++i)\\n        {\\n            if (i == p+1 && A[i] <= A[i-1])\\n                p++;\\n            else if (asc) \\n            {\\n                if (A[i] == A[i-1]) \\n                    p=i;\\n                else if (A[i] < A[i-1])                  \\n                    asc = false; \\n            }\\n            else if (A[i] >= A[i-1])\\n            {\\n                asc = true;\\n                m = max(i-p, m);\\n                p = (A[i] >  A[i-1]) ? i-1: i;\\n            }\\n        }\\n            \\n        if (!asc) m = max(int(A.size())-p, m);     \\n        return m;\\n\\t }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285499,
                "title": "java-dp-o-n-easier-to-understand",
                "content": "let\\'s create 2 dp arrays ,\\none for counting length of mountain up from the left side,\\nthe other same purpose from the right side.\\nCodes are a little too much , but this is a very easy way to come up during interview.\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        int n = A.length;//n stands for array length\\n        \\n        if(n>0){\\n            \\n         int[] left = new int[n];\\n         int[] right = new int[n];\\n         left[0]=0;\\n         right[n-1]=0;\\n            \\n         for(int i = 1;i<n;i++){\\n            if(A[i]>A[i-1]){\\n                left[i]=left[i-1]+1;\\n            }else{\\n                left[i]=0;\\n            }\\n         }\\n        \\n         for(int j = n-2;j>-1;j--){\\n            if(A[j]>A[j+1]){\\n                right[j]=right[j+1]+1;\\n            }else{\\n                right[j]=0;\\n            }\\n         }\\n        \\n        \\n         for(int k = 0;k<n;k++){\\n          if(left[k]>0 && right[k]>0){\\n            result = Math.max(result,left[k]+right[k]+1);      \\n          }   \\n         }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        int n = A.length;//n stands for array length\\n        \\n        if(n>0){\\n            \\n         int[] left = new int[n];\\n         int[] right = new int[n];\\n         left[0]=0;\\n         right[n-1]=0;\\n            \\n         for(int i = 1;i<n;i++){\\n            if(A[i]>A[i-1]){\\n                left[i]=left[i-1]+1;\\n            }else{\\n                left[i]=0;\\n            }\\n         }\\n        \\n         for(int j = n-2;j>-1;j--){\\n            if(A[j]>A[j+1]){\\n                right[j]=right[j+1]+1;\\n            }else{\\n                right[j]=0;\\n            }\\n         }\\n        \\n        \\n         for(int k = 0;k<n;k++){\\n          if(left[k]>0 && right[k]>0){\\n            result = Math.max(result,left[k]+right[k]+1);      \\n          }   \\n         }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285145,
                "title": "java-intuitive-solution-go-uphill-and-downhill",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int res = 0;\\n        for(int i = 1; i < A.length; ){\\n            if(A[i] > A[i - 1]){\\n                int j = i;\\n                \\n                //go uphill\\n                while(j < A.length && A[j] > A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j == A.length)\\n                    break;\\n                if(A[j] == A[j - 1]){\\n                    i = j + 1;\\n                    continue;\\n                }\\t\\t\\t\\t\\t\\n                \\n                //go downhill\\n                while(j < A.length && A[j] < A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j - i > 1)\\n                    res = Math.max(res, j - i + 1);\\n                \\n                i = j;\\n            } else \\n                i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThanks fan_zh for point out the duplicate numbers senario.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n        int res = 0;\\n        for(int i = 1; i < A.length; ){\\n            if(A[i] > A[i - 1]){\\n                int j = i;\\n                \\n                //go uphill\\n                while(j < A.length && A[j] > A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j == A.length)\\n                    break;\\n                if(A[j] == A[j - 1]){\\n                    i = j + 1;\\n                    continue;\\n                }\\t\\t\\t\\t\\t\\n                \\n                //go downhill\\n                while(j < A.length && A[j] < A[j - 1]){\\n                    j++;\\n                }\\n                \\n                if(j - i > 1)\\n                    res = Math.max(res, j - i + 1);\\n                \\n                i = j;\\n            } else \\n                i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239625,
                "title": "1-pass-solution-easy-to-understand",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int start = 0;\\n        int peak = 0;\\n        int end = 0;\\n        int answer = 0;\\n        while(i + 1 < A.size())\\n        {\\n            // go to local min\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record starting index\\n            start = i;\\n            // going up\\n            while(i + 1 < A.size() && A[i] < A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record peak index\\n            peak = i;\\n            // going down\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            //record end index\\n            end = i;\\n            // if start, peak, end, have different index, there is a mountain\\n            if(start != peak && peak != end)\\n            {\\n                answer = max(answer, i + 1 - start);\\n            }\\n            // if is flat, move one step\\n            if(i + 1 < A.size() && A[i] == A[i + 1])\\n            {\\n                i++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int start = 0;\\n        int peak = 0;\\n        int end = 0;\\n        int answer = 0;\\n        while(i + 1 < A.size())\\n        {\\n            // go to local min\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record starting index\\n            start = i;\\n            // going up\\n            while(i + 1 < A.size() && A[i] < A[i + 1])\\n            {\\n                i++;\\n            }\\n            // record peak index\\n            peak = i;\\n            // going down\\n            while(i + 1 < A.size() && A[i] > A[i + 1])\\n            {\\n                i++;\\n            }\\n            //record end index\\n            end = i;\\n            // if start, peak, end, have different index, there is a mountain\\n            if(start != peak && peak != end)\\n            {\\n                answer = max(answer, i + 1 - start);\\n            }\\n            // if is flat, move one step\\n            if(i + 1 < A.size() && A[i] == A[i + 1])\\n            {\\n                i++;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148674,
                "title": "c-one-pass-with-comments",
                "content": "```\\n    int longestMountain(vector<int>& A) {\\n        int s = 0, p = -1, res = 0, n = A.size();\\n        for (int i = 1; i < n; i++) {\\n            if (p != -1) {\\n                // if we are tracking peak and it goes down then update result\\n                // if it does not go down, then reset peak\\n                if (A[i] < A[i-1]) res = max(i-s+1, res);\\n                else p = -1;\\n            }\\n            if ((i < n-1 && A[i] < A[i+1]) && A[i] <= A[i-1]) {\\n                // find starting point of next mountain\\n                s = i;\\n            }\\n            if ((A[i-1] < A[i]) && (i < n-1 && A[i] > A[i+1])) {\\n                // find peak\\n                p = i;\\n            }            \\n        }\\n        return res;\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    int longestMountain(vector<int>& A) {\\n        int s = 0, p = -1, res = 0, n = A.size();\\n        for (int i = 1; i < n; i++) {\\n            if (p != -1) {\\n                // if we are tracking peak and it goes down then update result\\n                // if it does not go down, then reset peak\\n                if (A[i] < A[i-1]) res = max(i-s+1, res);\\n                else p = -1;\\n            }\\n            if ((i < n-1 && A[i] < A[i+1]) && A[i] <= A[i-1]) {\\n                // find starting point of next mountain\\n                s = i;\\n            }\\n            if ((A[i-1] < A[i]) && (i < n-1 && A[i] > A[i+1])) {\\n                // find peak\\n                p = i;\\n            }            \\n        }\\n        return res;\\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 135623,
                "title": "kt-js-py3-cpp-mountain-peak",
                "content": "Let each index `k` be the candidate \"peak\" of the mountain.  Let `i` be the index used to traverse the left-downslope of the mountain and let `j` be the index used to traverse the right-downslope of the mountain.  If both `i` and `j` are able to go downwards starting from the peak `k`, then a mountain has been found.  Return the longest mountain from `i..j` inclusive as the `best` answer.\\n\\n---\\n\\n**Runtime:** O(N<sup>2</sup>)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestMountain(A: IntArray): Int {\\n        var best = 0\\n        var N = A.size\\n        for (k in 1 until N - 1) {\\n            var i = k\\n            var j = k\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = Math.max(best, j - i + 1)  // +1 for i..j inclusive\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestMountain = (A, best = 0) => {\\n    let N = A.length;\\n    for (let k = 1; k + 1 < N; ++k) {\\n        let i = k,\\n            j = k;\\n        while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n        while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n        if (i < k && k < j)\\n            best = Math.max(best, j - i + 1);  // +1 for i..j inclusive\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int], best = 0) -> int:\\n        N = len(A)\\n        for k in range(1, N - 1):\\n            i = k\\n            j = k\\n            while 0 <= i - 1 and A[i - 1] < A[i]: i -= 1\\n            while j + 1 < N  and A[j] > A[j + 1]: j += 1\\n            if i < k < j:\\n                best = max(best, j - i + 1)  # +1 for i..j inclusive\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int longestMountain(VI& A, int best = 0) {\\n        int N = A.size();\\n        for (auto k{ 1 }; k + 1 < N; ++k) {\\n            auto i = k,\\n                 j = k;\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = max(best, j - i + 1);  // +1 for i..j inclusive\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestMountain(A: IntArray): Int {\\n        var best = 0\\n        var N = A.size\\n        for (k in 1 until N - 1) {\\n            var i = k\\n            var j = k\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = Math.max(best, j - i + 1)  // +1 for i..j inclusive\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet longestMountain = (A, best = 0) => {\\n    let N = A.length;\\n    for (let k = 1; k + 1 < N; ++k) {\\n        let i = k,\\n            j = k;\\n        while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n        while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n        if (i < k && k < j)\\n            best = Math.max(best, j - i + 1);  // +1 for i..j inclusive\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int], best = 0) -> int:\\n        N = len(A)\\n        for k in range(1, N - 1):\\n            i = k\\n            j = k\\n            while 0 <= i - 1 and A[i - 1] < A[i]: i -= 1\\n            while j + 1 < N  and A[j] > A[j + 1]: j += 1\\n            if i < k < j:\\n                best = max(best, j - i + 1)  # +1 for i..j inclusive\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int longestMountain(VI& A, int best = 0) {\\n        int N = A.size();\\n        for (auto k{ 1 }; k + 1 < N; ++k) {\\n            auto i = k,\\n                 j = k;\\n            while (0 <= i - 1 && A[i - 1] < A[i]) --i;\\n            while (j + 1 < N  && A[j] > A[j + 1]) ++j;\\n            if (i < k && k < j)\\n                best = max(best, j - i + 1);  // +1 for i..j inclusive\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066684,
                "title": "java-easy-one-pass-solution-o-1-memory",
                "content": "```java\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int up = 0, down = 0, result = 0;\\n\\n        for(int i = 1; i < arr.length; ++i) {\\n            if((down > 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i])\\n                up = down = 0;\\n            if(arr[i - 1] < arr[i])\\n                up++;\\n            if(arr[i - 1] > arr[i])\\n                down++;\\n            if(down > 0 && up > 0 && up + down + 1 > result)\\n                result = up + down + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int up = 0, down = 0, result = 0;\\n\\n        for(int i = 1; i < arr.length; ++i) {\\n            if((down > 0 && arr[i - 1] < arr[i]) || arr[i - 1] == arr[i])\\n                up = down = 0;\\n            if(arr[i - 1] < arr[i])\\n                up++;\\n            if(arr[i - 1] > arr[i])\\n                down++;\\n            if(down > 0 && up > 0 && up + down + 1 > result)\\n                result = up + down + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041553,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int helper(int arr[], int idx){\\n        int ans = 0;\\n\\n        int i = idx-1;\\n        int a = arr[idx];\\n        while(i>=0 && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i--;\\n        }\\n        \\n        i=idx+1;\\n        a=arr[idx];\\n\\n        while(i<arr.length && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i++;\\n        }\\n\\n        return ans+1;\\n    }\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n\\n        int max = 0;\\n\\n        for(int i=1; i<n-1; i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                max = Math.max(max,helper(arr,i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int helper(int arr[], int idx){\\n        int ans = 0;\\n\\n        int i = idx-1;\\n        int a = arr[idx];\\n        while(i>=0 && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i--;\\n        }\\n        \\n        i=idx+1;\\n        a=arr[idx];\\n\\n        while(i<arr.length && arr[i]<a){\\n            ans++;\\n            a=arr[i];\\n            i++;\\n        }\\n\\n        return ans+1;\\n    }\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n\\n        int max = 0;\\n\\n        for(int i=1; i<n-1; i++){\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                max = Math.max(max,helper(arr,i));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759339,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nWe have an array `arr` where two consecutive elements can be either one of these:-\\n1. `arr[i] > arr[i-1]`\\n2. `arr[i] < arr[i-1]`\\n3. `arr[i] == arr[i-1]` `Apparently arr[i] not a part of the mountain array`\\nLooking at our question carefully, we can say for cases with `arr.size() < 3` would  have no mountain array. Whenever the array is increasing first(i.e. 1st condition holds first) there is a possibility of having the required array.But we can\\'t be assured until we encounter 2nd condition at least once. This is the primary logic behind.\\n\\n# Approach\\nWe initialise two variables to check when our array is strictly increasing or strictly decreasing. Next we check the cases where the monotonocity is broken.Cases where 3rd condition mentioned in intuition hold will just be ignored and thus we approach the maximum length of mountain we can encounter.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n// no mountain exists\\n        if(n < 3) return 0;\\n        int ans = 0,temp = 0,checkinc = 0, checkdec = 0;\\n        for(int  i = 1; i < n; i++){\\n            if(arr[i] > arr[i-1]){\\n// the end of the mountain\\n                if(checkdec == 1){\\n                    ans = max(temp,ans);\\n                    checkdec = 0;\\n                    checkinc = 1;\\n                    temp = 2;\\n                }\\n                else{\\n// the start of a new mountain\\n                    if(checkinc == 0){\\n                    temp =2;\\n                    checkinc = 1;\\n                    }\\n//add to the existing mountain\\n                    else\\n                    temp++;\\n                }\\n            }\\n            else if(arr[i] < arr[i-1]){\\n// the peak of the mountain\\n                if(checkinc == 1){\\n                    if(checkdec == 0)\\n                    checkdec =1;\\n//add to the existing mountain\\n                    temp++;\\n                }\\n//no mountain\\n                else{\\n                temp = 0;\\n                checkdec = 0;\\n                checkinc = 0;\\n            }\\n            }\\n            else{\\n// the end of the mountain\\n                if(checkinc == 1 && checkdec == 1)\\n                 ans = max(temp,ans);\\n// no mountain exists here\\n                 checkinc = 0;\\n                 checkdec = 0;\\n                 temp = 0;\\n            }\\n        }\\n// the end of the mountain\\n        if(checkinc == 1 && checkdec == 1)\\n        ans = max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n// no mountain exists\\n        if(n < 3) return 0;\\n        int ans = 0,temp = 0,checkinc = 0, checkdec = 0;\\n        for(int  i = 1; i < n; i++){\\n            if(arr[i] > arr[i-1]){\\n// the end of the mountain\\n                if(checkdec == 1){\\n                    ans = max(temp,ans);\\n                    checkdec = 0;\\n                    checkinc = 1;\\n                    temp = 2;\\n                }\\n                else{\\n// the start of a new mountain\\n                    if(checkinc == 0){\\n                    temp =2;\\n                    checkinc = 1;\\n                    }\\n//add to the existing mountain\\n                    else\\n                    temp++;\\n                }\\n            }\\n            else if(arr[i] < arr[i-1]){\\n// the peak of the mountain\\n                if(checkinc == 1){\\n                    if(checkdec == 0)\\n                    checkdec =1;\\n//add to the existing mountain\\n                    temp++;\\n                }\\n//no mountain\\n                else{\\n                temp = 0;\\n                checkdec = 0;\\n                checkinc = 0;\\n            }\\n            }\\n            else{\\n// the end of the mountain\\n                if(checkinc == 1 && checkdec == 1)\\n                 ans = max(temp,ans);\\n// no mountain exists here\\n                 checkinc = 0;\\n                 checkdec = 0;\\n                 temp = 0;\\n            }\\n        }\\n// the end of the mountain\\n        if(checkinc == 1 && checkdec == 1)\\n        ans = max(temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626219,
                "title": "longest-bitonic-subsequence-dynamic-programming-c",
                "content": "# Approach :\\nTo solve this problem, we can start by observing that a mountain sequence is essentially a combination of an increasing subsequence followed by a decreasing subsequence. Therefore, we can utilize the concept of the Longest Increasing Subsequence (LIS) to find the longest mountain sequence.\\n\\nWe can maintain two dynamic programming arrays: dp and dp2. The dp array will store the length of the increasing subsequence ending at each index, similar to the LIS problem. The dp2 array will store the length of the decreasing subsequence starting at each index.\\n\\nWe can iterate over the array arr twice. In the first iteration, we calculate the length of the increasing subsequence ending at each index and store it in the dp array. We compare each element with its previous element and if it is greater, we can extend the increasing subsequence length. In the second iteration (reversed), we calculate the length of the decreasing subsequence starting at each index and store it in the dp2 array. We compare each element with its next element and if it is greater, we can extend the decreasing subsequence length.\\n\\nFinally, we iterate over each index and check if both the increasing and decreasing subsequences have lengths greater than 1. If this condition is met at a particular index, we calculate the length of the mountain sequence by summing the lengths of the corresponding subsequences and subtracting 1 (to avoid counting the same element twice). We update a variable ans to keep track of the maximum length found.\\n\\nAt the end of the iteration, we return the value stored in ans, which represents the maximum length of a valid mountain sequence in the input array arr.\\n\\nIn summary, we utilize the concept of the Longest Increasing Subsequence (LIS) to find the longest mountain sequence. By maintaining two dynamic programming arrays and iterating over the array twice, we can calculate the lengths of the increasing and decreasing subsequences. Finally, we find the maximum length of a mountain sequence by summing the lengths of the corresponding subsequences at each index and subtracting 1.\\n\\n**[Link to the detailed Longest Bitonic Subsequence approach](https://takeuforward.org/data-structure/longest-bitonic-subsequence-dp-46/)**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : The time complexity of the given solution is $$O(n)$$, where n is the size of the input array arr. This is because we iterate over the array twice, performing constant-time operations for each element.\\nIn the first iteration, we calculate the length of the increasing subsequence ending at each index. This requires comparing each element with its previous element, resulting in n-1 comparisons. Therefore, the time complexity of this step is $$O(n)$$.\\nIn the second iteration (reversed), we calculate the length of the decreasing subsequence starting at each index. This also requires comparing each element with its next element, resulting in n-1 comparisons. Hence, the time complexity of this step is also $$O(n)$$.\\nFinally, we iterate over each index to find the maximum length of a mountain sequence. This operation takes constant time for each index, resulting in $$O(n)$$ time complexity.\\nOverall, the time complexity of the solution is $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : The space complexity of the solution is $$O(n)$$ as well. We use two additional arrays, dp and dp2, to store the lengths of the increasing and decreasing subsequences, respectively. Both arrays have a length of n, which is the same as the input array arr. Therefore, the space complexity is linear in terms of the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code :\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1); // dp[i] stores the length of the increasing subsequence ending at index i\\n        vector<int> dp2(n, 1); // dp2[i] stores the length of the decreasing subsequence starting at index i\\n        int ans = 0; // Variable to store the maximum length of a mountain sequence\\n\\n        // Calculate the length of the increasing subsequence ending at each index\\n        for (int ind = 1; ind < n; ind++) {\\n            if (arr[ind] > arr[ind - 1]) {\\n                // If the element at the current index is greater than the previous element,\\n                // we can extend the increasing subsequence. Increment dp[ind] by 1.\\n                dp[ind] = 1 + dp[ind - 1];\\n            }\\n        }\\n\\n        // Calculate the length of the decreasing subsequence starting at each index\\n        for (int ind = n - 2; ind >= 0; ind--) {\\n            if (arr[ind] > arr[ind + 1]) {\\n                // If the element at the current index is greater than the next element,\\n                // we can extend the decreasing subsequence. Increment dp2[ind] by 1.\\n                dp2[ind] = 1 + dp2[ind + 1];\\n            }\\n        }\\n\\n        // Iterate over each index and find the maximum length of a mountain sequence\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                // If both the increasing and decreasing subsequences have lengths greater than 1 at index i,\\n                // calculate the length of the mountain sequence by summing the lengths of the subsequences\\n                // and subtracting 1 (to avoid counting the same element twice). Update the ans variable.\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return ans; // Return the maximum length of a mountain sequence\\n    }\\n};\\n```\\n---\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/c7837255-5339-41d8-b699-1dff126e8726_1686500536.441457.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1); // dp[i] stores the length of the increasing subsequence ending at index i\\n        vector<int> dp2(n, 1); // dp2[i] stores the length of the decreasing subsequence starting at index i\\n        int ans = 0; // Variable to store the maximum length of a mountain sequence\\n\\n        // Calculate the length of the increasing subsequence ending at each index\\n        for (int ind = 1; ind < n; ind++) {\\n            if (arr[ind] > arr[ind - 1]) {\\n                // If the element at the current index is greater than the previous element,\\n                // we can extend the increasing subsequence. Increment dp[ind] by 1.\\n                dp[ind] = 1 + dp[ind - 1];\\n            }\\n        }\\n\\n        // Calculate the length of the decreasing subsequence starting at each index\\n        for (int ind = n - 2; ind >= 0; ind--) {\\n            if (arr[ind] > arr[ind + 1]) {\\n                // If the element at the current index is greater than the next element,\\n                // we can extend the decreasing subsequence. Increment dp2[ind] by 1.\\n                dp2[ind] = 1 + dp2[ind + 1];\\n            }\\n        }\\n\\n        // Iterate over each index and find the maximum length of a mountain sequence\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                // If both the increasing and decreasing subsequences have lengths greater than 1 at index i,\\n                // calculate the length of the mountain sequence by summing the lengths of the subsequences\\n                // and subtracting 1 (to avoid counting the same element twice). Update the ans variable.\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return ans; // Return the maximum length of a mountain sequence\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462560,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n=arr.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i-1]<arr[i])\\n                dp1[i]=dp1[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i+1]<arr[i])\\n                dp2[i]=dp2[i+1]+1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            System.out.println(dp1[i]+\" \"+dp2[i]);\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,dp1[i]+dp2[i]-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n=arr.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i-1]<arr[i])\\n                dp1[i]=dp1[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i+1]<arr[i])\\n                dp2[i]=dp2[i+1]+1;\\n        }\\n        int max=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            System.out.println(dp1[i]+\" \"+dp2[i]);\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,dp1[i]+dp2[i]-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161657,
                "title": "prefix-and-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int prefix[10001],suffix[10001];\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        map<int,int> mp;\\n        for(auto it:arr) mp[it]++;\\n        if(mp.size()==1) return 0;\\n        int n=arr.size();\\n       int ckt=1;\\n        prefix[0]=ckt;\\n        for(int i=1;i<n;i++){\\n          if(arr[i-1]<arr[i]){\\n              ckt++;\\n          }\\n        else ckt=1;\\n          prefix[i]=ckt;\\n        }\\n        // similarly for suffix\\n        ckt=1;\\n        suffix[n-1]=ckt;\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]) ckt++;\\n            else ckt=1;\\n            suffix[i]=ckt;\\n        }\\n        for(int i=0;i<n;i++){\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<suffix[i]<<\" \";\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int sum=prefix[i]+suffix[i]-1;\\n            if(prefix[i]!=1 && suffix[i]!=1) maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int prefix[10001],suffix[10001];\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        map<int,int> mp;\\n        for(auto it:arr) mp[it]++;\\n        if(mp.size()==1) return 0;\\n        int n=arr.size();\\n       int ckt=1;\\n        prefix[0]=ckt;\\n        for(int i=1;i<n;i++){\\n          if(arr[i-1]<arr[i]){\\n              ckt++;\\n          }\\n        else ckt=1;\\n          prefix[i]=ckt;\\n        }\\n        // similarly for suffix\\n        ckt=1;\\n        suffix[n-1]=ckt;\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]) ckt++;\\n            else ckt=1;\\n            suffix[i]=ckt;\\n        }\\n        for(int i=0;i<n;i++){\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            cout<<suffix[i]<<\" \";\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int sum=prefix[i]+suffix[i]-1;\\n            if(prefix[i]!=1 && suffix[i]!=1) maxi=max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3047278,
                "title": "two-python-solution-with-o-n-time-o-n-space-and-second-with-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        # n = len(arr)\\n        # incre, decre = [0]* n, [0]*n\\n\\n        # for i in range(1, n):\\n        #     if arr[i] > arr[i-1]:\\n        #         incre[i] = incre[i-1] + 1\\n\\n        # for i in range(n-1)[::-1]:\\n        #     if arr[i] > arr[i+1]:\\n        #         decre[i] = decre[i+1] + 1\\n        # maxi = 0   \\n        # for i in range(1, n):\\n        #     if incre[i] and decre[i]:\\n        #         maxi = max(maxi, incre[i] + decre[i] + 1)\\n        # return maxi\\n        # if len(arr) < 3:\\n        #     return 0\\n\\n        # In constant O(1) space\\n        incre,decre,ans = 0,0,0\\n        for i in range(1, len(arr)):\\n            if (decre and arr[i-1] < arr[i]) or arr[i-1] == arr[i]:\\n                incre,decre = 0, 0\\n            incre += arr[i-1] < arr[i]\\n            decre += arr[i-1] > arr[i]\\n\\n            if incre  and decre:\\n                ans = max(ans, incre + decre + 1)\\n        return ans    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        # n = len(arr)\\n        # incre, decre = [0]* n, [0]*n\\n\\n        # for i in range(1, n):\\n        #     if arr[i] > arr[i-1]:\\n        #         incre[i] = incre[i-1] + 1\\n\\n        # for i in range(n-1)[::-1]:\\n        #     if arr[i] > arr[i+1]:\\n        #         decre[i] = decre[i+1] + 1\\n        # maxi = 0   \\n        # for i in range(1, n):\\n        #     if incre[i] and decre[i]:\\n        #         maxi = max(maxi, incre[i] + decre[i] + 1)\\n        # return maxi\\n        # if len(arr) < 3:\\n        #     return 0\\n\\n        # In constant O(1) space\\n        incre,decre,ans = 0,0,0\\n        for i in range(1, len(arr)):\\n            if (decre and arr[i-1] < arr[i]) or arr[i-1] == arr[i]:\\n                incre,decre = 0, 0\\n            incre += arr[i-1] < arr[i]\\n            decre += arr[i-1] > arr[i]\\n\\n            if incre  and decre:\\n                ans = max(ans, incre + decre + 1)\\n        return ans    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883947,
                "title": "java-without-using-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n        \\n        int ans= 0;\\n        for(int i =1;i<n-1;){\\n            if(arr[i-1]<arr[i] && arr[i]>arr[i+1]){\\n                int j=i;\\n                int count = 1;\\n                 while( j>0 && arr[j] > arr[j-1] ){ \\n// if your condition is  arr[j] > arr[j-1] && j>0,\\n// it\\'ll throw error cz it, first check code which \\n//are in first, so then arr[j-1] try to find and \\n//check the condition, so it\\'ll throw error \\n                    j--;\\n                    count++;\\n                }\\n                while( i < n-1 && arr[i] > arr[i+1] ){\\n                    i++;\\n                    count++;\\n                }\\n                ans = Math.max(count,ans);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int n = arr.length;\\n        \\n        int ans= 0;\\n        for(int i =1;i<n-1;){\\n            if(arr[i-1]<arr[i] && arr[i]>arr[i+1]){\\n                int j=i;\\n                int count = 1;\\n                 while( j>0 && arr[j] > arr[j-1] ){ \\n// if your condition is  arr[j] > arr[j-1] && j>0,\\n// it\\'ll throw error cz it, first check code which \\n//are in first, so then arr[j-1] try to find and \\n//check the condition, so it\\'ll throw error \\n                    j--;\\n                    count++;\\n                }\\n                while( i < n-1 && arr[i] > arr[i+1] ){\\n                    i++;\\n                    count++;\\n                }\\n                ans = Math.max(count,ans);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610920,
                "title": "c-fastest-submission-tc-o-n-sc-o-1-dp",
                "content": "TC: O(N)\\nSC: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int i=0;\\n        int maxi=0;\\n        \\n        while(i<n){\\n            \\n            int up=1;\\n            //upside\\n            while(i+1<n && arr[i]<arr[i+1]){\\n                i++;\\n                up++;\\n            }\\n            \\n            int down=0;\\n            //downside\\n            while(i+1<n && arr[i]>arr[i+1]){\\n                i++;\\n                down++;\\n            }\\n            \\n\\t\\t\\t//check for valid mountain array\\n            if(up>1 && down >0){\\n                maxi= maxi < up + down ? up+down : maxi;\\n                    \\n            }\\n    \\t/*\\n\\t        if there is  down means the break point will be at arr[i] <= arr[i+1] in this case arr[i] \\n\\t\\t\\tcan be part of new mountrain array in upside so we will miss one element in further \\n\\t\\t\\tcreation . thats why if(down!=0) we will again start from same index i, else we can take\\n\\t\\t\\tnew i+1\\n\\t\\t*/\\n            if(down==0)\\n                i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        int i=0;\\n        int maxi=0;\\n        \\n        while(i<n){\\n            \\n            int up=1;\\n            //upside\\n            while(i+1<n && arr[i]<arr[i+1]){\\n                i++;\\n                up++;\\n            }\\n            \\n            int down=0;\\n            //downside\\n            while(i+1<n && arr[i]>arr[i+1]){\\n                i++;\\n                down++;\\n            }\\n            \\n\\t\\t\\t//check for valid mountain array\\n            if(up>1 && down >0){\\n                maxi= maxi < up + down ? up+down : maxi;\\n                    \\n            }\\n    \\t/*\\n\\t        if there is  down means the break point will be at arr[i] <= arr[i+1] in this case arr[i] \\n\\t\\t\\tcan be part of new mountrain array in upside so we will miss one element in further \\n\\t\\t\\tcreation . thats why if(down!=0) we will again start from same index i, else we can take\\n\\t\\t\\tnew i+1\\n\\t\\t*/\\n            if(down==0)\\n                i++;\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588163,
                "title": "scan-left-then-right",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        \\n        int n = a.size();\\n        int i=1;\\n        \\n        int res = 0;\\n        while(i<n)\\n        {\\n            while(i<n && a[i]==a[i-1])\\n                i++;\\n            \\n            int up=0;\\n            while(i<n && a[i]>a[i-1]){\\n                up++;\\n                i++;\\n            }\\n            \\n            int down=0;\\n            while(i<n && a[i]<a[i-1])\\n            {\\n                down++;\\n                i++;    \\n            }\\n            \\n            if(down && up)\\n            {\\n                res = max(res,up+down+1);\\n            }\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        \\n        int n = a.size();\\n        int i=1;\\n        \\n        int res = 0;\\n        while(i<n)\\n        {\\n            while(i<n && a[i]==a[i-1])\\n                i++;\\n            \\n            int up=0;\\n            while(i<n && a[i]>a[i-1]){\\n                up++;\\n                i++;\\n            }\\n            \\n            int down=0;\\n            while(i<n && a[i]<a[i-1])\\n            {\\n                down++;\\n                i++;    \\n            }\\n            \\n            if(down && up)\\n            {\\n                res = max(res,up+down+1);\\n            }\\n            \\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549874,
                "title": "python-easy-to-understand-dp",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        dp = [0] * len(arr)\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                dp[i] = dp[i-1] + 1\\n        print(dp)\\n        dp2 = [0] * len(arr)\\n        for i in range(len(arr)-2, -1, -1):\\n            if arr[i] > arr[i+1]:\\n                dp2[i] = dp2[i+1] + 1\\n        print(dp2)\\n        res = 0\\n        for i in range(len(arr)):\\n            if dp[i] > 0 and dp2[i] > 0:\\n                res = max(res, dp[i] + dp2[i] + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        dp = [0] * len(arr)\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i-1]:\\n                dp[i] = dp[i-1] + 1\\n        print(dp)\\n        dp2 = [0] * len(arr)\\n        for i in range(len(arr)-2, -1, -1):\\n            if arr[i] > arr[i+1]:\\n                dp2[i] = dp2[i+1] + 1\\n        print(dp2)\\n        res = 0\\n        for i in range(len(arr)):\\n            if dp[i] > 0 and dp2[i] > 0:\\n                res = max(res, dp[i] + dp2[i] + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522458,
                "title": "c-easy-short-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/8b9f5a80-42ca-4be7-b3d2-568d3395eeb9_1662187875.807191.png)\\n\\n**T->O(n) &&& S->O(n)**\\n\\n***This question is the extension of longest Bitonic/Mountain subsequence. In that we compare with all the prevoius elements and store the max on dp[i] but since we want a consecutive Subsequence that we just have compare with the last element. Rest of the code is same as finding the longest mountain subsequence!***\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp1(n,1),dp2(n,1),sum(n,0);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(arr[i]>arr[i-1] && 1+dp1[i-1]>dp1[i]) dp1[i]=1+dp1[i-1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tif(arr[i]>arr[i+1] && 1+dp2[i+1]>dp2[i]) dp2[i]=1+dp2[i+1];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(dp1[i]!=1 && dp2[i]!=1) sum[i]=dp1[i]+dp2[i];\\n\\t\\t\\t}  \\n\\t\\t\\tint ans=*max_element(sum.begin(),sum.end());\\n\\t\\t\\tif(ans) ans-=1;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n\\t\\t\\tint n=arr.size();\\n\\t\\t\\tvector<int> dp1(n,1),dp2(n,1),sum(n,0);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(arr[i]>arr[i-1] && 1+dp1[i-1]>dp1[i]) dp1[i]=1+dp1[i-1];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2509007,
                "title": "java-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        // if (arr.length < 3) return 0;\\n\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n\\n                uphill = downhill = false;\\n\\t\\t\\t\\t\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        // if (arr.length < 3) return 0;\\n\\n        int maxLength = 0, i = 0;\\n        boolean uphill = false, downhill = false;\\n\\n        while (i < arr.length - 1) {\\n            if (arr[i] < arr[i + 1]) {\\n                int start = i;\\n\\n                while (i < arr.length - 1 && arr[i] < arr[i + 1]) {\\n                    i++;\\n                    uphill = true;\\n                }\\n\\n                while (i < arr.length - 1 && arr[i] > arr[i + 1]) {\\n                    i++;\\n                    downhill = true;\\n                }\\n\\n                if (uphill && downhill) {\\n                    maxLength = Math.max(maxLength, i - start + 1);\\n                }\\n\\n                uphill = downhill = false;\\n\\t\\t\\t\\t\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461948,
                "title": "python-2-pass-dp-solution",
                "content": "```\\ndp1 is the forward increasing subarry ending at index i (left of mountain)\\ndp2 is the backward increasing subarry ending at index i (right of mountain)\\nThe length of moutain as peak at index i is dp1[i]+dp2[i]-1\\n```\\n\\n```\\ndef longestMountain(self, nums: List[int]) -> int:\\n\\tdp1 = [1]+[0]*(len(nums)-1)\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i-1]<nums[i]:\\n\\t\\t\\tdp1[i] = dp1[i-1]+1\\n\\t\\telse:\\n\\t\\t\\tdp1[i] = 1\\n\\tdp2 = [0]*(len(nums)-1)+[1]\\n\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\tif nums[i]>nums[i+1]:\\n\\t\\t\\tdp2[i] = dp2[i+1]+1\\n\\t\\telse:\\n\\t\\t\\tdp2[i] = 1\\n\\tans = max([dp1[i]+dp2[i]-1 for i in range(1, len(nums)-1) if dp1[i]>1 and dp2[i]>1] or [0]) \\n\\treturn ans if ans>=3 else 0\\n```",
                "solutionTags": [],
                "code": "```\\ndp1 is the forward increasing subarry ending at index i (left of mountain)\\ndp2 is the backward increasing subarry ending at index i (right of mountain)\\nThe length of moutain as peak at index i is dp1[i]+dp2[i]-1\\n```\n```\\ndef longestMountain(self, nums: List[int]) -> int:\\n\\tdp1 = [1]+[0]*(len(nums)-1)\\n\\tfor i in range(1, len(nums)):\\n\\t\\tif nums[i-1]<nums[i]:\\n\\t\\t\\tdp1[i] = dp1[i-1]+1\\n\\t\\telse:\\n\\t\\t\\tdp1[i] = 1\\n\\tdp2 = [0]*(len(nums)-1)+[1]\\n\\tfor i in range(len(nums)-2, -1, -1):\\n\\t\\tif nums[i]>nums[i+1]:\\n\\t\\t\\tdp2[i] = dp2[i+1]+1\\n\\t\\telse:\\n\\t\\t\\tdp2[i] = 1\\n\\tans = max([dp1[i]+dp2[i]-1 for i in range(1, len(nums)-1) if dp1[i]>1 and dp2[i]>1] or [0]) \\n\\treturn ans if ans>=3 else 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2452384,
                "title": "c-highly-commented-code-o-n-time-and-o-1-space",
                "content": "For complexity analysis and other stuff, go [here](https://garmadon.notion.site/Longest-Bitonic-Subarray-76cd76ecd7464f4da5c1d61382d8c1e8).\\n\\n```\\n//works successfully on leetcode!\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n\\n    //constraint given in the question\\n    if(arr.size() < 3)\\n        return 0;\\n        \\n    //start travelling from the beginning of the array\\n    int traveller = 0;\\n    int mountainStart, mountainPeak, mountainLength=0; //answer will be 0 when no mountain exists\\n\\n    //travel till the end of the array\\n    while(traveller < arr.size())\\n    {\\n        //set the starting point of the current mountain \\n        mountainStart = traveller;\\n\\n        //climb the mountain (if an ascending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) < arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if there was a descending slope, the traveller would be standing at the same place\\n        //hence start travelling from the next step\\n        if(traveller == mountainStart)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //traveller is now standing on the mountain peak\\n        mountainPeak = traveller;\\n\\n        //climb down the mountain (if an descending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) > arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if it\\'s a plain surface the traveller must not have moved\\n        //so take one step ahead and start finding the mountain again\\n        if(traveller == mountainPeak)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //Find the longest mountain throughout the trip\\n        mountainLength = max(mountainLength, traveller - mountainStart + 1);\\n    }\\n\\n    return mountainLength;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//works successfully on leetcode!\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n\\n    //constraint given in the question\\n    if(arr.size() < 3)\\n        return 0;\\n        \\n    //start travelling from the beginning of the array\\n    int traveller = 0;\\n    int mountainStart, mountainPeak, mountainLength=0; //answer will be 0 when no mountain exists\\n\\n    //travel till the end of the array\\n    while(traveller < arr.size())\\n    {\\n        //set the starting point of the current mountain \\n        mountainStart = traveller;\\n\\n        //climb the mountain (if an ascending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) < arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if there was a descending slope, the traveller would be standing at the same place\\n        //hence start travelling from the next step\\n        if(traveller == mountainStart)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //traveller is now standing on the mountain peak\\n        mountainPeak = traveller;\\n\\n        //climb down the mountain (if an descending slope exists)\\n        while(traveller + 1 < arr.size() and arr.at(traveller) > arr.at(traveller+1))\\n        {\\n            traveller++;\\n        }\\n\\n        //if it\\'s a plain surface the traveller must not have moved\\n        //so take one step ahead and start finding the mountain again\\n        if(traveller == mountainPeak)\\n        {\\n            traveller++;\\n            continue;\\n        }\\n\\n        //Find the longest mountain throughout the trip\\n        mountainLength = max(mountainLength, traveller - mountainStart + 1);\\n    }\\n\\n    return mountainLength;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430580,
                "title": "one-pass-o-1-space-jugad",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int longest = 0;\\n        bool check = false;\\n        int len = 0;\\n        if(arr[1]>arr[0])   check = true;\\n        for(int i=0;i<n;i++) {\\n            if(i!=0&&arr[i]==arr[i-1])   {\\n                check = false;\\n                len = 0;\\n            }\\n            if(i!=0&&i!=n-1&&arr[i-1]>=arr[i]&&arr[i+1]>=arr[i]) {\\n                len++;\\n                longest = max(longest,len);\\n                len = 1;\\n                check = true;\\n            }\\n            else if(check)  len++;\\n            \\n        }\\n        if(arr[n-1]<arr[n-2])   longest = max(longest,len);\\n        return longest>=3?longest:0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int longest = 0;\\n        bool check = false;\\n        int len = 0;\\n        if(arr[1]>arr[0])   check = true;\\n        for(int i=0;i<n;i++) {\\n            if(i!=0&&arr[i]==arr[i-1])   {\\n                check = false;\\n                len = 0;\\n            }\\n            if(i!=0&&i!=n-1&&arr[i-1]>=arr[i]&&arr[i+1]>=arr[i]) {\\n                len++;\\n                longest = max(longest,len);\\n                len = 1;\\n                check = true;\\n            }\\n            else if(check)  len++;\\n            \\n        }\\n        if(arr[n-1]<arr[n-2])   longest = max(longest,len);\\n        return longest>=3?longest:0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421729,
                "title": "java-one-pass-tc-o-n-sc-o-1-2-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int maxLen = 0, count = 1; //coz we included 1st element\\n        boolean inc = false, dsc = false; //maintain if we first increased and then decreased\\n        \\n        int i = 1;\\n        \\n        while (i < arr.length) {\\n            \\n            inc = false; dsc = false;\\n            count = 1;\\n \\n            //increasing\\n            while (i < arr.length && arr[i] > arr[i-1]) {\\n                count++;\\n                i++;\\n                inc = true;\\n            }\\n            \\n            //decreasing, we will calculate only when we have increased flg is true\\n            while (inc && i < arr.length && arr[i] < arr[i-1]) {\\n                count++;\\n                i++;\\n                dsc = true;\\n            }\\n            \\n            //if values increased and decreased\\n            if (inc && dsc) {\\n                maxLen = Math.max(maxLen, count);\\n                count= 1;\\n                \\n            }else i++;\\n            \\n        }\\n        return maxLen>=3 ? maxLen : 0;     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        \\n        int maxLen = 0, count = 1; //coz we included 1st element\\n        boolean inc = false, dsc = false; //maintain if we first increased and then decreased\\n        \\n        int i = 1;\\n        \\n        while (i < arr.length) {\\n            \\n            inc = false; dsc = false;\\n            count = 1;\\n \\n            //increasing\\n            while (i < arr.length && arr[i] > arr[i-1]) {\\n                count++;\\n                i++;\\n                inc = true;\\n            }\\n            \\n            //decreasing, we will calculate only when we have increased flg is true\\n            while (inc && i < arr.length && arr[i] < arr[i-1]) {\\n                count++;\\n                i++;\\n                dsc = true;\\n            }\\n            \\n            //if values increased and decreased\\n            if (inc && dsc) {\\n                maxLen = Math.max(maxLen, count);\\n                count= 1;\\n                \\n            }else i++;\\n            \\n        }\\n        return maxLen>=3 ? maxLen : 0;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323939,
                "title": "c-easy-to-understand",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n       \\n        int n = arr.size();\\n        int i=1, lgst=0;\\n        \\n        while(i<n-1){\\n            \\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){ //peak found\\n                \\n                int j = i, cnt = 1;\\n                \\n                while(j>0 and arr[j-1] < arr[j]) cnt++, j--; //ele on left of peak\\n                \\n                while(i<n-1 and arr[i] > arr[i+1]) i++, cnt++; //ele on right of peak\\n                \\n                lgst = max(lgst, cnt);\\n            }\\n            else \\n                i++;      \\n        }\\n        \\n        return lgst; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n       \\n        int n = arr.size();\\n        int i=1, lgst=0;\\n        \\n        while(i<n-1){\\n            \\n            if(arr[i] > arr[i-1] and arr[i] > arr[i+1]){ //peak found\\n                \\n                int j = i, cnt = 1;\\n                \\n                while(j>0 and arr[j-1] < arr[j]) cnt++, j--; //ele on left of peak\\n                \\n                while(i<n-1 and arr[i] > arr[i+1]) i++, cnt++; //ele on right of peak\\n                \\n                lgst = max(lgst, cnt);\\n            }\\n            else \\n                i++;      \\n        }\\n        \\n        return lgst; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2309853,
                "title": "c-solution-dp",
                "content": "```\\n   int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]<arr[i]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1){\\n                ans = max(ans,right[i]+left[i]-1);\\n            }\\n        }\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n   int longestMountain(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]<arr[i]){\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i]>arr[i+1]){\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(left[i]>1 && right[i]>1){\\n                ans = max(ans,right[i]+left[i]-1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307197,
                "title": "java-3-ms-easy-to-understand-code",
                "content": "class Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }\\n            //go downhill\\n            while(i<A.length && A[i-1]>A[i]){\\n                downHill=true;\\n                i++;\\n            }\\n\\t\\t\\t\\n            //if found uphill and downhill then there was mountain \\n            if(upHill && downHill){\\n                //only update when mountain size was equal or greater than 3\\n                if(i-start>=3)result = Math.max(i-start,result);\\n            }else{\\n                //if there was no mountain, then ensuring it\\'s not plain surface\\n                while(i<A.length && A[i-1]==A[i])i++;\\n            }\\n            \\n            //update uphill and downhill for next iteration.\\n            upHill = false;\\n            downHill = false;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestMountain(int[] A) {\\n        int result = 0;\\n        if(A==null || A.length<3) return result;\\n        int i = 1;\\n        int start = 0;\\n        boolean upHill = false;\\n        boolean downHill = false;\\n        while(i<A.length){\\n            start = i-1;\\n            //go uphill\\n            while(i<A.length && A[i-1]<A[i]){\\n                upHill=true;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2289642,
                "title": "simple-c-code-o-n",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        int i = 1, j = n-2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int snd = 1;\\n            if(nums[i-1]< nums[i])\\n            {\\n                snd = max(snd, LISFront[i-1]+1);\\n            }\\n            LISFront[i] = snd;\\n            snd = 1;\\n            if(nums[j+1] < nums[j])\\n            {\\n                snd = max(snd, LISBack[j+1]+1);\\n            }\\n            LISBack[j] = snd;\\n            j--;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        int i = 1, j = n-2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int snd = 1;\\n            if(nums[i-1]< nums[i])\\n            {\\n                snd = max(snd, LISFront[i-1]+1);\\n            }\\n            LISFront[i] = snd;\\n            snd = 1;\\n            if(nums[j+1] < nums[j])\\n            {\\n                snd = max(snd, LISBack[j+1]+1);\\n            }\\n            LISBack[j] = snd;\\n            j--;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247437,
                "title": "c-simple-solution-time-o-n-space-o-1-beats-99",
                "content": "```\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int ans = 0, cnt = 0;\\n        for (int l = 1; l < n - 1; l++)\\n        {\\n            if (arr[l] > arr[l - 1] && arr[l] > arr[l + 1])\\n            {\\n\\n                int j = l - 1, k = l + 1;\\n                cnt = 3;\\n                while (j - 1 >= 0 && arr[j] > arr[j - 1])\\n                    j--, cnt++;\\n                while (k + 1 < n && arr[k] > arr[k + 1])\\n                    k++, cnt++;\\n                ans = max(ans, cnt);\\n                l=k-1;\\n            }\\n          \\n        }\\n\\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int longestMountain(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int ans = 0, cnt = 0;\\n        for (int l = 1; l < n - 1; l++)\\n        {\\n            if (arr[l] > arr[l - 1] && arr[l] > arr[l + 1])\\n            {\\n\\n                int j = l - 1, k = l + 1;\\n                cnt = 3;\\n                while (j - 1 >= 0 && arr[j] > arr[j - 1])\\n                    j--, cnt++;\\n                while (k + 1 < n && arr[k] > arr[k + 1])\\n                    k++, cnt++;\\n                ans = max(ans, cnt);\\n                l=k-1;\\n            }\\n          \\n        }\\n\\n        ans = max(ans, cnt);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246185,
                "title": "c-simple-colution-prefix-suffic-technique",
                "content": "```\\n int longestMountain(vector<int>& arr) {\\n        \\n        int i,j,maxi=0,n=arr.size();\\n        int inc[n],dec[n];\\n        inc[0] = 0;\\n        dec[n-1] = 0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n            {\\n                inc[i]  = inc[i-1] + 1;\\n            }\\n            else{\\n                inc[i]  = 0;\\n            }\\n        }\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]>arr[i+1])\\n            {\\n                dec[i] = dec[i+1] + 1;\\n            }\\n            else{\\n                dec[i] = 0;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(inc[i]!=0 && dec[i]!=0)\\n            {\\n                maxi = max(maxi,inc[i] + dec[i]+1);\\n            }\\n           \\n        }\\n        if(maxi<3)\\n        {\\n            return 0;\\n        }\\n        else{\\n            \\n            return maxi;\\n        }\\n",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\n int longestMountain(vector<int>& arr) {\\n        \\n        int i,j,maxi=0,n=arr.size();\\n        int inc[n],dec[n];\\n        inc[0] = 0;\\n        dec[n-1] = 0;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n            {\\n                inc[i]  = inc[i-1] + 1;\\n            }\\n            else{\\n                inc[i]  = 0;\\n            }\\n        }\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]>arr[i+1])\\n            {\\n                dec[i] = dec[i+1] + 1;\\n            }\\n            else{\\n                dec[i] = 0;\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(inc[i]!=0 && dec[i]!=0)\\n            {\\n                maxi = max(maxi,inc[i] + dec[i]+1);\\n            }\\n           \\n        }\\n        if(maxi<3)\\n        {\\n            return 0;\\n        }\\n        else{\\n            \\n            return maxi;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2069011,
                "title": "easy-c-commented-o-n-solution-in-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // ic 1 means we are looking for increasing sequence ic 0 means we are looking for decreasing sequence\\n        \\n// intially we want increasing sequence starting form i=0\\n        int ic=1,l=1,a=0;          \\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]>arr[i-1]){   // numbers in increasing sequence\\n                if(ic==1)l++;   // if we were looking for incresing then we found another number to add to our answer\\n                else{\\n                    \\n/*\\n\\n\\n         /\\\\\\n        /  \\\\  /\\n            \\\\/\\n             this point here marks the end of mountain\\n             what this means is that we were hoping this number to be less than the previous  one\\n\\t\\t\\t but we found it greater than the prevoius one. \\n\\t\\t\\t this marks the end of our  current mountain and start of new mountain\\n*/\\n                  a=max(a,l); \\n                    l=2;\\n                    ic=1;\\n                }\\n            }else if(arr[i]<arr[i-1]){\\n                if(ic==0)l++,a=max(a,l);\\n                else{\\n/*\\n\\n\\n          /\\\\\\n         /  this point here marks the peak of the mountain.\\n            we wanted to continue going up hill but instead we found a slope.\\n            this makes this a mountain we check if this suitable( max ) answer and then we continue hoping to go downhill.\\n            \\n            \\\\                                               /\\\\\\n              this is not a peak                           this is a peak\\n                            we need atleast 3 numbers including current one \\n*/     \\n                    \\n                    \\n                    \\n                    if(l>1)l++,ic=0,a=max(a,l);\\n                    else l=1,ic=1;\\n                     \\n                }\\n            }else{\\n                l=1;\\n                ic=1;\\n            }\\n            \\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        // ic 1 means we are looking for increasing sequence ic 0 means we are looking for decreasing sequence\\n        \\n// intially we want increasing sequence starting form i=0\\n        int ic=1,l=1,a=0;          \\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i]>arr[i-1]){   // numbers in increasing sequence\\n                if(ic==1)l++;   // if we were looking for incresing then we found another number to add to our answer\\n                else{\\n                    \\n/*\\n\\n\\n         /\\\\\\n        /  \\\\  /\\n            \\\\/\\n             this point here marks the end of mountain\\n             what this means is that we were hoping this number to be less than the previous  one\\n\\t\\t\\t but we found it greater than the prevoius one. \\n\\t\\t\\t this marks the end of our  current mountain and start of new mountain\\n*/\\n                  a=max(a,l); \\n                    l=2;\\n                    ic=1;\\n                }\\n            }else if(arr[i]<arr[i-1]){\\n                if(ic==0)l++,a=max(a,l);\\n                else{\\n/*\\n\\n\\n          /\\\\\\n         /  this point here marks the peak of the mountain.\\n            we wanted to continue going up hill but instead we found a slope.\\n            this makes this a mountain we check if this suitable( max ) answer and then we continue hoping to go downhill.\\n            \\n            \\\\                                               /\\\\\\n              this is not a peak                           this is a peak\\n                            we need atleast 3 numbers including current one \\n*/     \\n                    \\n                    \\n                    \\n                    if(l>1)l++,ic=0,a=max(a,l);\\n                    else l=1,ic=1;\\n                     \\n                }\\n            }else{\\n                l=1;\\n                ic=1;\\n            }\\n            \\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007291,
                "title": "preprocessing-left-and-right-monotonicity-simple",
                "content": "```\\nint longestMountain(vector<int>& arr) {\\n    int n = arr.size();\\n    vector<int>left_inc(n, 0);\\n    vector<int>right_inc(n, 0);\\n    int ans = INT_MIN;\\n    \\n    for(int i=1;i<n;i++)\\n        if(arr[i] > arr[i-1])\\n            left_inc[i] = 1 + left_inc[i-1];\\n    \\n    for(int i=(n-2);i>=0;i--)\\n        if(arr[i] > arr[i+1])\\n            right_inc[i] = 1 + right_inc[i+1];        \\n    \\n    for(int i=0;i<n;i++)\\n        if(left_inc[i]>0 && right_inc[i]>0)\\n            ans = max(ans, (left_inc[i]+right_inc[i]));\\n    \\n    if(ans!=INT_MIN)\\n        return ans+1;\\n    else\\n        return 0;\\n    \\n}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint longestMountain(vector<int>& arr) {\\n    int n = arr.size();\\n    vector<int>left_inc(n, 0);\\n    vector<int>right_inc(n, 0);\\n    int ans = INT_MIN;\\n    \\n    for(int i=1;i<n;i++)\\n        if(arr[i] > arr[i-1])\\n            left_inc[i] = 1 + left_inc[i-1];\\n    \\n    for(int i=(n-2);i>=0;i--)\\n        if(arr[i] > arr[i+1])\\n            right_inc[i] = 1 + right_inc[i+1];        \\n    \\n    for(int i=0;i<n;i++)\\n        if(left_inc[i]>0 && right_inc[i]>0)\\n            ans = max(ans, (left_inc[i]+right_inc[i]));\\n    \\n    if(ans!=INT_MIN)\\n        return ans+1;\\n    else\\n        return 0;\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1971664,
                "title": "c-very-easy-simple-solution",
                "content": "\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>left_inc(n, 0);\\n        vector<int>right_inc(n, 0);\\n        int ans = INT_MIN;\\n        \\n        for(int i=1;i<n;i++)\\n            if(arr[i] > arr[i-1])\\n                left_inc[i] = 1 + left_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(arr[i] > arr[i+1])\\n                right_inc[i] = 1 + right_inc[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            if(left_inc[i]>0 && right_inc[i]>0)\\n                ans = max(ans, (left_inc[i]+right_inc[i]));\\n        \\n        if(ans!=INT_MIN)\\n            return ans+1;\\n        else\\n            return 0;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tint longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>left_inc(n, 0);\\n        vector<int>right_inc(n, 0);\\n        int ans = INT_MIN;\\n        \\n        for(int i=1;i<n;i++)\\n            if(arr[i] > arr[i-1])\\n                left_inc[i] = 1 + left_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(arr[i] > arr[i+1])\\n                right_inc[i] = 1 + right_inc[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            if(left_inc[i]>0 && right_inc[i]>0)\\n                ans = max(ans, (left_inc[i]+right_inc[i]));\\n        \\n        if(ans!=INT_MIN)\\n            return ans+1;\\n        else\\n            return 0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1956860,
                "title": "java-1-pass-o-1-space-easy-to-understand",
                "content": "We will look for the peak and will expand to both sides from there till we reach bottom of the mountain. Once a mountain has been found, look for the peak of the next moutain and expand from there and so on.\\n\\n```\\n public int longestMountain(int[] arr) {\\n        int longest = 0; // longest Mountain\\n        for (int i = 1; i < arr.length - 1; ) {\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) { // peak of the current mountain starts from here. Will expand from here to both side just like HIMALAYAS\\n                int k = i - 1;\\n                int j = i + 1;\\n                while (k > 0 && arr[k] > arr[k - 1]) {\\n                    k--;\\n                }\\n                // reached left bottom of the mountain\\n                while (j < arr.length - 1 && arr[j] > arr[j + 1]) {\\n                    j++;\\n                }\\n                // reached right bottom of the mountain\\n                longest = Math.max(longest, j - k + 1); // compare current mountain length with the longest\\n                i = j + 1;  // look for next moutain peak from two index after the right bottom of the current mountain\\n            } else\\n                i++;\\n        }\\n        return longest;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] arr) {\\n        int longest = 0; // longest Mountain\\n        for (int i = 1; i < arr.length - 1; ) {\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) { // peak of the current mountain starts from here. Will expand from here to both side just like HIMALAYAS\\n                int k = i - 1;\\n                int j = i + 1;\\n                while (k > 0 && arr[k] > arr[k - 1]) {\\n                    k--;\\n                }\\n                // reached left bottom of the mountain\\n                while (j < arr.length - 1 && arr[j] > arr[j + 1]) {\\n                    j++;\\n                }\\n                // reached right bottom of the mountain\\n                longest = Math.max(longest, j - k + 1); // compare current mountain length with the longest\\n                i = j + 1;  // look for next moutain peak from two index after the right bottom of the current mountain\\n            } else\\n                i++;\\n        }\\n        return longest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903129,
                "title": "longest-mountain-in-array",
                "content": "```\\n**# CHECK FOR THE ELEMENT WHICH IS GREATER THAN FROM IT\\'S RIGHT AND LEFT BOTH. (NUMS[I-1]<NUMS[I] && NUMS[I]>NUMS[I+1])\\n# IF THIS CONDITION IS CORRECT CHECK ALL ITS LEFT TILL THEY FOLLOW DECREASING ORDER \\n# SIMILIARLY CHECK ALL IT\\'S RIGHT TILL THEY FOLLOW DECREASING ORDER AS WELL.\\n# AFTER GETTING THE INDEX\\'S TILL THEY ARE FOLLOWING DECREASING ORDER FROM LEFT AND RIGHT\\n# (CONSIDERING BOUNDRY SHOULD NOT VOILETED) =>FIND MAX IF ANY MOUNTAIN HAS BEEN FOUND BEFORE AND NOW. ANS=MAX(ANS,RIGHT-LEFT+1)\\n# THANK YOU.\\n# PLEASE UPVOTE IF YOU FIND IT HELPFUL**\\n```\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                int j=i;\\n                int k=i;\\n                while(j>0)\\n                {\\n                    if(nums[j]>nums[j-1])\\n                        j--;\\n                    else\\n                        break;\\n                }\\n                while(k<n-1)\\n                {\\n                    if(nums[k]>nums[k+1])\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                res=max(res,k-j+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n**# CHECK FOR THE ELEMENT WHICH IS GREATER THAN FROM IT\\'S RIGHT AND LEFT BOTH. (NUMS[I-1]<NUMS[I] && NUMS[I]>NUMS[I+1])\\n# IF THIS CONDITION IS CORRECT CHECK ALL ITS LEFT TILL THEY FOLLOW DECREASING ORDER \\n# SIMILIARLY CHECK ALL IT\\'S RIGHT TILL THEY FOLLOW DECREASING ORDER AS WELL.\\n# AFTER GETTING THE INDEX\\'S TILL THEY ARE FOLLOWING DECREASING ORDER FROM LEFT AND RIGHT\\n# (CONSIDERING BOUNDRY SHOULD NOT VOILETED) =>FIND MAX IF ANY MOUNTAIN HAS BEEN FOUND BEFORE AND NOW. ANS=MAX(ANS,RIGHT-LEFT+1)\\n# THANK YOU.\\n# PLEASE UPVOTE IF YOU FIND IT HELPFUL**\\n```\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int res=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                int j=i;\\n                int k=i;\\n                while(j>0)\\n                {\\n                    if(nums[j]>nums[j-1])\\n                        j--;\\n                    else\\n                        break;\\n                }\\n                while(k<n-1)\\n                {\\n                    if(nums[k]>nums[k+1])\\n                        k++;\\n                    else\\n                        break;\\n                }\\n                res=max(res,k-j+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819288,
                "title": "c-easy-implementation",
                "content": "```\\n int longestMountain(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int res=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(arr[i]>arr[i-1]&&arr[i]>arr[i+1])\\n            {\\n                int start=i;\\n                int end=i;\\n                \\n                while(start>0&&arr[start]>arr[start-1])\\n                    start--;\\n                while(end<n-1&&arr[end]>arr[end+1])\\n                    end++;\\n                res=max(res, end-start+1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int longestMountain(vector<int>& arr) \\n    {\\n        int n=arr.size();\\n        int res=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(arr[i]>arr[i-1]&&arr[i]>arr[i+1])\\n            {\\n                int start=i;\\n                int end=i;\\n                \\n                while(start>0&&arr[start]>arr[start-1])\\n                    start--;\\n                while(end<n-1&&arr[end]>arr[end+1])\\n                    end++;\\n                res=max(res, end-start+1);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816679,
                "title": "java-two-solutions-with-extra-space-using-array-and-without-extra-space-using-two-pointers",
                "content": "```\\n// brute force\\n// from each index find the longest decreasing sequence starting from that index toward left , and find the longest  continuous  decreasing sequence starting from that index to the right, TC O(n) , space complexity O(n)\\n//Runtime: 3 ms, faster than 73.85% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int n = arr.length;\\n        int[] decr = new int[n];\\n        // no decreasing number from the 0-index\\n        decr[0] = 0;\\n        int count = 0;\\n        for(int i=1; i< n ; i++){\\n            if(arr[i] <= arr[i-1]){\\n\\t\\t\\t  // this mean there can not be  continuous decreasing sequence  starting from this i-th index\\n                count =0;\\n                decr[i] = 0;\\n                continue;\\n            }\\n             count++;\\n            decr[i] = count;\\n        }\\n        \\n        count = 0;\\n        int res = Integer.MIN_VALUE;\\n        for(int i=n-2; i>=0  ; i--){\\n            if(arr[i] <= arr[i+1]){\\n\\t\\t\\t//  this mean there can not be  continuous increasing sequence  starting from this i-th index\\n                count =0;\\n                continue;\\n            }\\n            count++;\\n            if(decr[i] >0){\\n\\t\\t\\t// update res only if there was at least one decreasing number , add 1 to cover the number at i-th index it self\\n              res = Math.max(res, count + decr[i]+1); \\n            }\\n        \\n        }\\n        \\n        return Math.max(res, 0);\\n    }\\n}\\n```\\n\\n// solution without extra space\\n// the idea is to find all the continuous increasing sequence from the i-th index  untill we reach the peak element for the sequence, after we found the peak element , we just need to count all the continous decreasing sequence starting from the peak element, we just need to be sure that at least we have 2 elements, TC O(n) since each element will be visited at most two times, and SC O(1)\\n```\\n\\n//Runtime: 2 ms, faster than 94.44% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int res = 0,  left = 0;\\n        int i =0;\\n        while( i< arr.length){\\n            int incr = 0;\\n            while( i + 1 < arr.length && arr[i] < arr[i+1]){\\n                incr++;\\n                i++;\\n            }\\n            if(incr == 0){\\n                i++;\\n                continue;\\n            }\\n            int decr = 0;\\n            while( i + 1 < arr.length && arr[i] > arr[i+1]){\\n                decr++;\\n                i++;\\n            }\\n            if(decr == 0){\\n                continue;\\n            }\\n\\n            res = Math.max(res, incr + decr + 1);\\n\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n// brute force\\n// from each index find the longest decreasing sequence starting from that index toward left , and find the longest  continuous  decreasing sequence starting from that index to the right, TC O(n) , space complexity O(n)\\n//Runtime: 3 ms, faster than 73.85% of Java online submissions for Longest Mountain in Array.\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length < 3){\\n            return 0;\\n        }\\n        int n = arr.length;\\n        int[] decr = new int[n];\\n        // no decreasing number from the 0-index\\n        decr[0] = 0;\\n        int count = 0;\\n        for(int i=1; i< n ; i++){\\n            if(arr[i] <= arr[i-1]){\\n\\t\\t\\t  // this mean there can not be  continuous decreasing sequence  starting from this i-th index\\n                count =0;\\n                decr[i] = 0;\\n                continue;\\n            }\\n             count++;\\n            decr[i] = count;\\n        }\\n        \\n        count = 0;\\n        int res = Integer.MIN_VALUE;\\n        for(int i=n-2; i>=0  ; i--){\\n            if(arr[i] <= arr[i+1]){\\n\\t\\t\\t//  this mean there can not be  continuous increasing sequence  starting from this i-th index\\n                count =0;\\n                continue;\\n            }\\n            count++;\\n            if(decr[i] >0){\\n\\t\\t\\t// update res only if there was at least one decreasing number , add 1 to cover the number at i-th index it self\\n              res = Math.max(res, count + decr[i]+1); \\n            }\\n        \\n        }\\n        \\n        return Math.max(res, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792146,
                "title": "easy-beginners-friendly-approach-java",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int largest = 0;\\n        int n=a.length;\\n        for(int i=1;i<n-1;){\\n            //for founding the peaks\\n            if(a[i]>a[i-1] && a[i]>a[i+1]){\\n                int count =1;\\n                int j=i;\\n                //for count in the backwards\\n                while(j>=1 && a[j]>a[j-1]){\\n                    j--;\\n                    count++;\\n                }\\n                 //for count in the forwards\\n                while(i<n-1 && a[i]>a[i+1]){\\n                    i++;\\n                    count++;\\n                }\\n                //checking if it is the largest peak;\\n                largest = Math.max(largest,count);\\n            }\\n            else\\n                i++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int largest = 0;\\n        int n=a.length;\\n        for(int i=1;i<n-1;){\\n            //for founding the peaks\\n            if(a[i]>a[i-1] && a[i]>a[i+1]){\\n                int count =1;\\n                int j=i;\\n                //for count in the backwards\\n                while(j>=1 && a[j]>a[j-1]){\\n                    j--;\\n                    count++;\\n                }\\n                 //for count in the forwards\\n                while(i<n-1 && a[i]>a[i+1]){\\n                    i++;\\n                    count++;\\n                }\\n                //checking if it is the largest peak;\\n                largest = Math.max(largest,count);\\n            }\\n            else\\n                i++;\\n        }\\n        return largest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785329,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int largest=0;\\n        for(int i=1;i<=n-2;){\\n            if(arr[i]>arr[i-1] and arr[i]>arr[i+1]){\\n                \\n                int cnt=1;\\n                int j=i;\\n                \\n                //backward count\\n                while(j>=1 and arr[j]>arr[j-1]){\\n                    cnt++;\\n                    j--;\\n                }\\n                \\n                //forward direction\\n                \\n                while(i<=n-2 and arr[i]>arr[i+1]){\\n                    cnt++;\\n                    i++;\\n                }\\n                \\n                 largest=max(largest,cnt);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return largest;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int largest=0;\\n        for(int i=1;i<=n-2;){\\n            if(arr[i]>arr[i-1] and arr[i]>arr[i+1]){\\n                \\n                int cnt=1;\\n                int j=i;\\n                \\n                //backward count\\n                while(j>=1 and arr[j]>arr[j-1]){\\n                    cnt++;\\n                    j--;\\n                }\\n                \\n                //forward direction\\n                \\n                while(i<=n-2 and arr[i]>arr[i+1]){\\n                    cnt++;\\n                    i++;\\n                }\\n                \\n                 largest=max(largest,cnt);\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return largest;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745280,
                "title": "c-o-n-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0, j = 0, ans = 0, x = 1;\\n        while(j<n)\\n        {\\n            if(j<n-1 && arr[j]<arr[j+1])\\n            {\\n               while(j<n-1 && arr[j] < arr[j+1])\\n               {\\n                    x++;\\n                    j++;\\n               }\\n                int y = x;\\n               while(j<n-1 && arr[j] > arr[j+1])\\n               {\\n                   x++;\\n                   j++;\\n               }\\n                if(y == x)\\n                    x = 0;\\n            }\\n            else\\n                 j++;\\n           ans = max(ans, x);\\n           x = 1;\\n        }\\n        return ans == 1?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int i = 0, j = 0, ans = 0, x = 1;\\n        while(j<n)\\n        {\\n            if(j<n-1 && arr[j]<arr[j+1])\\n            {\\n               while(j<n-1 && arr[j] < arr[j+1])\\n               {\\n                    x++;\\n                    j++;\\n               }\\n                int y = x;\\n               while(j<n-1 && arr[j] > arr[j+1])\\n               {\\n                   x++;\\n                   j++;\\n               }\\n                if(y == x)\\n                    x = 0;\\n            }\\n            else\\n                 j++;\\n           ans = max(ans, x);\\n           x = 1;\\n        }\\n        return ans == 1?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727552,
                "title": "simple-java-solution-100-faster",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42 \\nclass Solution {\\n\\n    public int longestMountain(int[] arr) {\\n        int s = 0;\\n        for(int i=1;i<arr.length-1;i++) {\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]) {\\n                int j=i,tem=1;\\n                while(j>0 && arr[j]>arr[j-1]){\\n                    j--;tem++;\\n                }\\n                j=i;\\n                while(j<arr.length-1 && arr[j]>arr[j+1]) {\\n                    j++;tem++;\\n                }\\n                s=Math.max(s,tem);\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int longestMountain(int[] arr) {\\n        int s = 0;\\n        for(int i=1;i<arr.length-1;i++) {\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]) {\\n                int j=i,tem=1;\\n                while(j>0 && arr[j]>arr[j-1]){\\n                    j--;tem++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1715077,
                "title": "c-1-pass-o-1-space-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int low{0},res{0};\\n        for(int i=1;i<nums.size(); )\\n        {\\n            bool increasing{false},decreasing{false};\\n            while(i<nums.size() and nums[i]>nums[i-1] ) \\n            {\\n                increasing=true;\\n                i++;\\n            }\\n            while(i<nums.size() and nums[i]<nums[i-1] and increasing)\\n            {\\n                decreasing=true;\\n                i++;\\n            }\\n            if(increasing and decreasing)\\n            {\\n                res=max(res,(i-1)-low+1);\\n                low=i-1;\\n            }\\n            else\\n            {\\n                low=i;\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        int low{0},res{0};\\n        for(int i=1;i<nums.size(); )\\n        {\\n            bool increasing{false},decreasing{false};\\n            while(i<nums.size() and nums[i]>nums[i-1] ) \\n            {\\n                increasing=true;\\n                i++;\\n            }\\n            while(i<nums.size() and nums[i]<nums[i-1] and increasing)\\n            {\\n                decreasing=true;\\n                i++;\\n            }\\n            if(increasing and decreasing)\\n            {\\n                res=max(res,(i-1)-low+1);\\n                low=i-1;\\n            }\\n            else\\n            {\\n                low=i;\\n                i++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677513,
                "title": "python-o-n-time-o-1-space-solution-no-shortcuts-direct-solution",
                "content": "I am open to other solutions also. Kindly comment your ideas and PoVs. Thank you!\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        maxlen = 0\\n        n = len( arr)\\n        maxi = 0\\n        tp = 0\\n        incFlag = 0\\n        decFlag = 0\\n        if n < 3:\\n            return 0\\n\\n        for i in range (2,n):\\n            prev = arr[i-1]    \\n            prevprev = arr[i-2]    \\n            # print( tp)\\n            if prevprev < prev and prev < arr[i]:\\n                if tp == 0:\\n                    tp = 2\\n                tp += 1\\n                incFlag = 1\\n            elif decFlag != 1 and prevprev < prev and prev > arr[i]:\\n                if incFlag == 0:\\n                    incFlag = 1\\n                    tp += 2\\n                tp += 1\\n                decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            elif incFlag == 1 and decFlag == 1 and prevprev > prev and prev > arr[i]:\\n                tp += 1\\n                # decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            else:\\n                incFlag = 0\\n                decFlag = 0\\n                tp = 0\\n            print( tp)\\n        return maxlen\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        maxlen = 0\\n        n = len( arr)\\n        maxi = 0\\n        tp = 0\\n        incFlag = 0\\n        decFlag = 0\\n        if n < 3:\\n            return 0\\n\\n        for i in range (2,n):\\n            prev = arr[i-1]    \\n            prevprev = arr[i-2]    \\n            # print( tp)\\n            if prevprev < prev and prev < arr[i]:\\n                if tp == 0:\\n                    tp = 2\\n                tp += 1\\n                incFlag = 1\\n            elif decFlag != 1 and prevprev < prev and prev > arr[i]:\\n                if incFlag == 0:\\n                    incFlag = 1\\n                    tp += 2\\n                tp += 1\\n                decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            elif incFlag == 1 and decFlag == 1 and prevprev > prev and prev > arr[i]:\\n                tp += 1\\n                # decFlag = 1\\n                # if incFlag == 1 and decFlag == 1:\\n                maxlen = max( maxlen, tp)\\n            else:\\n                incFlag = 0\\n                decFlag = 0\\n                tp = 0\\n            print( tp)\\n        return maxlen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672869,
                "title": "longest-mountain-in-array-c-code-without-dp-easy-approach",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int count,j,mx=0,n=arr.size();\\n        bool flag;\\n        for(int i=1;i<n;i++){\\n            j=i;\\n            count=1;\\n            flag=false;\\n            \\n            //increasing sequence\\n            while(j<n && arr[j]>arr[j-1]){\\n                count++;\\n                j++;\\n            }\\n            \\n            //decreasing sequence\\n            while(i!=j && j<n && arr[j]<arr[j-1]){\\n                count++;\\n                j++;\\n                flag=true;\\n            }\\n            \\n            //length is max or not\\n            if(i!=j && flag && count>=3){\\n                mx=max(mx,count);\\n                j--;\\n            }\\n            \\n            i=j;\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int count,j,mx=0,n=arr.size();\\n        bool flag;\\n        for(int i=1;i<n;i++){\\n            j=i;\\n            count=1;\\n            flag=false;\\n            \\n            //increasing sequence\\n            while(j<n && arr[j]>arr[j-1]){\\n                count++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1642862,
                "title": "clean-and-clearly-understandable-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int res = 0;\\n        if(arr.length < 2) return 0;\\n        for(int i=1; i<arr.length-1;i++){\\n            boolean isPeak = false;\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1]){\\n                isPeak = true;\\n            }\\n            if(isPeak){   \\n                int j =i-1;\\n                int currPeak = 1;\\n                while(j>=0 && arr[j+1]>arr[j]){\\n                    currPeak++;\\n                    j--;\\n                }\\n                j=i+1;\\n                while(j<arr.length && arr[j-1] > arr[j]){\\n                    currPeak++;\\n                    j++;\\n                }\\n                 res = Math.max(currPeak,res);\\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        int res = 0;\\n        if(arr.length < 2) return 0;\\n        for(int i=1; i<arr.length-1;i++){\\n            boolean isPeak = false;\\n            if(arr[i] > arr[i-1] && arr[i] > arr[i+1]){\\n                isPeak = true;\\n            }\\n            if(isPeak){   \\n                int j =i-1;\\n                int currPeak = 1;\\n                while(j>=0 && arr[j+1]>arr[j]){\\n                    currPeak++;\\n                    j--;\\n                }\\n                j=i+1;\\n                while(j<arr.length && arr[j-1] > arr[j]){\\n                    currPeak++;\\n                    j++;\\n                }\\n                 res = Math.max(currPeak,res);\\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511677,
                "title": "java-o-n-pre-compute",
                "content": "1. For each index precompute number of contiguous minimum numbers on left and right side.\\n2. For each index i calcuate ans=left[i] + 1 + right[i] => if left[i] and right[i] is > 0.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int n=a.length;\\n        int[] left=new int[n];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(a[i]>a[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n            else if(a[i]<a[i-1])\\n            {\\n                left[i]=0;\\n            }\\n        }\\n        int[] right=new int[n];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(a[i]>a[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n            else if(a[i]<a[i+1])\\n            {\\n                right[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(left[i]>0 && right[i]>0)\\n            {\\n                ans=Math.max(ans, left[i]+right[i]+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int n=a.length;\\n        int[] left=new int[n];\\n        for(int i=1; i<n; i++)\\n        {\\n            if(a[i]>a[i-1])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n            else if(a[i]<a[i-1])\\n            {\\n                left[i]=0;\\n            }\\n        }\\n        int[] right=new int[n];\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(a[i]>a[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n            else if(a[i]<a[i+1])\\n            {\\n                right[i]=0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(left[i]>0 && right[i]>0)\\n            {\\n                ans=Math.max(ans, left[i]+right[i]+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505656,
                "title": "prefix-suffix-array-simple-solution",
                "content": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> pre(n,1);\\n        vector<int> suf(n,1);\\n\\n        int sol = INT_MIN;\\n\\n        for(int i=1;i<n;i++){\\n            \\n            if(nums[i-1]<nums[i]){\\n                \\n                pre[i]=pre[i-1]+1;\\n            }\\n        }\\n\\n        \\n        for(int i=n-2;i>=0;i--){\\n            \\n            if(nums[i+1]<nums[i]){\\n                \\n                suf[i]=suf[i+1]+1;\\n            }\\n            \\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(pre[i] > 1 && suf[i] > 1)\\n            {\\n                sol = max(sol , pre[i] + suf[i]-1);\\n            }\\n           \\n        }\\n        \\n        \\n        if(sol==INT_MIN){\\n            return 0;\\n        }\\n        \\n        else{\\n            return sol;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<int> pre(n,1);\\n        vector<int> suf(n,1);\\n\\n        int sol = INT_MIN;\\n\\n        for(int i=1;i<n;i++){\\n            \\n            if(nums[i-1]<nums[i]){\\n                \\n                pre[i]=pre[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1504390,
                "title": "c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        vector<int> dp(arr.size());\\n           vector<int> dp1(arr.size());\\n    \\n        for(int i=1;i<arr.size()-1;i++){\\n            if(arr[i-1]<arr[i]){\\n                dp[i]=dp[i-1]+1;\\n            }\\n        }\\n         for(int i=arr.size()-2;i>=1;i--){\\n            if(arr[i+1]<arr[i]){\\n                dp1[i]=dp1[i+1]+1;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i]!=0&&dp1[i]!=0){\\n                ans=max(ans,dp[i]+dp1[i]+1);\\n            }\\n        }\\n        return ((ans==INT_MIN)?0:ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        vector<int> dp(arr.size());\\n           vector<int> dp1(arr.size());\\n    \\n        for(int i=1;i<arr.size()-1;i++){\\n            if(arr[i-1]<arr[i]){\\n                dp[i]=dp[i-1]+1;\\n            }\\n        }\\n         for(int i=arr.size()-2;i>=1;i--){\\n            if(arr[i+1]<arr[i]){\\n                dp1[i]=dp1[i+1]+1;\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<dp.size();i++){\\n            if(dp[i]!=0&&dp1[i]!=0){\\n                ans=max(ans,dp[i]+dp1[i]+1);\\n            }\\n        }\\n        return ((ans==INT_MIN)?0:ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426271,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int start = 0;\\n        int res = 0;\\n        \\n        while(start < arr.size())\\n        {\\n            int end = start; // init end to be the same position as start\\n            bool walked_up = false;\\n            bool walked_down = false;\\n            while(end + 1 < arr.size() && arr[end + 1] > arr[end]) // we can walk up if the next value is greater\\n            {\\n                walked_up = true; // we actually walked up.\\n                end++;\\n            }\\n            while(end + 1 < arr.size() && arr[end + 1] < arr[end]) // now we walk down\\n            {\\n                walked_down = true; // we actually walked down\\n                end++;\\n            }\\n            if (walked_up && walked_down) // it is only a valid mountain if we walked up and down.\\n            {\\n                res = max(res, end - start + 1);\\n            }\\n            start = max(end, start + 1); // the next index we look at is either the end of a mountain, or simply the next index.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int start = 0;\\n        int res = 0;\\n        \\n        while(start < arr.size())\\n        {\\n            int end = start; // init end to be the same position as start\\n            bool walked_up = false;\\n            bool walked_down = false;\\n            while(end + 1 < arr.size() && arr[end + 1] > arr[end]) // we can walk up if the next value is greater\\n            {\\n                walked_up = true; // we actually walked up.\\n                end++;\\n            }\\n            while(end + 1 < arr.size() && arr[end + 1] < arr[end]) // now we walk down\\n            {\\n                walked_down = true; // we actually walked down\\n                end++;\\n            }\\n            if (walked_up && walked_down) // it is only a valid mountain if we walked up and down.\\n            {\\n                res = max(res, end - start + 1);\\n            }\\n            start = max(end, start + 1); // the next index we look at is either the end of a mountain, or simply the next index.\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419207,
                "title": "one-pass-93-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d36ec6e4-bac9-427e-b67c-95b779bd8d16_1629623535.5961733.png)\\n```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        len_mountain = slope = 0\\n        start = -1\\n        arr.append(arr[-1])    # to trigger len_mountain check in the loop\\n        for i, (a, b) in enumerate(zip(arr, arr[1:])):\\n            if b > a:\\n                if slope < 1:\\n                    if slope == -1 and start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                    start = i\\n                    slope = 1\\n            elif b < a:\\n                if slope == 1:\\n                    slope = -1\\n            else:\\n                if slope == -1:\\n                    if start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                slope = 0\\n                start = -1\\n        return len_mountain\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        len_mountain = slope = 0\\n        start = -1\\n        arr.append(arr[-1])    # to trigger len_mountain check in the loop\\n        for i, (a, b) in enumerate(zip(arr, arr[1:])):\\n            if b > a:\\n                if slope < 1:\\n                    if slope == -1 and start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                    start = i\\n                    slope = 1\\n            elif b < a:\\n                if slope == 1:\\n                    slope = -1\\n            else:\\n                if slope == -1:\\n                    if start > -1:\\n                        len_mountain = max(len_mountain, i + 1 - start)\\n                slope = 0\\n                start = -1\\n        return len_mountain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409639,
                "title": "c-one-pass-o-n-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int lm = 0, m = 0;\\n        bool gu = false; // going up flag\\n        for(int i = 0; i < n-1; i++) {\\n            if(arr[i]<arr[i+1] && (gu || m==0)) { // going up the mountain at end of array\\n                m++;\\n                gu = true;\\n            } else if(arr[i]>arr[i+1] && (gu || m>0)) { // going down the mountain\\n                m++;\\n                gu = false;\\n                if(i==n-2) lm = max(lm,m); // end of mountain\\n            } else if(arr[i]<arr[i+1] && !gu && m>0) { // end of current mountain and start of probable new mountain\\n                lm = max(lm,m);\\n                m = 1;\\n                gu = true;\\n            } else { // interruption in current mountain (equal values)\\n                if(!gu) lm = max(lm,m); // counted as a mountain if descent had started\\n                m = 0;\\n                gu = false;\\n            }\\n        }\\n        return lm>=2 ? lm+1 : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<3) return 0;\\n        int lm = 0, m = 0;\\n        bool gu = false; // going up flag\\n        for(int i = 0; i < n-1; i++) {\\n            if(arr[i]<arr[i+1] && (gu || m==0)) { // going up the mountain at end of array\\n                m++;\\n                gu = true;\\n            } else if(arr[i]>arr[i+1] && (gu || m>0)) { // going down the mountain\\n                m++;\\n                gu = false;\\n                if(i==n-2) lm = max(lm,m); // end of mountain\\n            } else if(arr[i]<arr[i+1] && !gu && m>0) { // end of current mountain and start of probable new mountain\\n                lm = max(lm,m);\\n                m = 1;\\n                gu = true;\\n            } else { // interruption in current mountain (equal values)\\n                if(!gu) lm = max(lm,m); // counted as a mountain if descent had started\\n                m = 0;\\n                gu = false;\\n            }\\n        }\\n        return lm>=2 ? lm+1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382513,
                "title": "c-solution-12-ms-96-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    /* The logic behind this is until finding the peak value the array should be in \\n       strictly increasing order and after finding the peak the values should be in \\n       strictly decreasing order \\n    */\\n       int longestMountain(vector<int>& arr) {\\n        int start=0,end=1;\\n        int max_val=0;\\n        bool peak_found=false;\\n        while(end<arr.size()){\\n            if(arr[end]>arr[end-1] && !peak_found){\\n                if(end+1<arr.size() && arr[end]>arr[end+1]){ // checking for peak value\\n                   peak_found=true; \\n                }\\n            }\\n            else if(arr[end]<=arr[end-1] && !peak_found){\\n                start=end; // if value in decreasing order before finding peak shift start to end\\n            }\\n            else if(arr[end]>=arr[end-1] && peak_found){\\n                max_val=max(max_val,end-start);//if value in increasing order after finding the peak  calculate the maxlength shift start to end-1                                                          \\n                start=end-1;\\n                peak_found=false;\\n                continue;\\n            }\\n            end++;\\n        }``\\n        if(peak_found){\\n            max_val=max(max_val,end-start);\\n        }\\n        return max_val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /* The logic behind this is until finding the peak value the array should be in \\n       strictly increasing order and after finding the peak the values should be in \\n       strictly decreasing order \\n    */\\n       int longestMountain(vector<int>& arr) {\\n        int start=0,end=1;\\n        int max_val=0;\\n        bool peak_found=false;\\n        while(end<arr.size()){\\n            if(arr[end]>arr[end-1] && !peak_found){\\n                if(end+1<arr.size() && arr[end]>arr[end+1]){ // checking for peak value\\n                   peak_found=true; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1356525,
                "title": "sum-of-lis-and-lds",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        \\n        lis=[0]*len(arr)\\n        \\n        for i in range(1,len(arr)):\\n            if arr[i-1]<arr[i]:\\n                lis[i]=lis[i-1]+1\\n            else:\\n                lis[i]=0\\n        \\n        lds=[0]*len(arr)\\n        \\n        for i in  range(len(arr)-2,-1,-1):\\n            if arr[i+1]<arr[i]:\\n                lds[i]=lds[i+1]+1\\n            else:\\n                lds[i]=0\\n        ans=0\\n        for i in range(1,len(arr)-1):\\n            if lis[i]!=0 and lds[i]!=0:\\n                ans=max(ans,lds[i]+lis[i])\\n        #print(lis)\\n        #print(lds)\\n        return ans+1 if ans!=0 else 0\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        \\n        lis=[0]*len(arr)\\n        \\n        for i in range(1,len(arr)):\\n            if arr[i-1]<arr[i]:\\n                lis[i]=lis[i-1]+1\\n            else:\\n                lis[i]=0\\n        \\n        lds=[0]*len(arr)\\n        \\n        for i in  range(len(arr)-2,-1,-1):\\n            if arr[i+1]<arr[i]:\\n                lds[i]=lds[i+1]+1\\n            else:\\n                lds[i]=0\\n        ans=0\\n        for i in range(1,len(arr)-1):\\n            if lis[i]!=0 and lds[i]!=0:\\n                ans=max(ans,lds[i]+lis[i])\\n        #print(lis)\\n        #print(lds)\\n        return ans+1 if ans!=0 else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355415,
                "title": "java-single-pass",
                "content": "```\\npublic static int longestMountain(int[] arr) {\\n    int maxPeakLength = 0;\\n\\n\\tint i = 1;\\n\\twhile (i < arr.length) {\\n\\t\\t// Go on increasing(till mountain)\\n\\t\\tint increasingLength = increase(i, arr);\\n\\t\\tif (increasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + increasingLength;\\n\\t\\t\\n\\t\\t// Go on decreasing\\n\\t\\tint decreasingLength = decrease(i, arr);\\n\\t\\tif (decreasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + decreasingLength;\\n\\n\\t\\t// Added 1 because peak number is not counted in both increasingLength/decreasingLength.\\n\\t\\tint peakLength = increasingLength + decreasingLength + 1;\\n\\t\\tif (peakLength > maxPeakLength) {\\n\\t\\t\\tmaxPeakLength = peakLength;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPeakLength;\\n}\\n\\npublic static int increase(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] < arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n\\npublic static int decrease(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] > arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n```\\n\\nTime Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic static int longestMountain(int[] arr) {\\n    int maxPeakLength = 0;\\n\\n\\tint i = 1;\\n\\twhile (i < arr.length) {\\n\\t\\t// Go on increasing(till mountain)\\n\\t\\tint increasingLength = increase(i, arr);\\n\\t\\tif (increasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + increasingLength;\\n\\t\\t\\n\\t\\t// Go on decreasing\\n\\t\\tint decreasingLength = decrease(i, arr);\\n\\t\\tif (decreasingLength == 0) {\\n\\t\\t\\ti++;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\ti = i + decreasingLength;\\n\\n\\t\\t// Added 1 because peak number is not counted in both increasingLength/decreasingLength.\\n\\t\\tint peakLength = increasingLength + decreasingLength + 1;\\n\\t\\tif (peakLength > maxPeakLength) {\\n\\t\\t\\tmaxPeakLength = peakLength;\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxPeakLength;\\n}\\n\\npublic static int increase(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] < arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n\\npublic static int decrease(int index, int[] arr) {\\n\\tint initialValue = index;\\n\\twhile (index < arr.length && arr[index - 1] > arr[index]) {\\n\\t\\tindex++;\\n\\t}\\n\\n\\treturn index - initialValue;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275264,
                "title": "python3-solution-with-no-if-operators-just-for-fun",
                "content": "```\\nclass State:\\n    def __init__(self):\\n        self.best = self.up = self.down = 0\\n        self.process_value = self.process_first\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_eq(self):\\n        self.up = self.down = 0\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_down_then_up(self):\\n        self.up = 1\\n        self.down = 0        \\n        self.process_down = self.process_up_then_down\\n        self.process_up = self.process_just_up\\n    def process_just_up(self):\\n        self.up += 1\\n        self.process_down = self.process_up_then_down\\n    def process_up_then_down(self):\\n        self.down += 1\\n        self.best = max(self.best, self.up+self.down+1)\\n        self.process_up = self.process_down_then_up\\n    def process_just_down(self):\\n        pass\\n    def process_first(self, v):\\n        self.prev = v\\n        self.process_value = self.process_next\\n    def process_next(self, v):\\n        p =  self.prev\\n        self.prev = v\\n        [self.process_down,self.process_eq,self.process_up][int(v>p)+1-int(v<p)]()\\n    def get_result(self):\\n        return self.best\\n        \\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        S = State()\\n        for v in arr: S.process_value(v)\\n        return S.get_result()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass State:\\n    def __init__(self):\\n        self.best = self.up = self.down = 0\\n        self.process_value = self.process_first\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_eq(self):\\n        self.up = self.down = 0\\n        self.process_up = self.process_just_up\\n        self.process_down = self.process_just_down\\n    def process_down_then_up(self):\\n        self.up = 1\\n        self.down = 0        \\n        self.process_down = self.process_up_then_down\\n        self.process_up = self.process_just_up\\n    def process_just_up(self):\\n        self.up += 1\\n        self.process_down = self.process_up_then_down\\n    def process_up_then_down(self):\\n        self.down += 1\\n        self.best = max(self.best, self.up+self.down+1)\\n        self.process_up = self.process_down_then_up\\n    def process_just_down(self):\\n        pass\\n    def process_first(self, v):\\n        self.prev = v\\n        self.process_value = self.process_next\\n    def process_next(self, v):\\n        p =  self.prev\\n        self.prev = v\\n        [self.process_down,self.process_eq,self.process_up][int(v>p)+1-int(v<p)]()\\n    def get_result(self):\\n        return self.best\\n        \\nclass Solution:\\n    def longestMountain(self, arr: List[int]) -> int:\\n        S = State()\\n        for v in arr: S.process_value(v)\\n        return S.get_result()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265918,
                "title": "cpp-time-o-n-space-o-1-single-pass-exactly-n-operations",
                "content": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        if(arr.size()<3)\\n            return 0;\\n        //find all the peak\\n        int left =1;\\n        int max =0;\\n        for(int i=1;i<arr.size()-1;){\\n            //skip 1st downhill/plateau\\n            if(i==1)\\n            while(i<=arr.size()-1 && arr[i]<=arr[i-1]){\\n                i++;\\n            }\\n            //check if  peak and count downhill\\n            if(i<arr.size()-1 && arr[i]>arr[i-1]&&arr[i]>arr[i+1]){\\n                int right =0;\\n                i++;\\n                while(i<=arr.size()-1 &&arr[i]<arr[i-1]){\\n                    right++;\\n                    i++;\\n                }\\n                if(max<left+right+1)\\n                    max = left+right+1;\\n                //reset left\\n                left =1;  \\n            }\\n            //check uphill till peak\\n            else{\\n                if(i<=arr.size()-1 && arr[i]>arr[i-1])\\n                left++;\\n                else\\n                    left =1;// reset for plateau\\n                i++;\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        \\n        if(arr.size()<3)\\n            return 0;\\n        //find all the peak\\n        int left =1;\\n        int max =0;\\n        for(int i=1;i<arr.size()-1;){\\n            //skip 1st downhill/plateau\\n            if(i==1)\\n            while(i<=arr.size()-1 && arr[i]<=arr[i-1]){\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1220179,
                "title": "c-time-o-n-space-o-1-modular-solution-proper-naming",
                "content": "```\\nclass Solution {\\npublic:\\n    int goLeft(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx-1>=0 and arr[idx]>arr[idx-1])\\n            cc++,idx--;\\n        return cc;\\n    }\\n\\t\\n    int goRight(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx+1<n and arr[idx]>arr[idx+1])\\n            cc++,idx++;\\n        return cc;\\n    }\\n\\t\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            int left = goLeft(i, arr, n);\\n            int right = goRight(i, arr, n);\\n            if(left>0 and right>0)\\n                ans = max(ans, left+right+1);\\n            i+=right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int goLeft(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx-1>=0 and arr[idx]>arr[idx-1])\\n            cc++,idx--;\\n        return cc;\\n    }\\n\\t\\n    int goRight(int idx, vector<int>& arr, int n){\\n        int cc = 0;\\n        while(idx+1<n and arr[idx]>arr[idx+1])\\n            cc++,idx++;\\n        return cc;\\n    }\\n\\t\\n    int longestMountain(vector<int>& arr) {\\n        int n = arr.size();\\n        int ans = 0;\\n        for(int i=1; i<n-1; i++){\\n            int left = goLeft(i, arr, n);\\n            int right = goRight(i, arr, n);\\n            if(left>0 and right>0)\\n                ans = max(ans, left+right+1);\\n            i+=right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195315,
                "title": "java-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n\\n        int res = 0, start, j;\\n        boolean up=false,down=false;\\n\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[i - 1]) {\\n                start = i - 1;\\n                j = i-1;\\n\\n                while ((start + 1) < arr.length && arr[start] < arr[start + 1]) {\\n                    start++;\\n                    up = true;\\n                }\\n\\n                while ((start + 1) < arr.length && arr[start] > arr[start + 1]) {\\n                    start++;\\n                    down = true;\\n                }\\n\\n                if (up && down) {\\n                    res = Math.max(res, start - j + 1);\\n                }\\n                i = start;\\n                up = false;\\n                down = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n\\n        int res = 0, start, j;\\n        boolean up=false,down=false;\\n\\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] > arr[i - 1]) {\\n                start = i - 1;\\n                j = i-1;\\n\\n                while ((start + 1) < arr.length && arr[start] < arr[start + 1]) {\\n                    start++;\\n                    up = true;\\n                }\\n\\n                while ((start + 1) < arr.length && arr[start] > arr[start + 1]) {\\n                    start++;\\n                    down = true;\\n                }\\n\\n                if (up && down) {\\n                    res = Math.max(res, start - j + 1);\\n                }\\n                i = start;\\n                up = false;\\n                down = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181214,
                "title": "c-one-pass-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int j = 0;\\n        int i = 0;\\n        int n = arr.size();\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            j = i;\\n            if(j+1<n && arr[j+1]>arr[j])\\n            {\\n                while(j+1<n && arr[j+1]>arr[j])\\n                {\\n                    j++;\\n                }\\n                if(j+1<n && arr[j]>arr[j+1])\\n                {\\n                    while(j+1<n && arr[j]>arr[j+1])\\n                    {\\n                        j++;\\n                    }\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            i = max(i+1,j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int j = 0;\\n        int i = 0;\\n        int n = arr.size();\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            j = i;\\n            if(j+1<n && arr[j+1]>arr[j])\\n            {\\n                while(j+1<n && arr[j+1]>arr[j])\\n                {\\n                    j++;\\n                }\\n                if(j+1<n && arr[j]>arr[j+1])\\n                {\\n                    while(j+1<n && arr[j]>arr[j+1])\\n                    {\\n                        j++;\\n                    }\\n                    ans = max(ans,j-i+1);\\n                }\\n            }\\n            i = max(i+1,j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176112,
                "title": "one-pass-space-complexity-o-1",
                "content": "A simple solution to keep track of rising and going down with a boolean flag and solving it using in one single pass\\nThere are three scenarios which can happen when we are traversing the array\\n\\n```\\n\\npublic int longestMountain(int[] arr) {\\n\\tint max = 0;\\n\\n\\tint increaseStart = Integer.MAX_VALUE;\\n\\tboolean increase = false;\\n\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tif (arr[i] >= arr[i - 1] && !increase) { //Mountain has started to ascend. Hence we need to mark the mountain start with variables increaseStart.\\n\\t\\t\\tincreaseStart = i - 1;\\n\\t\\t\\tincrease = true;\\n\\t\\t}\\n\\t\\tif (arr[i] == arr[i - 1]) {\\n\\t\\t\\tincreaseStart = Integer.MAX_VALUE;//If the mountain remains flat then ignore the previous mountain start, as by definition it has to be strictly increasing.\\n\\t\\t\\tincrease = false;\\n\\t\\t}\\n\\n\\t\\tif (arr[i] < arr[i - 1]) {\\n\\t\\t\\tincrease = false; //The mountain is decending hence continously mark our mountain length and check with our max.\\n\\t\\t\\tmax = Math.max(max, i - increaseStart + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int longestMountain(int[] arr) {\\n\\tint max = 0;\\n\\n\\tint increaseStart = Integer.MAX_VALUE;\\n\\tboolean increase = false;\\n\\n\\tfor (int i = 1; i < arr.length; i++) {\\n\\t\\tif (arr[i] >= arr[i - 1] && !increase) { //Mountain has started to ascend. Hence we need to mark the mountain start with variables increaseStart.\\n\\t\\t\\tincreaseStart = i - 1;\\n\\t\\t\\tincrease = true;\\n\\t\\t}\\n\\t\\tif (arr[i] == arr[i - 1]) {\\n\\t\\t\\tincreaseStart = Integer.MAX_VALUE;//If the mountain remains flat then ignore the previous mountain start, as by definition it has to be strictly increasing.\\n\\t\\t\\tincrease = false;\\n\\t\\t}\\n\\n\\t\\tif (arr[i] < arr[i - 1]) {\\n\\t\\t\\tincrease = false; //The mountain is decending hence continously mark our mountain length and check with our max.\\n\\t\\t\\tmax = Math.max(max, i - increaseStart + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123097,
                "title": "java-two-pointers-one-pass",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int max = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            int left = i, right = i;\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\\n                left--;\\n                right++;\\n                while (left >= 1 && arr[left] > arr[left - 1]) left--;\\n                while (right < arr.length - 1 && arr[right] > arr[right + 1]) right++;\\n                max = Math.max(max, right - left + 1);\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestMountain(int[] arr) {\\n        if (arr == null || arr.length == 0) return 0;\\n        int max = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            int left = i, right = i;\\n            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {\\n                left--;\\n                right++;\\n                while (left >= 1 && arr[left] > arr[left - 1]) left--;\\n                while (right < arr.length - 1 && arr[right] > arr[right + 1]) right++;\\n                max = Math.max(max, right - left + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1085155,
                "title": "java-linear-scan-o-n",
                "content": "The first approach came to mind immediately is expand from center, which will go to O(n^2).\\nAfter sumbitting I realized that there has to be an O(n) solution.\\n## Linear Scan, O(n)\\nI view a mountain as left-top-right.\\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        int left = 0;\\n        while (left < arr.length - 2) {\\n            int top = left;\\n            while (top + 1 < arr.length && arr[top + 1] > arr[top]) top++;\\n            int right = top;\\n            while (right + 1 < arr.length && arr[right + 1] < arr[right]) right++;\\n            if (left < top && top < right) ans = Math.max(ans, right - left + 1);\\n            left = Math.max(left + 1, right);\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Expand From Center, O(n^2)\\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) ans = Math.max(ans, expandFromCenter(i, arr));\\n        return ans;\\n    }\\n\\n    private int expandFromCenter(int center, int[] a) {\\n        int left = center;\\n        int right = center;\\n        while (left - 1 >= 0 && a[left - 1] < a[left]) left--;\\n        while (right + 1 < a.length && a[right + 1] < a[right]) right++;\\n        return left == center || right == center ? 0 : right - left + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        int left = 0;\\n        while (left < arr.length - 2) {\\n            int top = left;\\n            while (top + 1 < arr.length && arr[top + 1] > arr[top]) top++;\\n            int right = top;\\n            while (right + 1 < arr.length && arr[right + 1] < arr[right]) right++;\\n            if (left < top && top < right) ans = Math.max(ans, right - left + 1);\\n            left = Math.max(left + 1, right);\\n        }\\n        return ans;\\n    }\\n```\n```\\n    public int longestMountain(int[] arr) {\\n        int ans = 0;\\n        for (int i = 0; i < arr.length; i++) ans = Math.max(ans, expandFromCenter(i, arr));\\n        return ans;\\n    }\\n\\n    private int expandFromCenter(int center, int[] a) {\\n        int left = center;\\n        int right = center;\\n        while (left - 1 >= 0 && a[left - 1] < a[left]) left--;\\n        while (right + 1 < a.length && a[right + 1] < a[right]) right++;\\n        return left == center || right == center ? 0 : right - left + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974108,
                "title": "python3-1-pass-o-1-space-solution-longest-mountain-in-array",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        ans, start = 0, None\\n        for i in range(1, len(A)):\\n            if A[i] > A[i-1] and (i == 1 or A[i-1] <= A[i-2]):\\n                start = i - 1\\n            elif A[i] == A[i-1]:\\n                start = None \\n            elif A[i] < A[i-1] and start is not None:\\n                ans = max(ans, i - start + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        ans, start = 0, None\\n        for i in range(1, len(A)):\\n            if A[i] > A[i-1] and (i == 1 or A[i-1] <= A[i-2]):\\n                start = i - 1\\n            elif A[i] == A[i-1]:\\n                start = None \\n            elif A[i] < A[i-1] and start is not None:\\n                ans = max(ans, i - start + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955919,
                "title": "beats-99-41-of-people-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max=0,i=0;\\n        while(i<arr.size()-1){\\n           // cout<<i<<\" \";\\n            int x=i;\\n            bool a=true,b=true;\\n            while(x<arr.size()-1){\\n                if(arr[x]>=arr[x+1])\\n                    break;\\n                a=false;\\n                x++;\\n            }\\n            if(!a){\\n                while(x<arr.size()-1){\\n                    if(arr[x]<=arr[x+1])\\n                        break;\\n                    x++;\\n                    b=false;\\n                }\\n            }\\n            else\\n                x++;\\n            if(!b){\\n                   max = max<(x-i+1)?(x-i+1):max;\\n            }\\n            i=x;\\n \\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestMountain(vector<int>& arr) {\\n        int max=0,i=0;\\n        while(i<arr.size()-1){\\n           // cout<<i<<\" \";\\n            int x=i;\\n            bool a=true,b=true;\\n            while(x<arr.size()-1){\\n                if(arr[x]>=arr[x+1])\\n                    break;\\n                a=false;\\n                x++;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 954738,
                "title": "java-dp-solution-by-traversing-from-both-ends-with-explanation",
                "content": "Step 1 : Create a dp1 array and store Length of increasing substring moving left to right.\\nStep 2 : Create a dp2 array and store Length of increasing substring moving right to left.\\nStep 3 : Find the Mountain combining both dp arrays.\\n\\nFeel free to ask questions.\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length<3){\\n            return 0;\\n        }\\n        int dp1[] = new int[arr.length];\\n        int dp2[] = new int[arr.length];\\n        \\n        dp1[0]=0;\\n        for(int i=1; i<dp1.length; i++){\\n            if(arr[i]>arr[i-1]){\\n                dp1[i] = dp1[i-1] +1;\\n            }    \\n            else{\\n                dp1[i] = 0;\\n            }\\n        }\\n        dp2[dp2.length-1] = 0;\\n        \\n        for(int j=dp2.length-2; j>=0; j--){\\n            if(arr[j]>arr[j+1]){\\n                dp2[j]=dp2[j+1] + 1; \\n            }else{\\n                dp2[j] = 0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n            {  \\n                ans = Math.max(ans, dp1[i] + dp2[i] + 1);\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length<3){\\n            return 0;\\n        }\\n        int dp1[] = new int[arr.length];\\n        int dp2[] = new int[arr.length];\\n        \\n        dp1[0]=0;\\n        for(int i=1; i<dp1.length; i++){\\n            if(arr[i]>arr[i-1]){\\n                dp1[i] = dp1[i-1] +1;\\n            }    \\n            else{\\n                dp1[i] = 0;\\n            }\\n        }\\n        dp2[dp2.length-1] = 0;\\n        \\n        for(int j=dp2.length-2; j>=0; j--){\\n            if(arr[j]>arr[j+1]){\\n                dp2[j]=dp2[j+1] + 1; \\n            }else{\\n                dp2[j] = 0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n            {  \\n                ans = Math.max(ans, dp1[i] + dp2[i] + 1);\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947350,
                "title": "javascript-o-n-time-o-1-space-straight-forward-approach",
                "content": "```\\nfunction longestPeak(array) {\\n\\tlet maxLength = 0\\n\\tfor(let i = 1; i < array.length; i++) {\\n\\t\\tconst isPeak = array[i] > array[i - 1] && array[i] > array[i + 1]\\n    if(!isPeak) {\\n      continue\\n    }\\n\\n     let left = i - 1,\\n        right = i + 1;\\n    while(left >= 0 && array[left] > array[left - 1]) {\\n      left--\\n    }\\n\\n    while(right < array.length && array[right] > array[right + 1]) {\\n      right++\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1)\\n\\t\\t\\n\\t}\\n\\n  return maxLength\\n}",
                "solutionTags": [],
                "code": "```\\nfunction longestPeak(array) {\\n\\tlet maxLength = 0\\n\\tfor(let i = 1; i < array.length; i++) {\\n\\t\\tconst isPeak = array[i] > array[i - 1] && array[i] > array[i + 1]\\n    if(!isPeak) {\\n      continue\\n    }\\n\\n     let left = i - 1,\\n        right = i + 1;\\n    while(left >= 0 && array[left] > array[left - 1]) {\\n      left--\\n    }\\n\\n    while(right < array.length && array[right] > array[right + 1]) {\\n      right++\\n    }\\n\\n    maxLength = Math.max(maxLength, right - left + 1)\\n\\t\\t\\n\\t}\\n\\n  return maxLength\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 939845,
                "title": "java-one-pass-with-o-1-space",
                "content": "```\\n public int longestMountain(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int up = 0, down = 0, maxLen = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (down != 0) {\\n                    down = 0;\\n                    up = 0;\\n                }\\n                up++;\\n            } else if (A[i] < A[i - 1]) {\\n                if (up != 0) {\\n                    down++;\\n                    maxLen = Math.max(maxLen, down + up + 1);\\n                }\\n            } else {\\n                up = 0;\\n                down = 0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int up = 0, down = 0, maxLen = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (down != 0) {\\n                    down = 0;\\n                    up = 0;\\n                }\\n                up++;\\n            } else if (A[i] < A[i - 1]) {\\n                if (up != 0) {\\n                    down++;\\n                    maxLen = Math.max(maxLen, down + up + 1);\\n                }\\n            } else {\\n                up = 0;\\n                down = 0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 938967,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans=0;\\n        \\n        int i=0;\\n        while(i<A.size())\\n        {\\n            int j=i+1;\\n            int temp_ans=0;\\n            \\n            while(j<A.size() && A[j]>A[j-1])\\n            {\\n                j++;\\n                temp_ans++;\\n            }\\n            \\n            if(j==i+1 || j==A.size())\\n            {\\n                i=j;\\n                continue;\\n            }\\n            int k = j;\\n            while(j<A.size() && A[j]<A[j-1])\\n            {\\n                temp_ans++;\\n                j++;\\n            }\\n            if(j==k)\\n            {\\n                i=j;\\n                continue;\\n            }\\n            ans = max(ans,temp_ans+1);\\n            i=j-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans=0;\\n        \\n        int i=0;\\n        while(i<A.size())\\n        {\\n            int j=i+1;\\n            int temp_ans=0;\\n            \\n            while(j<A.size() && A[j]>A[j-1])\\n            {\\n                j++;\\n                temp_ans++;\\n            }\\n            \\n            if(j==i+1 || j==A.size())\\n            {\\n                i=j;\\n                continue;\\n            }\\n            int k = j;\\n            while(j<A.size() && A[j]<A[j-1])\\n            {\\n                temp_ans++;\\n                j++;\\n            }\\n            if(j==k)\\n            {\\n                i=j;\\n                continue;\\n            }\\n            ans = max(ans,temp_ans+1);\\n            i=j-1;\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938770,
                "title": "python3-solution-with-comment",
                "content": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res, n = 0, len(A)\\n\\t\\t\\n        if n < 3:  return 0\\n        \\n        for i in range(1, n-1):\\n\\t\\t\\t\\n\\t\\t\\t#if we find the peak, we start to count the length\\n            if A[i - 1] < A[i] > A[i + 1]:\\n\\t\\t\\t\\n\\t\\t\\t\\t#set up the left and right pointer\\n                l, r = i, i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#left part and right part\\n                lcur, rcur = 0, 0\\n                \\n\\t\\t\\t\\t#count the length of left part\\n                while l != 0:\\n                    if A[l-1] < A[l]:\\n                        lcur += 1\\n                        l -= 1\\n                    else: \\n                        break\\n\\n\\t\\t\\t\\t#count the length of right part\\n                while r != n - 1:\\n                    if A[r] > A[r + 1]:\\n                        rcur += 1\\n                        r += 1\\n                    else: \\n                        break\\n                 \\n\\t\\t\\t\\t#do not forget to add the peak, so here the total length = (left part + right part + 1)\\n                res = max(res, lcur + rcur + 1)\\n        \\n        return res \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        res, n = 0, len(A)\\n\\t\\t\\n        if n < 3:  return 0\\n        \\n        for i in range(1, n-1):\\n\\t\\t\\t\\n\\t\\t\\t#if we find the peak, we start to count the length\\n            if A[i - 1] < A[i] > A[i + 1]:\\n\\t\\t\\t\\n\\t\\t\\t\\t#set up the left and right pointer\\n                l, r = i, i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#left part and right part\\n                lcur, rcur = 0, 0\\n                \\n\\t\\t\\t\\t#count the length of left part\\n                while l != 0:\\n                    if A[l-1] < A[l]:\\n                        lcur += 1\\n                        l -= 1\\n                    else: \\n                        break\\n\\n\\t\\t\\t\\t#count the length of right part\\n                while r != n - 1:\\n                    if A[r] > A[r + 1]:\\n                        rcur += 1\\n                        r += 1\\n                    else: \\n                        break\\n                 \\n\\t\\t\\t\\t#do not forget to add the peak, so here the total length = (left part + right part + 1)\\n                res = max(res, lcur + rcur + 1)\\n        \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 938498,
                "title": "longest-mountain-in-array-python-3",
                "content": "```\\n    def longestMountain(self, A: List[int]) -> int:\\n        lsize = 1\\n        rsize = 0\\n        mtnsize = 0\\n\\n        for idx in range(1, len(A)):\\n            if A[idx] > A[idx-1]:\\n                if rsize > 0:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                    lsize = 1\\n                    rsize = 0\\n                lsize += 1\\n            elif lsize > 1 and A[idx] < A[idx-1]:\\n                rsize += 1\\n            else:\\n                if lsize > 1 and rsize >= 1:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                lsize = 1\\n                rsize = 0\\n                    \\n        return max(mtnsize, lsize + rsize) if rsize > 0 else mtnsize\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def longestMountain(self, A: List[int]) -> int:\\n        lsize = 1\\n        rsize = 0\\n        mtnsize = 0\\n\\n        for idx in range(1, len(A)):\\n            if A[idx] > A[idx-1]:\\n                if rsize > 0:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                    lsize = 1\\n                    rsize = 0\\n                lsize += 1\\n            elif lsize > 1 and A[idx] < A[idx-1]:\\n                rsize += 1\\n            else:\\n                if lsize > 1 and rsize >= 1:\\n                    mtnsize = max(mtnsize, lsize+rsize)\\n                lsize = 1\\n                rsize = 0\\n                    \\n        return max(mtnsize, lsize + rsize) if rsize > 0 else mtnsize\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938198,
                "title": "java-clean-easy-to-understand-o-n-two-pass-solution",
                "content": "The idea is to check  if current index is a peak of mountain and then stretch to left and right to find the length of indexes included in this mountain.\\n**Upvote** if helpful :) \\n\\n``` \\npublic int longestMountain(int[] a) {\\n        int ans =0;\\n        if(a.length<3)\\n            return 0;\\n       for(int i=1;i<a.length-1;i++){\\n           if(a[i] > a[i-1] && a[i] > a[i+1]){  // Check if this index is a peak \\n             int left = leftDownHillLength(a,i-1);\\n             int right = rightDownHillLength(a,i+1);\\n             ans = Math.max(ans, 1+left+right);    \\n           }   \\n       }\\n       return ans; \\n    }\\n    \\n    \\n    public int leftDownHillLength(int[] a, int i){\\n        int count=0;\\n        while(i>=0 && a[i] < a[i+1]){\\n            count++;\\n            i--;\\n        }\\n        return count;\\n    }\\n    \\n    public int rightDownHillLength(int[] a, int i){\\n        int count=0;\\n        int n=a.length-1;\\n        while(i<=n && a[i-1] > a[i]){\\n            count++;\\n            i++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is to check  if current index is a peak of mountain and then stretch to left and right to find the length of indexes included in this mountain.\\n**Upvote** if helpful :) \\n\\n``` \\npublic int longestMountain(int[] a) {\\n        int ans =0;\\n        if(a.length<3)\\n            return 0;\\n       for(int i=1;i<a.length-1;i++){\\n           if(a[i] > a[i-1] && a[i] > a[i+1]){  // Check if this index is a peak \\n             int left = leftDownHillLength(a,i-1);\\n             int right = rightDownHillLength(a,i+1);\\n             ans = Math.max(ans, 1+left+right);    \\n           }   \\n       }\\n       return ans; \\n    }\\n    \\n    \\n    public int leftDownHillLength(int[] a, int i){\\n        int count=0;\\n        while(i>=0 && a[i] < a[i+1]){\\n            count++;\\n            i--;\\n        }\\n        return count;\\n    }\\n    \\n    public int rightDownHillLength(int[] a, int i){\\n        int count=0;\\n        int n=a.length-1;\\n        while(i<=n && a[i-1] > a[i]){\\n            count++;\\n            i++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 938147,
                "title": "c-real-one-pass-no-extra-while-s",
                "content": "I see most solutions that claim to be one-pass contain actually a \"while\" inside the main \"for\". While complexity is still O(n) I think the code is more difficult to follow than this solution.\\nThe idea is very similar to this python solution which contains a nice explanation: https://leetcode.com/explore/featured/card/november-leetcoding-challenge/566/week-3-november-15th-november-21st/3533/discuss/937652/Python-one-pass-O(1)-space-explained\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0;\\n        for (int i = 1, left = 0, status = \\'flat\\'; i < A.size(); i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (status == \\'desc\\' || status == \\'flat\\') left = i - 1, status = \\'asc\\';\\n            } else if (A[i] < A[i - 1]) {\\n                if (status == \\'asc\\' || status == \\'desc\\') ans = max(ans, i - left + 1), status = \\'desc\\';\\n            } else {\\n                status = \\'flat\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int ans = 0;\\n        for (int i = 1, left = 0, status = \\'flat\\'; i < A.size(); i++) {\\n            if (A[i] > A[i - 1]) {\\n                if (status == \\'desc\\' || status == \\'flat\\') left = i - 1, status = \\'asc\\';\\n            } else if (A[i] < A[i - 1]) {\\n                if (status == \\'asc\\' || status == \\'desc\\') ans = max(ans, i - left + 1), status = \\'desc\\';\\n            } else {\\n                status = \\'flat\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937955,
                "title": "easier-solution-faster-than-92-28-python-with-complete-explanation",
                "content": "Runtime: **156 ms**, faster than **92.28%** of Python3 online submissions. \\n\\n**Complete Explanation of code through comments**\\n```\\nclass Solution:\\n    def longestMountain(self, a: List[int]) -> int:\\n        n = len(a) \\n        ind = 0 \\n        max_dist = 0\\n        flag = False # to determine whether the array ends with upwards hill or downwards hill \\n        while ind < n-1:\\n            if a[ind] < a[ind+1]: #check whether its the starting point of mountain\\n                start = ind\\n                # loops till the peak of the mountain\\n                while ind<n-1 and a[ind]<a[ind+1]: \\n                    ind+=1 \\n                    flag = False\\n                # loops from the peak to the ending of the hill \\n                while ind<n-1 and a[ind]>a[ind+1]:\\n                    ind+=1 \\n                    flag = True\\n                if flag: # incase of termination of array check whether the hill is downwards\\n                    dist = ind-start+1 \\n                    max_dist = max(max_dist, dist) #compare\\n            else:\\n                ind+=1\\n        return max_dist        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, a: List[int]) -> int:\\n        n = len(a) \\n        ind = 0 \\n        max_dist = 0\\n        flag = False # to determine whether the array ends with upwards hill or downwards hill \\n        while ind < n-1:\\n            if a[ind] < a[ind+1]: #check whether its the starting point of mountain\\n                start = ind\\n                # loops till the peak of the mountain\\n                while ind<n-1 and a[ind]<a[ind+1]: \\n                    ind+=1 \\n                    flag = False\\n                # loops from the peak to the ending of the hill \\n                while ind<n-1 and a[ind]>a[ind+1]:\\n                    ind+=1 \\n                    flag = True\\n                if flag: # incase of termination of array check whether the hill is downwards\\n                    dist = ind-start+1 \\n                    max_dist = max(max_dist, dist) #compare\\n            else:\\n                ind+=1\\n        return max_dist        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 937918,
                "title": "longestmountain-python3-one-pass-o-1-space",
                "content": "```python\\nclass Solution:\\n    def longestMountain(self, A: [int]) -> int:\\n        ret, cur, up = 0, 1, True\\n        for i in range(len(A) - 1):\\n            if A[i+1] == A[i]:\\n                ret, cur, up = max(cur, ret) if not up else ret, 1, True\\n                continue\\n            if up:\\n                cur += 1 if A[i+1] > A[i] else 0\\n                if cur <= 1:\\n                    continue\\n                if A[i+1] < A[i]:\\n                    cur, up = cur + 1, False\\n                    continue\\n            else:\\n                if A[i+1] > A[i]:\\n                    ret, cur, up = max(cur, ret), 1, True\\n                cur += 1\\n        return ret if (ret := max(ret, cur) if not up else ret) >= 3 else 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestMountain(self, A: [int]) -> int:\\n        ret, cur, up = 0, 1, True\\n        for i in range(len(A) - 1):\\n            if A[i+1] == A[i]:\\n                ret, cur, up = max(cur, ret) if not up else ret, 1, True\\n                continue\\n            if up:\\n                cur += 1 if A[i+1] > A[i] else 0\\n                if cur <= 1:\\n                    continue\\n                if A[i+1] < A[i]:\\n                    cur, up = cur + 1, False\\n                    continue\\n            else:\\n                if A[i+1] > A[i]:\\n                    ret, cur, up = max(cur, ret), 1, True\\n                cur += 1\\n        return ret if (ret := max(ret, cur) if not up else ret) >= 3 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937906,
                "title": "java-using-direction-variable-o-n-tc-o-1-space",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length == 0) return 0;\\n        \\n        int max = 0;\\n        \\n        int currMax = 0;\\n        int prev = arr[0];\\n        \\n        int dir = 0;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(dir == -1 && (prev < arr[i] || prev == arr[i])){\\n                max = Math.max(max, currMax+1);\\n                currMax = 0;\\n            }\\n            \\n            if(prev == arr[i]){\\n                dir = 0;\\n                currMax = 0;\\n            }\\n            \\n            if(prev < arr[i]){\\n                dir = 1;\\n                currMax++;\\n            }\\n            \\n            if(dir != 0 && prev > arr[i]){\\n                dir = -1;\\n                currMax++;\\n            }\\n            \\n            prev = arr[i];\\n        }\\n        \\n        if(dir == -1){\\n            max = Math.max(max, currMax+1);\\n        }\\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] arr) {\\n        if(arr.length == 0) return 0;\\n        \\n        int max = 0;\\n        \\n        int currMax = 0;\\n        int prev = arr[0];\\n        \\n        int dir = 0;\\n        \\n        for(int i = 1; i < arr.length; i++){\\n            if(dir == -1 && (prev < arr[i] || prev == arr[i])){\\n                max = Math.max(max, currMax+1);\\n                currMax = 0;\\n            }\\n            \\n            if(prev == arr[i]){\\n                dir = 0;\\n                currMax = 0;\\n            }\\n            \\n            if(prev < arr[i]){\\n                dir = 1;\\n                currMax++;\\n            }\\n            \\n            if(dir != 0 && prev > arr[i]){\\n                dir = -1;\\n                currMax++;\\n            }\\n            \\n            prev = arr[i];\\n        }\\n        \\n        if(dir == -1){\\n            max = Math.max(max, currMax+1);\\n        }\\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937853,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn longest_mountain(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut i = 1;\\n        while i < a.len() {\\n            let (mut inc, mut dec) = (0, 0);\\n            while i < a.len() && a[i - 1] < a[i] {\\n                i += 1;\\n                inc += 1;\\n            }\\n            while i < a.len() && a[i - 1] > a[i] {\\n                i += 1;\\n                dec += 1;\\n            }\\n            if inc > 0 && dec > 0 {\\n                answer = std::cmp::max(answer, inc + dec + 1);\\n            }\\n            while i < a.len() && a[i - 1] == a[i] {\\n                i += 1;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn longest_mountain(a: Vec<i32>) -> i32 {\\n        let mut answer = 0;\\n        let mut i = 1;\\n        while i < a.len() {\\n            let (mut inc, mut dec) = (0, 0);\\n            while i < a.len() && a[i - 1] < a[i] {\\n                i += 1;\\n                inc += 1;\\n            }\\n            while i < a.len() && a[i - 1] > a[i] {\\n                i += 1;\\n                dec += 1;\\n            }\\n            if inc > 0 && dec > 0 {\\n                answer = std::cmp::max(answer, inc + dec + 1);\\n            }\\n            while i < a.len() && a[i - 1] == a[i] {\\n                i += 1;\\n            }\\n        }\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937818,
                "title": "java-find-peak-and-move-down",
                "content": "If you liked my solution, **please upvote my post**\\n\\n```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n\\t\\t// peak chould be at least 3 points\\n        if (A == null || A.length <= 2) return 0;\\n        \\n        int max = 0;\\n\\t\\t// starting from second and finishing pre-last\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (isPeak(i, A)) {\\n                int l = i - 1;\\n                int r = i + 1;\\n                int count = 3;\\n\\t\\t\\t\\t// move to left and count length\\n                while (l > 0) {\\n                    if (A[l] > A[l - 1]) {\\n                        l--;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n\\t\\t\\t\\t// move to right and count length\\n                while (r < A.length - 1) {\\n                    if (A[r] > A[r + 1]) {\\n                        r++;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n                max = Math.max(max, count);\\n                // not to check right side of the mountain again on the peak\\n                i = r;\\n            }\\n        }\\n        return max;\\n    }\\n\\t// check condition if point is peak\\n    private boolean isPeak(int i, int[] A) {\\n        return A[i - 1] < A[i] && A[i + 1] < A[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] A) {\\n\\t\\t// peak chould be at least 3 points\\n        if (A == null || A.length <= 2) return 0;\\n        \\n        int max = 0;\\n\\t\\t// starting from second and finishing pre-last\\n        for (int i = 1; i < A.length - 1; i++) {\\n            if (isPeak(i, A)) {\\n                int l = i - 1;\\n                int r = i + 1;\\n                int count = 3;\\n\\t\\t\\t\\t// move to left and count length\\n                while (l > 0) {\\n                    if (A[l] > A[l - 1]) {\\n                        l--;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n\\t\\t\\t\\t// move to right and count length\\n                while (r < A.length - 1) {\\n                    if (A[r] > A[r + 1]) {\\n                        r++;\\n                        count++;\\n                        continue;\\n                    }\\n                    break;\\n                }\\n                max = Math.max(max, count);\\n                // not to check right side of the mountain again on the peak\\n                i = r;\\n            }\\n        }\\n        return max;\\n    }\\n\\t// check condition if point is peak\\n    private boolean isPeak(int i, int[] A) {\\n        return A[i - 1] < A[i] && A[i + 1] < A[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937774,
                "title": "longest-mountain-in-array-o-n-time-o-1-space-java",
                "content": "```\\npublic int longestMountain(int[] A) {\\n        int res = 0;\\n        int iCount = 0;\\n        int dCount = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (dCount > 0 && A[i] < A[i + 1] || A[i] == A[i + 1]) {\\n                iCount = dCount = 0;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                iCount++;\\n            }\\n            if (A[i] > A[i + 1]) {\\n                dCount++;\\n            }\\n            if (iCount > 0 && dCount > 0 ){\\n              res = Math.max(res, iCount + dCount + 1);  \\n            } \\n        }\\n        return res;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic int longestMountain(int[] A) {\\n        int res = 0;\\n        int iCount = 0;\\n        int dCount = 0;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (dCount > 0 && A[i] < A[i + 1] || A[i] == A[i + 1]) {\\n                iCount = dCount = 0;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                iCount++;\\n            }\\n            if (A[i] > A[i + 1]) {\\n                dCount++;\\n            }\\n            if (iCount > 0 && dCount > 0 ){\\n              res = Math.max(res, iCount + dCount + 1);  \\n            } \\n        }\\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 937734,
                "title": "java-easy-one-pass-solution-o-1-space",
                "content": "```\\n   public int longestMountain(int[] nums) {\\n        int len = nums.length;\\n        if(len <= 2) return 0;\\n        int left = 1;\\n        int res = 0;\\n        while(left < len){\\n            if(nums[left] <= nums[left - 1]){\\n                left++;\\n                continue;\\n            }\\n            int cur = left - 1;\\n            while(left < len && nums[left] > nums[left - 1]){\\n                left++;\\n            }\\n            boolean isMountain = false;\\n            while(left < len && nums[left] < nums[left - 1]){\\n                isMountain = true;\\n                left++;\\n            }\\n            if(isMountain) res = Math.max(left - cur, res);       \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   public int longestMountain(int[] nums) {\\n        int len = nums.length;\\n        if(len <= 2) return 0;\\n        int left = 1;\\n        int res = 0;\\n        while(left < len){\\n            if(nums[left] <= nums[left - 1]){\\n                left++;\\n                continue;\\n            }\\n            int cur = left - 1;\\n            while(left < len && nums[left] > nums[left - 1]){\\n                left++;\\n            }\\n            boolean isMountain = false;\\n            while(left < len && nums[left] < nums[left - 1]){\\n                isMountain = true;\\n                left++;\\n            }\\n            if(isMountain) res = Math.max(left - cur, res);       \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 937687,
                "title": "longest-mountain-in-array-with-constrain-and-without-constrain-both-solutions",
                "content": "Without the constraints. dp solution\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        if(!A.size()) return 0;\\n        int ans = 0;\\n        vector<int> forw(A.size(), 0), back(A.size(), 0);\\n        for(int i=1;i<A.size();i++) if(A[i] > A[i-1]) back[i] = 1 + back[i-1];\\n        for(int i=A.size()-2;i>=0;i--) if(A[i] > A[i+1]) forw[i] = 1 + forw[i+1];\\n        for(int i=1;i<A.size()-1;i++){\\n            if(back[i] > 0 && forw[i] > 0) ans = max(ans, back[i] + forw[i] +1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nWith constraint O(1) space and 1 traversal solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int increasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] <= A[index]) break;\\n        return index;\\n    }\\n    int decreasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] >= A[index]) break;\\n        return index;\\n    }\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int ans = 0;\\n        bool up = true;\\n        int increasingElements = 0;\\n        int newIndex = 0;\\n        while(i<A.size()){\\n            if(up){\\n                newIndex = increasing(A, i);\\n                increasingElements = newIndex - i;\\n                if(increasingElements) up^=1;\\n                else newIndex++;\\n            } else{\\n                newIndex = decreasing(A, i);\\n                if((newIndex - i)) ans = max(ans, (newIndex - i + increasingElements +1));\\n                increasingElements = 0;\\n                up^=1;\\n            }\\n            i = newIndex;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        if(!A.size()) return 0;\\n        int ans = 0;\\n        vector<int> forw(A.size(), 0), back(A.size(), 0);\\n        for(int i=1;i<A.size();i++) if(A[i] > A[i-1]) back[i] = 1 + back[i-1];\\n        for(int i=A.size()-2;i>=0;i--) if(A[i] > A[i+1]) forw[i] = 1 + forw[i+1];\\n        for(int i=1;i<A.size()-1;i++){\\n            if(back[i] > 0 && forw[i] > 0) ans = max(ans, back[i] + forw[i] +1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int increasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] <= A[index]) break;\\n        return index;\\n    }\\n    int decreasing(vector<int>& A, int index){\\n        for(;index<A.size()-1;index++) if(A[index+1] >= A[index]) break;\\n        return index;\\n    }\\n    int longestMountain(vector<int>& A) {\\n        int i = 0;\\n        int ans = 0;\\n        bool up = true;\\n        int increasingElements = 0;\\n        int newIndex = 0;\\n        while(i<A.size()){\\n            if(up){\\n                newIndex = increasing(A, i);\\n                increasingElements = newIndex - i;\\n                if(increasingElements) up^=1;\\n                else newIndex++;\\n            } else{\\n                newIndex = decreasing(A, i);\\n                if((newIndex - i)) ans = max(ans, (newIndex - i + increasingElements +1));\\n                increasingElements = 0;\\n                up^=1;\\n            }\\n            i = newIndex;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 932167,
                "title": "not-the-shortest-but-intuitive-one-single-pass-o-n",
                "content": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int end=0,begin=0;\\n        int maxm = Integer.MIN_VALUE;\\n        //find the first rising point\\n        while(begin < a.length-1 &&  a[begin]>=a[begin+1]){\\n            begin++;\\n        }\\n        end = begin;\\n        //To handle if list of duplicates only\\n        if(end>=a.length-1)\\n            return 0;\\n        //Variables to check if mountain condition satisfied\\n        boolean up = false, down=false;\\n        while(end < a.length-1){\\n            up=false;down=false;\\n            // time to check a mountain\\n            if(a[end] < a[end+1]){\\n               while(end<a.length-1 && a[end]<a[end+1]) {end++;up=true;}\\n               while(end<a.length-1  && a[end]>a[end+1]) {end++;down=true;}\\n               if(up==true && down==true){\\n                   maxm = Math.max(maxm,end-begin+1);\\n                    up=false;down=false;\\n                }\\n                begin=end;\\n            }\\n            else{\\n                end++;\\n                begin++;\\n            }\\n        }\\n         if(up==true && down==true){\\n              maxm=Math.max(maxm,end-begin+1);\\n         }\\n        return (maxm == Integer.MIN_VALUE || maxm<3)?0 : maxm;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestMountain(int[] a) {\\n        int end=0,begin=0;\\n        int maxm = Integer.MIN_VALUE;\\n        //find the first rising point\\n        while(begin < a.length-1 &&  a[begin]>=a[begin+1]){\\n            begin++;\\n        }\\n        end = begin;\\n        //To handle if list of duplicates only\\n        if(end>=a.length-1)\\n            return 0;\\n        //Variables to check if mountain condition satisfied\\n        boolean up = false, down=false;\\n        while(end < a.length-1){\\n            up=false;down=false;\\n            // time to check a mountain\\n            if(a[end] < a[end+1]){\\n               while(end<a.length-1 && a[end]<a[end+1]) {end++;up=true;}\\n               while(end<a.length-1  && a[end]>a[end+1]) {end++;down=true;}\\n               if(up==true && down==true){\\n                   maxm = Math.max(maxm,end-begin+1);\\n                    up=false;down=false;\\n                }\\n                begin=end;\\n            }\\n            else{\\n                end++;\\n                begin++;\\n            }\\n        }\\n         if(up==true && down==true){\\n              maxm=Math.max(maxm,end-begin+1);\\n         }\\n        return (maxm == Integer.MIN_VALUE || maxm<3)?0 : maxm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887801,
                "title": "1-pass-python-o-1-space",
                "content": "```class Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        j,k=0,0\\n        ans=0\\n        for i in range(1,len(A)):\\n            if(A[i]-A[i-1]>0):\\n                if(k>0):\\n                    ans=max(ans,j+k+1)\\n                    j=1\\n                    k=0\\n                else:\\n                    j+=1\\n            elif(A[i]-A[i-1]<0):\\n                if(j>0):\\n                    k+=1\\n            else:\\n                if(k!=0 and j!=0):\\n                    ans=max(ans,j+k+1)\\n                j=0\\n                k=0\\n        if(k!=0 and j!=0):\\n            ans=max(ans,j+k+1)\\n        return ans\\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        j,k=0,0\\n        ans=0\\n        for i in range(1,len(A)):\\n            if(A[i]-A[i-1]>0):\\n                if(k>0):\\n                    ans=max(ans,j+k+1)\\n                    j=1\\n                    k=0\\n                else:\\n                    j+=1\\n            elif(A[i]-A[i-1]<0):\\n                if(j>0):\\n                    k+=1\\n            else:\\n                if(k!=0 and j!=0):\\n                    ans=max(ans,j+k+1)\\n                j=0\\n                k=0\\n        if(k!=0 and j!=0):\\n            ans=max(ans,j+k+1)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 881817,
                "title": "simple-c-approach-91-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int n=A.size(); \\n        if(n==0)return 0;\\n        int inc[n];\\n        int dec[n];\\n        //inc[i] stores length of increasing subarray till index i;\\n        inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            inc[i]=A[i]>A[i-1]?inc[i-1]+1:1;\\n        }\\n          //dec[i] stores the length of decreasing subarray starting at index i\\n        dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dec[i]=A[i]>A[i+1]?dec[i+1]+1:1;\\n        }\\n        \\n        int len=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dec[i]>1 && inc[i]>1 && len<dec[i]+inc[i]-1) len=inc[i]+dec[i]-1;\\n        }\\n        \\n        cout<<len<<endl;\\n        return len<3?0:len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n        int n=A.size(); \\n        if(n==0)return 0;\\n        int inc[n];\\n        int dec[n];\\n        //inc[i] stores length of increasing subarray till index i;\\n        inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            inc[i]=A[i]>A[i-1]?inc[i-1]+1:1;\\n        }\\n          //dec[i] stores the length of decreasing subarray starting at index i\\n        dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            dec[i]=A[i]>A[i+1]?dec[i+1]+1:1;\\n        }\\n        \\n        int len=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dec[i]>1 && inc[i]>1 && len<dec[i]+inc[i]-1) len=inc[i]+dec[i]-1;\\n        }\\n        \\n        cout<<len<<endl;\\n        return len<3?0:len;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 857132,
                "title": "naive-c-1-pass-and-o-1-space",
                "content": "```\\npublic class Solution {\\n    public int LongestMountain(int[] A) {\\n        var max = 0;\\n        var up = 0;\\n        var mountainLength = 0;\\n        \\n        for(var i = 1; i < A.Length; i++)\\n        {\\n            if(A[i] > A[i-1])\\n            {\\n                mountainLength = ++up;\\n                continue;\\n            }\\n            if(A[i] < A[i-1])\\n            {\\n                if(mountainLength == 0)\\n                    continue;\\n                mountainLength++;\\n            }\\n            else{\\n                mountainLength = 0;\\n            }\\n            up = 0;\\n            max = Math.Max(max, mountainLength > 0 && up == 0 ? mountainLength + 1 : 0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestMountain(int[] A) {\\n        var max = 0;\\n        var up = 0;\\n        var mountainLength = 0;\\n        \\n        for(var i = 1; i < A.Length; i++)\\n        {\\n            if(A[i] > A[i-1])\\n            {\\n                mountainLength = ++up;\\n                continue;\\n            }\\n            if(A[i] < A[i-1])\\n            {\\n                if(mountainLength == 0)\\n                    continue;\\n                mountainLength++;\\n            }\\n            else{\\n                mountainLength = 0;\\n            }\\n            up = 0;\\n            max = Math.Max(max, mountainLength > 0 && up == 0 ? mountainLength + 1 : 0);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852833,
                "title": "c-solution-one-pass-two-pointer",
                "content": "Runtime: 40 ms, faster than 86.10% of C++ online submissions for Longest Mountain in Array.\\nMemory Usage: 18.5 MB, less than 75.29% of C++ online submissions for Longest Mountain in Array.\\n\\nhttps://leetcode.com/problems/longest-mountain-in-array/discuss/773237/C++-Two-pointer-solution\\n\\n```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n\\n        int n = A.size();\\n        if(n<3) return 0;\\n        \\n        int maxL = 0;\\n        int i = 0;\\n        int up = 0;\\n        int down = 0;\\n        while(i<n)\\n        {\\n            // track the up and down scenario  in the mountain\\n            up = 0; down = 0;\\n            \\n            // check if we can go up and count up length\\n            while(i<n-1 && A[i]<A[i+1])i++,up++;\\n            \\n            // check if we can go down and also check if up is valid and count down length\\n            while(i<n-1 && A[i]>A[i+1] && up)i++,down++;\\n            \\n            // if there is a up and down then count length as up+down+1 (including peek)\\n            if(up && down)\\n                maxL  = max(maxL,up + down + 1);\\n            else\\n                i++;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& A) {\\n\\n        int n = A.size();\\n        if(n<3) return 0;\\n        \\n        int maxL = 0;\\n        int i = 0;\\n        int up = 0;\\n        int down = 0;\\n        while(i<n)\\n        {\\n            // track the up and down scenario  in the mountain\\n            up = 0; down = 0;\\n            \\n            // check if we can go up and count up length\\n            while(i<n-1 && A[i]<A[i+1])i++,up++;\\n            \\n            // check if we can go down and also check if up is valid and count down length\\n            while(i<n-1 && A[i]>A[i+1] && up)i++,down++;\\n            \\n            // if there is a up and down then count length as up+down+1 (including peek)\\n            if(up && down)\\n                maxL  = max(maxL,up + down + 1);\\n            else\\n                i++;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830281,
                "title": "java-bitonic",
                "content": "public int longestMountain(int[] A) {\\n        //extension of bitonic array \\n        \\n    /*  2  1  4  7  3  2  5\\n        0  0  1  2  0  0  1 //increasing from left to right pass(khud se start kru ya purane k saath add hu)\\n                          \\n        1  0  0  2  1  0  0//increasing from right to left\\n        \\n        2  -  2  5  2  -  - //add both+1 */\\n            \\n      int[] lefttoright=new int[A.length];\\n      int[] righttoleft=new int[A.length];\\n        int max=0;\\n        for(int start=1;start<=A.length-1;start++){\\n            if(A[start]>A[start-1]){\\n            lefttoright[start]=lefttoright[start-1]+1;\\n            }else{\\n                lefttoright[start]=0;\\n            }\\n        }\\n        for(int end=A.length-2;end>=0;end--){\\n           if(A[end]>A[end+1]){\\n                righttoleft[end]=righttoleft[end+1]+1;\\n            }else{\\n                righttoleft[end]=0;\\n            } \\n        }\\n        //calculate max(sum)+1 (Now include element if only it increasing from both side)\\n        for(int s=0;s<A.length;s++){\\n            if(lefttoright[s]>0 && righttoleft[s]>0){\\n            int ans=lefttoright[s]+righttoleft[s]+1;\\n            max=Math.max(ans,max);\\n            }\\n        }\\n    return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "public int longestMountain(int[] A) {\\n        //extension of bitonic array \\n        \\n    /*  2  1  4  7  3  2  5\\n        0  0  1  2  0  0  1 //increasing from left to right pass(khud se start kru ya purane k saath add hu)\\n                          \\n        1  0  0  2  1  0  0//increasing from right to left\\n        \\n        2  -  2  5  2  -  - //add both+1 */\\n            \\n      int[] lefttoright=new int[A.length];\\n      int[] righttoleft=new int[A.length];\\n        int max=0;\\n        for(int start=1;start<=A.length-1;start++){\\n            if(A[start]>A[start-1]){\\n            lefttoright[start]=lefttoright[start-1]+1;\\n            }else{\\n                lefttoright[start]=0;\\n            }\\n        }\\n        for(int end=A.length-2;end>=0;end--){\\n           if(A[end]>A[end+1]){\\n                righttoleft[end]=righttoleft[end+1]+1;\\n            }else{\\n                righttoleft[end]=0;\\n            } \\n        }\\n        //calculate max(sum)+1 (Now include element if only it increasing from both side)\\n        for(int s=0;s<A.length;s++){\\n            if(lefttoright[s]>0 && righttoleft[s]>0){\\n            int ans=lefttoright[s]+righttoleft[s]+1;\\n            max=Math.max(ans,max);\\n            }\\n        }\\n    return max;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 796410,
                "title": "well-commented-c-code-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();\\n        int i=0,start=0,top=-1,len=0;\\n        while(i<n-1)\\n        {\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;  //checking where the hill starts\\n            if(i==n-1) break;   //if hill doesn\\'t start eg. 2 2 2\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i; //incrementing untill we find a hill top\\n            while(i<n-1 and a[i]>a[i+1]) i++;   //going downhill after finding a top\\n            if(top<i) len = max(len,i-start+1); //checking if a value exists after hill top\\n            start=i;    //staring from this position for the next hill\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();\\n        int i=0,start=0,top=-1,len=0;\\n        while(i<n-1)\\n        {\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;  //checking where the hill starts\\n            if(i==n-1) break;   //if hill doesn\\'t start eg. 2 2 2\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i; //incrementing untill we find a hill top\\n            while(i<n-1 and a[i]>a[i+1]) i++;   //going downhill after finding a top\\n            if(top<i) len = max(len,i-start+1); //checking if a value exists after hill top\\n            start=i;    //staring from this position for the next hill\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796409,
                "title": "c-1-pass-solution-o-n-time-o-1-space-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();int i=0,start=0,top=-1,len=0;\\n        while(i<n)\\n        {   //find the start of mountain\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;\\n            if(i==n-1) break;\\n            //see if the peak is really the peak\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i;\\n            //find the end of mountain\\n            while(i<n-1 and a[i]>a[i+1]) i++;\\n            //calculate the total length\\n            if(top<i) len=max(len,i-start+1);\\n            start=i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestMountain(vector<int>& a) {\\n        int n=a.size();int i=0,start=0,top=-1,len=0;\\n        while(i<n)\\n        {   //find the start of mountain\\n            while(i<n-1 and a[i]>=a[i+1]) i++,start++;\\n            if(i==n-1) break;\\n            //see if the peak is really the peak\\n            while(i<n-1 and a[i]<a[i+1]) i++,top=i;\\n            //find the end of mountain\\n            while(i<n-1 and a[i]>a[i+1]) i++;\\n            //calculate the total length\\n            if(top<i) len=max(len,i-start+1);\\n            start=i;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760497,
                "title": "detailed-explanation-with-java-o-n-time-and-o-1-space",
                "content": "\\n```\\n public int longestMountain(int[] array) {\\n        int longestLength = 0;\\n        int i = 1;\\n        while(i < array.length - 1){\\n            boolean isPeak = array[i - 1] < array[i] && array[i] > array[i + 1];\\n            \\n            if(!isPeak){\\n                i++;\\n                continue;\\n            }\\n            \\n            int leftIdx = i - 2;\\n            while(leftIdx >=0 && array[leftIdx] < array[leftIdx + 1]){\\n                leftIdx--;\\n            }\\n            \\n            int rightIdx = i + 2;\\n            while(rightIdx < array.length && array[rightIdx - 1] > array[rightIdx]){\\n                rightIdx++;\\n            }\\n            \\n            int currentLength = rightIdx - leftIdx - 1;\\n            if(currentLength > longestLength){\\n                longestLength = currentLength;\\n            }\\n            i = rightIdx;\\n        }\\n        return longestLength;\\n    }\\n```\\n\\n\\n**Intuition**:\\nFirst you have to know if a number is a peak. Once you know the peak you need to expand to its both directions and calulate its length along the way. Keep updating the length by comparing it with length of other peaks and choose the longest length.\\n\\n\\n**Algorithm**:\\nSo we first have to know if the current number is the peak. Start traversing the array from left to right. If a current value satisfies the peak condition then store the boolean result in a variable call it \\'isPeak\\'. Note that traversal will start from the second element, because it doesnt make sense to check if the first element is a peak, because it cant be, according to the definition of a peak.\\n\\nCondition: array[ i - 1 ] < array[ i ] && array[ i ] > array[ i + 1 ]\\n\\nThe reason to use a boolean variable is just for simplying the code. Otherwise you can directly write a peak condition inside the if construct.\\n\\nLets move on, \\n\\nIf the current value is not a peak then we dont do anything in this iteration, simply increment the iterator \\'i\\' and just continue with the search for a peak on to the next element.\\n\\nIf we have the peak:\\nThen we have to expand to the right and left, so long as we have strictly decreasing integers in either directions.\\n\\n**Lets expand to the left first:**\\nWe already know the left( i - 1 ) of the current element (i) is smaller. So we dont have to check that again. We start from i - 2. Hence we define a variable leftIdx initialized to i - 2\\n\\nNow we iterate through the left part backwords. As long as our leftIdx is in the bounds and array[leftIdx] < array[leftIdx + 1] . Keep decrementing the leftIdx. So that we can keep checking all values to the left. At the end leftIdx, will hold the index of the element from where the peak began.\\n\\n\\n**Lets expand to the right now:**\\nWe already know that the right ( i + 1 ) of the current element ( i ) is greater. So we dont have to check that again. We start from i + 2\\n\\nNow iterate through the right part forwards. As long as our rightIdx is in the bounds and array[ rightIdx - 1 ]  >  array[ i ]. Keep increamenting the rightIdx.  So that we can keep checking all values to the right. At the end rightIdx, will hold the index of the element to where the peak ends.\\n\\nNow get the currentPeakLength by doing rightIdx - leftIdx - 1 \\nAnd compare it with the longestPeakLength,  and return the longest amongst them.\\n\\n\\nTo increment the iteration variable i, do this:\\ni = rightIdx\\n\\nWhy it works ?. The rightIdx holds the location of a and end of a peak. All the element between a peak and this rightIdx, were in a strictly decreasing manner. So it doesnt make a sense to check values before the rightIdx.\\n\\n\\n**Complexity Analysis**\\n\\nTime: O(n), How many times do we visit every element in the array ? There are few cases to consider. Lets say you have strictly increasing or strictly decreasing or a flat array. Then there is no peak. In all these three cases you visit each element once. But when we find a peak, we have to expand to left and right. There can be multiple peaks to expand. All these expansion is also a visit. So in this case too we are visiting each element for once at least. And then we visit every element at most 2-3 times. It converges to O(N)\\n\\n*Please correct me if you find that I misunderstood something in the explaination*",
                "solutionTags": [],
                "code": "```\\n public int longestMountain(int[] array) {\\n        int longestLength = 0;\\n        int i = 1;\\n        while(i < array.length - 1){\\n            boolean isPeak = array[i - 1] < array[i] && array[i] > array[i + 1];\\n            \\n            if(!isPeak){\\n                i++;\\n                continue;\\n            }\\n            \\n            int leftIdx = i - 2;\\n            while(leftIdx >=0 && array[leftIdx] < array[leftIdx + 1]){\\n                leftIdx--;\\n            }\\n            \\n            int rightIdx = i + 2;\\n            while(rightIdx < array.length && array[rightIdx - 1] > array[rightIdx]){\\n                rightIdx++;\\n            }\\n            \\n            int currentLength = rightIdx - leftIdx - 1;\\n            if(currentLength > longestLength){\\n                longestLength = currentLength;\\n            }\\n            i = rightIdx;\\n        }\\n        return longestLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749845,
                "title": "python-3-explanation",
                "content": "* Iterate through `A` and look for a mountain \\'peak\\', that is, where the numbers **either side of the current number** are less than the current number.\\n* Once we find a peak, we set two pointers `left` and `right` to start from the current index `i`.\\n\\t* These two pointers will \\'descend\\' down the mountain until either:\\n\\t1. They go out of range of `A`.\\n\\t2. The downward slope of the mountain stops.\\n* Once we have gotten to the base of the current mountain spanning outwards from index `i`, we find the `mountainLength` by taking the difference of `right` and `left` and add one to count the peak as well.\\n```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        longestMountain = 0\\n\\n        for i in range(1, len(A) - 1):\\n            # Index i denotes a \\'peak\\' in the mountain.\\n            if A[i - 1] < A[i] > A[i + 1]:\\n                left = right = i\\n                \\n                # Traverse left and down the mountain from i until there is no longer a downwards slope.\\n                while left > 0 and A[left - 1] < A[left]:\\n                    left -= 1\\n                                \\n                # Traverse right and down the mountain from i until there is no longer a downwards slope.\\n                while right + 1 < len(A) and A[right + 1] < A[right]:\\n                    right += 1\\n                    \\n                # The length of the mountain will be the distance from left and right (+ 1 to factor in the peak).\\n                mountainLength = right - left + 1\\n                longestMountain = max(longestMountain, mountainLength)\\n        \\n        return longestMountain\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestMountain(self, A: List[int]) -> int:\\n        if len(A) < 3:\\n            return 0\\n        \\n        longestMountain = 0\\n\\n        for i in range(1, len(A) - 1):\\n            # Index i denotes a \\'peak\\' in the mountain.\\n            if A[i - 1] < A[i] > A[i + 1]:\\n                left = right = i\\n                \\n                # Traverse left and down the mountain from i until there is no longer a downwards slope.\\n                while left > 0 and A[left - 1] < A[left]:\\n                    left -= 1\\n                                \\n                # Traverse right and down the mountain from i until there is no longer a downwards slope.\\n                while right + 1 < len(A) and A[right + 1] < A[right]:\\n                    right += 1\\n                    \\n                # The length of the mountain will be the distance from left and right (+ 1 to factor in the peak).\\n                mountainLength = right - left + 1\\n                longestMountain = max(longestMountain, mountainLength)\\n        \\n        return longestMountain\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1773841,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1737004,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1801992,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1970341,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1959957,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1950953,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            },
            {
                "id": 1861077,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Tip : Try to think it as Longest Biotonic Subarray.\\nUse the concept of Longest Increasing Subarray and Longest Decreasing Subarray to find the longest mountain in array."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "So hard... edge cases are SOOOO annoying..."
                    },
                    {
                        "username": "Sakettiwari",
                        "content": "Check these cases !\nThank me later ;)\nUPVOTE IF IT HELPED\n\n[0,2,0,0,2,0,2,1,1,0,2,1,0,0,1,0,2,1,2,0,1,1,0,2,2,1,2,2,0,0,0,1,0,2,0,0,1,2,0,1,0,2,0,2,0,0,0,0,2,1,0,0,0,0,1,0,2,1,2,2,1,0,0,1,0,2,0,0,0,2,1,0,1,2,1,0,1,0,2,1,0,2,0,2,1,1,2,0,1,0,1,1,1,1,2,1,2,2,2,0]\n\n\n[0,1,2,0]\n\n[875,884,239,731,723,685]\n\n[2,3,1,2,3,4,5,6]\n\n[0]\n\n[1,2,3,4,5]\n\n[5,4,3,2,1]\n\n[0,1,2,3,4,5,4,3,2,1,0]\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Nice work"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "The edge cases were a bit tedious to address but I\\'m surprised I managed to solve the initial code relatively quickly!"
                    },
                    {
                        "username": "HARSH_252525",
                        "content": "just traverse an array/vector and check for lower and greater conditions given in question(check for mountain) and simply take two counters one for each subarray that satisfy given condition and one for final answer"
                    },
                    {
                        "username": "spookie886",
                        "content": "Hate to be that guy but this should be an easy problem"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Try these :- \\n\\n[0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,1]\\n\\n[5770,9921,1853,441,6808,8847,9186,3091,1524,2415]\\n\\n[0,2,0,2,1,2,3,4,4,1]"
                    }
                ]
            }
        ]
    }
]