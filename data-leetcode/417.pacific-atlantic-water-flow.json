[
    {
        "title": "Pacific Atlantic Water Flow",
        "question_content": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\nThe island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\nReturn a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.\n&nbsp;\nExample 1:\n\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n&nbsp;      [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n&nbsp;      [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n&nbsp;      [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n&nbsp;      [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n&nbsp;      [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n&nbsp;      [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\nExample 2:\n\nInput: heights = [[1]]\nOutput: [[0,0]]\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\n\n&nbsp;\nConstraints:\n\n\tm == heights.length\n\tn == heights[r].length\n\t1 <= m, n <= 200\n\t0 <= heights[r][c] <= 105",
        "solutions": [
            {
                "id": 90733,
                "title": "java-bfs-dfs-from-ocean",
                "content": "1. Two Queue and add all the Pacific border to one queue; Atlantic border to another queue.\\n2. Keep a visited matrix for each queue. In the end, add the cell visited by two queue to the result.\\nBFS: Water flood from ocean to the cell. Since water can only flow from high/equal cell to low cell, add the neighboor cell with height larger or equal to current cell to the queue and mark as visited.\\n```\\npublic class Solution {\\n    int[][]dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new LinkedList<>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return res;\\n        }\\n        int n = matrix.length, m = matrix[0].length;\\n        //One visited map for each ocean\\n        boolean[][] pacific = new boolean[n][m];\\n        boolean[][] atlantic = new boolean[n][m];\\n        Queue<int[]> pQueue = new LinkedList<>();\\n        Queue<int[]> aQueue = new LinkedList<>();\\n        for(int i=0; i<n; i++){ //Vertical border\\n            pQueue.offer(new int[]{i, 0});\\n            aQueue.offer(new int[]{i, m-1});\\n            pacific[i][0] = true;\\n            atlantic[i][m-1] = true;\\n        }\\n        for(int i=0; i<m; i++){ //Horizontal border\\n            pQueue.offer(new int[]{0, i});\\n            aQueue.offer(new int[]{n-1, i});\\n            pacific[0][i] = true;\\n            atlantic[n-1][i] = true;\\n        }\\n        bfs(matrix, pQueue, pacific);\\n        bfs(matrix, aQueue, atlantic);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(pacific[i][j] && atlantic[i][j])\\n                    res.add(new int[]{i,j});\\n            }\\n        }\\n        return res;\\n    }\\n    public void bfs(int[][]matrix, Queue<int[]> queue, boolean[][]visited){\\n        int n = matrix.length, m = matrix[0].length;\\n        while(!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n            for(int[] d:dir){\\n                int x = cur[0]+d[0];\\n                int y = cur[1]+d[1];\\n                if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < matrix[cur[0]][cur[1]]){\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y});\\n            } \\n        }\\n    }\\n}\\n````\\nDFS version:\\n```\\npublic class Solution {\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new LinkedList<>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return res;\\n        }\\n        int n = matrix.length, m = matrix[0].length;\\n        boolean[][]pacific = new boolean[n][m];\\n        boolean[][]atlantic = new boolean[n][m];\\n        for(int i=0; i<n; i++){\\n            dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);\\n            dfs(matrix, atlantic, Integer.MIN_VALUE, i, m-1);\\n        }\\n        for(int i=0; i<m; i++){\\n            dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);\\n            dfs(matrix, atlantic, Integer.MIN_VALUE, n-1, i);\\n        }\\n        for (int i = 0; i < n; i++) \\n            for (int j = 0; j < m; j++) \\n                if (pacific[i][j] && atlantic[i][j]) \\n                    res.add(new int[] {i, j});\\n        return res;\\n    }\\n    \\n    int[][]dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    public void dfs(int[][]matrix, boolean[][]visited, int height, int x, int y){\\n        int n = matrix.length, m = matrix[0].length;\\n        if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < height)\\n            return;\\n        visited[x][y] = true;\\n        for(int[]d:dir){\\n            dfs(matrix, visited, matrix[x][y], x+d[0], y+d[1]);\\n        }\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[][]dir = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new LinkedList<>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return res;\\n        }\\n        int n = matrix.length, m = matrix[0].length;\\n        //One visited map for each ocean\\n        boolean[][] pacific = new boolean[n][m];\\n        boolean[][] atlantic = new boolean[n][m];\\n        Queue<int[]> pQueue = new LinkedList<>();\\n        Queue<int[]> aQueue = new LinkedList<>();\\n        for(int i=0; i<n; i++){ //Vertical border\\n            pQueue.offer(new int[]{i, 0});\\n            aQueue.offer(new int[]{i, m-1});\\n            pacific[i][0] = true;\\n            atlantic[i][m-1] = true;\\n        }\\n        for(int i=0; i<m; i++){ //Horizontal border\\n            pQueue.offer(new int[]{0, i});\\n            aQueue.offer(new int[]{n-1, i});\\n            pacific[0][i] = true;\\n            atlantic[n-1][i] = true;\\n        }\\n        bfs(matrix, pQueue, pacific);\\n        bfs(matrix, aQueue, atlantic);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(pacific[i][j] && atlantic[i][j])\\n                    res.add(new int[]{i,j});\\n            }\\n        }\\n        return res;\\n    }\\n    public void bfs(int[][]matrix, Queue<int[]> queue, boolean[][]visited){\\n        int n = matrix.length, m = matrix[0].length;\\n        while(!queue.isEmpty()){\\n            int[] cur = queue.poll();\\n            for(int[] d:dir){\\n                int x = cur[0]+d[0];\\n                int y = cur[1]+d[1];\\n                if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < matrix[cur[0]][cur[1]]){\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y});\\n            } \\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new LinkedList<>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return res;\\n        }\\n        int n = matrix.length, m = matrix[0].length;\\n        boolean[][]pacific = new boolean[n][m];\\n        boolean[][]atlantic = new boolean[n][m];\\n        for(int i=0; i<n; i++){\\n            dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);\\n            dfs(matrix, atlantic, Integer.MIN_VALUE, i, m-1);\\n        }\\n        for(int i=0; i<m; i++){\\n            dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);\\n            dfs(matrix, atlantic, Integer.MIN_VALUE, n-1, i);\\n        }\\n        for (int i = 0; i < n; i++) \\n            for (int j = 0; j < m; j++) \\n                if (pacific[i][j] && atlantic[i][j]) \\n                    res.add(new int[] {i, j});\\n        return res;\\n    }\\n    \\n    int[][]dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n    \\n    public void dfs(int[][]matrix, boolean[][]visited, int height, int x, int y){\\n        int n = matrix.length, m = matrix[0].length;\\n        if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < height)\\n            return;\\n        visited[x][y] = true;\\n        for(int[]d:dir){\\n            dfs(matrix, visited, matrix[x][y], x+d[0], y+d[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90758,
                "title": "not-understanding-the-problem-could-someone-please-explain",
                "content": "Hi Guys,\\n\\nSorry for the noob question. I actually don't understand the problem very well. Where I am not understanding the problem is that, in the matrix given in the problem, if the water can flow only in 4 directions, why is it spilling diagonally to 2nd row 3rd column (5)? How is water going from (5) -> (7)? \\n\\nCould someone please help me understand the problem? \\n\\nThank you! \\n\\n```java\\nGiven the following 5x5 matrix:\\n\\n  Pacific ~   ~   ~   ~   ~ \\n       ~  1   2   2   3  (5) *\\n       ~  3   2   3  (4) (4) *\\n       ~  2   4  (5)  3   1  *\\n       ~ (6) (7)  1   4   5  *\\n       ~ (5)  1   1   2   4  *\\n          *   *   *   *   * Atlantic\\n\\nReturn:\\n\\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).```",
                "solutionTags": [],
                "code": "```java\\nGiven the following 5x5 matrix:\\n\\n  Pacific ~   ~   ~   ~   ~ \\n       ~  1   2   2   3  (5) *\\n       ~  3   2   3  (4) (4) *\\n       ~  2   4  (5)  3   1  *\\n       ~ (6) (7)  1   4   5  *\\n       ~ (5)  1   1   2   4  *\\n          *   *   *   *   * Atlantic\\n\\nReturn:\\n\\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126938,
                "title": "short-easy-w-explanation-diagrams-simple-graph-traversals-dfs-bfs",
                "content": "In a naive approach, we would have to consider each cell and find if it is reachable to both the oceans by checking if it is able to reach - **1.** top or left edge(atlantic) and,  **2.** bottom or right edge (pacific). This would take about **`O((mn)^2)`**, which is not efficient.\\n\\n***Solution - I (DFS Traversal)***\\n\\nI will try to explain the process using images provided in LC solution.\\n\\nWe can observe that there are these cells which can reach -\\n\\n* None \\n* Pacific\\n* Atlantic\\n* Both Pacific and Atlantic\\n\\n\\nWe need only the cells satisfying the last condition above.\\n\\n\\nNow, if we start from the cells connected to altantic ocean and visit all cells having height greater than current cell (**water can only flow from a cell to another one with height equal or lower**), we are able to reach some subset of cells (let\\'s call them **`A`**).\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/7fe6657a-4bc1-4d68-8a26-befe6e106371_1616674367.2859244.png\" align=\"center\" width=\"500\"/></p>\\n\\n\\n\\nNext, we start from the cells connected to pacific ocean and repeat the same process, we find another subset (let\\'s call this one **`B`**).\\n\\n<p align=\"center\"><img src=\"https://assets.leetcode.com/users/images/ef3a788b-7b66-4c70-a47c-58490b998177_1616674843.2320118.png\" align=\"center\" width=\"500\"/></p>\\n\\n\\nThe final answer we get will be the intersection of sets `A` and `B` (**`A \\u2229 B`**).\\n\\n<p align=\"center\"><img src=\"https://assets.leetcode.com/users/images/6a9f7a1f-105e-4d6c-8e7c-ede3a2f9b6de_1616674967.7329113.png\" align=\"center\" width=\"500\"/></p>\\n\\nSo, we just need to iterate from edge cells, find cells reachable from atlantic (set `A`), cells reachable from pacific (set `B`) and return their intersection. This can be done using DFS or BFS graph traversals.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n\\t// denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool> > atlantic, pacific;\\n\\tvector<vector<int> > ans;    \\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n\\t\\t// perform dfs from all edge cells (ocean-connected cells)\\n        for(int i = 0; i < m; i++) dfs(mat, pacific, i, 0), dfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) dfs(mat, pacific, 0, i), dfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void dfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        if(visited[i][j]) return;\\n        visited[i][j] = true;\\n\\t\\t// if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});    \\n\\t\\t// dfs from current cell only if height of next cell is greater\\n/*\\u2B07\\uFE0F*/  if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) dfs(mat, visited, i + 1, j); \\n/*\\u2B06\\uFE0F*/  if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) dfs(mat, visited, i - 1, j);\\n/*\\u27A1\\uFE0F*/  if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) dfs(mat, visited, i, j + 1); \\n/*\\u2B05\\uFE0F*/  if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) dfs(mat, visited, i, j - 1);\\n    }\\n};\\n```\\n\\n**Time Complexity :** **`O(M*N)`**, in worst case, all cells are reachable to both oceans and would be visited twice. This case can occur when all elements are equal.\\n**Space Complexity :** **`O(M*N)`**, to mark the atlantic and pacific visited cells.\\n\\n\\n---------\\n---------\\n\\n***Solution - II (BFS Traversal)***\\n\\nBelow is similar solution as above converted to **BFS traversal** -\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int> > ans;\\n    vector<vector<bool> > atlantic, pacific;\\n    queue<pair<int, int> > q;\\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n        for(int i = 0; i < m; i++) bfs(mat, pacific, i, 0), bfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) bfs(mat, pacific, 0, i), bfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void bfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        q.push({i, j});\\n        while(!q.empty()){\\n            tie(i, j) = q.front(); q.pop();\\n            if(visited[i][j]) continue;\\n            visited[i][j] = true;\\n            if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});\\n            if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) q.push({i + 1, j});\\n            if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) q.push({i - 1, j});\\n            if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) q.push({i, j + 1});\\n            if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) q.push({i, j - 1});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n\\t// denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool> > atlantic, pacific;\\n\\tvector<vector<int> > ans;    \\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n\\t\\t// perform dfs from all edge cells (ocean-connected cells)\\n        for(int i = 0; i < m; i++) dfs(mat, pacific, i, 0), dfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) dfs(mat, pacific, 0, i), dfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void dfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        if(visited[i][j]) return;\\n        visited[i][j] = true;\\n\\t\\t// if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});    \\n\\t\\t// dfs from current cell only if height of next cell is greater\\n/*\\u2B07\\uFE0F*/  if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) dfs(mat, visited, i + 1, j); \\n/*\\u2B06\\uFE0F*/  if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) dfs(mat, visited, i - 1, j);\\n/*\\u27A1\\uFE0F*/  if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) dfs(mat, visited, i, j + 1); \\n/*\\u2B05\\uFE0F*/  if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) dfs(mat, visited, i, j - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int> > ans;\\n    vector<vector<bool> > atlantic, pacific;\\n    queue<pair<int, int> > q;\\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n        for(int i = 0; i < m; i++) bfs(mat, pacific, i, 0), bfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) bfs(mat, pacific, 0, i), bfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void bfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        q.push({i, j});\\n        while(!q.empty()){\\n            tie(i, j) = q.front(); q.pop();\\n            if(visited[i][j]) continue;\\n            visited[i][j] = true;\\n            if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});\\n            if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) q.push({i + 1, j});\\n            if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) q.push({i - 1, j});\\n            if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) q.push({i, j + 1});\\n            if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) q.push({i, j - 1});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90739,
                "title": "python-dfs-bests-85-tips-for-all-dfs-in-matrix-question",
                "content": "The DFS solution is straightforward. Starting from each point, and dfs its neighbor if the neighbor is equal or less than itself. And maintain two boolean matrix for two oceans, indicating an ocean can reach to that point or not. Finally go through all nodes again and see if it can be both reached by two oceans. The trick is if a node is already visited, no need to visited again. Otherwise it will reach the recursion limits.\\n\\nThis question is very similar to https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ And here are some common tips for this kind of question\\n1. init a directions var like `self.directions = [(1,0),(-1,0),(0,1),(0,-1)]` so that when you want to explore from a node, you can just do \\n```\\nfor direction in self.directions:\\n            x, y = i + direction[0], j + direction[1]\\n```\\n\\n2. this is a what I normally do for a dfs helper method for exploring a matrix\\n```\\ndef dfs(self, i, j, matrix, visited, m, n):\\n  if visited: \\n    # return or return a value\\n  for dir in self.directions:\\n    x, y = i + direction[0], j + direction[1]\\n        if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] <= matrix[i][j] (or a condition you want to skip this round):\\n           continue\\n        # do something like\\n        visited[i][j] = True\\n        # explore the next level like\\n        self.dfs(x, y, matrix, visited, m, n)\\n```\\nHope it helps\\n\\n*Solution*\\n```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not matrix: return []\\n        self.directions = [(1,0),(-1,0),(0,1),(0,-1)]\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        p_visited = [[False for _ in range(n)] for _ in range(m)]\\n        \\n        a_visited = [[False for _ in range(n)] for _ in range(m)]\\n        result = []\\n        \\n        for i in range(m):\\n            # p_visited[i][0] = True\\n            # a_visited[i][n-1] = True\\n            self.dfs(matrix, i, 0, p_visited, m, n)\\n            self.dfs(matrix, i, n-1, a_visited, m, n)\\n        for j in range(n):\\n            # p_visited[0][j] = True\\n            # a_visited[m-1][j] = True\\n            self.dfs(matrix, 0, j, p_visited, m, n)\\n            self.dfs(matrix, m-1, j, a_visited, m, n)\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if p_visited[i][j] and a_visited[i][j]:\\n                    result.append([i,j])\\n        return result\\n                \\n                \\n    def dfs(self, matrix, i, j, visited, m, n):\\n        # when dfs called, meaning its caller already verified this point \\n        visited[i][j] = True\\n        for dir in self.directions:\\n            x, y = i + dir[0], j + dir[1]\\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or matrix[x][y] < matrix[i][j]:\\n                continue\\n            self.dfs(matrix, x, y, visited, m, n)\\n# 113 / 113 test cases passed.\\n# Runtime: 196 ms\\n```\\n\\n*Solution for longest increasing path in matrix*\\n```\\nclass Solution(object):\\n    def longestIncreasingPath(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix: return 0\\n        self.directions = [(1,0),(-1,0),(0,1),(0,-1)]\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        cache = [[-1 for _ in range(n)] for _ in range(m)]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                cur_len = self.dfs(i, j, matrix, cache, m, n)\\n                res = max(res, cur_len)\\n        return res\\n        \\n    def dfs(self, i, j, matrix, cache, m, n):\\n        if cache[i][j] != -1:\\n            return cache[i][j]\\n        res = 1\\n        for direction in self.directions:\\n            x, y = i + direction[0], j + direction[1]\\n            if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] <= matrix[i][j]:\\n                continue\\n            length = 1 + self.dfs(x, y, matrix, cache, m, n)\\n            res = max(length, res)\\n        cache[i][j] = res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfor direction in self.directions:\\n            x, y = i + direction[0], j + direction[1]\\n```\n```\\ndef dfs(self, i, j, matrix, visited, m, n):\\n  if visited: \\n    # return or return a value\\n  for dir in self.directions:\\n    x, y = i + direction[0], j + direction[1]\\n        if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] <= matrix[i][j] (or a condition you want to skip this round):\\n           continue\\n        # do something like\\n        visited[i][j] = True\\n        # explore the next level like\\n        self.dfs(x, y, matrix, visited, m, n)\\n```\n```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not matrix: return []\\n        self.directions = [(1,0),(-1,0),(0,1),(0,-1)]\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        p_visited = [[False for _ in range(n)] for _ in range(m)]\\n        \\n        a_visited = [[False for _ in range(n)] for _ in range(m)]\\n        result = []\\n        \\n        for i in range(m):\\n            # p_visited[i][0] = True\\n            # a_visited[i][n-1] = True\\n            self.dfs(matrix, i, 0, p_visited, m, n)\\n            self.dfs(matrix, i, n-1, a_visited, m, n)\\n        for j in range(n):\\n            # p_visited[0][j] = True\\n            # a_visited[m-1][j] = True\\n            self.dfs(matrix, 0, j, p_visited, m, n)\\n            self.dfs(matrix, m-1, j, a_visited, m, n)\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if p_visited[i][j] and a_visited[i][j]:\\n                    result.append([i,j])\\n        return result\\n                \\n                \\n    def dfs(self, matrix, i, j, visited, m, n):\\n        # when dfs called, meaning its caller already verified this point \\n        visited[i][j] = True\\n        for dir in self.directions:\\n            x, y = i + dir[0], j + dir[1]\\n            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or matrix[x][y] < matrix[i][j]:\\n                continue\\n            self.dfs(matrix, x, y, visited, m, n)\\n# 113 / 113 test cases passed.\\n# Runtime: 196 ms\\n```\n```\\nclass Solution(object):\\n    def longestIncreasingPath(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix: return 0\\n        self.directions = [(1,0),(-1,0),(0,1),(0,-1)]\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        cache = [[-1 for _ in range(n)] for _ in range(m)]\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                cur_len = self.dfs(i, j, matrix, cache, m, n)\\n                res = max(res, cur_len)\\n        return res\\n        \\n    def dfs(self, i, j, matrix, cache, m, n):\\n        if cache[i][j] != -1:\\n            return cache[i][j]\\n        res = 1\\n        for direction in self.directions:\\n            x, y = i + direction[0], j + direction[1]\\n            if x < 0 or x >= m or y < 0 or y >= n or matrix[x][y] <= matrix[i][j]:\\n                continue\\n            length = 1 + self.dfs(x, y, matrix, cache, m, n)\\n            res = max(length, res)\\n        cache[i][j] = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438276,
                "title": "python-beats-98-dfs-template-for-matrix",
                "content": "This is a DFS Template to solve matrix questions:\\n\\n```python\\ndef dfs(matrix):\\n    # 1. Check for an empty graph.\\n    if not matrix:\\n        return []\\n\\n    # 2. Initialize\\n    rows, cols = len(matrix), len(matrix[0])\\n    visited = set()\\n    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n\\n    def traverse(i, j):\\n        # a. Check if visited\\n        if (i, j) in visited:\\n            return\\n\\t\\t# b. Else add to visted\\n        visited.add((i, j))\\n\\n        # c. Traverse neighbors.\\n        for direction in directions:\\n            next_i, next_j = i + direction[0], j + direction[1]\\n            if 0 <= next_i < rows and 0 <= next_j < cols:\\n                # d. Add in your question-specific checks.\\n                traverse(next_i, next_j)\\n\\n    # 3. For each point, traverse it.\\n    for i in range(rows):\\n        for j in range(cols):\\n            traverse(i, j)\\n\\n```\\n\\nUse this template to addess the problem:\\n\\n```python\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        # Check for an empty graph.\\n        if not matrix:\\n            return []\\n\\n        p_visited = set()\\n        a_visited = set()\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n\\n        def traverse(i, j, visited):\\n            if (i, j) in visited:\\n                return\\n            visited.add((i, j))\\n            # Traverse neighbors.\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    # Add in your question-specific checks.\\n                    if matrix[next_i][next_j] >= matrix[i][j]:\\n                        traverse(next_i, next_j, visited)\\n\\n        for row in range(rows):\\n            traverse(row, 0, p_visited)\\n            traverse(row, cols - 1, a_visited)\\n\\n        for col in range(cols):\\n            traverse(0, col, p_visited)\\n            traverse(rows - 1, col, a_visited)\\n\\n        return list(p_visited & a_visited)\\n```\\n\\n> Your runtime beats 98.84 % of python3 submissions\\n\\n### Complexity Analysis:\\n- Time Complexity: since we keep a visited set for each ocean, we only visit a cell if it is not visited before. For each ocean, the worst case is `mn` thus totally `O(mn)`\\n\\n- Space Complexity: `O(2mn + h) = O(mn)`. \\n\\t- For each DFS we need `O(h)` space used by the system stack, where `h` is the maximum depth of the recursion. In the worst case, `O(h) = O(m*n)`.\\n\\t- Each visited set can have at maximum all cells from the matrix so `O(mn)`. Two ocean means `O(2mn)`. \\n\\n---\\n[329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)\\n\\n**Solution using the above template (LTE):**\\n\\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        # Check edge case\\n        if not matrix:\\n            return 0\\n\\n        # Initialize\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        visited = set()\\n        res = 0\\n\\n        def dfs(i, j, visited):\\n            # Check if visited\\n            if (i, j) in visited:\\n                return 0\\n\\t\\t\\tvisited.add((i, j))\\n            res = 1\\n\\n            # work with neighbors\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n\\n                # for each direction we try to find a new count\\n                direction_count = 0\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    if matrix[i][j] < matrix[next_i][next_j]:\\n                        direction_count = 1 + dfs(next_i, next_j, visited)\\n\\n                res = max(direction_count, res)\\n\\n            return res\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                res = max(dfs(row, col, visited), res)\\n\\n        return res\\n```\\n\\nTime Complexity: `O(mn*mn)`\\n\\n**Template with Memoization**\\n\\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        # Check edge case\\n        if not matrix:\\n            return 0\\n\\n        # Initialize\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        memo = [[-1] * cols for _ in range(rows)]\\n        res = 0\\n\\n        def dfs(i, j, visited):\\n            # Check if visited\\n            if memo[i][j] != -1:\\n                return memo[i][j]\\n\\n            res = 1\\n\\n            # work with neighbors\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n\\n                # for each direction we try to find a new count\\n                direction_count = 0\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    if matrix[i][j] < matrix[next_i][next_j]:\\n                        direction_count = 1 + dfs(next_i, next_j, visited)\\n\\n                res = max(direction_count, res)\\n\\n            memo[i][j] = res\\n            return res\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                res = max(dfs(row, col, memo), res)\\n\\n        return res\\n``` \\n\\n### Complexity Analysis:\\n- Time Complexity: `O(mn)` each cell is visited once.\\n\\n- Space Complexity: `O(mn + h) = O(mn)`. \\n\\t- For each DFS we need `O(h)` space used by the system stack, where `h` is the maximum depth of the recursion. In the worst case, `O(h) = O(m*n)`.\\n\\t- Each visited set can have at maximum all cells from the matrix so `O(mn)`\\n",
                "solutionTags": [],
                "code": "```python\\ndef dfs(matrix):\\n    # 1. Check for an empty graph.\\n    if not matrix:\\n        return []\\n\\n    # 2. Initialize\\n    rows, cols = len(matrix), len(matrix[0])\\n    visited = set()\\n    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n\\n    def traverse(i, j):\\n        # a. Check if visited\\n        if (i, j) in visited:\\n            return\\n\\t\\t# b. Else add to visted\\n        visited.add((i, j))\\n\\n        # c. Traverse neighbors.\\n        for direction in directions:\\n            next_i, next_j = i + direction[0], j + direction[1]\\n            if 0 <= next_i < rows and 0 <= next_j < cols:\\n                # d. Add in your question-specific checks.\\n                traverse(next_i, next_j)\\n\\n    # 3. For each point, traverse it.\\n    for i in range(rows):\\n        for j in range(cols):\\n            traverse(i, j)\\n\\n```\n```python\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        # Check for an empty graph.\\n        if not matrix:\\n            return []\\n\\n        p_visited = set()\\n        a_visited = set()\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n\\n        def traverse(i, j, visited):\\n            if (i, j) in visited:\\n                return\\n            visited.add((i, j))\\n            # Traverse neighbors.\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    # Add in your question-specific checks.\\n                    if matrix[next_i][next_j] >= matrix[i][j]:\\n                        traverse(next_i, next_j, visited)\\n\\n        for row in range(rows):\\n            traverse(row, 0, p_visited)\\n            traverse(row, cols - 1, a_visited)\\n\\n        for col in range(cols):\\n            traverse(0, col, p_visited)\\n            traverse(rows - 1, col, a_visited)\\n\\n        return list(p_visited & a_visited)\\n```\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        # Check edge case\\n        if not matrix:\\n            return 0\\n\\n        # Initialize\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        visited = set()\\n        res = 0\\n\\n        def dfs(i, j, visited):\\n            # Check if visited\\n            if (i, j) in visited:\\n                return 0\\n\\t\\t\\tvisited.add((i, j))\\n            res = 1\\n\\n            # work with neighbors\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n\\n                # for each direction we try to find a new count\\n                direction_count = 0\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    if matrix[i][j] < matrix[next_i][next_j]:\\n                        direction_count = 1 + dfs(next_i, next_j, visited)\\n\\n                res = max(direction_count, res)\\n\\n            return res\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                res = max(dfs(row, col, visited), res)\\n\\n        return res\\n```\n```python\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        # Check edge case\\n        if not matrix:\\n            return 0\\n\\n        # Initialize\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = ((0, 1), (0, -1), (-1, 0), (1, 0))\\n        memo = [[-1] * cols for _ in range(rows)]\\n        res = 0\\n\\n        def dfs(i, j, visited):\\n            # Check if visited\\n            if memo[i][j] != -1:\\n                return memo[i][j]\\n\\n            res = 1\\n\\n            # work with neighbors\\n            for direction in directions:\\n                next_i, next_j = i + direction[0], j + direction[1]\\n\\n                # for each direction we try to find a new count\\n                direction_count = 0\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    if matrix[i][j] < matrix[next_i][next_j]:\\n                        direction_count = 1 + dfs(next_i, next_j, visited)\\n\\n                res = max(direction_count, res)\\n\\n            memo[i][j] = res\\n            return res\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                res = max(dfs(row, col, memo), res)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743503,
                "title": "c-code-bfs-as-well-as-dfs-approach-simple-solution-runtime-20ms",
                "content": "\\u2714 ***All codes are running successfully !***\\n*if you find that this post to be helpful for you, So, please take out **one second** for single UPVOTE.* \\n\\n____\\n**1. DFS Approach :**\\n\\n> **Time Complexity :** **`O(M*N)`**, When worst case occur then all cells are reachable to both oceans and also visited twice.  And this will happened only when all elements are become equal.\\n> **Space Complexity :** **`O(M*N)`**, to mark the atlantic and pacific visited cells.\\n```\\nclass Solution {\\npublic:\\n    \\n    /// main logic or trick for this problem : bahar se andar ki taraf jao\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        vector<vector<int>>ans;\\n        int m = heights.size();\\n        int n = heights[0].size();\\n        \\n        vector<vector<bool>> pacific(m, vector<bool>(n));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n));\\n        \\n        for (int i = 0; i < m; i++) {\\n            \\n            dfs(heights, pacific, i, 0);\\n            dfs(heights, atlantic, i, n-1);\\n\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            \\n            dfs(heights, pacific, 0, j);\\n            dfs(heights, atlantic, m-1, j);\\n        }\\n\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (pacific[i][j] && atlantic[i][j]) // agar uss particular point se dono oceans mai jaa paa rahe hai\\n                    ans.push_back({i,j});           // toh answer push kardo\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& h, vector<vector<bool>>& vis, int i, int j) {\\n        \\n        int m = h.size();\\n        int n = h[0].size();\\n\\n        vis[i][j] = true;\\n        //up\\n        if (i-1 >= 0 && vis[i-1][j] != true && h[i-1][j] >= h[i][j])\\n            dfs(h, vis, i-1, j);\\n        //down\\n        if (i+1 < m && vis[i+1][j] != true && h[i+1][j] >= h[i][j])\\n            dfs(h, vis, i+1, j);\\n        //left\\n        if (j-1 >= 0 && vis[i][j-1] != true && h[i][j-1] >= h[i][j])\\n            dfs(h, vis, i, j-1);\\n        //right\\n        if (j+1 < n && vis[i][j+1] != true && h[i][j+1] >= h[i][j])\\n            dfs(h, vis, i, j+1);\\n\\n    }\\n};\\n```\\n\\n***\\n**2. BFS Approach :**\\n\\n> **Time Complexity :** **`O(M*N)`**, When worst case occur then all cells are reachable to both oceans and also visited twice. And this will happened only when all elements are become equal.\\n> **Space Complexity :** **`O(M*N)`**, to mark the atlantic and pacific visited cells.\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<int>dir={0,1,0,-1,0};\\n    queue<pair<int,int>> pac;\\n    queue<pair<int,int>> atl;\\n    \\n    bool isValid(int x, int y){\\n        return x>=0 && x<m && y>=0 && y<n;\\n    }\\n    \\n    // andar se bahar ki taraf jaa rahe hai\\n    void bfs(queue<pair<int,int>> &q, vector<vector<int>> &vis, vector<vector<int>>& matrix)\\n    {\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            vis[x][y]=1;\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int xx = x+dir[k];\\n                int yy = y+dir[k+1];\\n                if(isValid(xx,yy) && matrix[x][y] <= matrix[xx][yy] && vis[xx][yy]==0) // greater equal \\n                {\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n    }\\n    \\n        \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) \\n    {\\n        vector<vector<int>> ans;\\n        m=matrix.size();\\n        n=matrix[0].size();\\n \\n        vector<vector<int>> visp(m, vector<int>(n,0));\\n        vector<vector<int>> visq(m, vector<int>(n,0));\\n        // push boundaries of pacific ocean\\n        for(int i=m-1;i>=0;i--)\\n            pac.push({i,0});\\n        for(int i=n-1;i>=0;i--)\\n            pac.push({0,i});\\n        \\n        // push boundaries of atlantic ocean\\n        for(int i=m-1;i>=0;i--)\\n            atl.push({i,n-1});\\n        for(int i=n-1;i>=0;i--)\\n            atl.push({m-1,i});\\n        \\n        bfs(pac, visp, matrix);\\n        bfs(atl, visq, matrix);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(visp[i][j]==1 && visq[i][j]==1)\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**if you like my approach please don\\'t forget to hit the upvote button ! : )**\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /// main logic or trick for this problem : bahar se andar ki taraf jao\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        vector<vector<int>>ans;\\n        int m = heights.size();\\n        int n = heights[0].size();\\n        \\n        vector<vector<bool>> pacific(m, vector<bool>(n));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n));\\n        \\n        for (int i = 0; i < m; i++) {\\n            \\n            dfs(heights, pacific, i, 0);\\n            dfs(heights, atlantic, i, n-1);\\n\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            \\n            dfs(heights, pacific, 0, j);\\n            dfs(heights, atlantic, m-1, j);\\n        }\\n\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (pacific[i][j] && atlantic[i][j]) // agar uss particular point se dono oceans mai jaa paa rahe hai\\n                    ans.push_back({i,j});           // toh answer push kardo\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& h, vector<vector<bool>>& vis, int i, int j) {\\n        \\n        int m = h.size();\\n        int n = h[0].size();\\n\\n        vis[i][j] = true;\\n        //up\\n        if (i-1 >= 0 && vis[i-1][j] != true && h[i-1][j] >= h[i][j])\\n            dfs(h, vis, i-1, j);\\n        //down\\n        if (i+1 < m && vis[i+1][j] != true && h[i+1][j] >= h[i][j])\\n            dfs(h, vis, i+1, j);\\n        //left\\n        if (j-1 >= 0 && vis[i][j-1] != true && h[i][j-1] >= h[i][j])\\n            dfs(h, vis, i, j-1);\\n        //right\\n        if (j+1 < n && vis[i][j+1] != true && h[i][j+1] >= h[i][j])\\n            dfs(h, vis, i, j+1);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<int>dir={0,1,0,-1,0};\\n    queue<pair<int,int>> pac;\\n    queue<pair<int,int>> atl;\\n    \\n    bool isValid(int x, int y){\\n        return x>=0 && x<m && y>=0 && y<n;\\n    }\\n    \\n    // andar se bahar ki taraf jaa rahe hai\\n    void bfs(queue<pair<int,int>> &q, vector<vector<int>> &vis, vector<vector<int>>& matrix)\\n    {\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            vis[x][y]=1;\\n            q.pop();\\n            for(int k=0;k<4;k++)\\n            {\\n                int xx = x+dir[k];\\n                int yy = y+dir[k+1];\\n                if(isValid(xx,yy) && matrix[x][y] <= matrix[xx][yy] && vis[xx][yy]==0) // greater equal \\n                {\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n    }\\n    \\n        \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) \\n    {\\n        vector<vector<int>> ans;\\n        m=matrix.size();\\n        n=matrix[0].size();\\n \\n        vector<vector<int>> visp(m, vector<int>(n,0));\\n        vector<vector<int>> visq(m, vector<int>(n,0));\\n        // push boundaries of pacific ocean\\n        for(int i=m-1;i>=0;i--)\\n            pac.push({i,0});\\n        for(int i=n-1;i>=0;i--)\\n            pac.push({0,i});\\n        \\n        // push boundaries of atlantic ocean\\n        for(int i=m-1;i>=0;i--)\\n            atl.push({i,n-1});\\n        for(int i=n-1;i>=0;i--)\\n            atl.push({m-1,i});\\n        \\n        bfs(pac, visp, matrix);\\n        bfs(atl, visq, matrix);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(visp[i][j]==1 && visq[i][j]==1)\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90747,
                "title": "very-concise-c-solution-using-dfs-and-bit-mask",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> res;\\n    vector<vector<int>> visited;\\n    void dfs(vector<vector<int>>& matrix, int x, int y, int pre, int preval){\\n        if (x < 0 || x >= matrix.size() || y < 0 || y >= matrix[0].size()  \\n                || matrix[x][y] < pre || (visited[x][y] & preval) == preval) \\n            return;\\n        visited[x][y] |= preval;\\n        if (visited[x][y] == 3) res.push_back({x, y});\\n        dfs(matrix, x + 1, y, matrix[x][y], visited[x][y]); dfs(matrix, x - 1, y, matrix[x][y], visited[x][y]);\\n        dfs(matrix, x, y + 1, matrix[x][y], visited[x][y]); dfs(matrix, x, y - 1, matrix[x][y], visited[x][y]);\\n    }\\n\\n    vector<pair<int, int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        if (matrix.empty()) return res;\\n        int m = matrix.size(), n = matrix[0].size();\\n        visited.resize(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            dfs(matrix, i, 0, INT_MIN, 1);\\n            dfs(matrix, i, n - 1, INT_MIN, 2);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dfs(matrix, 0, i, INT_MIN, 1);\\n            dfs(matrix, m - 1, i, INT_MIN, 2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> res;\\n    vector<vector<int>> visited;\\n    void dfs(vector<vector<int>>& matrix, int x, int y, int pre, int preval){\\n        if (x < 0 || x >= matrix.size() || y < 0 || y >= matrix[0].size()  \\n                || matrix[x][y] < pre || (visited[x][y] & preval) == preval) \\n            return;\\n        visited[x][y] |= preval;\\n        if (visited[x][y] == 3) res.push_back({x, y});\\n        dfs(matrix, x + 1, y, matrix[x][y], visited[x][y]); dfs(matrix, x - 1, y, matrix[x][y], visited[x][y]);\\n        dfs(matrix, x, y + 1, matrix[x][y], visited[x][y]); dfs(matrix, x, y - 1, matrix[x][y], visited[x][y]);\\n    }\\n\\n    vector<pair<int, int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        if (matrix.empty()) return res;\\n        int m = matrix.size(), n = matrix[0].size();\\n        visited.resize(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            dfs(matrix, i, 0, INT_MIN, 1);\\n            dfs(matrix, i, n - 1, INT_MIN, 2);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dfs(matrix, 0, i, INT_MIN, 1);\\n            dfs(matrix, m - 1, i, INT_MIN, 2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507304,
                "title": "java-easy-solution-using-dfs-91-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int rows = heights.length, cols = heights[0].length;\\n        boolean[][] pac = new boolean[rows][cols];\\n        boolean[][] atl = new boolean[rows][cols];\\n        \\n        for (int col = 0; col< cols; col++){\\n            dfs(0, col, rows, cols, pac, heights[0][col], heights);\\n            dfs(rows-1, col,rows, cols, atl, heights[rows-1][col], heights);\\n        }\\n        for (int row = 0; row<rows; row++){\\n            dfs(row, 0,rows, cols, pac, heights[row][0], heights);\\n            dfs(row, cols-1,rows, cols, atl, heights[row][cols-1], heights);\\n        }\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for (int i = 0; i < rows; i++)\\n            for (int j = 0; j < cols; j++){\\n                if (pac[i][j] && atl[i][j])\\n                    result.add(Arrays.asList(i,j));\\n            }\\n        return result;\\n    }\\n    private void dfs(int row, int col, int rows, int cols, boolean[][] visited, int prevHeight, int[][] heights){\\n        if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col] || prevHeight > heights[row][col])\\n            return;\\n        visited[row][col]= true;\\n        dfs(row+1, col, rows, cols, visited, heights[row][col], heights);\\n        dfs(row-1, col, rows, cols, visited, heights[row][col], heights);\\n        dfs(row, col+1, rows, cols, visited, heights[row][col], heights);\\n        dfs(row, col-1, rows, cols, visited, heights[row][col], heights);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int rows = heights.length, cols = heights[0].length;\\n        boolean[][] pac = new boolean[rows][cols];\\n        boolean[][] atl = new boolean[rows][cols];\\n        \\n        for (int col = 0; col< cols; col++){\\n            dfs(0, col, rows, cols, pac, heights[0][col], heights);\\n            dfs(rows-1, col,rows, cols, atl, heights[rows-1][col], heights);\\n        }\\n        for (int row = 0; row<rows; row++){\\n            dfs(row, 0,rows, cols, pac, heights[row][0], heights);\\n            dfs(row, cols-1,rows, cols, atl, heights[row][cols-1], heights);\\n        }\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        for (int i = 0; i < rows; i++)\\n            for (int j = 0; j < cols; j++){\\n                if (pac[i][j] && atl[i][j])\\n                    result.add(Arrays.asList(i,j));\\n            }\\n        return result;\\n    }\\n    private void dfs(int row, int col, int rows, int cols, boolean[][] visited, int prevHeight, int[][] heights){\\n        if (row < 0 || row >= rows || col < 0 || col >= cols || visited[row][col] || prevHeight > heights[row][col])\\n            return;\\n        visited[row][col]= true;\\n        dfs(row+1, col, rows, cols, visited, heights[row][col], heights);\\n        dfs(row-1, col, rows, cols, visited, heights[row][col], heights);\\n        dfs(row, col+1, rows, cols, visited, heights[row][col], heights);\\n        dfs(row, col-1, rows, cols, visited, heights[row][col], heights);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126782,
                "title": "python-simple-bfs-explained",
                "content": "Let us reverse logic in this problem. Instead of looking for places from which one or another ocean can be reached, we will start from ocean and move in **increasing** way, not decreasing. So, we do the following\\n1. Start from `pacific` ocean: all nodes with one of coordinates equal to `0`, and perform `bfs` from all these cells: we put them into queue and then as usual popleft element and add its neigbours if we can: that is we did not visit it yet, and such that new value is more or equal to the old one. In the end my function return all visited cells.\\n2. Start from `atlantic` ocean and do exactly the same logic.\\n3. Finally, intersect two sets we get on previous two steps and return it (even though it is set, not list, leetcode allows to do it)\\n\\n**Complexity**: time and space complexity is `O(mn)`: we perform bfs twice and then did intersection of sets.\\n\\n```\\nclass Solution:\\n    def pacificAtlantic(self, M):\\n        if not M or not M[0]: return []\\n        \\n        m, n = len(M[0]), len(M)\\n        def bfs(starts):\\n            queue = deque(starts)\\n            visited = set(starts)\\n            while queue:\\n                x, y = queue.popleft()\\n                for dx, dy in [(x, y+1), (x, y-1), (x-1, y), (x+1, y)]:\\n                    if 0 <= dx < n and 0 <= dy < m and (dx, dy) not in visited and M[dx][dy] >= M[x][y]:\\n                        queue.append((dx, dy))\\n                        visited.add((dx, dy))\\n                        \\n            return visited\\n        \\n        pacific  = [(0, i) for i in range(m)]   + [(i, 0) for i in range(1,n)]\\n        atlantic = [(n-1, i) for i in range(m)] + [(i, m-1) for i in range(n-1)]\\n        \\n        return bfs(pacific) & bfs(atlantic)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, M):\\n        if not M or not M[0]: return []\\n        \\n        m, n = len(M[0]), len(M)\\n        def bfs(starts):\\n            queue = deque(starts)\\n            visited = set(starts)\\n            while queue:\\n                x, y = queue.popleft()\\n                for dx, dy in [(x, y+1), (x, y-1), (x-1, y), (x+1, y)]:\\n                    if 0 <= dx < n and 0 <= dy < m and (dx, dy) not in visited and M[dx][dy] >= M[x][y]:\\n                        queue.append((dx, dy))\\n                        visited.add((dx, dy))\\n                        \\n            return visited\\n        \\n        pacific  = [(0, i) for i in range(m)]   + [(i, 0) for i in range(1,n)]\\n        atlantic = [(n-1, i) for i in range(m)] + [(i, m-1) for i in range(n-1)]\\n        \\n        return bfs(pacific) & bfs(atlantic)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90764,
                "title": "python-solution-using-bfs-and-sets",
                "content": "```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        if not matrix: return []\\n        m, n = len(matrix), len(matrix[0])\\n        def bfs(reachable_ocean):\\n            q = collections.deque(reachable_ocean)\\n            while q:\\n                (i, j) = q.popleft()\\n                for (di, dj) in [(0,1), (0, -1), (1, 0), (-1, 0)]:\\n                    if 0 <= di+i < m and 0 <= dj+j < n and (di+i, dj+j) not in reachable_ocean \\\\\\n                        and matrix[di+i][dj+j] >= matrix[i][j]:\\n                        q.append( (di+i,dj+j) )\\n                        reachable_ocean.add( (di+i, dj+j) )\\n            return reachable_ocean         \\n        pacific  =set ( [ (i, 0) for i in range(m)]   + [(0, j) for j  in range(1, n)]) \\n        atlantic =set ( [ (i, n-1) for i in range(m)] + [(m-1, j) for j in range(n-1)]) \\n        return list( bfs(pacific) & bfs(atlantic) )\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        if not matrix: return []\\n        m, n = len(matrix), len(matrix[0])\\n        def bfs(reachable_ocean):\\n            q = collections.deque(reachable_ocean)\\n            while q:\\n                (i, j) = q.popleft()\\n                for (di, dj) in [(0,1), (0, -1), (1, 0), (-1, 0)]:\\n                    if 0 <= di+i < m and 0 <= dj+j < n and (di+i, dj+j) not in reachable_ocean \\\\\\n                        and matrix[di+i][dj+j] >= matrix[i][j]:\\n                        q.append( (di+i,dj+j) )\\n                        reachable_ocean.add( (di+i, dj+j) )\\n            return reachable_ocean         \\n        pacific  =set ( [ (i, 0) for i in range(m)]   + [(0, j) for j  in range(1, n)]) \\n        atlantic =set ( [ (i, n-1) for i in range(m)] + [(m-1, j) for j in range(n-1)]) \\n        return list( bfs(pacific) & bfs(atlantic) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114904,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<pair<int, int>> r;\\n        int m = matrix.size();\\n        if (m == 0)\\n            return r;\\n        int n = matrix[0].size();\\n        if (n == 0)\\n            return r;\\n        vector<vector<bool>> pacific(m, vector<bool>(n));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n));\\n        \\n        for (int i = 0; i < m; i++) {\\n            dfs(matrix, pacific, i, 0);\\n            dfs(matrix, atlantic, i, n-1);\\n\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dfs(matrix, pacific, 0, j);\\n            dfs(matrix, atlantic, m-1, j);\\n        }\\n\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] && atlantic[i][j])\\n                    r.push_back(make_pair(i,j));\\n            }\\n        }\\n        return r;\\n    }\\n    \\n    void dfs(vector<vector<int>>& matrix, vector<vector<bool>>& visited, int i, int j) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        visited[i][j] = true;\\n        //up\\n        if (i-1 >= 0 && visited[i-1][j] != true && matrix[i-1][j]>=matrix[i][j])\\n            dfs(matrix, visited, i-1, j);\\n        //down\\n        if (i+1 < m && visited[i+1][j] != true && matrix[i+1][j]>=matrix[i][j])\\n            dfs(matrix, visited, i+1, j);\\n        //left\\n        if (j-1 >= 0 && visited[i][j-1] != true && matrix[i][j-1]>=matrix[i][j])\\n            dfs(matrix, visited, i, j-1);\\n        //right\\n        if (j+1 <n && visited[i][j+1] != true && matrix[i][j+1]>=matrix[i][j])\\n            dfs(matrix, visited, i, j+1);\\n\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<pair<int, int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<pair<int, int>> r;\\n        int m = matrix.size();\\n        if (m == 0)\\n            return r;\\n        int n = matrix[0].size();\\n        if (n == 0)\\n            return r;\\n        vector<vector<bool>> pacific(m, vector<bool>(n));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n));\\n        \\n        for (int i = 0; i < m; i++) {\\n            dfs(matrix, pacific, i, 0);\\n            dfs(matrix, atlantic, i, n-1);\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 264494,
                "title": "python-very-concise-solution-using-dfs-set-128ms",
                "content": "```python\\ndef pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n    if not matrix:\\n        return []\\n    p_land = set()\\n    a_land = set()\\n    R, C = len(matrix), len(matrix[0])\\n    def spread(i, j, land):\\n        land.add((i, j))\\n        for x, y in ((i+1, j), (i, j+1), (i-1, j), (i, j-1)):\\n            if (0<=x<R and 0<=y<C and matrix[x][y] >= matrix[i][j]\\n                    and (x, y) not in land):\\n                spread(x, y, land)\\n                \\n    for i in range(R):\\n        spread(i, 0, p_land)\\n        spread(i, C-1, a_land)\\n    for j in range(C):\\n        spread(0, j, p_land)\\n        spread(R-1, j, a_land)\\n    return list(p_land & a_land)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```python\\ndef pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n    if not matrix:\\n        return []\\n    p_land = set()\\n    a_land = set()\\n    R, C = len(matrix), len(matrix[0])\\n    def spread(i, j, land):\\n        land.add((i, j))\\n        for x, y in ((i+1, j), (i, j+1), (i-1, j), (i, j-1)):\\n            if (0<=x<R and 0<=y<C and matrix[x][y] >= matrix[i][j]\\n                    and (x, y) not in land):\\n                spread(x, y, land)\\n                \\n    for i in range(R):\\n        spread(i, 0, p_land)\\n        spread(i, C-1, a_land)\\n    for j in range(C):\\n        spread(0, j, p_land)\\n        spread(R-1, j, a_land)\\n    return list(p_land & a_land)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2507246,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nWe need to count the number of cells from which waer could flow to both the oceans.\\nWater can go to **left,top** for pacific and to **right,down** for atlantic.\\n\\n**APPROACH**\\n\\nWe just do what is asked for.\\n\\nWhen at cell ```ht[i][j]``` :\\n* we check that water can flow to **left,top** and also to **right,down**.\\n* It is similar to finding a path with non-increasing values.\\n* To prevent repeation, we use memoization to store the result for certain ```ht[i][j]```.\\n\\n*How memoization helps :*\\n* Let water can flow to both oceans from cell ```ht[i][j]```, so while checking for its adjacent cells, we need not find the complete path to oceans, **we just find a path that leads to a cell that reaches both oceans.**\\n\\n**Finding water can reach both oceans :**\\n* As we going for memoization, we create two ```vector<vector<bool>>``` that stores that whether water can flow to ocean for each ocean respectively.\\n* For pacific, we created ```pac``` and water initially water can flow for top and left cells.\\n* For atlanic, we created ```atl``` and water initially water can flow for bottom and right cells.\\n* Then for each cell, we check whether water flows off :\\n* * For cell ```ht[i][j]``` we recurcively call for its adjacent cells, if neightbouring height is less or equal to current cell.\\n* * Water can flow off if we reach a cell for which we already have solution.\\n* * * For pacific we already made top,left cells ```true``` and same for atlantic.\\n\\n* Whenever water reaches, make all cells in that path ```true``` so they need not to be calculated in future.\\n\\n\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    \\n    bool s(vector<vector<bool>>& ocean, int i, int j, vector<vector<int>>& ht){\\n        \\n        if (i<0 || j<0 || i==m || j==n || ht[i][j]==100004) return false;\\n        if (ocean[i][j]) return true;\\n        \\n        int k = ht[i][j];\\n        ht[i][j]=100004;\\n        bool zz = false;\\n        if (i>0 && ht[i-1][j]<=k)   zz = zz || s(ocean,i-1,j,ht);\\n        if (j>0 && ht[i][j-1]<=k)   zz = zz || s(ocean,i,j-1,ht);\\n        if (i<m-1 && ht[i+1][j]<=k) zz = zz || s(ocean,i+1,j,ht);\\n        if (j<n-1 && ht[i][j+1]<=k) zz = zz || s(ocean,i,j+1,ht);\\n        \\n        ocean[i][j]=zz;\\n        ht[i][j]=k;\\n        return zz;\\n        \\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& ht) {\\n        m = ht.size();\\n        n = ht[0].size();\\n        vector<vector<bool>> pac(m, vector<bool> (n,false));\\n        vector<vector<bool>> atl(m, vector<bool> (n,false));\\n        for (int i=0; i<m; i++){\\n            pac[i][0]=true;\\n            atl[i][n-1]=true;\\n        }\\n        for (int i=0; i<n; i++){\\n            pac[0][i]=true;\\n            atl[m-1][i]=true;\\n        }\\n        vector<vector<int>> res;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (s(pac,i,j,ht) && s(atl,i,j,ht)) res.push_back({i,j});\\n            }\\n        }return res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8cd20a0a-9ab1-456e-a5f3-69f05e67e3ed_1661908619.3639503.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```ht[i][j]```\n```ht[i][j]```\n```ht[i][j]```\n```vector<vector<bool>>```\n```pac```\n```atl```\n```ht[i][j]```\n```true```\n```true```\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    \\n    bool s(vector<vector<bool>>& ocean, int i, int j, vector<vector<int>>& ht){\\n        \\n        if (i<0 || j<0 || i==m || j==n || ht[i][j]==100004) return false;\\n        if (ocean[i][j]) return true;\\n        \\n        int k = ht[i][j];\\n        ht[i][j]=100004;\\n        bool zz = false;\\n        if (i>0 && ht[i-1][j]<=k)   zz = zz || s(ocean,i-1,j,ht);\\n        if (j>0 && ht[i][j-1]<=k)   zz = zz || s(ocean,i,j-1,ht);\\n        if (i<m-1 && ht[i+1][j]<=k) zz = zz || s(ocean,i+1,j,ht);\\n        if (j<n-1 && ht[i][j+1]<=k) zz = zz || s(ocean,i,j+1,ht);\\n        \\n        ocean[i][j]=zz;\\n        ht[i][j]=k;\\n        return zz;\\n        \\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& ht) {\\n        m = ht.size();\\n        n = ht[0].size();\\n        vector<vector<bool>> pac(m, vector<bool> (n,false));\\n        vector<vector<bool>> atl(m, vector<bool> (n,false));\\n        for (int i=0; i<m; i++){\\n            pac[i][0]=true;\\n            atl[i][n-1]=true;\\n        }\\n        for (int i=0; i<n; i++){\\n            pac[0][i]=true;\\n            atl[m-1][i]=true;\\n        }\\n        vector<vector<int>> res;\\n        for (int i=0; i<m; i++){\\n            for (int j=0; j<n; j++){\\n                if (s(pac,i,j,ht) && s(atl,i,j,ht)) res.push_back({i,j});\\n            }\\n        }return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126812,
                "title": "js-python-java-c-easy-dfs-recursion-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIt should be obvious from the start that we\\'ll need to solve this problem in reverse. We know that the edges of the input matrix (**M**) will flow water out to the ocean on their respective sides, and we can tell whether an adjacent cell will funnel water to the current cell, so we\\'ll have to start from the edges and work our way inward.\\n\\nUnfortunately, since the path the water will take can possibly wind around, we can\\'t do a straight one-time iteration. Instead, we\\'ll have to use a **depth first search** (**DFS**) approach with either a **stack**/**queue** structure or **recursion**.\\n\\nFor each cell that touches an ocean, we\\'ll have to follow the reverse path of the water up the continent as far as it will go. Since we only want cells that are reached by both oceans, we\\'ll need a data structure to store the preliminary data for the cells while we wait for the opposite ocean to potentially find the same cell.\\n\\nThere are a few ways we can do this, but I\\'ll choose a **dynamic programming** (**DP**) array (**dp**). Since there\\'s no real reason to mimic the **2-D matrix** structure of **M**, we can just use a flattened **1-D array** instead, which should save some processing overhead. In order to store both oceans\\' data discretely in **dp**, we can use **+1** for one and **+2** for the other. That means that when a cell goes to **3**, it should be added to our answer array (**ans**).\\n\\nOur DFS recursion function (**dfs**) should also check to make sure that we haven\\'t already marked this cell with the current ocean (**w**) by using a **bitwise AND** (**&**) operator. Then, at the end of **dfs** we should fire off new recursions in all four directions, if possible.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use the lighter, typed **Uint8Array** for **dp**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **100ms / 44.1MB** (beats 100% / 100%).\\n```javascript\\nvar pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **264ms / 15.6MB** (beats 97% / 53%).\\n```python\\nclass Solution:\\n    def pacificAtlantic(self, M: List[List[int]]) -> List[List[int]]:\\n        if not M: return M\\n        x, y = len(M[0]), len(M)\\n        ans, dp = [], [0] * (x * y)\\n        def dfs(i: int, j: int, w: int, h: int):\\n            ij = i * x + j\\n            if dp[ij] & w or M[i][j] < h: return\\n            dp[ij] += w\\n            h = M[i][j]\\n            if dp[ij] == 3: ans.append([i,j])\\n            if i + 1 < y: dfs(i+1, j, w, h)\\n            if i > 0: dfs(i-1, j, w, h)\\n            if j + 1 < x: dfs(i, j+1, w, h)\\n            if j > 0: dfs(i, j-1, w, h)\\n        for i in range(y):\\n            dfs(i, 0, 1, M[i][0])\\n            dfs(i, x-1, 2, M[i][x-1])\\n        for j in range(x):\\n            dfs(0, j, 1, M[0][j])\\n            dfs(y-1, j, 2, M[y-1][j])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 40.4MB** (beats 100% / 43%).\\n```java\\nclass Solution {\\n    static void dfs(int i, int j, int w, int h, int[][] M, byte[] dp, List<List<Integer>> ans) {\\n        int ij = i * M[0].length + j;\\n        if ((dp[ij] & w) > 0 || M[i][j] < h) return;\\n        dp[ij] += w;\\n        h = M[i][j];\\n        if (dp[ij] == 3) ans.add(Arrays.asList(i,j));\\n        if (i + 1 < M.length) dfs(i+1, j, w, h, M, dp, ans);\\n        if (i > 0) dfs(i-1, j, w, h, M, dp, ans);\\n        if (j + 1 < M[0].length) dfs(i, j+1, w, h, M, dp, ans);\\n        if (j > 0) dfs(i, j-1, w, h, M, dp, ans);\\n    }\\n    public List<List<Integer>> pacificAtlantic(int[][] M) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (M.length == 0) return ans;\\n        int y = M.length, x = M[0].length;\\n        byte[] dp = new byte[x * y];\\n        for (int i = 0; i < x; i++) {\\n            dfs(0, i, 1, M[0][i], M, dp, ans);\\n            dfs(y-1, i, 2, M[y-1][i], M, dp, ans);\\n        }   \\n        for (int i = 0; i < y; i++) {\\n            dfs(i, 0, 1, M[i][0], M, dp, ans);\\n            dfs(i, x-1, 2, M[i][x-1], M, dp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **24ms / 16.7MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        if (M.empty()) return ans;\\n        int y = M.size(), x = M[0].size();\\n        vector<char> dp(y * x);\\n        for (int i = 0; i < y; i++) {\\n            dfs(M, dp, i, 0, 1, 0);\\n            dfs(M, dp, i, x - 1, 2, 0);\\n        }\\n        for (int i = 0; i < x; i++) {\\n            dfs(M, dp, 0, i, 1, 0);\\n            dfs(M, dp, y - 1, i, 2, 0);\\n        }\\n        for (int i = 0; i < y; i++) \\n            for (int j = 0; j < x; j++) \\n                if (dp[i * x + j] == 3) \\n                    ans.push_back({i, j});\\n        return ans;\\n    }\\nprivate:\\n    void dfs(const vector<vector<int>>& M, vector<char>& dp, int i, int j, int w, int h) {\\n        int y = M.size(), x = M[0].size(), ij = i * x + j, newh = M[i][j];;\\n        if ((dp[ij] & w) || M[i][j] < h) return;\\n        dp[ij] += w;\\n        if (i + 1 < y) dfs(M, dp, i + 1, j, w, newh);\\n        if (i > 0) dfs(M, dp, i - 1, j, w, newh);\\n        if (j + 1 < x) dfs(M, dp, i, j + 1, w, newh);\\n        if (j > 0) dfs(M, dp, i, j - 1, w, newh);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def pacificAtlantic(self, M: List[List[int]]) -> List[List[int]]:\\n        if not M: return M\\n        x, y = len(M[0]), len(M)\\n        ans, dp = [], [0] * (x * y)\\n        def dfs(i: int, j: int, w: int, h: int):\\n            ij = i * x + j\\n            if dp[ij] & w or M[i][j] < h: return\\n            dp[ij] += w\\n            h = M[i][j]\\n            if dp[ij] == 3: ans.append([i,j])\\n            if i + 1 < y: dfs(i+1, j, w, h)\\n            if i > 0: dfs(i-1, j, w, h)\\n            if j + 1 < x: dfs(i, j+1, w, h)\\n            if j > 0: dfs(i, j-1, w, h)\\n        for i in range(y):\\n            dfs(i, 0, 1, M[i][0])\\n            dfs(i, x-1, 2, M[i][x-1])\\n        for j in range(x):\\n            dfs(0, j, 1, M[0][j])\\n            dfs(y-1, j, 2, M[y-1][j])\\n        return ans\\n```\n```java\\nclass Solution {\\n    static void dfs(int i, int j, int w, int h, int[][] M, byte[] dp, List<List<Integer>> ans) {\\n        int ij = i * M[0].length + j;\\n        if ((dp[ij] & w) > 0 || M[i][j] < h) return;\\n        dp[ij] += w;\\n        h = M[i][j];\\n        if (dp[ij] == 3) ans.add(Arrays.asList(i,j));\\n        if (i + 1 < M.length) dfs(i+1, j, w, h, M, dp, ans);\\n        if (i > 0) dfs(i-1, j, w, h, M, dp, ans);\\n        if (j + 1 < M[0].length) dfs(i, j+1, w, h, M, dp, ans);\\n        if (j > 0) dfs(i, j-1, w, h, M, dp, ans);\\n    }\\n    public List<List<Integer>> pacificAtlantic(int[][] M) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (M.length == 0) return ans;\\n        int y = M.length, x = M[0].length;\\n        byte[] dp = new byte[x * y];\\n        for (int i = 0; i < x; i++) {\\n            dfs(0, i, 1, M[0][i], M, dp, ans);\\n            dfs(y-1, i, 2, M[y-1][i], M, dp, ans);\\n        }   \\n        for (int i = 0; i < y; i++) {\\n            dfs(i, 0, 1, M[i][0], M, dp, ans);\\n            dfs(i, x-1, 2, M[i][x-1], M, dp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        if (M.empty()) return ans;\\n        int y = M.size(), x = M[0].size();\\n        vector<char> dp(y * x);\\n        for (int i = 0; i < y; i++) {\\n            dfs(M, dp, i, 0, 1, 0);\\n            dfs(M, dp, i, x - 1, 2, 0);\\n        }\\n        for (int i = 0; i < x; i++) {\\n            dfs(M, dp, 0, i, 1, 0);\\n            dfs(M, dp, y - 1, i, 2, 0);\\n        }\\n        for (int i = 0; i < y; i++) \\n            for (int j = 0; j < x; j++) \\n                if (dp[i * x + j] == 3) \\n                    ans.push_back({i, j});\\n        return ans;\\n    }\\nprivate:\\n    void dfs(const vector<vector<int>>& M, vector<char>& dp, int i, int j, int w, int h) {\\n        int y = M.size(), x = M[0].size(), ij = i * x + j, newh = M[i][j];;\\n        if ((dp[ij] & w) || M[i][j] < h) return;\\n        dp[ij] += w;\\n        if (i + 1 < y) dfs(M, dp, i + 1, j, w, newh);\\n        if (i > 0) dfs(M, dp, i - 1, j, w, newh);\\n        if (j + 1 < x) dfs(M, dp, i, j + 1, w, newh);\\n        if (j > 0) dfs(M, dp, i, j - 1, w, newh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126937,
                "title": "pacific-atlantic-water-flow-short-easy-w-explanation-diagrams",
                "content": "In a naive approach, we would have to consider each cell and find if it is reachable to both the oceans by checking if it is able to reach - **1.** top or left edge(atlantic) and,  **2.** bottom or right edge (pacific). This would take about **`O((mn)^2)`**, which is not efficient.\\n\\n***Solution - I (DFS Traversal)***\\n\\nI will try to explain the process using images provided in LC solution.\\n\\nWe can observe that there are these cells which can reach -\\n\\n* None \\n* Pacific\\n* Atlantic\\n* Both Pacific and Atlantic\\n\\n\\nWe need only the cells satisfying the last condition above.\\n\\n\\nNow, if we start from the cells connected to altantic ocean and visit all cells having height greater than current cell (**water can only flow from a cell to another one with height equal or lower**), we are able to reach some subset of cells (let\\'s call them **`A`**).\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/7fe6657a-4bc1-4d68-8a26-befe6e106371_1616674367.2859244.png\" align=\"center\" width=\"500\"/></p>\\n\\n\\n\\nNext, we start from the cells connected to pacific ocean and repeat the same process, we find another subset (let\\'s call this one **`B`**).\\n\\n<p align=\"center\"><img src=\"https://assets.leetcode.com/users/images/ef3a788b-7b66-4c70-a47c-58490b998177_1616674843.2320118.png\" align=\"center\" width=\"500\"/></p>\\n\\n\\nThe final answer we get will be the intersection of sets `A` and `B` (**`A \\u2229 B`**).\\n\\n<p align=\"center\"><img src=\"https://assets.leetcode.com/users/images/6a9f7a1f-105e-4d6c-8e7c-ede3a2f9b6de_1616674967.7329113.png\" align=\"center\" width=\"500\"/></p>\\n\\nSo, we just need to iterate from edge cells, find cells reachable from atlantic (set `A`), cells reachable from pacific (set `B`) and return their intersection. This can be done using DFS or BFS graph traversals.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n\\t// denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool> > atlantic, pacific;\\n\\tvector<vector<int> > ans;    \\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n\\t\\t// perform dfs from all edge cells (ocean-connected cells)\\n        for(int i = 0; i < m; i++) dfs(mat, pacific, i, 0), dfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) dfs(mat, pacific, 0, i), dfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void dfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        if(visited[i][j]) return;\\n        visited[i][j] = true;\\n\\t\\t// if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});    \\n\\t\\t// dfs from current cell only if height of next cell is greater\\n/*\\u2B07\\uFE0F*/  if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) dfs(mat, visited, i + 1, j); \\n/*\\u2B06\\uFE0F*/  if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) dfs(mat, visited, i - 1, j);\\n/*\\u27A1\\uFE0F*/  if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) dfs(mat, visited, i, j + 1); \\n/*\\u2B05\\uFE0F*/  if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) dfs(mat, visited, i, j - 1);\\n    }\\n};\\n```\\n\\n**Time Complexity :** **`O(M*N)`**, in worst case, all cells are reachable to both oceans and would be visited twice. This case can occur when all elements are equal.\\n**Space Complexity :** **`O(M*N)`**, to mark the atlantic and pacific visited cells.\\n\\n\\n---------\\n---------\\n\\n***Solution - II (BFS Traversal)***\\n\\nBelow is similar solution as above converted to **BFS traversal** -\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int> > ans;\\n    vector<vector<bool> > atlantic, pacific;\\n    queue<pair<int, int> > q;\\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n        for(int i = 0; i < m; i++) bfs(mat, pacific, i, 0), bfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) bfs(mat, pacific, 0, i), bfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void bfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        q.push({i, j});\\n        while(!q.empty()){\\n            tie(i, j) = q.front(); q.pop();\\n            if(visited[i][j]) continue;\\n            visited[i][j] = true;\\n            if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});\\n            if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) q.push({i + 1, j});\\n            if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) q.push({i - 1, j});\\n            if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) q.push({i, j + 1});\\n            if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) q.push({i, j - 1});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n\\t// denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool> > atlantic, pacific;\\n\\tvector<vector<int> > ans;    \\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n\\t\\t// perform dfs from all edge cells (ocean-connected cells)\\n        for(int i = 0; i < m; i++) dfs(mat, pacific, i, 0), dfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) dfs(mat, pacific, 0, i), dfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void dfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        if(visited[i][j]) return;\\n        visited[i][j] = true;\\n\\t\\t// if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});    \\n\\t\\t// dfs from current cell only if height of next cell is greater\\n/*\\u2B07\\uFE0F*/  if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) dfs(mat, visited, i + 1, j); \\n/*\\u2B06\\uFE0F*/  if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) dfs(mat, visited, i - 1, j);\\n/*\\u27A1\\uFE0F*/  if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) dfs(mat, visited, i, j + 1); \\n/*\\u2B05\\uFE0F*/  if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) dfs(mat, visited, i, j - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int> > ans;\\n    vector<vector<bool> > atlantic, pacific;\\n    queue<pair<int, int> > q;\\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n        for(int i = 0; i < m; i++) bfs(mat, pacific, i, 0), bfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) bfs(mat, pacific, 0, i), bfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void bfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        q.push({i, j});\\n        while(!q.empty()){\\n            tie(i, j) = q.front(); q.pop();\\n            if(visited[i][j]) continue;\\n            visited[i][j] = true;\\n            if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});\\n            if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) q.push({i + 1, j});\\n            if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) q.push({i - 1, j});\\n            if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) q.push({i, j + 1});\\n            if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) q.push({i, j - 1});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507556,
                "title": "c-faster-than-98-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\t#define vvi vector<vector<int>>\\n\\t#define vvb vector<vector<bool>>\\n\\t#define vb vector<bool>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint n, m;\\n\\n\\t\\t// Go througout the adjacent if the adjacent\\'s height is more or equal to current height\\n\\t\\tvoid dfs(vvi& grid, vvb& flag, int x, int y) {\\n\\t\\t\\tflag[x][y] = true;\\n\\t\\t\\tif (x - 1 >= 0 && !flag[x - 1][y] && grid[x - 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x - 1, y);\\n\\t\\t\\tif (x + 1 < n && !flag[x + 1][y] && grid[x + 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x + 1, y);\\n\\t\\t\\tif (y - 1 >= 0 && !flag[x][y - 1] && grid[x][y - 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y - 1);\\n\\t\\t\\tif (y + 1 < m && !flag[x][y + 1] && grid[x][y + 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y + 1);\\n\\t\\t}\\n\\n\\t\\tvvi pacificAtlantic(vvi& heights) {\\n\\t\\t\\tn = heights.size();\\n\\t\\t\\tm = heights[0].size();\\n\\n\\t\\t\\tvvb flag1(n, vb(m)), flag2(n, vb(m));\\n\\t\\t\\tvvi ans;\\n\\n\\t\\t\\t// Pacific\\n\\t\\t\\t// Do DFS starting from upper border and left border\\n\\t\\t\\t// Mark true in flag1 if posibble\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tdfs(heights, flag1, i, 0);\\n\\t\\t\\tfor (int i = 1; i < m; i++)\\n\\t\\t\\t\\tdfs(heights, flag1, 0, i);\\n\\n\\t\\t\\t// Attlantic\\n\\t\\t\\t// DFS starting from bottom border and right border\\n\\t\\t\\t// Mark true in flag2 if posibble\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tdfs(heights, flag2, i, m - 1);\\n\\t\\t\\tfor (int i = 0; i < m - 1; i++)\\n\\t\\t\\t\\tdfs(heights, flag2, n - 1, i);\\n\\n\\t\\t\\t// Add cordinate to ans if both flag1 and flag2 is equal to true\\n\\t\\t\\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++)\\n\\t\\t\\t\\tif (flag1[i][j] && flag2[i][j])\\n\\t\\t\\t\\t\\tans.push_back({i, j});\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint n, m;\\n\\n\\t\\t// Go througout the adjacent if the adjacent\\'s height is more or equal to current height\\n\\t\\tvoid dfs(vvi& grid, vvb& flag, int x, int y) {\\n\\t\\t\\tflag[x][y] = true;\\n\\t\\t\\tif (x - 1 >= 0 && !flag[x - 1][y] && grid[x - 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x - 1, y);\\n\\t\\t\\tif (x + 1 < n && !flag[x + 1][y] && grid[x + 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x + 1, y);\\n\\t\\t\\tif (y - 1 >= 0 && !flag[x][y - 1] && grid[x][y - 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y - 1);\\n\\t\\t\\tif (y + 1 < m && !flag[x][y + 1] && grid[x][y + 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y + 1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 543988,
                "title": "easy-understand-dfs-solution-beat-97",
                "content": "![image](https://assets.leetcode.com/users/jefferyzzy/image_1584588025.png)\\n\\n```Python\\ndef pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix or not matrix[0]:return []\\n        m, n = len(matrix),len(matrix[0])\\n        p_visited = set()\\n        a_visited = set()\\n        directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n        def dfs(visited, x,y):\\n            visited.add((x,y))\\n            for dx, dy in directions:\\n                new_x, new_y = x+dx, y+dy\\n                if 0<=new_x<m and 0<=new_y<n and (new_x,new_y) not in visited and matrix[new_x][new_y]>=matrix[x][y]:\\n                    dfs(visited, new_x,new_y)\\n        #iterate from left border and right border\\n        for i in range(m):\\n            dfs(p_visited,i,0)\\n            dfs(a_visited,i,n-1)\\n        #iterate from up border and bottom border\\n        for j in range(n):\\n            dfs(p_visited,0,j)\\n            dfs(a_visited,m-1,j)\\n        #The intersections of two sets are coordinates where water can flow to both P and A\\n        return list(p_visited.intersection(a_visited))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```Python\\ndef pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix or not matrix[0]:return []\\n        m, n = len(matrix),len(matrix[0])\\n        p_visited = set()\\n        a_visited = set()\\n        directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n        def dfs(visited, x,y):\\n            visited.add((x,y))\\n            for dx, dy in directions:\\n                new_x, new_y = x+dx, y+dy\\n                if 0<=new_x<m and 0<=new_y<n and (new_x,new_y) not in visited and matrix[new_x][new_y]>=matrix[x][y]:\\n                    dfs(visited, new_x,new_y)\\n        #iterate from left border and right border\\n        for i in range(m):\\n            dfs(p_visited,i,0)\\n            dfs(a_visited,i,n-1)\\n        #iterate from up border and bottom border\\n        for j in range(n):\\n            dfs(p_visited,0,j)\\n            dfs(a_visited,m-1,j)\\n        #The intersections of two sets are coordinates where water can flow to both P and A\\n        return list(p_visited.intersection(a_visited))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 90749,
                "title": "java-17ms-solution-simple-and-clear-similar-to-number-of-islands-s-idea",
                "content": "The idea is as following:\\n\\nFirst, we can separate Pacific and Atlantic ocean into two, they share the same idea. The only difference is the starting position.\\n\\nSecond, we think this problem in the opposite way: all the valid positions must have at least one path to connect to the ocean, so we start from the ocean to find out all the paths.\\n\\n1, 1, 1, 1\\n1, 0, 0, 0\\n1, 0, 0, 0\\n1, 0, 0, 0\\n\\nThen we create a new boolean[][] matrix like above, all the beaches is marked as True (1) in the beginning, which means they can connect to the ocean, then we explore from the beach to find out all the paths. The idea is the same for Pacific and Atlantic.\\n\\nThe last step is to use && to find positions satisfy both Pacific and Atlantic.\\n\\nHere comes the solution:\\n\\n\\n\\n    static int[] dx = {-1,0,0,1};\\n    static int[] dy = {0,1,-1,0};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;\\n        boolean[][] pacific = new boolean[matrix.length][matrix[0].length];\\n        boolean[][] atlantic = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++){\\n            pacific[i][0] = true;\\n            atlantic[i][matrix[0].length-1] = true;\\n        }\\n        for (int j = 0; j < matrix[0].length; j++){\\n            pacific[0][j] = true;\\n            atlantic[matrix.length-1][j] = true;\\n        }\\n        for (int i = 0; i < matrix.length; i++){\\n            explore(pacific, matrix, i, 0);\\n            explore(atlantic, matrix, i, matrix[0].length-1);\\n        }\\n        for (int j = 0; j < matrix[0].length; j++){\\n            explore(pacific, matrix, 0, j);\\n            explore(atlantic, matrix, matrix.length-1, j);\\n        }\\n        for (int i = 0; i < matrix.length; i++){\\n            for (int j = 0; j < matrix[0].length; j++){\\n                if (pacific[i][j] && atlantic[i][j] == true)\\n                    res.add(new int[]{i,j});\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    private void explore(boolean[][] grid, int[][] matrix, int i, int j){\\n        grid[i][j] = true;\\n        for (int d = 0; d < dx.length; d++){\\n            if (i+dy[d] < grid.length && i+dy[d] >= 0 && \\n                j + dx[d] < grid[0].length && j + dx[d] >= 0 && \\n                grid[i+dy[d]][j+dx[d]] == false && matrix[i+dy[d]][j+dx[d]] >= matrix[i][j])\\n                    explore(grid, matrix, i+dy[d], j+dx[d]);\\n        }\\n    }",
                "solutionTags": [],
                "code": "The idea is as following:\\n\\nFirst, we can separate Pacific and Atlantic ocean into two, they share the same idea. The only difference is the starting position.\\n\\nSecond, we think this problem in the opposite way: all the valid positions must have at least one path to connect to the ocean, so we start from the ocean to find out all the paths.\\n\\n1, 1, 1, 1\\n1, 0, 0, 0\\n1, 0, 0, 0\\n1, 0, 0, 0\\n\\nThen we create a new boolean[][] matrix like above, all the beaches is marked as True (1) in the beginning, which means they can connect to the ocean, then we explore from the beach to find out all the paths. The idea is the same for Pacific and Atlantic.\\n\\nThe last step is to use && to find positions satisfy both Pacific and Atlantic.\\n\\nHere comes the solution:\\n\\n\\n\\n    static int[] dx = {-1,0,0,1};\\n    static int[] dy = {0,1,-1,0};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;\\n        boolean[][] pacific = new boolean[matrix.length][matrix[0].length];\\n        boolean[][] atlantic = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++){\\n            pacific[i][0] = true;\\n            atlantic[i][matrix[0].length-1] = true;\\n        }\\n        for (int j = 0; j < matrix[0].length; j++){\\n            pacific[0][j] = true;\\n            atlantic[matrix.length-1][j] = true;\\n        }\\n        for (int i = 0; i < matrix.length; i++){\\n            explore(pacific, matrix, i, 0);\\n            explore(atlantic, matrix, i, matrix[0].length-1);\\n        }\\n        for (int j = 0; j < matrix[0].length; j++){\\n            explore(pacific, matrix, 0, j);\\n            explore(atlantic, matrix, matrix.length-1, j);\\n        }\\n        for (int i = 0; i < matrix.length; i++){\\n            for (int j = 0; j < matrix[0].length; j++){\\n                if (pacific[i][j] && atlantic[i][j] == true)\\n                    res.add(new int[]{i,j});\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    private void explore(boolean[][] grid, int[][] matrix, int i, int j){\\n        grid[i][j] = true;\\n        for (int d = 0; d < dx.length; d++){\\n            if (i+dy[d] < grid.length && i+dy[d] >= 0 && \\n                j + dx[d] < grid[0].length && j + dx[d] >= 0 && \\n                grid[i+dy[d]][j+dx[d]] == false && matrix[i+dy[d]][j+dx[d]] >= matrix[i][j])\\n                    explore(grid, matrix, i+dy[d], j+dx[d]);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2507663,
                "title": "python-dfs-recursion-simple-and-readable",
                "content": "**Intuition**\\n\\n- Instead of seeing how water can flow from land to the ocean, we can reverse our thinking and see how water can flow from ocean to land\\n- Recursive DFS helps keeps the code clean and readable\\n- We try to traverse to a cell that is equal of higher than the previous cell\\n- We perform DFS on all four sides, keeping track of coordinates reachable from both Pacific and Atlantic\\n- Intersection of two sets of coordinates gives us our answer\\n\\n**Solution**\\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        \\n        def dfs(i: int, j: int, prev_height: int, coords: Set[Tuple[int]]) -> None:\\n            if i < 0 or i == m or j < 0 or j == n:\\n                # out of bounds\\n                return\\n            \\n            if (i, j) in coords:\\n                # already visited\\n                return\\n            \\n            height = heights[i][j]\\n            \\n            if height < prev_height:\\n                # water can\\'t flow to a higher height\\n                return\\n            \\n            # ocean is reachable from current coordinate\\n            coords.add((i, j))\\n            \\n            # all four directions\\n            dfs(i + 1, j, height, coords)\\n            dfs(i - 1, j, height, coords)\\n            dfs(i, j + 1, height, coords)\\n            dfs(i, j - 1, height, coords)\\n            \\n        pacific_coords = set()\\n        \\n        # top row\\n        for j in range(n):\\n            dfs(0, j, 0, pacific_coords)\\n        \\n        # left col\\n        for i in range(m):\\n            dfs(i, 0, 0, pacific_coords)\\n            \\n        atlantic_coords = set()\\n            \\n        # right col\\n        for i in range(m):\\n            dfs(i, n - 1, 0, atlantic_coords)\\n            \\n        # bottom row\\n        for j in range(n):\\n            dfs(m - 1, j, 0, atlantic_coords)\\n            \\n        # intersection of coords reachable from both Pacific and Atlantic\\n        return list(pacific_coords & atlantic_coords)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        \\n        def dfs(i: int, j: int, prev_height: int, coords: Set[Tuple[int]]) -> None:\\n            if i < 0 or i == m or j < 0 or j == n:\\n                # out of bounds\\n                return\\n            \\n            if (i, j) in coords:\\n                # already visited\\n                return\\n            \\n            height = heights[i][j]\\n            \\n            if height < prev_height:\\n                # water can\\'t flow to a higher height\\n                return\\n            \\n            # ocean is reachable from current coordinate\\n            coords.add((i, j))\\n            \\n            # all four directions\\n            dfs(i + 1, j, height, coords)\\n            dfs(i - 1, j, height, coords)\\n            dfs(i, j + 1, height, coords)\\n            dfs(i, j - 1, height, coords)\\n            \\n        pacific_coords = set()\\n        \\n        # top row\\n        for j in range(n):\\n            dfs(0, j, 0, pacific_coords)\\n        \\n        # left col\\n        for i in range(m):\\n            dfs(i, 0, 0, pacific_coords)\\n            \\n        atlantic_coords = set()\\n            \\n        # right col\\n        for i in range(m):\\n            dfs(i, n - 1, 0, atlantic_coords)\\n            \\n        # bottom row\\n        for j in range(n):\\n            dfs(m - 1, j, 0, atlantic_coords)\\n            \\n        # intersection of coords reachable from both Pacific and Atlantic\\n        return list(pacific_coords & atlantic_coords)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507502,
                "title": "easy-dfs-solution-beats-100-solution-java-python-c",
                "content": "**Upvote** if you like quick and simple explanations!\\n\\n**Intuition**\\nInitially we have the first row/column are able to reach the pacific ocean.\\nSay our current location can reach the pacific, all locations with a height >= the current location can have water flow into our current location and thus reach the pacific.\\n\\nWe keep this principle and do a DFS over all nodes starting from the ones that can reach the pacific to find all nodes that can reach the pacific ocean if water were placed on it.\\nWe do the exact same process for the atlantic ocean and then we check which positions can reach both the atlantic and pacific.\\n\\n**Note:** for simplicity we can say the sea is at water level (i.e height of 0)\\n\\n**SOLUTION**\\n```java\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rlen = heights.length;\\n        int clen = heights[0].length;\\n        \\n        List<List<Integer>> output = new ArrayList();\\n        boolean[][] atlantic = new boolean[rlen][clen];\\n        boolean[][] pacific = new boolean[rlen][clen];\\n\\n\\t\\t//Do a DFS on all nodes at the pacific end and the atlantic end:\\n        for(int r = 0; r < rlen; r++){\\n            for(int c = 0; c < clen; c++){          \\n                if(r == 0 || c == 0){ dfs(pacific, heights, r, c, 0);}\\n                if(r == rlen-1 || c == clen-1){ dfs(atlantic, heights, r, c, 0); }\\n            }\\n        }\\n        \\n\\t\\t// Check which locations can reach both pacific and atlantic:\\n        for(int r = 0; r < rlen; r++){\\n            for(int c = 0; c < clen; c++){          \\n                if(atlantic[r][c] && pacific[r][c]){\\n                    output.add(Arrays.asList(r,c));\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    // Go to a node - all the larger ones around it can reach the current sea:\\n    public void dfs(boolean[][] sea, int[][] grid, int r, int c, int prev){\\n        if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return;\\n        if(grid[r][c] < prev) return;\\n        if(sea[r][c]) return; \\n        \\n        sea[r][c] = true;\\n        dfs(sea, grid, r+1, c, grid[r][c]); // bottom \\n        dfs(sea, grid, r-1, c, grid[r][c]); // top \\n        dfs(sea, grid, r, c-1, grid[r][c]); // left \\n        dfs(sea, grid, r, c+1, grid[r][c]); // right\\n    }\\n}\\n```\\n\\nI\\'ll be back to making youtube videos on daily leetcode questions, come checkout the youtube channel here: \\n**https://www.youtube.com/channel/UCfvW4KQXzpE3ZZqNxAHnaPQ**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rlen = heights.length;\\n        int clen = heights[0].length;\\n        \\n        List<List<Integer>> output = new ArrayList();\\n        boolean[][] atlantic = new boolean[rlen][clen];\\n        boolean[][] pacific = new boolean[rlen][clen];\\n\\n\\t\\t//Do a DFS on all nodes at the pacific end and the atlantic end:\\n        for(int r = 0; r < rlen; r++){\\n            for(int c = 0; c < clen; c++){          \\n                if(r == 0 || c == 0){ dfs(pacific, heights, r, c, 0);}\\n                if(r == rlen-1 || c == clen-1){ dfs(atlantic, heights, r, c, 0); }\\n            }\\n        }\\n        \\n\\t\\t// Check which locations can reach both pacific and atlantic:\\n        for(int r = 0; r < rlen; r++){\\n            for(int c = 0; c < clen; c++){          \\n                if(atlantic[r][c] && pacific[r][c]){\\n                    output.add(Arrays.asList(r,c));\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    // Go to a node - all the larger ones around it can reach the current sea:\\n    public void dfs(boolean[][] sea, int[][] grid, int r, int c, int prev){\\n        if(r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return;\\n        if(grid[r][c] < prev) return;\\n        if(sea[r][c]) return; \\n        \\n        sea[r][c] = true;\\n        dfs(sea, grid, r+1, c, grid[r][c]); // bottom \\n        dfs(sea, grid, r-1, c, grid[r][c]); // top \\n        dfs(sea, grid, r, c-1, grid[r][c]); // left \\n        dfs(sea, grid, r, c+1, grid[r][c]); // right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90812,
                "title": "simple-commented-java-solution-with-thinking-progress-o-n",
                "content": "```\\n/*\\n1.Naive solution:\\n    Standard dfs, which means for each point, we check if it can reach both pacific and atlantic, \\n    for each point, we can possibly check all the rest of points, O(m*n * m*n)\\n\\n2.A little improvement:\\n    What about we 4 hash tables, they keep track of all the points we know so far that \\n        can reach atlantic\\n        cannot reach atlantic\\n        can reach pacific\\n        cannot reach pacific\\n    It's doable, still hit TLE, although I didn't hit TLE when not submitting the code, but running it using the provided testing environment\\n\\n3.On the other hand, we can consider the flip side\\n    We can let the pacific and atlantic ocean \"flow into\" the matrix as much as possible,\\n    using 2 boolean arrays, one for each ocean. \\n    The result are the points that are true in both boolean table\\n*/\\n\\n\\npublic class Solution {\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> result = new ArrayList<int[]>();\\n        if(matrix.length == 0 || matrix[0].length == 0) return result;   \\n        boolean[][] pacific = new boolean[matrix.length][matrix[0].length];  // the pacific boolean table\\n        boolean[][] atlantic = new boolean[matrix.length][matrix[0].length]; // the atlantic booean table\\n        //initially, all the top and left cells are flooded with pacific water\\n        //and all the right and bottom cells are flooded with atlantic water\\n        for(int i = 0; i < matrix.length; i++){\\n            pacific[i][0] = true;\\n            atlantic[i][matrix[0].length-1] = true;\\n        }\\n        for(int i = 0; i < matrix[0].length; i++){\\n            pacific[0][i] = true;\\n            atlantic[matrix.length-1][i] = true; \\n        }\\n        //we go around the matrix and try to flood the matrix from 4 side.\\n        for(int i = 0; i < matrix.length; i++){\\n            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];\\n            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];\\n            water(pacific, pacificVisited, matrix, i,0);\\n            water(atlantic, atlanticVisited, matrix, i, matrix[0].length - 1);            \\n        }\\n        for(int i = 0; i < matrix[0].length; i++){\\n            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];\\n            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];\\n            water(pacific, pacificVisited, matrix, 0,i);\\n            water(atlantic, atlanticVisited, matrix, matrix.length - 1, i);            \\n        }\\n        //check the shared points among 2 tables\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    int[] element = {i,j};\\n                    result.add(element);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    //the flood function\\n    private void water(boolean[][] wet, boolean[][] visited, int[][] matrix, int i , int j){\\n        wet[i][j] = true;\\n        visited[i][j] = true;\\n        int[] x = {0,0,1,-1};\\n        int[] y = {1,-1,0,0};\\n        for(int k = 0; k < 4; k++){\\n            if(i+y[k] >= 0 && i+y[k] < matrix.length && j+x[k] >= 0 && j+x[k] < matrix[0].length \\n                && !visited[i+y[k]][j+x[k]] && matrix[i+y[k]][j+x[k]] >= matrix[i][j]){\\n                water(wet, visited, matrix, i+y[k], j+x[k]);\\n            }\\n        }\\n    }\\n}````\\n\\nP.S Sometimes you choose an option just because the alternative is just worse.....",
                "solutionTags": [],
                "code": "```\\n/*\\n1.Naive solution:\\n    Standard dfs, which means for each point, we check if it can reach both pacific and atlantic, \\n    for each point, we can possibly check all the rest of points, O(m*n * m*n)\\n\\n2.A little improvement:\\n    What about we 4 hash tables, they keep track of all the points we know so far that \\n        can reach atlantic\\n        cannot reach atlantic\\n        can reach pacific\\n        cannot reach pacific\\n    It's doable, still hit TLE, although I didn't hit TLE when not submitting the code, but running it using the provided testing environment\\n\\n3.On the other hand, we can consider the flip side\\n    We can let the pacific and atlantic ocean \"flow into\" the matrix as much as possible,\\n    using 2 boolean arrays, one for each ocean. \\n    The result are the points that are true in both boolean table\\n*/\\n\\n\\npublic class Solution {\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> result = new ArrayList<int[]>();\\n        if(matrix.length == 0 || matrix[0].length == 0) return result;   \\n        boolean[][] pacific = new boolean[matrix.length][matrix[0].length];  // the pacific boolean table\\n        boolean[][] atlantic = new boolean[matrix.length][matrix[0].length]; // the atlantic booean table\\n        //initially, all the top and left cells are flooded with pacific water\\n        //and all the right and bottom cells are flooded with atlantic water\\n        for(int i = 0; i < matrix.length; i++){\\n            pacific[i][0] = true;\\n            atlantic[i][matrix[0].length-1] = true;\\n        }\\n        for(int i = 0; i < matrix[0].length; i++){\\n            pacific[0][i] = true;\\n            atlantic[matrix.length-1][i] = true; \\n        }\\n        //we go around the matrix and try to flood the matrix from 4 side.\\n        for(int i = 0; i < matrix.length; i++){\\n            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];\\n            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];\\n            water(pacific, pacificVisited, matrix, i,0);\\n            water(atlantic, atlanticVisited, matrix, i, matrix[0].length - 1);            \\n        }\\n        for(int i = 0; i < matrix[0].length; i++){\\n            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];\\n            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];\\n            water(pacific, pacificVisited, matrix, 0,i);\\n            water(atlantic, atlanticVisited, matrix, matrix.length - 1, i);            \\n        }\\n        //check the shared points among 2 tables\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    int[] element = {i,j};\\n                    result.add(element);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    //the flood function\\n    private void water(boolean[][] wet, boolean[][] visited, int[][] matrix, int i , int j){\\n        wet[i][j] = true;\\n        visited[i][j] = true;\\n        int[] x = {0,0,1,-1};\\n        int[] y = {1,-1,0,0};\\n        for(int k = 0; k < 4; k++){\\n            if(i+y[k] >= 0 && i+y[k] < matrix.length && j+x[k] >= 0 && j+x[k] < matrix[0].length \\n                && !visited[i+y[k]][j+x[k]] && matrix[i+y[k]][j+x[k]] >= matrix[i][j]){\\n                water(wet, visited, matrix, i+y[k], j+x[k]);\\n            }\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2507252,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**HERE I HAVE CREATED TWO SEPRATE FUNCTION , ONE FUNCTION COULD BE MADE , THIS IS JUST DONE FOR CLARITY.**\\n\\nWe need to count the number of cells from which waer could flow to both the oceans.\\nWater can go to **left,top** for pacific and to **right,down** for atlantic.\\n\\n**APPROACH**\\n\\nWe just do what is asked for.\\n\\nWhen at cell ```ht[i][j]``` :\\n* we check that water can flow to **left,top** and also to **right,down**.\\n* It is similar to finding a path with non-increasing values.\\n* To prevent repeation, we use memoization to store the result for certain ```ht[i][j]```.\\n\\n*How memoization helps :*\\n* Let water can flow to both oceans from cell ```ht[i][j]```, so while checking for its adjacent cells, we need not find the complete path to oceans, **we just find a path that leads to a cell that reaches both oceans.**\\n\\n**Finding water can reach both oceans :**\\n* As we going for memoization, we create two ```2-D array  for atlantic and pacific``` that stores that whether water can flow to ocean for each ocean respectively.\\n* For pacific, we created ```pac``` and water initially water can flow for top and left cells.\\n* For atlanic, we created ```atl``` and water initially water can flow for bottom and right cells.\\n* Then for each cell, we check whether water flows off :\\n* * For cell ```ht[i][j]``` we recurcively call for its adjacent cells, if neightbouring height is less or equal to current cell.\\n* * Water can flow off if we reach a cell for which we already have solution.\\n* * * For pacific we already made top,left cells ```true``` and same for atlantic.\\n\\n* Whenever water reaches, make all cells in that path ```true``` so they need not to be calculated in future.\\n\\n\\n\\n**UPVOTE IF HELPFuuL**\\n\\n*Here i created and pdated the memoization table first and calculated number of cells afterwards, can be combined to single step.*\\n\\n**PYTHOON**\\n```\\nclass Solution:\\n    def pacificAtlantic(self, ht: List[List[int]]) -> List[List[int]]:\\n        \\n        def pac(i,j):\\n            if rp[i][j]:\\n                return True\\n            k=False\\n            h=ht[i][j]\\n            ht[i][j]=100001\\n            if ht[i-1][j]<=h:\\n                k=k or pac(i-1,j)\\n                \\n            if ht[i][j-1]<=h:\\n                k=k or pac(i,j-1)\\n                \\n            if i<m-1 and ht[i+1][j]<=h:\\n                k=k or pac(i+1,j)\\n                \\n            if j<n-1 and ht[i][j+1]<=h:\\n                k=k or pac(i,j+1)\\n                \\n            ht[i][j]=h\\n            rp[i][j]=k\\n            return k\\n        \\n        def ant(i,j):\\n            if ra[i][j]:\\n                return True\\n            k=False\\n            h=ht[i][j]\\n            ht[i][j]=100001\\n            if i>0 and ht[i-1][j]<=h:\\n                k=k or ant(i-1,j)\\n                \\n            if j>0 and ht[i][j-1]<=h:\\n                k=k or ant(i,j-1)\\n                \\n            if ht[i+1][j]<=h:\\n                k=k or ant(i+1,j)\\n                \\n            if ht[i][j+1]<=h:\\n                k=k or ant(i,j+1)\\n                \\n            ht[i][j]=h\\n            ra[i][j]=k\\n            return k\\n        \\n        m=len(ht)\\n        n=len(ht[0])\\n        rp=[[False for i in range(n)] for j in range(m)]\\n        ra=[[False for i in range(n)] for j in range(m)]\\n        \\n        for i in range(m):\\n            rp[i][0]=True\\n            ra[i][-1]=True\\n        for i in range(n):\\n            rp[0][i]=True\\n            ra[-1][i]=True\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                pac(i,j)\\n                ant(i,j)\\n        res=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if rp[i][j] and ra[i][j]:\\n                    res.append([i,j])\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8cd20a0a-9ab1-456e-a5f3-69f05e67e3ed_1661908619.3639503.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```ht[i][j]```\n```ht[i][j]```\n```ht[i][j]```\n```2-D array  for atlantic and pacific```\n```pac```\n```atl```\n```ht[i][j]```\n```true```\n```true```\n```\\nclass Solution:\\n    def pacificAtlantic(self, ht: List[List[int]]) -> List[List[int]]:\\n        \\n        def pac(i,j):\\n            if rp[i][j]:\\n                return True\\n            k=False\\n            h=ht[i][j]\\n            ht[i][j]=100001\\n            if ht[i-1][j]<=h:\\n                k=k or pac(i-1,j)\\n                \\n            if ht[i][j-1]<=h:\\n                k=k or pac(i,j-1)\\n                \\n            if i<m-1 and ht[i+1][j]<=h:\\n                k=k or pac(i+1,j)\\n                \\n            if j<n-1 and ht[i][j+1]<=h:\\n                k=k or pac(i,j+1)\\n                \\n            ht[i][j]=h\\n            rp[i][j]=k\\n            return k\\n        \\n        def ant(i,j):\\n            if ra[i][j]:\\n                return True\\n            k=False\\n            h=ht[i][j]\\n            ht[i][j]=100001\\n            if i>0 and ht[i-1][j]<=h:\\n                k=k or ant(i-1,j)\\n                \\n            if j>0 and ht[i][j-1]<=h:\\n                k=k or ant(i,j-1)\\n                \\n            if ht[i+1][j]<=h:\\n                k=k or ant(i+1,j)\\n                \\n            if ht[i][j+1]<=h:\\n                k=k or ant(i,j+1)\\n                \\n            ht[i][j]=h\\n            ra[i][j]=k\\n            return k\\n        \\n        m=len(ht)\\n        n=len(ht[0])\\n        rp=[[False for i in range(n)] for j in range(m)]\\n        ra=[[False for i in range(n)] for j in range(m)]\\n        \\n        for i in range(m):\\n            rp[i][0]=True\\n            ra[i][-1]=True\\n        for i in range(n):\\n            rp[0][i]=True\\n            ra[-1][i]=True\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                pac(i,j)\\n                ant(i,j)\\n        res=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if rp[i][j] and ra[i][j]:\\n                    res.append([i,j])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317325,
                "title": "easy-to-read-java-dfs-flood-from-ocean",
                "content": "Top answer right now uses 2 matrices to track visited but we can do it with one - use codes for visited by Pacific, Atlantic, or both.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList();\\n        if (matrix.length == 0 || matrix[0].length == 0)  return res;\\n        // visited by pacific == -1, atlantic == -2, both == -3\\n        int[][] visited = new int[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            dfs(matrix, visited, i, 0, -1);\\n            dfs(matrix, visited, i, matrix[0].length-1, -2);\\n        }\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            dfs(matrix, visited, 0, i, -1);\\n            dfs(matrix, visited, matrix.length-1, i, -2);\\n        }\\n        \\n        \\n        for (int y = 0; y < matrix.length; y++) {\\n            for (int x = 0; x < matrix[0].length; x++) {\\n                if (visited[y][x] == -3) {\\n                    res.add(Arrays.asList(y,x));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int[][] matrix, int[][] visited, int y, int x, int code) {\\n        int val = matrix[y][x];\\n        int vis = visited[y][x];\\n        if (vis == code || vis == -3) return;\\n        visited[y][x] = vis < 0 ? -3 : code;\\n        \\n        boolean left = x > 0 && matrix[y][x-1] >= val;\\n        boolean right = x < matrix[0].length -1 && matrix[y][x+1] >= val;\\n        boolean up = y > 0 && matrix[y-1][x] >= val;\\n        boolean down = y < matrix.length - 1 && matrix[y+1][x] >= val;\\n        \\n        if (left) dfs(matrix, visited, y, x-1, code);\\n        if (right) dfs(matrix, visited, y, x+1, code);\\n        if (up) dfs(matrix, visited, y-1, x, code);\\n        if (down) dfs(matrix, visited, y+1, x, code);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList();\\n        if (matrix.length == 0 || matrix[0].length == 0)  return res;\\n        // visited by pacific == -1, atlantic == -2, both == -3\\n        int[][] visited = new int[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            dfs(matrix, visited, i, 0, -1);\\n            dfs(matrix, visited, i, matrix[0].length-1, -2);\\n        }\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            dfs(matrix, visited, 0, i, -1);\\n            dfs(matrix, visited, matrix.length-1, i, -2);\\n        }\\n        \\n        \\n        for (int y = 0; y < matrix.length; y++) {\\n            for (int x = 0; x < matrix[0].length; x++) {\\n                if (visited[y][x] == -3) {\\n                    res.add(Arrays.asList(y,x));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int[][] matrix, int[][] visited, int y, int x, int code) {\\n        int val = matrix[y][x];\\n        int vis = visited[y][x];\\n        if (vis == code || vis == -3) return;\\n        visited[y][x] = vis < 0 ? -3 : code;\\n        \\n        boolean left = x > 0 && matrix[y][x-1] >= val;\\n        boolean right = x < matrix[0].length -1 && matrix[y][x+1] >= val;\\n        boolean up = y > 0 && matrix[y-1][x] >= val;\\n        boolean down = y < matrix.length - 1 && matrix[y+1][x] >= val;\\n        \\n        if (left) dfs(matrix, visited, y, x-1, code);\\n        if (right) dfs(matrix, visited, y, x+1, code);\\n        if (up) dfs(matrix, visited, y-1, x, code);\\n        if (down) dfs(matrix, visited, y+1, x, code);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508728,
                "title": "c-dfs-with-explanation-easy",
                "content": "*  Start from all the cell connected with pacific ocean and visit all the cell that are greater than or equal to curent cell **(since water can flow from adjacent cell if height is equal or lower)**\\n* **cell connected with pacific** ocean have either **i==0 or j==0**\\n* If height is greater or equal means water will be able to reach pacific ocean i.e. this cell is reachable by pacific ocean\\n<img src=\"https://assets.leetcode.com/users/images/8172d3fb-d4c0-42ac-a67c-687c17130bd3_1661938631.9706295.png\" alt=\"drawing\" width=\"500\"/>\\n* Start from all the cell connected with Atlantic ocean and visit all the cell that are greater than or equal to curent cell **(since water can flow from adjacent cell if height is equal or lower)**\\n* **cells connected to atlantic** ocean have either **i==n-1 or j==m-1**\\n*  If height is greater or equal means water will be able to reach Atlantic ocean i.e. this cell is reachable by Atlantic ocean\\n<img src=\"https://assets.leetcode.com/users/images/4c38fc61-9561-4a23-96d9-5686d3f91635_1661938716.8930888.png\" alt=\"drawing\" width=\"500\">\\n* Finally include those cells in ans that are reachable from both pacific and atlantic oceans **(means from these cell water can flow in both oceans)**\\n<img src=\"https://assets.leetcode.com/users/images/2f6384b3-5e43-4935-9b08-a968f1ec9e97_1661939112.8621476.png\" alt=\"drawing\" width=\"500\">\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&heights,vector<vector<int>>&oceans,int i,int j,int n,int m)\\n    {\\n        if(i<0 || i>n-1 || j<0 || j>m-1) return;\\n        if(!oceans[i][j])\\n        {\\n            oceans[i][j]=1;\\n            if(i-1>=0 && heights[i-1][j]>=heights[i][j]) dfs(heights,oceans,i-1,j,n,m);\\n            if(i+1<n && heights[i+1][j]>=heights[i][j]) dfs(heights,oceans,i+1,j,n,m); \\n            if(j-1>=0 && heights[i][j-1]>=heights[i][j]) dfs(heights,oceans,i,j-1,n,m);\\n            if(j+1<m && heights[i][j+1]>=heights[i][j]) dfs(heights,oceans,i,j+1,n,m);\\n        }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int n=heights.size();\\n        int m=heights[0].size();\\n        vector<vector<int>>pacific(n,vector<int>(m,0));\\n        vector<vector<int>>atlantic(n,vector<int>(m,0));\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0 || j==0){\\n                    if(!pacific[i][j])\\n                    {\\n                        dfs(heights,pacific,i,j,n,m);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==n-1 || j==m-1){\\n                    if(!atlantic[i][j])\\n                    {\\n                        dfs(heights,atlantic,i,j,n,m);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(pacific[i][j] && atlantic[i][j])\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&heights,vector<vector<int>>&oceans,int i,int j,int n,int m)\\n    {\\n        if(i<0 || i>n-1 || j<0 || j>m-1) return;\\n        if(!oceans[i][j])\\n        {\\n            oceans[i][j]=1;\\n            if(i-1>=0 && heights[i-1][j]>=heights[i][j]) dfs(heights,oceans,i-1,j,n,m);\\n            if(i+1<n && heights[i+1][j]>=heights[i][j]) dfs(heights,oceans,i+1,j,n,m); \\n            if(j-1>=0 && heights[i][j-1]>=heights[i][j]) dfs(heights,oceans,i,j-1,n,m);\\n            if(j+1<m && heights[i][j+1]>=heights[i][j]) dfs(heights,oceans,i,j+1,n,m);\\n        }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int n=heights.size();\\n        int m=heights[0].size();\\n        vector<vector<int>>pacific(n,vector<int>(m,0));\\n        vector<vector<int>>atlantic(n,vector<int>(m,0));\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0 || j==0){\\n                    if(!pacific[i][j])\\n                    {\\n                        dfs(heights,pacific,i,j,n,m);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==n-1 || j==m-1){\\n                    if(!atlantic[i][j])\\n                    {\\n                        dfs(heights,atlantic,i,j,n,m);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(pacific[i][j] && atlantic[i][j])\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508669,
                "title": "easy-bfs-solution-c-time-n-m-space-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n\\t\\tqueue<pair<int,int>>q;\\n\\tset<vector<int>>ans;\\n\\tmap<pair<int,int>,bool>atlantic,pacific;\\n\\n\\tfor(int count=0;count<heights[0].size();++count)\\n\\t\\tatlantic[{0,count}]=true,q.push({0,count});\\n\\n\\t\\tfor(int count =0;count<heights.size();++count)\\n\\t\\t\\t\\tatlantic[{count,0}]=true,q.push({count,0});\\n\\n\\n\\tint dir[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\\n\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint x = q.front().first;\\n\\t\\tint y =  q.front().second;\\n\\n\\t\\tfor(int count =0;count<4;++count)\\n\\t\\t{\\n\\t\\t\\tint i = x+dir[count][0];\\n\\t\\t\\tint j = y+dir[count][1];\\n\\n\\t\\t\\tif(i>=0 && j>=0 && i<heights.size() && j<heights[0].size() && !atlantic[{i,j}] && heights[i][j]>=heights[x][y])\\n\\t\\t\\t{\\n\\t\\t\\t\\tatlantic[{i,j}]=1;\\n\\t\\t\\t\\tq.push({i,j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tq.pop();\\n\\t}\\n\\n\\t for(int count=0;count<heights[0].size();++count)\\n\\t\\tpacific[{heights.size()-1,count}]=true,q.push({heights.size()-1,count});\\n\\n\\t for(int count=0;count<heights.size();++count)\\n\\t pacific[{count,heights[0].size()-1}]=true,q.push({count,heights[0].size()-1});\\n\\n\\n\\t  while(!q.empty())\\n\\t{\\n\\t\\tint x = q.front().first;\\n\\t\\tint y =  q.front().second;\\n\\t\\tif(atlantic[{x,y}])\\n\\t\\t\\tans.insert({x,y});\\n\\t\\tfor(int count =0;count<4;++count)\\n\\t\\t{\\n\\t\\t\\tint i = x+dir[count][0];\\n\\t\\t\\tint j = y+dir[count][1];\\n\\n\\t\\t\\tif(i>=0 && j>=0 && i<heights.size() && j<heights[0].size() && !pacific[{i,j}] && heights[i][j]>=heights[x][y])\\n\\t\\t\\t{\\n\\n\\n\\t\\t\\t\\tpacific[{i,j}]=1;\\n\\t\\t\\t\\tq.push({i,j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tq.pop();\\n\\t}\\n\\n\\treturn {ans.begin(),ans.end()};\\n} \\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n\\t\\tqueue<pair<int,int>>q;\\n\\tset<vector<int>>ans;\\n\\tmap<pair<int,int>,bool>atlantic,pacific;\\n\\n\\tfor(int count=0;count<heights[0].size();++count)\\n\\t\\tatlantic[{0,count}]=true,q.push({0,count});\\n\\n\\t\\tfor(int count =0;count<heights.size();++count)\\n\\t\\t\\t\\tatlantic[{count,0}]=true,q.push({count,0});\\n\\n\\n\\tint dir[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\\n\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint x = q.front().first;\\n\\t\\tint y =  q.front().second;\\n\\n\\t\\tfor(int count =0;count<4;++count)\\n\\t\\t{\\n\\t\\t\\tint i = x+dir[count][0];\\n\\t\\t\\tint j = y+dir[count][1];\\n\\n\\t\\t\\tif(i>=0 && j>=0 && i<heights.size() && j<heights[0].size() && !atlantic[{i,j}] && heights[i][j]>=heights[x][y])\\n\\t\\t\\t{\\n\\t\\t\\t\\tatlantic[{i,j}]=1;\\n\\t\\t\\t\\tq.push({i,j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tq.pop();\\n\\t}\\n\\n\\t for(int count=0;count<heights[0].size();++count)\\n\\t\\tpacific[{heights.size()-1,count}]=true,q.push({heights.size()-1,count});\\n\\n\\t for(int count=0;count<heights.size();++count)\\n\\t pacific[{count,heights[0].size()-1}]=true,q.push({count,heights[0].size()-1});\\n\\n\\n\\t  while(!q.empty())\\n\\t{\\n\\t\\tint x = q.front().first;\\n\\t\\tint y =  q.front().second;\\n\\t\\tif(atlantic[{x,y}])\\n\\t\\t\\tans.insert({x,y});\\n\\t\\tfor(int count =0;count<4;++count)\\n\\t\\t{\\n\\t\\t\\tint i = x+dir[count][0];\\n\\t\\t\\tint j = y+dir[count][1];\\n\\n\\t\\t\\tif(i>=0 && j>=0 && i<heights.size() && j<heights[0].size() && !pacific[{i,j}] && heights[i][j]>=heights[x][y])\\n\\t\\t\\t{\\n\\n\\n\\t\\t\\t\\tpacific[{i,j}]=1;\\n\\t\\t\\t\\tq.push({i,j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tq.pop();\\n\\t}\\n\\n\\treturn {ans.begin(),ans.end()};\\n} \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348967,
                "title": "java-easy-solution",
                "content": "Upvote if you like the solution\\n```\\nclass Solution {\\n    static int[][] dir={{0,1},{0,-1},{1,0},{-1,0}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        int m=heights.length;\\n        int n=heights[0].length;\\n        boolean[][] pac=new boolean[heights.length][heights[0].length];\\n        boolean[][] atl=new boolean[heights.length][heights[0].length];\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(heights,0,i,Integer.MIN_VALUE,pac);\\n            dfs(heights,m-1,i,Integer.MIN_VALUE,atl);\\n        }\\n        for(int j=0;j<m;j++){\\n            dfs(heights,j,0,Integer.MIN_VALUE,pac);\\n            dfs(heights,j,n-1,Integer.MIN_VALUE,atl);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n               if(pac[i][j] && atl[i][j]){\\n                   List<Integer> l=new ArrayList<>();\\n                   l.add(i);\\n                   l.add(j);\\n                   ans.add(l);\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static void dfs(int[][] heights,int i, int j,int prev, boolean[][] arr){\\n        if(i<0 || j<0 || i>=heights.length || j>=heights[0].length || arr[i][j]==true || heights[i][j]<prev)return;\\n        \\n        arr[i][j]=true;\\n        for(int k=0;k<4;k++){\\n            int x=i+dir[k][0];\\n            int y=j+dir[k][1];\\n            \\n            dfs(heights,x,y,heights[i][j],arr);\\n        }\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    static int[][] dir={{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 440088,
                "title": "easy-to-understand-c-solution-dfs-beats-93",
                "content": "Runtime: 44 ms, faster than 93.45% of C++ online submissions for Pacific Atlantic Water Flow.\\nMemory Usage: 14.1 MB, less than 100.00% of C++ online submissions for Pacific Atlantic Water Flow.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        if(n == 0) return {};\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> res;\\n        vector<vector<bool>> pacafic(n, vector<bool>(m, false));\\n        vector<vector<bool>> atlantic(n, vector<bool>(m, false));\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            dfs(matrix, pacafic, INT_MIN, 0, i);\\n            dfs(matrix, atlantic, INT_MIN, n-1, i);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            dfs(matrix, pacafic, INT_MIN, i, 0);\\n            dfs(matrix, atlantic, INT_MIN, i, m-1);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(pacafic[i][j] && atlantic[i][j])\\n                    res.push_back(vector<int> {i,j});\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void dfs(vector<vector<int>>& matrix, vector<vector<bool>>& visited, int prev, int i, int j)\\n    {\\n        if(i < 0 || j < 0 || i >= matrix.size() || j >= matrix[0].size() || prev > matrix[i][j] || visited[i][j]) return;\\n        \\n        visited[i][j] = true;\\n        dfs(matrix, visited, matrix[i][j], i+1, j);\\n        dfs(matrix, visited, matrix[i][j], i-1, j);\\n        dfs(matrix, visited, matrix[i][j], i, j+1);\\n        dfs(matrix, visited, matrix[i][j], i, j-1);\\n    }\\n};\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        if(n == 0) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2508533,
                "title": "python-elegant-short-dfs-99-21-faster",
                "content": "![image](https://assets.leetcode.com/users/images/6e32f2ac-4bce-4a83-aa85-26bc06457eeb_1661969728.801651.png)\\n\\n```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*m)\\n\\tMemory: O(n*m)\\n\\t\"\"\"\\n\\n\\tMOVES = [(-1, 0), (0, -1), (1, 0), (0, 1)]\\n\\n\\tdef pacificAtlantic(self, heights: List[List[int]]) -> Set[Tuple[int, int]]:\\n\\t\\tdef dfs(i: int, j: int, visited: set):\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tfor di, dj in self.MOVES:\\n\\t\\t\\t\\tx, y = i + di, j + dj\\n\\t\\t\\t\\tif 0 <= x < n and 0 <= y < m and (x, y) not in visited and heights[i][j] <= heights[x][y]:\\n\\t\\t\\t\\t\\tdfs(x, y, visited)\\n\\n\\t\\tn, m = len(heights), len(heights[0])\\n\\n\\t\\tatl_visited = set()\\n\\t\\tpas_visited = set()\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tdfs(i,     0, pas_visited)\\n\\t\\t\\tdfs(i, m - 1, atl_visited)\\n\\n\\t\\tfor j in range(m):\\n\\t\\t\\tdfs(    0, j, pas_visited)\\n\\t\\t\\tdfs(n - 1, j, atl_visited)\\n\\n\\t\\treturn atl_visited & pas_visited\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*m)\\n\\tMemory: O(n*m)\\n\\t\"\"\"\\n\\n\\tMOVES = [(-1, 0), (0, -1), (1, 0), (0, 1)]\\n\\n\\tdef pacificAtlantic(self, heights: List[List[int]]) -> Set[Tuple[int, int]]:\\n\\t\\tdef dfs(i: int, j: int, visited: set):\\n\\t\\t\\tvisited.add((i, j))\\n\\t\\t\\tfor di, dj in self.MOVES:\\n\\t\\t\\t\\tx, y = i + di, j + dj\\n\\t\\t\\t\\tif 0 <= x < n and 0 <= y < m and (x, y) not in visited and heights[i][j] <= heights[x][y]:\\n\\t\\t\\t\\t\\tdfs(x, y, visited)\\n\\n\\t\\tn, m = len(heights), len(heights[0])\\n\\n\\t\\tatl_visited = set()\\n\\t\\tpas_visited = set()\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tdfs(i,     0, pas_visited)\\n\\t\\t\\tdfs(i, m - 1, atl_visited)\\n\\n\\t\\tfor j in range(m):\\n\\t\\t\\tdfs(    0, j, pas_visited)\\n\\t\\t\\tdfs(n - 1, j, atl_visited)\\n\\n\\t\\treturn atl_visited & pas_visited\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126771,
                "title": "my-java-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        int row = matrix.length;\\n        if (row == 0)\\n            return result;\\n        int col = matrix[0].length;\\n        boolean [][] pacific = new boolean [row][col];\\n        boolean [][] atlantic = new boolean [row][col];\\n        // top bottom\\n        for (int i=0; i<col; i++) {\\n            dfs(matrix, 0, i, matrix[0][i], pacific);\\n            dfs(matrix, row-1, i, matrix[row-1][i], atlantic);\\n        }\\n        // left right\\n        for (int i=0; i<row; i++) {\\n            dfs(matrix, i, 0, matrix[i][0], pacific);\\n            dfs(matrix, i, col-1, matrix[i][col-1], atlantic);\\n        }\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (pacific[i][j] && atlantic[i][j]) {\\n                    List<Integer> currentResult = new ArrayList<>();\\n                    currentResult.add(i);\\n                    currentResult.add(j);\\n                    result.add(currentResult);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public void dfs(int [][] matrix, int i, int j, int preHeight, boolean [][] ocean) {\\n        if (i < 0 || j < 0 || i >= matrix.length || j >= matrix[0].length || preHeight > matrix[i][j] || ocean[i][j])\\n            return;\\n        ocean[i][j] = true;\\n        dfs(matrix, i+1, j, matrix[i][j], ocean);\\n        dfs(matrix, i-1, j, matrix[i][j], ocean);\\n        dfs(matrix, i, j+1, matrix[i][j], ocean);\\n        dfs(matrix, i, j-1, matrix[i][j], ocean);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        int row = matrix.length;\\n        if (row == 0)\\n            return result;\\n        int col = matrix[0].length;\\n        boolean [][] pacific = new boolean [row][col];\\n        boolean [][] atlantic = new boolean [row][col];\\n        // top bottom\\n        for (int i=0; i<col; i++) {\\n            dfs(matrix, 0, i, matrix[0][i], pacific);\\n            dfs(matrix, row-1, i, matrix[row-1][i], atlantic);\\n        }\\n        // left right\\n        for (int i=0; i<row; i++) {\\n            dfs(matrix, i, 0, matrix[i][0], pacific);\\n            dfs(matrix, i, col-1, matrix[i][col-1], atlantic);\\n        }\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (pacific[i][j] && atlantic[i][j]) {\\n                    List<Integer> currentResult = new ArrayList<>();\\n                    currentResult.add(i);\\n                    currentResult.add(j);\\n                    result.add(currentResult);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public void dfs(int [][] matrix, int i, int j, int preHeight, boolean [][] ocean) {\\n        if (i < 0 || j < 0 || i >= matrix.length || j >= matrix[0].length || preHeight > matrix[i][j] || ocean[i][j])\\n            return;\\n        ocean[i][j] = true;\\n        dfs(matrix, i+1, j, matrix[i][j], ocean);\\n        dfs(matrix, i-1, j, matrix[i][j], ocean);\\n        dfs(matrix, i, j+1, matrix[i][j], ocean);\\n        dfs(matrix, i, j-1, matrix[i][j], ocean);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882548,
                "title": "python-3-bfs-set-intersection-explanation",
                "content": "### Explanation\\n- Starting from pacific and atlantic, going back to the water, check which position they can reach\\n\\t- Of course, following statement should be reversed\\n\\t- > Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.\\n\\t- i.e. Pacific or Atlantic water can only go to water, which height is equal or higher\\n- Take intersection of 2 sets to find common positions\\n### Implementation\\n```\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix: return []\\n        m, n = len(matrix), len(matrix[0])\\n        pacific = [(0, i) for i in range(n)] + [(i, 0) for i in range(1, m)]\\n        atlantic = [(m-1, i) for i in range(n)] + [(i, n-1) for i in range(m-1)]\\n        def bfs(q):\\n            visited = set()\\n            q = collections.deque(q)\\n            while q:\\n                i, j = q.popleft()\\n                visited.add((i, j))\\n                for ii, jj in map(lambda x: (x[0]+i, x[1]+j), [(-1, 0), (1, 0), (0, -1), (0, 1)]):\\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in visited and matrix[ii][jj] >= matrix[i][j]:\\n                        q.append((ii, jj))\\n            return visited     \\n        return bfs(pacific) & bfs(atlantic)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix: return []\\n        m, n = len(matrix), len(matrix[0])\\n        pacific = [(0, i) for i in range(n)] + [(i, 0) for i in range(1, m)]\\n        atlantic = [(m-1, i) for i in range(n)] + [(i, n-1) for i in range(m-1)]\\n        def bfs(q):\\n            visited = set()\\n            q = collections.deque(q)\\n            while q:\\n                i, j = q.popleft()\\n                visited.add((i, j))\\n                for ii, jj in map(lambda x: (x[0]+i, x[1]+j), [(-1, 0), (1, 0), (0, -1), (0, 1)]):\\n                    if 0 <= ii < m and 0 <= jj < n and (ii, jj) not in visited and matrix[ii][jj] >= matrix[i][j]:\\n                        q.append((ii, jj))\\n            return visited     \\n        return bfs(pacific) & bfs(atlantic)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018375,
                "title": "explanation-dfs",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\n\\n/*\\n\\nbasic idea -->\\npopulate cells reached from atlantic and cells reached from pacific with dfs\\nloop through matrix\\nadd coords to return array if they exist in both the atlantic matrix and the pacific matrix\\nreturn result\\n\\ndfs --> \\n1. base - return if out of bounds\\n2. base - return if our previous spot was larger because we are only marking spot as true\\nif it is larger than prev (prev) **this is tricky, we aren\\'t checking if the water is\\nable to flow to this spot from a previous spot...instead we are checking if water can flow out FROM this spot\\nTO the \"prev\" spot, so really prev is kind of a confusing name, because it represents the next spot that water could flow to\\n2. base - if the spot is already marked as true we can just return, because it means that water from this spot can already reach ocean\\n3. if we\\'ve reached this point it means that our flow has not yet been interrupted from our starting point\\nso we CAN reach our ocean (pacific or atlantic) from the current spot, so we simply mark that in our ocean i.e. ocean[i][j] = true\\n4. call dfs recursively on all 4 surrounding spots\\n\\n\\n*/\\nvar pacificAtlantic = function(matrix) {\\n    if (matrix.length === 0) return [] \\n   let numRows = matrix.length\\n   let numCols = matrix[0].length\\n   \\n   let atlantic = []\\n   let pacific = []\\n   for (let i = 0;i<numRows;i++){\\n       atlantic.push(new Array(numCols).fill(false))\\n       pacific.push(new Array(numCols).fill(false))\\n   }\\n   \\n   for (let col=0 ;col<matrix[0].length;col++){\\n       dfs(matrix, 0, col, Number.MIN_SAFE_INTEGER, pacific)\\n       dfs(matrix, numRows - 1, col, Number.MIN_SAFE_INTEGER, atlantic)\\n   }\\n    \\n    for (let row = 0;row<matrix.length; row++){\\n        dfs(matrix, row, 0, Number.MIN_SAFE_INTEGER, pacific)\\n        dfs(matrix, row, numCols - 1, Number.MIN_SAFE_INTEGER, atlantic)\\n    }\\n    \\n    let res = []\\n    for (let i=0;i<numRows;i++){\\n        for (let j=0;j<numCols;j++){\\n            if (atlantic[i][j] && pacific[i][j]){\\n                res.push([i, j])\\n            }\\n        }\\n    }\\n    return res\\n}\\n   \\n\\n\\nconst dfs = (matrix, i, j, prev, ocean) =>{\\n  //checkOutOfBounds\\n    if (i<0 ||\\n       i > matrix.length -1 ||\\n       j < 0 ||\\n       j > matrix[i].length - 1\\n      ) return\\n    \\n    \\n    if (matrix[i][j] < prev) return\\n    if (ocean[i][j]) return\\n    ocean[i][j] = true\\n    \\n    dfs(matrix, i+1, j, matrix[i][j], ocean)\\n    dfs(matrix, i-1, j, matrix[i][j], ocean)\\n    dfs(matrix, i, j+1, matrix[i][j], ocean)\\n    dfs(matrix, i, j-1, matrix[i][j], ocean)    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\n\\n/*\\n\\nbasic idea -->\\npopulate cells reached from atlantic and cells reached from pacific with dfs\\nloop through matrix\\nadd coords to return array if they exist in both the atlantic matrix and the pacific matrix\\nreturn result\\n\\ndfs --> \\n1. base - return if out of bounds\\n2. base - return if our previous spot was larger because we are only marking spot as true\\nif it is larger than prev (prev) **this is tricky, we aren\\'t checking if the water is\\nable to flow to this spot from a previous spot...instead we are checking if water can flow out FROM this spot\\nTO the \"prev\" spot, so really prev is kind of a confusing name, because it represents the next spot that water could flow to\\n2. base - if the spot is already marked as true we can just return, because it means that water from this spot can already reach ocean\\n3. if we\\'ve reached this point it means that our flow has not yet been interrupted from our starting point\\nso we CAN reach our ocean (pacific or atlantic) from the current spot, so we simply mark that in our ocean i.e. ocean[i][j] = true\\n4. call dfs recursively on all 4 surrounding spots\\n\\n\\n*/\\nvar pacificAtlantic = function(matrix) {\\n    if (matrix.length === 0) return [] \\n   let numRows = matrix.length\\n   let numCols = matrix[0].length\\n   \\n   let atlantic = []\\n   let pacific = []\\n   for (let i = 0;i<numRows;i++){\\n       atlantic.push(new Array(numCols).fill(false))\\n       pacific.push(new Array(numCols).fill(false))\\n   }\\n   \\n   for (let col=0 ;col<matrix[0].length;col++){\\n       dfs(matrix, 0, col, Number.MIN_SAFE_INTEGER, pacific)\\n       dfs(matrix, numRows - 1, col, Number.MIN_SAFE_INTEGER, atlantic)\\n   }\\n    \\n    for (let row = 0;row<matrix.length; row++){\\n        dfs(matrix, row, 0, Number.MIN_SAFE_INTEGER, pacific)\\n        dfs(matrix, row, numCols - 1, Number.MIN_SAFE_INTEGER, atlantic)\\n    }\\n    \\n    let res = []\\n    for (let i=0;i<numRows;i++){\\n        for (let j=0;j<numCols;j++){\\n            if (atlantic[i][j] && pacific[i][j]){\\n                res.push([i, j])\\n            }\\n        }\\n    }\\n    return res\\n}\\n   \\n\\n\\nconst dfs = (matrix, i, j, prev, ocean) =>{\\n  //checkOutOfBounds\\n    if (i<0 ||\\n       i > matrix.length -1 ||\\n       j < 0 ||\\n       j > matrix[i].length - 1\\n      ) return\\n    \\n    \\n    if (matrix[i][j] < prev) return\\n    if (ocean[i][j]) return\\n    ocean[i][j] = true\\n    \\n    dfs(matrix, i+1, j, matrix[i][j], ocean)\\n    dfs(matrix, i-1, j, matrix[i][j], ocean)\\n    dfs(matrix, i, j+1, matrix[i][j], ocean)\\n    dfs(matrix, i, j-1, matrix[i][j], ocean)    \\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324852,
                "title": "cpp-solution-2-ways-dfs-bfs-with-explanation",
                "content": "There seem to be a lack of explanation in all the CPP contributions even for some voted highly. So here\\'s one with explanations. \\n\\n**Skip to (2) if you want the working solution**\\n\\nFirst Attempt: *Solution1 class*\\n(1) The idea is for every single cell, we want to check if it can reach the atlantic, pacific, none, or both. I first started with two separate functions, one for checking the atlantic and one for checking pacific and then comparing the two...but this is too inefficient so I merged the two functions. \\n\\nWe know we can reach the pacific if we ended at row 0 or col 0 and the atlantic if we reached last row and last column, so these are the base case. But there is also a special case where we can jump from a NONE state to a BOTH state which is when we reached the \\'hot corners\\' the upper right and bottom left which are connected to both the atlantic and pacific.\\n\\nTo check if we can reach the edges, it\\'s simple: we just need to do either BFS or DFS (recursive or iterative with stacks). So from that cell we see if water can spill to its neighbours and the neighbours\\' neighbours etc. \\n\\n```\\n\\nclass Solution1 {\\nprivate: \\n    \\n    enum class State\\n    {\\n        PACIFIC,\\n        ATLANTIC, \\n        BOTH, \\n        NONE\\n    };\\n     \\n    int rowSize, colSize;\\n    vector<int> offset = {0, 1, 0, -1, 0};\\n    \\n    bool outOfBounds(int row, int col){\\n        return row < 0 || col < 0 || row >= rowSize || col >= colSize;\\n    }\\n    \\n    State flowToPacificOrAtlantic(vector<vector<int>>& matrix, int row, int col, vector<vector<bool>> visited, State prevState){       \\n        if (prevState == State::BOTH)\\n            return State::BOTH;\\n        \\n        \\n        if((row == rowSize -1 && col == 0) || (row == 0 && col== colSize -1)) // top right and bottom left (Special corners)\\n            return State::BOTH;\\n        \\n        // Update the state: We can only go from None to Pacific or Atlantic or from Pacific or Atlantic to both from here on. \\n        if (row == 0 || col == 0){ // Pacific Ocean\\n            if (prevState == State::ATLANTIC){ \\n                return prevState = State::BOTH; // We already previously reached the atlantic, so we change the state to both\\n            } else{\\n                prevState = State::PACIFIC;\\n            }\\n        } else if (row == rowSize -1 || col== colSize -1){ // Atlantic Ocean\\n            if (prevState == State::PACIFIC){\\n                return prevState = State::BOTH; // We already previously reached the pacific, so we change the state to both\\n            } else {\\n                prevState = State::ATLANTIC;\\n            }\\n        }\\n        \\n        // We need to keep track of the visited ones for cycles since we are checking equal water levels as well which means we can get\\n        // stuck in a cycle of the same values\\n        visited[row][col] = true; \\n        \\n        int currWaterLevel = matrix[row][col];\\n        for (int i = 1; i<offset.size(); i++){ // Go to left right up down using the offset --> (+1, +0) (+0, +1), (-1, +0), (+0, -1)\\n            int r = row + offset[i], c = col + offset[i-1]; // assign variable to record the row and col of the up down left right \\n            if(!outOfBounds(r , c) && \\n               currWaterLevel >= matrix[r][c] && // current water level is higher than the surrounding water\\n               !visited[r][c]){\\n                \\n                prevState = flowToPacificOrAtlantic(matrix, r, c, visited, prevState); // Update the state\\n            }\\n        }\\n        return prevState;\\n    }\\n    \\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> result;\\n        rowSize = matrix.size(); \\n        if (rowSize == 0)\\n            return result;\\n        colSize = matrix[0].size();\\n        \\n        \\n        vector<vector<bool>> visited(rowSize, vector<bool> (colSize, 0));\\n        for (int row = 0; row < rowSize; row++){\\n            for (int col = 0; col<colSize; col++){\\n                if (flowToPacificOrAtlantic(matrix, row, col, visited, State::NONE) == State::BOTH){\\n                    result.push_back({row, col});\\n                }\\n            }\\n        }     \\n        return result;\\n    }\\n};\\n```\\n\\nBut since we are recursing over every single cell for a very large m and n, this becomes very inefficeint. All we really need to do is to check for the edges and find how far the pacific ocean and atlantic ocean spill respectively. This is where the second approach comes in. \\n\\nSecond Solution: *Solution class*\\n(2) The second approach is much more efficient as mentioned before. We need to record the \\'map\\' of where the pacific  and atlantic ocean can spill into. So we need two separate maps one for the atlantic and one for the pacific. Once done, we just compare to see where the common areas where both the atlantic and pacific water can \\'spill upwards\\' from the edges. By spill upwards I mean imagine the water from the edges flowing up hill, hence we are looking for bigger numbers. This is just the reverse logic from (1).  \\n\\n\\n\\n```\\n\\nclass Solution {\\nprivate: \\n\\n    int rowSize, colSize;\\n    vector<int> offset = {0, 1, 0, -1, 0};\\n    \\n    bool outOfBounds(int row, int col){\\n        return row < 0 || col < 0 || row >= rowSize || col >= colSize;\\n    }\\n    \\n    void flowToPacificOrAtlantic(vector<vector<int>>& matrix, int row, int col, vector<vector<bool>>& visited){       \\n        visited[row][col] = true; \\n        \\n        int currWaterLevel = matrix[row][col];\\n        for (int i = 1; i<offset.size(); i++){ // Go to left right up down using the offset --> (+1, +0) (+0, +1), (-1, +0), (+0, -1)\\n            int r = row + offset[i], c = col + offset[i-1]; \\n            if(!outOfBounds(r , c) && \\n               currWaterLevel <= matrix[r][c] && // !!! current water level is lower than the surrounding water !!!\\n               !visited[r][c]){\\n                \\n                flowToPacificOrAtlantic(matrix, r, c, visited);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> result;\\n        rowSize = matrix.size(); \\n        if (rowSize == 0)\\n            return result;\\n        colSize = matrix[0].size();\\n        \\n        // initialize the maps to 0\\n        vector<vector<bool>> pacific(rowSize, vector<bool> (colSize, 0)); \\n        vector<vector<bool>> atlantic(rowSize, vector<bool> (colSize, 0));\\n\\n        for (int row = 0; row < rowSize; row++){\\n            flowToPacificOrAtlantic(matrix, row, 0, pacific); // column 0 (pacific)\\n            flowToPacificOrAtlantic(matrix, row, colSize -1, atlantic); // column end (atlantic)\\n        }    \\n        for (int col = 0; col < colSize; col++){\\n             flowToPacificOrAtlantic(matrix, 0, col, pacific); // row 0 (pacific)\\n             flowToPacificOrAtlantic(matrix, rowSize -1, col, atlantic); // row end (atlantic)\\n        }\\n\\n        // Compare the two \\'maps\\' and find where they have a common 1\\n        for (int row = 0; row<rowSize; row++){\\n            for(int col = 0; col<colSize; col++){\\n                if (pacific[row][col] == 1 && atlantic[row][col] == 1){\\n                    result.push_back({row, col});\\n                }\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\\n\\nEdit: \\nI am adding BFS rather than the DFS for finding the visited matrix. This code is very similar to DFS except it uses a queue which prevents additional space incurred by use of the call stack. Just change ```flowToPacificOrAtlantic``` to ```BFS``` from solution 2 and everything should work. \\n\\n```\\nvoid BFS(vector<vector<int>> & matrix, int row, int col, vector<vector<bool>> &visited){\\n        queue<pair<int, int>> todo;\\n        todo.push(make_pair(row, col));\\n        visited[row][col] = 1;\\n        while (!todo.empty()){\\n            pair<int, int> p = todo.front(); \\n            int currWaterLevel = matrix[p.first][p.second];\\n            todo.pop(); \\n            // check neighbours of todo\\n            for (int i = 1; i<offset.size(); i++){\\n                int r = p.first + offset[i], c =  p.second + offset[i-1];\\n                if (!outOfBounds(r, c) && currWaterLevel <= matrix[r][c] && !visited[r][c]){\\n                    todo.push(make_pair(r, c));\\n                    visited[r][c] = 1;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution1 {\\nprivate: \\n    \\n    enum class State\\n    {\\n        PACIFIC,\\n        ATLANTIC, \\n        BOTH, \\n        NONE\\n    };\\n     \\n    int rowSize, colSize;\\n    vector<int> offset = {0, 1, 0, -1, 0};\\n    \\n    bool outOfBounds(int row, int col){\\n        return row < 0 || col < 0 || row >= rowSize || col >= colSize;\\n    }\\n    \\n    State flowToPacificOrAtlantic(vector<vector<int>>& matrix, int row, int col, vector<vector<bool>> visited, State prevState){       \\n        if (prevState == State::BOTH)\\n            return State::BOTH;\\n        \\n        \\n        if((row == rowSize -1 && col == 0) || (row == 0 && col== colSize -1)) // top right and bottom left (Special corners)\\n            return State::BOTH;\\n        \\n        // Update the state: We can only go from None to Pacific or Atlantic or from Pacific or Atlantic to both from here on. \\n        if (row == 0 || col == 0){ // Pacific Ocean\\n            if (prevState == State::ATLANTIC){ \\n                return prevState = State::BOTH; // We already previously reached the atlantic, so we change the state to both\\n            } else{\\n                prevState = State::PACIFIC;\\n            }\\n        } else if (row == rowSize -1 || col== colSize -1){ // Atlantic Ocean\\n            if (prevState == State::PACIFIC){\\n                return prevState = State::BOTH; // We already previously reached the pacific, so we change the state to both\\n            } else {\\n                prevState = State::ATLANTIC;\\n            }\\n        }\\n        \\n        // We need to keep track of the visited ones for cycles since we are checking equal water levels as well which means we can get\\n        // stuck in a cycle of the same values\\n        visited[row][col] = true; \\n        \\n        int currWaterLevel = matrix[row][col];\\n        for (int i = 1; i<offset.size(); i++){ // Go to left right up down using the offset --> (+1, +0) (+0, +1), (-1, +0), (+0, -1)\\n            int r = row + offset[i], c = col + offset[i-1]; // assign variable to record the row and col of the up down left right \\n            if(!outOfBounds(r , c) && \\n               currWaterLevel >= matrix[r][c] && // current water level is higher than the surrounding water\\n               !visited[r][c]){\\n                \\n                prevState = flowToPacificOrAtlantic(matrix, r, c, visited, prevState); // Update the state\\n            }\\n        }\\n        return prevState;\\n    }\\n    \\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> result;\\n        rowSize = matrix.size(); \\n        if (rowSize == 0)\\n            return result;\\n        colSize = matrix[0].size();\\n        \\n        \\n        vector<vector<bool>> visited(rowSize, vector<bool> (colSize, 0));\\n        for (int row = 0; row < rowSize; row++){\\n            for (int col = 0; col<colSize; col++){\\n                if (flowToPacificOrAtlantic(matrix, row, col, visited, State::NONE) == State::BOTH){\\n                    result.push_back({row, col});\\n                }\\n            }\\n        }     \\n        return result;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\nprivate: \\n\\n    int rowSize, colSize;\\n    vector<int> offset = {0, 1, 0, -1, 0};\\n    \\n    bool outOfBounds(int row, int col){\\n        return row < 0 || col < 0 || row >= rowSize || col >= colSize;\\n    }\\n    \\n    void flowToPacificOrAtlantic(vector<vector<int>>& matrix, int row, int col, vector<vector<bool>>& visited){       \\n        visited[row][col] = true; \\n        \\n        int currWaterLevel = matrix[row][col];\\n        for (int i = 1; i<offset.size(); i++){ // Go to left right up down using the offset --> (+1, +0) (+0, +1), (-1, +0), (+0, -1)\\n            int r = row + offset[i], c = col + offset[i-1]; \\n            if(!outOfBounds(r , c) && \\n               currWaterLevel <= matrix[r][c] && // !!! current water level is lower than the surrounding water !!!\\n               !visited[r][c]){\\n                \\n                flowToPacificOrAtlantic(matrix, r, c, visited);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> result;\\n        rowSize = matrix.size(); \\n        if (rowSize == 0)\\n            return result;\\n        colSize = matrix[0].size();\\n        \\n        // initialize the maps to 0\\n        vector<vector<bool>> pacific(rowSize, vector<bool> (colSize, 0)); \\n        vector<vector<bool>> atlantic(rowSize, vector<bool> (colSize, 0));\\n\\n        for (int row = 0; row < rowSize; row++){\\n            flowToPacificOrAtlantic(matrix, row, 0, pacific); // column 0 (pacific)\\n            flowToPacificOrAtlantic(matrix, row, colSize -1, atlantic); // column end (atlantic)\\n        }    \\n        for (int col = 0; col < colSize; col++){\\n             flowToPacificOrAtlantic(matrix, 0, col, pacific); // row 0 (pacific)\\n             flowToPacificOrAtlantic(matrix, rowSize -1, col, atlantic); // row end (atlantic)\\n        }\\n\\n        // Compare the two \\'maps\\' and find where they have a common 1\\n        for (int row = 0; row<rowSize; row++){\\n            for(int col = 0; col<colSize; col++){\\n                if (pacific[row][col] == 1 && atlantic[row][col] == 1){\\n                    result.push_back({row, col});\\n                }\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```\n```flowToPacificOrAtlantic```\n```BFS```\n```\\nvoid BFS(vector<vector<int>> & matrix, int row, int col, vector<vector<bool>> &visited){\\n        queue<pair<int, int>> todo;\\n        todo.push(make_pair(row, col));\\n        visited[row][col] = 1;\\n        while (!todo.empty()){\\n            pair<int, int> p = todo.front(); \\n            int currWaterLevel = matrix[p.first][p.second];\\n            todo.pop(); \\n            // check neighbours of todo\\n            for (int i = 1; i<offset.size(); i++){\\n                int r = p.first + offset[i], c =  p.second + offset[i-1];\\n                if (!outOfBounds(r, c) && currWaterLevel <= matrix[r][c] && !visited[r][c]){\\n                    todo.push(make_pair(r, c));\\n                    visited[r][c] = 1;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183836,
                "title": "c-solution-bfs-implementation-easy-to-understand-clean-code",
                "content": "First of all many of us might be having some issues understanding the problem.\\n\\n**Confusion : Is water going from ocean to island?**\\n\\nNo, actually we are given an island and we are asked if we supply a specific coordinate with water then tell us the flow of water.\\nCan the water flow to both pacific and atlantic ocean from a specific coordinate ? If yes then add that coordinate in your answer.\\n\\nHope you got the point!\\n\\n\\tvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int n = heights.size();\\n        int m = heights[0].size();\\n        \\n\\t\\t//the points from where its possible to flow water to pacific\\n        vector<vector<bool> > pacific(n, vector<bool> (m,false));\\n\\t\\t//same for atlantic\\n        vector<vector<bool> > atlantic(n, vector<bool> (m,false));\\n        \\n\\t\\t//utility queues for both oceans\\n        queue<pair<int,int> > pq;\\n        queue<pair<int,int>> aq;\\n        \\n\\t\\t//push the respective boundary elements to the pacific and atlantic queue and bool array\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i == 0 || j == 0){\\n                    pq.push({i,j});\\n                    pacific[i][j] = true;\\n                }\\n                \\n                if(i == n-1 || j == m-1){\\n                    aq.push({i,j});\\n                    atlantic[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//final answer array containing commom points\\n        vector<vector<int> > ans;\\n        \\n        bfs(heights, pq, pacific);\\n        bfs(heights, aq, atlantic);\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n                                       \\n    }\\n    \\n    void bfs(vector<vector<int>> &heights, queue<pair<int,int> > q, vector<vector<bool> > &vis){\\n        int n = heights.size();\\n        int m = heights[0].size();\\n        \\n\\t\\t//direction arrays\\n        vector<int> dx = {0,0,1,-1};\\n        vector<int> dy = {-1,1,0,0};\\n        \\n        while(!q.empty()){\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            \\n            q.pop();\\n            \\n\\t\\t\\t//iterate all 4 directions\\n            for(int i=0; i<4; i++){\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n\\t\\t\\t\\t//along with all the eligibility criteria the next coordinates height must be greater than or equal to the current coordinates heights cause we are moving from ocean to island and\\n\\t\\t\\t\\t//we want the water to go from island to ocean.\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == false && heights[nx][ny] >= heights[x][y]){\\n                    q.push({nx,ny});\\n                    vis[nx][ny] = true;\\n                }\\n            }\\n        }\\n        \\n        return ;\\n    }\\n\\t\\n**ps: feel free to ask any question in the comment section : )**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "First of all many of us might be having some issues understanding the problem.\\n\\n**Confusion : Is water going from ocean to island?**\\n\\nNo, actually we are given an island and we are asked if we supply a specific coordinate with water then tell us the flow of water.\\nCan the water flow to both pacific and atlantic ocean from a specific coordinate ? If yes then add that coordinate in your answer.\\n\\nHope you got the point!\\n\\n\\tvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int n = heights.size();\\n        int m = heights[0].size();\\n        \\n\\t\\t//the points from where its possible to flow water to pacific\\n        vector<vector<bool> > pacific(n, vector<bool> (m,false));\\n\\t\\t//same for atlantic\\n        vector<vector<bool> > atlantic(n, vector<bool> (m,false));\\n        \\n\\t\\t//utility queues for both oceans\\n        queue<pair<int,int> > pq;\\n        queue<pair<int,int>> aq;\\n        \\n\\t\\t//push the respective boundary elements to the pacific and atlantic queue and bool array\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(i == 0 || j == 0){\\n                    pq.push({i,j});\\n                    pacific[i][j] = true;\\n                }\\n                \\n                if(i == n-1 || j == m-1){\\n                    aq.push({i,j});\\n                    atlantic[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n\\t\\t//final answer array containing commom points\\n        vector<vector<int> > ans;\\n        \\n        bfs(heights, pq, pacific);\\n        bfs(heights, aq, atlantic);\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n                                       \\n    }\\n    \\n    void bfs(vector<vector<int>> &heights, queue<pair<int,int> > q, vector<vector<bool> > &vis){\\n        int n = heights.size();\\n        int m = heights[0].size();\\n        \\n\\t\\t//direction arrays\\n        vector<int> dx = {0,0,1,-1};\\n        vector<int> dy = {-1,1,0,0};\\n        \\n        while(!q.empty()){\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            \\n            q.pop();\\n            \\n\\t\\t\\t//iterate all 4 directions\\n            for(int i=0; i<4; i++){\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n\\t\\t\\t\\t//along with all the eligibility criteria the next coordinates height must be greater than or equal to the current coordinates heights cause we are moving from ocean to island and\\n\\t\\t\\t\\t//we want the water to go from island to ocean.\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < m && vis[nx][ny] == false && heights[nx][ny] >= heights[x][y]){\\n                    q.push({nx,ny});\\n                    vis[nx][ny] = true;\\n                }\\n            }\\n        }\\n        \\n        return ;\\n    }\\n\\t\\n**ps: feel free to ask any question in the comment section : )**",
                "codeTag": "Unknown"
            },
            {
                "id": 760606,
                "title": "c-solution-with-short-explanation-dfs",
                "content": "The main idea is to try to go from the edges (\"oceans\") to other nodes. By keeping track of reached nodes from each \"ocean\" we can find the nodes which can reach both oceans.\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<vector<int>>& matrix, const vector<pair<int, int>> &coords, vector<vector<bool>> &visited, int i, int j) {\\n        visited[i][j] = true;\\n        \\n        for(auto &coord : coords) {\\n            int next_i = coord.first + i;\\n            int next_j = coord.second + j;\\n            \\n\\t\\t\\t// since we\\'re going backwards (from \"ocean\" instead of to) we want the next node\\'s value to be equal to or more than the current node\\'s value\\n            if (is_in_bounds(matrix, next_i, next_j) && !visited[next_i][next_j] && matrix[next_i][next_j] >= matrix[i][j]) {\\n                dfs(matrix, coords, visited, next_i, next_j);\\n            }\\n        }\\n    }\\n    \\n    bool is_in_bounds(const vector<vector<int>>& matrix, int i, int j) {\\n        return i >= 0 && j >= 0 && i < matrix.size() && j < matrix[0].size();\\n    }\\n    \\npublic:\\n    vector<vector<int>> pacificAtlantic(const vector<vector<int>>& matrix) {\\n        if (matrix.empty())\\n            return vector<vector<int>>();\\n        \\n        const vector<pair<int, int>> coords = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<bool>> visited_atlantic(n, vector<bool>(m, false));\\n        vector<vector<bool>> visited_pacific(n, vector<bool>(m, false));\\n        \\n        for(int i = 0; i < n; i++) {\\n\\t\\t    // left edge for pacific ocean\\n            dfs(matrix, coords, visited_pacific, i, 0);\\n\\t\\t    // right edge for atlantic ocean\\n            dfs(matrix, coords, visited_atlantic, i, m - 1);\\n        }\\n        for(int j = 0; j < m; j++) {\\n            // top edge for pacific ocean\\n            dfs(matrix, coords, visited_pacific, 0, j);\\n\\t\\t\\t// bottom edge for atlantic ocean\\n            dfs(matrix, coords, visited_atlantic, n - 1, j);\\n        }\\n        \\n        vector<vector<int>> result;\\n\\t\\t// find the nodes that can reach both oceans\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if (visited_pacific[i][j] && visited_atlantic[i][j])\\n                    result.push_back({ i, j });\\n        \\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<vector<int>>& matrix, const vector<pair<int, int>> &coords, vector<vector<bool>> &visited, int i, int j) {\\n        visited[i][j] = true;\\n        \\n        for(auto &coord : coords) {\\n            int next_i = coord.first + i;\\n            int next_j = coord.second + j;\\n            \\n\\t\\t\\t// since we\\'re going backwards (from \"ocean\" instead of to) we want the next node\\'s value to be equal to or more than the current node\\'s value\\n            if (is_in_bounds(matrix, next_i, next_j) && !visited[next_i][next_j] && matrix[next_i][next_j] >= matrix[i][j]) {\\n                dfs(matrix, coords, visited, next_i, next_j);\\n            }\\n        }\\n    }\\n    \\n    bool is_in_bounds(const vector<vector<int>>& matrix, int i, int j) {\\n        return i >= 0 && j >= 0 && i < matrix.size() && j < matrix[0].size();\\n    }\\n    \\npublic:\\n    vector<vector<int>> pacificAtlantic(const vector<vector<int>>& matrix) {\\n        if (matrix.empty())\\n            return vector<vector<int>>();\\n        \\n        const vector<pair<int, int>> coords = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n        \\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<bool>> visited_atlantic(n, vector<bool>(m, false));\\n        vector<vector<bool>> visited_pacific(n, vector<bool>(m, false));\\n        \\n        for(int i = 0; i < n; i++) {\\n\\t\\t    // left edge for pacific ocean\\n            dfs(matrix, coords, visited_pacific, i, 0);\\n\\t\\t    // right edge for atlantic ocean\\n            dfs(matrix, coords, visited_atlantic, i, m - 1);\\n        }\\n        for(int j = 0; j < m; j++) {\\n            // top edge for pacific ocean\\n            dfs(matrix, coords, visited_pacific, 0, j);\\n\\t\\t\\t// bottom edge for atlantic ocean\\n            dfs(matrix, coords, visited_atlantic, n - 1, j);\\n        }\\n        \\n        vector<vector<int>> result;\\n\\t\\t// find the nodes that can reach both oceans\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if (visited_pacific[i][j] && visited_atlantic[i][j])\\n                    result.push_back({ i, j });\\n        \\n        return result;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140233,
                "title": "java-dfs-solution-beat-99-99-and-sharing-my-thoughts-666",
                "content": "So the basic idea is start from 4 boards, for the points in the first row and column, they are definitely connect with Pacific Ocean, and for the points in the last row and columnm, they are connected with A Ocean. Then, run dfs first time to mark these points that is able to connect with Pacifica Ocean as \\'P\\', run dfs second time to find the points that has been already marked as \"P\", if its \\'A\\' then we find a point is able to connect with both P and A. Thus the total time complexity will be O(2 * m * n)\\n```\\nprivate static final int[][] directions = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) return res;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        char[][] visited = new char[m][n];\\n          for (int col = 0; col < n; col++) {\\n            dfs(matrix, 0, col, visited, \\'P\\', res);\\n        }\\n        for (int row = 0; row < m; row++) {\\n            dfs(matrix, row, 0, visited, \\'P\\', res);\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            dfs(matrix, m - 1, col, visited, \\'A\\', res);\\n        }\\n        for (int row = 0; row < m; row++) {\\n            dfs(matrix, row, n - 1, visited, \\'A\\', res);\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int[][] matrix, int row, int col, char[][] visited, char ch, List<int[]> res) {\\n        if (visited[row][col] == \\'P\\' && ch == \\'A\\') res.add(new int[]{row, col});\\n        visited[row][col] = ch;\\n        for (int[] dir : directions) {\\n            int x = row + dir[0];\\n            int y = col + dir[1];\\n            if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[row][col] > matrix[x][y] || visited[x][y] == ch) continue;\\n            dfs(matrix, x, y, visited, ch, res);\\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "So the basic idea is start from 4 boards, for the points in the first row and column, they are definitely connect with Pacific Ocean, and for the points in the last row and columnm, they are connected with A Ocean. Then, run dfs first time to mark these points that is able to connect with Pacifica Ocean as \\'P\\', run dfs second time to find the points that has been already marked as \"P\", if its \\'A\\' then we find a point is able to connect with both P and A. Thus the total time complexity will be O(2 * m * n)\\n```\\nprivate static final int[][] directions = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) return res;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        char[][] visited = new char[m][n];\\n          for (int col = 0; col < n; col++) {\\n            dfs(matrix, 0, col, visited, \\'P\\', res);\\n        }\\n        for (int row = 0; row < m; row++) {\\n            dfs(matrix, row, 0, visited, \\'P\\', res);\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            dfs(matrix, m - 1, col, visited, \\'A\\', res);\\n        }\\n        for (int row = 0; row < m; row++) {\\n            dfs(matrix, row, n - 1, visited, \\'A\\', res);\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int[][] matrix, int row, int col, char[][] visited, char ch, List<int[]> res) {\\n        if (visited[row][col] == \\'P\\' && ch == \\'A\\') res.add(new int[]{row, col});\\n        visited[row][col] = ch;\\n        for (int[] dir : directions) {\\n            int x = row + dir[0];\\n            int y = col + dir[1];\\n            if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[row][col] > matrix[x][y] || visited[x][y] == ch) continue;\\n            dfs(matrix, x, y, visited, ch, res);\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3266691,
                "title": "417-time-96-50-and-space-94-12-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the input matrix is empty. If it is, return an empty list.\\n\\n2. Determine the number of rows and columns in the input matrix.\\n\\n3. Create two visited matrices of the same size as the input matrix, one for each ocean.\\n\\n4. Create two empty queues, one for each ocean.\\n\\n5. Add all the cells in the first and last rows to the Pacific queue, and mark them as visited in the Pacific visited matrix. Add all the cells in the first and last columns to the Atlantic queue, and mark them as visited in the Atlantic visited matrix.\\n\\n6. Define a helper function, bfs, that takes a queue and a visited matrix as input, and runs a breadth-first search on the input matrix starting from the cells in the queue. The function visits each cell that can flow to the ocean and adds it to the queue.\\n\\n7. Run bfs on both oceans, starting from the boundary cells.\\n\\n8. Find the cells that can flow to both oceans by iterating through all cells in the input matrix, and adding the ones that are marked as visited in both the Pacific and Atlantic visited matrices to the result list.\\n\\n9. Return the result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        if not heights:\\n            return []\\n        \\n        rows, cols = len(heights), len(heights[0])\\n        \\n        # Create visited matrices for both oceans\\n        pacific_visited = [[False] * cols for _ in range(rows)]\\n        atlantic_visited = [[False] * cols for _ in range(rows)]\\n        \\n        # Create queue for both oceans\\n        pacific_queue = deque()\\n        atlantic_queue = deque()\\n        \\n        # Add cells in the first and last rows to their respective queues\\n        for col in range(cols):\\n            pacific_queue.append((0, col))\\n            atlantic_queue.append((rows-1, col))\\n            pacific_visited[0][col] = True\\n            atlantic_visited[rows-1][col] = True\\n        \\n        # Add cells in the first and last columns to their respective queues\\n        for row in range(rows):\\n            pacific_queue.append((row, 0))\\n            atlantic_queue.append((row, cols-1))\\n            pacific_visited[row][0] = True\\n            atlantic_visited[row][cols-1] = True\\n        \\n        # Define helper function to check if a cell can flow to an ocean\\n        def bfs(queue, visited):\\n            while queue:\\n                row, col = queue.popleft()\\n                # Check adjacent cells\\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    r, c = row + dr, col + dc\\n                    # Check if cell is within bounds and hasn\\'t been visited yet\\n                    if 0 <= r < rows and 0 <= c < cols and not visited[r][c]:\\n                        # Check if cell can flow to the ocean\\n                        if heights[r][c] >= heights[row][col]:\\n                            visited[r][c] = True\\n                            queue.append((r, c))\\n        \\n        # Run BFS on both oceans starting from the boundary cells\\n        bfs(pacific_queue, pacific_visited)\\n        bfs(atlantic_queue, atlantic_visited)\\n        \\n        # Find the cells that can flow to both oceans\\n        result = []\\n        for row in range(rows):\\n            for col in range(cols):\\n                if pacific_visited[row][col] and atlantic_visited[row][col]:\\n                    result.append([row, col])\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        if not heights:\\n            return []\\n        \\n        rows, cols = len(heights), len(heights[0])\\n        \\n        # Create visited matrices for both oceans\\n        pacific_visited = [[False] * cols for _ in range(rows)]\\n        atlantic_visited = [[False] * cols for _ in range(rows)]\\n        \\n        # Create queue for both oceans\\n        pacific_queue = deque()\\n        atlantic_queue = deque()\\n        \\n        # Add cells in the first and last rows to their respective queues\\n        for col in range(cols):\\n            pacific_queue.append((0, col))\\n            atlantic_queue.append((rows-1, col))\\n            pacific_visited[0][col] = True\\n            atlantic_visited[rows-1][col] = True\\n        \\n        # Add cells in the first and last columns to their respective queues\\n        for row in range(rows):\\n            pacific_queue.append((row, 0))\\n            atlantic_queue.append((row, cols-1))\\n            pacific_visited[row][0] = True\\n            atlantic_visited[row][cols-1] = True\\n        \\n        # Define helper function to check if a cell can flow to an ocean\\n        def bfs(queue, visited):\\n            while queue:\\n                row, col = queue.popleft()\\n                # Check adjacent cells\\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    r, c = row + dr, col + dc\\n                    # Check if cell is within bounds and hasn\\'t been visited yet\\n                    if 0 <= r < rows and 0 <= c < cols and not visited[r][c]:\\n                        # Check if cell can flow to the ocean\\n                        if heights[r][c] >= heights[row][col]:\\n                            visited[r][c] = True\\n                            queue.append((r, c))\\n        \\n        # Run BFS on both oceans starting from the boundary cells\\n        bfs(pacific_queue, pacific_visited)\\n        bfs(atlantic_queue, atlantic_visited)\\n        \\n        # Find the cells that can flow to both oceans\\n        result = []\\n        for row in range(rows):\\n            for col in range(cols):\\n                if pacific_visited[row][col] and atlantic_visited[row][col]:\\n                    result.append([row, col])\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384871,
                "title": "c-shortest-solution-dfs-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    \\n   void dfs(int i,int j,vector<vector<int>>& height, vector<vector<bool>> &ocean)\\n   {\\n        \\n        int n=height.size();\\n        int m=height[0].size();\\n        if(ocean[i][j]==false)\\n          ocean[i][j]=true;\\n          if(i>0 && height[i-1][j]>=height[i][j] && ocean[i-1][j]==false)dfs(i-1,j,height,ocean);\\n          if(j>0 && height[i][j-1]>=height[i][j] && ocean[i][j-1]==false)dfs(i,j-1,height,ocean);\\n          if(i<n-1 && height[i+1][j]>=height[i][j] && ocean[i+1][j]==false)dfs(i+1,j,height,ocean);\\n          if(j<m-1 && height[i][j+1]>=height[i][j] && ocean[i][j+1]==false)dfs(i,j+1,height,ocean);\\n          return;\\n   }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n         vector<vector<int>> ans;\\n        \\n           \\n        int n=heights.size();\\n        int m=heights[0].size();\\n         vector<vector<bool>> pacific(n+1,vector<bool>(m+1,false));\\n         vector<vector<bool>> atlantic(n+1,vector<bool>(m+1,false));\\n  \\n      \\n        //Check Edges for Pacific ocean\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0 || j==0)\\n                dfs(i,j,heights,pacific);  \\n          }\\n        }\\n        \\n        \\n        //Check Edges for Atlantic ocean\\n        for(int i=0;i<n;i++)\\n        {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==n-1 || j==m-1)\\n                dfs(i,j,heights,atlantic);  \\n          }\\n        }\\n       \\n        \\n        //If water can flow from a cell in both atlantic and pacific add that to our answer.\\n           for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(atlantic[i][j]==true && pacific[i][j]==true)\\n                     ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```\\nPlease upvote if it was helpful.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n   void dfs(int i,int j,vector<vector<int>>& height, vector<vector<bool>> &ocean)\\n   {\\n        \\n        int n=height.size();\\n        int m=height[0].size();\\n        if(ocean[i][j]==false)\\n          ocean[i][j]=true;\\n          if(i>0 && height[i-1][j]>=height[i][j] && ocean[i-1][j]==false)dfs(i-1,j,height,ocean);\\n          if(j>0 && height[i][j-1]>=height[i][j] && ocean[i][j-1]==false)dfs(i,j-1,height,ocean);\\n          if(i<n-1 && height[i+1][j]>=height[i][j] && ocean[i+1][j]==false)dfs(i+1,j,height,ocean);\\n          if(j<m-1 && height[i][j+1]>=height[i][j] && ocean[i][j+1]==false)dfs(i,j+1,height,ocean);\\n          return;\\n   }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n         vector<vector<int>> ans;\\n        \\n           \\n        int n=heights.size();\\n        int m=heights[0].size();\\n         vector<vector<bool>> pacific(n+1,vector<bool>(m+1,false));\\n         vector<vector<bool>> atlantic(n+1,vector<bool>(m+1,false));\\n  \\n      \\n        //Check Edges for Pacific ocean\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==0 || j==0)\\n                dfs(i,j,heights,pacific);  \\n          }\\n        }\\n        \\n        \\n        //Check Edges for Atlantic ocean\\n        for(int i=0;i<n;i++)\\n        {\\n          for(int j=0;j<m;j++)\\n          {\\n              if(i==n-1 || j==m-1)\\n                dfs(i,j,heights,atlantic);  \\n          }\\n        }\\n       \\n        \\n        //If water can flow from a cell in both atlantic and pacific add that to our answer.\\n           for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(atlantic[i][j]==true && pacific[i][j]==true)\\n                     ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126814,
                "title": "pacific-atlantic-water-flow-js-python-java-c-easy-dfs-recursion-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIt should be obvious from the start that we\\'ll need to solve this problem in reverse. We know that the edges of the input matrix (**M**) will flow water out to the ocean on their respective sides, and we can tell whether an adjacent cell will funnel water to the current cell, so we\\'ll have to start from the edges and work our way inward.\\n\\nUnfortunately, since the path the water will take can possibly wind around, we can\\'t do a straight one-time iteration. Instead, we\\'ll have to use a **depth first search** (**DFS**) approach with either a **stack**/**queue** structure or **recursion**.\\n\\nFor each cell that touches an ocean, we\\'ll have to follow the reverse path of the water up the continent as far as it will go. Since we only want cells that are reached by both oceans, we\\'ll need a data structure to store the preliminary data for the cells while we wait for the opposite ocean to potentially find the same cell.\\n\\nThere are a few ways we can do this, but I\\'ll choose a **dynamic programming** (**DP**) array (**dp**). Since there\\'s no real reason to mimic the **2-D matrix** structure of **M**, we can just use a flattened **1-D array** instead, which should save some processing overhead. In order to store both oceans\\' data discretely in **dp**, we can use **+1** for one and **+2** for the other. That means that when a cell goes to **3**, it should be added to our answer array (**ans**).\\n\\nOur DFS recursion function (**dfs**) should also check to make sure that we haven\\'t already marked this cell with the current ocean (**w**) by using a **bitwise AND** (**&**) operator. Then, at the end of **dfs** we should fire off new recursions in all four directions, if possible.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use the lighter, typed **Uint8Array** for **dp**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **100ms / 44.1MB** (beats 100% / 100%).\\n```javascript\\nvar pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **264ms / 15.6MB** (beats 97% / 53%).\\n```python\\nclass Solution:\\n    def pacificAtlantic(self, M: List[List[int]]) -> List[List[int]]:\\n        if not M: return M\\n        x, y = len(M[0]), len(M)\\n        ans, dp = [], [0] * (x * y)\\n        def dfs(i: int, j: int, w: int, h: int):\\n            ij = i * x + j\\n            if dp[ij] & w or M[i][j] < h: return\\n            dp[ij] += w\\n            h = M[i][j]\\n            if dp[ij] == 3: ans.append([i,j])\\n            if i + 1 < y: dfs(i+1, j, w, h)\\n            if i > 0: dfs(i-1, j, w, h)\\n            if j + 1 < x: dfs(i, j+1, w, h)\\n            if j > 0: dfs(i, j-1, w, h)\\n        for i in range(y):\\n            dfs(i, 0, 1, M[i][0])\\n            dfs(i, x-1, 2, M[i][x-1])\\n        for j in range(x):\\n            dfs(0, j, 1, M[0][j])\\n            dfs(y-1, j, 2, M[y-1][j])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 40.4MB** (beats 100% / 43%).\\n```java\\nclass Solution {\\n    static void dfs(int i, int j, int w, int h, int[][] M, byte[] dp, List<List<Integer>> ans) {\\n        int ij = i * M[0].length + j;\\n        if ((dp[ij] & w) > 0 || M[i][j] < h) return;\\n        dp[ij] += w;\\n        h = M[i][j];\\n        if (dp[ij] == 3) ans.add(Arrays.asList(i,j));\\n        if (i + 1 < M.length) dfs(i+1, j, w, h, M, dp, ans);\\n        if (i > 0) dfs(i-1, j, w, h, M, dp, ans);\\n        if (j + 1 < M[0].length) dfs(i, j+1, w, h, M, dp, ans);\\n        if (j > 0) dfs(i, j-1, w, h, M, dp, ans);\\n    }\\n    public List<List<Integer>> pacificAtlantic(int[][] M) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (M.length == 0) return ans;\\n        int y = M.length, x = M[0].length;\\n        byte[] dp = new byte[x * y];\\n        for (int i = 0; i < x; i++) {\\n            dfs(0, i, 1, M[0][i], M, dp, ans);\\n            dfs(y-1, i, 2, M[y-1][i], M, dp, ans);\\n        }   \\n        for (int i = 0; i < y; i++) {\\n            dfs(i, 0, 1, M[i][0], M, dp, ans);\\n            dfs(i, x-1, 2, M[i][x-1], M, dp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **24ms / 16.7MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        if (M.empty()) return ans;\\n        int y = M.size(), x = M[0].size();\\n        vector<char> dp(y * x);\\n        for (int i = 0; i < y; i++) {\\n            dfs(M, dp, i, 0, 1, 0);\\n            dfs(M, dp, i, x - 1, 2, 0);\\n        }\\n        for (int i = 0; i < x; i++) {\\n            dfs(M, dp, 0, i, 1, 0);\\n            dfs(M, dp, y - 1, i, 2, 0);\\n        }\\n        for (int i = 0; i < y; i++) \\n            for (int j = 0; j < x; j++) \\n                if (dp[i * x + j] == 3) \\n                    ans.push_back({i, j});\\n        return ans;\\n    }\\nprivate:\\n    void dfs(const vector<vector<int>>& M, vector<char>& dp, int i, int j, int w, int h) {\\n        int y = M.size(), x = M[0].size(), ij = i * x + j, newh = M[i][j];;\\n        if ((dp[ij] & w) || M[i][j] < h) return;\\n        dp[ij] += w;\\n        if (i + 1 < y) dfs(M, dp, i + 1, j, w, newh);\\n        if (i > 0) dfs(M, dp, i - 1, j, w, newh);\\n        if (j + 1 < x) dfs(M, dp, i, j + 1, w, newh);\\n        if (j > 0) dfs(M, dp, i, j - 1, w, newh);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def pacificAtlantic(self, M: List[List[int]]) -> List[List[int]]:\\n        if not M: return M\\n        x, y = len(M[0]), len(M)\\n        ans, dp = [], [0] * (x * y)\\n        def dfs(i: int, j: int, w: int, h: int):\\n            ij = i * x + j\\n            if dp[ij] & w or M[i][j] < h: return\\n            dp[ij] += w\\n            h = M[i][j]\\n            if dp[ij] == 3: ans.append([i,j])\\n            if i + 1 < y: dfs(i+1, j, w, h)\\n            if i > 0: dfs(i-1, j, w, h)\\n            if j + 1 < x: dfs(i, j+1, w, h)\\n            if j > 0: dfs(i, j-1, w, h)\\n        for i in range(y):\\n            dfs(i, 0, 1, M[i][0])\\n            dfs(i, x-1, 2, M[i][x-1])\\n        for j in range(x):\\n            dfs(0, j, 1, M[0][j])\\n            dfs(y-1, j, 2, M[y-1][j])\\n        return ans\\n```\n```java\\nclass Solution {\\n    static void dfs(int i, int j, int w, int h, int[][] M, byte[] dp, List<List<Integer>> ans) {\\n        int ij = i * M[0].length + j;\\n        if ((dp[ij] & w) > 0 || M[i][j] < h) return;\\n        dp[ij] += w;\\n        h = M[i][j];\\n        if (dp[ij] == 3) ans.add(Arrays.asList(i,j));\\n        if (i + 1 < M.length) dfs(i+1, j, w, h, M, dp, ans);\\n        if (i > 0) dfs(i-1, j, w, h, M, dp, ans);\\n        if (j + 1 < M[0].length) dfs(i, j+1, w, h, M, dp, ans);\\n        if (j > 0) dfs(i, j-1, w, h, M, dp, ans);\\n    }\\n    public List<List<Integer>> pacificAtlantic(int[][] M) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (M.length == 0) return ans;\\n        int y = M.length, x = M[0].length;\\n        byte[] dp = new byte[x * y];\\n        for (int i = 0; i < x; i++) {\\n            dfs(0, i, 1, M[0][i], M, dp, ans);\\n            dfs(y-1, i, 2, M[y-1][i], M, dp, ans);\\n        }   \\n        for (int i = 0; i < y; i++) {\\n            dfs(i, 0, 1, M[i][0], M, dp, ans);\\n            dfs(i, x-1, 2, M[i][x-1], M, dp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        if (M.empty()) return ans;\\n        int y = M.size(), x = M[0].size();\\n        vector<char> dp(y * x);\\n        for (int i = 0; i < y; i++) {\\n            dfs(M, dp, i, 0, 1, 0);\\n            dfs(M, dp, i, x - 1, 2, 0);\\n        }\\n        for (int i = 0; i < x; i++) {\\n            dfs(M, dp, 0, i, 1, 0);\\n            dfs(M, dp, y - 1, i, 2, 0);\\n        }\\n        for (int i = 0; i < y; i++) \\n            for (int j = 0; j < x; j++) \\n                if (dp[i * x + j] == 3) \\n                    ans.push_back({i, j});\\n        return ans;\\n    }\\nprivate:\\n    void dfs(const vector<vector<int>>& M, vector<char>& dp, int i, int j, int w, int h) {\\n        int y = M.size(), x = M[0].size(), ij = i * x + j, newh = M[i][j];;\\n        if ((dp[ij] & w) || M[i][j] < h) return;\\n        dp[ij] += w;\\n        if (i + 1 < y) dfs(M, dp, i + 1, j, w, newh);\\n        if (i > 0) dfs(M, dp, i - 1, j, w, newh);\\n        if (j + 1 < x) dfs(M, dp, i, j + 1, w, newh);\\n        if (j > 0) dfs(M, dp, i, j - 1, w, newh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954799,
                "title": "dfs-python3-easy-to-understand-with-comments",
                "content": "Please +1 if you like the solution\\n```\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix or not matrix[0]:\\n                return []\\n    \\n        # list which will have both the coordinates\\n        pacific = set()\\n        atlantic = set()\\n        # get the number of rows and columns\\n        m,n = len(matrix), len(matrix[0])\\n\\n        # define left, right, up, down\\n        directions = [(-1,0),(1,0),(0,1),(0,-1)]\\n\\n        # define the dfs traversal\\n        def dfs(visited, x,y):\\n            visited.add((x,y))\\n            for dx, dy in directions:\\n                new_x, new_y  = x + dx, y + dy\\n\\n                # if the coordinates are valid and if c(i) > c (i-1)\\n                if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and matrix[new_x][new_y] >= matrix[x][y]:\\n                    dfs (visited, new_x, new_y)\\n\\n        # iterate for rows\\n        for i in range(m):\\n            dfs(pacific, i , 0)\\n            dfs(atlantic, i, n-1)\\n\\n        # iterate for columns\\n        for j in range(n):\\n            dfs(pacific, 0 , j)\\n            dfs(atlantic, m-1, j)\\n\\n        # return the matching coordinates\\n        return list(pacific.intersection(atlantic))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix or not matrix[0]:\\n                return []\\n    \\n        # list which will have both the coordinates\\n        pacific = set()\\n        atlantic = set()\\n        # get the number of rows and columns\\n        m,n = len(matrix), len(matrix[0])\\n\\n        # define left, right, up, down\\n        directions = [(-1,0),(1,0),(0,1),(0,-1)]\\n\\n        # define the dfs traversal\\n        def dfs(visited, x,y):\\n            visited.add((x,y))\\n            for dx, dy in directions:\\n                new_x, new_y  = x + dx, y + dy\\n\\n                # if the coordinates are valid and if c(i) > c (i-1)\\n                if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and matrix[new_x][new_y] >= matrix[x][y]:\\n                    dfs (visited, new_x, new_y)\\n\\n        # iterate for rows\\n        for i in range(m):\\n            dfs(pacific, i , 0)\\n            dfs(atlantic, i, n-1)\\n\\n        # iterate for columns\\n        for j in range(n):\\n            dfs(pacific, 0 , j)\\n            dfs(atlantic, m-1, j)\\n\\n        # return the matching coordinates\\n        return list(pacific.intersection(atlantic))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903332,
                "title": "c-bfs-solution-explained",
                "content": "Runtime: 76 ms, faster than 80.07% of C++ online submissions for Pacific Atlantic Water Flow.\\nMemory Usage: 18.3 MB, less than 5.28% of C++ online submissions for Pacific Atlantic Water Flow.\\n\\n\\n```\\nAs we want grid position from where water can reach both pacific and atlantic ocean, we can \\nalso think it as grid positions which are reachable both from pacific and atlantic ocean boundary.\\n\\nRun BFS from all pacific boundary positions and track reachable grid positions, also run BFS from\\natlantic boundary postions and track reachable grid positions. Grid position which are both\\nreachable from pacific and atlantic are the result. From boundary positions water can flow in to\\nneighbor grid positions which have greater or equal height.\\n\\nExample: \\n\\nYellow = Reachable from pacific boundary\\nBlue = Reachable from atlantic boundary\\nGreen = Reachable from both boundary\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e58f1f23-3ec8-4f7c-b5dd-87e19661bd95_1603217239.0575259.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // run bfs to track reachable grid position from pacific or atlantic boundary\\n    void bfs(int m, int n, queue<pair<int,int>>&Q, vector<vector<int>>& grid, vector<vector<bool>>&visited)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        int currentHeight;\\n        int cx,cy;\\n        int px,py;\\n        \\n        while(!Q.empty())\\n        {\\n            cx = Q.front().first;\\n            cy = Q.front().second;\\n            currentHeight = grid[cx][cy];\\n            \\n            Q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                px = cx + rowOffset[k];\\n                py = cy + colOffset[k];\\n                \\n                // child node can be reached from current nodes if \\n                // greater or equal in height compared to current node height\\n                if(px>=0 && px<m && py>=0 && py<n && grid[px][py]>=currentHeight && !visited[px][py])\\n                {\\n                    visited[px][py] = true;\\n                    Q.push({px,py});\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>>result;\\n        \\n        int m = grid.size();\\n        if(m==0) return result;\\n        \\n        int n = grid[0].size();\\n        if(n==0) return result;\\n        \\n        // track nodes reachable from pacific boundary\\n        vector<vector<bool>>pacificVisited(m,vector<bool>(n,false));\\n        \\n        // track nodes reachable from atlantic boundary\\n        vector<vector<bool>>atlanticVisited(m,vector<bool>(n,false));\\n        \\n        queue<pair<int,int>>Q;\\n        \\n        // add pacific boundary nodes  in to queue\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!pacificVisited[0][i])\\n            {\\n                pacificVisited[0][i] = true;\\n                Q.push({0,i});                    \\n            }\\n        }\\n\\n        // add pacific boundary nodes  in to queue       \\n        for(int i=1;i<m;i++)\\n        {\\n            if(!pacificVisited[i][0])\\n            {\\n                pacificVisited[i][0] = true;\\n                Q.push({i,0});                    \\n            }\\n        }\\n        \\n        // run bfs from pacific boundary nodes\\n        bfs(m,n,Q,grid,pacificVisited);\\n        \\n        // add atlantic boundary nodes\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!atlanticVisited[m-1][i])\\n            {\\n                atlanticVisited[m-1][i] = true;\\n                Q.push({m-1,i});                    \\n            }\\n        }\\n\\n        // add atlantic boundary nodes        \\n        for(int i=0;i<m-1;i++)\\n        {\\n            if(!atlanticVisited[i][n-1])\\n            {\\n                atlanticVisited[i][n-1] = true;\\n                Q.push({i,n-1});                    \\n            }\\n        }\\n        \\n        // run bfs from atlantic boundary nodes\\n        bfs(m,n,Q,grid,atlanticVisited);\\n        \\n        // push nodes in to result vector which are reachable both from pacific and atlantic boundary\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(pacificVisited[i][j] && atlanticVisited[i][j])\\n                    result.push_back({i,j});\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nAs we want grid position from where water can reach both pacific and atlantic ocean, we can \\nalso think it as grid positions which are reachable both from pacific and atlantic ocean boundary.\\n\\nRun BFS from all pacific boundary positions and track reachable grid positions, also run BFS from\\natlantic boundary postions and track reachable grid positions. Grid position which are both\\nreachable from pacific and atlantic are the result. From boundary positions water can flow in to\\nneighbor grid positions which have greater or equal height.\\n\\nExample: \\n\\nYellow = Reachable from pacific boundary\\nBlue = Reachable from atlantic boundary\\nGreen = Reachable from both boundary\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // run bfs to track reachable grid position from pacific or atlantic boundary\\n    void bfs(int m, int n, queue<pair<int,int>>&Q, vector<vector<int>>& grid, vector<vector<bool>>&visited)\\n    {\\n        int rowOffset[] = {0,0,1,-1};\\n        int colOffset[] = {1,-1,0,0};\\n        int currentHeight;\\n        int cx,cy;\\n        int px,py;\\n        \\n        while(!Q.empty())\\n        {\\n            cx = Q.front().first;\\n            cy = Q.front().second;\\n            currentHeight = grid[cx][cy];\\n            \\n            Q.pop();\\n            \\n            for(int k=0;k<4;k++)\\n            {\\n                px = cx + rowOffset[k];\\n                py = cy + colOffset[k];\\n                \\n                // child node can be reached from current nodes if \\n                // greater or equal in height compared to current node height\\n                if(px>=0 && px<m && py>=0 && py<n && grid[px][py]>=currentHeight && !visited[px][py])\\n                {\\n                    visited[px][py] = true;\\n                    Q.push({px,py});\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        \\n        vector<vector<int>>result;\\n        \\n        int m = grid.size();\\n        if(m==0) return result;\\n        \\n        int n = grid[0].size();\\n        if(n==0) return result;\\n        \\n        // track nodes reachable from pacific boundary\\n        vector<vector<bool>>pacificVisited(m,vector<bool>(n,false));\\n        \\n        // track nodes reachable from atlantic boundary\\n        vector<vector<bool>>atlanticVisited(m,vector<bool>(n,false));\\n        \\n        queue<pair<int,int>>Q;\\n        \\n        // add pacific boundary nodes  in to queue\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!pacificVisited[0][i])\\n            {\\n                pacificVisited[0][i] = true;\\n                Q.push({0,i});                    \\n            }\\n        }\\n\\n        // add pacific boundary nodes  in to queue       \\n        for(int i=1;i<m;i++)\\n        {\\n            if(!pacificVisited[i][0])\\n            {\\n                pacificVisited[i][0] = true;\\n                Q.push({i,0});                    \\n            }\\n        }\\n        \\n        // run bfs from pacific boundary nodes\\n        bfs(m,n,Q,grid,pacificVisited);\\n        \\n        // add atlantic boundary nodes\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!atlanticVisited[m-1][i])\\n            {\\n                atlanticVisited[m-1][i] = true;\\n                Q.push({m-1,i});                    \\n            }\\n        }\\n\\n        // add atlantic boundary nodes        \\n        for(int i=0;i<m-1;i++)\\n        {\\n            if(!atlanticVisited[i][n-1])\\n            {\\n                atlanticVisited[i][n-1] = true;\\n                Q.push({i,n-1});                    \\n            }\\n        }\\n        \\n        // run bfs from atlantic boundary nodes\\n        bfs(m,n,Q,grid,atlanticVisited);\\n        \\n        // push nodes in to result vector which are reachable both from pacific and atlantic boundary\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(pacificVisited[i][j] && atlanticVisited[i][j])\\n                    result.push_back({i,j});\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408166,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    boolean pacific;\\n    boolean atlantic;\\n    int numRows;\\n    int numColumns;\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        //Go through all the cells in the matrix\\n        //Run a DFS for each cell\\n        //In the execution of the DFS, set pacific and atlantic to true or false\\n        //at the end of the execution, if both pacific and atlantic are true, then add i,j to the list\\n        \\n        //create a boolean visited matrix\\n        \\n       \\n        //create a list of answers;\\n        List<List<Integer>> answers = new ArrayList<List<Integer>>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return answers;\\n        \\n        numRows = matrix.length;\\n        numColumns = matrix[0].length;\\n        \\n        \\n        for(int i = 0;i<matrix.length; i++)\\n        {\\n            for(int j = 0;j<matrix[0].length;j++)\\n            {\\n                pacific = false;\\n                atlantic = false;\\n                boolean[][] visited = new boolean[matrix.length][matrix[0].length];\\n                dfs(matrix,visited,i,j);\\n                if(pacific && atlantic)\\n                {\\n                    ArrayList<Integer> temp = new ArrayList<Integer>();\\n                    temp.add(i);\\n                    temp.add(j);\\n                    answers.add(temp);\\n                }\\n            }\\n        }\\n        return answers;\\n        \\n        \\n        \\n    }\\n    \\n    //In the execution of DFS,\\n    //once you set the value of pacific or atlantic to true, don\\'t change it\\n    public void dfs(int[][] matrix, boolean[][] visited, int i, int j)\\n    {   \\n        //mark the node as visited\\n        visited[i][j] = true;\\n        \\n        //check for pacific\\n        if(( ( (i==0) && (j>=0 && j<numColumns) ) || ( (j==0) && (i>=0 && i<numRows) ) ) && !pacific)\\n        {\\n           pacific = true; \\n        }\\n        \\n        \\n        //check for atlantic\\n        if(( ( (i==numRows-1) && (j>=0 && j<numColumns) ) || ( (j == numColumns-1) && (i>=0 && i<numRows) ) ) && !atlantic)\\n        {\\n           atlantic = true; \\n        }\\n        \\n        // if(i<0 || i>=numRows || y<0 || y>=numColumns )\\n        //     return;\\n        \\n        int x = i;\\n        int y = j;\\n        //top is x-1,y\\n            if( (x-1)>=0 && y>=0 && y<numColumns && (matrix[x][y] >= matrix[x-1][y]) && !visited[x-1][y])\\n                dfs(matrix,visited,x-1,y);\\n        \\n        \\n        //right is x,y+1\\n         if( x>=0 && x<numRows && y+1<numColumns && (matrix[x][y] >= matrix[x][y+1]) && !visited[x][y+1] )\\n             dfs(matrix,visited,x,y+1);\\n        \\n        //bottom is x+1,y\\n             if(x+1<numRows && y>=0 && y<numColumns && (matrix[x][y] >= matrix[x+1][y]) && !visited[x+1][y])\\n                 dfs(matrix,visited,x+1,y);\\n        \\n        //left is x,y-1\\n            if(x>=0 && x<numRows && y-1>=0 && matrix[x][y] >= matrix[x][y-1] && !visited[x][y-1])\\n                dfs(matrix,visited,x,y-1);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean pacific;\\n    boolean atlantic;\\n    int numRows;\\n    int numColumns;\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        //Go through all the cells in the matrix\\n        //Run a DFS for each cell\\n        //In the execution of the DFS, set pacific and atlantic to true or false\\n        //at the end of the execution, if both pacific and atlantic are true, then add i,j to the list\\n        \\n        //create a boolean visited matrix\\n        \\n       \\n        //create a list of answers;\\n        List<List<Integer>> answers = new ArrayList<List<Integer>>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return answers;\\n        \\n        numRows = matrix.length;\\n        numColumns = matrix[0].length;\\n        \\n        \\n        for(int i = 0;i<matrix.length; i++)\\n        {\\n            for(int j = 0;j<matrix[0].length;j++)\\n            {\\n                pacific = false;\\n                atlantic = false;\\n                boolean[][] visited = new boolean[matrix.length][matrix[0].length];\\n                dfs(matrix,visited,i,j);\\n                if(pacific && atlantic)\\n                {\\n                    ArrayList<Integer> temp = new ArrayList<Integer>();\\n                    temp.add(i);\\n                    temp.add(j);\\n                    answers.add(temp);\\n                }\\n            }\\n        }\\n        return answers;\\n        \\n        \\n        \\n    }\\n    \\n    //In the execution of DFS,\\n    //once you set the value of pacific or atlantic to true, don\\'t change it\\n    public void dfs(int[][] matrix, boolean[][] visited, int i, int j)\\n    {   \\n        //mark the node as visited\\n        visited[i][j] = true;\\n        \\n        //check for pacific\\n        if(( ( (i==0) && (j>=0 && j<numColumns) ) || ( (j==0) && (i>=0 && i<numRows) ) ) && !pacific)\\n        {\\n           pacific = true; \\n        }\\n        \\n        \\n        //check for atlantic\\n        if(( ( (i==numRows-1) && (j>=0 && j<numColumns) ) || ( (j == numColumns-1) && (i>=0 && i<numRows) ) ) && !atlantic)\\n        {\\n           atlantic = true; \\n        }\\n        \\n        // if(i<0 || i>=numRows || y<0 || y>=numColumns )\\n        //     return;\\n        \\n        int x = i;\\n        int y = j;\\n        //top is x-1,y\\n            if( (x-1)>=0 && y>=0 && y<numColumns && (matrix[x][y] >= matrix[x-1][y]) && !visited[x-1][y])\\n                dfs(matrix,visited,x-1,y);\\n        \\n        \\n        //right is x,y+1\\n         if( x>=0 && x<numRows && y+1<numColumns && (matrix[x][y] >= matrix[x][y+1]) && !visited[x][y+1] )\\n             dfs(matrix,visited,x,y+1);\\n        \\n        //bottom is x+1,y\\n             if(x+1<numRows && y>=0 && y<numColumns && (matrix[x][y] >= matrix[x+1][y]) && !visited[x+1][y])\\n                 dfs(matrix,visited,x+1,y);\\n        \\n        //left is x,y-1\\n            if(x>=0 && x<numRows && y-1>=0 && matrix[x][y] >= matrix[x][y-1] && !visited[x][y-1])\\n                dfs(matrix,visited,x,y-1);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316838,
                "title": "the-driver-for-c-is-broken",
                "content": "All submissions would get\\n\\n```\\nLine 22: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int[]>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n```",
                "solutionTags": [],
                "code": "```\\nLine 22: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.IList<int[]>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90774,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Pacific Atlantic Water Flow** https://leetcode.com/problems/pacific-atlantic-water-flow/\\n\\n**Brute Force Solution**\\n* For every point in the grid, find whether it can reach both pacific and atlantic. You can use standard DFS or BFS for this. There are mn points and DFS/BFS is O(2mn).\\n\\n**Optimized Solution**\\n* On the other hand, we can consider the flip side. We can let the pacific and atlantic ocean \"flow into\" the matrix as much as possible, using 2 boolean arrays, one for each ocean. The result are the points that are true in both boolean table.\\n* Two Queue and add all the Pacific border to one queue; Atlantic border to another queue.\\n* Keep a visited matrix for each queue. In the end, add the cell visited by two queue to the result.\\n* Water flows from ocean to the cell. Since water can only flow from high/equal cell to low cell, **add the neighboor cell with height larger or equal to current cell to the queue and mark as visited**.\\n```\\nif 0<=x1<N and 0<=y1<M and not visited[x1][y1] and matrix[x1][y1] >= matrix[x][y]\\n```\\n* Note we can also use DFS here. Do a DFS from every pacific point and then from every atlantic point. Take an intersection later.\\n* https://discuss.leetcode.com/topic/62280/simple-commented-java-solution-with-thinking-progress-o-n\\n* https://discuss.leetcode.com/topic/62379/java-bfs-dfs-from-ocean\\n\\n```\\nfrom Queue import Queue\\nclass Solution(object):\\n    def bfs(self, q, matrix, visited):\\n        N, M  = len(matrix), len(matrix[0])\\n        while q.empty() == False:\\n            (x,y) = q.get()\\n            candidates = [(x+1,y), (x-1,y), (x,y+1), (x,y-1)]\\n            for (x1,y1) in candidates:\\n                if 0<=x1<N and 0<=y1<M and not visited[x1][y1] and matrix[x1][y1] >= matrix[x][y]:\\n                    q.put((x1,y1))\\n                    visited[x1][y1]=True\\n        return\\n    \\n    def initialize_q(self, N, M, pac_q, atl_q, pac_visited, atl_visited):\\n        for i in range(N):\\n            pac_q.put((i,0))\\n            atl_q.put((i, M-1))\\n            pac_visited[i][0], atl_visited[i][M-1] = True, True\\n                        \\n        for j in range(M):\\n            pac_q.put((0,j))\\n            atl_q.put((N-1,j))\\n            pac_visited[0][j], atl_visited[N-1][j] = True, True\\n        return\\n    \\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if matrix == []:\\n            return []\\n        N, M  = len(matrix), len(matrix[0])\\n        pac_q, atl_q = Queue(), Queue()\\n        pac_visited = [[False]*M for _ in range(N)]\\n        atl_visited = [[False]*M for _ in range(N)]        \\n        \\n        self.initialize_q(N, M, pac_q, atl_q, pac_visited, atl_visited)\\n        self.bfs(pac_q, matrix, pac_visited)            \\n        self.bfs(atl_q, matrix, atl_visited)            \\n        \\n        result = []\\n        for i in range(N):\\n            for j in range(M):\\n                if pac_visited[i][j] and atl_visited[i][j]:\\n                    result.append([i,j])\\n                    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nif 0<=x1<N and 0<=y1<M and not visited[x1][y1] and matrix[x1][y1] >= matrix[x][y]\\n```\n```\\nfrom Queue import Queue\\nclass Solution(object):\\n    def bfs(self, q, matrix, visited):\\n        N, M  = len(matrix), len(matrix[0])\\n        while q.empty() == False:\\n            (x,y) = q.get()\\n            candidates = [(x+1,y), (x-1,y), (x,y+1), (x,y-1)]\\n            for (x1,y1) in candidates:\\n                if 0<=x1<N and 0<=y1<M and not visited[x1][y1] and matrix[x1][y1] >= matrix[x][y]:\\n                    q.put((x1,y1))\\n                    visited[x1][y1]=True\\n        return\\n    \\n    def initialize_q(self, N, M, pac_q, atl_q, pac_visited, atl_visited):\\n        for i in range(N):\\n            pac_q.put((i,0))\\n            atl_q.put((i, M-1))\\n            pac_visited[i][0], atl_visited[i][M-1] = True, True\\n                        \\n        for j in range(M):\\n            pac_q.put((0,j))\\n            atl_q.put((N-1,j))\\n            pac_visited[0][j], atl_visited[N-1][j] = True, True\\n        return\\n    \\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if matrix == []:\\n            return []\\n        N, M  = len(matrix), len(matrix[0])\\n        pac_q, atl_q = Queue(), Queue()\\n        pac_visited = [[False]*M for _ in range(N)]\\n        atl_visited = [[False]*M for _ in range(N)]        \\n        \\n        self.initialize_q(N, M, pac_q, atl_q, pac_visited, atl_visited)\\n        self.bfs(pac_q, matrix, pac_visited)            \\n        self.bfs(atl_q, matrix, atl_visited)            \\n        \\n        result = []\\n        for i in range(N):\\n            for j in range(M):\\n                if pac_visited[i][j] and atl_visited[i][j]:\\n                    result.append([i,j])\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507378,
                "title": "leetcode-the-hard-way-easy-dfs-with-explanations",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\n// https://wingkwong.github.io/leetcode-the-hard-way/solutions/0400-0499/pacific-atlantic-water-flow-medium\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& M, vector<vector<int>>& vis, int i, int j) {\\n        int m = M.size(), n = M[0].size();\\n        // marked this cell (i, j) as visited\\n        // so that we won\\'t visit it again\\n        vis[i][j] = 1;\\n        // perform DFS on the left cell\\n        if (i - 1 >= 0 && !vis[i - 1][j] && M[i - 1][j] >= M[i][j]) dfs(M, vis, i - 1, j);\\n        // perform DFS on the right cell\\n        if (i + 1 < m && !vis[i + 1][j] && M[i + 1][j] >= M[i][j]) dfs(M, vis, i + 1, j);\\n        // perform DFS on the top cell\\n        if (j - 1 >= 0 && !vis[i][j - 1] && M[i][j - 1] >= M[i][j]) dfs(M, vis, i, j - 1);\\n        // perform DFS on the bottom cell\\n        if (j + 1 < n && !vis[i][j + 1] && M[i][j + 1] >= M[i][j]) dfs(M, vis, i, j + 1);\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        int m = M.size(), n = M[0].size();\\n        // P[i][j] = 1 means it is able to flow to pacific ocean\\n        vector<vector<int>> P(m, vector<int>(n));\\n        // A[i][j] = 1 means it is able to flow to atlantic ocean\\n        vector<vector<int>> A(m, vector<int>(n));\\n        for(int i = 0; i < m; i++) {\\n            // perform dfs starting from the left-most column \\n            dfs(M, P, i, 0);\\n            // perform dfs starting from the right-most column \\n            dfs(M, A, i, n - 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            // perform dfs starting from the top-most row\\n            dfs(M, P, 0, i);\\n            // perform dfs starting from the bottom-most row\\n            dfs(M, A, m - 1, i);\\n        }\\n        // iterate each row\\n        for(int i = 0; i < m; i++) {\\n            // iterate each column\\n            for(int j = 0; j < n; j++) {\\n                // if both P[i][j] & A[i][j] are visited\\n                // that means this cell can flow to both ocean\\n                if(P[i][j] && A[i][j]) {\\n                    // then put the coordinate (i, j) to answer\\n                    ans.push_back(vector<int>{i, j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\n// https://wingkwong.github.io/leetcode-the-hard-way/solutions/0400-0499/pacific-atlantic-water-flow-medium\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& M, vector<vector<int>>& vis, int i, int j) {\\n        int m = M.size(), n = M[0].size();\\n        // marked this cell (i, j) as visited\\n        // so that we won\\'t visit it again\\n        vis[i][j] = 1;\\n        // perform DFS on the left cell\\n        if (i - 1 >= 0 && !vis[i - 1][j] && M[i - 1][j] >= M[i][j]) dfs(M, vis, i - 1, j);\\n        // perform DFS on the right cell\\n        if (i + 1 < m && !vis[i + 1][j] && M[i + 1][j] >= M[i][j]) dfs(M, vis, i + 1, j);\\n        // perform DFS on the top cell\\n        if (j - 1 >= 0 && !vis[i][j - 1] && M[i][j - 1] >= M[i][j]) dfs(M, vis, i, j - 1);\\n        // perform DFS on the bottom cell\\n        if (j + 1 < n && !vis[i][j + 1] && M[i][j + 1] >= M[i][j]) dfs(M, vis, i, j + 1);\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        int m = M.size(), n = M[0].size();\\n        // P[i][j] = 1 means it is able to flow to pacific ocean\\n        vector<vector<int>> P(m, vector<int>(n));\\n        // A[i][j] = 1 means it is able to flow to atlantic ocean\\n        vector<vector<int>> A(m, vector<int>(n));\\n        for(int i = 0; i < m; i++) {\\n            // perform dfs starting from the left-most column \\n            dfs(M, P, i, 0);\\n            // perform dfs starting from the right-most column \\n            dfs(M, A, i, n - 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            // perform dfs starting from the top-most row\\n            dfs(M, P, 0, i);\\n            // perform dfs starting from the bottom-most row\\n            dfs(M, A, m - 1, i);\\n        }\\n        // iterate each row\\n        for(int i = 0; i < m; i++) {\\n            // iterate each column\\n            for(int j = 0; j < n; j++) {\\n                // if both P[i][j] & A[i][j] are visited\\n                // that means this cell can flow to both ocean\\n                if(P[i][j] && A[i][j]) {\\n                    // then put the coordinate (i, j) to answer\\n                    ans.push_back(vector<int>{i, j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507136,
                "title": "daily-leetcoding-challenge-august-day-31",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 31.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/pacific-atlantic-water-flow/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth First Search (BFS)\n\n  \n**Approach 2:** Depth First Search (DFS)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/pacific-atlantic-water-flow/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Breadth First Search (BFS)\n**Approach 2:** Depth First Search (DFS)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1127215,
                "title": "java-bfs-easy-to-understand-let-water-flow-from-respective-occean-sides",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new ArrayList();\\n        \\n        int R = matrix.length, C = matrix[0].length;\\n        \\n        boolean[][] pacific = new boolean[R][C];\\n        boolean[][] atlantic = new boolean[R][C];\\n        \\n        for(int i = 0; i < R; i++) {\\n            bfs(i, 0, matrix, pacific);\\n            bfs(i, C - 1, matrix, atlantic);\\n        }\\n        \\n        for(int j = 0; j < C; j++) {\\n            bfs(0, j, matrix, pacific);\\n            bfs(R - 1, j, matrix, atlantic);\\n        }\\n        \\n        List<List<Integer>> list = new ArrayList();\\n        for(int i = 0; i < R; i++) {\\n            for(int j = 0; j < C; j++) {\\n                if(pacific[i][j] && atlantic[i][j]) {\\n                    list.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private void bfs(int x, int y, int[][] matrix, boolean[][] visited) {\\n        int R = matrix.length, C = matrix[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{x, y});\\n        visited[x][y] = true;\\n        int[][] dir = new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        while(q.size() > 0) {\\n            x = q.peek()[0];\\n            y = q.peek()[1];\\n            q.poll();\\n            \\n            for(int[] d : dir) {\\n                int nx = x + d[0];\\n                int ny = y + d[1];\\n                \\n                if(nx >= 0 && nx < R && ny >= 0 && ny < C && matrix[x][y] <= matrix[nx][ny] && !visited[nx][ny]) {\\n                    q.add(new int[]{nx, ny});\\n                    visited[nx][ny] = true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new ArrayList();\\n        \\n        int R = matrix.length, C = matrix[0].length;\\n        \\n        boolean[][] pacific = new boolean[R][C];\\n        boolean[][] atlantic = new boolean[R][C];\\n        \\n        for(int i = 0; i < R; i++) {\\n            bfs(i, 0, matrix, pacific);\\n            bfs(i, C - 1, matrix, atlantic);\\n        }\\n        \\n        for(int j = 0; j < C; j++) {\\n            bfs(0, j, matrix, pacific);\\n            bfs(R - 1, j, matrix, atlantic);\\n        }\\n        \\n        List<List<Integer>> list = new ArrayList();\\n        for(int i = 0; i < R; i++) {\\n            for(int j = 0; j < C; j++) {\\n                if(pacific[i][j] && atlantic[i][j]) {\\n                    list.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private void bfs(int x, int y, int[][] matrix, boolean[][] visited) {\\n        int R = matrix.length, C = matrix[0].length;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{x, y});\\n        visited[x][y] = true;\\n        int[][] dir = new int[][] {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        while(q.size() > 0) {\\n            x = q.peek()[0];\\n            y = q.peek()[1];\\n            q.poll();\\n            \\n            for(int[] d : dir) {\\n                int nx = x + d[0];\\n                int ny = y + d[1];\\n                \\n                if(nx >= 0 && nx < R && ny >= 0 && ny < C && matrix[x][y] <= matrix[nx][ny] && !visited[nx][ny]) {\\n                    q.add(new int[]{nx, ny});\\n                    visited[nx][ny] = true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126756,
                "title": "c-simple-readable-recursive-dfs-solution",
                "content": "We need to find cells that can reach Pacific and Atlantic.\\nSo we keep a vector \"states\": 1 = can reach Pacific, 2 = can reach Atlantic, 3 = can reach both.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        if (!matrix.size() || !matrix[0].size()) \\n            return res;\\n        \\n        n = matrix.size();\\n        m = matrix[0].size();\\n        states.assign(n,vector<int> (m, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            recDFS(matrix, i, 0, INT_MIN, 1);\\n            recDFS(matrix, i, m-1, INT_MIN, 2);\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            recDFS(matrix, 0, i, INT_MIN, 1);\\n            recDFS(matrix, n-1, i, INT_MIN, 2);\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> res, states;\\n    vector<int> x_points = {1, 0, -1, 0};\\n    vector<int> y_points = {0, 1, 0, -1};\\n    int m, n;\\n    \\n    bool isValid(int x, int y) {\\n        return x < n and x >= 0 and y < m and y >= 0;\\n    }\\n    \\n    void recDFS(vector<vector<int>>& mat, int x, int y, int prev, int prev_state) {\\n        if (!isValid(x, y) || mat[x][y] < prev || states[x][y] == prev_state || states[x][y] == 3) \\n            return;\\n        \\n        states[x][y] += prev_state;\\n        \\n        if (states[x][y] == 3) \\n            res.push_back({x, y});\\n        \\n        for (int i = 0; i < 4; i++) {\\n            recDFS(mat, x + x_points[i], y + y_points[i], mat[x][y], prev_state);\\n        }\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        if (!matrix.size() || !matrix[0].size()) \\n            return res;\\n        \\n        n = matrix.size();\\n        m = matrix[0].size();\\n        states.assign(n,vector<int> (m, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            recDFS(matrix, i, 0, INT_MIN, 1);\\n            recDFS(matrix, i, m-1, INT_MIN, 2);\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            recDFS(matrix, 0, i, INT_MIN, 1);\\n            recDFS(matrix, n-1, i, INT_MIN, 2);\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<int>> res, states;\\n    vector<int> x_points = {1, 0, -1, 0};\\n    vector<int> y_points = {0, 1, 0, -1};\\n    int m, n;\\n    \\n    bool isValid(int x, int y) {\\n        return x < n and x >= 0 and y < m and y >= 0;\\n    }\\n    \\n    void recDFS(vector<vector<int>>& mat, int x, int y, int prev, int prev_state) {\\n        if (!isValid(x, y) || mat[x][y] < prev || states[x][y] == prev_state || states[x][y] == 3) \\n            return;\\n        \\n        states[x][y] += prev_state;\\n        \\n        if (states[x][y] == 3) \\n            res.push_back({x, y});\\n        \\n        for (int i = 0; i < 4; i++) {\\n            recDFS(mat, x + x_points[i], y + y_points[i], mat[x][y], prev_state);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589401,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nconst pacificAtlantic = (matrix) => {\\n  if (matrix.length === 0) return [];\\n  \\n  const pacific = [];\\n  const atlantic = [];\\n  const result = [];\\n  \\n  for (let i = 0; i < matrix.length; i++) {\\n    pacific[i] = Array(matrix[0].length).fill(0);\\n    atlantic[i] = Array(matrix[0].length).fill(0);\\n  }\\n  \\n  // top and botom\\n  for (let i = 0; i < matrix[0].length; i++) {\\n    dfs(matrix, 0, i, Number.MIN_SAFE_INTEGER, pacific);\\n    dfs(matrix, matrix.length - 1, i, Number.MIN_SAFE_INTEGER, atlantic);\\n  }\\n  \\n  // left and right\\n  for (let i = 0; i < matrix.length; i++) {\\n    dfs(matrix, i, 0, Number.MIN_SAFE_INTEGER, pacific);\\n    dfs(matrix, i, matrix[0].length - 1, Number.MIN_SAFE_INTEGER, atlantic);\\n  }\\n  \\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (pacific[i][j] === 1 && atlantic[i][j] === 1) {\\n        result.push([i, j]);\\n      }\\n    }\\n  }\\n  \\n  return result;\\n};\\n\\nfunction dfs(matrix, row, col, previous, ocean) {\\n  // if we\\'re looking at a valid matrix position\\n  if (!isValid(matrix, row, col)) return;\\n  \\n  // ocean can\\'t reach\\n  if (matrix[row][col] < previous) return;\\n\\n  // the ocean was already here\\n  if (ocean[row][col] === 1) return;\\n  \\n  ocean[row][col] = 1;\\n  dfs(matrix, row + 1, col, matrix[row][col], ocean);\\n  dfs(matrix, row - 1, col, matrix[row][col], ocean);\\n  dfs(matrix, row, col + 1, matrix[row][col], ocean);\\n  dfs(matrix, row, col - 1, matrix[row][col], ocean);\\n}\\n\\nfunction isValid(matrix, row, col) {\\n  const rowIsValid = row >= 0 && row < matrix.length;\\n  const colIsValid = col >= 0 && col < matrix[0].length;\\n  return rowIsValid && colIsValid;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nconst pacificAtlantic = (matrix) => {\\n  if (matrix.length === 0) return [];\\n  \\n  const pacific = [];\\n  const atlantic = [];\\n  const result = [];\\n  \\n  for (let i = 0; i < matrix.length; i++) {\\n    pacific[i] = Array(matrix[0].length).fill(0);\\n    atlantic[i] = Array(matrix[0].length).fill(0);\\n  }\\n  \\n  // top and botom\\n  for (let i = 0; i < matrix[0].length; i++) {\\n    dfs(matrix, 0, i, Number.MIN_SAFE_INTEGER, pacific);\\n    dfs(matrix, matrix.length - 1, i, Number.MIN_SAFE_INTEGER, atlantic);\\n  }\\n  \\n  // left and right\\n  for (let i = 0; i < matrix.length; i++) {\\n    dfs(matrix, i, 0, Number.MIN_SAFE_INTEGER, pacific);\\n    dfs(matrix, i, matrix[0].length - 1, Number.MIN_SAFE_INTEGER, atlantic);\\n  }\\n  \\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (pacific[i][j] === 1 && atlantic[i][j] === 1) {\\n        result.push([i, j]);\\n      }\\n    }\\n  }\\n  \\n  return result;\\n};\\n\\nfunction dfs(matrix, row, col, previous, ocean) {\\n  // if we\\'re looking at a valid matrix position\\n  if (!isValid(matrix, row, col)) return;\\n  \\n  // ocean can\\'t reach\\n  if (matrix[row][col] < previous) return;\\n\\n  // the ocean was already here\\n  if (ocean[row][col] === 1) return;\\n  \\n  ocean[row][col] = 1;\\n  dfs(matrix, row + 1, col, matrix[row][col], ocean);\\n  dfs(matrix, row - 1, col, matrix[row][col], ocean);\\n  dfs(matrix, row, col + 1, matrix[row][col], ocean);\\n  dfs(matrix, row, col - 1, matrix[row][col], ocean);\\n}\\n\\nfunction isValid(matrix, row, col) {\\n  const rowIsValid = row >= 0 && row < matrix.length;\\n  const colIsValid = col >= 0 && col < matrix[0].length;\\n  return rowIsValid && colIsValid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2526745,
                "title": "why-we-reverse-intuition-from-brute-force-to-optimized",
                "content": "Going through discussion tab and youtube folks found that a lot of people start an explanation like this:\\n\\n\"Let us **reverse logic** in this problem.\"\\n\"It should be **obvious** from the start that we\\'ll need to solve this problem **in reverse**.\"\\n\\nThose all are smart folks and for them \"it\\'s quite **obvious** what to do\", but for me it was not and I had to scratch the back of my head a bit. I\\'ll write down how I ended up with the same solution.\\n\\nThis is the first thing that came to my mind.\\n\\n**1. Brute-force**\\n\\nAs I want to find **the shortest path** to an ocean from a [row,col] cell I picked BFS graph traversal.\\nAccording to the problem statement the water from the [row,col] cell should **end up in both Pacific and Atlantic** oceans. So we will need 2 sets to track this requirements.\\n\\nWe go from a \"land\" cell to out of boundaries `row < 0 or row > ROWS or col < 0 or col > COLS`\\n\\n**Observation #1**: The first observation that I got is that as soon as we reach a border cell (marked with pink on the pic) - we definitely end up in an ocean. Think about an ocean cell as the one with height = 0.\\n\\n**Observation #2**: Bottom-left and top-right land cells end up in both oceans. They have the same coordinates adjacent to both oceans\\n\\n![image](https://assets.leetcode.com/users/images/f016131b-80ab-41fa-b96e-a6938d7a3f5c_1662242543.9600108.png)\\n\\nI start a BFS traversal for every possible [row,col] combination and when I am on a \"border cell\" I store *traversal_starting_position* in a *reached_X_ocean* set. This is how I check a \"border cell\" position\\n```\\nif r == 0 or c == 0:\\n    reached_pacific_ocean.add(traversal_starting_position)\\nif r == ROWS - 1 or c == COLS - 1:\\n    reached_atlantic_ocean.add(traversal_starting_position)\\n```\\n\\nWhen I am done with the traversals I check which cells ended up in both oceans and return them.\\n\\nThis approach will work, but will be slow - `O(ROWS*COLS)^2)`\\n\\n![image](https://assets.leetcode.com/users/images/6105af16-7f4d-4ed8-adae-95659f95fc4e_1662234754.5888665.png)\\n\\nSource code for the approach:\\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        def bfs(traversal_starting_position):\\n            queue = deque([traversal_starting_position])\\n            visited = set()\\n            \\n            while queue:\\n                r,c = queue.popleft()\\n                \\n                if r == 0 or c == 0:\\n\\t\\t\\t\\t    reached_pacific_ocean.add(traversal_starting_position)\\n                if r == ROWS - 1 or c == COLS - 1:\\n\\t\\t\\t\\t    reached_atlantic_ocean.add(traversal_starting_position)\\n                \\n                if traversal_starting_position in reached_atlantic_ocean and traversal_starting_position in reached_pacific_ocean:\\n                    return\\n                \\n                for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                    nr,nc = r + dr, c + dc\\n                    \\n                    if 0 <= nr < ROWS and 0 <= nc < COLS and heights[nr][nc] <= heights[r][c] \\\\\\n                        and (nr,nc) not in visited:\\n                        queue.append((nr,nc))\\n                        visited.add((nr,nc))\\n        \\n        ROWS,COLS = len(heights), len(heights[0])\\n        \\n        reached_atlantic_ocean = set()\\n        reached_pacific_ocean = set()\\n        \\n        for traversal_starting_position in product(range(ROWS), range(COLS)):\\n            bfs(traversal_starting_position)\\n        \\n        return reached_atlantic_ocean & reached_pacific_ocean\\n```\\n\\n**2. Optimizing brute-force**\\n\\nBy now we know a few things:\\n* water flows top to bottom (physics 101)\\n* If we got to a border cell, we are in the ocean\\n* we used 2 sets to identify if a cell landed in both oceans\\n* brute-forcing every [row.col] **is slow**\\n\\nLet\\'s start from the last item from the list.\\n\\n**How can we speed it up?**\\n\\nIn order to speed it up we need to reduce number of *traversal_starting_position* checks, but how?\\n\\nLet\\'s look at the example:\\n\\n```\\n11112\\n10001\\n10401\\n10001\\n21111\\n```\\n\\nIn our case no matter what we do, `4` will not reach any ocean. The same we can say about any of `0`. So it does not make any sence to check them. C\\u0336r\\u0336o\\u0336s\\u0336s\\u0336i\\u0336n\\u0336g\\u0336 \\u0336o\\u0336u\\u0336t\\u0336\\n\\n**How do we know which land cells can reach an ocean?**\\n\\nFrom the bruce-force approach\\'s observation #1 and #2 we know that any border cell can reach an ocean and at least 2 border cells can reach both oceans.\\n\\nBased on the above information we need somehow to reach the border land cells. How?\\n\\nThe only 2 ways to reach a border cell:\\n1) start from it \\n2) **Observation #3**: arrive from a heigher (or equal) land cell adjacent to the border cell.\\n\\n![image](https://assets.leetcode.com/users/images/0b7e100f-4244-4c89-a2a8-3d6a561cc815_1662242903.9839532.png)\\n\\nIf we repeat the process again and again (looks like peeling an onion ring by ring) we will end up with land cells that we are stuck on and cannot go higher anymore.\\n\\nThis way we drop land cells that can\\'t guide us to a possible solution as soon as possible.\\n\\n---\\n\\nThis is what we do in **Top-Down** approaches: you have your target (big goal) and you build a way to get there from smaller targets.\\n\\n---\\n\\nSo we need to track which land cells end up in which ocean and find intersecting coordinates in both atlantic and pacific sets and we are done.\\n\\n**How do we do it?**\\n\\nNow that we know what we need, left to figure out how to achive it.\\n\\n**1. We start from border cells**.\\nWe split border cells in 2 groups: the ones that are adjacent to Pacific ocean and another one for Atlantic ocean. We need to know which border cell ended up in which ocean.\\n\\n**2. We start BFS traversion on those border cells**\\nHow do we determine how to expand the BFS search space???\\n\\nOriginal state transition from the problem description:\\n...*water can flow ... if the neighboring cell\\'s height* \\\\*<=\\\\* *current cell\\'s height..*\\n\\nBut we are going **from the bottom to the top**, so this needs to be **reversed** \\n...*water can flow ... if the neighboring cell\\'s height* \\\\*>=\\\\* *current cell\\'s height..*\\n\\n**3. We got land cells that we cannot move heigher anymore**\\nWe intersect such cells from both oceans and that\\'s our result.\\n\\n**But it is still not optimized!!!**\\n\\nIn order to speed up the current approach we need somehow to run **in parallel** our BFS traversals for multiple starting coordinates. But good old BFS runs only sequentially for each starting point???\\n\\nLuckly for us there is (if you did not know, now you know) **multi-source BFS** (aka MS BFS, click [here](https://www.vldb.org/pvldb/vol8/p449-then.pdf) if you like papers).\\n\\nEach time you see that you need to **run BFS on MULTIPLE SOURCES at the SAME TIME** - it\\'s 99.99% MS BFS (the other 0.01 is DP, but that\\'s another problem). The same one is used in \"Rotting Oranges\" (amazon\\'s fav), \"Map of Highest Peak\", \"As Far from Land as Possible\", \"Pacific Atlantic Water Flow\", \"Wall and Gates\" and others.\\n\\n---\\n\\nMore about similar problems and how to apply it I posted for another problem [here](https://leetcode.com/problems/as-far-from-land-as-possible/discuss/2515617/how-to-solve-multi-source-bfs-problems-intuition)\\n\\n---\\n\\nNow left to apply MS BFS to our problem and we are done.\\n\\n**Optimization with MS BFS**\\n\\nAs we need to start **in parallel** we need to prepare our \"BFS queue\" with the border land cells (sources) in advance. So we have to find all the border land cells and place them in the queue before staring the typical \"BFS loop\". This way we traverse multiple starting points **in parallel**.\\n\\nI like the idea of a \"virtual start node\" aka dummy on the pic: You virtually connect all the \"land\" cells to a virtual node and then do a classic BFS on the virtual node. Except this is the mental model. In the code you just find the \"starting\" source nodes and dump them in the queue and run a bfs on the queue.\\n\\n![image](https://assets.leetcode.com/users/images/4e361cdd-25d6-4bf7-8f1a-670a119ca8d3_1662245696.096896.png)\\n*The pic as always taken from the Internet.*\\n\\nAs a result of running 2 BFS for both oceans we are going to have 2 **visited** sets, that contain all \"reachable\" land cells from border cells. We intersect the cell coordinates and return them.\\n\\n---\\n\\nSo, hopefully, by now we know why we need to **reverse the logic** and why it\\'s **obvious**.\\nThis is the same problem with solutions that provide tabular DP. You got 5 lines of code and no idea how they ended up there.\\n\\n---\\n\\nSource code for the approach:\\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        def bfs(queue):\\n            visited = set(queue)\\n            while queue:\\n                r,c = queue.popleft()\\n                \\n                for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                    nr,nc = r + dr, c + dc\\n                    \\n                    if 0 <= nr < ROWS and 0 <= nc < COLS and \\\\\\n                        heights[r][c] <= heights[nr][nc] and (nr,nc) not in visited:\\n                        visited.add((nr,nc))\\n                        queue.append((nr,nc))\\n            \\n            return visited\\n        \\n        atlantic_ocean_queue = deque()\\n        pacific_ocean_queue = deque()\\n        \\n        ROWS,COLS = len(heights),len(heights[0])\\n        \\n        for r in range(ROWS):\\n            atlantic_ocean_queue.append((r, COLS - 1))\\n            pacific_ocean_queue.append((r, 0))\\n            \\n        for c in range(COLS):\\n            atlantic_ocean_queue.append((ROWS - 1, c))\\n            pacific_ocean_queue.append((0, c))\\n        \\n        reached_atlantic_ocean = bfs(atlantic_ocean_queue)\\n        reached_pacific_ocean = bfs(pacific_ocean_queue)\\n        \\n        return reached_atlantic_ocean & reached_pacific_ocean\\n```\\n\\nTC: `O(ROWS*COLS)`\\nSC: `O(ROWS*COLS)`\\n\\nIt can also be solved with DFS. The same core logic, different traversal, recursion (stack) and ...\\n\\n... did you know that you can optimize/solve the problem with DP? \\n\\n( \\u25D1\\u203F\\u25D1)\\u0254\\u250F\\uD83C\\uDF5F--\\uD83C\\uDF54\\u2511\\u0669(^\\u25E1^ )\\n\\n**If you liked the read, upvote so the other people can see it too.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nif r == 0 or c == 0:\\n    reached_pacific_ocean.add(traversal_starting_position)\\nif r == ROWS - 1 or c == COLS - 1:\\n    reached_atlantic_ocean.add(traversal_starting_position)\\n```\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        def bfs(traversal_starting_position):\\n            queue = deque([traversal_starting_position])\\n            visited = set()\\n            \\n            while queue:\\n                r,c = queue.popleft()\\n                \\n                if r == 0 or c == 0:\\n\\t\\t\\t\\t    reached_pacific_ocean.add(traversal_starting_position)\\n                if r == ROWS - 1 or c == COLS - 1:\\n\\t\\t\\t\\t    reached_atlantic_ocean.add(traversal_starting_position)\\n                \\n                if traversal_starting_position in reached_atlantic_ocean and traversal_starting_position in reached_pacific_ocean:\\n                    return\\n                \\n                for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                    nr,nc = r + dr, c + dc\\n                    \\n                    if 0 <= nr < ROWS and 0 <= nc < COLS and heights[nr][nc] <= heights[r][c] \\\\\\n                        and (nr,nc) not in visited:\\n                        queue.append((nr,nc))\\n                        visited.add((nr,nc))\\n        \\n        ROWS,COLS = len(heights), len(heights[0])\\n        \\n        reached_atlantic_ocean = set()\\n        reached_pacific_ocean = set()\\n        \\n        for traversal_starting_position in product(range(ROWS), range(COLS)):\\n            bfs(traversal_starting_position)\\n        \\n        return reached_atlantic_ocean & reached_pacific_ocean\\n```\n```\\n11112\\n10001\\n10401\\n10001\\n21111\\n```\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        def bfs(queue):\\n            visited = set(queue)\\n            while queue:\\n                r,c = queue.popleft()\\n                \\n                for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                    nr,nc = r + dr, c + dc\\n                    \\n                    if 0 <= nr < ROWS and 0 <= nc < COLS and \\\\\\n                        heights[r][c] <= heights[nr][nc] and (nr,nc) not in visited:\\n                        visited.add((nr,nc))\\n                        queue.append((nr,nc))\\n            \\n            return visited\\n        \\n        atlantic_ocean_queue = deque()\\n        pacific_ocean_queue = deque()\\n        \\n        ROWS,COLS = len(heights),len(heights[0])\\n        \\n        for r in range(ROWS):\\n            atlantic_ocean_queue.append((r, COLS - 1))\\n            pacific_ocean_queue.append((r, 0))\\n            \\n        for c in range(COLS):\\n            atlantic_ocean_queue.append((ROWS - 1, c))\\n            pacific_ocean_queue.append((0, c))\\n        \\n        reached_atlantic_ocean = bfs(atlantic_ocean_queue)\\n        reached_pacific_ocean = bfs(pacific_ocean_queue)\\n        \\n        return reached_atlantic_ocean & reached_pacific_ocean\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508644,
                "title": "most-concise-c-solution-dfs-bit-mask",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint dx[4] = {1, -1, 0, 0};\\n\\tint dy[4] = {0, 0, -1, 1};\\n\\n\\tvector<vector<int>> ans, mask;\\n\\n\\tvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n\\t\\tint m = heights.size(), n = heights[0].size();\\n\\t\\tmask.resize(m, vector<int>(n, 0));\\n\\n\\t\\tfunction<void(int, int, int, int)> dfs = [&](int r, int c, int prev, int val) {\\n\\t\\t\\tif (r < 0 or c < 0 or r >= m or c >= n or ((mask[r][c] | val) == mask[r][c])) return;\\n\\t\\t\\tif (heights[r][c] < prev) return;\\n\\t\\t\\tmask[r][c] |= val;\\n\\t\\t\\tif (mask[r][c] == 3) ans.push_back({r, c});\\n\\t\\t\\tfor (int dir = 0; dir < 4; ++dir) {\\n\\t\\t\\t\\tint x = r + dx[dir];\\n\\t\\t\\t\\tint y = c + dy[dir];\\n\\t\\t\\t\\tdfs(x, y, heights[r][c], mask[r][c]);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tfor (int i = 0; i < m; ++i) {\\n\\t\\t\\tdfs(i, 0, INT_MIN, 1);\\n\\t\\t\\tdfs(i, n - 1, INT_MIN, 2);\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\tdfs(0, j, INT_MIN, 1);\\n\\t\\t\\tdfs(m - 1, j, INT_MIN, 2);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint dx[4] = {1, -1, 0, 0};\\n\\tint dy[4] = {0, 0, -1, 1};\\n\\n\\tvector<vector<int>> ans, mask;\\n\\n\\tvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n\\t\\tint m = heights.size(), n = heights[0].size();\\n\\t\\tmask.resize(m, vector<int>(n, 0));\\n\\n\\t\\tfunction<void(int, int, int, int)> dfs = [&](int r, int c, int prev, int val) {\\n\\t\\t\\tif (r < 0 or c < 0 or r >= m or c >= n or ((mask[r][c] | val) == mask[r][c])) return;\\n\\t\\t\\tif (heights[r][c] < prev) return;\\n\\t\\t\\tmask[r][c] |= val;\\n\\t\\t\\tif (mask[r][c] == 3) ans.push_back({r, c});\\n\\t\\t\\tfor (int dir = 0; dir < 4; ++dir) {\\n\\t\\t\\t\\tint x = r + dx[dir];\\n\\t\\t\\t\\tint y = c + dy[dir];\\n\\t\\t\\t\\tdfs(x, y, heights[r][c], mask[r][c]);\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tfor (int i = 0; i < m; ++i) {\\n\\t\\t\\tdfs(i, 0, INT_MIN, 1);\\n\\t\\t\\tdfs(i, n - 1, INT_MIN, 2);\\n\\t\\t}\\n\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\tdfs(0, j, INT_MIN, 1);\\n\\t\\t\\tdfs(m - 1, j, INT_MIN, 2);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468157,
                "title": "think-the-other-way-ocean-to-land-dfs-c-explaind",
                "content": "## **Intution** \\uD83D\\uDCA1\\ninstead of going from land to ocean\\nwe will do a *DFS* from **both the oceans** towards the land\\nif the cell of the land can be visited from both oceans, vice-versa of that (that is asked in question) is also **true**\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& land, vector<vector<bool>> &oceanToLand, int i, int j, int rows, int cols) {\\n        if(i < 0 || i >= rows || j < 0 || j >= cols || oceanToLand[i][j] == true)\\n            return;\\n        \\n        oceanToLand[i][j] = true; // marking visited, means ocean water can come to that land\\n        \\n        // just checking the neighbouring cells\\n        if(i + 1 < rows && land[i + 1][j] >= land[i][j])\\n            dfs(land, oceanToLand, i + 1, j, rows, cols);\\n        \\n        if(i - 1 >= 0 && land[i - 1][j] >= land[i][j])\\n            dfs(land, oceanToLand, i - 1, j, rows, cols);\\n        \\n        if(j + 1 < cols && land[i][j + 1] >= land[i][j])\\n            dfs(land, oceanToLand, i, j + 1, rows, cols);\\n        \\n        if(j - 1 >= 0 && land[i][j - 1] >= land[i][j])\\n            dfs(land, oceanToLand, i, j - 1, rows, cols);\\n    }\\n\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        int rows = heights.size();\\n        int cols = heights[0].size();\\n        \\n        vector<vector<bool>> pacificToLand(rows, vector<bool>(cols, false));\\n        vector<vector<bool>> atlanticToLand(rows, vector<bool>(cols, false));\\n        \\n        // column 0 is pacific ocean\\'s boundary and last column (cols - 1) is atlantic\\'s\\n        for(int i = 0; i < rows; ++i) {\\n            dfs(heights, pacificToLand, i, 0, rows, cols);\\n            dfs(heights, atlanticToLand, i, cols - 1, rows, cols);\\n        }\\n        \\n        // row 0 is pacific ocean\\'s boundary and last row (rows - 1) is atlantic\\'s\\n        for(int i = 0; i < cols; ++i) {\\n            dfs(heights, pacificToLand, 0, i, rows, cols);\\n            dfs(heights, atlanticToLand, rows - 1, i, rows, cols);\\n        }\\n        \\n        \\n        // if from *both* oceans, we can reach to a particular cell of land, then vice-versa is also true\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(pacificToLand[i][j] && atlanticToLand[i][j]) {\\n                    ans.push_back({i, j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you have any doubts, *Please ask in the Comments* \\nIf it helped you, **Please UpVote** \\uD83D\\uDD3C :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& land, vector<vector<bool>> &oceanToLand, int i, int j, int rows, int cols) {\\n        if(i < 0 || i >= rows || j < 0 || j >= cols || oceanToLand[i][j] == true)\\n            return;\\n        \\n        oceanToLand[i][j] = true; // marking visited, means ocean water can come to that land\\n        \\n        // just checking the neighbouring cells\\n        if(i + 1 < rows && land[i + 1][j] >= land[i][j])\\n            dfs(land, oceanToLand, i + 1, j, rows, cols);\\n        \\n        if(i - 1 >= 0 && land[i - 1][j] >= land[i][j])\\n            dfs(land, oceanToLand, i - 1, j, rows, cols);\\n        \\n        if(j + 1 < cols && land[i][j + 1] >= land[i][j])\\n            dfs(land, oceanToLand, i, j + 1, rows, cols);\\n        \\n        if(j - 1 >= 0 && land[i][j - 1] >= land[i][j])\\n            dfs(land, oceanToLand, i, j - 1, rows, cols);\\n    }\\n\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        int rows = heights.size();\\n        int cols = heights[0].size();\\n        \\n        vector<vector<bool>> pacificToLand(rows, vector<bool>(cols, false));\\n        vector<vector<bool>> atlanticToLand(rows, vector<bool>(cols, false));\\n        \\n        // column 0 is pacific ocean\\'s boundary and last column (cols - 1) is atlantic\\'s\\n        for(int i = 0; i < rows; ++i) {\\n            dfs(heights, pacificToLand, i, 0, rows, cols);\\n            dfs(heights, atlanticToLand, i, cols - 1, rows, cols);\\n        }\\n        \\n        // row 0 is pacific ocean\\'s boundary and last row (rows - 1) is atlantic\\'s\\n        for(int i = 0; i < cols; ++i) {\\n            dfs(heights, pacificToLand, 0, i, rows, cols);\\n            dfs(heights, atlanticToLand, rows - 1, i, rows, cols);\\n        }\\n        \\n        \\n        // if from *both* oceans, we can reach to a particular cell of land, then vice-versa is also true\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(pacificToLand[i][j] && atlanticToLand[i][j]) {\\n                    ans.push_back({i, j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758961,
                "title": "helpful-dfs-javascript-solution",
                "content": "If you\\'re like me, this may be the first DFS problem you\\'ve ever come across. I looked at some answers, they broke my brain, and I had to leave and learn about DFS and come back (which is a bit more difficult if JavaScript is your primary language). I\\'d recommend doing that. But here is the solution I wish had existed.\\n\\nIn a nutshell, Depth First Search takes a starting point (node or vertex, in this problem one of the squares in the matrix) and checks to see if it can find a path*. It goes all along a path until it\\'s reached the end (in contrast to BFS, which checks one next node around it at a time before moving on). If the function has visited a node, it marks it off its list and moves on, storing the result in an adjacency matrix (used here) or adjacency list.  This is the best explanation of the concept I\\'ve seen: [https://xkcd.com/761/](http://)\\n\\n\\\\* *In this case, we\\'ll write a dfs function to check if water can flow from a node adjacent to the ocean up to a high point--if that high point is found from both the pacific and atlantic oceans, it goes into our result. (Despite the problem statement of finding downhill flow, we must understand that the best approach to this problem is the opposite: starting at downhill points and working uphill.)*\\n\\nDFS can be implemented in several ways. Here we use recursion to check neighboring nodes. Stacks are also commonly used. \\n\\nThe fastest solution uses dynamic programming; you can find that solution in someone else\\'s post on the discussion board. The solution here is currently the most comfortable for me, and I am confident that at my current level I could explain it at interview, but if that changes I will update this. It currently beats about 70%. \\n\\n```\\nconst pacificAtlantic = (matrix) => {\\n  if (!matrix.length) return [];\\n  \\n  let numRows = matrix.length;\\n  let numCols = matrix[0].length;\\n  \\n  //create two adjacency matrices for results of atlantic and pacific dfs\\n  //(if a node can reach an ocean, it goes in that matrix)\\n  const pacific = new Array(numRows).fill().map(() => Array(numCols).fill(false))\\n  const atlantic = new Array(numRows).fill().map(() => Array(numCols).fill(false))\\n  \\n  /*KEY POINT: dfs will be run from the ocean inwards, not vice versa\\n  (from the ocean-adjacent nodes to the highest point(s))*/\\n  \\n  //dfs works by marking successfully visited squares in matrix as true\\n  //remember we\\'re going from ocean inland\\n  const dfs = (r, c, current, ocean) =>{ //r=row c=column ocean=pacific/atlantic current=the node we\\'re checking\\n    //base case: return if out of bounds\\n    if (r < 0 || c < 0 || r >= numRows || c >= numCols) return;\\n    //base case: return if our current node is larger than the surrounding nodes, because we are only marking node as true if it is larger than the next...remember we are working upwards to the highest point. This is a bit confusing, but look at the inputs: when we run this recursively, below, if N, S, E, or W are less than the current node, we\\'ll return, because they need to be HIGHER to work upwards.\\n    if (matrix[r][c] < current) return;\\n    //base case: return if this node already marked (in ocean), thus already visited\\n    if (ocean[r][c]) return;\\n    //if we\\'re here it means the conditions have been successfully met and thus we can reach the ocean, so we mark this node true (water can flow here) in that ocean\\n    ocean[r][c] = true;\\n    //call dfs recursively on each of the surrounding cells (ie N,S,E,W)\\n    dfs(r+1, c, matrix[r][c], ocean);\\n    dfs(r-1, c, matrix[r][c], ocean);\\n    dfs(r, c+1, matrix[r][c], ocean);\\n    dfs(r, c-1, matrix[r][c], ocean);\\n  };\\n  \\n  /*the pacfic touches the top and left sides of the matrix (N & E)\\n  and the atlantic touches the right and bottom sides (W & S)\\n  thus...*/\\n  //we run DFS for the top and bottom rows\\n  for (let col=0; col < numCols; col++){\\n   dfs(0, col, Number.MIN_SAFE_INTEGER, pacific);\\n   dfs(numRows-1, col, Number.MIN_SAFE_INTEGER, atlantic);\\n  }\\n  //and for the first and last columns\\n  for (let row = 0; row < numRows; row++){\\n    dfs(row, 0, Number.MIN_SAFE_INTEGER, pacific)\\n    dfs(row, numCols-1, Number.MIN_SAFE_INTEGER, atlantic)\\n  }\\n\\n  //add to result if exists in both pacific and atlantic\\n  let result = [];\\n  for (let i=0; i < numRows; i++){\\n    for (let j=0; j < numCols; j++){\\n      if (atlantic[i][j] && pacific[i][j]){\\n        result.push([i, j]);\\n      }\\n    }\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst pacificAtlantic = (matrix) => {\\n  if (!matrix.length) return [];\\n  \\n  let numRows = matrix.length;\\n  let numCols = matrix[0].length;\\n  \\n  //create two adjacency matrices for results of atlantic and pacific dfs\\n  //(if a node can reach an ocean, it goes in that matrix)\\n  const pacific = new Array(numRows).fill().map(() => Array(numCols).fill(false))\\n  const atlantic = new Array(numRows).fill().map(() => Array(numCols).fill(false))\\n  \\n  /*KEY POINT: dfs will be run from the ocean inwards, not vice versa\\n  (from the ocean-adjacent nodes to the highest point(s))*/\\n  \\n  //dfs works by marking successfully visited squares in matrix as true\\n  //remember we\\'re going from ocean inland\\n  const dfs = (r, c, current, ocean) =>{ //r=row c=column ocean=pacific/atlantic current=the node we\\'re checking\\n    //base case: return if out of bounds\\n    if (r < 0 || c < 0 || r >= numRows || c >= numCols) return;\\n    //base case: return if our current node is larger than the surrounding nodes, because we are only marking node as true if it is larger than the next...remember we are working upwards to the highest point. This is a bit confusing, but look at the inputs: when we run this recursively, below, if N, S, E, or W are less than the current node, we\\'ll return, because they need to be HIGHER to work upwards.\\n    if (matrix[r][c] < current) return;\\n    //base case: return if this node already marked (in ocean), thus already visited\\n    if (ocean[r][c]) return;\\n    //if we\\'re here it means the conditions have been successfully met and thus we can reach the ocean, so we mark this node true (water can flow here) in that ocean\\n    ocean[r][c] = true;\\n    //call dfs recursively on each of the surrounding cells (ie N,S,E,W)\\n    dfs(r+1, c, matrix[r][c], ocean);\\n    dfs(r-1, c, matrix[r][c], ocean);\\n    dfs(r, c+1, matrix[r][c], ocean);\\n    dfs(r, c-1, matrix[r][c], ocean);\\n  };\\n  \\n  /*the pacfic touches the top and left sides of the matrix (N & E)\\n  and the atlantic touches the right and bottom sides (W & S)\\n  thus...*/\\n  //we run DFS for the top and bottom rows\\n  for (let col=0; col < numCols; col++){\\n   dfs(0, col, Number.MIN_SAFE_INTEGER, pacific);\\n   dfs(numRows-1, col, Number.MIN_SAFE_INTEGER, atlantic);\\n  }\\n  //and for the first and last columns\\n  for (let row = 0; row < numRows; row++){\\n    dfs(row, 0, Number.MIN_SAFE_INTEGER, pacific)\\n    dfs(row, numCols-1, Number.MIN_SAFE_INTEGER, atlantic)\\n  }\\n\\n  //add to result if exists in both pacific and atlantic\\n  let result = [];\\n  for (let i=0; i < numRows; i++){\\n    for (let j=0; j < numCols; j++){\\n      if (atlantic[i][j] && pacific[i][j]){\\n        result.push([i, j]);\\n      }\\n    }\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136283,
                "title": "javascript-easy-dfs",
                "content": "```\\nvar pacificAtlantic = function(matrix) {\\n    let res = [];\\n    let min = -Infinity;\\n    let rows = matrix.length;\\n    let cols = matrix[0].length; \\n    let pacific = new Array(rows).fill().map(() => new Array(cols).fill(0));\\n    let atlantic = new Array(rows).fill().map(() => new Array(cols).fill(0));\\n    \\n    // left & right\\n    for (let row = 0; row < rows; row ++) {\\n        dfs(matrix, row, 0, min, pacific)\\n        dfs(matrix, row, matrix[0].length - 1, min, atlantic)\\n    }\\n    // top & bottom\\n    for (let col = 0; col <  cols; col ++) {\\n        dfs(matrix, 0, col, min, pacific)\\n        dfs(matrix, matrix.length - 1, col, min, atlantic)\\n    }\\n    \\n    for (let row = 0; row < rows; row ++) {\\n        for (let col = 0; col < cols; col ++) {\\n            if (pacific[row][col] == 1 && atlantic[row][col] == 1) {\\n                res.push([row, col])\\n            }\\n        }\\n    }\\n    return res;\\n    \\n};\\n\\nconst dfs = (matrix, r, c, prevVal, ocean) => {\\n    // 1. Check necessary condition.\\n    if (r < 0 || c < 0 || r > matrix.length - 1 || c > matrix[0].length - 1) return;\\n    if (matrix[r][c] < prevVal) return;\\n    if (ocean[r][c] == 1) return;\\n    \\n    // 2. Process call.\\n    ocean[r][c] = 1;\\n    \\n    // 3. Call dfs as needed.\\n    dfs (matrix, r - 1, c, matrix[r][c], ocean);\\n    dfs (matrix, r + 1, c, matrix[r][c], ocean);\\n    dfs (matrix, r, c - 1, matrix[r][c], ocean);\\n    dfs (matrix, r, c + 1, matrix[r][c], ocean);\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar pacificAtlantic = function(matrix) {\\n    let res = [];\\n    let min = -Infinity;\\n    let rows = matrix.length;\\n    let cols = matrix[0].length; \\n    let pacific = new Array(rows).fill().map(() => new Array(cols).fill(0));\\n    let atlantic = new Array(rows).fill().map(() => new Array(cols).fill(0));\\n    \\n    // left & right\\n    for (let row = 0; row < rows; row ++) {\\n        dfs(matrix, row, 0, min, pacific)\\n        dfs(matrix, row, matrix[0].length - 1, min, atlantic)\\n    }\\n    // top & bottom\\n    for (let col = 0; col <  cols; col ++) {\\n        dfs(matrix, 0, col, min, pacific)\\n        dfs(matrix, matrix.length - 1, col, min, atlantic)\\n    }\\n    \\n    for (let row = 0; row < rows; row ++) {\\n        for (let col = 0; col < cols; col ++) {\\n            if (pacific[row][col] == 1 && atlantic[row][col] == 1) {\\n                res.push([row, col])\\n            }\\n        }\\n    }\\n    return res;\\n    \\n};\\n\\nconst dfs = (matrix, r, c, prevVal, ocean) => {\\n    // 1. Check necessary condition.\\n    if (r < 0 || c < 0 || r > matrix.length - 1 || c > matrix[0].length - 1) return;\\n    if (matrix[r][c] < prevVal) return;\\n    if (ocean[r][c] == 1) return;\\n    \\n    // 2. Process call.\\n    ocean[r][c] = 1;\\n    \\n    // 3. Call dfs as needed.\\n    dfs (matrix, r - 1, c, matrix[r][c], ocean);\\n    dfs (matrix, r + 1, c, matrix[r][c], ocean);\\n    dfs (matrix, r, c - 1, matrix[r][c], ocean);\\n    dfs (matrix, r, c + 1, matrix[r][c], ocean);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1052432,
                "title": "insufficient-and-incorrect-explanation",
                "content": "If the starting point is 5 in the midle on the matrix, then we can reach to Atlantic or Pacific ocean. (\\nPacific ~   ~   ~   ~   ~ \\n       ~  1   2   2   3  (5) *\\n       ~  3   2   3  (4) (4) *\\n->       ~  2   4  (5)  3   1  <-\\n       ~ (6) (7)  1   4   5  *\\n       ~ (5)  1   1   2   4  *\\n          *   *   *   *   * Atlantic\\nAlso, it is mentioned that the water can go either up, down, left or right, then how does flow reach from (7) to (5)\\n\\nPacific ~   ~   ~   ~   ~ \\n       ~  1   2   2   3  (5) *\\n       ~  3   2   3  (4) (4) *\\n       ~  2   4  (5)  3   1  *\\n       ~ (6) (7)  1   4   5  *\\n       ~ (5)  1   1   2   4  *\\n          *   *   *   *   * Atlantic\\n\\nCan someone please help me with the explanation here?",
                "solutionTags": [],
                "code": "If the starting point is 5 in the midle on the matrix, then we can reach to Atlantic or Pacific ocean. (\\nPacific ~   ~   ~   ~   ~ \\n       ~  1   2   2   3  (5) *\\n       ~  3   2   3  (4) (4) *\\n->       ~  2   4  (5)  3   1  <-\\n       ~ (6) (7)  1   4   5  *\\n       ~ (5)  1   1   2   4  *\\n          *   *   *   *   * Atlantic\\nAlso, it is mentioned that the water can go either up, down, left or right, then how does flow reach from (7) to (5)\\n\\nPacific ~   ~   ~   ~   ~ \\n       ~  1   2   2   3  (5) *\\n       ~  3   2   3  (4) (4) *\\n       ~  2   4  (5)  3   1  *\\n       ~ (6) (7)  1   4   5  *\\n       ~ (5)  1   1   2   4  *\\n          *   *   *   *   * Atlantic\\n\\nCan someone please help me with the explanation here?",
                "codeTag": "Unknown"
            },
            {
                "id": 608490,
                "title": "c-implementation-dfs",
                "content": "C++ Implementation of the following amazing post:\\nhttps://leetcode.com/problems/pacific-atlantic-water-flow/discuss/90739/Python-DFS-bests-85.-Tips-for-all-DFS-in-matrix-question.\\n\\n```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, -1, 0};\\n    int dy[4] = {1, 0, 0, -1};\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& v, int i, int j, int height) {\\n        if (i < 0 || i > grid.size()-1 || j < 0 || j > grid[0].size()-1 || v[i][j]) return;\\n        if (grid[i][j] < height) return;\\n        v[i][j] = true;\\n        for (int k=0; k<4; k++) {\\n            dfs(grid, v, i+dx[k], j+dy[k], grid[i][j]);\\n        }\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        if (!matrix.size()) return ans;\\n        vector<vector<bool>> v1(matrix.size(), vector<bool>(matrix[0].size(), false));\\n        vector<vector<bool>> v2(matrix.size(), vector<bool>(matrix[0].size(), false));\\n        for (int i=0; i<matrix.size(); i++) {\\n            dfs(matrix, v1, i, 0, INT_MIN);\\n            dfs(matrix, v2, i, matrix[0].size()-1, INT_MIN);\\n        }\\n        for (int j=0; j<matrix[0].size(); j++) {\\n            dfs(matrix, v1, 0, j, INT_MIN);\\n            dfs(matrix, v2, matrix.size()-1, j, INT_MIN);\\n        }\\n        for (int i=0; i<matrix.size(); i++) {\\n            for (int j=0; j<matrix[0].size(); j++) {\\n                if (v1[i][j] && v2[i][j]) {\\n                    vector<int> temp{i, j};\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, -1, 0};\\n    int dy[4] = {1, 0, 0, -1};\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& v, int i, int j, int height) {\\n        if (i < 0 || i > grid.size()-1 || j < 0 || j > grid[0].size()-1 || v[i][j]) return;\\n        if (grid[i][j] < height) return;\\n        v[i][j] = true;\\n        for (int k=0; k<4; k++) {\\n            dfs(grid, v, i+dx[k], j+dy[k], grid[i][j]);\\n        }\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        if (!matrix.size()) return ans;\\n        vector<vector<bool>> v1(matrix.size(), vector<bool>(matrix[0].size(), false));\\n        vector<vector<bool>> v2(matrix.size(), vector<bool>(matrix[0].size(), false));\\n        for (int i=0; i<matrix.size(); i++) {\\n            dfs(matrix, v1, i, 0, INT_MIN);\\n            dfs(matrix, v2, i, matrix[0].size()-1, INT_MIN);\\n        }\\n        for (int j=0; j<matrix[0].size(); j++) {\\n            dfs(matrix, v1, 0, j, INT_MIN);\\n            dfs(matrix, v2, matrix.size()-1, j, INT_MIN);\\n        }\\n        for (int i=0; i<matrix.size(); i++) {\\n            for (int j=0; j<matrix[0].size(); j++) {\\n                if (v1[i][j] && v2[i][j]) {\\n                    vector<int> temp{i, j};\\n                    ans.push_back(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90730,
                "title": "python-dfs-from-ocean-easy-to-understand",
                "content": "Divide the problem into the set of cell where water can run into the Pacific and the set of cell where water can run into the Atlantic. Then we join two sets to get the result.\\nFor the Pacific subset, start running from the ocean (edge where row = 0 or col = 0), and find all the cells which are greater or equal.\\nSimilar for the Atlantic.\\n```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        results = []\\n        if not len(matrix) or not len(matrix[0]):\\n            return results\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        \\n        def Pacific(mat):\\n            visited = set()\\n            for j in range(cols):\\n                dfs(mat, 0, j, visited)\\n            for i in range(rows):\\n                dfs(mat, i, 0, visited)\\n            return visited        \\n        \\n        def Atlantic(mat):\\n            visited = set()\\n            for j in reversed(range(cols)):\\n                dfs(mat, rows-1, j, visited)\\n            for i in reversed(range(rows)):\\n                dfs(mat, i, cols-1, visited)\\n            return visited\\n        \\n        def dfs(mat, i, j, visited):\\n            if (i, j) in visited:\\n                return\\n            visited.add((i, j))\\n            for direction in directions:\\n                next_i, next_j = i+direction[0],j+direction[1]\\n                if 0 <= next_i < rows and 0 <= next_j < cols and mat[next_i][next_j] >= mat[i][j]:\\n                    dfs(mat, next_i, next_j, visited)\\n        \\n        atlantic = Atlantic(matrix)\\n        pacific = Pacific(matrix)\\n        for i, j in atlantic:\\n            if (i,j) in pacific:\\n                results.append([i,j])\\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        results = []\\n        if not len(matrix) or not len(matrix[0]):\\n            return results\\n        rows, cols = len(matrix), len(matrix[0])\\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        \\n        def Pacific(mat):\\n            visited = set()\\n            for j in range(cols):\\n                dfs(mat, 0, j, visited)\\n            for i in range(rows):\\n                dfs(mat, i, 0, visited)\\n            return visited        \\n        \\n        def Atlantic(mat):\\n            visited = set()\\n            for j in reversed(range(cols)):\\n                dfs(mat, rows-1, j, visited)\\n            for i in reversed(range(rows)):\\n                dfs(mat, i, cols-1, visited)\\n            return visited\\n        \\n        def dfs(mat, i, j, visited):\\n            if (i, j) in visited:\\n                return\\n            visited.add((i, j))\\n            for direction in directions:\\n                next_i, next_j = i+direction[0],j+direction[1]\\n                if 0 <= next_i < rows and 0 <= next_j < cols and mat[next_i][next_j] >= mat[i][j]:\\n                    dfs(mat, next_i, next_j, visited)\\n        \\n        atlantic = Atlantic(matrix)\\n        pacific = Pacific(matrix)\\n        for i, j in atlantic:\\n            if (i,j) in pacific:\\n                results.append([i,j])\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90810,
                "title": "java-28ms-bfs-solution-using-one-queue",
                "content": "I use two bits to save the information of pacific ocean and atlantic ocean.\\n`00`: cannot reach any ocean\\n`01`: can reach pacific ocean\\n`10`: can reach atlantic ocean\\n`11`: can reach two oceans\\n\\n**Step 1**: Update the status of border cells and put them into the queue\\n**Step 2**: Iterate the queue and explore the four directions. We only put a new cell into the queue if :\\n- row and col index are valid\\n- the height of the new cell is larger or equals to the height of the current cell\\n- the new cell can benifit from the current cell (check status)\\n\\n```java\\npublic class Solution {\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new ArrayList<>();\\n        int m = matrix.length;\\n        if (m == 0) return res;\\n        int n = matrix[0].length;\\n        int[][] state = new int[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            state[i][0] |= 1;\\n            if (i == m - 1 || n == 1) state[i][0] |= 2;\\n            if (state[i][0] == 3) res.add(new int[]{i, 0});\\n            q.add(new int[]{i, 0});\\n            if (n > 1) {\\n                state[i][n - 1] |= 2;\\n                if (i == 0) state[i][n - 1] |= 1;\\n                if (state[i][n - 1] == 3) res.add(new int[]{i, n - 1});\\n                q.add(new int[]{i, n - 1});\\n            }\\n        }\\n        for (int j = 1; j < n - 1; j++) {\\n            state[0][j] |= 1;\\n            if (m == 1) state[0][j] |= 2;\\n            if (state[0][j] == 3) res.add(new int[]{0, j});\\n            q.add(new int[]{0, j});\\n            if (m > 1) {\\n                state[m - 1][j] |= 2;\\n                if (state[m - 1][j] == 3) res.add(new int[]{m - 1, j});\\n                q.add(new int[]{m - 1, j});\\n            }\\n        }\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while (!q.isEmpty()) {\\n            int[] cell = q.poll();\\n            for (int[] dir : dirs) {\\n                int row = cell[0] + dir[0];\\n                int col = cell[1] + dir[1];\\n                if (row < 0 || col < 0 || row == m || col == n || matrix[row][col] < matrix[cell[0]][cell[1]] || ((state[cell[0]][cell[1]] | state[row][col]) == state[row][col])) continue;\\n                state[row][col] |= state[cell[0]][cell[1]];\\n                if (state[row][col] == 3) res.add(new int[]{row, col});\\n                q.add(new int[]{row, col});\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> res = new ArrayList<>();\\n        int m = matrix.length;\\n        if (m == 0) return res;\\n        int n = matrix[0].length;\\n        int[][] state = new int[m][n];\\n        Queue<int[]> q = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            state[i][0] |= 1;\\n            if (i == m - 1 || n == 1) state[i][0] |= 2;\\n            if (state[i][0] == 3) res.add(new int[]{i, 0});\\n            q.add(new int[]{i, 0});\\n            if (n > 1) {\\n                state[i][n - 1] |= 2;\\n                if (i == 0) state[i][n - 1] |= 1;\\n                if (state[i][n - 1] == 3) res.add(new int[]{i, n - 1});\\n                q.add(new int[]{i, n - 1});\\n            }\\n        }\\n        for (int j = 1; j < n - 1; j++) {\\n            state[0][j] |= 1;\\n            if (m == 1) state[0][j] |= 2;\\n            if (state[0][j] == 3) res.add(new int[]{0, j});\\n            q.add(new int[]{0, j});\\n            if (m > 1) {\\n                state[m - 1][j] |= 2;\\n                if (state[m - 1][j] == 3) res.add(new int[]{m - 1, j});\\n                q.add(new int[]{m - 1, j});\\n            }\\n        }\\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        while (!q.isEmpty()) {\\n            int[] cell = q.poll();\\n            for (int[] dir : dirs) {\\n                int row = cell[0] + dir[0];\\n                int col = cell[1] + dir[1];\\n                if (row < 0 || col < 0 || row == m || col == n || matrix[row][col] < matrix[cell[0]][cell[1]] || ((state[cell[0]][cell[1]] | state[row][col]) == state[row][col])) continue;\\n                state[row][col] |= state[cell[0]][cell[1]];\\n                if (state[row][col] == 3) res.add(new int[]{row, col});\\n                q.add(new int[]{row, col});\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90828,
                "title": "simple-java-dfs-solution",
                "content": "Build two sets for Pacific and Atlantic. The result is the intersection of them.\\n```\\n private int[][] direction = new int[][]{{1, 0},{0, 1},{-1, 0},{0, -1}};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> result = new ArrayList<>();\\n        if (matrix.length == 0) return result;\\n        Set<Integer> pacific = new HashSet<>();\\n        Set<Integer> atlantic = new HashSet<>();\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            dfs(matrix, 0, i, pacific);\\n            dfs(matrix, matrix.length - 1, i, atlantic);\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            dfs(matrix, i, 0, pacific);\\n            dfs(matrix, i, matrix[0].length - 1, atlantic);\\n        }\\n        \\n        for (int i: pacific) {\\n            if (atlantic.contains(i)) {\\n                result.add(decode(i, matrix));\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(int[][] matrix, int i, int j, Set<Integer> result) {\\n        if (!result.add(encode(i, j, matrix))) return;\\n        for (int[] dir: direction) {\\n            int x = dir[0] + i;\\n            int y = dir[1] + j;\\n            if (x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length && matrix[x][y] >= matrix[i][j]) {\\n                dfs(matrix, x, y, result);\\n            }\\n        }\\n    }\\n    \\n    private int[] decode(int i, int[][] matrix) {\\n        return new int[]{i / matrix[0].length, i % matrix[0].length};\\n    }\\n    \\n    private int encode(int i, int j, int[][] matrix) {\\n        return i * matrix[0].length + j;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n private int[][] direction = new int[][]{{1, 0},{0, 1},{-1, 0},{0, -1}};\\n    public List<int[]> pacificAtlantic(int[][] matrix) {\\n        List<int[]> result = new ArrayList<>();\\n        if (matrix.length == 0) return result;\\n        Set<Integer> pacific = new HashSet<>();\\n        Set<Integer> atlantic = new HashSet<>();\\n        for (int i = 0; i < matrix[0].length; i++) {\\n            dfs(matrix, 0, i, pacific);\\n            dfs(matrix, matrix.length - 1, i, atlantic);\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            dfs(matrix, i, 0, pacific);\\n            dfs(matrix, i, matrix[0].length - 1, atlantic);\\n        }\\n        \\n        for (int i: pacific) {\\n            if (atlantic.contains(i)) {\\n                result.add(decode(i, matrix));\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private void dfs(int[][] matrix, int i, int j, Set<Integer> result) {\\n        if (!result.add(encode(i, j, matrix))) return;\\n        for (int[] dir: direction) {\\n            int x = dir[0] + i;\\n            int y = dir[1] + j;\\n            if (x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length && matrix[x][y] >= matrix[i][j]) {\\n                dfs(matrix, x, y, result);\\n            }\\n        }\\n    }\\n    \\n    private int[] decode(int i, int[][] matrix) {\\n        return new int[]{i / matrix[0].length, i % matrix[0].length};\\n    }\\n    \\n    private int encode(int i, int j, int[][] matrix) {\\n        return i * matrix[0].length + j;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420613,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def pacificAtlantic(self, h: List[List[int]]) -> List[List[int]]:\\n        n, m = len(h), len(h[0])\\n        isPacc = [[True if i == 0 or j == 0 else False for j in range(m)] for i in range(n)]\\n        isAtl = [[True if i == n - 1 or j == m - 1 else False for j in range(m)] for i in range(n)]\\n        \\n        def Pac(i, j, isPac):\\n            val = h[i][j]\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if 0 <= x < n and 0 <= y < m and not isPac[x][y] and h[x][y] >= val:\\n                    isPac[x][y] = True\\n                    Pac(x, y, isPac)\\n        \\n        for i in range(n): Pac(i, 0, isPacc)\\n        for j in range(m): Pac(0, j, isPacc)\\n        for i in range(n): Pac(i, m-1, isAtl)\\n        for j in range(m): Pac(n-1, j, isAtl)\\n        \\n        return [[i, j] for i in range(n) for j in range(m) if isPacc[i][j] and isAtl[i][j]]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, h: List[List[int]]) -> List[List[int]]:\\n        n, m = len(h), len(h[0])\\n        isPacc = [[True if i == 0 or j == 0 else False for j in range(m)] for i in range(n)]\\n        isAtl = [[True if i == n - 1 or j == m - 1 else False for j in range(m)] for i in range(n)]\\n        \\n        def Pac(i, j, isPac):\\n            val = h[i][j]\\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if 0 <= x < n and 0 <= y < m and not isPac[x][y] and h[x][y] >= val:\\n                    isPac[x][y] = True\\n                    Pac(x, y, isPac)\\n        \\n        for i in range(n): Pac(i, 0, isPacc)\\n        for j in range(m): Pac(0, j, isPacc)\\n        for i in range(n): Pac(i, m-1, isAtl)\\n        for j in range(m): Pac(n-1, j, isAtl)\\n        \\n        return [[i, j] for i in range(n) for j in range(m) if isPacc[i][j] and isAtl[i][j]]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507914,
                "title": "c-solution-bfs",
                "content": "**Language Used: C++**\\n\\n*If you have any questions, feel free to ask. If you like the solution and explanation, please **upvote!***\\n\\nTime Complexity: O(nm);\\nSpace Complexity: O(nm);\\n\\nIntution:\\n*  When we are at lower level, the water must come in it from a higher level. \\n*  So for pacific store all the element in the queue which are adjacent to the sea and traverse DFS/BFS to find the higher level.\\n*  Do the same for atlantic\\n*  Now the level which is covered by both is our answer.\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii; \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& h) {\\n        // Storing the solution\\n        vector<vector<int>> ans;\\n        int n = h.size();\\n        int m = h[0].size();\\n        // Initializing the Pacific and Atlantic matrices;\\n        vector<vector<int>> pa(n, vector<int>(m, 0));\\n        vector<vector<int>> at(n, vector<int>(m, 0));\\n        \\n        // BFS for the pacific;\\n        queue<pii> q;\\n        for(int i{}; i<n; i++) q.push({i, 0});\\n        for(int j{}; j<m; j++) q.push({0, j});\\n        bfs(h, q, pa);\\n        \\n        // BFS for the atlantic;\\n        queue<pii> q2;\\n        for(int i{}; i<n; i++) q2.push({i, m-1});\\n        for(int j{}; j<m; j++) q2.push({n-1, j});\\n        bfs(h, q2, at);\\n        \\n        for(int i{}; i<n; i++){\\n            for(int j{}; j<m; j++){\\n                if(pa[i][j]==1 && at[i][j]==1) ans.push_back({i, j});\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void bfs(vector<vector<int>>& h, queue<pii>&q, vector<vector<int>>& vis){\\n        int n = h.size(); int m = h[0].size();          // Dimension of the matrix\\n        int dx[4] = {-1,0,1,0};\\n        int dy[4] = {0,1,0,-1};\\n        while(!q.empty()){\\n            int x = q.front().first; int y = q.front().second;\\n            q.pop(); vis[x][y] = 1;        // Popping the element out ans marking as visited;\\n            for(int i{}; i<4; i++){\\n                int cx = x + dx[i]; int cy = y + dy[i];\\n\\t\\t\\t\\t// Checking feasibility of Current_x & Current_y\\n                if(cx>=0 && cy>=0 && cx<n && cy<m){\\n                    if(h[cx][cy] >= h[x][y] && vis[cx][cy] == 0) q.push({cx, cy});\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\nKeep Coding\\n**`while(!success){ tryAgain(); } :)`**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pii; \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& h) {\\n        // Storing the solution\\n        vector<vector<int>> ans;\\n        int n = h.size();\\n        int m = h[0].size();\\n        // Initializing the Pacific and Atlantic matrices;\\n        vector<vector<int>> pa(n, vector<int>(m, 0));\\n        vector<vector<int>> at(n, vector<int>(m, 0));\\n        \\n        // BFS for the pacific;\\n        queue<pii> q;\\n        for(int i{}; i<n; i++) q.push({i, 0});\\n        for(int j{}; j<m; j++) q.push({0, j});\\n        bfs(h, q, pa);\\n        \\n        // BFS for the atlantic;\\n        queue<pii> q2;\\n        for(int i{}; i<n; i++) q2.push({i, m-1});\\n        for(int j{}; j<m; j++) q2.push({n-1, j});\\n        bfs(h, q2, at);\\n        \\n        for(int i{}; i<n; i++){\\n            for(int j{}; j<m; j++){\\n                if(pa[i][j]==1 && at[i][j]==1) ans.push_back({i, j});\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    void bfs(vector<vector<int>>& h, queue<pii>&q, vector<vector<int>>& vis){\\n        int n = h.size(); int m = h[0].size();          // Dimension of the matrix\\n        int dx[4] = {-1,0,1,0};\\n        int dy[4] = {0,1,0,-1};\\n        while(!q.empty()){\\n            int x = q.front().first; int y = q.front().second;\\n            q.pop(); vis[x][y] = 1;        // Popping the element out ans marking as visited;\\n            for(int i{}; i<4; i++){\\n                int cx = x + dx[i]; int cy = y + dy[i];\\n\\t\\t\\t\\t// Checking feasibility of Current_x & Current_y\\n                if(cx>=0 && cy>=0 && cx<n && cy<m){\\n                    if(h[cx][cy] >= h[x][y] && vis[cx][cy] == 0) q.push({cx, cy});\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325505,
                "title": "easy-dfs-solution-99-30-faster",
                "content": "```\\nclass Solution {\\n    \\n    int[][] dir = {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int m = heights.length, n = heights[0].length, i, j;\\n        \\n        // mark true to all the cells that can flow to pacific ocean\\n        boolean[][] pacific = new boolean[m][n];\\n        for(i = 0; i < n; i++) bfs(heights, 0, i, pacific); // first row \\n        for(i = 0; i < m; i++) bfs(heights, i, 0, pacific); // first column\\n        \\n        // mark true to all the cells that can flow to atlantic ocean\\n        boolean[][] atlantic = new boolean[m][n];\\n        for(i = n-1; i >= 0; i--) bfs(heights, m-1, i, atlantic); // last row\\n        for(i = m-1; i >= 0; i--) bfs(heights, i, n-1, atlantic); // last column\\n        \\n        // find the cell of rain water that can flow to both ocean\\n        List<List<Integer>> output = new ArrayList<>();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(atlantic[i][j] && pacific[i][j])\\n                    output.add(new ArrayList<>(List.of(i, j)));\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    void bfs(int[][] heights, int r, int c, boolean[][] ans){\\n        \\n        ans[r][c] = true; // mark reachable\\n        for(int i = 0; i < dir.length; i++){\\n            \\n            int newr = r+dir[i][0];\\n            int newc = c+dir[i][1];\\n            if(newr<0 || newc<0 || newr>=heights.length || newc>=heights[0].length || ans[newr][newc] || heights[newr][newc] < heights[r][c])\\n                continue;\\n            \\n            bfs(heights, newr, newc, ans);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[][] dir = {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int m = heights.length, n = heights[0].length, i, j;\\n        \\n        // mark true to all the cells that can flow to pacific ocean\\n        boolean[][] pacific = new boolean[m][n];\\n        for(i = 0; i < n; i++) bfs(heights, 0, i, pacific); // first row \\n        for(i = 0; i < m; i++) bfs(heights, i, 0, pacific); // first column\\n        \\n        // mark true to all the cells that can flow to atlantic ocean\\n        boolean[][] atlantic = new boolean[m][n];\\n        for(i = n-1; i >= 0; i--) bfs(heights, m-1, i, atlantic); // last row\\n        for(i = m-1; i >= 0; i--) bfs(heights, i, n-1, atlantic); // last column\\n        \\n        // find the cell of rain water that can flow to both ocean\\n        List<List<Integer>> output = new ArrayList<>();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(atlantic[i][j] && pacific[i][j])\\n                    output.add(new ArrayList<>(List.of(i, j)));\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    void bfs(int[][] heights, int r, int c, boolean[][] ans){\\n        \\n        ans[r][c] = true; // mark reachable\\n        for(int i = 0; i < dir.length; i++){\\n            \\n            int newr = r+dir[i][0];\\n            int newc = c+dir[i][1];\\n            if(newr<0 || newc<0 || newr>=heights.length || newc>=heights[0].length || ans[newr][newc] || heights[newr][newc] < heights[r][c])\\n                continue;\\n            \\n            bfs(heights, newr, newc, ans);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321368,
                "title": "python-dfs-beats-99-13-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:  # Time: O(mn) and Space: O(mn)\\n       \\n\\t    rows, cols = len(heights), len(heights[0])\\n        pac, atl = set(), set()\\n\\n        def dfs(r, c, visit, prevHeight):  # current location, set of already visited tiles, the value of the tile where we are calling the dfs function\\n          \\n\\t\\t    # we will check if the index[r, c] is not already visited, row and column is inbounds and\\n            # the current tile should be lower than from we are coming from, it\\'s the condition for waterflow mentioned\\n            # if any one of these conditions fails exit the dfs by returning to from we came from\\n            if (r, c) in visit or r < 0 or c < 0 or r == rows or c == cols or heights[r][c] < prevHeight:\\n                return\\n\\t\\t\\t\\t\\n            visit.add((r, c))  # mark the tile visited(pac or atl depending on what is passed from the dfs function) when the if conditions true\\n\\t\\t\\t\\n            dfs(r + 1, c, visit, heights[r][c])  # we will next visit the tile down from the current one\\n            dfs(r - 1, c, visit, heights[r][c])  # up\\n            dfs(r, c + 1, visit, heights[r][c])  # right\\n            dfs(r, c - 1, visit, heights[r][c])  # left\\n\\n        for c in range(cols):                            # we will traverse the first & last row by fixing the r and moving c\\n            dfs(0, c, pac, heights[0][c])                # first row is just next to pacific\\n            dfs(rows - 1, c, atl, heights[rows - 1][c])  # last row is just next to atlantic\\n\\n        for r in range(rows):                            # we will traverse the first & last column by fixing the c and moving r\\n            dfs(r, 0, pac, heights[r][0])                # first column is just next to pacific\\n            dfs(r, cols - 1, atl, heights[r][cols - 1])  # last column is just next to atlantic\\n\\n        return list(pac.intersection(atl))  # returns the list which contains the same [i, j] in both the sets\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:  # Time: O(mn) and Space: O(mn)\\n       \\n\\t    rows, cols = len(heights), len(heights[0])\\n        pac, atl = set(), set()\\n\\n        def dfs(r, c, visit, prevHeight):  # current location, set of already visited tiles, the value of the tile where we are calling the dfs function\\n          \\n\\t\\t    # we will check if the index[r, c] is not already visited, row and column is inbounds and\\n            # the current tile should be lower than from we are coming from, it\\'s the condition for waterflow mentioned\\n            # if any one of these conditions fails exit the dfs by returning to from we came from\\n            if (r, c) in visit or r < 0 or c < 0 or r == rows or c == cols or heights[r][c] < prevHeight:\\n                return\\n\\t\\t\\t\\t\\n            visit.add((r, c))  # mark the tile visited(pac or atl depending on what is passed from the dfs function) when the if conditions true\\n\\t\\t\\t\\n            dfs(r + 1, c, visit, heights[r][c])  # we will next visit the tile down from the current one\\n            dfs(r - 1, c, visit, heights[r][c])  # up\\n            dfs(r, c + 1, visit, heights[r][c])  # right\\n            dfs(r, c - 1, visit, heights[r][c])  # left\\n\\n        for c in range(cols):                            # we will traverse the first & last row by fixing the r and moving c\\n            dfs(0, c, pac, heights[0][c])                # first row is just next to pacific\\n            dfs(rows - 1, c, atl, heights[rows - 1][c])  # last row is just next to atlantic\\n\\n        for r in range(rows):                            # we will traverse the first & last column by fixing the c and moving r\\n            dfs(r, 0, pac, heights[r][0])                # first column is just next to pacific\\n            dfs(r, cols - 1, atl, heights[r][cols - 1])  # last column is just next to atlantic\\n\\n        return list(pac.intersection(atl))  # returns the list which contains the same [i, j] in both the sets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795320,
                "title": "java-easy-beginner-friendly-simple-dfs-calls-with-checks-slow-but-works-fine",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> res;\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        res = new ArrayList<>();\\n        for(int i = 0;i<heights.length;i++){\\n            for(int j=0;j<heights[0].length;j++){\\n                if((i==heights.length-1 && j==0) || (i==0 && j==heights[0].length-1)){\\n                    res.add(Arrays.asList(i,j));\\n                    continue;\\n                }\\n                boolean[] pair = new boolean[2];\\n                boolean[][] visited = new boolean[heights.length][heights[0].length];\\n                dfs(heights,i,j,pair,visited,heights[i][j]);\\n                if(pair[0] && pair[1]) res.add(Arrays.asList(i,j));\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int[][] heights,int i,int j,boolean[] pair,boolean[][] visited,int prev){\\n        if(i<0 || j<0 || i>=heights.length || j>=heights[0].length || visited[i][j] == true || heights[i][j] > prev) return;\\n        if(i == 0 || j==0) pair[0] = true;\\n        if(i == heights.length-1 || j == heights[0].length-1) pair[1] = true;\\n        if(pair[0] && pair[1]) return;\\n        prev = heights[i][j];\\n        visited[i][j] = true;\\n        dfs(heights,i-1,j,pair,visited,prev);\\n        dfs(heights,i,j+1,pair,visited,prev);\\n        dfs(heights,i+1,j,pair,visited,prev);\\n        dfs(heights,i,j-1,pair,visited,prev);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> res;\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        res = new ArrayList<>();\\n        for(int i = 0;i<heights.length;i++){\\n            for(int j=0;j<heights[0].length;j++){\\n                if((i==heights.length-1 && j==0) || (i==0 && j==heights[0].length-1)){\\n                    res.add(Arrays.asList(i,j));\\n                    continue;\\n                }\\n                boolean[] pair = new boolean[2];\\n                boolean[][] visited = new boolean[heights.length][heights[0].length];\\n                dfs(heights,i,j,pair,visited,heights[i][j]);\\n                if(pair[0] && pair[1]) res.add(Arrays.asList(i,j));\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int[][] heights,int i,int j,boolean[] pair,boolean[][] visited,int prev){\\n        if(i<0 || j<0 || i>=heights.length || j>=heights[0].length || visited[i][j] == true || heights[i][j] > prev) return;\\n        if(i == 0 || j==0) pair[0] = true;\\n        if(i == heights.length-1 || j == heights[0].length-1) pair[1] = true;\\n        if(pair[0] && pair[1]) return;\\n        prev = heights[i][j];\\n        visited[i][j] = true;\\n        dfs(heights,i-1,j,pair,visited,prev);\\n        dfs(heights,i,j+1,pair,visited,prev);\\n        dfs(heights,i+1,j,pair,visited,prev);\\n        dfs(heights,i,j-1,pair,visited,prev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683885,
                "title": "explanation-for-why-dp-doesn-t-work-with-code",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.PACIFIC, self.ATLANTIC = 0, 1\\n        self.VISITED = -1\\n        EAST, WEST = [0, 1], [0, -1]\\n        NORTH, SOUTH = [-1, 0], [1, 0]\\n        self.DIRECTIONS = [EAST, WEST, NORTH, SOUTH]\\n        self.ROWS, self.COLS = 0, 0\\n        self.heights = []\\n        self.pacific_map = {}\\n        self.atlantic_map = {}\\n        \\n        \\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        self.ROWS, self.COLS = len(heights), len(heights[0])\\n        self.heights = heights\\n        both_reachable_coordinates = []\\n        \\n        for row in range(self.ROWS):\\n            for col in range(self.COLS):\\n                if (self.ocean_reachable(row, col, self.ATLANTIC) and\\n                    self.ocean_reachable(row, col, self.PACIFIC)):\\n                    both_reachable_coordinates.append([row, col])\\n\\n        return both_reachable_coordinates\\n                    \\n    def in_pacific(self, row, col):\\n        return row == -1 or col == -1\\n    \\n    def in_atlantic(self, row, col):\\n        return row == self.ROWS or col == self.COLS\\n    \\n    def in_range(self, row, col):\\n        return row in range(self.ROWS) and col in range(self.COLS)\\n    \\n    def can_water_flow(self, curr_height, new_row, new_col):\\n        return curr_height >= self.heights[new_row][new_col]\\n        \\n    def not_visited(self, row, col):\\n        return self.heights[row][col] != -1\\n    \\n    def update_dp_map(self, ocean, row, col, value):\\n        if ocean == self.PACIFIC:\\n            self.pacific_map[(row,col)] = value\\n        else:\\n            self.atlantic_map[(row,col)] = value                     \\n\\n    def is_cached(self, row, col, ocean):\\n        if ocean == self.PACIFIC:\\n            return (row,col) in self.pacific_map\\n        else:\\n            return (row,col) in self.atlantic_map\\n        \\n    def cached_value(self, row, col, ocean):\\n        if ocean == self.PACIFIC:\\n            return self.pacific_map[(row,col)]\\n        else:\\n            return self.atlantic_map[(row,col)]\\n\\n    def ocean_reachable(self, row, col, ocean):\\n            if self.is_cached(row, col, ocean):\\n                return self.cached_value(row, col, ocean)\\n           \\n            if ocean == self.PACIFIC and self.in_pacific(row, col):\\n                self.update_dp_map(ocean, row, col, True)\\n                return True\\n            if ocean == self.ATLANTIC and self.in_atlantic(row, col):\\n                self.update_dp_map(ocean, row, col, True)\\n                return True\\n            \\n            if not self.in_range(row, col):\\n                self.update_dp_map(ocean, row, col, False)\\n                return False\\n            \\n            curr_height = self.heights[row][col]\\n            self.heights[row][col] = self.VISITED\\n            for drow, dcol in self.DIRECTIONS:\\n                new_row, new_col = row + drow, col + dcol\\n                if ((((self.in_range(new_row, new_col) and \\n                     self.not_visited(new_row, new_col) and \\n                      self.can_water_flow(curr_height, new_row, new_col)) or\\n                      not self.in_range(new_row, new_col)) and\\n                    self.ocean_reachable(new_row, new_col, ocean))):\\n                    self.heights[row][col] = curr_height\\n                    self.update_dp_map(ocean, row, col, True) \\n                    self.update_dp_map(ocean, new_row, new_col, True) \\n                    return True\\n            \\n            self.heights[row][col] = curr_height\\n            self.update_dp_map(ocean, row, col, False)\\n            return False\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a0a1979b-ab69-40cc-9f6d-61d122d0a7f2_1641948104.655987.png)\\n\\nLets say you are trying to find if you can reach Pacific from index(1,2), and you reached index(1,2) via index(1,1). Also, lets assume the only way to Pacific from index(1,2) is via index(1,1), but since we reached index(1,2) from (1,1), we cannot visit it again to prevent cycles. So, even though the we can reach pacific from (1,2), since the answer to (1,2) was dependent on (1,1) and the answer to (1,1) was dependent on (1,2), we have what we call a **Cyclic Dependency**. Because of this, DP will not work for certain cases like this.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.PACIFIC, self.ATLANTIC = 0, 1\\n        self.VISITED = -1\\n        EAST, WEST = [0, 1], [0, -1]\\n        NORTH, SOUTH = [-1, 0], [1, 0]\\n        self.DIRECTIONS = [EAST, WEST, NORTH, SOUTH]\\n        self.ROWS, self.COLS = 0, 0\\n        self.heights = []\\n        self.pacific_map = {}\\n        self.atlantic_map = {}\\n        \\n        \\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        self.ROWS, self.COLS = len(heights), len(heights[0])\\n        self.heights = heights\\n        both_reachable_coordinates = []\\n        \\n        for row in range(self.ROWS):\\n            for col in range(self.COLS):\\n                if (self.ocean_reachable(row, col, self.ATLANTIC) and\\n                    self.ocean_reachable(row, col, self.PACIFIC)):\\n                    both_reachable_coordinates.append([row, col])\\n\\n        return both_reachable_coordinates\\n                    \\n    def in_pacific(self, row, col):\\n        return row == -1 or col == -1\\n    \\n    def in_atlantic(self, row, col):\\n        return row == self.ROWS or col == self.COLS\\n    \\n    def in_range(self, row, col):\\n        return row in range(self.ROWS) and col in range(self.COLS)\\n    \\n    def can_water_flow(self, curr_height, new_row, new_col):\\n        return curr_height >= self.heights[new_row][new_col]\\n        \\n    def not_visited(self, row, col):\\n        return self.heights[row][col] != -1\\n    \\n    def update_dp_map(self, ocean, row, col, value):\\n        if ocean == self.PACIFIC:\\n            self.pacific_map[(row,col)] = value\\n        else:\\n            self.atlantic_map[(row,col)] = value                     \\n\\n    def is_cached(self, row, col, ocean):\\n        if ocean == self.PACIFIC:\\n            return (row,col) in self.pacific_map\\n        else:\\n            return (row,col) in self.atlantic_map\\n        \\n    def cached_value(self, row, col, ocean):\\n        if ocean == self.PACIFIC:\\n            return self.pacific_map[(row,col)]\\n        else:\\n            return self.atlantic_map[(row,col)]\\n\\n    def ocean_reachable(self, row, col, ocean):\\n            if self.is_cached(row, col, ocean):\\n                return self.cached_value(row, col, ocean)\\n           \\n            if ocean == self.PACIFIC and self.in_pacific(row, col):\\n                self.update_dp_map(ocean, row, col, True)\\n                return True\\n            if ocean == self.ATLANTIC and self.in_atlantic(row, col):\\n                self.update_dp_map(ocean, row, col, True)\\n                return True\\n            \\n            if not self.in_range(row, col):\\n                self.update_dp_map(ocean, row, col, False)\\n                return False\\n            \\n            curr_height = self.heights[row][col]\\n            self.heights[row][col] = self.VISITED\\n            for drow, dcol in self.DIRECTIONS:\\n                new_row, new_col = row + drow, col + dcol\\n                if ((((self.in_range(new_row, new_col) and \\n                     self.not_visited(new_row, new_col) and \\n                      self.can_water_flow(curr_height, new_row, new_col)) or\\n                      not self.in_range(new_row, new_col)) and\\n                    self.ocean_reachable(new_row, new_col, ocean))):\\n                    self.heights[row][col] = curr_height\\n                    self.update_dp_map(ocean, row, col, True) \\n                    self.update_dp_map(ocean, new_row, new_col, True) \\n                    return True\\n            \\n            self.heights[row][col] = curr_height\\n            self.update_dp_map(ocean, row, col, False)\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581227,
                "title": "clean-python-code-o-mn-dfs",
                "content": "Naive solution is to do DFS from every other point and see if it reaches both the ocean but the trick to optimisation is to start from the oceans itself and go backwards to every point. Visited ones are all the points that are reachable from ocean so in the end, intersection of points `visited by pacific` and `visited by atlantic` will give you the answer.\\n\\nAnother thing to note is that the checks always start from the first and last rows/columns for each iteration. For columns, we iterate over each one and keep the row at 0 and m-1 while for rows we keep the column as 0 and n-1 for pacific and atlantic respectively.\\n\\n```\\nclass Solution:\\n\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        v_pac = set()\\n        v_atl = set()\\n        \\n        def dfs(v_set, row, col, curr_height):\\n            if row < 0 or row >= m or \\\\\\n                col < 0 or col >= n or \\\\\\n                    (row,col) in v_set or \\\\\\n                        curr_height > heights[row][col]:\\n                return\\n            v_set.add((row, col))\\n\\n            curr_height = heights[row][col]\\n            dfs(v_set, row + 1, col, curr_height)\\n            dfs(v_set, row - 1, col, curr_height)\\n            dfs(v_set, row, col + 1, curr_height)\\n            dfs(v_set, row, col - 1, curr_height)\\n\\n        # Approach is to start from both sides of \\n        # the oceans and then reach each point that can be \\n        # reached while maintaining the visited indices\\n\\n        # Iterate over columns and start from both 0, m-1 rows\\n        for col in range(n):\\n            dfs(v_pac, 0, col, heights[0][col]) # First row\\n            dfs(v_atl, m - 1, col, heights[m-1][col]) # Last row\\n\\n        # Iterate over rows and start from both 0, n-1 cols\\n        for row in range(m):\\n            dfs(v_pac, row, 0, heights[row][0]) # First column\\n            dfs(v_atl, row, n-1, heights[row][n-1]) # Last column\\n\\n        # Co-ordinates which can reach both the oceans are the winners\\n        # so we take intersection\\n        result = v_atl.intersection(v_pac)\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        v_pac = set()\\n        v_atl = set()\\n        \\n        def dfs(v_set, row, col, curr_height):\\n            if row < 0 or row >= m or \\\\\\n                col < 0 or col >= n or \\\\\\n                    (row,col) in v_set or \\\\\\n                        curr_height > heights[row][col]:\\n                return\\n            v_set.add((row, col))\\n\\n            curr_height = heights[row][col]\\n            dfs(v_set, row + 1, col, curr_height)\\n            dfs(v_set, row - 1, col, curr_height)\\n            dfs(v_set, row, col + 1, curr_height)\\n            dfs(v_set, row, col - 1, curr_height)\\n\\n        # Approach is to start from both sides of \\n        # the oceans and then reach each point that can be \\n        # reached while maintaining the visited indices\\n\\n        # Iterate over columns and start from both 0, m-1 rows\\n        for col in range(n):\\n            dfs(v_pac, 0, col, heights[0][col]) # First row\\n            dfs(v_atl, m - 1, col, heights[m-1][col]) # Last row\\n\\n        # Iterate over rows and start from both 0, n-1 cols\\n        for row in range(m):\\n            dfs(v_pac, row, 0, heights[row][0]) # First column\\n            dfs(v_atl, row, n-1, heights[row][n-1]) # Last column\\n\\n        # Co-ordinates which can reach both the oceans are the winners\\n        # so we take intersection\\n        result = v_atl.intersection(v_pac)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128519,
                "title": "c-dfs-bfs-solutions",
                "content": "**DFS**\\n```\\npublic class Solution {\\n    public IList<IList<int>> PacificAtlantic(int[][] matrix) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        if(matrix == null || matrix.Length == 0)\\n            return res;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        bool[,] pacific = new bool[m,n];\\n        bool[,] atlantic = new bool[m,n];\\n        \\n        for(int row = 0; row < m; row++)\\n        {\\n            DFS(row, 0, matrix, pacific, matrix[row][0]);\\n            DFS(row, n - 1, matrix, atlantic, matrix[row][n - 1]);\\n        }\\n\\n        for(int col = 0; col < n; col++)\\n        {\\n            DFS(0 , col,matrix, pacific, matrix[0][col]);\\n            DFS(m - 1, col, matrix, atlantic, matrix[m - 1][col]);        \\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(pacific[i,j] && atlantic[i,j])\\n                    res.Add(new List<int>(){i,j});\\n            }\\n        }\\n  \\n        return res;        \\n    }\\n    \\n    private void DFS(int row, int col, int[][] matrix, bool[,] reach, int prev)\\n    {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        \\n        if(row < 0 || row >= m || col < 0 || col >= n || reach[row,col] || matrix[row][col] < prev)\\n            return;\\n        \\n        reach[row,col] = true;\\n        DFS(row, col + 1, matrix, reach, matrix[row][col]);\\n        DFS(row, col - 1, matrix, reach, matrix[row][col]);\\n        DFS(row + 1, col, matrix, reach, matrix[row][col]);\\n        DFS(row - 1, col, matrix, reach, matrix[row][col]);\\n    }\\n}\\n```\\n\\n**BFS**\\n```\\npublic class Solution {\\n    public IList<IList<int>> PacificAtlantic(int[][] matrix) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        if(matrix == null || matrix.Length == 0)\\n            return res;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        Queue<(int,int)> queueP = new Queue<(int,int)>();\\n        Queue<(int,int)> queueA = new Queue<(int,int)>();\\n        bool[,] pacific = new bool[m,n];\\n        bool[,] atlantic = new bool[m,n];\\n        \\n        for(int row = 0; row < m; row++)\\n        {\\n            queueP.Enqueue((row, 0));\\n            pacific[row,0] = true;\\n            \\n            queueA.Enqueue((row, n - 1));   \\n            atlantic[row,n - 1] = true;\\n        }\\n\\n        for(int col = 0; col < n; col++)\\n        {\\n            queueP.Enqueue((0 , col));\\n            pacific[0,col] = true;\\n            \\n            queueA.Enqueue((m - 1, col));\\n            atlantic[m - 1,col] = true;\\n        }\\n\\n         BFS(queueP, matrix, pacific);   \\n         BFS(queueA, matrix, atlantic);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(pacific[i,j] && atlantic[i,j])\\n                    res.Add(new List<int>(){i,j});\\n            }\\n        }\\n  \\n        return res;        \\n    }\\n    \\n    private void BFS(Queue<(int,int)> queue, int[][] matrix, bool[,] reach)\\n    {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] dir = new int[,]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        \\n        while(queue.Count > 0)\\n        {      \\n            var curr = queue.Dequeue();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nextRow = curr.Item1 + dir[i,0];\\n                int nextCol = curr.Item2 + dir[i,1];\\n                \\n                if(nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && !reach[nextRow,nextCol]\\n                  && matrix[curr.Item1][curr.Item2] <= matrix[nextRow][nextCol])\\n                {\\n                    queue.Enqueue((nextRow,nextCol));\\n                    reach[nextRow, nextCol] = true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PacificAtlantic(int[][] matrix) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        if(matrix == null || matrix.Length == 0)\\n            return res;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        bool[,] pacific = new bool[m,n];\\n        bool[,] atlantic = new bool[m,n];\\n        \\n        for(int row = 0; row < m; row++)\\n        {\\n            DFS(row, 0, matrix, pacific, matrix[row][0]);\\n            DFS(row, n - 1, matrix, atlantic, matrix[row][n - 1]);\\n        }\\n\\n        for(int col = 0; col < n; col++)\\n        {\\n            DFS(0 , col,matrix, pacific, matrix[0][col]);\\n            DFS(m - 1, col, matrix, atlantic, matrix[m - 1][col]);        \\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(pacific[i,j] && atlantic[i,j])\\n                    res.Add(new List<int>(){i,j});\\n            }\\n        }\\n  \\n        return res;        \\n    }\\n    \\n    private void DFS(int row, int col, int[][] matrix, bool[,] reach, int prev)\\n    {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        \\n        if(row < 0 || row >= m || col < 0 || col >= n || reach[row,col] || matrix[row][col] < prev)\\n            return;\\n        \\n        reach[row,col] = true;\\n        DFS(row, col + 1, matrix, reach, matrix[row][col]);\\n        DFS(row, col - 1, matrix, reach, matrix[row][col]);\\n        DFS(row + 1, col, matrix, reach, matrix[row][col]);\\n        DFS(row - 1, col, matrix, reach, matrix[row][col]);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<int>> PacificAtlantic(int[][] matrix) {\\n        \\n        List<IList<int>> res = new List<IList<int>>();\\n        if(matrix == null || matrix.Length == 0)\\n            return res;\\n        \\n        int m = matrix.Length, n = matrix[0].Length;\\n        Queue<(int,int)> queueP = new Queue<(int,int)>();\\n        Queue<(int,int)> queueA = new Queue<(int,int)>();\\n        bool[,] pacific = new bool[m,n];\\n        bool[,] atlantic = new bool[m,n];\\n        \\n        for(int row = 0; row < m; row++)\\n        {\\n            queueP.Enqueue((row, 0));\\n            pacific[row,0] = true;\\n            \\n            queueA.Enqueue((row, n - 1));   \\n            atlantic[row,n - 1] = true;\\n        }\\n\\n        for(int col = 0; col < n; col++)\\n        {\\n            queueP.Enqueue((0 , col));\\n            pacific[0,col] = true;\\n            \\n            queueA.Enqueue((m - 1, col));\\n            atlantic[m - 1,col] = true;\\n        }\\n\\n         BFS(queueP, matrix, pacific);   \\n         BFS(queueA, matrix, atlantic);\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(pacific[i,j] && atlantic[i,j])\\n                    res.Add(new List<int>(){i,j});\\n            }\\n        }\\n  \\n        return res;        \\n    }\\n    \\n    private void BFS(Queue<(int,int)> queue, int[][] matrix, bool[,] reach)\\n    {\\n        int m = matrix.Length, n = matrix[0].Length;\\n        int[,] dir = new int[,]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        \\n        while(queue.Count > 0)\\n        {      \\n            var curr = queue.Dequeue();\\n            for(int i = 0; i < 4; i++)\\n            {\\n                int nextRow = curr.Item1 + dir[i,0];\\n                int nextCol = curr.Item2 + dir[i,1];\\n                \\n                if(nextRow >= 0 && nextRow < m && nextCol >= 0 && nextCol < n && !reach[nextRow,nextCol]\\n                  && matrix[curr.Item1][curr.Item2] <= matrix[nextRow][nextCol])\\n                {\\n                    queue.Enqueue((nextRow,nextCol));\\n                    reach[nextRow, nextCol] = true;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447703,
                "title": "c-basic-dfs-bfs-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets solve this question backwards\\n\\nAll the elements at `0th Row` and `0th Col` can Fall into `Pacific`\\nAll the elements at `M-1 th Row` and `N-1 th Col` can Fall into `Atlantic`\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nInstead of Traversing from Highest Level to Lower, Use Lower to Higher\\nmeaning `Heights[row][col] <= Heights[nrow][ncol]`.\\n\\nFind all the elements that can be visited and if the element is visited by Both `Atlantic` and `Pacific` Coast then push it in answer\\n\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\n    vector<int> delRow = {1,0,-1,0};\\n    vector<int> delCol = {0,1,0,-1};\\n    int m,n;\\n     void AtlanticFlow(vector<vector<int>>& heights, int row, int col, vector<vector<bool>>& atlantic){\\n          atlantic[row][col] = true;\\n          for(int i = 0;i<4;i++){\\n            int nrow = delRow[i]+row;\\n             int ncol = delCol[i]+col;\\n             if(nrow >=0 and ncol >=0 and nrow <m and ncol <n and !atlantic[nrow][ncol] and heights[row][col]<=heights[nrow][ncol]){\\n               AtlanticFlow(heights, nrow, ncol,atlantic);\\n             }\\n          }\\n     }\\n       void PacificFlow(vector<vector<int>>& heights, int row, int col, vector<vector<bool>>& pacific){\\n          pacific[row][col] = true;\\n          for(int i = 0;i<4;i++){\\n            int nrow = delRow[i]+row;\\n             int ncol = delCol[i]+col;\\n             if(nrow >=0 and ncol >=0 and nrow <m and ncol <n and !pacific[nrow][ncol] and heights[row][col]<=heights[nrow][ncol]){\\n               PacificFlow(heights, nrow, ncol,pacific);\\n             }\\n          }\\n     }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n         m = heights.size();\\n         n = heights[0].size();\\n        vector<vector<int>> ans;\\n        vector<vector<bool>> pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n,false));\\n \\n        for(int i = 0;i<m;i++){\\n             AtlanticFlow(heights, i, n-1, atlantic);\\n             PacificFlow(heights, i, 0, pacific);\\n        }\\n        for(int j = 0; j<n; j++){\\n            AtlanticFlow(heights, m-1, j, atlantic);\\n             PacificFlow(heights, 0, j, pacific);\\n        }\\n     \\n       for(int i = 0;i<m;i++){\\n           for(int j = 0; j< n ; j++){\\n               if(atlantic[i][j] and pacific[i][j]){\\n                   ans.push_back({i,j});\\n               }\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# BFS\\n```\\nclass Solution {\\npublic:\\n    vector<int> delRow = {1,0,-1,0};\\n    vector<int> delCol = {0,1,0,-1};\\n    int m,n;\\n    \\n    void bfs(vector<vector<int>>& heights, vector<vector<bool>>& visited, queue<pair<int, int>>& q) {\\n        while(!q.empty()) {\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            for(int i=0; i<4; i++) {\\n                int r = curr.first + delRow[i];\\n                int c = curr.second + delCol[i];\\n                if(r>=0 && c>=0 && r<m && c<n && !visited[r][c] && heights[r][c] >= heights[curr.first][curr.second]) {\\n                    visited[r][c] = true;\\n                    q.push(make_pair(r, c));\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        m = heights.size();\\n        n = heights[0].size();\\n        vector<vector<int>> ans;\\n        vector<vector<bool>> pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n,false));\\n        \\n        queue<pair<int, int>> pq;\\n        queue<pair<int, int>> aq;\\n        \\n        // First and Last row\\n        for(int i=0; i<n; i++) {\\n            pq.push(make_pair(0, i));\\n            aq.push(make_pair(m-1, i));\\n        }\\n        // First and Last column\\n        for(int i=0; i<m; i++) {\\n            pq.push(make_pair(i, 0));\\n            aq.push(make_pair(i, n-1));\\n        }\\n        \\n        bfs(heights, pacific, pq);\\n        bfs(heights, atlantic, aq);\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(pacific[i][j] && atlantic[i][j]) {\\n                    ans.push_back({i, j});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> delRow = {1,0,-1,0};\\n    vector<int> delCol = {0,1,0,-1};\\n    int m,n;\\n     void AtlanticFlow(vector<vector<int>>& heights, int row, int col, vector<vector<bool>>& atlantic){\\n          atlantic[row][col] = true;\\n          for(int i = 0;i<4;i++){\\n            int nrow = delRow[i]+row;\\n             int ncol = delCol[i]+col;\\n             if(nrow >=0 and ncol >=0 and nrow <m and ncol <n and !atlantic[nrow][ncol] and heights[row][col]<=heights[nrow][ncol]){\\n               AtlanticFlow(heights, nrow, ncol,atlantic);\\n             }\\n          }\\n     }\\n       void PacificFlow(vector<vector<int>>& heights, int row, int col, vector<vector<bool>>& pacific){\\n          pacific[row][col] = true;\\n          for(int i = 0;i<4;i++){\\n            int nrow = delRow[i]+row;\\n             int ncol = delCol[i]+col;\\n             if(nrow >=0 and ncol >=0 and nrow <m and ncol <n and !pacific[nrow][ncol] and heights[row][col]<=heights[nrow][ncol]){\\n               PacificFlow(heights, nrow, ncol,pacific);\\n             }\\n          }\\n     }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n         m = heights.size();\\n         n = heights[0].size();\\n        vector<vector<int>> ans;\\n        vector<vector<bool>> pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n,false));\\n \\n        for(int i = 0;i<m;i++){\\n             AtlanticFlow(heights, i, n-1, atlantic);\\n             PacificFlow(heights, i, 0, pacific);\\n        }\\n        for(int j = 0; j<n; j++){\\n            AtlanticFlow(heights, m-1, j, atlantic);\\n             PacificFlow(heights, 0, j, pacific);\\n        }\\n     \\n       for(int i = 0;i<m;i++){\\n           for(int j = 0; j< n ; j++){\\n               if(atlantic[i][j] and pacific[i][j]){\\n                   ans.push_back({i,j});\\n               }\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> delRow = {1,0,-1,0};\\n    vector<int> delCol = {0,1,0,-1};\\n    int m,n;\\n    \\n    void bfs(vector<vector<int>>& heights, vector<vector<bool>>& visited, queue<pair<int, int>>& q) {\\n        while(!q.empty()) {\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            for(int i=0; i<4; i++) {\\n                int r = curr.first + delRow[i];\\n                int c = curr.second + delCol[i];\\n                if(r>=0 && c>=0 && r<m && c<n && !visited[r][c] && heights[r][c] >= heights[curr.first][curr.second]) {\\n                    visited[r][c] = true;\\n                    q.push(make_pair(r, c));\\n                }\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        m = heights.size();\\n        n = heights[0].size();\\n        vector<vector<int>> ans;\\n        vector<vector<bool>> pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n,false));\\n        \\n        queue<pair<int, int>> pq;\\n        queue<pair<int, int>> aq;\\n        \\n        // First and Last row\\n        for(int i=0; i<n; i++) {\\n            pq.push(make_pair(0, i));\\n            aq.push(make_pair(m-1, i));\\n        }\\n        // First and Last column\\n        for(int i=0; i<m; i++) {\\n            pq.push(make_pair(i, 0));\\n            aq.push(make_pair(i, n-1));\\n        }\\n        \\n        bfs(heights, pacific, pq);\\n        bfs(heights, atlantic, aq);\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(pacific[i][j] && atlantic[i][j]) {\\n                    ans.push_back({i, j});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509652,
                "title": "c-dfs-using-2d-vector-of-pair-90-faster-code-beginner-friendly-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    void paci(vector<vector<int>>& h,vector<vector<pair<bool,bool>>>& ocean,int n,int m,int i,int j){\\n        ocean[i][j].first=true;\\n        for(int k=0;k<4;k++){\\n            int nx=i+dx[k];int ny=j+dy[k];\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && !ocean[nx][ny].first && h[nx][ny]>=h[i][j]){\\n                paci(h,ocean,n,m,nx,ny);\\n            }\\n        }\\n    }\\n    void atla(vector<vector<int>>& h,vector<vector<pair<bool,bool>>>& ocean,int n,int m,int i,int j){\\n        ocean[i][j].second=true;\\n        for(int k=0;k<4;k++){\\n            int nx=i+dx[k];int ny=j+dy[k];\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && !ocean[nx][ny].second && h[nx][ny]>=h[i][j]){\\n                atla(h,ocean,n,m,nx,ny);\\n            }\\n        }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& h) {\\n        int n=h.size();int m=h[0].size();\\n        //ocean.first for pacific \\n        //ocean.second for atlantic\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>>(m,{false,false}));\\n        for(int i=0;i<n;i++){\\n            paci(h,ocean,n,m,i,0);\\n            atla(h,ocean,n,m,i,m-1);\\n        }\\n        for(int i=0;i<m;i++){\\n            paci(h,ocean,n,m,0,i);\\n            atla(h,ocean,n,m,n-1,i);\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    void paci(vector<vector<int>>& h,vector<vector<pair<bool,bool>>>& ocean,int n,int m,int i,int j){\\n        ocean[i][j].first=true;\\n        for(int k=0;k<4;k++){\\n            int nx=i+dx[k];int ny=j+dy[k];\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && !ocean[nx][ny].first && h[nx][ny]>=h[i][j]){\\n                paci(h,ocean,n,m,nx,ny);\\n            }\\n        }\\n    }\\n    void atla(vector<vector<int>>& h,vector<vector<pair<bool,bool>>>& ocean,int n,int m,int i,int j){\\n        ocean[i][j].second=true;\\n        for(int k=0;k<4;k++){\\n            int nx=i+dx[k];int ny=j+dy[k];\\n            if(nx>=0 && nx<n && ny>=0 && ny<m && !ocean[nx][ny].second && h[nx][ny]>=h[i][j]){\\n                atla(h,ocean,n,m,nx,ny);\\n            }\\n        }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& h) {\\n        int n=h.size();int m=h[0].size();\\n        //ocean.first for pacific \\n        //ocean.second for atlantic\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>>(m,{false,false}));\\n        for(int i=0;i<n;i++){\\n            paci(h,ocean,n,m,i,0);\\n            atla(h,ocean,n,m,i,m-1);\\n        }\\n        for(int i=0;i<m;i++){\\n            paci(h,ocean,n,m,0,i);\\n            atla(h,ocean,n,m,n-1,i);\\n        }\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450501,
                "title": "easy-dfs-solution-with-self-explainatory-variable-names",
                "content": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(heights), len(heights[0])\\n        pacificSet, atlanticSet = set(), set()\\n        \\n        def dfs(row, col, visited, prevHeight):\\n            if (row not in range(ROWS) or\\n                col not in range(COLS) or\\n                (row, col) in visited or\\n                heights[row][col] < prevHeight\\n               ):\\n                return\\n            \\n            visited.add((row, col))\\n            dfs(row + 1, col, visited, heights[row][col])\\n            dfs(row - 1, col, visited, heights[row][col])\\n            dfs(row, col + 1, visited, heights[row][col])\\n            dfs(row, col - 1, visited, heights[row][col])        \\n        \\n        for row in range(ROWS):\\n            dfs(row, 0, pacificSet, heights[row][0])\\n            dfs(row, COLS - 1, atlanticSet, heights[row][COLS - 1])\\n            \\n        for col in range(COLS):\\n            dfs(0, col, pacificSet, heights[0][col])\\n            dfs(ROWS - 1, col, atlanticSet, heights[ROWS - 1][col])\\n        \\n        return pacificSet & atlanticSet\\n    # Time: O(m * n) where m and n are the dimensions of the grid\\n    # Space: O(m * n)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(heights), len(heights[0])\\n        pacificSet, atlanticSet = set(), set()\\n        \\n        def dfs(row, col, visited, prevHeight):\\n            if (row not in range(ROWS) or\\n                col not in range(COLS) or\\n                (row, col) in visited or\\n                heights[row][col] < prevHeight\\n               ):\\n                return\\n            \\n            visited.add((row, col))\\n            dfs(row + 1, col, visited, heights[row][col])\\n            dfs(row - 1, col, visited, heights[row][col])\\n            dfs(row, col + 1, visited, heights[row][col])\\n            dfs(row, col - 1, visited, heights[row][col])        \\n        \\n        for row in range(ROWS):\\n            dfs(row, 0, pacificSet, heights[row][0])\\n            dfs(row, COLS - 1, atlanticSet, heights[row][COLS - 1])\\n            \\n        for col in range(COLS):\\n            dfs(0, col, pacificSet, heights[0][col])\\n            dfs(ROWS - 1, col, atlanticSet, heights[ROWS - 1][col])\\n        \\n        return pacificSet & atlanticSet\\n    # Time: O(m * n) where m and n are the dimensions of the grid\\n    # Space: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132354,
                "title": "runtime-64-ms-faster-than-99-78-of-c-online-submissions-for-pacific-atlantic-water-flow",
                "content": "**STEP 1**- if we start from the cells connected to altantic ocean and visit all cells having height greater than current cell (**water can only flow from a cell to another one with height equal or lower**), we are able to reach some subset of cells (let\\'s call them A).\\n \\n ![image](https://assets.leetcode.com/users/images/923e6cc7-ab34-41e0-8126-38f828f11b38_1654803119.413273.png)\\n \\n**STEP-2**\\n Next, we start from the cells connected to pacific ocean and repeat the same process, we find another subset (let\\'s call this one B).\\n \\n![image](https://assets.leetcode.com/users/images/28272544-fe83-43a5-bf1b-fb7e7ceff7d4_1654803241.1074493.png)\\n\\n**The final answer we get will be the intersection of sets A and B (A \\u2229 B).**\\n\\n![image](https://assets.leetcode.com/users/images/79807c93-0015-4b10-b162-169d901e7444_1654803270.5645876.png)\\n\\n```\\nclass Solution\\n{\\n\\n\\tvoid bfs(vector<vector<int>> &h, queue<pair<int, int>> q, int n, int m, vector<vector<int>> &visi)\\n\\t{\\n\\t\\tint ar1[] = {0, 0, 1, -1};\\n\\t\\tint ar2[] = {1, -1, 0, 0};\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tint x = q.front().first;\\n\\t\\t\\tint y = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int i = 0; i < 4; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint xn = x + ar1[i];\\n\\t\\t\\t\\tint yn = y + ar2[i];\\n\\t\\t\\t\\tif (xn < 0 || yn < 0 || xn >= n || yn >= m || visi[xn][yn] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (h[x][y] <= h[xn][yn])\\n\\t\\t\\t\\t\\tq.push({xn, yn}), visi[xn][yn] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n\\tvector<vector<int>> pacificAtlantic(vector<vector<int>> &heights)\\n\\t{\\n        int n = heights.size();\\n\\t\\tint m = heights[0].size();\\n\\t\\tvector<vector<int>> visi1(n, vector<int>(m, 0)); // for Pacific Ocean\\n\\t\\tvector<vector<int>> visi2(n, vector<int>(m, 0)); // for Atlantic Ocean\\n\\n\\t\\tqueue<pair<int, int>> q;\\n\\t\\t// STEP-1\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tq.push({0, i}), visi1[0][i] = 1;\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\tq.push({j, 0}), visi1[j][0] = 1;\\n\\n\\t\\tbfs(heights, q, n, m, visi1); // for pacific ocean which are greator and equal to value\\n\\n\\t\\t// to empty the queue for atlantic Ocean\\n\\t\\twhile (!q.empty())\\n\\t\\t\\tq.pop();\\n\\t\\t// STEP-2\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tq.push({n - 1, i}), visi2[n - 1][i] = 1;\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\tq.push({j, m - 1}), visi2[j][m - 1] = 1;\\n\\n\\t\\tbfs(heights, q, n, m, visi2); // for Atalantic ocean which are greator and equal to value\\n\\t    // STEP-3\\n\\t\\tvector<vector<int>> ans;\\t  // to check the common in both visi1 and visi2 vector;\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\tif (visi1[i][j] == visi2[i][j] and visi1[i][j] == 1)\\n\\t\\t\\t\\t\\tans.push_back({i, j});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n\\tvoid bfs(vector<vector<int>> &h, queue<pair<int, int>> q, int n, int m, vector<vector<int>> &visi)\\n\\t{\\n\\t\\tint ar1[] = {0, 0, 1, -1};\\n\\t\\tint ar2[] = {1, -1, 0, 0};\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tint x = q.front().first;\\n\\t\\t\\tint y = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor (int i = 0; i < 4; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint xn = x + ar1[i];\\n\\t\\t\\t\\tint yn = y + ar2[i];\\n\\t\\t\\t\\tif (xn < 0 || yn < 0 || xn >= n || yn >= m || visi[xn][yn] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (h[x][y] <= h[xn][yn])\\n\\t\\t\\t\\t\\tq.push({xn, yn}), visi[xn][yn] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\npublic:\\n\\tvector<vector<int>> pacificAtlantic(vector<vector<int>> &heights)\\n\\t{\\n        int n = heights.size();\\n\\t\\tint m = heights[0].size();\\n\\t\\tvector<vector<int>> visi1(n, vector<int>(m, 0)); // for Pacific Ocean\\n\\t\\tvector<vector<int>> visi2(n, vector<int>(m, 0)); // for Atlantic Ocean\\n\\n\\t\\tqueue<pair<int, int>> q;\\n\\t\\t// STEP-1\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tq.push({0, i}), visi1[0][i] = 1;\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\tq.push({j, 0}), visi1[j][0] = 1;\\n\\n\\t\\tbfs(heights, q, n, m, visi1); // for pacific ocean which are greator and equal to value\\n\\n\\t\\t// to empty the queue for atlantic Ocean\\n\\t\\twhile (!q.empty())\\n\\t\\t\\tq.pop();\\n\\t\\t// STEP-2\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tq.push({n - 1, i}), visi2[n - 1][i] = 1;\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\tq.push({j, m - 1}), visi2[j][m - 1] = 1;\\n\\n\\t\\tbfs(heights, q, n, m, visi2); // for Atalantic ocean which are greator and equal to value\\n\\t    // STEP-3\\n\\t\\tvector<vector<int>> ans;\\t  // to check the common in both visi1 and visi2 vector;\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\tif (visi1[i][j] == visi2[i][j] and visi1[i][j] == 1)\\n\\t\\t\\t\\t\\tans.push_back({i, j});\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958268,
                "title": "c-dfs-easiest-explanation-simple-explanation",
                "content": "**Tried my level best to explain\\nIncase you liked the solution you can upvote it.**\\n<iframe src=\"https://leetcode.com/playground/96uMhG4u/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "**Tried my level best to explain\\nIncase you liked the solution you can upvote it.**\\n<iframe src=\"https://leetcode.com/playground/96uMhG4u/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1813891,
                "title": "pacific-atlantic",
                "content": "i thought it can  work with travel in pacific with [i,j + 1] and [i + 1,0]  & in atlantic  with [ i ,j-1] and [i-1,0].but i was wrong\\n\\t\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n\\n\\t\\tbool isSafe(int r,int c,int n,int m){\\n\\t\\t\\tif( r < 0 or c < 0 or r>=n or c>=m){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid dfs(vector<vector<int>>&grid,int r,int c,vector<vector<bool>> &visited)         {\\n\\n\\t\\t\\tint curr = grid[r][c];\\n\\t\\t\\tvisited[r][c] = 1;\\n\\t\\t\\tfor(int i = 0; i<dir.size();i++){\\n\\t\\t\\t\\tint r1 = r + dir[i][0];\\n\\t\\t\\t\\tint c1 = c + dir[i][1];\\n\\n\\n\\t\\t\\t\\tif(isSafe(r1,c1,grid.size(),grid[0].size()) and visited[r1][c1]==false and grid[r1][c1] >= curr){\\n\\t\\t\\t\\t\\tdfs(grid,r1,c1,visited);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n\\n\\n\\t\\t\\tint n = heights.size();\\n\\t\\t\\tint m = heights[0].size();\\n\\t\\t\\tvector<vector<bool>> pacific(n,vector<bool>(m,0));\\n\\t\\t\\tvector<vector<bool>> atlantic(n,vector<bool>(m,0));\\n\\n\\t\\t\\tfor(int i = 0; i<m;i++){\\n\\t\\t\\t\\tif(pacific[0][i]==false){\\n\\t\\t\\t\\t\\tdfs(heights,0,i,pacific);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i<n;i++){\\n\\t\\t\\t\\tif(pacific[i][0]==false){\\n\\t\\t\\t\\t\\tdfs(heights,i,0,pacific);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0; i<m;i++){\\n\\t\\t\\t\\tif(atlantic[n-1][i]==false){\\n\\t\\t\\t\\t\\tdfs(heights,n-1,i,atlantic);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i= 0; i<n;i++){\\n\\t\\t\\t\\tif(atlantic[i][m-1]==false){\\n\\t\\t\\t\\t\\tdfs(heights,i,m-1,atlantic);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<int>> ans;\\n\\n\\t\\t\\tfor(int i = 0; i<n;i++){\\n\\t\\t\\t\\tfor(int j = 0;j<m;j++){\\n\\t\\t\\t\\t\\tcout<<atlantic[i][j]<<\" \"<<pacific[i][j]<<\" ,\";\\n\\t\\t\\t\\t\\tif(atlantic[i][j] and pacific[i][j]){\\n\\t\\t\\t\\t\\t\\tans.push_back({i,j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcout<<endl;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> dir = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1676670,
                "title": "sharing-my-dfs-bfs-solution",
                "content": "Problems that are related to `Graph`, we usually utilize some classical graph traversal algorithms to work on.\\nHere I\\'m talking about Depth First Search `dfs` and Breadth First Search `bfs`\\n\\nWe\\'ll use 2 below options to solve this problem\\n1. Recursive dfs, be careful if we have very deep graphs.\\n1. Interative bfs, We use Queue\\n\\n**Idea**\\nWe need 2 2D boolean arrays. One is to store capability of any cell `(ri, ci)` that from that cell whether water can flow to the pacific ocean, the other is to store capability of any cell `(ri, ci)` that from that cell whether water can flow to the atlantic ocean\\n\\nSo water can flow from cell `(ri, ci) ` to both the Pacific and Atlantic oceans, if and only if value of  cell `(ri, ci) ` in  2 boolean arrays both are `true`\\n\\n**BFS**\\n```\\nclass Solution {\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int m = heights.length, n = heights[0].length;\\n        \\n        boolean[][] pacific = new boolean[m][n];\\n        boolean[][] atlantic = new boolean[m][n];\\n        \\n        Queue<int[]> pQueue = new LinkedList<>();\\n        Queue<int[]> aQueue = new LinkedList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            pQueue.offer(new int[]{i, 0});\\n            pacific[i][0] = true;\\n            aQueue.offer(new int[]{i, n-1});\\n            atlantic[i][n-1] = true;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            pQueue.offer(new int[]{0, i});\\n            pacific[0][i] = true;\\n            aQueue.offer(new int[]{m-1, i});\\n            atlantic[m-1][i] = true;\\n        }\\n        bfs(heights, pQueue, pacific);\\n        bfs(heights, aQueue, atlantic);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] && atlantic[i][j]) {\\n                    res.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void bfs(int[][] heights, Queue<int[]> queue, boolean[][] visited) {\\n        int m = heights.length, n = heights[0].length;\\n        while (!queue.isEmpty()) {\\n            int[] pos = queue.poll();\\n            for (int[] dir : dirs) {\\n                int x = pos[0] + dir[0];\\n                int y = pos[1] + dir[1];\\n                if (x < 0 || x >= m || y < 0 || y >= n || \\n                    visited[x][y] || heights[x][y] < heights[pos[0]][pos[1]]) {\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y});\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**DFS**\\n```\\nclass Solution {\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int m = heights.length, n = heights[0].length;\\n        \\n        boolean[][] pacific = new boolean[m][n];\\n        boolean[][] atlantic = new boolean[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dfs(heights, pacific, Integer.MIN_VALUE, i, 0);\\n            dfs(heights, atlantic, Integer.MIN_VALUE, i, n-1);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            dfs(heights, pacific, Integer.MIN_VALUE, 0, i);\\n            dfs(heights, atlantic, Integer.MIN_VALUE, m-1, i);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] && atlantic[i][j]) {\\n                    res.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int[][] heights, boolean[][] visited, int height, int x, int y) {\\n        int m = heights.length, n = heights[0].length;\\n        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || height > heights[x][y]) {\\n            return;\\n        }\\n        visited[x][y] = true;\\n        dfs(heights, visited, heights[x][y], x+1, y);\\n        dfs(heights, visited, heights[x][y], x-1, y);\\n        dfs(heights, visited, heights[x][y], x, y+1);\\n        dfs(heights, visited, heights[x][y], x, y-1);\\n    }\\n}\\n```\\n\\nTime Complexity: O(4mn)=O(mn) since a cell can be visited at most 4 times.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int m = heights.length, n = heights[0].length;\\n        \\n        boolean[][] pacific = new boolean[m][n];\\n        boolean[][] atlantic = new boolean[m][n];\\n        \\n        Queue<int[]> pQueue = new LinkedList<>();\\n        Queue<int[]> aQueue = new LinkedList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            pQueue.offer(new int[]{i, 0});\\n            pacific[i][0] = true;\\n            aQueue.offer(new int[]{i, n-1});\\n            atlantic[i][n-1] = true;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            pQueue.offer(new int[]{0, i});\\n            pacific[0][i] = true;\\n            aQueue.offer(new int[]{m-1, i});\\n            atlantic[m-1][i] = true;\\n        }\\n        bfs(heights, pQueue, pacific);\\n        bfs(heights, aQueue, atlantic);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] && atlantic[i][j]) {\\n                    res.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void bfs(int[][] heights, Queue<int[]> queue, boolean[][] visited) {\\n        int m = heights.length, n = heights[0].length;\\n        while (!queue.isEmpty()) {\\n            int[] pos = queue.poll();\\n            for (int[] dir : dirs) {\\n                int x = pos[0] + dir[0];\\n                int y = pos[1] + dir[1];\\n                if (x < 0 || x >= m || y < 0 || y >= n || \\n                    visited[x][y] || heights[x][y] < heights[pos[0]][pos[1]]) {\\n                    continue;\\n                }\\n                visited[x][y] = true;\\n                queue.offer(new int[]{x, y});\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int m = heights.length, n = heights[0].length;\\n        \\n        boolean[][] pacific = new boolean[m][n];\\n        boolean[][] atlantic = new boolean[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            dfs(heights, pacific, Integer.MIN_VALUE, i, 0);\\n            dfs(heights, atlantic, Integer.MIN_VALUE, i, n-1);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            dfs(heights, pacific, Integer.MIN_VALUE, 0, i);\\n            dfs(heights, atlantic, Integer.MIN_VALUE, m-1, i);\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] && atlantic[i][j]) {\\n                    res.add(Arrays.asList(i, j));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void dfs(int[][] heights, boolean[][] visited, int height, int x, int y) {\\n        int m = heights.length, n = heights[0].length;\\n        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || height > heights[x][y]) {\\n            return;\\n        }\\n        visited[x][y] = true;\\n        dfs(heights, visited, heights[x][y], x+1, y);\\n        dfs(heights, visited, heights[x][y], x-1, y);\\n        dfs(heights, visited, heights[x][y], x, y+1);\\n        dfs(heights, visited, heights[x][y], x, y-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643294,
                "title": "javascript-idiomatic-bfs-and-dfs",
                "content": "**Recursive DFS**\\n```\\nconst pacificAtlantic = (heights) => {\\n    const m = heights.length, n = heights[0].length  \\n    const atlantic = new Array(m).fill().map(() => new Array(n).fill(false))\\n    const pacific = new Array(m).fill().map(() => new Array(n).fill(false))\\n    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    const dfs = (x, y, visited) => {\\n        visited[x][y] = true\\n        for (let dir of directions) {\\n            let nx = x + dir[0]\\n            let ny = y + dir[1]\\n            if (nx < 0 || ny < 0 || nx >= m || ny >= n || visited[nx][ny]) continue\\n            if (heights[nx][ny] >= heights[x][y]) {\\n                dfs(nx, ny, visited)\\n            }\\n        }\\n    }\\n    \\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (x === 0 || y === 0) {\\n                dfs(x, y, pacific)\\n            }\\n            if (x === m - 1 || y === n - 1) {\\n                dfs(x, y, atlantic)\\n            }\\n        }\\n    }\\n    const paths = []\\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (pacific[x][y] && atlantic[x][y]) {\\n                paths.push([x, y])\\n            }\\n        }\\n    }\\n    return paths\\n}\\n```\\n\\n**BFS**\\n\\n```\\nconst pacificAtlantic = (heights) => {\\n    const m = heights.length, n = heights[0].length  \\n    const atlanticQueue = []\\n    const pacificQueue = []\\n    \\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (x === m - 1 || y === n - 1) {\\n                atlanticQueue.push([x, y])\\n            }\\n            if (x === 0 || y === 0) {\\n                pacificQueue.push([x, y])\\n            }\\n        }\\n    } \\n    const bfs = (queue) => {\\n        const isValid = (x, y) => x >= 0 && y >= 0 && x < m && y < n\\n        const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        const visited = new Array(m).fill().map(() => new Array(n).fill(false))\\n        while (queue.length) {\\n            const [x, y] = queue.shift()\\n            visited[x][y] = true\\n            for (let dir of directions) {\\n                let nx = x + dir[0]\\n                let ny = y + dir[1]\\n                if (!isValid(nx, ny) || visited[nx][ny]) continue\\n                if (heights[nx][ny] >= heights[x][y]) {\\n                    queue.push([nx, ny])\\n                }\\n            }\\n        }\\n        return visited\\n    }\\n    const pacific = bfs(atlanticQueue)\\n    const atlantic = bfs(pacificQueue)\\n    const paths = []\\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (pacific[x][y] && atlantic[x][y]) {\\n                paths.push([x, y])\\n            }\\n        }\\n    }\\n    return paths\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst pacificAtlantic = (heights) => {\\n    const m = heights.length, n = heights[0].length  \\n    const atlantic = new Array(m).fill().map(() => new Array(n).fill(false))\\n    const pacific = new Array(m).fill().map(() => new Array(n).fill(false))\\n    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    const dfs = (x, y, visited) => {\\n        visited[x][y] = true\\n        for (let dir of directions) {\\n            let nx = x + dir[0]\\n            let ny = y + dir[1]\\n            if (nx < 0 || ny < 0 || nx >= m || ny >= n || visited[nx][ny]) continue\\n            if (heights[nx][ny] >= heights[x][y]) {\\n                dfs(nx, ny, visited)\\n            }\\n        }\\n    }\\n    \\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (x === 0 || y === 0) {\\n                dfs(x, y, pacific)\\n            }\\n            if (x === m - 1 || y === n - 1) {\\n                dfs(x, y, atlantic)\\n            }\\n        }\\n    }\\n    const paths = []\\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (pacific[x][y] && atlantic[x][y]) {\\n                paths.push([x, y])\\n            }\\n        }\\n    }\\n    return paths\\n}\\n```\n```\\nconst pacificAtlantic = (heights) => {\\n    const m = heights.length, n = heights[0].length  \\n    const atlanticQueue = []\\n    const pacificQueue = []\\n    \\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (x === m - 1 || y === n - 1) {\\n                atlanticQueue.push([x, y])\\n            }\\n            if (x === 0 || y === 0) {\\n                pacificQueue.push([x, y])\\n            }\\n        }\\n    } \\n    const bfs = (queue) => {\\n        const isValid = (x, y) => x >= 0 && y >= 0 && x < m && y < n\\n        const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        const visited = new Array(m).fill().map(() => new Array(n).fill(false))\\n        while (queue.length) {\\n            const [x, y] = queue.shift()\\n            visited[x][y] = true\\n            for (let dir of directions) {\\n                let nx = x + dir[0]\\n                let ny = y + dir[1]\\n                if (!isValid(nx, ny) || visited[nx][ny]) continue\\n                if (heights[nx][ny] >= heights[x][y]) {\\n                    queue.push([nx, ny])\\n                }\\n            }\\n        }\\n        return visited\\n    }\\n    const pacific = bfs(atlanticQueue)\\n    const atlantic = bfs(pacificQueue)\\n    const paths = []\\n    for (let x = 0; x < m; x++) {\\n        for (let y = 0; y < n; y++) {\\n            if (pacific[x][y] && atlantic[x][y]) {\\n                paths.push([x, y])\\n            }\\n        }\\n    }\\n    return paths\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1515172,
                "title": "javascript-96-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/911f9a98-02ff-4409-a8ee-4d765dd85788_1633908034.6486025.png)\\n\\nDoing the Blind 75 List and posting all solutions.\\n\\n```\\nvar pacificAtlantic = function(heights) {\\n  const oceanMap = Array(heights.length).fill().map(_ => Array(heights[0].length).fill(0))\\n  const pTrack = new Set(), aTrack = new Set();\\n  const res = [];\\n  \\n  for (let i = 0; i < heights[0].length; i++) {\\n    traverse(0, i, pTrack)\\n    traverse(heights.length - 1, i, aTrack)\\n  }\\n  \\n  for (let i = 1; i < heights.length; i++) {\\n    traverse(i, 0, pTrack)\\n    traverse(heights.length - 1 - i, heights[i].length - 1, aTrack)\\n  }\\n    \\n  return res\\n  \\n  function traverse(row, col, ocean) {\\n    if (ocean.has(`${row}-${col}`)) return;\\n    ocean.add(`${row}-${col}`);\\n    oceanMap[row][col]++;\\n    if (oceanMap[row][col] === 2) res.push([row, col]);\\n    (row > 0 && heights[row][col] <= heights[row - 1][col]) && traverse(row - 1, col, ocean);\\n    (row < heights.length - 1 && heights[row][col] <= heights[row + 1][col]) && traverse(row + 1, col, ocean);\\n    (col > 0 && heights[row][col] <= heights[row][col - 1]) && traverse(row, col - 1, ocean);\\n    (col < heights[row].length - 1 && heights[row][col] <= heights[row][col + 1]) && traverse(row, col + 1, ocean)\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pacificAtlantic = function(heights) {\\n  const oceanMap = Array(heights.length).fill().map(_ => Array(heights[0].length).fill(0))\\n  const pTrack = new Set(), aTrack = new Set();\\n  const res = [];\\n  \\n  for (let i = 0; i < heights[0].length; i++) {\\n    traverse(0, i, pTrack)\\n    traverse(heights.length - 1, i, aTrack)\\n  }\\n  \\n  for (let i = 1; i < heights.length; i++) {\\n    traverse(i, 0, pTrack)\\n    traverse(heights.length - 1 - i, heights[i].length - 1, aTrack)\\n  }\\n    \\n  return res\\n  \\n  function traverse(row, col, ocean) {\\n    if (ocean.has(`${row}-${col}`)) return;\\n    ocean.add(`${row}-${col}`);\\n    oceanMap[row][col]++;\\n    if (oceanMap[row][col] === 2) res.push([row, col]);\\n    (row > 0 && heights[row][col] <= heights[row - 1][col]) && traverse(row - 1, col, ocean);\\n    (row < heights.length - 1 && heights[row][col] <= heights[row + 1][col]) && traverse(row + 1, col, ocean);\\n    (col > 0 && heights[row][col] <= heights[row][col - 1]) && traverse(row, col - 1, ocean);\\n    (col < heights[row].length - 1 && heights[row][col] <= heights[row][col + 1]) && traverse(row, col + 1, ocean)\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1515009,
                "title": "help-me-understand-this-input-1-2-3-8-9-4-7-6-5",
                "content": "The expected output is [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nI don\\'t get why [2, 1] is includes\\n\\n```\\n  Pacific ~   ~   ~\\n       ~  1   2   3  *\\n       ~  8   9   4  *\\n       ~  7   6   5  *\\n          *   *   *  Atlantic\\n\\n```\\n\\nI get that [2, 1] can flows into Atlantic by traveling left, but it\\'s blocked by 7 on the left, and 9 on top, how does it flows to Pacific?\\n\\nI get it now, 6 -> 5 -> 4 -> 3 -> Pacific. Somehow I thought it needs to be travering the same direction, which doesn\\'t make sense at all.",
                "solutionTags": [],
                "code": "```\\n  Pacific ~   ~   ~\\n       ~  1   2   3  *\\n       ~  8   9   4  *\\n       ~  7   6   5  *\\n          *   *   *  Atlantic\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307042,
                "title": "python-3-approaches-brute-force-flood-fill-with-explanations",
                "content": "----------------------------------\\nApproach 1: Brute-force\\nTLE : 111 / 113 test cases passed.\\n----------------------------------\\n----------------------------------\\n\\n**Idea:**\\n\\n- For each cell:\\n\\t- see if I can reach pacific \\n\\t- see if I can reach atlantic\\n\\t- if the answer is True for both -> add to result\\n\\n\\n- Time: \\n\\t- main function : `O(m*n) `\\n\\t- helper : `O(E+V) `\\n\\t- Overall => `O(E^2 + V)` => `O((M*N)^2)`\\n\\t- Iterating over cells and trigger 2 bfs searchs on each cell. We could do better!\\n\\n\\n```\\ndef pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n    \\n        # bfs helper 1:\\n        def reachPacific(x,y): # - O(E+V)\\n            if x == 0 or y == 0:\\n                return True\\n            \\n            from collections import deque\\n            q = deque()\\n            q.append((x,y))\\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    if x == 0 or y == 0:\\n                        return True # found my way to \\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs: # must only add nei that have less height - so that water falls to them\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:   \\n                            if (newX, newY) not in visited:\\n                                if grid[newX][newY] <= grid[x][y]: # water can flow\\n                                    q.append((newX, newY))\\n            return False \\n        \\n\\t\\t# bfs helper 2:\\n        def reachAtlantic(x,y): # - O(E+V)\\n            grid = heights\\n            \\n            if x == len(grid)-1 or y == len(grid[0])-1:\\n                return True\\n            \\n            from collections import deque\\n            q = deque()\\n            q.append((x,y))\\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    if x == len(grid)-1 or y == len(grid[0])-1:\\n                        return True # found my way to \\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs: # must only add nei that have less height - so that water falls to them\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:   \\n                            if (newX, newY) not in visited:\\n                                if grid[newX][newY] <= grid[x][y]: # water can flow\\n                                    q.append((newX, newY))\\n            return False \\n        \\n        # main:\\n        grid = heights\\n        res = []\\n        for r in range(len(grid)): # - O(V) or O(M*N)\\n            for c in range(len(grid[0])):\\n                if reachPacific(r,c) and reachAtlantic(r,c):\\n                    res.append([r,c])\\n        return res\\n\\n```    \\n\\n----------------------------------------------\\nApproach 2: Enhanced BFS (aka Flood-fill style BFS)\\n----------------------------------\\n----------------------------------\\n\\n**Idea:**\\n1- flood-fill-style, simaltanous BFS from all pacific ocean cells\\n2- flood-fill-style, simaltanous BFS from all atlantic ocean cells\\n\\n- start with 2 qeue : one for each ocean/cost\\n- In order for a cell to flush its share of rain into the ocean, the cell has to have a higher altitude.\\n- Hence, if a cell is higher than ocean cell -> include in ocean cell\\nperform intersect between atlantic cells and pacific cells\\n\\n- Time: \\n\\t-  `O(M*N)`\\n\\n```        \\n\\ndef pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        \\n\\tgrid = heights\\n    \\n        # helper 1:\\n        def findPacificCells(grid):\\n            from collections import deque\\n            q = deque()\\n            visited = set()\\n            \\n            # num_rows, num_cols\\n            numRows, numCols = len(grid), len(grid[0])\\n        \\n            # add all pacific cells\\n            for i in range(numCols): # top row\\n                q.append((0,i))\\n                visited.add((0,i))\\n            \\n            for i in range(numRows): # left most col\\n                q.append((i,0))\\n                visited.add((i,0))\\n            \\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs:\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:\\n                            if grid[newX][newY] >= grid[x][y]: # -- note [1]\\n                                if (newX, newY) not in visited:\\n                                    q.append((newX, newY))\\n                    \\n            # note [1]\\n            # if new cell is higher -> means rain can flow from it to pacific -> hence include new cell in pacific\\n            return visited\\n            \\n        # helper 2\\n        def findAtlanticCells(grid):\\n            \\n            from collections import deque\\n            q = deque()\\n            visited = set()\\n            \\n            # num_rows, num_cols\\n            numRows, numCols = len(grid), len(grid[0])\\n            \\n            # add all atlantic cells\\n            for i in range(numCols): # bottom row\\n                q.append((numRows-1,i))\\n                visited.add((numRows-1,i))\\n            \\n            for i in range(len(grid)): # right most col\\n                q.append((i,numCols-1))\\n                visited.add((i,numCols-1))\\n            \\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs:\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:\\n                            if grid[newX][newY] >= grid[x][y]: # -- note [1]\\n                                if (newX, newY) not in visited:\\n                                    q.append((newX, newY))\\n                    \\n            # note [1]\\n            # if new cell is higher -> means rain can flow from it to pacific -> hence include new cell in pacific\\n            return visited\\n            \\n        # main:\\n        pacific = findPacificCells(grid)\\n        atlantic = findAtlanticCells(grid)\\n        mutual = pacific.intersection(atlantic)\\n        \\n        return list(mutual)\\n```    \\n    \\n--------------------------------------------\\nApproach 3 : Enhanced Flood-fill BFS\\n--------------------------------------------\\n--------------------------------------------\\n- Instead of having 2 seperate functions: `findPacificCells` and `findAtlanticCells`\\n- Use one bfs helper function on 2 different queues\\n- Time: \\n\\t-  `O(M*N)`\\n        \\n```        \\n def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n \\n        # bfs helper\\n        def bfs(q):\\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    visited.add((x,y))\\n                    \\n                    # expand to nei cell if nei cell is higher in atltitude\\n                    for dir in dirs:\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:\\n                            if (newX, newY) not in visited:\\n                                if grid[newX][newY] >= grid[x][y]: # water can flow from nei to x,y to ocean\\n                                    q.append((newX, newY))\\n            return visited\\n                    \\n        \\n        # main\\n        # initial queues - one for each cost/ocean\\n        from collections import deque\\n        qp = deque()\\n        qa = deque()\\n        \\n        grid = heights\\n        \\n        # num_rows, num_cols\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        # 1) pacific:\\n        for i in range(numCols): # top row\\n            qp.append((0,i))\\n        \\n        for i in range(numRows): # left most col\\n            qp.append((i,0))\\n        \\n        # 2) atlantic\\n        for i in range(numRows): # right most col\\n            qa.append((i,numCols-1))\\n            \\n        for i in range(numCols): # bottom row\\n            qa.append((numRows-1, i))\\n        \\n        pacific = bfs(qp)\\n        atlantic = bfs(qa)\\n        mutual = pacific.intersection(atlantic)\\n        return mutual\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n    \\n        # bfs helper 1:\\n        def reachPacific(x,y): # - O(E+V)\\n            if x == 0 or y == 0:\\n                return True\\n            \\n            from collections import deque\\n            q = deque()\\n            q.append((x,y))\\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    if x == 0 or y == 0:\\n                        return True # found my way to \\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs: # must only add nei that have less height - so that water falls to them\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:   \\n                            if (newX, newY) not in visited:\\n                                if grid[newX][newY] <= grid[x][y]: # water can flow\\n                                    q.append((newX, newY))\\n            return False \\n        \\n\\t\\t# bfs helper 2:\\n        def reachAtlantic(x,y): # - O(E+V)\\n            grid = heights\\n            \\n            if x == len(grid)-1 or y == len(grid[0])-1:\\n                return True\\n            \\n            from collections import deque\\n            q = deque()\\n            q.append((x,y))\\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    if x == len(grid)-1 or y == len(grid[0])-1:\\n                        return True # found my way to \\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs: # must only add nei that have less height - so that water falls to them\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:   \\n                            if (newX, newY) not in visited:\\n                                if grid[newX][newY] <= grid[x][y]: # water can flow\\n                                    q.append((newX, newY))\\n            return False \\n        \\n        # main:\\n        grid = heights\\n        res = []\\n        for r in range(len(grid)): # - O(V) or O(M*N)\\n            for c in range(len(grid[0])):\\n                if reachPacific(r,c) and reachAtlantic(r,c):\\n                    res.append([r,c])\\n        return res\\n\\n```\n```        \\n\\ndef pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        \\n\\tgrid = heights\\n    \\n        # helper 1:\\n        def findPacificCells(grid):\\n            from collections import deque\\n            q = deque()\\n            visited = set()\\n            \\n            # num_rows, num_cols\\n            numRows, numCols = len(grid), len(grid[0])\\n        \\n            # add all pacific cells\\n            for i in range(numCols): # top row\\n                q.append((0,i))\\n                visited.add((0,i))\\n            \\n            for i in range(numRows): # left most col\\n                q.append((i,0))\\n                visited.add((i,0))\\n            \\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs:\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:\\n                            if grid[newX][newY] >= grid[x][y]: # -- note [1]\\n                                if (newX, newY) not in visited:\\n                                    q.append((newX, newY))\\n                    \\n            # note [1]\\n            # if new cell is higher -> means rain can flow from it to pacific -> hence include new cell in pacific\\n            return visited\\n            \\n        # helper 2\\n        def findAtlanticCells(grid):\\n            \\n            from collections import deque\\n            q = deque()\\n            visited = set()\\n            \\n            # num_rows, num_cols\\n            numRows, numCols = len(grid), len(grid[0])\\n            \\n            # add all atlantic cells\\n            for i in range(numCols): # bottom row\\n                q.append((numRows-1,i))\\n                visited.add((numRows-1,i))\\n            \\n            for i in range(len(grid)): # right most col\\n                q.append((i,numCols-1))\\n                visited.add((i,numCols-1))\\n            \\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    visited.add((x,y))\\n                    \\n                    for dir in dirs:\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:\\n                            if grid[newX][newY] >= grid[x][y]: # -- note [1]\\n                                if (newX, newY) not in visited:\\n                                    q.append((newX, newY))\\n                    \\n            # note [1]\\n            # if new cell is higher -> means rain can flow from it to pacific -> hence include new cell in pacific\\n            return visited\\n            \\n        # main:\\n        pacific = findPacificCells(grid)\\n        atlantic = findAtlanticCells(grid)\\n        mutual = pacific.intersection(atlantic)\\n        \\n        return list(mutual)\\n```\n```        \\n def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n \\n        # bfs helper\\n        def bfs(q):\\n            dirs = [(1,0), (0,1), (-1,0), (0,-1)]\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    x, y = q.popleft()\\n                    visited.add((x,y))\\n                    \\n                    # expand to nei cell if nei cell is higher in atltitude\\n                    for dir in dirs:\\n                        newX, newY = x+dir[0], y+dir[1]\\n                        if newX >= 0 and newX <= len(grid)-1 and newY >= 0 and newY <= len(grid[0])-1:\\n                            if (newX, newY) not in visited:\\n                                if grid[newX][newY] >= grid[x][y]: # water can flow from nei to x,y to ocean\\n                                    q.append((newX, newY))\\n            return visited\\n                    \\n        \\n        # main\\n        # initial queues - one for each cost/ocean\\n        from collections import deque\\n        qp = deque()\\n        qa = deque()\\n        \\n        grid = heights\\n        \\n        # num_rows, num_cols\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        # 1) pacific:\\n        for i in range(numCols): # top row\\n            qp.append((0,i))\\n        \\n        for i in range(numRows): # left most col\\n            qp.append((i,0))\\n        \\n        # 2) atlantic\\n        for i in range(numRows): # right most col\\n            qa.append((i,numCols-1))\\n            \\n        for i in range(numCols): # bottom row\\n            qa.append((numRows-1, i))\\n        \\n        pacific = bfs(qp)\\n        atlantic = bfs(qa)\\n        mutual = pacific.intersection(atlantic)\\n        return mutual\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1184489,
                "title": "python-easy-to-understand-bfs",
                "content": "```python\\n\\tdef pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        pacific = deque([[0,j] for j in range(n)] + [[i,0] for i in range(m)])\\n        atlantic = deque([[i,n-1] for i in range(m)] + [[m-1, i] for i in range(n)])\\n                \\n        def bfs(queue):\\n            visited = set()\\n            while queue:\\n                x,y = queue.popleft()\\n                visited.add((x,y))\\n                for dx,dy in [[1,0],[0,1],[-1,0],[0,-1]]:\\n                    if 0 <= x+dx < m and 0 <= y+dy < n:\\n                        if (x+dx, y+dy) not in visited:\\n                            if heights[x+dx][y+dy] >= heights[x][y]:\\n                                queue.append((x+dx, y+dy))\\n            return visited\\n        \\n        p, a = bfs(pacific), bfs(atlantic)\\n                        \\n        return p.intersection(a)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n\\tdef pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        pacific = deque([[0,j] for j in range(n)] + [[i,0] for i in range(m)])\\n        atlantic = deque([[i,n-1] for i in range(m)] + [[m-1, i] for i in range(n)])\\n                \\n        def bfs(queue):\\n            visited = set()\\n            while queue:\\n                x,y = queue.popleft()\\n                visited.add((x,y))\\n                for dx,dy in [[1,0],[0,1],[-1,0],[0,-1]]:\\n                    if 0 <= x+dx < m and 0 <= y+dy < n:\\n                        if (x+dx, y+dy) not in visited:\\n                            if heights[x+dx][y+dy] >= heights[x][y]:\\n                                queue.append((x+dx, y+dy))\\n            return visited\\n        \\n        p, a = bfs(pacific), bfs(atlantic)\\n                        \\n        return p.intersection(a)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1127913,
                "title": "java-simple-and-easy-to-understand-solution-using-bfs-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    private static final int[][] DIRECTIONS = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    int rows;\\n    int cols;\\n    int[][] matrix;\\n    \\n    \\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        if(matrix.length == 0 || matrix[0].length == 0)\\n            return new ArrayList<>();\\n        \\n        this.matrix = matrix;\\n        rows = matrix.length;\\n        cols = matrix[0].length;\\n        \\n        \\n        \\n        Queue<int[]> pacificQueue = new LinkedList();\\n        Queue<int[]> atlanticQueue = new LinkedList();\\n        \\n        for(int i = 0; i < rows; i++){\\n            pacificQueue.add(new int[]{i, 0});\\n            atlanticQueue.add(new int[]{i, cols - 1});\\n        }\\n        \\n        \\n        for(int j = 0; j < cols; j++){\\n            pacificQueue.add(new int[]{0, j});\\n            atlanticQueue.add(new int[]{rows - 1, j});\\n        }\\n        \\n        \\n        int[][] pacificReachable = bfs(pacificQueue);\\n        int[][] altanticReachable = bfs(atlanticQueue);\\n        \\n        \\n        List<List<Integer>> commanCell = new ArrayList();\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                //marked\\n                if(pacificReachable[i][j] == 1 && altanticReachable[i][j] == 1){\\n                    commanCell.add(new ArrayList<Integer>(List.of(i, j)));\\n                }\\n            }\\n        }\\n        \\n        \\n        return commanCell;\\n    }\\n    \\n    \\n    private int[][] bfs(Queue<int[]> queue){\\n        \\n        int[][] reachable = new int[rows][cols];\\n        \\n        while(!queue.isEmpty()){\\n            int[] cell = queue.remove();\\n            \\n            \\n            //mark as reached this cell\\n            reachable[cell[0]][cell[1]] = 1;\\n            \\n            for(int[] dir : DIRECTIONS){\\n                int newRow = cell[0] + dir[0];\\n                int newCol = cell[1] + dir[1];\\n                \\n                //Boundary check\\n                if(newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols)\\n                    continue;\\n                \\n                \\n                //check already reached from pacific ocean or altantic ocean\\n                if(reachable[newRow][newCol] > 0)\\n                    continue;\\n                \\n                //check from.this cell we can reached to ocean or not\\n                if(matrix[newRow][newCol] < matrix[cell[0]][cell[1]])\\n                    continue;\\n                \\n                queue.offer(new int[]{newRow, newCol});\\n            }\\n        }\\n        \\n        return reachable;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final int[][] DIRECTIONS = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    int rows;\\n    int cols;\\n    int[][] matrix;\\n    \\n    \\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        if(matrix.length == 0 || matrix[0].length == 0)\\n            return new ArrayList<>();\\n        \\n        this.matrix = matrix;\\n        rows = matrix.length;\\n        cols = matrix[0].length;\\n        \\n        \\n        \\n        Queue<int[]> pacificQueue = new LinkedList();\\n        Queue<int[]> atlanticQueue = new LinkedList();\\n        \\n        for(int i = 0; i < rows; i++){\\n            pacificQueue.add(new int[]{i, 0});\\n            atlanticQueue.add(new int[]{i, cols - 1});\\n        }\\n        \\n        \\n        for(int j = 0; j < cols; j++){\\n            pacificQueue.add(new int[]{0, j});\\n            atlanticQueue.add(new int[]{rows - 1, j});\\n        }\\n        \\n        \\n        int[][] pacificReachable = bfs(pacificQueue);\\n        int[][] altanticReachable = bfs(atlanticQueue);\\n        \\n        \\n        List<List<Integer>> commanCell = new ArrayList();\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                //marked\\n                if(pacificReachable[i][j] == 1 && altanticReachable[i][j] == 1){\\n                    commanCell.add(new ArrayList<Integer>(List.of(i, j)));\\n                }\\n            }\\n        }\\n        \\n        \\n        return commanCell;\\n    }\\n    \\n    \\n    private int[][] bfs(Queue<int[]> queue){\\n        \\n        int[][] reachable = new int[rows][cols];\\n        \\n        while(!queue.isEmpty()){\\n            int[] cell = queue.remove();\\n            \\n            \\n            //mark as reached this cell\\n            reachable[cell[0]][cell[1]] = 1;\\n            \\n            for(int[] dir : DIRECTIONS){\\n                int newRow = cell[0] + dir[0];\\n                int newCol = cell[1] + dir[1];\\n                \\n                //Boundary check\\n                if(newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols)\\n                    continue;\\n                \\n                \\n                //check already reached from pacific ocean or altantic ocean\\n                if(reachable[newRow][newCol] > 0)\\n                    continue;\\n                \\n                //check from.this cell we can reached to ocean or not\\n                if(matrix[newRow][newCol] < matrix[cell[0]][cell[1]])\\n                    continue;\\n                \\n                queue.offer(new int[]{newRow, newCol});\\n            }\\n        }\\n        \\n        return reachable;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634382,
                "title": "c-clean-and-simple-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m = heights.size();\\n        int n = heights[0].size();\\n\\n        vector<vector<int>> visited_p(m, vector<int> (n, 0));\\n        vector<vector<int>> visited_a(m, vector<int> (n, 0));\\n        queue<pair<int, int>> q_pacific;\\n        queue<pair<int, int>> q_atlantic;\\n\\n\\n        for(int i=0;i<n;i++){\\n            visited_p[0][i] = 1;\\n            q_pacific.push({0, i});\\n            visited_a[m-1][i] = 1;   \\n            q_atlantic.push({m-1, i});\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            visited_p[i][0] = 1;\\n            q_pacific.push({i, 0});\\n            visited_a[i][n-1] = 1;\\n            q_atlantic.push({i, n-1});\\n        }\\n\\n        vector<int> di = {+1, 0, 0, -1};\\n        vector<int> dj = {0, +1, -1, 0};\\n\\n        while(!q_pacific.empty()){\\n            int row = q_pacific.front().first;\\n            int col = q_pacific.front().second;\\n            q_pacific.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int n_row = row + di[i];\\n                int n_col = col + dj[i];\\n\\n                if(n_row >= 0 && n_row < m && n_col >= 0 && n_col < n && visited_p[n_row][n_col] == 0){\\n                    if(heights[n_row][n_col] >= heights[row][col]){\\n                        visited_p[n_row][n_col] = 1;\\n                        q_pacific.push({n_row, n_col});\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!q_atlantic.empty()){\\n            int row = q_atlantic.front().first;\\n            int col = q_atlantic.front().second;\\n            q_atlantic.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int n_row = row + di[i];\\n                int n_col = col + dj[i];\\n\\n                if(n_row >= 0 && n_row < m && n_col >= 0 && n_col < n && visited_a[n_row][n_col] == 0){\\n                    if(heights[n_row][n_col] >= heights[row][col]){\\n                        visited_a[n_row][n_col] = 1;\\n                        q_atlantic.push({n_row, n_col});\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visited_p[i][j] == 1 && visited_a[i][j] == 1)\\n                    ans.push_back({i, j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m = heights.size();\\n        int n = heights[0].size();\\n\\n        vector<vector<int>> visited_p(m, vector<int> (n, 0));\\n        vector<vector<int>> visited_a(m, vector<int> (n, 0));\\n        queue<pair<int, int>> q_pacific;\\n        queue<pair<int, int>> q_atlantic;\\n\\n\\n        for(int i=0;i<n;i++){\\n            visited_p[0][i] = 1;\\n            q_pacific.push({0, i});\\n            visited_a[m-1][i] = 1;   \\n            q_atlantic.push({m-1, i});\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            visited_p[i][0] = 1;\\n            q_pacific.push({i, 0});\\n            visited_a[i][n-1] = 1;\\n            q_atlantic.push({i, n-1});\\n        }\\n\\n        vector<int> di = {+1, 0, 0, -1};\\n        vector<int> dj = {0, +1, -1, 0};\\n\\n        while(!q_pacific.empty()){\\n            int row = q_pacific.front().first;\\n            int col = q_pacific.front().second;\\n            q_pacific.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int n_row = row + di[i];\\n                int n_col = col + dj[i];\\n\\n                if(n_row >= 0 && n_row < m && n_col >= 0 && n_col < n && visited_p[n_row][n_col] == 0){\\n                    if(heights[n_row][n_col] >= heights[row][col]){\\n                        visited_p[n_row][n_col] = 1;\\n                        q_pacific.push({n_row, n_col});\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!q_atlantic.empty()){\\n            int row = q_atlantic.front().first;\\n            int col = q_atlantic.front().second;\\n            q_atlantic.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int n_row = row + di[i];\\n                int n_col = col + dj[i];\\n\\n                if(n_row >= 0 && n_row < m && n_col >= 0 && n_col < n && visited_a[n_row][n_col] == 0){\\n                    if(heights[n_row][n_col] >= heights[row][col]){\\n                        visited_a[n_row][n_col] = 1;\\n                        q_atlantic.push({n_row, n_col});\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visited_p[i][j] == 1 && visited_a[i][j] == 1)\\n                    ans.push_back({i, j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104524,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& heights, queue<pair<int, int>>& q, vector<vector<bool>>& v)\\n    {\\n        int x[5]={0, 1, 0, -1, 0};\\n        int m=heights.size();\\n        int n=heights[0].size();\\n        while(!q.empty())\\n        {\\n            // cout<<\"d\";\\n            auto p=q.front();\\n            q.pop();\\n            int i=p.first;\\n            int j=p.second;\\n            for(int k=0;k<4;k++)\\n            {\\n                int r=i+x[k];\\n                int c=j+x[k+1];\\n                if(r>=0 && r<m && c>=0 && c<n && heights[r][c]>=heights[i][j] && v[r][c]==false)\\n                {\\n                    v[r][c]=true;\\n                    q.push({r, c});\\n                }\\n            }\\n        }\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     cout<<v[i][j]<<\" \";\\n        //     cout<<\"\\\\n\";\\n        // }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m=heights.size();\\n        int n=heights[0].size();\\n        vector<vector<bool>> p(m, vector<bool>(n, false));\\n        vector<vector<bool>> a(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q1, q2;\\n        for(int j=0;j<n;j++)\\n        {\\n            q1.push({0, j});\\n            p[0][j]=true;\\n            q2.push({m-1, j});\\n            a[m-1][j]=true;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            q1.push({i, 0});\\n            p[i][0]=true;\\n            q2.push({i, n-1});\\n            a[i][n-1]=true;\\n        }\\n        bfs(heights, q1, p);\\n        cout<<\"\\\\n\";\\n        bfs(heights, q2, a);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            if(p[i][j] && a[i][j])\\n            ans.push_back({i, j});\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>& heights, queue<pair<int, int>>& q, vector<vector<bool>>& v)\\n    {\\n        int x[5]={0, 1, 0, -1, 0};\\n        int m=heights.size();\\n        int n=heights[0].size();\\n        while(!q.empty())\\n        {\\n            // cout<<\"d\";\\n            auto p=q.front();\\n            q.pop();\\n            int i=p.first;\\n            int j=p.second;\\n            for(int k=0;k<4;k++)\\n            {\\n                int r=i+x[k];\\n                int c=j+x[k+1];\\n                if(r>=0 && r<m && c>=0 && c<n && heights[r][c]>=heights[i][j] && v[r][c]==false)\\n                {\\n                    v[r][c]=true;\\n                    q.push({r, c});\\n                }\\n            }\\n        }\\n        // for(int i=0;i<m;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //     cout<<v[i][j]<<\" \";\\n        //     cout<<\"\\\\n\";\\n        // }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m=heights.size();\\n        int n=heights[0].size();\\n        vector<vector<bool>> p(m, vector<bool>(n, false));\\n        vector<vector<bool>> a(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q1, q2;\\n        for(int j=0;j<n;j++)\\n        {\\n            q1.push({0, j});\\n            p[0][j]=true;\\n            q2.push({m-1, j});\\n            a[m-1][j]=true;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            q1.push({i, 0});\\n            p[i][0]=true;\\n            q2.push({i, n-1});\\n            a[i][n-1]=true;\\n        }\\n        bfs(heights, q1, p);\\n        cout<<\"\\\\n\";\\n        bfs(heights, q2, a);\\n        vector<vector<int>> ans;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            if(p[i][j] && a[i][j])\\n            ans.push_back({i, j});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2694838,
                "title": "python-bfs",
                "content": "# Intuition\\n- BFS from cells that are beside pacific ocean to find reachable cells.\\n- BFS from cells that are beside atlantic ocean to find reachable cells.\\n- Take the intersection of the reachable cells to get cells that can reach both oceans.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  First, create the starting queues for BFS by adding cells beside ocean.\\n    - `pacificQueue` takes those cells with `row == 0` and `col == 0`\\n    - `atlanticQueue` takes those cells with `row == ROWS - 1` and `cols == COLS - 1`\\n    - Add their `level` from `heights` as a third param in the tuple\\n1.  Perform BFS on each `queue` (Use a function)\\n    - Create a `reachable` set\\n    - For each cell, go through the adjacent cells\\n    - If cell is in bounds, not in `reachable` set and has `height` greater than the `level` of the current cell, we add it to the `queue`.\\n    - Notice we add all the popped cells to `reachable` set as from our previous condition, we only add reachable cells to the `reachable` set.\\n    - Return the `reachable` set\\n1.  Get the intersection of the `atlanticReachable` and `pacificReachable` sets to get the cells that can reach both oceans. Remember to return as a `list`\\n\\n# Complexity\\n- Time complexity: `O(M*N)`\\n- Space complexity: `O(M*N)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(heights), len(heights[0])\\n        \\n        pacificQueue, atlanticQueue = deque(), deque()\\n        \\n        for col in range(COLS):\\n            pacificQueue.append((0, col, heights[0][col]))\\n            atlanticQueue.append((ROWS-1, col, heights[ROWS-1][col]))\\n        \\n        for row in range(ROWS):\\n            pacificQueue.append((row, 0, heights[row][0]))\\n            atlanticQueue.append((row, COLS-1, heights[row][COLS-1]))\\n        \\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        def bfs(queue):\\n            reachable = set()\\n            while queue:\\n                for _ in range(len(queue)):\\n                    r, c, level = queue.popleft()\\n                    reachable.add((r, c))\\n\\n                    for dr, dc in directions:\\n                        nr, nc = r + dr, c + dc\\n\\n                        if (nr < 0 or nr >= ROWS or \\n                            nc < 0 or nc >= COLS or \\n                            heights[nr][nc] < level or \\n                            (nr, nc) in reachable):\\n                            continue\\n\\n                        queue.append((nr, nc, heights[nr][nc]))\\n            return reachable\\n                    \\n        atlanticReachable = bfs(atlanticQueue)\\n        pacificReachable = bfs(pacificQueue)\\n\\n        return list(atlanticReachable.intersection(pacificReachable))\\n```\\n\\n### Bonus: DFS Approach\\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(heights), len(heights[0])\\n        \\n        def dfs(r, c, prev_height):\\n            if r < 0 or c < 0 or r == ROWS or c == COLS or heights[r][c] < prev_height or (r, c) in reachable:\\n                return\\n            reachable.add((r, c))\\n            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                dfs(r + dr, c + dc, heights[r][c])\\n        \\n        reachable = set()\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                if r == 0 or c == 0:\\n                    dfs(r, c, -1)\\n        pacific_reachable = reachable\\n        \\n        reachable = set()\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                if r == ROWS - 1 or c == COLS - 1:\\n                    dfs(r, c, -1)\\n        atlantic_reachable = reachable\\n        \\n        return list(pacific_reachable.intersection(atlantic_reachable))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(heights), len(heights[0])\\n        \\n        pacificQueue, atlanticQueue = deque(), deque()\\n        \\n        for col in range(COLS):\\n            pacificQueue.append((0, col, heights[0][col]))\\n            atlanticQueue.append((ROWS-1, col, heights[ROWS-1][col]))\\n        \\n        for row in range(ROWS):\\n            pacificQueue.append((row, 0, heights[row][0]))\\n            atlanticQueue.append((row, COLS-1, heights[row][COLS-1]))\\n        \\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        def bfs(queue):\\n            reachable = set()\\n            while queue:\\n                for _ in range(len(queue)):\\n                    r, c, level = queue.popleft()\\n                    reachable.add((r, c))\\n\\n                    for dr, dc in directions:\\n                        nr, nc = r + dr, c + dc\\n\\n                        if (nr < 0 or nr >= ROWS or \\n                            nc < 0 or nc >= COLS or \\n                            heights[nr][nc] < level or \\n                            (nr, nc) in reachable):\\n                            continue\\n\\n                        queue.append((nr, nc, heights[nr][nc]))\\n            return reachable\\n                    \\n        atlanticReachable = bfs(atlanticQueue)\\n        pacificReachable = bfs(pacificQueue)\\n\\n        return list(atlanticReachable.intersection(pacificReachable))\\n```\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        ROWS, COLS = len(heights), len(heights[0])\\n        \\n        def dfs(r, c, prev_height):\\n            if r < 0 or c < 0 or r == ROWS or c == COLS or heights[r][c] < prev_height or (r, c) in reachable:\\n                return\\n            reachable.add((r, c))\\n            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                dfs(r + dr, c + dc, heights[r][c])\\n        \\n        reachable = set()\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                if r == 0 or c == 0:\\n                    dfs(r, c, -1)\\n        pacific_reachable = reachable\\n        \\n        reachable = set()\\n        for r in range(ROWS):\\n            for c in range(COLS):\\n                if r == ROWS - 1 or c == COLS - 1:\\n                    dfs(r, c, -1)\\n        atlantic_reachable = reachable\\n        \\n        return list(pacific_reachable.intersection(atlantic_reachable))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507844,
                "title": "python-fastest-queue-solution",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        # construct a BFS tree rooted at the pacific ocean and record what nodes we can reach\\n        # construct a BFS tree rooted at the atlantic ocean and record what nodes we can reach\\n\\n        m = len(heights)\\n        n = len(heights[0])\\n\\n        \\n        def BFS(grid, startingNodes):\\n            # return a list of reachable cells\\n            nonlocal m,n\\n            \\n            Q = deque()\\n            Q.extend(startingNodes)\\n            visited = set(startingNodes)\\n            while Q:\\n                r,c = Q.popleft()\\n                h = grid[r][c]\\n                \\n                # north\\n                if r>0 and grid[r-1][c]>=h and (r-1,c) not in visited:\\n                    visited.add((r-1,c))\\n                    Q.append((r-1,c))\\n                    \\n                # south\\n                if r<m-1 and grid[r+1][c]>=h and (r+1,c) not in visited:\\n                    visited.add((r+1,c))\\n                    Q.append((r+1,c))\\n                    \\n                # east\\n                if c>0 and grid[r][c-1]>=h and (r,c-1) not in visited:\\n                    visited.add((r,c-1))\\n                    Q.append((r,c-1))\\n\\n                # east\\n                if c<n-1 and grid[r][c+1]>=h and (r,c+1) not in visited:\\n                    visited.add((r,c+1))\\n                    Q.append((r,c+1))\\n                    \\n            return visited\\n        \\n        \\n        pacificNeighbours = [(0,0)]\\n        for i in range(1,n):\\n            pacificNeighbours.append((0,i))\\n        for i in range(1,m):\\n            pacificNeighbours.append((i,0))\\n\\n        atlanticNeighbours = [(m-1,n-1)]\\n        for i in range(n-1):\\n            atlanticNeighbours.append((m-1,i))\\n        for i in range(m-1):\\n            atlanticNeighbours.append((i,n-1))\\n            \\n        pCells = BFS(heights, pacificNeighbours)\\n        aCells = BFS(heights, atlanticNeighbours)\\n        \\n        X = pCells.intersection(aCells)\\n        return list(X)\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        # construct a BFS tree rooted at the pacific ocean and record what nodes we can reach\\n        # construct a BFS tree rooted at the atlantic ocean and record what nodes we can reach\\n\\n        m = len(heights)\\n        n = len(heights[0])\\n\\n        \\n        def BFS(grid, startingNodes):\\n            # return a list of reachable cells\\n            nonlocal m,n\\n            \\n            Q = deque()\\n            Q.extend(startingNodes)\\n            visited = set(startingNodes)\\n            while Q:\\n                r,c = Q.popleft()\\n                h = grid[r][c]\\n                \\n                # north\\n                if r>0 and grid[r-1][c]>=h and (r-1,c) not in visited:\\n                    visited.add((r-1,c))\\n                    Q.append((r-1,c))\\n                    \\n                # south\\n                if r<m-1 and grid[r+1][c]>=h and (r+1,c) not in visited:\\n                    visited.add((r+1,c))\\n                    Q.append((r+1,c))\\n                    \\n                # east\\n                if c>0 and grid[r][c-1]>=h and (r,c-1) not in visited:\\n                    visited.add((r,c-1))\\n                    Q.append((r,c-1))\\n\\n                # east\\n                if c<n-1 and grid[r][c+1]>=h and (r,c+1) not in visited:\\n                    visited.add((r,c+1))\\n                    Q.append((r,c+1))\\n                    \\n            return visited\\n        \\n        \\n        pacificNeighbours = [(0,0)]\\n        for i in range(1,n):\\n            pacificNeighbours.append((0,i))\\n        for i in range(1,m):\\n            pacificNeighbours.append((i,0))\\n\\n        atlanticNeighbours = [(m-1,n-1)]\\n        for i in range(n-1):\\n            atlanticNeighbours.append((m-1,i))\\n        for i in range(m-1):\\n            atlanticNeighbours.append((i,n-1))\\n            \\n        pCells = BFS(heights, pacificNeighbours)\\n        aCells = BFS(heights, atlanticNeighbours)\\n        \\n        X = pCells.intersection(aCells)\\n        return list(X)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507675,
                "title": "c-dfs-easy-solution",
                "content": "class Solution {\\n    public:\\n\\n    int DR[4]={1,0,-1,0};\\n    int DC[4]={0,-1,0,1};\\n    void dfs(int i,int j,int prev, vector<vector<int>> &ocean, vector<vector<int>> &height){\\n        int n=height.size();\\n        int m=height[0].size();\\n        \\n        ocean[i][j]=1;\\n        \\n        for(int k=0;k<4;k++){\\n            int ci=i+DR[k];\\n            int cj=j+DC[k];\\n            \\n            if(ci>=0 && ci<n && cj>=0 && cj<m && !ocean[ci][cj] && prev <= height[ci][cj]){\\n                dfs(ci,cj,height[ci][cj],ocean,height);\\n            }\\n        }\\n        \\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int n=heights.size();\\n        int m=heights[0].size();\\n        \\n        vector<vector<int>> ans;\\n        vector<vector<int>> pacificVis(n,vector<int>(m,0));\\n        vector<vector<int>> atlanticVis(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++){\\n            //1st row\\n            dfs(0,j,heights[0][j],pacificVis,heights);\\n            //last row\\n            dfs(n-1,j,heights[n-1][j],atlanticVis,heights);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            //1st col\\n            dfs(i,0,heights[i][0],pacificVis,heights);\\n            //last col\\n            dfs(i,m-1,heights[i][m-1],atlanticVis,heights);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pacificVis[i][j] && atlanticVis[i][j]){\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n\\n    int DR[4]={1,0,-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2507633,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n  int dir[][] = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) \\n            return res;\\n        \\n        int row = matrix.length, col = matrix[0].length;\\n        boolean[][] pacific = new boolean[row][col];\\n        boolean[][] atlantic = new boolean[row][col];\\n        \\n        //DFS\\n        for(int i = 0; i < col; i++){\\n            dfs(matrix, 0, i, Integer.MIN_VALUE, pacific);\\n            dfs(matrix, row-1, i, Integer.MIN_VALUE, atlantic);\\n        }\\n        for(int i = 0; i < row; i++){\\n            dfs(matrix, i, 0, Integer.MIN_VALUE, pacific);\\n            dfs(matrix, i, col-1, Integer.MIN_VALUE, atlantic);\\n        }\\n        \\n        //preparing the result\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++) {\\n                if(pacific[i][j] && atlantic[i][j]) {\\n                    res.add(Arrays.asList(i,j));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(int[][] matrix, int i, int j, int prev, boolean[][] ocean){\\n        if(i < 0 || i >= ocean.length || j < 0 || j >= ocean[0].length) return;\\n        if(matrix[i][j] < prev || ocean[i][j]) return;\\n        ocean[i][j] = true;\\n        for(int[] d : dir){\\n            dfs(matrix, i+d[0], j+d[1], matrix[i][j], ocean);\\n        }\\n        \\n    }\\n}\\n```\\n\\n**113 / 113 test cases passed.\\nStatus: Accepted\\nRuntime: 6 ms\\nMemory Usage: 55.4 MB**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  int dir[][] = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) \\n            return res;\\n        \\n        int row = matrix.length, col = matrix[0].length;\\n        boolean[][] pacific = new boolean[row][col];\\n        boolean[][] atlantic = new boolean[row][col];\\n        \\n        //DFS\\n        for(int i = 0; i < col; i++){\\n            dfs(matrix, 0, i, Integer.MIN_VALUE, pacific);\\n            dfs(matrix, row-1, i, Integer.MIN_VALUE, atlantic);\\n        }\\n        for(int i = 0; i < row; i++){\\n            dfs(matrix, i, 0, Integer.MIN_VALUE, pacific);\\n            dfs(matrix, i, col-1, Integer.MIN_VALUE, atlantic);\\n        }\\n        \\n        //preparing the result\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++) {\\n                if(pacific[i][j] && atlantic[i][j]) {\\n                    res.add(Arrays.asList(i,j));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(int[][] matrix, int i, int j, int prev, boolean[][] ocean){\\n        if(i < 0 || i >= ocean.length || j < 0 || j >= ocean[0].length) return;\\n        if(matrix[i][j] < prev || ocean[i][j]) return;\\n        ocean[i][j] = true;\\n        for(int[] d : dir){\\n            dfs(matrix, i+d[0], j+d[1], matrix[i][j], ocean);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924073,
                "title": "java-intuition-commented-dfs",
                "content": "Performing a simple DFS while checking for the conditions mentioned.\\n\"arr\" array keeps track of pacific and atlantic ocean state (reached or not reached)\\n**arr**\\n* array 0th index  representing if we can reach pacific ocean (we can reach pacific ocean with index : (0, n) or (n, 0) where n is any appropriate index)\\n* array 1st index representing if we can reach atlantic ocean (we can rach atlantic ocean with index : (r-1, n) or (n, c-1) where r and c are row and column number and n is appropriate index)\\n\\n**Intuition :**\\nDoing dfs at every four possible position and cheking if we have reached the atlantic or pacific ocean yet\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int r = heights.length, c = heights[0].length;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//traversing through 2d array\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                int[][] visited = new int[r][c];\\n                int[] arr = new int[2]; //0th index for pacific -> (0, n) or (n, 0) //1st index for atlantic -> (r-1, n) or (n, c-1)\\n                dfs(i, j, heights, arr, visited);\\n                if(arr[0] == 1 && arr[1] == 1)\\n                    ans.add(Arrays.asList(i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int i, int j, int[][] h, int[] a, int[][] v) {\\n        if(a[0] == 1 && a[1] == 1) return; // if we can reach both pacific as well as atlantic ocean already\\n        if(i >= h.length || j >= h[0].length || i < 0 || j < 0 || v[i][j] == 1) return;\\n        v[i][j] = 1; // marking as visited\\n        if(i == 0 || j == 0) a[0] = 1; //reached pacific ocean\\n        if(i == h.length-1 || j == h[0].length-1) a[1] = 1; //reached atlantic ocean\\n        if(i+1 < h.length) {\\n            if(h[i][j] >= h[i+1][j])\\n                dfs(i+1, j, h, a, v);\\n        }\\n        if(j+1 < h[0].length) {\\n            if(h[i][j+1] <= h[i][j])\\n                dfs(i, j+1, h, a, v);\\n        }\\n        if(i-1 >= 0) {\\n            if(h[i-1][j] <= h[i][j])\\n                dfs(i-1, j, h, a, v);\\n        }\\n        if(j-1 >= 0) {\\n            if(h[i][j-1] <= h[i][j])\\n                dfs(i, j-1, h, a, v);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int r = heights.length, c = heights[0].length;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//traversing through 2d array\\n        for(int i = 0; i < r; i++) {\\n            for(int j = 0; j < c; j++) {\\n                int[][] visited = new int[r][c];\\n                int[] arr = new int[2]; //0th index for pacific -> (0, n) or (n, 0) //1st index for atlantic -> (r-1, n) or (n, c-1)\\n                dfs(i, j, heights, arr, visited);\\n                if(arr[0] == 1 && arr[1] == 1)\\n                    ans.add(Arrays.asList(i, j));\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int i, int j, int[][] h, int[] a, int[][] v) {\\n        if(a[0] == 1 && a[1] == 1) return; // if we can reach both pacific as well as atlantic ocean already\\n        if(i >= h.length || j >= h[0].length || i < 0 || j < 0 || v[i][j] == 1) return;\\n        v[i][j] = 1; // marking as visited\\n        if(i == 0 || j == 0) a[0] = 1; //reached pacific ocean\\n        if(i == h.length-1 || j == h[0].length-1) a[1] = 1; //reached atlantic ocean\\n        if(i+1 < h.length) {\\n            if(h[i][j] >= h[i+1][j])\\n                dfs(i+1, j, h, a, v);\\n        }\\n        if(j+1 < h[0].length) {\\n            if(h[i][j+1] <= h[i][j])\\n                dfs(i, j+1, h, a, v);\\n        }\\n        if(i-1 >= 0) {\\n            if(h[i-1][j] <= h[i][j])\\n                dfs(i-1, j, h, a, v);\\n        }\\n        if(j-1 >= 0) {\\n            if(h[i][j-1] <= h[i][j])\\n                dfs(i, j-1, h, a, v);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646040,
                "title": "dfs-and-bfs-solutions-python-use-as-template-code-for-similar-problems",
                "content": "DFS\\n```\\nclass Solution(object):\\n    def pacificAtlantic(self, heights):\\n        \"\"\"\\n        :type heights: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # # check side case\\n        # if not heights:\\n        #     return\\n        \\n        \\n        rows, cols = len(heights), len(heights[0])\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        # like a worker hahaha\\n        def traverse(i, j, visited):\\n            if (i, j) in visited:\\n                return\\n            visited.add((i, j))\\n            # traverse nbrs\\n            for d in dirs:\\n                next_i, next_j = i + d[0], j + d[1]\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    # question-specific checks:\\n                    if heights[next_i][next_j] >= heights[i][j]:\\n                        traverse(next_i, next_j, visited)\\n        \\n        pacific, atlantic = set(), set()\\n        for i in range(rows):\\n            traverse(i, 0, pacific)\\n            traverse(i, cols - 1, atlantic)\\n        for j in range(cols):\\n            traverse(0, j, pacific)\\n            traverse(rows - 1, j, atlantic)\\n            \\n        return [list(item) for item in pacific & atlantic]\\n```\\n\\nBFS\\n```\\nclass Solution:\\n    def pacificAtlantic(self, matrix):\\n        # check if the input is empty\\n        if not matrix or not matrix[0]:\\n            return []\\n        \\n        n_rows, n_cols = len(matrix), len(matrix[0])\\n        \\n        # queues for bfs\\n        pacific_queue = collections.deque()\\n        atlantic_queue = collections.deque()\\n        \\n        for i in range(n_rows):\\n            pacific_queue.append((i, 0))\\n            atlantic_queue.append((i, n_cols - 1))\\n        for j in range(n_cols):\\n            pacific_queue.append((0, j))\\n            atlantic_queue.append((n_rows - 1, j))\\n            \\n            \\n        # bfs\\n        def bfs(q):\\n            reachable = set()\\n            while q:\\n                r, c = q.popleft()\\n                reachable.add((r, c))\\n                for x, y in [(1, 0), (-1, 0), (0, -1), (0, +1)]:\\n                    new_r, new_c = r + x, c + y\\n                    \\n                    if new_r < 0 or new_r >= n_rows or new_c < 0 or new_c >= n_cols:\\n                        continue\\n                    if (new_r, new_c) in reachable:\\n                        continue\\n                    if matrix[new_r][new_c] < matrix[r][c]:\\n                        continue\\n                    q.append((new_r, new_c))\\n            return reachable\\n        \\n        \\n        pacific_reachable = bfs(pacific_queue)\\n        atlantic_reachable = bfs(atlantic_queue)\\n        \\n        return [list(item) for item in pacific_reachable & atlantic_reachable]\\n```\\n\\nGolang\\n```\\nfunc pacificAtlantic(matrix [][]int) [][]int {\\n\\tif len(matrix) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tn := len(matrix)\\n\\tm := len(matrix[0])\\n\\tif m == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\t// mark cells that flow to Pacific\\n\\tvar curr [][]int\\n\\tdx := []int{0, 0, -1, 1}\\n\\tdy := []int{-1, 1, 0, 0}\\n\\tpacific := make([][]bool, n)\\n\\tfor i := range matrix {\\n\\t\\tpacific[i] = make([]bool, m)\\n\\t\\tpacific[i][0] = true\\n\\t\\tcurr = append(curr, []int{i, 0})\\n\\t}\\n\\tfor j := range matrix[0] {\\n\\t\\tpacific[0][j] = true\\n\\t\\tcurr = append(curr, []int{0, j})\\n\\t}\\n\\tfor len(curr) != 0 {\\n\\t\\tnext := [][]int{}\\n\\t\\tfor _, c := range curr {\\n\\t\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\t\\tx := c[0] + dx[i]\\n\\t\\t\\t\\ty := c[1] + dy[i]\\n\\t\\t\\t\\tif x >= 0 && x < n && y >= 0 && y < m && !pacific[x][y] && matrix[x][y] >= matrix[c[0]][c[1]] {\\n\\t\\t\\t\\t\\tnext = append(next, []int{x, y})\\n\\t\\t\\t\\t\\tpacific[x][y] = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr = next\\n\\t}\\n\\t//  mark cells that flow to Atlantic\\n\\tcurr = [][]int{}\\n\\tatlantic := make([][]bool, n)\\n\\tfor i := range matrix {\\n\\t\\tatlantic[i] = make([]bool, m)\\n\\t\\tatlantic[i][m-1] = true\\n\\t\\tcurr = append(curr, []int{i, m - 1})\\n\\t}\\n\\tfor j := range matrix[0] {\\n\\t\\tatlantic[n-1][j] = true\\n\\t\\tcurr = append(curr, []int{n - 1, j})\\n\\t}\\n\\tfor len(curr) != 0 {\\n\\t\\tnext := [][]int{}\\n\\t\\tfor _, c := range curr {\\n\\t\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\t\\tx := c[0] + dx[i]\\n\\t\\t\\t\\ty := c[1] + dy[i]\\n\\t\\t\\t\\tif x >= 0 && x < n && y >= 0 && y < m && !atlantic[x][y] && matrix[x][y] >= matrix[c[0]][c[1]] {\\n\\t\\t\\t\\t\\tnext = append(next, []int{x, y})\\n\\t\\t\\t\\t\\tatlantic[x][y] = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr = next\\n\\t}\\n\\t// find the list that flow to both oceans\\n\\tvar res [][]int\\n\\tfor i := range matrix {\\n\\t\\tfor j := range matrix[0] {\\n\\t\\t\\tif atlantic[i][j] && pacific[i][j] {\\n\\t\\t\\t\\tres = append(res, []int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def pacificAtlantic(self, heights):\\n        \"\"\"\\n        :type heights: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # # check side case\\n        # if not heights:\\n        #     return\\n        \\n        \\n        rows, cols = len(heights), len(heights[0])\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        # like a worker hahaha\\n        def traverse(i, j, visited):\\n            if (i, j) in visited:\\n                return\\n            visited.add((i, j))\\n            # traverse nbrs\\n            for d in dirs:\\n                next_i, next_j = i + d[0], j + d[1]\\n                if 0 <= next_i < rows and 0 <= next_j < cols:\\n                    # question-specific checks:\\n                    if heights[next_i][next_j] >= heights[i][j]:\\n                        traverse(next_i, next_j, visited)\\n        \\n        pacific, atlantic = set(), set()\\n        for i in range(rows):\\n            traverse(i, 0, pacific)\\n            traverse(i, cols - 1, atlantic)\\n        for j in range(cols):\\n            traverse(0, j, pacific)\\n            traverse(rows - 1, j, atlantic)\\n            \\n        return [list(item) for item in pacific & atlantic]\\n```\n```\\nclass Solution:\\n    def pacificAtlantic(self, matrix):\\n        # check if the input is empty\\n        if not matrix or not matrix[0]:\\n            return []\\n        \\n        n_rows, n_cols = len(matrix), len(matrix[0])\\n        \\n        # queues for bfs\\n        pacific_queue = collections.deque()\\n        atlantic_queue = collections.deque()\\n        \\n        for i in range(n_rows):\\n            pacific_queue.append((i, 0))\\n            atlantic_queue.append((i, n_cols - 1))\\n        for j in range(n_cols):\\n            pacific_queue.append((0, j))\\n            atlantic_queue.append((n_rows - 1, j))\\n            \\n            \\n        # bfs\\n        def bfs(q):\\n            reachable = set()\\n            while q:\\n                r, c = q.popleft()\\n                reachable.add((r, c))\\n                for x, y in [(1, 0), (-1, 0), (0, -1), (0, +1)]:\\n                    new_r, new_c = r + x, c + y\\n                    \\n                    if new_r < 0 or new_r >= n_rows or new_c < 0 or new_c >= n_cols:\\n                        continue\\n                    if (new_r, new_c) in reachable:\\n                        continue\\n                    if matrix[new_r][new_c] < matrix[r][c]:\\n                        continue\\n                    q.append((new_r, new_c))\\n            return reachable\\n        \\n        \\n        pacific_reachable = bfs(pacific_queue)\\n        atlantic_reachable = bfs(atlantic_queue)\\n        \\n        return [list(item) for item in pacific_reachable & atlantic_reachable]\\n```\n```\\nfunc pacificAtlantic(matrix [][]int) [][]int {\\n\\tif len(matrix) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tn := len(matrix)\\n\\tm := len(matrix[0])\\n\\tif m == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\t// mark cells that flow to Pacific\\n\\tvar curr [][]int\\n\\tdx := []int{0, 0, -1, 1}\\n\\tdy := []int{-1, 1, 0, 0}\\n\\tpacific := make([][]bool, n)\\n\\tfor i := range matrix {\\n\\t\\tpacific[i] = make([]bool, m)\\n\\t\\tpacific[i][0] = true\\n\\t\\tcurr = append(curr, []int{i, 0})\\n\\t}\\n\\tfor j := range matrix[0] {\\n\\t\\tpacific[0][j] = true\\n\\t\\tcurr = append(curr, []int{0, j})\\n\\t}\\n\\tfor len(curr) != 0 {\\n\\t\\tnext := [][]int{}\\n\\t\\tfor _, c := range curr {\\n\\t\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\t\\tx := c[0] + dx[i]\\n\\t\\t\\t\\ty := c[1] + dy[i]\\n\\t\\t\\t\\tif x >= 0 && x < n && y >= 0 && y < m && !pacific[x][y] && matrix[x][y] >= matrix[c[0]][c[1]] {\\n\\t\\t\\t\\t\\tnext = append(next, []int{x, y})\\n\\t\\t\\t\\t\\tpacific[x][y] = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr = next\\n\\t}\\n\\t//  mark cells that flow to Atlantic\\n\\tcurr = [][]int{}\\n\\tatlantic := make([][]bool, n)\\n\\tfor i := range matrix {\\n\\t\\tatlantic[i] = make([]bool, m)\\n\\t\\tatlantic[i][m-1] = true\\n\\t\\tcurr = append(curr, []int{i, m - 1})\\n\\t}\\n\\tfor j := range matrix[0] {\\n\\t\\tatlantic[n-1][j] = true\\n\\t\\tcurr = append(curr, []int{n - 1, j})\\n\\t}\\n\\tfor len(curr) != 0 {\\n\\t\\tnext := [][]int{}\\n\\t\\tfor _, c := range curr {\\n\\t\\t\\tfor i := 0; i < 4; i++ {\\n\\t\\t\\t\\tx := c[0] + dx[i]\\n\\t\\t\\t\\ty := c[1] + dy[i]\\n\\t\\t\\t\\tif x >= 0 && x < n && y >= 0 && y < m && !atlantic[x][y] && matrix[x][y] >= matrix[c[0]][c[1]] {\\n\\t\\t\\t\\t\\tnext = append(next, []int{x, y})\\n\\t\\t\\t\\t\\tatlantic[x][y] = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurr = next\\n\\t}\\n\\t// find the list that flow to both oceans\\n\\tvar res [][]int\\n\\tfor i := range matrix {\\n\\t\\tfor j := range matrix[0] {\\n\\t\\t\\tif atlantic[i][j] && pacific[i][j] {\\n\\t\\t\\t\\tres = append(res, []int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422234,
                "title": "java-4ms-solution-4ms-with-explaination-tc-o-m-n-dfs",
                "content": "```\\nclass Solution {\\n    int dir[][] = {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>(); // create a new list to store result \\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)  //if matrix is etiehr null or 1d\\n            return res;\\n        \\n        // create 2 boolean arrays for pacific and atlantic\\n        int row = matrix.length, col = matrix[0].length;\\n        boolean[][] pacific = new boolean[row][col];\\n        boolean[][] atlantic = new boolean[row][col];\\n        \\n        // call upon the dfs ,s.t. pacific starts from top and left and atlantic starts from bottom and right \\n        //DFS\\n        for(int i = 0; i < col; i++){\\n            dfs(matrix, 0, i, Integer.MIN_VALUE, pacific);\\n            dfs(matrix, row-1, i, Integer.MIN_VALUE, atlantic);\\n        }\\n        for(int i = 0; i < row; i++){\\n            dfs(matrix, i, 0, Integer.MIN_VALUE, pacific);\\n            dfs(matrix, i, col-1, Integer.MIN_VALUE, atlantic);\\n        }\\n        \\n        //Ceheck for conditions where both pacific[i][j] and atlantic[i][j] are true \\n        //preparing the result\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++) {\\n                if(pacific[i][j] && atlantic[i][j]) {\\n                    res.add(Arrays.asList(i,j));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void dfs(int[][] matrix, int i, int j, int prev, boolean[][] ocean){\\n        if(i < 0 || i >= ocean.length || j < 0 || j >= ocean[0].length) return; // checking edge cases here\\n        if(matrix[i][j] < prev || ocean[i][j]) return; // if either current cell is already visited or the current cell is < prev\\n        ocean[i][j] = true; // set cell as true\\n        // move into hte 4 directions\\n        for(int[] d : dir){\\n            dfs(matrix, i+d[0], j+d[1], matrix[i][j], ocean);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int dir[][] = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1315621,
                "title": "c-easy-peasy-dfs-just-1-observation-matters",
                "content": "\\n**Important Point:  Water, if falls into any of the oceans from any cell (i,j) will have to fall through one of the border cells eventually.**\\nTherefore it is nice to start dfs from border cells  and visit all cells from which water can fall into these cells .\\n**i.e. cells whose heights are >=current cell height**  *Notice that we are trying to find the path in reverse i.e. from bottom to top.*\\n\\nAs we cover the cells we keep marking them as visited in respective function calls. Two visited arrays are created , One for the Pacific ocean and other for the Atlantic Ocean.\\nEventually all cells which are marked as visited in both the arrays( Atlantic and Pacific ) are pushed into ans . \\n![image](https://assets.leetcode.com/users/images/a8071531-94ff-4284-84b2-a23fd8907bb0_1625405505.4151123.jpeg)\\n```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> pac,atl;\\n    int n,m;\\n    void dfsp(int i,int j,vector<vector<int>>& h,int prev)\\n    {\\n        if(i<0||j<0||i==n||j==m||pac[i][j]||h[i][j]<prev){return;}\\n        pac[i][j]=true;\\n        \\n        int v=h[i][j];\\n        dfsp(i,j+1,h,v);\\n        dfsp(i,j-1,h,v);\\n        dfsp(i+1,j,h,v);\\n        dfsp(i-1,j,h,v);\\n    \\n    }\\n    \\n    void dfsa(int i,int j,vector<vector<int>>& h,int prev)\\n    {\\n        if(i<0||j<0||i==n||j==m||atl[i][j]||h[i][j]<prev){return;}\\n        atl[i][j]=true;\\n        \\n        int v=h[i][j];\\n        dfsa(i,j+1,h,v);\\n        dfsa(i,j-1,h,v);\\n        dfsa(i+1,j,h,v);\\n        dfsa(i-1,j,h,v);\\n    \\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        pac.assign(heights.size(),vector<bool>(heights[0].size(),false));\\n        atl.assign(heights.size(),vector<bool>(heights[0].size(),false));\\n        n=heights.size();m=heights[0].size();\\n        for(int i=0;i<n;i++){\\n            dfsp(i,0,heights,-1);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            dfsp(0,j,heights,-1);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            dfsa(i,m-1,heights,-1);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            dfsa(n-1,j,heights,-1);\\n        }\\n        \\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(atl[i][j]&&pac[i][j]){\\n                    ans.push_back(vector<int>{i,j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> pac,atl;\\n    int n,m;\\n    void dfsp(int i,int j,vector<vector<int>>& h,int prev)\\n    {\\n        if(i<0||j<0||i==n||j==m||pac[i][j]||h[i][j]<prev){return;}\\n        pac[i][j]=true;\\n        \\n        int v=h[i][j];\\n        dfsp(i,j+1,h,v);\\n        dfsp(i,j-1,h,v);\\n        dfsp(i+1,j,h,v);\\n        dfsp(i-1,j,h,v);\\n    \\n    }\\n    \\n    void dfsa(int i,int j,vector<vector<int>>& h,int prev)\\n    {\\n        if(i<0||j<0||i==n||j==m||atl[i][j]||h[i][j]<prev){return;}\\n        atl[i][j]=true;\\n        \\n        int v=h[i][j];\\n        dfsa(i,j+1,h,v);\\n        dfsa(i,j-1,h,v);\\n        dfsa(i+1,j,h,v);\\n        dfsa(i-1,j,h,v);\\n    \\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        pac.assign(heights.size(),vector<bool>(heights[0].size(),false));\\n        atl.assign(heights.size(),vector<bool>(heights[0].size(),false));\\n        n=heights.size();m=heights[0].size();\\n        for(int i=0;i<n;i++){\\n            dfsp(i,0,heights,-1);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            dfsp(0,j,heights,-1);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            dfsa(i,m-1,heights,-1);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            dfsa(n-1,j,heights,-1);\\n        }\\n        \\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(atl[i][j]&&pac[i][j]){\\n                    ans.push_back(vector<int>{i,j});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126854,
                "title": "bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int dx[4]={1,0,-1,0};\\n    int dy[4]={0,1,0,-1};\\n    queue<pair<int,int>> pac;\\n    queue<pair<int,int>> atl;\\n    \\n    bool isValid(int x, int y){\\n        return x>=0 && x<m && y>=0 && y<n;\\n    }\\n    \\n    void bfs(queue<pair<int,int>> &q, vector<vector<int>> &vis, vector<vector<int>>& matrix){\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            vis[x][y]=1;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int xx=x+dx[k];\\n                int yy=y+dy[k];\\n                if(isValid(xx,yy) && matrix[x][y]<=matrix[xx][yy] && vis[xx][yy]==0){\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n    }\\n    \\n        \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        m=matrix.size();\\n        if(m==0)\\n            return ans;\\n        n=matrix[0].size();\\n        if(n==0)\\n            return ans;\\n        vector<vector<int>> visp(m, vector<int>(n,0));\\n        vector<vector<int>> visq(m, vector<int>(n,0));\\n        for(int i=m-1;i>=0;i--)\\n            pac.push({i,0});\\n        for(int i=n-1;i>=0;i--)\\n            pac.push({0,i});\\n        for(int i=m-1;i>=0;i--)\\n            atl.push({i,n-1});\\n        for(int i=n-1;i>=0;i--)\\n            atl.push({m-1,i});\\n        bfs(pac,visp,matrix);\\n        bfs(atl,visq,matrix);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visp[i][j]==1 && visq[i][j]==1)\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int dx[4]={1,0,-1,0};\\n    int dy[4]={0,1,0,-1};\\n    queue<pair<int,int>> pac;\\n    queue<pair<int,int>> atl;\\n    \\n    bool isValid(int x, int y){\\n        return x>=0 && x<m && y>=0 && y<n;\\n    }\\n    \\n    void bfs(queue<pair<int,int>> &q, vector<vector<int>> &vis, vector<vector<int>>& matrix){\\n        while(!q.empty()){\\n            int x=q.front().first;\\n            int y=q.front().second;\\n            vis[x][y]=1;\\n            q.pop();\\n            for(int k=0;k<4;k++){\\n                int xx=x+dx[k];\\n                int yy=y+dy[k];\\n                if(isValid(xx,yy) && matrix[x][y]<=matrix[xx][yy] && vis[xx][yy]==0){\\n                    q.push({xx,yy});\\n                }\\n            }\\n        }\\n    }\\n    \\n        \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        m=matrix.size();\\n        if(m==0)\\n            return ans;\\n        n=matrix[0].size();\\n        if(n==0)\\n            return ans;\\n        vector<vector<int>> visp(m, vector<int>(n,0));\\n        vector<vector<int>> visq(m, vector<int>(n,0));\\n        for(int i=m-1;i>=0;i--)\\n            pac.push({i,0});\\n        for(int i=n-1;i>=0;i--)\\n            pac.push({0,i});\\n        for(int i=m-1;i>=0;i--)\\n            atl.push({i,n-1});\\n        for(int i=n-1;i>=0;i--)\\n            atl.push({m-1,i});\\n        bfs(pac,visp,matrix);\\n        bfs(atl,visq,matrix);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visp[i][j]==1 && visq[i][j]==1)\\n                    ans.push_back({i,j});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126739,
                "title": "pacific-atlantic-water-flow-easy-solution-simple-code-using-dfs",
                "content": "The idea is we are visiting every index that is reachable from pacific and atlantic and marking it as `visited=true` , and Finally we are checking if any index is reachable from both pacific and atlantic,then it is pushed into `res`.\\n\\n**DO UPVOTE** if you find it helpful!!\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        vector<vector<int>>res;\\n        int n = mat.size();\\n        if(n==0) return res;\\n        int m = mat[0].size();\\n        if(m==0) return res;\\n        vector<vector<bool>>pc(n,vector<bool>(m,false));\\n        vector<vector<bool>>at(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(mat,pc,i,0,INT_MIN);\\n            dfs(mat,at,i,m-1,INT_MIN);\\n        }\\n        for(int j=0;j<m;j++){\\n            dfs(mat,pc,0,j,INT_MIN);\\n            dfs(mat,at,n-1,j,INT_MIN);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pc[i][j] && at[i][j])\\n                    res.push_back({i,j});\\n            }\\n        }\\n        return res;\\n    }    \\n    void dfs(vector<vector<int>>&mat,vector<vector<bool>> &visited,int i,int j,int prev){\\n        if(i<0 || j<0 || i>=mat.size() || j>= mat[0].size() || visited[i][j] || mat[i][j]<prev) return;\\n        visited[i][j] = true;\\n            dfs(mat,visited,i+1,j,mat[i][j]);\\n            dfs(mat,visited,i-1,j,mat[i][j]);\\n            dfs(mat,visited,i,j+1,mat[i][j]);\\n            dfs(mat,visited,i,j-1,mat[i][j]);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        vector<vector<int>>res;\\n        int n = mat.size();\\n        if(n==0) return res;\\n        int m = mat[0].size();\\n        if(m==0) return res;\\n        vector<vector<bool>>pc(n,vector<bool>(m,false));\\n        vector<vector<bool>>at(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(mat,pc,i,0,INT_MIN);\\n            dfs(mat,at,i,m-1,INT_MIN);\\n        }\\n        for(int j=0;j<m;j++){\\n            dfs(mat,pc,0,j,INT_MIN);\\n            dfs(mat,at,n-1,j,INT_MIN);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pc[i][j] && at[i][j])\\n                    res.push_back({i,j});\\n            }\\n        }\\n        return res;\\n    }    \\n    void dfs(vector<vector<int>>&mat,vector<vector<bool>> &visited,int i,int j,int prev){\\n        if(i<0 || j<0 || i>=mat.size() || j>= mat[0].size() || visited[i][j] || mat[i][j]<prev) return;\\n        visited[i][j] = true;\\n            dfs(mat,visited,i+1,j,mat[i][j]);\\n            dfs(mat,visited,i-1,j,mat[i][j]);\\n            dfs(mat,visited,i,j+1,mat[i][j]);\\n            dfs(mat,visited,i,j-1,mat[i][j]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819204,
                "title": "python3-dfs-solution-pacific-atlantic-water-flow",
                "content": "```\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix or not matrix[0]:\\n            return []\\n        R, C = len(matrix), len(matrix[0])\\n        pacific, atlantic = set(), set()\\n        def dfs(r, c, seen):\\n            if (r, c) in seen:\\n                return\\n            seen.add((r, c))\\n            for nr, nc in ((r, c+1), (r, c-1), (r+1, c), (r-1, c)):\\n                if 0 <= nr < R and 0 <= nc < C and matrix[nr][nc] >= matrix[r][c]:\\n                    dfs(nr, nc, seen)\\n        for r, c in [(r, 0) for r in range(R)] + [(0, c) for c in range(C)]:\\n            dfs(r, c, pacific)\\n        for r, c in [(r, C-1) for r in range(R)] + [(R-1, c) for c in range(C)]:\\n            dfs(r, c, atlantic)\\n        return pacific & atlantic\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix or not matrix[0]:\\n            return []\\n        R, C = len(matrix), len(matrix[0])\\n        pacific, atlantic = set(), set()\\n        def dfs(r, c, seen):\\n            if (r, c) in seen:\\n                return\\n            seen.add((r, c))\\n            for nr, nc in ((r, c+1), (r, c-1), (r+1, c), (r-1, c)):\\n                if 0 <= nr < R and 0 <= nc < C and matrix[nr][nc] >= matrix[r][c]:\\n                    dfs(nr, nc, seen)\\n        for r, c in [(r, 0) for r in range(R)] + [(0, c) for c in range(C)]:\\n            dfs(r, c, pacific)\\n        for r, c in [(r, C-1) for r in range(R)] + [(R-1, c) for c in range(C)]:\\n            dfs(r, c, atlantic)\\n        return pacific & atlantic\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273406,
                "title": "easy-understanding-heavily-commented-java-solution-bfs",
                "content": "Note that this solution comes with the help of a self-defined class \"Cell\" in the end.\\n\\n```\\npublic class Solution {\\n  public List<int[]> pacificAtlantic(int[][] matrix) {\\n    // BFS Approach\\n    // Assuming input matrix has m rows and n columns\\n    // Time: O(m * n) ... to be specific: O(4 * m * n)  \\n    // Space: O(m * n) ... due to the cellMatrix (the queue itself takes only O(m + n) space)\\n    \\n    // Corner cases:\\n    if (matrix == null || matrix.length == 0) {\\n        return Collections.emptyList();\\n    }\\n    \\n    // Step 1: Convert int[][] to Cell[][] in order to carry more information\\n    Cell[][] cellMatrix = convertToCellMatrix(matrix);\\n    \\n    // Step 2: Use BFS to find reachable cells from Pacific ocean\\n    // We need a queue to implement BFS. \\n    Queue<Cell> queue = new LinkedList<>();\\n    findReachablePointsFromPacific(cellMatrix, queue);\\n    \\n    // Step 3: Use BFS to find reachable cells from Atlantic ocean\\n    // Note that the original queue can be reused, since after step 2, the queue will be empty!\\n    findReachablePointsFromAtlantic(cellMatrix, queue);\\n    \\n    // Step 4: If a cell can be reached from both oceans, we add it to result\\n    List<int[]> result = addToResult(cellMatrix);\\n    return result;\\n  }\\n  \\n  private Cell[][] convertToCellMatrix(int[][] matrix) {\\n    // This function will convert the original int[][] matrix to the Cell[][] cellMatrix. The benefit of doing this\\n    // is each cell can carry more information compared to the original int[][] matrix\\n\\n    int row = matrix.length;\\n    int col = matrix[0].length;\\n    \\n    Cell[][] cellMatrix = new Cell[row][col];\\n    for (int i = 0; i < row; i++) {\\n      for (int j = 0; j < col; j++) {\\n        cellMatrix[i][j] = new Cell(i, j, matrix[i][j]);\\n      }\\n    }\\n    return cellMatrix;\\n  }\\n  \\n  private void findReachablePointsFromPacific(Cell[][] cellMatrix, Queue<Cell> queue) {\\n    // This function will find all the points that can be reached from Pacific ocean. To be specific, it will update \\n\\t// all the possible cells\\' \"reachableFromPacific\" value. BFS is performed here.\\n\\t\\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    \\n    // Step 1: Initialize: Add the upper and left borders (those adjacent to Pacific ocean) to the queue.\\n    for (int i = 0; i < row; i++) {\\n      cellMatrix[i][0].reachableFromPacific = true;\\n      queue.add(cellMatrix[i][0]);\\n    }\\n    for (int j = 1; j < col; j++) {\\n      cellMatrix[0][j].reachableFromPacific = true;\\n      queue.offer(cellMatrix[0][j]);\\n    }\\n    \\n    // Step 2: Expand and generate\\n    ExpandAndGenerate(cellMatrix, queue, \"Pacific\");\\n  }\\n  \\n  private void findReachablePointsFromAtlantic(Cell[][] cellMatrix, Queue<Cell> queue) {\\n    // This function will find all the points that can be reached from Atlantic ocean. To be specific, it will update\\n\\t// all the possible cells\\' \"reachableFromAtlantic\" value. BFS is performed here.\\n\\t\\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    \\n    // Initialize: Add the lower and right borders (those adjacent to Atlantic ocean) to the queue.\\n    for (int i = 0; i < row; i++) {\\n      cellMatrix[i][col - 1].reachableFromAtlantic = true;\\n      queue.add(cellMatrix[i][col - 1]);\\n    }\\n    for (int j = 0; j < col - 1; j++) {\\n      cellMatrix[row - 1][j].reachableFromAtlantic = true;\\n      queue.offer(cellMatrix[row - 1][j]);\\n    }\\n    \\n    // Step 2: Expand and generate\\n    ExpandAndGenerate(cellMatrix, queue, \"Atlantic\");\\n  }\\n  \\n  private void ExpandAndGenerate(Cell[][] cellMatrix, Queue<Cell> queue, String oceanName) {\\n    // This function will do the \"expand and generate\" process\\n    // During the process, the cell\\'s reachableFromOcean value will gradually be updated\\n   \\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    \\n    // Expand and generate\\n    // Those cells in the queue are the ones that can reach the ocean. Each time we poll a cell out of the queue, \\n    // and use this cell to update it neighbors reachableFromOcean value (4 directions).\\n    while (!queue.isEmpty()) {\\n      Cell cur = queue.poll();\\n      // Make sure that we won\\'t get indexOutOfBoundException\\n      if (cur.row - 1 >= 0) {\\n        Cell upper = cellMatrix[cur.row - 1][cur.col];\\n        enqueue(cur, upper, queue, oceanName);\\n      }\\n      if (cur.row + 1 <= row - 1) {\\n        Cell lower = cellMatrix[cur.row + 1][cur.col];\\n        enqueue(cur, lower, queue, oceanName);\\n      }\\n      if (cur.col - 1 >= 0) {\\n        Cell left = cellMatrix[cur.row][cur.col - 1];\\n        enqueue(cur, left, queue, oceanName);\\n      }\\n      if (cur.col + 1 <= col - 1) {\\n        Cell right = cellMatrix[cur.row][cur.col + 1];\\n        enqueue(cur, right, queue, oceanName);\\n      }\\n    }\\n  }\\n  \\n  private void enqueue(Cell cur, Cell neighbor, Queue<Cell> queue, String oceanName) {\\n    // This function will put my neighbor cell into the queue (if the condition is met)\\n    // Condition: My neighbor is heigher than me, ALSO, my neighbor cannot reach the ocean currently\\n    // Note that cur cell is just polled out from the queue, which implies the cur cell can reach the ocean\\n    \\n    if (oceanName == \"Pacific\") {\\n      if (neighbor.reachableFromPacific == false && neighbor.height >= cur.height) {\\n        neighbor.reachableFromPacific = true;\\n        queue.offer(neighbor);\\n      }\\n    }\\n    if (oceanName == \"Atlantic\") {\\n      if (neighbor.reachableFromAtlantic == false && neighbor.height >= cur.height) {\\n        neighbor.reachableFromAtlantic = true;\\n        queue.offer(neighbor);\\n      }\\n    }\\n  }\\n  \\n  private List<int[]> addToResult(Cell[][] cellMatrix) {\\n    // This function will call reachableFromBoth() function for all the cell points\\n    // If receives true, add that particular point to the answer\\n    \\n\\tList<int[]> result = new ArrayList<>();\\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    for (int i = 0; i < row; i++) {\\n      for (int j = 0; j < col; j++) {\\n        if (cellMatrix[i][j].reachableFromBoth()) {\\n          result.add(new int[] {i, j});\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n}\\n\\nclass Cell { // My self-defined class \"Cell\"\\n  int row;\\n  int col;\\n  int height;\\n  boolean reachableFromPacific;\\n  boolean reachableFromAtlantic;\\n  \\n  Cell (int row, int col, int height) {\\n    this.row = row;\\n    this.col = col;\\n    this.height = height;\\n  }\\n  \\n  boolean reachableFromBoth() {\\n    return reachableFromPacific && reachableFromAtlantic;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n  public List<int[]> pacificAtlantic(int[][] matrix) {\\n    // BFS Approach\\n    // Assuming input matrix has m rows and n columns\\n    // Time: O(m * n) ... to be specific: O(4 * m * n)  \\n    // Space: O(m * n) ... due to the cellMatrix (the queue itself takes only O(m + n) space)\\n    \\n    // Corner cases:\\n    if (matrix == null || matrix.length == 0) {\\n        return Collections.emptyList();\\n    }\\n    \\n    // Step 1: Convert int[][] to Cell[][] in order to carry more information\\n    Cell[][] cellMatrix = convertToCellMatrix(matrix);\\n    \\n    // Step 2: Use BFS to find reachable cells from Pacific ocean\\n    // We need a queue to implement BFS. \\n    Queue<Cell> queue = new LinkedList<>();\\n    findReachablePointsFromPacific(cellMatrix, queue);\\n    \\n    // Step 3: Use BFS to find reachable cells from Atlantic ocean\\n    // Note that the original queue can be reused, since after step 2, the queue will be empty!\\n    findReachablePointsFromAtlantic(cellMatrix, queue);\\n    \\n    // Step 4: If a cell can be reached from both oceans, we add it to result\\n    List<int[]> result = addToResult(cellMatrix);\\n    return result;\\n  }\\n  \\n  private Cell[][] convertToCellMatrix(int[][] matrix) {\\n    // This function will convert the original int[][] matrix to the Cell[][] cellMatrix. The benefit of doing this\\n    // is each cell can carry more information compared to the original int[][] matrix\\n\\n    int row = matrix.length;\\n    int col = matrix[0].length;\\n    \\n    Cell[][] cellMatrix = new Cell[row][col];\\n    for (int i = 0; i < row; i++) {\\n      for (int j = 0; j < col; j++) {\\n        cellMatrix[i][j] = new Cell(i, j, matrix[i][j]);\\n      }\\n    }\\n    return cellMatrix;\\n  }\\n  \\n  private void findReachablePointsFromPacific(Cell[][] cellMatrix, Queue<Cell> queue) {\\n    // This function will find all the points that can be reached from Pacific ocean. To be specific, it will update \\n\\t// all the possible cells\\' \"reachableFromPacific\" value. BFS is performed here.\\n\\t\\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    \\n    // Step 1: Initialize: Add the upper and left borders (those adjacent to Pacific ocean) to the queue.\\n    for (int i = 0; i < row; i++) {\\n      cellMatrix[i][0].reachableFromPacific = true;\\n      queue.add(cellMatrix[i][0]);\\n    }\\n    for (int j = 1; j < col; j++) {\\n      cellMatrix[0][j].reachableFromPacific = true;\\n      queue.offer(cellMatrix[0][j]);\\n    }\\n    \\n    // Step 2: Expand and generate\\n    ExpandAndGenerate(cellMatrix, queue, \"Pacific\");\\n  }\\n  \\n  private void findReachablePointsFromAtlantic(Cell[][] cellMatrix, Queue<Cell> queue) {\\n    // This function will find all the points that can be reached from Atlantic ocean. To be specific, it will update\\n\\t// all the possible cells\\' \"reachableFromAtlantic\" value. BFS is performed here.\\n\\t\\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    \\n    // Initialize: Add the lower and right borders (those adjacent to Atlantic ocean) to the queue.\\n    for (int i = 0; i < row; i++) {\\n      cellMatrix[i][col - 1].reachableFromAtlantic = true;\\n      queue.add(cellMatrix[i][col - 1]);\\n    }\\n    for (int j = 0; j < col - 1; j++) {\\n      cellMatrix[row - 1][j].reachableFromAtlantic = true;\\n      queue.offer(cellMatrix[row - 1][j]);\\n    }\\n    \\n    // Step 2: Expand and generate\\n    ExpandAndGenerate(cellMatrix, queue, \"Atlantic\");\\n  }\\n  \\n  private void ExpandAndGenerate(Cell[][] cellMatrix, Queue<Cell> queue, String oceanName) {\\n    // This function will do the \"expand and generate\" process\\n    // During the process, the cell\\'s reachableFromOcean value will gradually be updated\\n   \\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    \\n    // Expand and generate\\n    // Those cells in the queue are the ones that can reach the ocean. Each time we poll a cell out of the queue, \\n    // and use this cell to update it neighbors reachableFromOcean value (4 directions).\\n    while (!queue.isEmpty()) {\\n      Cell cur = queue.poll();\\n      // Make sure that we won\\'t get indexOutOfBoundException\\n      if (cur.row - 1 >= 0) {\\n        Cell upper = cellMatrix[cur.row - 1][cur.col];\\n        enqueue(cur, upper, queue, oceanName);\\n      }\\n      if (cur.row + 1 <= row - 1) {\\n        Cell lower = cellMatrix[cur.row + 1][cur.col];\\n        enqueue(cur, lower, queue, oceanName);\\n      }\\n      if (cur.col - 1 >= 0) {\\n        Cell left = cellMatrix[cur.row][cur.col - 1];\\n        enqueue(cur, left, queue, oceanName);\\n      }\\n      if (cur.col + 1 <= col - 1) {\\n        Cell right = cellMatrix[cur.row][cur.col + 1];\\n        enqueue(cur, right, queue, oceanName);\\n      }\\n    }\\n  }\\n  \\n  private void enqueue(Cell cur, Cell neighbor, Queue<Cell> queue, String oceanName) {\\n    // This function will put my neighbor cell into the queue (if the condition is met)\\n    // Condition: My neighbor is heigher than me, ALSO, my neighbor cannot reach the ocean currently\\n    // Note that cur cell is just polled out from the queue, which implies the cur cell can reach the ocean\\n    \\n    if (oceanName == \"Pacific\") {\\n      if (neighbor.reachableFromPacific == false && neighbor.height >= cur.height) {\\n        neighbor.reachableFromPacific = true;\\n        queue.offer(neighbor);\\n      }\\n    }\\n    if (oceanName == \"Atlantic\") {\\n      if (neighbor.reachableFromAtlantic == false && neighbor.height >= cur.height) {\\n        neighbor.reachableFromAtlantic = true;\\n        queue.offer(neighbor);\\n      }\\n    }\\n  }\\n  \\n  private List<int[]> addToResult(Cell[][] cellMatrix) {\\n    // This function will call reachableFromBoth() function for all the cell points\\n    // If receives true, add that particular point to the answer\\n    \\n\\tList<int[]> result = new ArrayList<>();\\n    int row = cellMatrix.length;\\n    int col = cellMatrix[0].length;\\n    for (int i = 0; i < row; i++) {\\n      for (int j = 0; j < col; j++) {\\n        if (cellMatrix[i][j].reachableFromBoth()) {\\n          result.add(new int[] {i, j});\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n}\\n\\nclass Cell { // My self-defined class \"Cell\"\\n  int row;\\n  int col;\\n  int height;\\n  boolean reachableFromPacific;\\n  boolean reachableFromAtlantic;\\n  \\n  Cell (int row, int col, int height) {\\n    this.row = row;\\n    this.col = col;\\n    this.height = height;\\n  }\\n  \\n  boolean reachableFromBoth() {\\n    return reachableFromPacific && reachableFromAtlantic;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90753,
                "title": "simple-and-elegant-python-dfs-solution",
                "content": "Simply do two DFS, each time starting from the edges that belong to the Pacific and Atlantic Ocean.\\n\\n`nodes = set(coords[type]) | set(zip(*coords)[type])` is a really neat trick to get the cells for each ocean. When `type` is 0, you will get the Pacific Ocean cells, when `type` is -1, you will get the Atlantic Ocean cells.\\n\\nThe rest is standard DFS code already presented multiple times by others.\\n\\n\\n```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not len(matrix) or not len(matrix[0]):\\n            return []\\n        rows, cols = len(matrix), len(matrix[0])\\n        coords = [[(row, col) for col in range(cols)] for row in range(rows)]\\n        def ocean_nodes(type):\\n            nodes = set(coords[type]) | set(zip(*coords)[type])\\n            traversable = set()\\n            def traverse(node):\\n                if node in traversable:\\n                    return\\n                traversable.add(node)\\n                curr_height = matrix[node[0]][node[1]]\\n                for direction in ((0, 1), (0, -1), (1, 0), (-1, 0)):\\n                    row, col = node[0] + direction[0], node[1] + direction[1]\\n                    if 0 <= row < rows and 0 <= col < cols and curr_height <= matrix[row][col]:\\n                        traverse((row, col))\\n            [traverse(node) for node in nodes]\\n            return traversable\\n        return list(ocean_nodes(0) & ocean_nodes(-1))          \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pacificAtlantic(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not len(matrix) or not len(matrix[0]):\\n            return []\\n        rows, cols = len(matrix), len(matrix[0])\\n        coords = [[(row, col) for col in range(cols)] for row in range(rows)]\\n        def ocean_nodes(type):\\n            nodes = set(coords[type]) | set(zip(*coords)[type])\\n            traversable = set()\\n            def traverse(node):\\n                if node in traversable:\\n                    return\\n                traversable.add(node)\\n                curr_height = matrix[node[0]][node[1]]\\n                for direction in ((0, 1), (0, -1), (1, 0), (-1, 0)):\\n                    row, col = node[0] + direction[0], node[1] + direction[1]\\n                    if 0 <= row < rows and 0 <= col < cols and curr_height <= matrix[row][col]:\\n                        traverse((row, col))\\n            [traverse(node) for node in nodes]\\n            return traversable\\n        return list(ocean_nodes(0) & ocean_nodes(-1))          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 90768,
                "title": "javascript-solution-using-dfs",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nvar pacificAtlantic = function(matrix) {\\n    var res = [];\\n    \\n    if (!matrix || matrix.length === 0 || matrix[0].length === 0) { return res; }\\n    \\n    var ymax = matrix.length - 1;\\n    var xmax = matrix[0].length - 1;\\n    var pacific = [];\\n    var atlantic = [];\\n    for (let y = 0; y <= ymax; y++) {\\n        var rowPacific = [];\\n        var rowAtlantic = [];\\n        for (let x = 0; x <= xmax; x++) {\\n            rowPacific.push(false);\\n            rowAtlantic.push(false);\\n        }\\n        pacific.push(rowPacific);\\n        atlantic.push(rowAtlantic);\\n    }\\n    \\n    for (let y = 0; y <= ymax; y++) {\\n        helper(0, y, pacific, -1, matrix);\\n        helper(xmax, y, atlantic, -1, matrix);\\n    }\\n    \\n    for (let x = 0; x <= xmax; x++) {\\n        helper(x, 0, pacific, -1, matrix);\\n        helper(x, ymax, atlantic, -1, matrix);\\n    }\\n    \\n    for (let y = 0; y <= ymax; y++) {\\n        for (let x = 0; x <= xmax; x++) {\\n            if (pacific[y][x] && atlantic[y][x]) {\\n                res.push([y, x]);\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nvar helper = function(x, y, visited, height, matrix) {\\n    if (x < 0 || x >= matrix[0].length || y < 0 || y >= matrix.length || visited[y][x] || matrix[y][x] < height) {\\n        return;\\n    }\\n    \\n    visited[y][x] = true;\\n    helper(x + 1, y, visited, matrix[y][x], matrix);\\n    helper(x - 1, y, visited, matrix[y][x], matrix);\\n    helper(x, y + 1, visited, matrix[y][x], matrix);\\n    helper(x, y - 1, visited, matrix[y][x], matrix);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[][]}\\n */\\nvar pacificAtlantic = function(matrix) {\\n    var res = [];\\n    \\n    if (!matrix || matrix.length === 0 || matrix[0].length === 0) { return res; }\\n    \\n    var ymax = matrix.length - 1;\\n    var xmax = matrix[0].length - 1;\\n    var pacific = [];\\n    var atlantic = [];\\n    for (let y = 0; y <= ymax; y++) {\\n        var rowPacific = [];\\n        var rowAtlantic = [];\\n        for (let x = 0; x <= xmax; x++) {\\n            rowPacific.push(false);\\n            rowAtlantic.push(false);\\n        }\\n        pacific.push(rowPacific);\\n        atlantic.push(rowAtlantic);\\n    }\\n    \\n    for (let y = 0; y <= ymax; y++) {\\n        helper(0, y, pacific, -1, matrix);\\n        helper(xmax, y, atlantic, -1, matrix);\\n    }\\n    \\n    for (let x = 0; x <= xmax; x++) {\\n        helper(x, 0, pacific, -1, matrix);\\n        helper(x, ymax, atlantic, -1, matrix);\\n    }\\n    \\n    for (let y = 0; y <= ymax; y++) {\\n        for (let x = 0; x <= xmax; x++) {\\n            if (pacific[y][x] && atlantic[y][x]) {\\n                res.push([y, x]);\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nvar helper = function(x, y, visited, height, matrix) {\\n    if (x < 0 || x >= matrix[0].length || y < 0 || y >= matrix.length || visited[y][x] || matrix[y][x] < height) {\\n        return;\\n    }\\n    \\n    visited[y][x] = true;\\n    helper(x + 1, y, visited, matrix[y][x], matrix);\\n    helper(x - 1, y, visited, matrix[y][x], matrix);\\n    helper(x, y + 1, visited, matrix[y][x], matrix);\\n    helper(x, y - 1, visited, matrix[y][x], matrix);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 90762,
                "title": "straightforward-efficient-c-solution-using-stack",
                "content": "The code is rather long, but very easy to understand.\\nBasically, we use two tables to record if the water can flow to pacific or atlantic. To determine the element, we use a stack structure to search the element on the four sides of a certain element.\\nIn the test the runtime is 55ms.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> result;\\n        int m=matrix.size();\\n        if (m==0) return result;\\n        int n=matrix[0].size();\\n        int pacific[m][n];\\n        int atlantic[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                pacific[i][j]=0;\\n                atlantic[i][j]=0;\\n            }\\n        }\\n        stack<pair<int,int>> sp;\\n        stack<pair<int,int>> sa;\\n        for (int i=0;i<m;i++){\\n            pacific[i][0]=1;\\n            sp.push(make_pair(i,0));\\n        }\\n        for(int i=1;i<n;i++){\\n            pacific[0][i]=1;\\n            sp.push(make_pair(0,i));\\n        }\\n        while(!sp.empty()){\\n            pair<int, int> index=sp.top();\\n            int x=index.first;\\n            int y=index.second;\\n            sp.pop();\\n            if (x-1>=0&&pacific[x-1][y]==0&&matrix[x-1][y]>=matrix[x][y]){\\n                sp.push(make_pair(x-1,y));\\n                pacific[x-1][y]=1;\\n            }\\n            if (x+1<m&&pacific[x+1][y]==0&&matrix[x+1][y]>=matrix[x][y]){\\n                sp.push(make_pair(x+1,y));\\n                pacific[x+1][y]=1;\\n            }\\n            if (y-1>=0&&pacific[x][y-1]==0&&matrix[x][y-1]>=matrix[x][y]){\\n                sp.push(make_pair(x,y-1));\\n                pacific[x][y-1]=1;\\n            }\\n            if (y+1<n&&pacific[x][y+1]==0&&matrix[x][y+1]>=matrix[x][y]){\\n                sp.push(make_pair(x,y+1));\\n                pacific[x][y+1]=1;\\n            }\\n        }\\n        for (int i=0;i<m;i++){\\n            atlantic[i][n-1]=1;\\n            sa.push(make_pair(i,n-1));\\n        }\\n        for(int i=0;i<n-1;i++){\\n            atlantic[m-1][i]=1;\\n            sa.push(make_pair(m-1,i));\\n        }\\n        while(!sa.empty()){\\n            pair<int, int> index=sa.top();\\n            int x=index.first;\\n            int y=index.second;\\n            sa.pop();\\n            if (x-1>=0&&atlantic[x-1][y]==0&&matrix[x-1][y]>=matrix[x][y]){\\n                sa.push(make_pair(x-1,y));\\n                atlantic[x-1][y]=1;\\n            }\\n            if (x+1<m&&atlantic[x+1][y]==0&&matrix[x+1][y]>=matrix[x][y]){\\n                sa.push(make_pair(x+1,y));\\n                atlantic[x+1][y]=1;\\n            }\\n            if (y-1>=0&&atlantic[x][y-1]==0&&matrix[x][y-1]>=matrix[x][y]){\\n                sa.push(make_pair(x,y-1));\\n                atlantic[x][y-1]=1;\\n            }\\n            if (y+1<n&&atlantic[x][y+1]==0&&matrix[x][y+1]>=matrix[x][y]){\\n                sa.push(make_pair(x,y+1));\\n                atlantic[x][y+1]=1;\\n            }\\n        }\\n        for(int i=0; i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if (atlantic[i][j]==1&&pacific[i][j]==1){\\n                    result.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> result;\\n        int m=matrix.size();\\n        if (m==0) return result;\\n        int n=matrix[0].size();\\n        int pacific[m][n];\\n        int atlantic[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                pacific[i][j]=0;\\n                atlantic[i][j]=0;\\n            }\\n        }\\n        stack<pair<int,int>> sp;\\n        stack<pair<int,int>> sa;\\n        for (int i=0;i<m;i++){\\n            pacific[i][0]=1;\\n            sp.push(make_pair(i,0));\\n        }\\n        for(int i=1;i<n;i++){\\n            pacific[0][i]=1;\\n            sp.push(make_pair(0,i));\\n        }\\n        while(!sp.empty()){\\n            pair<int, int> index=sp.top();\\n            int x=index.first;\\n            int y=index.second;\\n            sp.pop();\\n            if (x-1>=0&&pacific[x-1][y]==0&&matrix[x-1][y]>=matrix[x][y]){\\n                sp.push(make_pair(x-1,y));\\n                pacific[x-1][y]=1;\\n            }\\n            if (x+1<m&&pacific[x+1][y]==0&&matrix[x+1][y]>=matrix[x][y]){\\n                sp.push(make_pair(x+1,y));\\n                pacific[x+1][y]=1;\\n            }\\n            if (y-1>=0&&pacific[x][y-1]==0&&matrix[x][y-1]>=matrix[x][y]){\\n                sp.push(make_pair(x,y-1));\\n                pacific[x][y-1]=1;\\n            }\\n            if (y+1<n&&pacific[x][y+1]==0&&matrix[x][y+1]>=matrix[x][y]){\\n                sp.push(make_pair(x,y+1));\\n                pacific[x][y+1]=1;\\n            }\\n        }\\n        for (int i=0;i<m;i++){\\n            atlantic[i][n-1]=1;\\n            sa.push(make_pair(i,n-1));\\n        }\\n        for(int i=0;i<n-1;i++){\\n            atlantic[m-1][i]=1;\\n            sa.push(make_pair(m-1,i));\\n        }\\n        while(!sa.empty()){\\n            pair<int, int> index=sa.top();\\n            int x=index.first;\\n            int y=index.second;\\n            sa.pop();\\n            if (x-1>=0&&atlantic[x-1][y]==0&&matrix[x-1][y]>=matrix[x][y]){\\n                sa.push(make_pair(x-1,y));\\n                atlantic[x-1][y]=1;\\n            }\\n            if (x+1<m&&atlantic[x+1][y]==0&&matrix[x+1][y]>=matrix[x][y]){\\n                sa.push(make_pair(x+1,y));\\n                atlantic[x+1][y]=1;\\n            }\\n            if (y-1>=0&&atlantic[x][y-1]==0&&matrix[x][y-1]>=matrix[x][y]){\\n                sa.push(make_pair(x,y-1));\\n                atlantic[x][y-1]=1;\\n            }\\n            if (y+1<n&&atlantic[x][y+1]==0&&matrix[x][y+1]>=matrix[x][y]){\\n                sa.push(make_pair(x,y+1));\\n                atlantic[x][y+1]=1;\\n            }\\n        }\\n        for(int i=0; i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if (atlantic[i][j]==1&&pacific[i][j]==1){\\n                    result.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752942,
                "title": "c-dfs-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& heights, vector<vector<bool>>& visited, int i, int j, int prevHeight, bool isPacific, bool isAtlantic) {\\n        if (i < 0 || i >= heights.size() || j < 0 || j >= heights[0].size())\\n            return;\\n        \\n        if (visited[i][j] || heights[i][j] < prevHeight)\\n            return;\\n\\n        visited[i][j] = true;\\n        \\n        if (isPacific && isAtlantic)\\n            return;\\n\\n        dfs(heights, visited, i - 1, j, heights[i][j], isPacific, isAtlantic);\\n        dfs(heights, visited, i + 1, j, heights[i][j], isPacific, isAtlantic);\\n        dfs(heights, visited, i, j - 1, heights[i][j], isPacific, isAtlantic);\\n        dfs(heights, visited, i, j + 1, heights[i][j], isPacific, isAtlantic);\\n    }\\n\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        if (heights.empty() || heights[0].empty())\\n            return {};\\n        \\n        int m = heights.size();\\n        int n = heights[0].size();\\n        \\n        vector<vector<bool>> pacific(m, vector<bool>(n, false));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            dfs(heights, pacific, i, 0, INT_MIN, true, false);\\n            dfs(heights, atlantic, i, n - 1, INT_MIN, false, true);\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            dfs(heights, pacific, 0, j, INT_MIN, true, false);\\n            dfs(heights, atlantic, m - 1, j, INT_MIN, false, true);\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] && atlantic[i][j])\\n                    result.push_back({i, j});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& heights, vector<vector<bool>>& visited, int i, int j, int prevHeight, bool isPacific, bool isAtlantic) {\\n        if (i < 0 || i >= heights.size() || j < 0 || j >= heights[0].size())\\n            return;\\n        \\n        if (visited[i][j] || heights[i][j] < prevHeight)\\n            return;\\n\\n        visited[i][j] = true;\\n        \\n        if (isPacific && isAtlantic)\\n            return;\\n\\n        dfs(heights, visited, i - 1, j, heights[i][j], isPacific, isAtlantic);\\n        dfs(heights, visited, i + 1, j, heights[i][j], isPacific, isAtlantic);\\n        dfs(heights, visited, i, j - 1, heights[i][j], isPacific, isAtlantic);\\n        dfs(heights, visited, i, j + 1, heights[i][j], isPacific, isAtlantic);\\n    }\\n\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        if (heights.empty() || heights[0].empty())\\n            return {};\\n        \\n        int m = heights.size();\\n        int n = heights[0].size();\\n        \\n        vector<vector<bool>> pacific(m, vector<bool>(n, false));\\n        vector<vector<bool>> atlantic(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            dfs(heights, pacific, i, 0, INT_MIN, true, false);\\n            dfs(heights, atlantic, i, n - 1, INT_MIN, false, true);\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            dfs(heights, pacific, 0, j, INT_MIN, true, false);\\n            dfs(heights, atlantic, m - 1, j, INT_MIN, false, true);\\n        }\\n        \\n        vector<vector<int>> result;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] && atlantic[i][j])\\n                    result.push_back({i, j});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590284,
                "title": "solving-in-reverse-order-by-using-connected-componenet-dfs",
                "content": "# Intuition\\nSolving in reverse order will be more easy. as all the 4 corner can git into nearest oncean. So we will find connected indexes from those by the help of dfs/bfs.\\n\\nnow all the indexes will be 1 if that is visited else 0.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Solve the reverse version of this problem\\n\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n\\n    void dfs(int x,int y, vector<vector<int>> &adj,vector<vector<int>> &vis){\\n        vis[x][y]=1;\\n        \\n        for(int i=0;i<4;i+=1){\\n            int x1= dx[i]+x,y1=dy[i]+y;\\n\\n            if(x1>=0 && y1>=0 && x1<adj.size() && y1<adj[0].size() && !vis[x1][y1] && adj[x1][y1] >= adj[x][y]){\\n                dfs(x1,y1,adj,vis);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& adj) {\\n        int n=adj.size(),m=adj[0].size();\\n\\n        vector<vector<int>> atlantic(n,vector<int>(m,0)),pacific(n,vector<int>(m,0));\\n        for(int i=0;i<m;i+=1){\\n            /* now here atalantic will store all the indexes which can go in pacific */\\n            dfs(0,i,adj,pacific);\\n            \\n            /* now it will give all the indexes which can go into atlantic */\\n            dfs(n-1,i,adj,atlantic);\\n        }\\n\\n        for(int i=0;i<n;i+=1){\\n            /* for pacific */\\n            dfs(i,0,adj,pacific);\\n\\n            /* for atlantic */\\n            dfs(i,m-1,adj,atlantic);\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i+=1){\\n            for(int j=0;j<m;j+=1){\\n                if(atlantic [i][j] == pacific[i][j] && pacific[i][j]==1){\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASEEE UPVOTE IF IT HELPED",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Solve the reverse version of this problem\\n\\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n\\n    void dfs(int x,int y, vector<vector<int>> &adj,vector<vector<int>> &vis){\\n        vis[x][y]=1;\\n        \\n        for(int i=0;i<4;i+=1){\\n            int x1= dx[i]+x,y1=dy[i]+y;\\n\\n            if(x1>=0 && y1>=0 && x1<adj.size() && y1<adj[0].size() && !vis[x1][y1] && adj[x1][y1] >= adj[x][y]){\\n                dfs(x1,y1,adj,vis);\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& adj) {\\n        int n=adj.size(),m=adj[0].size();\\n\\n        vector<vector<int>> atlantic(n,vector<int>(m,0)),pacific(n,vector<int>(m,0));\\n        for(int i=0;i<m;i+=1){\\n            /* now here atalantic will store all the indexes which can go in pacific */\\n            dfs(0,i,adj,pacific);\\n            \\n            /* now it will give all the indexes which can go into atlantic */\\n            dfs(n-1,i,adj,atlantic);\\n        }\\n\\n        for(int i=0;i<n;i+=1){\\n            /* for pacific */\\n            dfs(i,0,adj,pacific);\\n\\n            /* for atlantic */\\n            dfs(i,m-1,adj,atlantic);\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i+=1){\\n            for(int j=0;j<m;j+=1){\\n                if(atlantic [i][j] == pacific[i][j] && pacific[i][j]==1){\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579806,
                "title": "c-very-very-easy-solution-o-m-n-complexity-beats-66",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the island, the left and top most cells can automatically reach the Pacific ocean. Likewise, the right and bottom most cells can automatically reach the Atlantic ocean. So, we have to find the indexes of intersection of both.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- As the left and top most cells can automatically reach the Pacific ocean and the right and bottom most cells can automatically reach the Atlantic ocean, we have to declare two vectors to store reachable cells for each ocean.\\n- The process can be generalized into a single function ```getReachable()```.\\n- As we iterate through the island after the process, if the current cell is reachable from both the oceans, it is an possible answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case is if every cell is reachable for both the oceans, ```O(m*n)``` will be the time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs vectors for pacific and atlantic oceans are stored, ```O(m*n)``` will be the space complexity.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m = heights.size(), n = heights[0].size();\\n\\n        // To store all reachable cells for pacific and atlantic\\n        vector<vector<int>> pacific(m, vector<int>(n, -1)), atlantic(m, vector<int>(n, -1));\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                // The left and top cells can reach pacific ocean\\n                if(i==0 || j==0) getReachable(heights, pacific, i, j, m, n);\\n                // The right and bottom cells can reach atlantic ocean\\n                if(i==m-1 || j==n-1) getReachable(heights, atlantic, i, j, m, n);\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                // If the current cell can reach both the oceans, then it is an answer\\n                if(pacific[i][j]==1 && atlantic[i][j]==1) {\\n                    ans.push_back(vector<int>{i, j});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\nprivate:\\n    void getReachable(vector<vector<int>>& heights, vector<vector<int>>& ocean, int i, int j, int m, int n) {\\n        // Ocean is taken as a parameter to generalize both pacific and atlantic oceans, the ocean used as parameter will the current ocean\\n\\n        // If the cell is out of bounds, return\\n        if(!isReachable(i, j, m, n) || ocean[i][j]!=-1) return;\\n\\n        // Mark current cell as reachable for current ocean\\n        ocean[i][j] = 1;\\n\\n        // If any neighbouring cell is in bounds and the height is greater than current height, it can reach current ocean\\n        if(isReachable(i-1, j, m, n) && heights[i-1][j]>=heights[i][j]) getReachable(heights, ocean, i-1, j, m, n);\\n        if(isReachable(i+1, j, m, n) && heights[i+1][j]>=heights[i][j]) getReachable(heights, ocean, i+1, j, m, n);\\n        if(isReachable(i, j-1, m, n) && heights[i][j-1]>=heights[i][j]) getReachable(heights, ocean, i, j-1, m, n);\\n        if(isReachable(i, j+1, m, n) && heights[i][j+1]>=heights[i][j]) getReachable(heights, ocean, i, j+1, m, n);\\n    }\\n\\n    // Return if the cell is in bounds or not\\n    bool isReachable(int i, int j, int m, int n) {\\n        if(i<0 || j<0 || i>=m || j>=n) return false;\\n        return true;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/ff401015-7515-4a34-a51d-bdbb837f02bc_1685470787.9153085.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```getReachable()```\n```O(m*n)```\n```O(m*n)```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m = heights.size(), n = heights[0].size();\\n\\n        // To store all reachable cells for pacific and atlantic\\n        vector<vector<int>> pacific(m, vector<int>(n, -1)), atlantic(m, vector<int>(n, -1));\\n\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                // The left and top cells can reach pacific ocean\\n                if(i==0 || j==0) getReachable(heights, pacific, i, j, m, n);\\n                // The right and bottom cells can reach atlantic ocean\\n                if(i==m-1 || j==n-1) getReachable(heights, atlantic, i, j, m, n);\\n            }\\n        }\\n\\n        vector<vector<int>> ans;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                // If the current cell can reach both the oceans, then it is an answer\\n                if(pacific[i][j]==1 && atlantic[i][j]==1) {\\n                    ans.push_back(vector<int>{i, j});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\nprivate:\\n    void getReachable(vector<vector<int>>& heights, vector<vector<int>>& ocean, int i, int j, int m, int n) {\\n        // Ocean is taken as a parameter to generalize both pacific and atlantic oceans, the ocean used as parameter will the current ocean\\n\\n        // If the cell is out of bounds, return\\n        if(!isReachable(i, j, m, n) || ocean[i][j]!=-1) return;\\n\\n        // Mark current cell as reachable for current ocean\\n        ocean[i][j] = 1;\\n\\n        // If any neighbouring cell is in bounds and the height is greater than current height, it can reach current ocean\\n        if(isReachable(i-1, j, m, n) && heights[i-1][j]>=heights[i][j]) getReachable(heights, ocean, i-1, j, m, n);\\n        if(isReachable(i+1, j, m, n) && heights[i+1][j]>=heights[i][j]) getReachable(heights, ocean, i+1, j, m, n);\\n        if(isReachable(i, j-1, m, n) && heights[i][j-1]>=heights[i][j]) getReachable(heights, ocean, i, j-1, m, n);\\n        if(isReachable(i, j+1, m, n) && heights[i][j+1]>=heights[i][j]) getReachable(heights, ocean, i, j+1, m, n);\\n    }\\n\\n    // Return if the cell is in bounds or not\\n    bool isReachable(int i, int j, int m, int n) {\\n        if(i<0 || j<0 || i>=m || j>=n) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465521,
                "title": "dfs-graph-solution",
                "content": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        rows,cols=len(heights),len(heights[0])\\n        pac,atl=set(),set()\\n        def dfs(r,c,visit,preheight):\\n            if ((r,c) in visit or r<0 or c<0 or r==rows or c==cols or heights[r][c]<preheight):\\n                return \\n            visit.add((r,c))\\n            dfs(r+1,c,visit,heights[r][c])\\n            dfs(r-1,c,visit,heights[r][c])\\n            dfs(r,c+1,visit,heights[r][c])\\n            dfs(r,c-1,visit,heights[r][c])\\n        for c in range(cols):\\n            dfs(0,c,pac,heights[0][c])\\n            dfs(rows-1,c,atl,heights[rows-1][c])\\n        for r in range(rows):\\n            dfs(r,0,pac,heights[r][0])\\n            dfs(r,cols-1,atl,heights[r][cols-1])\\n        list1=[]\\n        for r in range(rows):\\n            for c in range(cols):\\n                if (r,c) in pac and (r,c) in atl:\\n                    list1.append([r,c])\\n        return list1\\n   ```\\n   # please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        rows,cols=len(heights),len(heights[0])\\n        pac,atl=set(),set()\\n        def dfs(r,c,visit,preheight):\\n            if ((r,c) in visit or r<0 or c<0 or r==rows or c==cols or heights[r][c]<preheight):\\n                return \\n            visit.add((r,c))\\n            dfs(r+1,c,visit,heights[r][c])\\n            dfs(r-1,c,visit,heights[r][c])\\n            dfs(r,c+1,visit,heights[r][c])\\n            dfs(r,c-1,visit,heights[r][c])\\n        for c in range(cols):\\n            dfs(0,c,pac,heights[0][c])\\n            dfs(rows-1,c,atl,heights[rows-1][c])\\n        for r in range(rows):\\n            dfs(r,0,pac,heights[r][0])\\n            dfs(r,cols-1,atl,heights[r][cols-1])\\n        list1=[]\\n        for r in range(rows):\\n            for c in range(cols):\\n                if (r,c) in pac and (r,c) in atl:\\n                    list1.append([r,c])\\n        return list1\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3408469,
                "title": "unique-compact-and-fast-3ms-99-solution-with-explanation",
                "content": "# Intuition\\nDFS\\n\\n# Approach\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. The pacificAtlantic method is the entry point of the solution. It takes the heights matrix as input and returns a list of lists of integers representing the coordinates of the cells where water can flow to both oceans.\\n\\n2. The visited matrix is a 2D array of integers with the same dimensions as the heights matrix, used to keep track of visited cells. It is initialized with all values set to 0.\\n\\n3. The ans list is used to store the final result - the list of lists of coordinates.\\n\\n4. The first two nested loops iterate over the first and last row of the heights matrix, and the dfs method is called for each cell in these rows. The dfs method is called with the row index, column index, heights matrix, visited matrix, mark (1 or 2) representing which ocean the water is flowing to, current height of the cell, and the ans list.\\n\\n5. The second pair of nested loops iterate over the first and last column of the heights matrix, and the dfs method is called for each cell in these columns, similar to step 4.\\n\\n6. The dfs method is a recursive function that performs the depth-first search. It takes the current row index, column index, heights matrix, visited matrix, mark, current height of the cell, and the ans list as input.\\n\\n7. The dfs method starts by checking if the current cell is out of bounds (i.e., row or column index is less than 0 or greater than or equal to the dimensions of the heights matrix), or if the height of the current cell is less than the height of the previous cell (i.e., water can\\'t flow uphill), or if the current cell has already been visited by the same ocean (mark) or by both oceans (mark=3). If any of these conditions are true, the function returns early and does not further explore the current cell.\\n\\n8. If the current cell passes the above checks, it is marked as visited by adding the mark to the visited matrix at the current row and column index.\\n\\n9. If the current cell has been visited by both oceans (mark=3), its coordinates (row and column index) are added to the ans list as a new list of integers representing the coordinates.\\n\\n10. The dfs method is then recursively called for the neighboring cells (up, down, left, and right) of the current cell, passing the updated row and column indices, mark, and the height of the current cell.\\n\\n11. After the DFS traversal is complete, the ans list contains the coordinates of the cells where water can flow to both oceans.\\n\\n12. Finally, the ans list is returned as the solution to the problem.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int visited[][] = new int[heights.length][heights[0].length];\\n        List<List<Integer>>ans =  new ArrayList<>();\\n        for(int i=0;i<heights[0].length;i++){\\n            dfs(0,i,heights,visited,1,heights[0][i],ans);\\n            dfs(heights.length-1,i,heights,visited,2,heights[heights.length-1][i],ans);\\n        }\\n        for(int i=0;i<heights.length;i++){\\n            dfs(i,0,heights,visited,1,heights[i][0],ans);\\n            dfs(i,heights[0].length-1,heights,visited,2,heights[i][heights[0].length-1],ans);\\n        }\\n        return ans;\\n    }\\n    private void dfs(int i , int j ,int[][] heights, int[][] visited, int mark, int ch, List<List<Integer>> ans){\\n        if(i<0 || j<0 || i>=heights.length || j>=heights[0].length || heights[i][j]<ch || visited[i][j]==mark || visited[i][j]==3) return ;\\n        visited[i][j]+=mark;\\n        if(visited[i][j]==3){\\n            ans.add(new ArrayList<>(Arrays.asList(i,j)));\\n        }\\n        dfs(i+1,j,heights,visited,mark,heights[i][j],ans);\\n        dfs(i,j+1,heights,visited,mark,heights[i][j],ans);\\n        dfs(i-1,j,heights,visited,mark,heights[i][j],ans);\\n        dfs(i,j-1,heights,visited,mark,heights[i][j],ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int visited[][] = new int[heights.length][heights[0].length];\\n        List<List<Integer>>ans =  new ArrayList<>();\\n        for(int i=0;i<heights[0].length;i++){\\n            dfs(0,i,heights,visited,1,heights[0][i],ans);\\n            dfs(heights.length-1,i,heights,visited,2,heights[heights.length-1][i],ans);\\n        }\\n        for(int i=0;i<heights.length;i++){\\n            dfs(i,0,heights,visited,1,heights[i][0],ans);\\n            dfs(i,heights[0].length-1,heights,visited,2,heights[i][heights[0].length-1],ans);\\n        }\\n        return ans;\\n    }\\n    private void dfs(int i , int j ,int[][] heights, int[][] visited, int mark, int ch, List<List<Integer>> ans){\\n        if(i<0 || j<0 || i>=heights.length || j>=heights[0].length || heights[i][j]<ch || visited[i][j]==mark || visited[i][j]==3) return ;\\n        visited[i][j]+=mark;\\n        if(visited[i][j]==3){\\n            ans.add(new ArrayList<>(Arrays.asList(i,j)));\\n        }\\n        dfs(i+1,j,heights,visited,mark,heights[i][j],ans);\\n        dfs(i,j+1,heights,visited,mark,heights[i][j],ans);\\n        dfs(i-1,j,heights,visited,mark,heights[i][j],ans);\\n        dfs(i,j-1,heights,visited,mark,heights[i][j],ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194894,
                "title": "simple-python-easy-solution-using-depth-first-search-100-working",
                "content": "# Intuition\\nWe\\'ll start from the edge and use depth first search to find out if the height of adjacent element is greater than or equal to the current. If so, we\\'ll proceed forward till we reach to atlantic and pacific ocean.\\n# Code\\n```\\nclass Solution(object):\\n    def pacificAtlantic(self, heights):\\n        \"\"\"\\n        :type heights: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        rows,cols=len(heights),len(heights[0])\\n        pac,atl=set(),set()\\n        def dfs(r,c,visit,prevHeight):\\n            if ((r,c) in visit or r<0 or c<0 or c==cols or r==rows or heights[r][c]<prevHeight):\\n                return\\n            visit.add((r,c))\\n            dfs(r+1,c,visit,heights[r][c])\\n            dfs(r-1,c,visit,heights[r][c])\\n            dfs(r,c+1,visit,heights[r][c])\\n            dfs(r,c-1,visit,heights[r][c])\\n        for c in range(cols):\\n            dfs(0,c,pac,heights[0][c])\\n            dfs(rows-1,c,atl,heights[rows-1][c])\\n        for r in range(rows):\\n            dfs(r,0,pac,heights[r][0])\\n            dfs(r,cols-1,atl,heights[r][cols-1])\\n        res=[]\\n        for r in range(rows):\\n            for c in range(cols):\\n                if (r,c) in pac and (r,c) in atl:\\n                    res.append([r,c])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def pacificAtlantic(self, heights):\\n        \"\"\"\\n        :type heights: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        rows,cols=len(heights),len(heights[0])\\n        pac,atl=set(),set()\\n        def dfs(r,c,visit,prevHeight):\\n            if ((r,c) in visit or r<0 or c<0 or c==cols or r==rows or heights[r][c]<prevHeight):\\n                return\\n            visit.add((r,c))\\n            dfs(r+1,c,visit,heights[r][c])\\n            dfs(r-1,c,visit,heights[r][c])\\n            dfs(r,c+1,visit,heights[r][c])\\n            dfs(r,c-1,visit,heights[r][c])\\n        for c in range(cols):\\n            dfs(0,c,pac,heights[0][c])\\n            dfs(rows-1,c,atl,heights[rows-1][c])\\n        for r in range(rows):\\n            dfs(r,0,pac,heights[r][0])\\n            dfs(r,cols-1,atl,heights[r][cols-1])\\n        res=[]\\n        for r in range(rows):\\n            for c in range(cols):\\n                if (r,c) in pac and (r,c) in atl:\\n                    res.append([r,c])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188347,
                "title": "c-plane-easy-bfs-heavily-commented-intuitive-the-striver-s-way",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        \\n        int N=mat.size();\\n        int M=mat[0].size();\\n        \\n         \\n        vector<vector<int>> visa(N,vector<int>(M,0)); //visited matrix for atlantic ocean\\n        vector<vector<int>> visi(N,vector<int>(M,0)); //visited matrix for pacific ocean\\n            \\n         \\n        queue<pair<int,int>> mqa;   //queue for storing the edge cells that  directly touch the atlantic ocean\\n         \\n        for(int i=0;i<N;i++){\\n            mqa.push({i,M-1});      //pushing the edge cells into queue and marking them as visited\\n            visa[i][M-1]=1;\\n        }\\n        for(int i=0;i<M;i++){\\n            mqa.push({N-1,i});\\n            visa[N-1][i]=1;\\n        }\\n         \\n         while(!mqa.empty()){\\n             \\n             int r=mqa.front().first;\\n             int c=mqa.front().second;\\n             mqa.pop();\\n             \\n             for(int delr=-1;delr<=1;delr++){         // A way to traverrse in four directions ,it\\'s my way you can \\n                 for(int delc=-1;delc<=1;delc++){     //  do as you like\\n                     if(delr==0||delc==0){\\n                         int nr=r+delr;\\n                         int nc=c+delc;\\n                         if(nr>=0&&nr<N&&nc>=0&&nc<M){\\n                             if(!visa[nr][nc]&&mat[nr][nc]>=mat[r][c]){\\n                                \\n                                 visa[nr][nc]=1;\\n                                 mqa.push({nr,nc});\\n                             }\\n                         }\\n                     }\\n                 }\\n             }\\n         }\\n    \\n        for(int i=0;i<N;i++){                         // Same thing for pacific ocean  \\n             mqa.push({i,0});                         // Can take the same queue as it is empty now\\n             visi[i][0]=1;\\n         }\\n         for(int i=0;i<M;i++){\\n             mqa.push({0,i});\\n             visi[0][i]=1;\\n         }\\n        while(!mqa.empty()){\\n             \\n             int r=mqa.front().first;\\n             int c=mqa.front().second;\\n             mqa.pop();\\n\\n             for(int delr=-1;delr<=1;delr++){\\n                 for(int delc=-1;delc<=1;delc++){\\n                     if(delr==0||delc==0){\\n                         int nr=r+delr;\\n                         int nc=c+delc;\\n                         if(nr>=0&&nr<N&&nc>=0&&nc<M){\\n                             if(!visi[nr][nc]&&mat[nr][nc]>=mat[r][c]){\\n                                \\n                                 visi[nr][nc]=1;\\n                                 mqa.push({nr,nc});\\n                             }\\n                         }\\n                     }\\n                 }\\n             }\\n         }\\n         \\n        \\n         vector<vector<int>> fin;    \\n                                                \\n         for(int i=0;i<N;i++){                   //In the two visited matrices where both the cells are marked as \\n             for(int j=0;j<M;j++){                    // 1 will contribute to the answer\\n                 if(visa[i][j]==1&&visi[i][j]==1){\\n                     fin.push_back({i,j});\\n                 }\\n             }\\n         }return fin;\\n         \\n         \\n    \\n    \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        \\n        int N=mat.size();\\n        int M=mat[0].size();\\n        \\n         \\n        vector<vector<int>> visa(N,vector<int>(M,0)); //visited matrix for atlantic ocean\\n        vector<vector<int>> visi(N,vector<int>(M,0)); //visited matrix for pacific ocean\\n            \\n         \\n        queue<pair<int,int>> mqa;   //queue for storing the edge cells that  directly touch the atlantic ocean\\n         \\n        for(int i=0;i<N;i++){\\n            mqa.push({i,M-1}",
                "codeTag": "Java"
            },
            {
                "id": 2887984,
                "title": "dfs-dp-simple-explanation-with-code-documentation-c",
                "content": "> #### *Very Very important for understanding the concept of dfs+dp and usage of 2D vector*\\n# Intuition \\nThis problem\\'s trick is to understand, from where we have to run dfs and how to memoization in our favour.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* In this problem, we can run **_dfs_** only on the **row and column** which are directly in touch with pacific ocean and according to condition which cell we can visit we will memoize it using a dp array(visited array) and in another array of dp(path array) we\\'ll **permantly store the path we are travelling with an increment 1**.\\n* Then we\\'ll run dfs only for the atlantic ocean touched row and column and also memozie it which path we are traveling (but we have to remember that before running dfs in these cells, we have to **initialize the visited array (dp array) by 0**..and we\\'ll also do increment on the parmanent path array..\\n* Now in the path array(dp) in which cell, the acquired value is 2, that means from there we can go to both ocean.\\n* Then we have to collect and store the indices of the path array which are 2 in a 2D vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity**: \\n$O(m*n)$, in worst case, all cells are reachable to both oceans and would be visited twice. This case can occur when all elements are equal.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- **Space complexity:**\\n$O(m*n)$, to mark the atlantic and pacific visited cells.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[205][205]; //to check visited or not\\n    void dfs(int i, int j,int prevVal, vector<vector<int>>& heights, vector<vector<int>>& path){\\n        vector<int>v;\\n        if(i<0 || j<0 || i>=heights.size() || j>=heights[0].size()) return;\\n        if(heights[i][j] < prevVal) return ;\\n        if(dp[i][j] != 0) return;\\n        path[i][j]++;\\n        dp[i][j]=1;\\n\\n        dfs(i, j+1, heights[i][j], heights, path);\\n        dfs(i, j-1, heights[i][j], heights, path);\\n        dfs(i+1, j, heights[i][j], heights, path);\\n        dfs(i-1, j, heights[i][j], heights, path);\\n\\n\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        vector<vector<int>> path(205, vector<int>(205, 0)); //permanantly storing the visiting cell\\n        vector<vector<int>> ans;\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0;i<heights.size(); i++){\\n            for(int j=0; j<heights[i].size(); j++){\\n                if(i==0 || j==0){\\n                    dfs(i, j, -1, heights, path);\\n                }         \\n            }\\n        }\\n        memset(dp, 0, sizeof(dp)); //initializing the dp array with 0 again\\n        for(int i=0;i<heights.size(); i++){\\n            for(int j=0; j<heights[i].size(); j++){\\n                if(i==heights.size()-1 || j==heights[0].size()-1){\\n                    dfs(i, j, -1, heights, path);\\n                }\\n\\n            }\\n        }\\n        //storing the indices to a 2D vector\\n        for(int i=0;i<heights.size();i++){\\n            for(int j=0;j<heights[0].size();j++){\\n                vector<int>v;\\n                if(path[i][j]==2){\\n                    v.push_back(i);\\n                    v.push_back(j);\\n                    ans.push_back(v); //if we put this line out of the if condition, there\\'ll be stored some unnecessary null vector?\\n                }\\n                v.clear();\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Brainteaser",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[205][205]; //to check visited or not\\n    void dfs(int i, int j,int prevVal, vector<vector<int>>& heights, vector<vector<int>>& path){\\n        vector<int>v;\\n        if(i<0 || j<0 || i>=heights.size() || j>=heights[0].size()) return;\\n        if(heights[i][j] < prevVal) return ;\\n        if(dp[i][j] != 0) return;\\n        path[i][j]++;\\n        dp[i][j]=1;\\n\\n        dfs(i, j+1, heights[i][j], heights, path);\\n        dfs(i, j-1, heights[i][j], heights, path);\\n        dfs(i+1, j, heights[i][j], heights, path);\\n        dfs(i-1, j, heights[i][j], heights, path);\\n\\n\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        vector<vector<int>> path(205, vector<int>(205, 0)); //permanantly storing the visiting cell\\n        vector<vector<int>> ans;\\n        memset(dp, 0, sizeof(dp));\\n        for(int i=0;i<heights.size(); i++){\\n            for(int j=0; j<heights[i].size(); j++){\\n                if(i==0 || j==0){\\n                    dfs(i, j, -1, heights, path);\\n                }         \\n            }\\n        }\\n        memset(dp, 0, sizeof(dp)); //initializing the dp array with 0 again\\n        for(int i=0;i<heights.size(); i++){\\n            for(int j=0; j<heights[i].size(); j++){\\n                if(i==heights.size()-1 || j==heights[0].size()-1){\\n                    dfs(i, j, -1, heights, path);\\n                }\\n\\n            }\\n        }\\n        //storing the indices to a 2D vector\\n        for(int i=0;i<heights.size();i++){\\n            for(int j=0;j<heights[0].size();j++){\\n                vector<int>v;\\n                if(path[i][j]==2){\\n                    v.push_back(i);\\n                    v.push_back(j);\\n                    ans.push_back(v); //if we put this line out of the if condition, there\\'ll be stored some unnecessary null vector?\\n                }\\n                v.clear();\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877980,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS 2D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m, vis[205][205];\\n    bool pacific, atlantic;\\n    vector<vector<int>> grids;\\n\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n+2 and y >= 0 and y < m+2 and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void dfs(int x, int y) {\\n        vis[x][y] = 1;\\n        if(x == 0 or y == 0) {\\n            pacific = 1;\\n            return;\\n        }\\n        if(x == n+1 or y == m+1) {\\n            atlantic = 1;\\n            return;\\n        }\\n        if(valid(x+1, y) and grids[x][y] >= grids[x+1][y]) dfs(x+1, y);\\n        if(valid(x-1, y) and grids[x][y] >= grids[x-1][y]) dfs(x-1, y);\\n        if(valid(x, y+1) and grids[x][y] >= grids[x][y+1]) dfs(x, y+1);\\n        if(valid(x, y-1) and grids[x][y] >= grids[x][y-1]) dfs(x, y-1);\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        n = heights.size(), m = heights[0].size();\\n        vector<vector<int>> tmp(205, vector<int> (205, 0));\\n        grids = tmp;\\n        for(int i=1; i<=n; i++) for(int j=1; j<=m; j++) grids[i][j] = heights[i-1][j-1];\\n\\n        vector<vector<int>> ans;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                memset(vis, 0, sizeof(vis));\\n                pacific = 0, atlantic = 0;\\n                dfs(i, j);\\n                if(pacific and atlantic) ans.push_back({i-1, j-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m, vis[205][205];\\n    bool pacific, atlantic;\\n    vector<vector<int>> grids;\\n\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n+2 and y >= 0 and y < m+2 and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void dfs(int x, int y) {\\n        vis[x][y] = 1;\\n        if(x == 0 or y == 0) {\\n            pacific = 1;\\n            return;\\n        }\\n        if(x == n+1 or y == m+1) {\\n            atlantic = 1;\\n            return;\\n        }\\n        if(valid(x+1, y) and grids[x][y] >= grids[x+1][y]) dfs(x+1, y);\\n        if(valid(x-1, y) and grids[x][y] >= grids[x-1][y]) dfs(x-1, y);\\n        if(valid(x, y+1) and grids[x][y] >= grids[x][y+1]) dfs(x, y+1);\\n        if(valid(x, y-1) and grids[x][y] >= grids[x][y-1]) dfs(x, y-1);\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        n = heights.size(), m = heights[0].size();\\n        vector<vector<int>> tmp(205, vector<int> (205, 0));\\n        grids = tmp;\\n        for(int i=1; i<=n; i++) for(int j=1; j<=m; j++) grids[i][j] = heights[i-1][j-1];\\n\\n        vector<vector<int>> ans;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                memset(vis, 0, sizeof(vis));\\n                pacific = 0, atlantic = 0;\\n                dfs(i, j);\\n                if(pacific and atlantic) ans.push_back({i-1, j-1});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840373,
                "title": "readable-javascript-dfs-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} heights\\n * @return {number[][]}\\n */\\nvar pacificAtlantic = function(heights) {\\n    let ROWS = heights.length \\n    let COLS = heights[0].length\\n    let pac = new Set()\\n    let atl = new Set()\\n    let res = []\\n\\n    function dfs(r, c, visit, prevHeight) {\\n        if (Math.min(r,c) < 0 || r >= ROWS || c >= COLS || heights[r][c] < prevHeight || visit.has(r + \\'-\\' + c)) { //Checks for invalid entries\\n            return \\n        }\\n\\n        visit.add(r + \\'-\\' + c) //Valid entries gets added to set\\n        dfs(r + 1, c, visit, heights[r][c]) //Checks neighbors\\n        dfs(r - 1, c, visit, heights[r][c])\\n        dfs(r, c + 1, visit, heights[r][c])\\n        dfs(r, c - 1, visit, heights[r][c])\\n    }\\n\\n    for (let c = 0; c < COLS; c++) { \\n        dfs(0, c, pac, heights[0][c]) //Top\\n        dfs(ROWS - 1, c, atl, heights[ROWS - 1][c]) //Bottom\\n    }\\n\\n    for (let r = 0; r < ROWS; r++) { \\n        dfs(r, 0, pac, heights[r][0]) //Left\\n        dfs(r, COLS - 1, atl, heights[r][COLS - 1]) //Right\\n    }\\n\\n    for (let r = 0; r < ROWS; r++) { //Checks for collisions\\n        for (let c = 0; c < COLS; c++) {\\n            if (pac.has(r + \\'-\\' + c) && atl.has(r + \\'-\\' + c)) { //If both sets have the same values\\n                res.push([r,c]) //Push coord to res\\n            }\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} heights\\n * @return {number[][]}\\n */\\nvar pacificAtlantic = function(heights) {\\n    let ROWS = heights.length \\n    let COLS = heights[0].length\\n    let pac = new Set()\\n    let atl = new Set()\\n    let res = []\\n\\n    function dfs(r, c, visit, prevHeight) {\\n        if (Math.min(r,c) < 0 || r >= ROWS || c >= COLS || heights[r][c] < prevHeight || visit.has(r + \\'-\\' + c)) { //Checks for invalid entries\\n            return \\n        }\\n\\n        visit.add(r + \\'-\\' + c) //Valid entries gets added to set\\n        dfs(r + 1, c, visit, heights[r][c]) //Checks neighbors\\n        dfs(r - 1, c, visit, heights[r][c])\\n        dfs(r, c + 1, visit, heights[r][c])\\n        dfs(r, c - 1, visit, heights[r][c])\\n    }\\n\\n    for (let c = 0; c < COLS; c++) { \\n        dfs(0, c, pac, heights[0][c]) //Top\\n        dfs(ROWS - 1, c, atl, heights[ROWS - 1][c]) //Bottom\\n    }\\n\\n    for (let r = 0; r < ROWS; r++) { \\n        dfs(r, 0, pac, heights[r][0]) //Left\\n        dfs(r, COLS - 1, atl, heights[r][COLS - 1]) //Right\\n    }\\n\\n    for (let r = 0; r < ROWS; r++) { //Checks for collisions\\n        for (let c = 0; c < COLS; c++) {\\n            if (pac.has(r + \\'-\\' + c) && atl.has(r + \\'-\\' + c)) { //If both sets have the same values\\n                res.push([r,c]) //Push coord to res\\n            }\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2833674,
                "title": "c-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int x, int y, int num, vector<vector<int>>& v, vector<vector<int>>& heights){\\n\\t\\t\\tif(x<0 || x>=heights.size() || y<0 || y>=heights[0].size() || heights[x][y]<num || v[x][y]){return;}\\n\\t\\t\\tv[x][y]=1;\\n\\t\\t\\tdfs(x-1, y, heights[x][y], v, heights);\\n\\t\\t\\tdfs(x, y-1, heights[x][y], v, heights);\\n\\t\\t\\tdfs(x+1, y, heights[x][y], v, heights);\\n\\t\\t\\tdfs(x, y+1, heights[x][y], v, heights);\\n\\t\\t}\\n\\t\\tvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n\\t\\t\\tvector<vector<int>>v1(heights.size(), vector<int>(heights[0].size(), 0));\\n\\t\\t\\tvector<vector<int>>v2(heights.size(), vector<int>(heights[0].size(), 0));\\n\\t\\t\\tfor(int i=0; i<heights.size(); i++){\\n\\t\\t\\t\\tif(!v1[i][0]){dfs(i, 0, heights[i][0], v1, heights);}\\n\\t\\t\\t\\tif(!v2[i][heights[0].size()-1]){dfs(i, heights[0].size()-1, heights[i][heights[0].size()-1], v2, heights);}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<heights[0].size(); i++){\\n\\t\\t\\t\\tif(!v1[0][i]){dfs(0, i, heights[0][i], v1, heights);}\\n\\t\\t\\t\\tif(!v2[heights.size()-1][i]){dfs(heights.size()-1, i, heights[heights.size()-1][i], v2, heights);}\\n\\t\\t\\t}\\n\\t\\t\\t// for(int i=0; i<heights.size(); i++){\\n\\t\\t\\t//     for(int j=0; j<heights[0].size(); j++){\\n\\t\\t\\t//         cout<<v1[i][j]<<\" \";\\n\\t\\t\\t//     }cout<<endl;\\n\\t\\t\\t// }cout<<endl;\\n\\t\\t\\t// for(int i=0; i<heights.size(); i++){\\n\\t\\t\\t//     for(int j=0; j<heights[0].size(); j++){\\n\\t\\t\\t//         cout<<v2[i][j]<<\" \";\\n\\t\\t\\t//     }cout<<endl;\\n\\t\\t\\t// }\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tfor(int i=0; i<heights.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<heights[0].size(); j++){\\n\\t\\t\\t\\t\\tif(v1[i][j] && v2[i][j]){\\n\\t\\t\\t\\t\\t\\tans.push_back({i, j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int x, int y, int num, vector<vector<int>>& v, vector<vector<int>>& heights){\\n\\t\\t\\tif(x<0 || x>=heights.size() || y<0 || y>=heights[0].size() || heights[x][y]<num || v[x][y]){return;}",
                "codeTag": "Java"
            },
            {
                "id": 2526551,
                "title": "clean-dfs-solution-with-minimum-number-of-recursive-calls-in-c",
                "content": "Time Complexity = O(N * M)\\nSpace Complexity = O(N * M)\\n\\n```\\nclass Solution {\\npublic:\\n/*\\n    TC: O(N*M)\\n    SC: O(N*M)\\n*/\\n    \\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    \\n    bool valid(int i, int j, int n, int m){\\n        return i >= 0 && i < n && j >= 0 && j < m;\\n    }\\n    \\n    void DFS(vector<vector<int>>& heights, int i, int j, int prev,vector<vector<bool>>& anyOcean){\\n        if(heights[i][j] < prev || anyOcean[i][j]) return;\\n        anyOcean[i][j] = true;\\n        for(int k = 0; k < 4; k++){\\n            int row = dx[k] + i;\\n            int col = dy[k] + j;\\n            if(valid(row, col, heights.size(), heights[0].size()) && !anyOcean[row][col])\\n                DFS(heights, row, col, heights[i][j], anyOcean);\\n        }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int n = heights.size(), m = heights[0].size();\\n        vector<vector<int>> res;\\n        vector<vector<bool>> atlantic(n, vector<bool>(m)), pacific(n, vector<bool>(m));\\n        \\n        // check for columns\\n        for(int i = 0; i < m; i++){\\n            DFS(heights, 0, i, INT_MIN, pacific);\\n            DFS(heights, n-1, i, INT_MIN, atlantic);\\n        }\\n        \\n        // check for rows\\n        for(int i = 0; i < n; i++){\\n            DFS(heights, i, 0, INT_MIN, pacific);\\n            DFS(heights, i, m-1, INT_MIN, atlantic);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(atlantic[i][j] && pacific[i][j])\\n                    res.push_back({i, j});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\n    TC: O(N*M)\\n    SC: O(N*M)\\n*/\\n    \\n    vector<int> dx = {-1, 1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    \\n    bool valid(int i, int j, int n, int m){\\n        return i >= 0 && i < n && j >= 0 && j < m;\\n    }\\n    \\n    void DFS(vector<vector<int>>& heights, int i, int j, int prev,vector<vector<bool>>& anyOcean){\\n        if(heights[i][j] < prev || anyOcean[i][j]) return;\\n        anyOcean[i][j] = true;\\n        for(int k = 0; k < 4; k++){\\n            int row = dx[k] + i;\\n            int col = dy[k] + j;\\n            if(valid(row, col, heights.size(), heights[0].size()) && !anyOcean[row][col])\\n                DFS(heights, row, col, heights[i][j], anyOcean);\\n        }\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int n = heights.size(), m = heights[0].size();\\n        vector<vector<int>> res;\\n        vector<vector<bool>> atlantic(n, vector<bool>(m)), pacific(n, vector<bool>(m));\\n        \\n        // check for columns\\n        for(int i = 0; i < m; i++){\\n            DFS(heights, 0, i, INT_MIN, pacific);\\n            DFS(heights, n-1, i, INT_MIN, atlantic);\\n        }\\n        \\n        // check for rows\\n        for(int i = 0; i < n; i++){\\n            DFS(heights, i, 0, INT_MIN, pacific);\\n            DFS(heights, i, m-1, INT_MIN, atlantic);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(atlantic[i][j] && pacific[i][j])\\n                    res.push_back({i, j});\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517431,
                "title": "java-dfs-recursion-bfs-iteration-two-solutions",
                "content": "```\\n\\n\\n    //Runtime: 6 ms, faster than 83.64% of Java online submissions for Pacific Atlantic Water Flow.\\n    //Memory Usage: 54.9 MB, less than 54.73% of Java online submissions for Pacific Atlantic Water Flow.\\n    //DFS + recursion\\n    //Time: O(M*N); Space: O(M*N)\\n    private static final int[][] DIRECTIONS = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n\\n        boolean[][] pacific = new boolean[heights.length][heights[0].length];\\n        boolean[][] atlantic = new boolean[heights.length][heights[0].length];\\n\\n        for (int i = 0; i < heights.length; i++) {\\n            helper_dfs(heights, i, 0, pacific);\\n            helper_dfs(heights,i, heights[0].length - 1, atlantic);\\n        }\\n\\n        for (int j = 0; j < heights[0].length; j++) {\\n            helper_dfs(heights, 0, j, pacific);\\n            helper_dfs(heights,heights.length - 1, j, atlantic);\\n        }\\n\\n        List<List<Integer>> res = new LinkedList<>();\\n        for (int i = 0; i < heights.length; i++)\\n            for (int j = 0; j < heights[0].length; j++)\\n                if (pacific[i][j] && atlantic[i][j]) res.add(Arrays.asList(i, j));\\n        return res;\\n    }\\n\\n    private void helper_dfs(int[][] heights, int i, int j, boolean[][] res){\\n        res[i][j] = true;\\n\\n        for (int[] dir : DIRECTIONS){\\n            int x = i + dir[0], y = j + dir[1];\\n            if (x >= 0 && x < heights.length\\n                    && y >= 0 && y < heights[0].length\\n                    && heights[x][y] >= heights[i][j]\\n                    && !res[x][y]\\n            )\\n                helper_dfs(heights, x, y, res);\\n        }\\n    }\\n    \\n\\n    //Runtime: 18 ms, faster than 31.87% of Java online submissions for Pacific Atlantic Water Flow.\\n    //Memory Usage: 55.3 MB, less than 31.12% of Java online submissions for Pacific Atlantic Water Flow.\\n    //BFS + iteration\\n    //Time: O(M*N); Space: O(M*N)\\n    //private static final int[][] DIRECTIONS = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public List<List<Integer>> pacificAtlantic_bfs(int[][] heights) {\\n\\n        boolean[][] pacific = helper_bfs(heights, true);\\n        boolean[][] atlantic = helper_bfs(heights, false);\\n\\n        List<List<Integer>> res = new LinkedList<>();\\n        for (int i = 0; i < heights.length; i++)\\n            for (int j = 0; j < heights[0].length; j++)\\n                if (pacific[i][j] && atlantic[i][j]) res.add(Arrays.asList(i, j));\\n        return res;\\n    }\\n\\n    //Time: O(M + N + M*N); Space:  O(M*N)\\n    private boolean[][] helper_bfs(int[][] heights, boolean flag){\\n        //flag true: pacific\\n        Queue<int[]> queue = new LinkedList<>();\\n        int fixJ = flag ? 0 :heights[0].length - 1;\\n        for (int i = 0; i < heights.length; i++) queue.add(new int[]{i, fixJ});\\n\\n        int fixI = flag ? 0 : heights.length - 1;\\n        for (int j = 0; j < heights[0].length; j++) queue.add(new int[]{fixI, j});\\n\\n        boolean[][] res = new boolean[heights.length][heights[0].length];\\n        while (!queue.isEmpty()){\\n            int[] node = queue.poll();\\n            int i = node[0], j = node[1];\\n            res[i][j] = true;\\n\\n            for (int[] dir : DIRECTIONS){\\n                int x = i + dir[0], y = j + dir[1];\\n                if (x >= 0 && x < heights.length\\n                        && y >= 0 && y < heights[0].length\\n                        && heights[x][y] >= heights[i][j]\\n                        && !res[x][y]\\n                )\\n                    queue.add(new int[]{x, y});\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n```\\n\\nPlease upvote if you like.\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\n\\n    //Runtime: 6 ms, faster than 83.64% of Java online submissions for Pacific Atlantic Water Flow.\\n    //Memory Usage: 54.9 MB, less than 54.73% of Java online submissions for Pacific Atlantic Water Flow.\\n    //DFS + recursion\\n    //Time: O(M*N); Space: O(M*N)\\n    private static final int[][] DIRECTIONS = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n\\n        boolean[][] pacific = new boolean[heights.length][heights[0].length];\\n        boolean[][] atlantic = new boolean[heights.length][heights[0].length];\\n\\n        for (int i = 0; i < heights.length; i++) {\\n            helper_dfs(heights, i, 0, pacific);\\n            helper_dfs(heights,i, heights[0].length - 1, atlantic);\\n        }\\n\\n        for (int j = 0; j < heights[0].length; j++) {\\n            helper_dfs(heights, 0, j, pacific);\\n            helper_dfs(heights,heights.length - 1, j, atlantic);\\n        }\\n\\n        List<List<Integer>> res = new LinkedList<>();\\n        for (int i = 0; i < heights.length; i++)\\n            for (int j = 0; j < heights[0].length; j++)\\n                if (pacific[i][j] && atlantic[i][j]) res.add(Arrays.asList(i, j));\\n        return res;\\n    }\\n\\n    private void helper_dfs(int[][] heights, int i, int j, boolean[][] res){\\n        res[i][j] = true;\\n\\n        for (int[] dir : DIRECTIONS){\\n            int x = i + dir[0], y = j + dir[1];\\n            if (x >= 0 && x < heights.length\\n                    && y >= 0 && y < heights[0].length\\n                    && heights[x][y] >= heights[i][j]\\n                    && !res[x][y]\\n            )\\n                helper_dfs(heights, x, y, res);\\n        }\\n    }\\n    \\n\\n    //Runtime: 18 ms, faster than 31.87% of Java online submissions for Pacific Atlantic Water Flow.\\n    //Memory Usage: 55.3 MB, less than 31.12% of Java online submissions for Pacific Atlantic Water Flow.\\n    //BFS + iteration\\n    //Time: O(M*N); Space: O(M*N)\\n    //private static final int[][] DIRECTIONS = new int[][]{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public List<List<Integer>> pacificAtlantic_bfs(int[][] heights) {\\n\\n        boolean[][] pacific = helper_bfs(heights, true);\\n        boolean[][] atlantic = helper_bfs(heights, false);\\n\\n        List<List<Integer>> res = new LinkedList<>();\\n        for (int i = 0; i < heights.length; i++)\\n            for (int j = 0; j < heights[0].length; j++)\\n                if (pacific[i][j] && atlantic[i][j]) res.add(Arrays.asList(i, j));\\n        return res;\\n    }\\n\\n    //Time: O(M + N + M*N); Space:  O(M*N)\\n    private boolean[][] helper_bfs(int[][] heights, boolean flag){\\n        //flag true: pacific\\n        Queue<int[]> queue = new LinkedList<>();\\n        int fixJ = flag ? 0 :heights[0].length - 1;\\n        for (int i = 0; i < heights.length; i++) queue.add(new int[]{i, fixJ});\\n\\n        int fixI = flag ? 0 : heights.length - 1;\\n        for (int j = 0; j < heights[0].length; j++) queue.add(new int[]{fixI, j});\\n\\n        boolean[][] res = new boolean[heights.length][heights[0].length];\\n        while (!queue.isEmpty()){\\n            int[] node = queue.poll();\\n            int i = node[0], j = node[1];\\n            res[i][j] = true;\\n\\n            for (int[] dir : DIRECTIONS){\\n                int x = i + dir[0], y = j + dir[1];\\n                if (x >= 0 && x < heights.length\\n                        && y >= 0 && y < heights[0].length\\n                        && heights[x][y] >= heights[i][j]\\n                        && !res[x][y]\\n                )\\n                    queue.add(new int[]{x, y});\\n            }\\n        }\\n        return res;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509506,
                "title": "python-double-bfs-from-each-ocean-brief-explanation",
                "content": "We need to perform a BFS from each ocean, atlantic and pacific. (We can also do DFS, we just need to find the reach of each ocean)\\n\\nWe record all the rows that we can reach from the pacific and atlantic oceans. Cells that are reached from both oceans are part of our answer.\\n\\nThe BFS walks the neighbor cells that have a heigher value than the current cell, because the water can flow from the neighbor cell to the current cell (reversing the order).\\n\\n```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        \\n        atlantic_vis = [[False for _ in range(n)] for _ in range(m)]\\n        pacific_vis = [[False for _ in range(n)] for _ in range(m)]\\n        \\n        atlantic = deque()\\n        pacific = deque()\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    pacific_vis[r][c] = True\\n                    pacific.append((r, c))\\n                if r == m-1 or c == n-1:\\n                    atlantic_vis[r][c] = True\\n                    atlantic.append((r, c))\\n                    \\n        def bfs(queue, vis_mat):\\n            reach = set()\\n            \\n            while queue:\\n                r, c = queue.popleft()\\n                reach.add((r, c))\\n\\n                for nr, nc in [(r, c-1), (r, c+1), (r+1, c), (r-1, c)]:\\n                    if not (0 <= nr < m and 0 <= nc < n): continue\\n                    if vis_mat[nr][nc]: continue\\n\\n                    if heights[nr][nc] >= heights[r][c]:\\n                        vis_mat[nr][nc] = True\\n                        queue.append((nr, nc))\\n            return reach\\n            \\n        \\n        # atlantic BFS\\n        atlantic_reach = bfs(atlantic, atlantic_vis)\\n        # pacific BFS\\n        pacific_reach = bfs(pacific, pacific_vis)\\n        \\n        return [[r, c] for r in range(m) for c in range(n) if (r,c) in pacific_reach and (r,c) in atlantic_reach]\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights), len(heights[0])\\n        \\n        atlantic_vis = [[False for _ in range(n)] for _ in range(m)]\\n        pacific_vis = [[False for _ in range(n)] for _ in range(m)]\\n        \\n        atlantic = deque()\\n        pacific = deque()\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0 or c == 0:\\n                    pacific_vis[r][c] = True\\n                    pacific.append((r, c))\\n                if r == m-1 or c == n-1:\\n                    atlantic_vis[r][c] = True\\n                    atlantic.append((r, c))\\n                    \\n        def bfs(queue, vis_mat):\\n            reach = set()\\n            \\n            while queue:\\n                r, c = queue.popleft()\\n                reach.add((r, c))\\n\\n                for nr, nc in [(r, c-1), (r, c+1), (r+1, c), (r-1, c)]:\\n                    if not (0 <= nr < m and 0 <= nc < n): continue\\n                    if vis_mat[nr][nc]: continue\\n\\n                    if heights[nr][nc] >= heights[r][c]:\\n                        vis_mat[nr][nc] = True\\n                        queue.append((nr, nc))\\n            return reach\\n            \\n        \\n        # atlantic BFS\\n        atlantic_reach = bfs(atlantic, atlantic_vis)\\n        # pacific BFS\\n        pacific_reach = bfs(pacific, pacific_vis)\\n        \\n        return [[r, c] for r in range(m) for c in range(n) if (r,c) in pacific_reach and (r,c) in atlantic_reach]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508448,
                "title": "rust-iterative-dfs-with-comments",
                "content": "This is a graph problem - find all nodes that can reach the ocean by a series of directed edges going from nodes to 4-connected neighbor nodes with lower or equal height. Nodes bordering the ocean can always reach the ocean. So by reversing the edges we can trace our way back to all the nodes that can reach the ocean by doing a BFS or DFS from the border nodes.\\n\\nMy thoughts when doing the solution:\\n* I use an enum for the state of the nodes in the `visited` matrix. Much nicer for anyone reading the code than having e.g. integers with magic values.\\n* The initial nodes are added to the stack using chained iterators over the border nodes. You have got to love that about Rust.\\n* I prefer DFS here since I like the shorter `if let Some(...) = stack.pop()` condition than the two lines of `while !q.is_empty() { for _ in 0..q.len()` for a BFS (and I don\\'t have to `use` a `VecDeque` :) ).\\n* I use the trick `[0, 1, 0, !0, 0].windows(2)` to get the deltas to the neighbors (`x.wrapping_add(!0) == x.wrapping_sub(1)`). And with the wrapping, I can do the very concise bounds checking `r < m && c < n` which returns false if I have overstepped any of the edges.\\n* `[r as _, c as _]`: the types of the vector elements are given anyway, since the return type is specified as `Vec<Vec<i32>>`. No need to overspecify types. This way, the code doesn\\'t have to change if the return type changes.\\n\\nAfter doing my implementation, I checked the reference solution, where they compile a boolean grid for each of the BFSs/DFSs, and then compute the intersection of those grids with a O(m * n) iteration. That might be what you do it in big-O land, since it doesn\\'t impact neither big-O time nor space complexity. But I don\\'t think that\\'s a good way of doing it. I instead use a single grid that I first use to keep track of nodes visited in the \"Atlantic\" search. I keep the grid for the \"Pacific\" search, and add all the nodes I encounter as reachable that are marked as \"Atlantic\" to the result, Less memory used, and less time spent on iteration.\\n\\n```\\n#[derive(Copy, Clone, PartialEq)]\\nenum Reaches {\\n    Unknown,\\n    Atlantic,\\n    Pacific,\\n}\\n\\nimpl Solution {\\n    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (heights.len(), heights[0].len());\\n        let mut visited = vec![vec![Reaches::Unknown; n]; m];\\n        let mut stack: Vec<_> = (0..m).map(|r| (r, n-1, 0)).chain((0..n-1).map(|c| (m-1, c, 0))).collect();\\n        while let Some((r, c, h)) = stack.pop() {\\n            if r < m && c < n && visited[r][c] != Reaches::Atlantic && h <= heights[r][c] {\\n                visited[r][c] = Reaches::Atlantic;\\n                for w in [0, 1, 0, !0, 0].windows(2) {\\n                    stack.push((r.wrapping_add(w[0]), c.wrapping_add(w[1]), heights[r][c]));\\n                }\\n            }\\n        }\\n\\n        let mut rez = vec![];\\n        stack = (0..m).map(|r| (r, 0, 0)).chain((1..n).map(|c| (0, c, 0))).collect();\\n        while let Some((r, c, h)) = stack.pop() {\\n            if r < m && c < n && visited[r][c] != Reaches::Pacific && h <= heights[r][c] {\\n                if visited[r][c] == Reaches::Atlantic {\\n                    rez.push(vec![r as _, c as _]);\\n                }\\n                visited[r][c] = Reaches::Pacific;\\n                for w in [0, 1, 0, !0, 0].windows(2) {\\n                    stack.push((r.wrapping_add(w[0]), c.wrapping_add(w[1]), heights[r][c]));\\n                }\\n            }\\n        }\\n        rez\\n    }\\n}\\n```\\n\\nAnd for those of you that don\\'t like the code duplication, here is a version with the DFS as a lambda (although I think it becomes harder to read, and adds some ugliness since the lambda has to accomodate for both of the DFS rounds).\\n\\n```\\n#[derive(Copy, Clone, PartialEq)]\\nenum Reaches {\\n    Unknown,\\n    Atlantic,\\n    Pacific,\\n}\\n\\nimpl Solution {\\n    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (heights.len(), heights[0].len());\\n        let mut visited = vec![vec![Reaches::Unknown; n]; m];\\n        let mut rez = vec![];\\n\\n        let mut dfs = |cond: Reaches\\n            , mut stack: Vec<(usize, usize, i32)>\\n            , payload: fn(usize, usize, Reaches, &mut Vec<Vec<i32>>)| {\\n            while let Some((r, c, h)) = stack.pop() {\\n                if r < m && c < n && visited[r][c] != cond && h <= heights[r][c] {\\n                    payload(r, c, visited[r][c], &mut rez);\\n                    visited[r][c] = cond;\\n                    for w in [0, 1, 0, !0, 0].windows(2) {\\n                        stack.push((r.wrapping_add(w[0]), c.wrapping_add(w[1]), heights[r][c]));\\n                    }\\n                }\\n            }\\n        };\\n\\n\\n        let stack: Vec<_> = (0..m).map(|r| (r, n-1, 0)).chain((0..n-1).map(|c| (m-1, c, 0))).collect();\\n        dfs(Reaches::Atlantic, stack, |_, _, _, _| () );\\n        let stack = (0..m).map(|r| (r, 0, 0)).chain((1..n).map(|c| (0, c, 0))).collect();\\n        dfs(Reaches::Pacific, stack, |r, c, reaches, rez| \\n            if reaches == Reaches::Atlantic { rez.push(vec![r as _, c as _]) } );\\n\\n        rez\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n#[derive(Copy, Clone, PartialEq)]\\nenum Reaches {\\n    Unknown,\\n    Atlantic,\\n    Pacific,\\n}\\n\\nimpl Solution {\\n    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (heights.len(), heights[0].len());\\n        let mut visited = vec![vec![Reaches::Unknown; n]; m];\\n        let mut stack: Vec<_> = (0..m).map(|r| (r, n-1, 0)).chain((0..n-1).map(|c| (m-1, c, 0))).collect();\\n        while let Some((r, c, h)) = stack.pop() {\\n            if r < m && c < n && visited[r][c] != Reaches::Atlantic && h <= heights[r][c] {\\n                visited[r][c] = Reaches::Atlantic;\\n                for w in [0, 1, 0, !0, 0].windows(2) {\\n                    stack.push((r.wrapping_add(w[0]), c.wrapping_add(w[1]), heights[r][c]));\\n                }\\n            }\\n        }\\n\\n        let mut rez = vec![];\\n        stack = (0..m).map(|r| (r, 0, 0)).chain((1..n).map(|c| (0, c, 0))).collect();\\n        while let Some((r, c, h)) = stack.pop() {\\n            if r < m && c < n && visited[r][c] != Reaches::Pacific && h <= heights[r][c] {\\n                if visited[r][c] == Reaches::Atlantic {\\n                    rez.push(vec![r as _, c as _]);\\n                }\\n                visited[r][c] = Reaches::Pacific;\\n                for w in [0, 1, 0, !0, 0].windows(2) {\\n                    stack.push((r.wrapping_add(w[0]), c.wrapping_add(w[1]), heights[r][c]));\\n                }\\n            }\\n        }\\n        rez\\n    }\\n}\\n```\n```\\n#[derive(Copy, Clone, PartialEq)]\\nenum Reaches {\\n    Unknown,\\n    Atlantic,\\n    Pacific,\\n}\\n\\nimpl Solution {\\n    pub fn pacific_atlantic(heights: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (heights.len(), heights[0].len());\\n        let mut visited = vec![vec![Reaches::Unknown; n]; m];\\n        let mut rez = vec![];\\n\\n        let mut dfs = |cond: Reaches\\n            , mut stack: Vec<(usize, usize, i32)>\\n            , payload: fn(usize, usize, Reaches, &mut Vec<Vec<i32>>)| {\\n            while let Some((r, c, h)) = stack.pop() {\\n                if r < m && c < n && visited[r][c] != cond && h <= heights[r][c] {\\n                    payload(r, c, visited[r][c], &mut rez);\\n                    visited[r][c] = cond;\\n                    for w in [0, 1, 0, !0, 0].windows(2) {\\n                        stack.push((r.wrapping_add(w[0]), c.wrapping_add(w[1]), heights[r][c]));\\n                    }\\n                }\\n            }\\n        };\\n\\n\\n        let stack: Vec<_> = (0..m).map(|r| (r, n-1, 0)).chain((0..n-1).map(|c| (m-1, c, 0))).collect();\\n        dfs(Reaches::Atlantic, stack, |_, _, _, _| () );\\n        let stack = (0..m).map(|r| (r, 0, 0)).chain((1..n).map(|c| (0, c, 0))).collect();\\n        dfs(Reaches::Pacific, stack, |r, c, reaches, rez| \\n            if reaches == Reaches::Atlantic { rez.push(vec![r as _, c as _]) } );\\n\\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2508092,
                "title": "c-dfs-o-m-n-matrix-easy-explaination",
                "content": "**Easy DFS Approach Solution with Explaination!!**\\n**DFS Traversal Approach !!**\\n\\n* Time Complexity:- **O(m*n)**\\n\\n* Space Complexity:- **O(m*n)**\\n    \\n```\\nclass Solution {\\npublic:\\n    \\n    // DFS Function implementation\\n    void dfs_fun(vector<vector<int>> &heights,int i,int j,int prev,vector<vector<int>> &oce){\\n        if(i<0 || i>=oce.size() || j<0 || j>=oce[0].size()){\\n            return;\\n        }\\n        if(heights[i][j]<prev || oce[i][j]==1){\\n            return;\\n        }\\n        \\n        oce[i][j]=1;\\n        \\n        dfs_fun(heights,i,j+1,heights[i][j],oce);\\n        dfs_fun(heights,i,j-1,heights[i][j],oce);\\n        dfs_fun(heights,i+1,j,heights[i][j],oce);\\n        dfs_fun(heights,i-1,j,heights[i][j],oce);\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        // no. of rows\\n        int m=heights.size();\\n        // no. of columns\\n        int n=heights[0].size();\\n        \\n        // 2-d vector for storing ans\\n        vector<vector<int>> ans;\\n        \\n        if(m==0 || n==0){\\n            return ans;\\n        }\\n        \\n        // pacific and atlantic 2-d vector for checking from which block it is possible to reach the specified location\\n        vector<vector<int>> pacific(m,vector<int> (n));\\n        vector<vector<int>> atlantic(m,vector<int> (n));\\n        \\n        \\n        // Depth First Traversal Call\\n        for(int j=0;j<n;j++){\\n            dfs_fun(heights,0,j,INT_MIN,pacific);\\n            dfs_fun(heights,m-1,j,INT_MIN,atlantic);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            dfs_fun(heights,j,0,INT_MIN,pacific);\\n            dfs_fun(heights,j,n-1,INT_MIN,atlantic);\\n        }\\n        \\n        \\n        // Intersection of Pacific and Atlantic ocean where both are having true value is our coordinates.\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(pacific[i][j]==1 && atlantic[i][j]==1){\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // DFS Function implementation\\n    void dfs_fun(vector<vector<int>> &heights,int i,int j,int prev,vector<vector<int>> &oce){\\n        if(i<0 || i>=oce.size() || j<0 || j>=oce[0].size()){\\n            return;\\n        }\\n        if(heights[i][j]<prev || oce[i][j]==1){\\n            return;\\n        }\\n        \\n        oce[i][j]=1;\\n        \\n        dfs_fun(heights,i,j+1,heights[i][j],oce);\\n        dfs_fun(heights,i,j-1,heights[i][j],oce);\\n        dfs_fun(heights,i+1,j,heights[i][j],oce);\\n        dfs_fun(heights,i-1,j,heights[i][j],oce);\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        // no. of rows\\n        int m=heights.size();\\n        // no. of columns\\n        int n=heights[0].size();\\n        \\n        // 2-d vector for storing ans\\n        vector<vector<int>> ans;\\n        \\n        if(m==0 || n==0){\\n            return ans;\\n        }\\n        \\n        // pacific and atlantic 2-d vector for checking from which block it is possible to reach the specified location\\n        vector<vector<int>> pacific(m,vector<int> (n));\\n        vector<vector<int>> atlantic(m,vector<int> (n));\\n        \\n        \\n        // Depth First Traversal Call\\n        for(int j=0;j<n;j++){\\n            dfs_fun(heights,0,j,INT_MIN,pacific);\\n            dfs_fun(heights,m-1,j,INT_MIN,atlantic);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            dfs_fun(heights,j,0,INT_MIN,pacific);\\n            dfs_fun(heights,j,n-1,INT_MIN,atlantic);\\n        }\\n        \\n        \\n        // Intersection of Pacific and Atlantic ocean where both are having true value is our coordinates.\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(pacific[i][j]==1 && atlantic[i][j]==1){\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507872,
                "title": "c-explained-solution-with-pictures-using-bfs",
                "content": "We can observe that there are these cells which can reach \\n* None\\n* Pacific\\n* Atlantic\\n* Both Pacific and Atlantic\\n\\n`We need only the cells satisfying the last condition above.`\\n\\nNow, if we start from the cells connected to altantic ocean and visit all cells having height greater than current cell (**water can only flow from a cell to another one with height equal or lower**), we are able to reach some subset of cells (let\\'s call them A).\\n\\n![image](https://assets.leetcode.com/users/images/5cf514c5-9391-41fa-bf61-67cef41dc555_1661924760.0297408.png)\\n\\n\\nNext, we start from the cells connected to pacific ocean and repeat the same process, we find another subset (let\\'s call this one B).\\n\\n![image](https://assets.leetcode.com/users/images/b17d2115-d7f4-463b-afab-560d7c441c54_1661924792.4795702.png)\\n\\n\\nThe final answer we get will be the intersection of sets A and B `(A \\u2229 B)`.\\n\\n![image](https://assets.leetcode.com/users/images/69c271a8-7945-4b51-8399-a89f72c96c69_1661924801.2395902.png)\\n\\n\\nSo, we just need to iterate from edge cells, find cells reachable from atlantic (set A), cells reachable from pacific (set B) and return their intersection. This can be done using DFS or BFS graph traversals.\\n\\n**C++ Solution Using BFS Traversal** :\\n\\n```\\nclass Solution {\\n    int n,m;\\n    vector<vector<bool>> atlantic, pacific;\\n    vector<vector<int>> ans;\\n    queue<pair<int,int>> q;\\n    const int d4i[4]={0,0,-1,1}, d4j[4]={1,-1,0,0};\\n    \\n    bool check(int i,int j){\\n        return 0<=i and 0<=j and n>i and m>j;\\n    }\\n    void bfs(const std::vector<vector<int>>& heights,vector<vector<bool>>& visited,int i,int j){\\n        q.push({i,j});\\n        \\n        while(!q.empty()){\\n            tie(i,j) = q.front(); \\n            q.pop();\\n            \\n            if(visited[i][j])\\n                continue;\\n            visited[i][j]=true;\\n            \\n            if(pacific[i][j] and atlantic[i][j])\\n                ans.emplace_back(vector<int>({i,j}));\\n            \\n            for(int k=0;k<4;++k){\\n                int ti = i+d4i[k];\\n                int tj = j+d4j[k];\\n                if(check(ti, tj) and heights[ti][tj]>=heights[i][j])\\n                    q.push({ti, tj});\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        n=size(heights);\\n        m=size(heights[0]);\\n        \\n        atlantic = pacific = vector<vector<bool>>(n, vector<bool>(m,false));\\n        ans.clear();\\n        for(int i=0;i<n;++i)\\n            bfs(heights, pacific, i, 0), bfs(heights, atlantic, i, m-1);\\n        \\n        for(int i=0;i<m;++i)\\n            bfs(heights, pacific, 0, i), bfs(heights ,atlantic, n-1, i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n,m;\\n    vector<vector<bool>> atlantic, pacific;\\n    vector<vector<int>> ans;\\n    queue<pair<int,int>> q;\\n    const int d4i[4]={0,0,-1,1}, d4j[4]={1,-1,0,0};\\n    \\n    bool check(int i,int j){\\n        return 0<=i and 0<=j and n>i and m>j;\\n    }\\n    void bfs(const std::vector<vector<int>>& heights,vector<vector<bool>>& visited,int i,int j){\\n        q.push({i,j});\\n        \\n        while(!q.empty()){\\n            tie(i,j) = q.front(); \\n            q.pop();\\n            \\n            if(visited[i][j])\\n                continue;\\n            visited[i][j]=true;\\n            \\n            if(pacific[i][j] and atlantic[i][j])\\n                ans.emplace_back(vector<int>({i,j}));\\n            \\n            for(int k=0;k<4;++k){\\n                int ti = i+d4i[k];\\n                int tj = j+d4j[k];\\n                if(check(ti, tj) and heights[ti][tj]>=heights[i][j])\\n                    q.push({ti, tj});\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        n=size(heights);\\n        m=size(heights[0]);\\n        \\n        atlantic = pacific = vector<vector<bool>>(n, vector<bool>(m,false));\\n        ans.clear();\\n        for(int i=0;i<n;++i)\\n            bfs(heights, pacific, i, 0), bfs(heights, atlantic, i, m-1);\\n        \\n        for(int i=0;i<m;++i)\\n            bfs(heights, pacific, 0, i), bfs(heights ,atlantic, n-1, i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507562,
                "title": "c-simple-dfs-solution-dfs-in-grid-with-explanation",
                "content": "**Approach** : \\nWe apply dfs from all the cells on the border \\nBecause they are in direct contact with both the oceans.\\n\\nAt every cell wherever we reach through dfs, we check whether we have reached that cell from both the oceans or not.\\nIf yes, then we add that cell to our ans.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pac,atl;\\n    vector<vector<int>> ans,arr;\\n    int n,m;\\n    void dfs(int i,int j,vector<vector<int>> &vis){\\n        if(vis[i][j])\\n            return;\\n        vis[i][j]++;\\n        if(pac[i][j] && atl[i][j]){\\n            ans.push_back({i, j});\\n        }\\n        if(i+1 < n && arr[i+1][j] >= arr[i][j])\\n            dfs(i+1, j, vis);\\n        if(i-1 >= 0 && arr[i-1][j] >= arr[i][j])\\n            dfs(i-1, j, vis);\\n        if(j+1 < m && arr[i][j+1] >= arr[i][j])\\n            dfs(i, j+1, vis);\\n        if(j-1 >= 0 && arr[i][j-1] >= arr[i][j])\\n            dfs(i, j-1, vis);\\n            \\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& arr) {\\n        this->arr = arr;\\n        n = arr.size(), m = arr[0].size();\\n        pac = atl = vector<vector<int>>(n,vector<int>(m));\\n        for(int i = 0;i < n;i++){\\n            dfs(i, 0, pac);\\n            dfs(i, m-1, atl);\\n        }\\n        for(int i = 0;i < m;i++){\\n            dfs(0, i, pac);\\n            dfs(n-1, i, atl);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pac,atl;\\n    vector<vector<int>> ans,arr;\\n    int n,m;\\n    void dfs(int i,int j,vector<vector<int>> &vis){\\n        if(vis[i][j])\\n            return;\\n        vis[i][j]++;\\n        if(pac[i][j] && atl[i][j]){\\n            ans.push_back({i, j});\\n        }\\n        if(i+1 < n && arr[i+1][j] >= arr[i][j])\\n            dfs(i+1, j, vis);\\n        if(i-1 >= 0 && arr[i-1][j] >= arr[i][j])\\n            dfs(i-1, j, vis);\\n        if(j+1 < m && arr[i][j+1] >= arr[i][j])\\n            dfs(i, j+1, vis);\\n        if(j-1 >= 0 && arr[i][j-1] >= arr[i][j])\\n            dfs(i, j-1, vis);\\n            \\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& arr) {\\n        this->arr = arr;\\n        n = arr.size(), m = arr[0].size();\\n        pac = atl = vector<vector<int>>(n,vector<int>(m));\\n        for(int i = 0;i < n;i++){\\n            dfs(i, 0, pac);\\n            dfs(i, m-1, atl);\\n        }\\n        for(int i = 0;i < m;i++){\\n            dfs(0, i, pac);\\n            dfs(n-1, i, atl);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507426,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // direction co-ordinates for left, right, top, bottom\\n    \\n    vector<int> dx = {-1, 0, 1, 0};\\n    \\n    vector<int> dy = {0, 1, 0, -1};\\n    \\n    void dfs(vector<vector<int>>& height, int i, int j, int n, int m, int prev, vector<vector<bool>>& vis)\\n    {\\n        // base case\\n        \\n        if(i < 0 || i >= n || j < 0 || j >= m || vis[i][j] || height[i][j] < prev)\\n            return;\\n        \\n        // mark the curr cell as visited\\n        \\n        vis[i][j] = true;\\n        \\n        // move in all 4 directions\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n            \\n            int new_j = j + dy[k];\\n            \\n            dfs(height, new_i, new_j, n, m, height[i][j], vis);\\n        }\\n    }\\n  \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        int n = heights.size();\\n        \\n        int m = heights[0].size();\\n        \\n        // pacific[i][j] will store can we reach to the pacific ocean\\n        \\n        vector<vector<bool>> pacific(n, vector<bool> (m, false));\\n        \\n        // we know one thing is that we can always reach to pacific ocean from 1st col and 1st row\\n        \\n        // so start dfs traversal from 1st row and 1st col and check from which cell we can reach the pacific ocean\\n        \\n        // start dfs from 1st col\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            dfs(heights, i, 0, n, m, heights[i][0], pacific);\\n        }\\n        \\n        // dfs from 1st row\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            dfs(heights, 0, j, n, m, heights[0][j], pacific);\\n        }\\n        \\n        // atlantic[i][j] will store can we reach to the atlantic ocean\\n        \\n        vector<vector<bool>> atlantic(n, vector<bool> (m, false));\\n        \\n        // we know one thing is that we can always reach to atlantic ocean from last col and last row\\n        \\n        // so start dfs traversal from last row and last col and check from which cell we can reach the pacific ocean \\n        \\n        // dfs from last col\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            dfs(heights, i, m - 1, n, m, heights[i][m - 1], atlantic);\\n        }\\n        \\n        // dfs from last row\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            dfs(heights, n - 1, j, n, m, heights[n - 1][j], atlantic);\\n        }\\n        \\n        // now check from which cell we can reach to the pacific as well as atlantic ocean\\n        \\n        // store the index no. of cell into res\\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(pacific[i][j] && atlantic[i][j])\\n                {\\n                    res.push_back({i, j});\\n                }\\n            }\\n        }\\n      \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // direction co-ordinates for left, right, top, bottom\\n    \\n    vector<int> dx = {-1, 0, 1, 0};\\n    \\n    vector<int> dy = {0, 1, 0, -1};\\n    \\n    void dfs(vector<vector<int>>& height, int i, int j, int n, int m, int prev, vector<vector<bool>>& vis)\\n    {\\n        // base case\\n        \\n        if(i < 0 || i >= n || j < 0 || j >= m || vis[i][j] || height[i][j] < prev)\\n            return;\\n        \\n        // mark the curr cell as visited\\n        \\n        vis[i][j] = true;\\n        \\n        // move in all 4 directions\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_i = i + dx[k];\\n            \\n            int new_j = j + dy[k];\\n            \\n            dfs(height, new_i, new_j, n, m, height[i][j], vis);\\n        }\\n    }\\n  \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        int n = heights.size();\\n        \\n        int m = heights[0].size();\\n        \\n        // pacific[i][j] will store can we reach to the pacific ocean\\n        \\n        vector<vector<bool>> pacific(n, vector<bool> (m, false));\\n        \\n        // we know one thing is that we can always reach to pacific ocean from 1st col and 1st row\\n        \\n        // so start dfs traversal from 1st row and 1st col and check from which cell we can reach the pacific ocean\\n        \\n        // start dfs from 1st col\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            dfs(heights, i, 0, n, m, heights[i][0], pacific);\\n        }\\n        \\n        // dfs from 1st row\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            dfs(heights, 0, j, n, m, heights[0][j], pacific);\\n        }\\n        \\n        // atlantic[i][j] will store can we reach to the atlantic ocean\\n        \\n        vector<vector<bool>> atlantic(n, vector<bool> (m, false));\\n        \\n        // we know one thing is that we can always reach to atlantic ocean from last col and last row\\n        \\n        // so start dfs traversal from last row and last col and check from which cell we can reach the pacific ocean \\n        \\n        // dfs from last col\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            dfs(heights, i, m - 1, n, m, heights[i][m - 1], atlantic);\\n        }\\n        \\n        // dfs from last row\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            dfs(heights, n - 1, j, n, m, heights[n - 1][j], atlantic);\\n        }\\n        \\n        // now check from which cell we can reach to the pacific as well as atlantic ocean\\n        \\n        // store the index no. of cell into res\\n        \\n        vector<vector<int>> res;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(pacific[i][j] && atlantic[i][j])\\n                {\\n                    res.push_back({i, j});\\n                }\\n            }\\n        }\\n      \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368824,
                "title": "using-border-condition-dfs-graph-c",
                "content": "Note:- Start form the borders of height\\n1. We mark those height Visited from which we can easily go to the pacific.\\n   Condition (curr_element>prev_element)\\n  ![image](https://assets.leetcode.com/users/images/3ad25eb0-7d66-4e4a-9d04-5ad3624b1f71_1659436427.9091544.png)\\n\\n2. Now we can mark those height Visited from which we can go to the atlantic.\\n    Condition (curr_element>prev_element)\\n\\t![image](https://assets.leetcode.com/users/images/7fea2678-ff19-40f9-ac5a-edd56dc3be65_1659436528.265659.png)\\n\\n3. Now, Finally We can store those height Which is visited from pacific and atlantic as well.\\n ![image](https://assets.leetcode.com/users/images/e95b7137-a7bc-42ea-8b38-d2a17f57e4ee_1659436612.4311867.png)\\n\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &arr,int x,int y,int prev,vector<vector<bool>> &ocean){\\n        if(x<0 || x>=arr.size() || y<0 || y>=arr[0].size()){\\n            return;\\n        }\\n        if(ocean[x][y]){\\n            return;\\n        }\\n        if(arr[x][y]<prev){\\n            return;\\n        }\\n        ocean[x][y]=true;\\n        dfs(arr,x+1,y,arr[x][y],ocean);\\n        dfs(arr,x-1,y,arr[x][y],ocean);\\n        dfs(arr,x,y+1,arr[x][y],ocean);\\n        dfs(arr,x,y-1,arr[x][y],ocean);\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        vector<vector<int>> res;\\n        if(heights.size()==0){\\n            return res;\\n        }\\n        int n=heights.size();\\n        int m=heights[0].size();\\n        \\n        vector<vector<bool>>atlan(n,vector<bool>(m,false));\\n        vector<vector<bool>>pacifi(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(heights,i,0,INT_MIN,pacifi);\\n            dfs(heights,i,m-1,INT_MIN,atlan);\\n        }\\n        \\n        for(int j=0;j<m;j++){\\n            dfs(heights,0,j,INT_MIN,pacifi);\\n            dfs(heights,n-1,j,INT_MIN,atlan);\\n        }        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(atlan[i][j] &&pacifi[i][j]){\\n                    res.push_back({i,j});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &arr,int x,int y,int prev,vector<vector<bool>> &ocean){\\n        if(x<0 || x>=arr.size() || y<0 || y>=arr[0].size()){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2344734,
                "title": "c-dfs-solution-explanation",
                "content": "**C++**\\n\\n\\t#define vvi vector<vector<int>>\\n\\t#define vvb vector<vector<bool>>\\n\\t#define vb vector<bool>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint n, m;\\n\\t\\t\\n\\t\\t// Go througout the adjacent if the adjacent\\'s height is more or ewual to current height\\n\\t\\tvoid dfs(vvi& grid, vvb& flag, int x, int y) {\\n\\t\\t\\tflag[x][y] = true;\\n\\t\\t\\tif (x - 1 >= 0 && !flag[x - 1][y] && grid[x - 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x - 1, y);\\n\\t\\t\\tif (x + 1 < n && !flag[x + 1][y] && grid[x + 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x + 1, y);\\n\\t\\t\\tif (y - 1 >= 0 && !flag[x][y - 1] && grid[x][y - 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y - 1);\\n\\t\\t\\tif (y + 1 < m && !flag[x][y + 1] && grid[x][y + 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tvvi pacificAtlantic(vvi& heights) {\\n\\t\\t\\tn = heights.size();\\n\\t\\t\\tm = heights[0].size();\\n\\t\\t\\t\\n\\t\\t\\tvvb flag1(n, vb(m)), flag2(n, vb(m));\\n\\t\\t\\tvvi ans;\\n\\t\\t\\t\\n\\t\\t\\t/* Pacific */\\n\\t\\t\\t// Do DFS starting from upper border and left border\\n\\t\\t\\t// Mark true in flag1 if posibble\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tdfs(heights, flag1, i, 0);\\n\\t\\t\\tfor (int i = 1; i < m; i++)\\n\\t\\t\\t\\tdfs(heights, flag1, 0, i);\\n\\t\\t\\t\\n\\t\\t\\t/* Atlantic */\\n\\t\\t\\t// DFS starting from bottom border and right border\\n\\t\\t\\t// Mark true in flag2 if posibble\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tdfs(heights, flag2, i, m - 1);\\n\\t\\t\\tfor (int i = 0; i < m - 1; i++)\\n\\t\\t\\t\\tdfs(heights, flag2, n - 1, i);\\n\\t\\t\\t\\n\\t\\t\\t// Add cordinate to ans if both flag1 and flag2 is equal to true\\n\\t\\t\\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++)\\n\\t\\t\\t\\tif (flag1[i][j] && flag2[i][j])\\n\\t\\t\\t\\t\\tans.push_back({i, j});\\n\\t\\t\\t\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint n, m;\\n\\t\\t\\n\\t\\t// Go througout the adjacent if the adjacent\\'s height is more or ewual to current height\\n\\t\\tvoid dfs(vvi& grid, vvb& flag, int x, int y) {\\n\\t\\t\\tflag[x][y] = true;\\n\\t\\t\\tif (x - 1 >= 0 && !flag[x - 1][y] && grid[x - 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x - 1, y);\\n\\t\\t\\tif (x + 1 < n && !flag[x + 1][y] && grid[x + 1][y] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x + 1, y);\\n\\t\\t\\tif (y - 1 >= 0 && !flag[x][y - 1] && grid[x][y - 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y - 1);\\n\\t\\t\\tif (y + 1 < m && !flag[x][y + 1] && grid[x][y + 1] >= grid[x][y])\\n\\t\\t\\t\\tdfs(grid, flag, x, y + 1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2284433,
                "title": "dfs-soluton-cpp-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<vector<int>>&g,int r,int c,int p,vector<vector<bool>>&ocean){\\n        if(r < 0 || c < 0 || r >= g.size() || c >= g[0].size() || p > g[r][c] || ocean[r][c]) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>&g,int r,int c,int p,vector<vector<bool>>&ocean){\\n        if(!isSafe(g,r,c,p,ocean)) return;\\n        \\n        ocean[r][c]=true;\\n        \\n        dfs(g,r+1,c,g[r][c],ocean);\\n        dfs(g,r-1,c,g[r][c],ocean);\\n        dfs(g,r,c+1,g[r][c],ocean);\\n        dfs(g,r,c-1,g[r][c],ocean);\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        vector<vector<int>> res;\\n        \\n        if(!heights.size())return res;\\n        \\n        int row = heights.size();\\n        int col = heights[0].size();\\n        \\n        vector<vector<bool>> atlantic(row, vector<bool>(col, false));\\n        vector<vector<bool>> pacific(row, vector<bool>(col, false));\\n        // Row with pacific and atlantic woterflow\\n        for(int i = 0; i < row; i++){\\n            dfs(heights, i, 0, INT_MIN, pacific);\\n            dfs(heights, i, col-1, INT_MIN, atlantic);\\n        }\\n        // Col with pacific and atlantic woterflow\\n        for(int j = 0; j < col; j++){\\n            dfs(heights, 0, j, INT_MIN, pacific);\\n            dfs(heights, row-1, j, INT_MIN, atlantic);\\n        }\\n        // if both are required flow then keep it result vector\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                if(pacific[i][j] && atlantic[i][j]) res.push_back({i, j});\\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<vector<int>>&g,int r,int c,int p,vector<vector<bool>>&ocean){\\n        if(r < 0 || c < 0 || r >= g.size() || c >= g[0].size() || p > g[r][c] || ocean[r][c]) return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>&g,int r,int c,int p,vector<vector<bool>>&ocean){\\n        if(!isSafe(g,r,c,p,ocean)) return;\\n        \\n        ocean[r][c]=true;\\n        \\n        dfs(g,r+1,c,g[r][c],ocean);\\n        dfs(g,r-1,c,g[r][c],ocean);\\n        dfs(g,r,c+1,g[r][c],ocean);\\n        dfs(g,r,c-1,g[r][c],ocean);\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        vector<vector<int>> res;\\n        \\n        if(!heights.size())return res;\\n        \\n        int row = heights.size();\\n        int col = heights[0].size();\\n        \\n        vector<vector<bool>> atlantic(row, vector<bool>(col, false));\\n        vector<vector<bool>> pacific(row, vector<bool>(col, false));\\n        // Row with pacific and atlantic woterflow\\n        for(int i = 0; i < row; i++){\\n            dfs(heights, i, 0, INT_MIN, pacific);\\n            dfs(heights, i, col-1, INT_MIN, atlantic);\\n        }\\n        // Col with pacific and atlantic woterflow\\n        for(int j = 0; j < col; j++){\\n            dfs(heights, 0, j, INT_MIN, pacific);\\n            dfs(heights, row-1, j, INT_MIN, atlantic);\\n        }\\n        // if both are required flow then keep it result vector\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                if(pacific[i][j] && atlantic[i][j]) res.push_back({i, j});\\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885773,
                "title": "java-2-different-approaches-brute-force-optimal-beats-99-66-dfs",
                "content": "## Techniques Used\\n- Graph\\n- DFS\\n\\n## Approach 1 (Brute-force, Slow)\\n- We maintain a flag variable (an array of length 2), storing the flag variables for both oceans. ie ```if flag[0] == 1 && flag[1] == 1``` means that a particular cell can flow the water into both oceans, and thus can be added to our resultant list.\\n- Loop over the grid, initialize the flag and visited arrays for each cell, and if the above condition is met for a particular cell, we add it to the list.\\n- In the DFS utility function, we pass the grid, row, col values, along with the height of the current element (on which DFS is called), along with the visited array and the flag variable.\\n\\t- if the ```row < 0 || col < 0```, this means that water has reached the pacific ocean.\\n\\t\\t- so, we make the ```flag[0] == 1``` and return.\\n\\t- or if the ```row >= heights.length || col >=  heights[0].length``` , this means that water has reached the atlantic ocean\\n\\t\\t- so, we make the ```flag[1] == 1``` and return\\n\\t- if the current cell has been visited OR if the height of current cell is greater than the height provided, we return.\\n\\t- now, to process the current element\\n\\t\\t- we mark the current cell as visited\\n\\t\\t- we change the height variable to the height of the current cell (this height will be provided to the further recursion calls made on the neighbors of the current cell)\\n\\t- call this ```dfs``` function on the 4-directionally neighboring cells of the current cell.\\n- This approach is slow, because we are trying to maintain separate visited arrays for each cell, and losing the data from previous dfs calls made. \\n- This still passes all the test cases but is just slow.\\n\\n## Approach 2 (Optimized, Fast)\\n- Call the DFS function for all boundary elements of the grid, and fill the visited arrays for each of the oceans.\\n- Add all those row & col combinations (for which both the visited arrays have the true value) to the resultant list.\\n- In the DFS utility function, \\n\\t- We try to visit all the neighbors (4-directionally) which are taller than the current element.\\n\\t- If we have already visited this element or if its height is smaller than the height provided, or if it is out of bounds of grid, we return.\\n## Complexity (Approach 1)\\n- Time Complexity: O(mn^2)\\n- Space Complexity: O(mn^2) \\n\\n## Complexity (Approach 2)\\n- Time Complexity: O(mn)\\n- Space Complexity: O(mn) for two visited arrays for each Ocean.\\n\\nThe code for both the approaches is provided below:\\n\\n**Note**: Please let me if there is a mistake anywhere.\\n## Code: Approach 2\\n``` java\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        \\n        int m = heights.length;\\n        int n = heights[0].length;\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        boolean[][] pacificVisited = new boolean[m][n];\\n        boolean[][] atlanticVisited = new boolean[m][n];\\n        \\n        \\n        // call dfs on boundary elements, while searching for the bigger (higher) neighbors of each elements\\n        for(int row = 0; row < m; row++){\\n            dfs(heights, Integer.MIN_VALUE, row, 0, pacificVisited);\\n            dfs(heights, Integer.MIN_VALUE, row, n - 1, atlanticVisited);\\n\\n        }\\n        \\n        for(int col = 0; col < n; col++){\\n            dfs(heights, Integer.MIN_VALUE, 0, col, pacificVisited);\\n            dfs(heights, Integer.MIN_VALUE, m - 1, col, atlanticVisited);\\n\\n        }\\n        \\n        // all those cells which are present in both oceans\\' visited array, will be added to result\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(pacificVisited[i][j] && atlanticVisited[i][j]){\\n                    List<Integer> cell = new ArrayList<>();\\n                    cell.add(i);\\n                    cell.add(j);\\n                    res.add(cell);\\n                }\\n            }\\n        }\\n        \\n   \\n        return res;\\n        \\n    }\\n    \\n    static void dfs(int[][] heights,  int height, int row, int col, boolean[][] visited){\\n        \\n        \\n        if(row < 0 || col < 0 || row >= heights.length || col >=  heights[0].length || visited[row][col] || heights[row][col] < height){\\n            \\n            return;\\n            \\n        } \\n        \\n        visited[row][col] = true; \\n        height = heights[row][col];\\n        \\n        dfs(heights, height, row - 1, col, visited);\\n        dfs(heights, height, row + 1, col, visited);\\n        dfs(heights, height, row, col - 1, visited);\\n        dfs(heights, height, row, col + 1, visited);\\n        \\n        \\n        return;\\n        \\n        \\n    }\\n}\\n\\n```\\n\\n## Code: Approach 1\\n\\n```java\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        \\n        int m = heights.length;\\n        int n = heights[0].length;\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        \\n        for(int i =  0; i < m; i++){\\n            for(int j =  0; j < n; j++){\\n                \\n            \\n                \\n                int[] flag = new int[2];\\n                boolean[][] visited = new boolean[m][n];\\n                int height = heights[i][j];\\n                dfs(heights, height, i, j, flag, visited);\\n                \\n                if(flag[0] == 1 && flag[1] == 1) {\\n                    // add to the list res\\n                    List<Integer> temp = new ArrayList<>();\\n                    temp.add(i);\\n                    temp.add(j);\\n                    res.add(temp);\\n                }\\n            }\\n        }\\n        \\n\\n        return res;\\n        \\n    }\\n    \\n    // flag[0] = pacific\\n    // flag[1] = atlantic\\n    \\n    \\n    static void dfs(int[][] heights,  int height, int row, int col, int[] flag, boolean[][] visited){\\n        \\n        \\n        // able to flow into pacific\\n        if(row < 0 || col < 0){\\n            \\n            flag[0] = 1;\\n            return;\\n            \\n        } \\n        \\n        //able to flow into atlantic\\n        if(row >= heights.length || col >=  heights[0].length){\\n\\n            flag[1] = 1;\\n            return;\\n        }\\n        \\n        if(visited[row][col]) return;\\n        \\n        if(heights[row][col] > height){\\n            return;\\n        }\\n        visited[row][col] = true; //marked as visited\\n        height = heights[row][col];\\n        \\n        dfs(heights, height, row - 1, col, flag, visited);\\n        dfs(heights, height, row + 1, col, flag, visited);\\n        dfs(heights, height, row, col - 1, flag, visited);\\n        dfs(heights, height, row, col + 1, flag, visited);\\n        \\n        \\n        return;\\n        \\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```if flag[0] == 1 && flag[1] == 1```\n```row < 0 || col < 0```\n```flag[0] == 1```\n```row >= heights.length || col >=  heights[0].length```\n```flag[1] == 1```\n```dfs```\n``` java\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        \\n        int m = heights.length;\\n        int n = heights[0].length;\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        boolean[][] pacificVisited = new boolean[m][n];\\n        boolean[][] atlanticVisited = new boolean[m][n];\\n        \\n        \\n        // call dfs on boundary elements, while searching for the bigger (higher) neighbors of each elements\\n        for(int row = 0; row < m; row++){\\n            dfs(heights, Integer.MIN_VALUE, row, 0, pacificVisited);\\n            dfs(heights, Integer.MIN_VALUE, row, n - 1, atlanticVisited);\\n\\n        }\\n        \\n        for(int col = 0; col < n; col++){\\n            dfs(heights, Integer.MIN_VALUE, 0, col, pacificVisited);\\n            dfs(heights, Integer.MIN_VALUE, m - 1, col, atlanticVisited);\\n\\n        }\\n        \\n        // all those cells which are present in both oceans\\' visited array, will be added to result\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(pacificVisited[i][j] && atlanticVisited[i][j]){\\n                    List<Integer> cell = new ArrayList<>();\\n                    cell.add(i);\\n                    cell.add(j);\\n                    res.add(cell);\\n                }\\n            }\\n        }\\n        \\n   \\n        return res;\\n        \\n    }\\n    \\n    static void dfs(int[][] heights,  int height, int row, int col, boolean[][] visited){\\n        \\n        \\n        if(row < 0 || col < 0 || row >= heights.length || col >=  heights[0].length || visited[row][col] || heights[row][col] < height){\\n            \\n            return;\\n            \\n        } \\n        \\n        visited[row][col] = true; \\n        height = heights[row][col];\\n        \\n        dfs(heights, height, row - 1, col, visited);\\n        dfs(heights, height, row + 1, col, visited);\\n        dfs(heights, height, row, col - 1, visited);\\n        dfs(heights, height, row, col + 1, visited);\\n        \\n        \\n        return;\\n        \\n        \\n    }\\n}\\n\\n```\n```java\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        \\n        int m = heights.length;\\n        int n = heights[0].length;\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        \\n        for(int i =  0; i < m; i++){\\n            for(int j =  0; j < n; j++){\\n                \\n            \\n                \\n                int[] flag = new int[2];\\n                boolean[][] visited = new boolean[m][n];\\n                int height = heights[i][j];\\n                dfs(heights, height, i, j, flag, visited);\\n                \\n                if(flag[0] == 1 && flag[1] == 1) {\\n                    // add to the list res\\n                    List<Integer> temp = new ArrayList<>();\\n                    temp.add(i);\\n                    temp.add(j);\\n                    res.add(temp);\\n                }\\n            }\\n        }\\n        \\n\\n        return res;\\n        \\n    }\\n    \\n    // flag[0] = pacific\\n    // flag[1] = atlantic\\n    \\n    \\n    static void dfs(int[][] heights,  int height, int row, int col, int[] flag, boolean[][] visited){\\n        \\n        \\n        // able to flow into pacific\\n        if(row < 0 || col < 0){\\n            \\n            flag[0] = 1;\\n            return;\\n            \\n        } \\n        \\n        //able to flow into atlantic\\n        if(row >= heights.length || col >=  heights[0].length){\\n\\n            flag[1] = 1;\\n            return;\\n        }\\n        \\n        if(visited[row][col]) return;\\n        \\n        if(heights[row][col] > height){\\n            return;\\n        }\\n        visited[row][col] = true; //marked as visited\\n        height = heights[row][col];\\n        \\n        dfs(heights, height, row - 1, col, flag, visited);\\n        dfs(heights, height, row + 1, col, flag, visited);\\n        dfs(heights, height, row, col - 1, flag, visited);\\n        dfs(heights, height, row, col + 1, flag, visited);\\n        \\n        \\n        return;\\n        \\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870784,
                "title": "simple-c-solution-using-dfs-using-two-visited-matrices",
                "content": "```\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<bool>>pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>>atlantic(m, vector<bool>(n,false));\\n        vector<vector<int>> result;\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(mat,pacific,0,i,-1); //for pacific top\\n            dfs(mat,atlantic,m-1,i,-1); //for atlantic bottom\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            dfs(mat,pacific,i,0,-1); //for pacific left\\n            dfs(mat,atlantic,i,n-1,-1); //for atlantic right\\n        }\\n        \\n        //cal result\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    result.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    void dfs(vector<vector<int>>& mat,vector<vector<bool>>& ocean,int r, int c,int prev){\\n        if(r<0 || c<0 || r>=mat.size() || c>=mat[0].size() || prev>mat[r][c] || ocean[r][c]==true)\\n            return;\\n        ocean[r][c]=true;\\n        \\n        dfs(mat,ocean,r+1,c,mat[r][c]);\\n        dfs(mat,ocean,r-1,c,mat[r][c]);\\n        dfs(mat,ocean,r,c+1,mat[r][c]);\\n        dfs(mat,ocean,r,c-1,mat[r][c]);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<vector<bool>>pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>>atlantic(m, vector<bool>(n,false));\\n        vector<vector<int>> result;\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(mat,pacific,0,i,-1); //for pacific top\\n            dfs(mat,atlantic,m-1,i,-1); //for atlantic bottom\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            dfs(mat,pacific,i,0,-1); //for pacific left\\n            dfs(mat,atlantic,i,n-1,-1); //for atlantic right\\n        }\\n        \\n        //cal result\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    result.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    void dfs(vector<vector<int>>& mat,vector<vector<bool>>& ocean,int r, int c,int prev){\\n        if(r<0 || c<0 || r>=mat.size() || c>=mat[0].size() || prev>mat[r][c] || ocean[r][c]==true)\\n            return;\\n        ocean[r][c]=true;\\n        \\n        dfs(mat,ocean,r+1,c,mat[r][c]);\\n        dfs(mat,ocean,r-1,c,mat[r][c]);\\n        dfs(mat,ocean,r,c+1,mat[r][c]);\\n        dfs(mat,ocean,r,c-1,mat[r][c]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832716,
                "title": "java-simple-bfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        List<List<Integer>> ans=new LinkedList<>();\\n        int m=heights.length,n=heights[0].length;\\n        boolean[][] visPacific=new boolean[m][n],visAtlantic=new boolean[m][n];\\n        Queue<int[]> queuePacific=new LinkedList<>(),queueAtlantic=new LinkedList<>();\\n        for(int i=0;i<m;i++)\\n        {\\n            visPacific[i][0]=true;\\n            visAtlantic[i][n-1]=true;\\n            queuePacific.offer(new int[]{i,0});\\n            queueAtlantic.offer(new int[]{i,n-1});\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            visPacific[0][i]=true;\\n            visAtlantic[m-1][i]=true;\\n            queuePacific.offer(new int[]{0,i});\\n            queueAtlantic.offer(new int[]{m-1,i});\\n        }\\n        bfs(queuePacific,visPacific,heights,m,n);\\n        bfs(queueAtlantic,visAtlantic,heights,m,n);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(visPacific[i][j]&&visAtlantic[i][j])\\n                {\\n                    List<Integer> temp=new LinkedList<>();\\n                    temp.add(i);\\n                    temp.add(j);\\n                    ans.add(temp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    void bfs(Queue<int[]> queue,boolean[][] vis,int[][] heights,int m,int n)\\n    {\\n        int[][] dirs={{1,0},{-1,0},{0,1},{0,-1}};\\n        while(!queue.isEmpty())\\n        {\\n            int[] curr=queue.poll();\\n            for(int[] dir:dirs)\\n            {\\n                int newX=curr[0]+dir[0];\\n                int newY=curr[1]+dir[1];\\n                if(newX>=0&&newY>=0&&newX<m&&newY<n&&!vis[newX][newY]\\n                   &&heights[curr[0]][curr[1]]<=heights[newX][newY])\\n                {\\n                    vis[newX][newY]=true;\\n                    queue.offer(new int[]{newX,newY});\\n                }\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        List<List<Integer>> ans=new LinkedList<>();\\n        int m=heights.length,n=heights[0].length;\\n        boolean[][] visPacific=new boolean[m][n],visAtlantic=new boolean[m][n];\\n        Queue<int[]> queuePacific=new LinkedList<>(),queueAtlantic=new LinkedList<>();\\n        for(int i=0;i<m;i++)\\n        {\\n            visPacific[i][0]=true;\\n            visAtlantic[i][n-1]=true;\\n            queuePacific.offer(new int[]{i,0}",
                "codeTag": "Java"
            },
            {
                "id": 1713076,
                "title": "dfs-approach-explained-using-comments-c",
                "content": "```\\nclass Solution {\\npublic:    \\n    /*\\n                     pacific\\n            \\n            pacific   m x n   atlantic\\n                     \\n                     atlantic\\n                     \\n            overflow if neighbouring cell\\'s height <= heights[i][j]\\n            \\n            Brute Force: Apply DFS for each cell and check if water is flowing into both the oceans from\\n                         that cell or not\\n                         O(m*n*(m+n))\\n                         \\n            Optimal: find from which grids water can flow into pacific and atlantic separately using DFS\\n                     return grids where both values are true\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t TC: O(mn)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t SC: O(mn)\\n            \\n        */\\n\\n    void dfsOcean(int i, int j, int prev, vector<vector<int>>& heights, vector<vector<bool>>&ocean)\\n    {\\n        int m= heights.size(), n= heights[0].size();\\n        \\n        // if we are out of bounds or its height is lesser than prev cell and water can\\'t flow\\n        if(i<0 || i>=m || j<0 || j>=n || prev>heights[i][j])\\n            return;\\n        \\n        //water can already flow from that cell probably to other direction\\n        if(ocean[i][j]==true)\\n            return;\\n        \\n        // otherwise we\\'ll mark that water can flow from here to prev \\n        ocean[i][j]= true;\\n        \\n        // and make travel further 4 directionally\\n        dfsOcean(i+1,j,heights[i][j],heights,ocean);\\n        dfsOcean(i-1,j,heights[i][j],heights,ocean);\\n        dfsOcean(i,j+1,heights[i][j],heights,ocean);\\n        dfsOcean(i,j-1,heights[i][j],heights,ocean);\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        int m= heights.size(), n= heights[0].size();\\n        vector<vector<int>> ans;\\n        vector<vector<bool>>pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>>atlantic(m, vector<bool>(n,false));\\n               \\n        \\n        // DFS for left and right edges\\n        for(int i=0; i<m; i++)\\n        {\\n            dfsOcean(i,0,heights[i][0],heights,pacific);\\n            dfsOcean(i,n-1,heights[i][n-1],heights,atlantic);\\n        }\\n        \\n        // DFS for top and bottom edges\\n        for(int j=0; j<n; j++)\\n        {\\n            dfsOcean(0,j,heights[0][j],heights,pacific);\\n            dfsOcean(m-1,j,heights[m-1][j],heights,atlantic);\\n        }\\n        \\n        // cells from which water can flow to both Pacific and Atlantic oceans\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(pacific[i][j] && atlantic[i][j])\\n                    ans.push_back({i,j}); \\n                   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    /*\\n                     pacific\\n            \\n            pacific   m x n   atlantic\\n                     \\n                     atlantic\\n                     \\n            overflow if neighbouring cell\\'s height <= heights[i][j]\\n            \\n            Brute Force: Apply DFS for each cell and check if water is flowing into both the oceans from\\n                         that cell or not\\n                         O(m*n*(m+n))\\n                         \\n            Optimal: find from which grids water can flow into pacific and atlantic separately using DFS\\n                     return grids where both values are true\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t TC: O(mn)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t SC: O(mn)\\n            \\n        */\\n\\n    void dfsOcean(int i, int j, int prev, vector<vector<int>>& heights, vector<vector<bool>>&ocean)\\n    {\\n        int m= heights.size(), n= heights[0].size();\\n        \\n        // if we are out of bounds or its height is lesser than prev cell and water can\\'t flow\\n        if(i<0 || i>=m || j<0 || j>=n || prev>heights[i][j])\\n            return;\\n        \\n        //water can already flow from that cell probably to other direction\\n        if(ocean[i][j]==true)\\n            return;\\n        \\n        // otherwise we\\'ll mark that water can flow from here to prev \\n        ocean[i][j]= true;\\n        \\n        // and make travel further 4 directionally\\n        dfsOcean(i+1,j,heights[i][j],heights,ocean);\\n        dfsOcean(i-1,j,heights[i][j],heights,ocean);\\n        dfsOcean(i,j+1,heights[i][j],heights,ocean);\\n        dfsOcean(i,j-1,heights[i][j],heights,ocean);\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        \\n        int m= heights.size(), n= heights[0].size();\\n        vector<vector<int>> ans;\\n        vector<vector<bool>>pacific(m, vector<bool>(n,false));\\n        vector<vector<bool>>atlantic(m, vector<bool>(n,false));\\n               \\n        \\n        // DFS for left and right edges\\n        for(int i=0; i<m; i++)\\n        {\\n            dfsOcean(i,0,heights[i][0],heights,pacific);\\n            dfsOcean(i,n-1,heights[i][n-1],heights,atlantic);\\n        }\\n        \\n        // DFS for top and bottom edges\\n        for(int j=0; j<n; j++)\\n        {\\n            dfsOcean(0,j,heights[0][j],heights,pacific);\\n            dfsOcean(m-1,j,heights[m-1][j],heights,atlantic);\\n        }\\n        \\n        // cells from which water can flow to both Pacific and Atlantic oceans\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(pacific[i][j] && atlantic[i][j])\\n                    ans.push_back({i,j}); \\n                   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570957,
                "title": "java-dfs-similar-to-no-of-islands",
                "content": "Idea is similar to Number of Islands and initiating search from corners of the heights matrix.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int m = heights.length;\\n        int n = heights[0].length;\\n        \\n        boolean[][] pacific= new boolean[m][n];\\n        boolean[][] atlantic = new boolean[m][n];\\n        \\n        for(int i = 0 ; i< m ; i++){\\n            dfs(heights,i , 0 , -1,pacific);\\n            dfs(heights,i, n-1,-1, atlantic);\\n        }\\n        \\n        for(int j = 0 ; j<n;j++){\\n            dfs(heights,0, j , -1,pacific);\\n            dfs(heights,m-1,j,-1, atlantic);\\n        }\\n        \\n        \\n        for(int i = 0 ; i < m; i++){\\n            for(int j = 0 ; j < n; j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    result.add(Arrays.asList(i,j));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void dfs(int[][] heights,int i, int j, int prev , boolean[][] reachable){\\n        if( i < 0 || j < 0|| i >= heights.length || j >= heights[0].length){\\n            return;\\n        }\\n        \\n        if(reachable[i][j]){\\n            return;\\n        }\\n        \\n        if(heights[i][j] < prev){\\n            return;\\n        }\\n        reachable[i][j]= true;\\n        \\n        dfs(heights, i+1 , j , heights[i][j], reachable);\\n        dfs( heights,i-1,j, heights[i][j], reachable);\\n        dfs(heights, i, j+1, heights[i][j], reachable);\\n        dfs(heights,i , j-1, heights[i][j], reachable);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n        int m = heights.length;\\n        int n = heights[0].length;\\n        \\n        boolean[][] pacific= new boolean[m][n];\\n        boolean[][] atlantic = new boolean[m][n];\\n        \\n        for(int i = 0 ; i< m ; i++){\\n            dfs(heights,i , 0 , -1,pacific);\\n            dfs(heights,i, n-1,-1, atlantic);\\n        }\\n        \\n        for(int j = 0 ; j<n;j++){\\n            dfs(heights,0, j , -1,pacific);\\n            dfs(heights,m-1,j,-1, atlantic);\\n        }\\n        \\n        \\n        for(int i = 0 ; i < m; i++){\\n            for(int j = 0 ; j < n; j++){\\n                if(pacific[i][j] && atlantic[i][j]){\\n                    result.add(Arrays.asList(i,j));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public void dfs(int[][] heights,int i, int j, int prev , boolean[][] reachable){\\n        if( i < 0 || j < 0|| i >= heights.length || j >= heights[0].length){\\n            return;\\n        }\\n        \\n        if(reachable[i][j]){\\n            return;\\n        }\\n        \\n        if(heights[i][j] < prev){\\n            return;\\n        }\\n        reachable[i][j]= true;\\n        \\n        dfs(heights, i+1 , j , heights[i][j], reachable);\\n        dfs( heights,i-1,j, heights[i][j], reachable);\\n        dfs(heights, i, j+1, heights[i][j], reachable);\\n        dfs(heights,i , j-1, heights[i][j], reachable);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394423,
                "title": "c-solution-using-dfs-approach-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n        void helper(vector<vector<int> > &mat,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n\\n    if(i<0 or j<0 or i>=m or j>=n or visited[i][j]){\\n        return;\\n    }\\n    visited[i][j]=true;\\n    // check on four direction if they exist\\n    if(i-1>=0 && mat[i][j] <= mat[i-1][j] and !visited[i-1][j]){\\n        helper(mat,i-1,j,m,n,visited);\\n    }\\n    if(j-1>=0 && mat[i][j] <= mat[i][j-1] and !visited[i][j-1]){\\n        helper(mat,i,j-1,m,n,visited);\\n    }\\n    if(i+1<m && mat[i][j] <= mat[i+1][j] and !visited[i+1][j]){\\n        helper(mat,i+1,j,m,n,visited);\\n    }\\n    if(j+1<n && mat[i][j] <= mat[i][j+1] and !visited[i][j+1]){\\n        helper(mat,i,j+1,m,n,visited);\\n    }\\n    return;\\n}    \\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat){\\n    int m=mat.size();\\n    if(m==0){\\n        return {};\\n    }\\n    int n=mat[0].size();\\n    \\n    // int count=0;\\n    vector<vector<bool>> blue(m,vector<bool>(n,false));\\n    vector<vector<bool>> red(m,vector<bool>(n,false));\\n    \\n    for(int i=0;i<m;i++){\\n        helper(mat,i,0,m,n,blue);\\n        helper(mat,i,n-1,m,n,red);\\n    }\\n    for(int j=0;j<n;j++){\\n        helper(mat,0,j,m,n,blue);\\n        helper(mat,m-1,j,m,n,red);\\n    }\\n        vector<vector<int>>ans;\\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n            if(blue[i][j]&&red[i][j]){\\n                ans.push_back({i,j});\\n            }\\n        }\\n    }\\n    // return count;\\n        // cout<<ans.size();\\n        return ans;\\n}\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        void helper(vector<vector<int> > &mat,int i,int j,int m,int n,vector<vector<bool>>& visited){\\n\\n    if(i<0 or j<0 or i>=m or j>=n or visited[i][j]){\\n        return;\\n    }\\n    visited[i][j]=true;\\n    // check on four direction if they exist\\n    if(i-1>=0 && mat[i][j] <= mat[i-1][j] and !visited[i-1][j]){\\n        helper(mat,i-1,j,m,n,visited);\\n    }\\n    if(j-1>=0 && mat[i][j] <= mat[i][j-1] and !visited[i][j-1]){\\n        helper(mat,i,j-1,m,n,visited);\\n    }\\n    if(i+1<m && mat[i][j] <= mat[i+1][j] and !visited[i+1][j]){\\n        helper(mat,i+1,j,m,n,visited);\\n    }\\n    if(j+1<n && mat[i][j] <= mat[i][j+1] and !visited[i][j+1]){\\n        helper(mat,i,j+1,m,n,visited);\\n    }\\n    return;\\n}    \\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat){\\n    int m=mat.size();\\n    if(m==0){\\n        return {};\\n    }\\n    int n=mat[0].size();\\n    \\n    // int count=0;\\n    vector<vector<bool>> blue(m,vector<bool>(n,false));\\n    vector<vector<bool>> red(m,vector<bool>(n,false));\\n    \\n    for(int i=0;i<m;i++){\\n        helper(mat,i,0,m,n,blue);\\n        helper(mat,i,n-1,m,n,red);\\n    }\\n    for(int j=0;j<n;j++){\\n        helper(mat,0,j,m,n,blue);\\n        helper(mat,m-1,j,m,n,red);\\n    }\\n        vector<vector<int>>ans;\\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n            if(blue[i][j]&&red[i][j]){\\n                ans.push_back({i,j});\\n            }\\n        }\\n    }\\n    // return count;\\n        // cout<<ans.size();\\n        return ans;\\n}\\n\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1127040,
                "title": "rust-dfs-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn pacific_atlantic(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        if matrix.is_empty() {\\n            return Vec::new();\\n        }\\n        let (m, n) = (matrix.len(), matrix[0].len());\\n        let mut p_reacheable = vec![vec![false; n]; m];\\n        let mut a_reacheable = vec![vec![false; n]; m];\\n        for i in 0..m {\\n            Self::dfs(&mut p_reacheable, &matrix, (i, 0));\\n            Self::dfs(&mut a_reacheable, &matrix, (i, n - 1));\\n        }\\n        for j in 0..n {\\n            Self::dfs(&mut p_reacheable, &matrix, (0, j));\\n            Self::dfs(&mut a_reacheable, &matrix, (m - 1, j));\\n        }\\n        let mut answer = Vec::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                if p_reacheable[i][j] && a_reacheable[i][j] {\\n                    answer.push([i as i32, j as i32].to_vec());\\n                }\\n            }\\n        }\\n        answer\\n    }\\n    fn dfs(reachable: &mut Vec<Vec<bool>>, matrix: &[Vec<i32>], (i, j): (usize, usize)) {\\n        reachable[i][j] = true;\\n        for &(di, dj) in &[(-1, 0), (0, -1), (0, 1), (1, 0)] {\\n            let ni = i as i32 + di;\\n            let nj = j as i32 + dj;\\n            if (0..matrix.len() as i32).contains(&ni)\\n                && (0..matrix[0].len() as i32).contains(&nj)\\n                && !reachable[ni as usize][nj as usize]\\n                && matrix[ni as usize][nj as usize] >= matrix[i][j]\\n            {\\n                Self::dfs(reachable, matrix, (ni as usize, nj as usize));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn pacific_atlantic(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        if matrix.is_empty() {\\n            return Vec::new();\\n        }\\n        let (m, n) = (matrix.len(), matrix[0].len());\\n        let mut p_reacheable = vec![vec![false; n]; m];\\n        let mut a_reacheable = vec![vec![false; n]; m];\\n        for i in 0..m {\\n            Self::dfs(&mut p_reacheable, &matrix, (i, 0));\\n            Self::dfs(&mut a_reacheable, &matrix, (i, n - 1));\\n        }\\n        for j in 0..n {\\n            Self::dfs(&mut p_reacheable, &matrix, (0, j));\\n            Self::dfs(&mut a_reacheable, &matrix, (m - 1, j));\\n        }\\n        let mut answer = Vec::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                if p_reacheable[i][j] && a_reacheable[i][j] {\\n                    answer.push([i as i32, j as i32].to_vec());\\n                }\\n            }\\n        }\\n        answer\\n    }\\n    fn dfs(reachable: &mut Vec<Vec<bool>>, matrix: &[Vec<i32>], (i, j): (usize, usize)) {\\n        reachable[i][j] = true;\\n        for &(di, dj) in &[(-1, 0), (0, -1), (0, 1), (1, 0)] {\\n            let ni = i as i32 + di;\\n            let nj = j as i32 + dj;\\n            if (0..matrix.len() as i32).contains(&ni)\\n                && (0..matrix[0].len() as i32).contains(&nj)\\n                && !reachable[ni as usize][nj as usize]\\n                && matrix[ni as usize][nj as usize] >= matrix[i][j]\\n            {\\n                Self::dfs(reachable, matrix, (ni as usize, nj as usize));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126921,
                "title": "simple-easy-to-understand-c",
                "content": "this can also be done using one matrix, but to make easy to understand i made separate matrix for cells reachable from pacific and cells reachable from atlantic\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        if(mat.size()==0) return {};\\n        n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pacific(n, vector<int>(m, 0));\\n        vector<vector<int>> atlantic(n, vector<int>(m, 0));\\n        for(int j=0;j<m;j++)\\n        {\\n            if(pacific[0][j]==0)  dfs(0, j, pacific, mat);   // starting from row 1, cells reachable\\n            if(atlantic[n-1][j]==0)  dfs(n-1, j, atlantic, mat); //starting from last row cells reachable\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n           if(pacific[i][0]==0)  dfs(i, 0, pacific, mat);   // starting from column 1, cells reachable\\n           if(atlantic[i][m-1]==0)  dfs(i, m-1, atlantic, mat); //starting from last column cells reachable\\n        }\\n        \\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                if(pacific[i][j]==atlantic[i][j] && pacific[i][j]==-1)  // overlapping reachable cells are the answers\\n                    v.push_back({i, j});\\n        }\\n        return v;\\n    }\\n    \\n    void dfs(int x, int y, vector<vector<int>>& dummy, vector<vector<int>>& mat)\\n    {\\n        if(dummy[x][y]==-1) return ;\\n        dummy[x][y] = -1;\\n        for(auto p : dirs)\\n        {\\n            int i = x + p.first, j = y + p.second;\\n            if(i>=0 && j>=0 && i<n && j<m &&  mat[i][j]>=mat[x][y] && dummy[i][j]==0)\\n                dfs(i, j, dummy, mat);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<pair<int, int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        if(mat.size()==0) return {};\\n        n = mat.size(), m = mat[0].size();\\n        vector<vector<int>> pacific(n, vector<int>(m, 0));\\n        vector<vector<int>> atlantic(n, vector<int>(m, 0));\\n        for(int j=0;j<m;j++)\\n        {\\n            if(pacific[0][j]==0)  dfs(0, j, pacific, mat);   // starting from row 1, cells reachable\\n            if(atlantic[n-1][j]==0)  dfs(n-1, j, atlantic, mat); //starting from last row cells reachable\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n           if(pacific[i][0]==0)  dfs(i, 0, pacific, mat);   // starting from column 1, cells reachable\\n           if(atlantic[i][m-1]==0)  dfs(i, m-1, atlantic, mat); //starting from last column cells reachable\\n        }\\n        \\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                if(pacific[i][j]==atlantic[i][j] && pacific[i][j]==-1)  // overlapping reachable cells are the answers\\n                    v.push_back({i, j});\\n        }\\n        return v;\\n    }\\n    \\n    void dfs(int x, int y, vector<vector<int>>& dummy, vector<vector<int>>& mat)\\n    {\\n        if(dummy[x][y]==-1) return ;\\n        dummy[x][y] = -1;\\n        for(auto p : dirs)\\n        {\\n            int i = x + p.first, j = y + p.second;\\n            if(i>=0 && j>=0 && i<n && j<m &&  mat[i][j]>=mat[x][y] && dummy[i][j]==0)\\n                dfs(i, j, dummy, mat);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126698,
                "title": "python-bfs",
                "content": "Let\\'s think of the grid as a graph (as water can \"meander\"). There is an edge between `(x, y)` and `(z, t)` if they are adjacent and `matrix[x][y] <= matrix[z][t]`. This defines the adjacency between each node of the graph (that is, each cell of the grid). The function `adjacent` below returns all nodes in the adjacency graph of `(r, c)`.\\n\\nWe need BFS twice, one for nodes that have access to the Atlantic, and one for the ones with access to the Pacific. For the Atlantic we initially have all the cells on the right and bottom sides, we find all nodes that can be achieved from this set of nodes. Same for Pacific but start from cells on the left and top sides. Note that, this way you need to run BFS only once for each ocean, visited notes will not be visited again. Once finished, return all the nodes that have access to both oceans.\\n\\nTime: `O(RC)`\\nSpace: `O(RC)`\\n\\n```python\\nclass Solution:\\n    def pacificAtlantic(self, matrix):\\n        if not matrix: return []\\n        R, C = len(matrix), len(matrix[0])\\n        \\n        #get adjacent nodes, i.e. there is an edge\\n        def adjacent(r, c):\\n            for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\\n                if 0 <= i < R and 0 <= j < C and matrix[r][c] <= matrix[i][j]:\\n                    yield (i, j)\\n        \\n        #Atlantic BFS\\n        que = collections.deque([])\\n        atlantic = [[0]*C for _ in range(R)]\\n        for r in range(R):\\n            que.append((r, C-1))\\n        for c in range(C-1):\\n            que.append((R-1, c))\\n        while que:\\n            r, c = que.popleft()\\n            atlantic[r][c] = 1\\n            for i, j in adjacent(r, c):\\n                if not atlantic[i][j]:\\n                    que.append((i, j))\\n        \\n        #Pacific BFS\\n        que = collections.deque([])\\n        pacific = [[0]*C for _ in range(R)]\\n        for r in range(R):\\n            que.append((r, 0))\\n        for c in range(1, C):\\n            que.append((0, c))\\n        while que:\\n            r, c = que.popleft()\\n            pacific[r][c] = 1\\n            for i, j in adjacent(r, c):\\n                if not pacific[i][j]:\\n                    que.append((i, j))\\n        \\n        #Find all nodes that can access both Oceans\\n        ans = []\\n        for r in range(R):\\n            for c in range(C):\\n                if atlantic[r][c] and pacific[r][c]:\\n                    ans.append([r, c])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def pacificAtlantic(self, matrix):\\n        if not matrix: return []\\n        R, C = len(matrix), len(matrix[0])\\n        \\n        #get adjacent nodes, i.e. there is an edge\\n        def adjacent(r, c):\\n            for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\\n                if 0 <= i < R and 0 <= j < C and matrix[r][c] <= matrix[i][j]:\\n                    yield (i, j)\\n        \\n        #Atlantic BFS\\n        que = collections.deque([])\\n        atlantic = [[0]*C for _ in range(R)]\\n        for r in range(R):\\n            que.append((r, C-1))\\n        for c in range(C-1):\\n            que.append((R-1, c))\\n        while que:\\n            r, c = que.popleft()\\n            atlantic[r][c] = 1\\n            for i, j in adjacent(r, c):\\n                if not atlantic[i][j]:\\n                    que.append((i, j))\\n        \\n        #Pacific BFS\\n        que = collections.deque([])\\n        pacific = [[0]*C for _ in range(R)]\\n        for r in range(R):\\n            que.append((r, 0))\\n        for c in range(1, C):\\n            que.append((0, c))\\n        while que:\\n            r, c = que.popleft()\\n            pacific[r][c] = 1\\n            for i, j in adjacent(r, c):\\n                if not pacific[i][j]:\\n                    que.append((i, j))\\n        \\n        #Find all nodes that can access both Oceans\\n        ans = []\\n        for r in range(R):\\n            for c in range(C):\\n                if atlantic[r][c] and pacific[r][c]:\\n                    ans.append([r, c])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126651,
                "title": "java-bfs-readable-code",
                "content": "**Question Statement :**\\nquestion statement is poorly worded . Basically in question water will flow from smaller to higher. i.e if neighbour have height greater than or equal to me than my water will flow to neighbour.\\n\\n**APPROCH:**\\n* make 2 queues add all the pacific island into pacific queue and atlantic island into atlantic queue\\n* also maintain 2 visited matrix to avoid infinte loop and also at last to check that both water is present at particular island or not.\\n* now run BFS on both queues to mark all island where water from particular ocean can reach.\\n* Atlast check for every island whether water from both ocean have reached here or not.\\n\\n\\n**Code:**\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n      List<List<Integer>> ans=new ArrayList<>();\\n      if(matrix.length==0 || matrix==null) return ans;\\n        \\n      boolean[][] pacific=new boolean[matrix.length][matrix[0].length];\\n      boolean[][] atlantic=new boolean[matrix.length][matrix[0].length];  \\n        \\n      Queue<Pair> pQue=new ArrayDeque<>();  //pQue: pacific Queue\\n      Queue<Pair> aQue=new ArrayDeque<>();  //aQue: atlantic Queue\\n        \\n      //1.Adding 1st col and 1st row -> pacific queue && last row and last col -> atlantic queue add \\n       \\n        int fc=0;   //fc:first column\\n        int lc=matrix[0].length-1; //lc:last column\\n      for(int r=0;r<matrix.length;r++){\\n         Pair pp=new Pair(r,fc);  //pp: pacific pair\\n         Pair ap=new Pair(r,lc);  //ap : atlantic pair\\n         \\n          pQue.add(pp);\\n          aQue.add(ap);\\n      }\\n        \\n       int fr=0;  //fr:first row\\n       int lr=matrix.length-1; //lr:last row\\n       for(int c=0;c<matrix[0].length;c++){\\n           Pair pp=new Pair(fr,c);\\n           Pair ap=new Pair(lr,c);\\n           \\n           pQue.add(pp);\\n           aQue.add(ap); \\n       } \\n        \\n        Bfs(pQue,pacific,matrix);\\n        Bfs(aQue,atlantic,matrix);\\n        \\n        for(int r=0;r<matrix.length;r++){\\n           for(int c=0;c<matrix[0].length;c++){\\n              if(pacific[r][c] && atlantic[r][c]){\\n                  //both visited means water from both ocean is there \\n                  List<Integer> both=new ArrayList<>();\\n                  both.add(r); both.add(c);\\n                  ans.add(both);\\n              }\\n           } \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void Bfs(Queue<Pair> que,boolean[][] visited,int[][] matrix){\\n         \\n        while(que.size()>0){\\n            Pair top=que.remove();\\n            int r=top.r;\\n            int c=top.c;\\n            int h=matrix[r][c];\\n            \\n           if(visited[r][c]) continue;\\n            visited[r][c]=true;\\n            \\n          for(int i=0;i<4;i++){\\n              int nr=r+dx[i];\\n              int nc=c+dy[i];\\n              \\n             if(isValid(nr,nc,visited)){\\n                 int nh=matrix[nr][nc]; //nh:new height\\n                 if(nh>=h){   //if height is greater than or equal to me then water can flow\\n                     Pair np=new Pair(nr,nc);\\n                     que.add(np);\\n                 }\\n             } \\n          }  \\n         }\\n    }\\n    \\n    private final int[] dx={-1,1,0,0}; // private and final can convert your hire into strong hire in interview:)\\n    private final int[] dy={0,0,1,-1};\\n    \\n    private boolean isValid(int r,int c,boolean[][] visited){\\n     if(r<0 || c<0 || r>=visited.length || c>=visited[0].length || visited[r][c]) return false;\\n        return true;\\n    }\\n    \\n    public class Pair{\\n        int r;\\n        int c;\\n     \\n        Pair(int r,int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n        \\n        Pair(){\\n            \\n        }\\n    }\\n}\\n```\\n**Complexity :** `O(n*m) and Space:O(n*m)`\\n\\nCan be solved using dfs also.\\nPlease do **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n      List<List<Integer>> ans=new ArrayList<>();\\n      if(matrix.length==0 || matrix==null) return ans;\\n        \\n      boolean[][] pacific=new boolean[matrix.length][matrix[0].length];\\n      boolean[][] atlantic=new boolean[matrix.length][matrix[0].length];  \\n        \\n      Queue<Pair> pQue=new ArrayDeque<>();  //pQue: pacific Queue\\n      Queue<Pair> aQue=new ArrayDeque<>();  //aQue: atlantic Queue\\n        \\n      //1.Adding 1st col and 1st row -> pacific queue && last row and last col -> atlantic queue add \\n       \\n        int fc=0;   //fc:first column\\n        int lc=matrix[0].length-1; //lc:last column\\n      for(int r=0;r<matrix.length;r++){\\n         Pair pp=new Pair(r,fc);  //pp: pacific pair\\n         Pair ap=new Pair(r,lc);  //ap : atlantic pair\\n         \\n          pQue.add(pp);\\n          aQue.add(ap);\\n      }\\n        \\n       int fr=0;  //fr:first row\\n       int lr=matrix.length-1; //lr:last row\\n       for(int c=0;c<matrix[0].length;c++){\\n           Pair pp=new Pair(fr,c);\\n           Pair ap=new Pair(lr,c);\\n           \\n           pQue.add(pp);\\n           aQue.add(ap); \\n       } \\n        \\n        Bfs(pQue,pacific,matrix);\\n        Bfs(aQue,atlantic,matrix);\\n        \\n        for(int r=0;r<matrix.length;r++){\\n           for(int c=0;c<matrix[0].length;c++){\\n              if(pacific[r][c] && atlantic[r][c]){\\n                  //both visited means water from both ocean is there \\n                  List<Integer> both=new ArrayList<>();\\n                  both.add(r); both.add(c);\\n                  ans.add(both);\\n              }\\n           } \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void Bfs(Queue<Pair> que,boolean[][] visited,int[][] matrix){\\n         \\n        while(que.size()>0){\\n            Pair top=que.remove();\\n            int r=top.r;\\n            int c=top.c;\\n            int h=matrix[r][c];\\n            \\n           if(visited[r][c]) continue;\\n            visited[r][c]=true;\\n            \\n          for(int i=0;i<4;i++){\\n              int nr=r+dx[i];\\n              int nc=c+dy[i];\\n              \\n             if(isValid(nr,nc,visited)){\\n                 int nh=matrix[nr][nc]; //nh:new height\\n                 if(nh>=h){   //if height is greater than or equal to me then water can flow\\n                     Pair np=new Pair(nr,nc);\\n                     que.add(np);\\n                 }\\n             } \\n          }  \\n         }\\n    }\\n    \\n    private final int[] dx={-1,1,0,0}; // private and final can convert your hire into strong hire in interview:)\\n    private final int[] dy={0,0,1,-1};\\n    \\n    private boolean isValid(int r,int c,boolean[][] visited){\\n     if(r<0 || c<0 || r>=visited.length || c>=visited[0].length || visited[r][c]) return false;\\n        return true;\\n    }\\n    \\n    public class Pair{\\n        int r;\\n        int c;\\n     \\n        Pair(int r,int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n        \\n        Pair(){\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044701,
                "title": "understandable-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, 0, -1};\\n    int dy[4] = {-1, 0, 1, 0};\\n    \\n    void dfs(vector<vector<int>>& mat, vector<vector<int>> &g, int x, int y){\\n        g[x][y]=1;\\n        for(int i=0;i<4;i++){\\n           int xx=x+dx[i];\\n           int yy=y+dy[i];\\n           if(xx>=0 && yy>=0 && xx<mat.size() && yy<mat[0].size() && !g[xx][yy] && mat[xx][yy]>=mat[x][y])\\n               dfs(mat, g, xx, yy);\\n        } \\n    }\\n    \\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        int n=matrix.size();\\n        if(n==0)\\n            return ans;\\n        int m=matrix[0].size();\\n        if(m==0)\\n            return ans;\\n        vector<vector<int>> pac(n, vector<int>(m,0));\\n        vector<vector<int>> atl(n, vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            if(!pac[i][0]){\\n                dfs(matrix, pac, i, 0);\\n            }\\n        }\\n         for(int i=0;i<m;i++){\\n            if(!pac[0][i]){\\n                dfs(matrix, pac, 0, i);\\n            }\\n        }\\n         for(int i=0;i<n;i++){\\n            if(!atl[i][m-1]){\\n                dfs(matrix, atl, i, m-1);\\n            }\\n        }\\n         \\n         for(int i=0;i<m;i++){\\n            if(!atl[n-1][i]){\\n                dfs(matrix, atl, n-1, i);\\n            }\\n        }\\n        \\n        for (int i=0;i<n;i++) {\\n            for (int j=0;j<m;j++) {\\n                if (pac[i][j] && atl[i][j]){\\n                    ans.push_back({i, j});\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0, 1, 0, -1};\\n    int dy[4] = {-1, 0, 1, 0};\\n    \\n    void dfs(vector<vector<int>>& mat, vector<vector<int>> &g, int x, int y){\\n        g[x][y]=1;\\n        for(int i=0;i<4;i++){\\n           int xx=x+dx[i];\\n           int yy=y+dy[i];\\n           if(xx>=0 && yy>=0 && xx<mat.size() && yy<mat[0].size() && !g[xx][yy] && mat[xx][yy]>=mat[x][y])\\n               dfs(mat, g, xx, yy);\\n        } \\n    }\\n    \\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n        vector<vector<int>> ans;\\n        int n=matrix.size();\\n        if(n==0)\\n            return ans;\\n        int m=matrix[0].size();\\n        if(m==0)\\n            return ans;\\n        vector<vector<int>> pac(n, vector<int>(m,0));\\n        vector<vector<int>> atl(n, vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            if(!pac[i][0]){\\n                dfs(matrix, pac, i, 0);\\n            }\\n        }\\n         for(int i=0;i<m;i++){\\n            if(!pac[0][i]){\\n                dfs(matrix, pac, 0, i);\\n            }\\n        }\\n         for(int i=0;i<n;i++){\\n            if(!atl[i][m-1]){\\n                dfs(matrix, atl, i, m-1);\\n            }\\n        }\\n         \\n         for(int i=0;i<m;i++){\\n            if(!atl[n-1][i]){\\n                dfs(matrix, atl, n-1, i);\\n            }\\n        }\\n        \\n        for (int i=0;i<n;i++) {\\n            for (int j=0;j<m;j++) {\\n                if (pac[i][j] && atl[i][j]){\\n                    ans.push_back({i, j});\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000676,
                "title": "python-concise-code",
                "content": "Start from both the pacific and atlantic ocean and gather all the values that are within reach. The intersection of both the set is the answer.\\n```\\nclass Solution:\\n    \\n    def isValid(self, i, j, rows, cols):\\n        return 0 <= i < rows and 0 <= j < cols    \\n\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix:\\n            return []\\n        rows, cols = len(matrix), len(matrix[0])\\n        pacific, atlantic, ans = set(), set(), []\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        \\n        def dfs(matrix, i, j, ocean, prev):\\n            if not self.isValid(i, j, rows, cols) or ((i, j) in ocean):\\n                return\\n            if prev > matrix[i][j]:\\n                return\\n            ocean.add((i, j))\\n            for x, y in directions:\\n                dfs(matrix, i + x, j + y, ocean, matrix[i][j])\\n            \\n        for k in range(rows):\\n            dfs(matrix, k, 0, pacific, matrix[k][0])\\n            dfs(matrix, k, cols - 1, atlantic, matrix[k][cols - 1])\\n        \\n        for k in range(cols):\\n            dfs(matrix, 0, k, pacific, matrix[0][k])\\n            dfs(matrix, rows - 1, k, atlantic, matrix[rows - 1][k])\\n        \\n        return list(pacific.intersection(atlantic))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def isValid(self, i, j, rows, cols):\\n        return 0 <= i < rows and 0 <= j < cols    \\n\\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\\n        if not matrix:\\n            return []\\n        rows, cols = len(matrix), len(matrix[0])\\n        pacific, atlantic, ans = set(), set(), []\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        \\n        def dfs(matrix, i, j, ocean, prev):\\n            if not self.isValid(i, j, rows, cols) or ((i, j) in ocean):\\n                return\\n            if prev > matrix[i][j]:\\n                return\\n            ocean.add((i, j))\\n            for x, y in directions:\\n                dfs(matrix, i + x, j + y, ocean, matrix[i][j])\\n            \\n        for k in range(rows):\\n            dfs(matrix, k, 0, pacific, matrix[k][0])\\n            dfs(matrix, k, cols - 1, atlantic, matrix[k][cols - 1])\\n        \\n        for k in range(cols):\\n            dfs(matrix, 0, k, pacific, matrix[0][k])\\n            dfs(matrix, rows - 1, k, atlantic, matrix[rows - 1][k])\\n        \\n        return list(pacific.intersection(atlantic))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876244,
                "title": "using-dfs-and-more-readable",
                "content": "```\\npublic class Solution {\\n    public  IList<IList<int>> PacificAtlantic (int[][] matrix)\\n        {\\n            IList<IList<int>> Coordinates = new List<IList<int>>();\\n            \\n            if (matrix.Length == 0) return Coordinates;\\n            \\n            int row = matrix.Length;\\n            int column = matrix[0].Length;\\n            \\n            bool[,] pacific = new bool[row,column];\\n            bool[,] atlantic = new bool[row,column];\\n\\n            // two row > top for Pacific & bottom for atlantic\\n            for (int i = 0; i < column; i++)\\n            {\\n                Dfs(matrix,0,i,pacific,Int32.MinValue); \\n                Dfs(matrix,row-1,i,atlantic,Int32.MinValue);\\n            }\\n\\n            // two column > left for Pacific & right for atlantic\\n            for (int i = 0; i < row; i++)\\n            {\\n                Dfs(matrix, i, 0, pacific, Int32.MinValue);\\n                Dfs(matrix, i, column-1, atlantic, Int32.MinValue);\\n            }\\n\\n            // for final selections\\n            for (int i = 0; i < row; i++)\\n            {\\n                for (int j = 0; j < column; j++)\\n                {\\n                    if (pacific[i, j]==true && atlantic[i, j]==true )\\n                    {\\n                        IList<int> Coordinate = new List<int>();\\n                        Coordinate.Add(i);\\n                        Coordinate.Add(j);\\n                        Coordinates.Add(Coordinate);\\n                    }\\n                }\\n            }\\n\\n            return Coordinates;\\n        }\\n\\n        private void Dfs (int[][] matrix, int row, int column, bool[,] ocean, int prev)\\n        {\\n           \\n            if (IsValidParam(matrix, row, column, ocean, prev))\\n            {\\n                ocean[row, column] = true;\\n                Dfs(matrix,row-1,column,ocean,matrix[row][column]);\\n                Dfs(matrix,row+1,column,ocean,matrix[row][column]);\\n                Dfs(matrix,row,column+1,ocean,matrix[row][column]);\\n                Dfs(matrix,row,column-1,ocean,matrix[row][column]);\\n            }\\n        }\\n\\n        private bool IsValidParam (int[][] matrix, int r, int c, bool[,] ocean, int prev)\\n        {\\n            return (r >= 0 && c >= 0 && r < matrix.Length && c < matrix[0].Length && matrix[r][c] >= prev && ocean[r, c] != true);\\n        }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public  IList<IList<int>> PacificAtlantic (int[][] matrix)\\n        {\\n            IList<IList<int>> Coordinates = new List<IList<int>>();\\n            \\n            if (matrix.Length == 0) return Coordinates;\\n            \\n            int row = matrix.Length;\\n            int column = matrix[0].Length;\\n            \\n            bool[,] pacific = new bool[row,column];\\n            bool[,] atlantic = new bool[row,column];\\n\\n            // two row > top for Pacific & bottom for atlantic\\n            for (int i = 0; i < column; i++)\\n            {\\n                Dfs(matrix,0,i,pacific,Int32.MinValue); \\n                Dfs(matrix,row-1,i,atlantic,Int32.MinValue);\\n            }\\n\\n            // two column > left for Pacific & right for atlantic\\n            for (int i = 0; i < row; i++)\\n            {\\n                Dfs(matrix, i, 0, pacific, Int32.MinValue);\\n                Dfs(matrix, i, column-1, atlantic, Int32.MinValue);\\n            }\\n\\n            // for final selections\\n            for (int i = 0; i < row; i++)\\n            {\\n                for (int j = 0; j < column; j++)\\n                {\\n                    if (pacific[i, j]==true && atlantic[i, j]==true )\\n                    {\\n                        IList<int> Coordinate = new List<int>();\\n                        Coordinate.Add(i);\\n                        Coordinate.Add(j);\\n                        Coordinates.Add(Coordinate);\\n                    }\\n                }\\n            }\\n\\n            return Coordinates;\\n        }\\n\\n        private void Dfs (int[][] matrix, int row, int column, bool[,] ocean, int prev)\\n        {\\n           \\n            if (IsValidParam(matrix, row, column, ocean, prev))\\n            {\\n                ocean[row, column] = true;\\n                Dfs(matrix,row-1,column,ocean,matrix[row][column]);\\n                Dfs(matrix,row+1,column,ocean,matrix[row][column]);\\n                Dfs(matrix,row,column+1,ocean,matrix[row][column]);\\n                Dfs(matrix,row,column-1,ocean,matrix[row][column]);\\n            }\\n        }\\n\\n        private bool IsValidParam (int[][] matrix, int r, int c, bool[,] ocean, int prev)\\n        {\\n            return (r >= 0 && c >= 0 && r < matrix.Length && c < matrix[0].Length && matrix[r][c] >= prev && ocean[r, c] != true);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837190,
                "title": "java-with-comments",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(matrix.length > 0 && matrix[0].length > 0) {\\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            int[][] pacific = new int[m][n];\\n            int[][] atlantic = new int[m][n];\\n            \\n            //lets fill up the pacific, columns\\n            for(int i=0; i<n; i++) {\\n                dfs(matrix, pacific, 0, i, -1);\\n            }\\n            \\n            //lets fill up the pacific, rows\\n            for(int i=0; i<m; i++) {\\n                dfs(matrix, pacific, i, 0, -1);\\n            }\\n            \\n            //lets fill up the atlantic, columns\\n            for(int i=0; i<n; i++) {\\n                dfs(matrix, atlantic, m-1, i, -1);\\n            }\\n            \\n            //lets fill up the atlantic, rows\\n            for(int i=0; i<m; i++) {\\n                dfs(matrix, atlantic, i, n-1, -1);\\n            }\\n            \\n            //now compare both the arrays and accept those where the value is 1 in both matrix\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    if(pacific[i][j] == 1 && atlantic[i][j] == 1) {\\n                        List<Integer> curr = new ArrayList<>();\\n                        curr.add(i);\\n                        curr.add(j);\\n                        res.add(curr);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(int[][]matrix, int[][] grid, int i, int j, int prev) {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length) return;\\n        else if (matrix[i][j] < prev) return;\\n        else if (grid[i][j] == 1) return;\\n        grid[i][j] = 1;\\n        dfs(matrix, grid, i+1, j, matrix[i][j]);\\n        dfs(matrix, grid, i, j+1, matrix[i][j]);\\n        dfs(matrix, grid, i-1, j, matrix[i][j]);\\n        dfs(matrix, grid, i, j-1, matrix[i][j]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if(matrix.length > 0 && matrix[0].length > 0) {\\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            int[][] pacific = new int[m][n];\\n            int[][] atlantic = new int[m][n];\\n            \\n            //lets fill up the pacific, columns\\n            for(int i=0; i<n; i++) {\\n                dfs(matrix, pacific, 0, i, -1);\\n            }\\n            \\n            //lets fill up the pacific, rows\\n            for(int i=0; i<m; i++) {\\n                dfs(matrix, pacific, i, 0, -1);\\n            }\\n            \\n            //lets fill up the atlantic, columns\\n            for(int i=0; i<n; i++) {\\n                dfs(matrix, atlantic, m-1, i, -1);\\n            }\\n            \\n            //lets fill up the atlantic, rows\\n            for(int i=0; i<m; i++) {\\n                dfs(matrix, atlantic, i, n-1, -1);\\n            }\\n            \\n            //now compare both the arrays and accept those where the value is 1 in both matrix\\n            for(int i=0; i<m; i++) {\\n                for(int j=0; j<n; j++) {\\n                    if(pacific[i][j] == 1 && atlantic[i][j] == 1) {\\n                        List<Integer> curr = new ArrayList<>();\\n                        curr.add(i);\\n                        curr.add(j);\\n                        res.add(curr);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void dfs(int[][]matrix, int[][] grid, int i, int j, int prev) {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length) return;\\n        else if (matrix[i][j] < prev) return;\\n        else if (grid[i][j] == 1) return;\\n        grid[i][j] = 1;\\n        dfs(matrix, grid, i+1, j, matrix[i][j]);\\n        dfs(matrix, grid, i, j+1, matrix[i][j]);\\n        dfs(matrix, grid, i-1, j, matrix[i][j]);\\n        dfs(matrix, grid, i, j-1, matrix[i][j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773181,
                "title": "c-dfs",
                "content": "Pacific pass: mark Pacific watershed with \"1\" in the seen vector\\nAtlantic pass: DFS from Atlantic side and add any encountered cells marked with \"1\" to the result. \\n\\n```\\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n\\tif(matrix.empty()) return {};\\n\\tvector<vector<int>> res, seen(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\n\\t// Pacific pass\\n\\tfor(int i=0; i<matrix.size(); i++)\\n\\t\\tdfs(matrix, seen, 1, 0, i, 0, res);\\n\\tfor(int j=0; j<matrix[0].size(); j++)\\n\\t\\tdfs(matrix, seen, 1, 0, 0, j, res);\\n\\n\\t// Atlantic pass\\n\\tfor(int i=0; i<matrix.size(); i++)\\n\\t\\tdfs(matrix, seen, 2, 0, i, matrix[0].size()-1, res);\\n\\tfor(int j=0; j<matrix[0].size(); j++)\\n\\t\\tdfs(matrix, seen, 2, 0, matrix.size()-1, j, res);\\n\\n\\n\\treturn res;\\n}\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& seen, int val, int prev, int i, int j, vector<vector<int>>& res){\\n\\n\\tif(i<0||j<0||i==grid.size()||j==grid[0].size()||seen[i][j]==val||grid[i][j]<prev)\\n\\t\\treturn;\\n\\n\\tif(seen[i][j]!=0)          //for \"Atlantic\" pass only\\n\\t\\tres.push_back({i,j});\\n\\n\\tseen[i][j]=val;\\n\\n\\tdfs(grid, seen, val, grid[i][j], i+1, j, res);\\n\\tdfs(grid, seen, val, grid[i][j], i-1, j, res);\\n\\tdfs(grid, seen, val, grid[i][j], i, j+1, res);\\n\\tdfs(grid, seen, val, grid[i][j], i, j-1, res);\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\\n\\tif(matrix.empty()) return {};\\n\\tvector<vector<int>> res, seen(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\n\\t// Pacific pass\\n\\tfor(int i=0; i<matrix.size(); i++)\\n\\t\\tdfs(matrix, seen, 1, 0, i, 0, res);\\n\\tfor(int j=0; j<matrix[0].size(); j++)\\n\\t\\tdfs(matrix, seen, 1, 0, 0, j, res);\\n\\n\\t// Atlantic pass\\n\\tfor(int i=0; i<matrix.size(); i++)\\n\\t\\tdfs(matrix, seen, 2, 0, i, matrix[0].size()-1, res);\\n\\tfor(int j=0; j<matrix[0].size(); j++)\\n\\t\\tdfs(matrix, seen, 2, 0, matrix.size()-1, j, res);\\n\\n\\n\\treturn res;\\n}\\n\\nvoid dfs(vector<vector<int>>& grid, vector<vector<int>>& seen, int val, int prev, int i, int j, vector<vector<int>>& res){\\n\\n\\tif(i<0||j<0||i==grid.size()||j==grid[0].size()||seen[i][j]==val||grid[i][j]<prev)\\n\\t\\treturn;\\n\\n\\tif(seen[i][j]!=0)          //for \"Atlantic\" pass only\\n\\t\\tres.push_back({i,j});\\n\\n\\tseen[i][j]=val;\\n\\n\\tdfs(grid, seen, val, grid[i][j], i+1, j, res);\\n\\tdfs(grid, seen, val, grid[i][j], i-1, j, res);\\n\\tdfs(grid, seen, val, grid[i][j], i, j+1, res);\\n\\tdfs(grid, seen, val, grid[i][j], i, j-1, res);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767684,
                "title": "standard-java-solution",
                "content": "### Theory\\nThis is a very tricky DFS and BFS problem thats hard to anlayze, don\\'t feel bad if you needed to look at the answer to figure out the algorithm. The basic idea is that we need to start from the edges and explore to see if our neighbors are fulfill our exploration criteria.\\n\\n### Solution DFS\\n```\\n    private static final int[][] DIRECTIONS = new int[][] {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    \\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) return res;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        boolean[][] ableToReachPacific = new boolean[rows][cols];\\n        boolean[][] ableToReachAtlantic = new boolean[rows][cols];\\n        \\n        for (int i = 0; i < cols; i++) {\\n            dfs(matrix, 0 , i, ableToReachPacific, Integer.MIN_VALUE);\\n            dfs(matrix, rows - 1 , i, ableToReachAtlantic, Integer.MIN_VALUE);\\n        }\\n        \\n        for (int i = 0; i < rows; i++) {\\n            dfs(matrix, i, 0, ableToReachPacific, Integer.MIN_VALUE);\\n            dfs(matrix, i, cols - 1, ableToReachAtlantic, Integer.MIN_VALUE);\\n        }\\n        \\n        for (int i = 0; i < matrix.length; i++)\\n            for (int j = 0; j < matrix[0].length; j++)\\n                if (ableToReachPacific[i][j] && ableToReachAtlantic[i][j])\\n                    res.add(Arrays.asList(i, j));\\n        \\n        return res;\\n    }\\n    \\n    \\n    private boolean outOfBounds(int x, int y, int[][] matrix) {\\n        return x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length;\\n    }\\n    \\n    \\n    private void dfs(int[][]matrix, int i, int j, boolean[][] ableToReach, int prev) {\\n        if (outOfBounds(i, j, matrix) || matrix[i][j] < prev || ableToReach[i][j]) return;\\n        ableToReach[i][j] = true;\\n        for (int[] dir : DIRECTIONS) {\\n            int newI = i + dir[0], newJ = j + dir[1];\\n            dfs(matrix, newI, newJ, ableToReach, matrix[i][j]);\\n        }\\n    }\\n```\\n\\n### Solution BFS\\n```\\n    private static final int[][] DIRECTIONS = new int[][] {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    \\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) return res;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        boolean[][] ableToReachPacific = new boolean[rows][cols];\\n        boolean[][] ableToReachAtlantic = new boolean[rows][cols];\\n        Queue<int[]> pacificQ = new LinkedList<>(), atlanticQ = new LinkedList<>();\\n        for (int i = 0; i < cols; i++) {\\n            pacificQ.add(new int[] {0, i});\\n            ableToReachPacific[0][i] = true;\\n            atlanticQ.add(new int[] {rows - 1 , i});\\n            ableToReachAtlantic[rows - 1][i] = true;\\n        }\\n        \\n        for (int i = 0; i < rows; i++) {\\n            pacificQ.add(new int[] {i, 0});\\n            ableToReachPacific[i][0] = true;\\n            atlanticQ.add(new int[] {i , cols - 1});\\n            ableToReachAtlantic[i][cols - 1] = true;\\n        }\\n        \\n        bfs(pacificQ, ableToReachPacific, matrix);\\n        bfs(atlanticQ, ableToReachAtlantic, matrix);\\n\\n        for (int i = 0; i < matrix.length; i++)\\n            for (int j = 0; j < matrix[0].length; j++)\\n                if (ableToReachPacific[i][j] && ableToReachAtlantic[i][j])\\n                    res.add(Arrays.asList(i, j));\\n        \\n        return res;\\n    }\\n    \\n    \\n    private boolean outOfBounds(int x, int y, int[][] matrix) {\\n        return x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length;\\n    }\\n    \\n    \\n    private void bfs(Queue<int[]> queue, boolean[][] ableToReach, int[][] matrix) {\\n        \\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int prev = matrix[curr[0]][curr[1]];\\n            for (int[] dir : DIRECTIONS) {\\n                int newX = curr[0] + dir[0], newY = curr[1] + dir[1];\\n                if (outOfBounds(newX, newY, matrix) || ableToReach[newX][newY] || prev > matrix[newX][newY])\\n                    continue;\\n                \\n                queue.add(new int[] {newX, newY});\\n                ableToReach[newX][newY] = true;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static final int[][] DIRECTIONS = new int[][] {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    \\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) return res;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        boolean[][] ableToReachPacific = new boolean[rows][cols];\\n        boolean[][] ableToReachAtlantic = new boolean[rows][cols];\\n        \\n        for (int i = 0; i < cols; i++) {\\n            dfs(matrix, 0 , i, ableToReachPacific, Integer.MIN_VALUE);\\n            dfs(matrix, rows - 1 , i, ableToReachAtlantic, Integer.MIN_VALUE);\\n        }\\n        \\n        for (int i = 0; i < rows; i++) {\\n            dfs(matrix, i, 0, ableToReachPacific, Integer.MIN_VALUE);\\n            dfs(matrix, i, cols - 1, ableToReachAtlantic, Integer.MIN_VALUE);\\n        }\\n        \\n        for (int i = 0; i < matrix.length; i++)\\n            for (int j = 0; j < matrix[0].length; j++)\\n                if (ableToReachPacific[i][j] && ableToReachAtlantic[i][j])\\n                    res.add(Arrays.asList(i, j));\\n        \\n        return res;\\n    }\\n    \\n    \\n    private boolean outOfBounds(int x, int y, int[][] matrix) {\\n        return x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length;\\n    }\\n    \\n    \\n    private void dfs(int[][]matrix, int i, int j, boolean[][] ableToReach, int prev) {\\n        if (outOfBounds(i, j, matrix) || matrix[i][j] < prev || ableToReach[i][j]) return;\\n        ableToReach[i][j] = true;\\n        for (int[] dir : DIRECTIONS) {\\n            int newI = i + dir[0], newJ = j + dir[1];\\n            dfs(matrix, newI, newJ, ableToReach, matrix[i][j]);\\n        }\\n    }\\n```\n```\\n    private static final int[][] DIRECTIONS = new int[][] {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n    \\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        if (matrix == null || matrix.length == 0) return res;\\n        int rows = matrix.length, cols = matrix[0].length;\\n        boolean[][] ableToReachPacific = new boolean[rows][cols];\\n        boolean[][] ableToReachAtlantic = new boolean[rows][cols];\\n        Queue<int[]> pacificQ = new LinkedList<>(), atlanticQ = new LinkedList<>();\\n        for (int i = 0; i < cols; i++) {\\n            pacificQ.add(new int[] {0, i});\\n            ableToReachPacific[0][i] = true;\\n            atlanticQ.add(new int[] {rows - 1 , i});\\n            ableToReachAtlantic[rows - 1][i] = true;\\n        }\\n        \\n        for (int i = 0; i < rows; i++) {\\n            pacificQ.add(new int[] {i, 0});\\n            ableToReachPacific[i][0] = true;\\n            atlanticQ.add(new int[] {i , cols - 1});\\n            ableToReachAtlantic[i][cols - 1] = true;\\n        }\\n        \\n        bfs(pacificQ, ableToReachPacific, matrix);\\n        bfs(atlanticQ, ableToReachAtlantic, matrix);\\n\\n        for (int i = 0; i < matrix.length; i++)\\n            for (int j = 0; j < matrix[0].length; j++)\\n                if (ableToReachPacific[i][j] && ableToReachAtlantic[i][j])\\n                    res.add(Arrays.asList(i, j));\\n        \\n        return res;\\n    }\\n    \\n    \\n    private boolean outOfBounds(int x, int y, int[][] matrix) {\\n        return x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length;\\n    }\\n    \\n    \\n    private void bfs(Queue<int[]> queue, boolean[][] ableToReach, int[][] matrix) {\\n        \\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int prev = matrix[curr[0]][curr[1]];\\n            for (int[] dir : DIRECTIONS) {\\n                int newX = curr[0] + dir[0], newY = curr[1] + dir[1];\\n                if (outOfBounds(newX, newY, matrix) || ableToReach[newX][newY] || prev > matrix[newX][newY])\\n                    continue;\\n                \\n                queue.add(new int[] {newX, newY});\\n                ableToReach[newX][newY] = true;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402946,
                "title": "java-dfs",
                "content": "```\\nclass Solution \\n{\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) \\n    {\\n        List<List<Integer>> r = new ArrayList();\\n        int m = matrix.length;\\n        if (m == 0) return r;\\n        int n = matrix[0].length;\\n        if (n == 0) return r;\\n        \\n        // pacific\\n        boolean[][] pac = new boolean[m][n];\\n        for (int j = 0; j < n; ++j) dfs(matrix, pac, 0, j, 0);\\n        for (int i = 0; i < m; ++i) dfs(matrix, pac, i, 0, 0);\\n        \\n        // atlantic\\n        boolean[][] atl = new boolean[m][n];\\n        for (int j = 0; j < n; ++j) dfs(matrix, atl, m - 1, j, 0);\\n        for (int i = 0; i < m; ++i) dfs(matrix, atl, i, n - 1, 0);\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (pac[i][j] && atl[i][j]) r.add(new ArrayList(Arrays.asList(i, j)));\\n        \\n        return r;\\n    }\\n    \\n    int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    void dfs(int[][] M, boolean[][] visited, int i, int j, int prev)\\n    {\\n        if (i < 0 || i >= M.length || j < 0 || j >= M[0].length || visited[i][j] || M[i][j] < prev) return;\\n        visited[i][j] = true;\\n        for (int[] d : dir) dfs(M, visited, i + d[0], j + d[1], M[i][j]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public List<List<Integer>> pacificAtlantic(int[][] matrix) \\n    {\\n        List<List<Integer>> r = new ArrayList();\\n        int m = matrix.length;\\n        if (m == 0) return r;\\n        int n = matrix[0].length;\\n        if (n == 0) return r;\\n        \\n        // pacific\\n        boolean[][] pac = new boolean[m][n];\\n        for (int j = 0; j < n; ++j) dfs(matrix, pac, 0, j, 0);\\n        for (int i = 0; i < m; ++i) dfs(matrix, pac, i, 0, 0);\\n        \\n        // atlantic\\n        boolean[][] atl = new boolean[m][n];\\n        for (int j = 0; j < n; ++j) dfs(matrix, atl, m - 1, j, 0);\\n        for (int i = 0; i < m; ++i) dfs(matrix, atl, i, n - 1, 0);\\n        \\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (pac[i][j] && atl[i][j]) r.add(new ArrayList(Arrays.asList(i, j)));\\n        \\n        return r;\\n    }\\n    \\n    int[][] dir = {{-1,0},{1,0},{0,-1},{0,1}};\\n    void dfs(int[][] M, boolean[][] visited, int i, int j, int prev)\\n    {\\n        if (i < 0 || i >= M.length || j < 0 || j >= M[0].length || visited[i][j] || M[i][j] < prev) return;\\n        visited[i][j] = true;\\n        for (int[] d : dir) dfs(M, visited, i + d[0], j + d[1], M[i][j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333075,
                "title": "c-dfs-isvisitedpacific-isvisitedatlantic",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> PacificAtlantic(int[][] matrix) {\\n        var row = matrix.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (row == 0) return result;\\n\\n        var col = matrix[0].Length;\\n\\n        var pacific = new bool[row, col];\\n        var atlantic = new bool[row, col];\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (i == 0 || j == 0) {\\n                    DFS(matrix, int.MinValue, i, j, pacific);\\n                }\\n\\n                if (i == row - 1 || j == col - 1) {\\n                    DFS(matrix, int.MinValue, i, j, atlantic);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (pacific[i, j] && atlantic[i, j]) {\\n                    result.Add(new List<int>() { i, j });\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[][] matrix, int pre, int x, int y, bool[,] isVisited) {\\n        var row = matrix.Length;\\n        var col = matrix[0].Length;\\n\\n        if (x >= row || x < 0 || y >= col || y < 0) return;\\n        if (isVisited[x, y]) return;\\n\\n        if (pre > matrix[x][y]) return;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(matrix, matrix[x][y], nextX, nextY, isVisited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> PacificAtlantic(int[][] matrix) {\\n        var row = matrix.Length;\\n\\n        var result = new List<IList<int>>();\\n        if (row == 0) return result;\\n\\n        var col = matrix[0].Length;\\n\\n        var pacific = new bool[row, col];\\n        var atlantic = new bool[row, col];\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (i == 0 || j == 0) {\\n                    DFS(matrix, int.MinValue, i, j, pacific);\\n                }\\n\\n                if (i == row - 1 || j == col - 1) {\\n                    DFS(matrix, int.MinValue, i, j, atlantic);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (pacific[i, j] && atlantic[i, j]) {\\n                    result.Add(new List<int>() { i, j });\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void DFS(int[][] matrix, int pre, int x, int y, bool[,] isVisited) {\\n        var row = matrix.Length;\\n        var col = matrix[0].Length;\\n\\n        if (x >= row || x < 0 || y >= col || y < 0) return;\\n        if (isVisited[x, y]) return;\\n\\n        if (pre > matrix[x][y]) return;\\n\\n        isVisited[x, y] = true;\\n\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(matrix, matrix[x][y], nextX, nextY, isVisited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90760,
                "title": "swift-solution-dfs-bfs",
                "content": "```\\nclass Solution {\\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    \\n    func pacificAtlantic_BFS(_ matrix: [[Int]]) -> [[Int]] {\\n        if matrix.count == 0 || matrix[0].count == 0 {\\n            return [[Int]]()\\n        }\\n        \\n        let n = matrix.count\\n        let m = matrix[0].count\\n        var result = [[Int]]()\\n        var pacific = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        var atlantic = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        var pQueue = [[Int]]()\\n        var aQueue = [[Int]]()\\n        \\n        for i in 0..<n {\\n            pQueue.append([i, 0])\\n            aQueue.append([i, m - 1])\\n            pacific[i][0] = true\\n            atlantic[i][m - 1] = true\\n        }\\n        for i in 0..<m {\\n            pQueue.append([0, i])\\n            aQueue.append([n - 1, i])\\n            pacific[0][i] = true\\n            atlantic[n - 1][i] = true\\n        }\\n        BFS(matrix, pQueue, &pacific)\\n        BFS(matrix, aQueue, &atlantic)\\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if pacific[i][j] && atlantic[i][j] {\\n                    result.append([i, j])\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func BFS(_ matrix: [[Int]], _ queue: [[Int]], _ visited: inout [[Bool]]) {\\n        let n = matrix.count\\n        let m = matrix[0].count\\n        var queue = queue\\n        \\n        while !queue.isEmpty {\\n            let current = queue.removeFirst()\\n            for direction in self.directions {\\n                let x = current[0] + direction[0]\\n                let y = current[1] + direction[1]\\n                if x < 0 || x >= n || y < 0 || y >= m || visited[x][y] || matrix[x][y] < matrix[current[0]][current[1]] {\\n                    continue\\n                }\\n                visited[x][y] = true\\n                queue.append([x, y])\\n            }\\n        }\\n    }\\n    \\n    func pacificAtlantic_DFS(_ matrix: [[Int]]) -> [[Int]] {\\n        if matrix.count == 0 || matrix[0].count == 0 {\\n            return [[Int]]()\\n        }\\n        \\n        let n = matrix.count\\n        let m = matrix[0].count\\n        var result = [[Int]]()\\n        var pacific = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        var atlantic = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        \\n        for i in 0..<n {\\n            DFS(matrix, Int.min, i, 0, &pacific)\\n            DFS(matrix, Int.min, i, m - 1, &atlantic)\\n        }\\n        for i in 0..<m {\\n            DFS(matrix, Int.min, 0, i, &pacific)\\n            DFS(matrix, Int.min, n - 1, i, &atlantic)\\n        }\\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if pacific[i][j] && atlantic[i][j] {\\n                    result.append([i, j])\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func DFS(_ matrix: [[Int]], _ height: Int, _ x: Int, _ y: Int, _ visited: inout [[Bool]]) {\\n        let n = matrix.count\\n        let m = matrix[0].count\\n        if x < 0 || x >= n || y < 0 || y >= m || visited[x][y] || matrix[x][y] < height {\\n            return\\n        }\\n        visited[x][y] = true\\n        for direction in self.directions {\\n            DFS(matrix, matrix[x][y], x + direction[0], y + direction[1], &visited)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    \\n    func pacificAtlantic_BFS(_ matrix: [[Int]]) -> [[Int]] {\\n        if matrix.count == 0 || matrix[0].count == 0 {\\n            return [[Int]]()\\n        }\\n        \\n        let n = matrix.count\\n        let m = matrix[0].count\\n        var result = [[Int]]()\\n        var pacific = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        var atlantic = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        var pQueue = [[Int]]()\\n        var aQueue = [[Int]]()\\n        \\n        for i in 0..<n {\\n            pQueue.append([i, 0])\\n            aQueue.append([i, m - 1])\\n            pacific[i][0] = true\\n            atlantic[i][m - 1] = true\\n        }\\n        for i in 0..<m {\\n            pQueue.append([0, i])\\n            aQueue.append([n - 1, i])\\n            pacific[0][i] = true\\n            atlantic[n - 1][i] = true\\n        }\\n        BFS(matrix, pQueue, &pacific)\\n        BFS(matrix, aQueue, &atlantic)\\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if pacific[i][j] && atlantic[i][j] {\\n                    result.append([i, j])\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func BFS(_ matrix: [[Int]], _ queue: [[Int]], _ visited: inout [[Bool]]) {\\n        let n = matrix.count\\n        let m = matrix[0].count\\n        var queue = queue\\n        \\n        while !queue.isEmpty {\\n            let current = queue.removeFirst()\\n            for direction in self.directions {\\n                let x = current[0] + direction[0]\\n                let y = current[1] + direction[1]\\n                if x < 0 || x >= n || y < 0 || y >= m || visited[x][y] || matrix[x][y] < matrix[current[0]][current[1]] {\\n                    continue\\n                }\\n                visited[x][y] = true\\n                queue.append([x, y])\\n            }\\n        }\\n    }\\n    \\n    func pacificAtlantic_DFS(_ matrix: [[Int]]) -> [[Int]] {\\n        if matrix.count == 0 || matrix[0].count == 0 {\\n            return [[Int]]()\\n        }\\n        \\n        let n = matrix.count\\n        let m = matrix[0].count\\n        var result = [[Int]]()\\n        var pacific = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        var atlantic = [[Bool]](repeatElement([Bool](repeatElement(false, count: m)), count: n))\\n        \\n        for i in 0..<n {\\n            DFS(matrix, Int.min, i, 0, &pacific)\\n            DFS(matrix, Int.min, i, m - 1, &atlantic)\\n        }\\n        for i in 0..<m {\\n            DFS(matrix, Int.min, 0, i, &pacific)\\n            DFS(matrix, Int.min, n - 1, i, &atlantic)\\n        }\\n        for i in 0..<n {\\n            for j in 0..<m {\\n                if pacific[i][j] && atlantic[i][j] {\\n                    result.append([i, j])\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n    \\n    private func DFS(_ matrix: [[Int]], _ height: Int, _ x: Int, _ y: Int, _ visited: inout [[Bool]]) {\\n        let n = matrix.count\\n        let m = matrix[0].count\\n        if x < 0 || x >= n || y < 0 || y >= m || visited[x][y] || matrix[x][y] < height {\\n            return\\n        }\\n        visited[x][y] = true\\n        for direction in self.directions {\\n            DFS(matrix, matrix[x][y], x + direction[0], y + direction[1], &visited)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 90807,
                "title": "short-and-concise-python-solution",
                "content": "Basically start with the edges and add all the coordinates that can reach edges into two sets (pacific and atlantic).  The answer is just the intersection of the two sets.  There's no data about the run times for this problem yet, but this code completes in about 225 ms.  Is that any good?\\n```\\nclass Solution(object):\\n\\tdef pacificAtlantic(self, matrix):\\n\\t\\tdef fill(ocean, stack):\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tr,c = stack.pop()\\n\\t\\t\\t\\tif (r,c) in ocean: continue\\n\\t\\t\\t\\tocean.add((r,c))\\n\\t\\t\\t\\tstack.extend([\\n\\t\\t\\t\\t\\t[nr, nc] for nr, nc in [[r-1,c], [r+1,c], [r,c-1], [r,c+1]]\\n\\t\\t\\t\\t\\tif 0 <= nr < m and 0 <= nc < n and matrix[r][c] <= matrix[nr][nc]])\\n\\t\\t\\t\\t\\t\\n\\t\\tif not matrix or not matrix[0]:\\treturn []\\n\\t\\tm, n = len(matrix), len(matrix[0])\\n\\t\\tpacific, atlantic = set(), set()\\n\\t\\tpstack = [[r,0] for r in xrange(m)] + [[0,c] for c in xrange(1,n)]\\n\\t\\tastack = [[r,n-1] for r in xrange(m)] + [[m-1,c] for c in xrange(n-1)]\\n\\n\\t\\tfill(pacific, pstack)\\n\\t\\tfill(atlantic, astack)\\n\\t\\t\\n\\t\\treturn [list(x) for x in pacific&atlantic]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef pacificAtlantic(self, matrix):\\n\\t\\tdef fill(ocean, stack):\\n\\t\\t\\twhile stack:\\n\\t\\t\\t\\tr,c = stack.pop()\\n\\t\\t\\t\\tif (r,c) in ocean: continue\\n\\t\\t\\t\\tocean.add((r,c))\\n\\t\\t\\t\\tstack.extend([\\n\\t\\t\\t\\t\\t[nr, nc] for nr, nc in [[r-1,c], [r+1,c], [r,c-1], [r,c+1]]\\n\\t\\t\\t\\t\\tif 0 <= nr < m and 0 <= nc < n and matrix[r][c] <= matrix[nr][nc]])\\n\\t\\t\\t\\t\\t\\n\\t\\tif not matrix or not matrix[0]:\\treturn []\\n\\t\\tm, n = len(matrix), len(matrix[0])\\n\\t\\tpacific, atlantic = set(), set()\\n\\t\\tpstack = [[r,0] for r in xrange(m)] + [[0,c] for c in xrange(1,n)]\\n\\t\\tastack = [[r,n-1] for r in xrange(m)] + [[m-1,c] for c in xrange(n-1)]\\n\\n\\t\\tfill(pacific, pstack)\\n\\t\\tfill(atlantic, astack)\\n\\t\\t\\n\\t\\treturn [list(x) for x in pacific&atlantic]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852386,
                "title": "c-dfs-clean-solution",
                "content": "# Intuition\\n* Find out which cells can flow into pacific & atlantic seperately\\n* Then pick the cells which can flow into both\\n* All the top & left cells can flow into pacific, so mark them 1\\n* All the bottom & right cells can flow into atlantic, so mark them 1\\n* Now DFS from these cells, whichever cells 4-directionally satisfy the condition, mark them with 1 (indicating can flow)\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m = heights.size(), n = heights[0].size();\\n\\n        vector<vector<int>> pacific(m, vector<int>(n, -1)), atlantic(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 || j == 0)\\n                    pacific[i][j] = 1;\\n                if (i == m-1 || j == n-1)\\n                    atlantic[i][j] = 1;\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] == 1)\\n                    dfs(heights, i, j, m, n, pacific);\\n                if (atlantic[i][j] == 1)\\n                    dfs(heights, i, j, m, n, atlantic);\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] == 1 && atlantic[i][j] == 1)\\n                    result.push_back({i, j});\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>>& heights, int r, int c, int& m, int& n, vector<vector<int>>& ocean) {\\n        int DIR[][2] = { {0,-1}, {1, 0}, {0, 1}, {-1, 0} }; // left, up, right, down\\n\\n        for (int i = 0; i < 4; i++) {\\n            int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n            // invalid index or visited\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || ocean[nr][nc] == 1) \\n                continue;\\n\\n            if (heights[nr][nc] >= heights[r][c]) {\\n                ocean[nr][nc] = 1; // visited & can flow\\n                dfs(heights, nr, nc, m, n, ocean); \\n            } \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        int m = heights.size(), n = heights[0].size();\\n\\n        vector<vector<int>> pacific(m, vector<int>(n, -1)), atlantic(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 || j == 0)\\n                    pacific[i][j] = 1;\\n                if (i == m-1 || j == n-1)\\n                    atlantic[i][j] = 1;\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] == 1)\\n                    dfs(heights, i, j, m, n, pacific);\\n                if (atlantic[i][j] == 1)\\n                    dfs(heights, i, j, m, n, atlantic);\\n            }\\n        }\\n\\n        vector<vector<int>> result;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (pacific[i][j] == 1 && atlantic[i][j] == 1)\\n                    result.push_back({i, j});\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    void dfs(vector<vector<int>>& heights, int r, int c, int& m, int& n, vector<vector<int>>& ocean) {\\n        int DIR[][2] = { {0,-1}, {1, 0}, {0, 1}, {-1, 0} }; // left, up, right, down\\n\\n        for (int i = 0; i < 4; i++) {\\n            int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n            // invalid index or visited\\n            if (nr < 0 || nc < 0 || nr >= m || nc >= n || ocean[nr][nc] == 1) \\n                continue;\\n\\n            if (heights[nr][nc] >= heights[r][c]) {\\n                ocean[nr][nc] = 1; // visited & can flow\\n                dfs(heights, nr, nc, m, n, ocean); \\n            } \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575521,
                "title": "bfs-easy-understanding-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. flow in reverse, set up a bool, check if the side comes from the diff place => update the hitting place\\n2. check point has both flowable => is the answer.\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\nO(mn)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> res;\\n    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\npublic:\\n    bool valid(int i, int j) {\\n        return (0 <= i) && (i < m) && (0 <= j) && (j < n);\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& g) {\\n\\n        queue <vector<int>> q;\\n        m = g.size(), n = g[0].size(); \\n        vector<vector<vector<int>>> flow(m, vector<vector<int>>(n, vector<int>(2)));\\n        vector<vector<int>> res;\\n\\n        // push from the ocean side\\n        for (int i = 0; i < m; i++) {\\n            // pacific (0)\\n            q.push({i, 0, 0});\\n            // Atlantic (1)\\n            q.push({i, n-1, 1});\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            // pacific (0)\\n            q.push({0, j, 0});\\n            // Atlantic (1)\\n            q.push({m-1, j, 1});\\n        }\\n\\n        // bfs to spread\\n        while (q.size()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                vector<int> current = q.front();\\n                q.pop();\\n                int x = current[0];\\n                int y = current[1];\\n                int from = current[2];\\n                flow[x][y][from]++;\\n                for (auto dir: dirs) {\\n                    int i = x + dir[0];\\n                    int j = y + dir[1];\\n                    if (valid(i, j) && (g[x][y] <= g[i][j]) && !flow[i][j][from]) {\\n                        q.push({i, j, from});\\n                    }\\n                }\\n            }\\n        }\\n\\n        // check if we get the part can flow to two side.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (flow[i][j][0] && flow[i][j][1]) {\\n                    res.push_back({i, j});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> res;\\n    vector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\npublic:\\n    bool valid(int i, int j) {\\n        return (0 <= i) && (i < m) && (0 <= j) && (j < n);\\n    }\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& g) {\\n\\n        queue <vector<int>> q;\\n        m = g.size(), n = g[0].size(); \\n        vector<vector<vector<int>>> flow(m, vector<vector<int>>(n, vector<int>(2)));\\n        vector<vector<int>> res;\\n\\n        // push from the ocean side\\n        for (int i = 0; i < m; i++) {\\n            // pacific (0)\\n            q.push({i, 0, 0});\\n            // Atlantic (1)\\n            q.push({i, n-1, 1});\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            // pacific (0)\\n            q.push({0, j, 0});\\n            // Atlantic (1)\\n            q.push({m-1, j, 1});\\n        }\\n\\n        // bfs to spread\\n        while (q.size()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                vector<int> current = q.front();\\n                q.pop();\\n                int x = current[0];\\n                int y = current[1];\\n                int from = current[2];\\n                flow[x][y][from]++;\\n                for (auto dir: dirs) {\\n                    int i = x + dir[0];\\n                    int j = y + dir[1];\\n                    if (valid(i, j) && (g[x][y] <= g[i][j]) && !flow[i][j][from]) {\\n                        q.push({i, j, from});\\n                    }\\n                }\\n            }\\n        }\\n\\n        // check if we get the part can flow to two side.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (flow[i][j][0] && flow[i][j][1]) {\\n                    res.push_back({i, j});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482507,
                "title": "best-explanation-ever-dfs",
                "content": "# Intuition\\nNaive approach is that we start dfs from each cell\\n\\n# Approach\\nInstead we will start dfs from each border \\nwe will keep two visited array of same dimension as of given matrix\\n**from the atlantic side we will reach to all cell and mark them in atlantic visited**\\n**from the pacific side we will reach to all cell and mark them in pacific visited**\\nCells which are marked in both visited array are our answers\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int row, int col,vector<vector<int>>& v, vector<vector<int>>& h )\\n{\\n    if(row<0 || col<0 || row>=h.size() || col>=h[0].size() || v[row][col])\\n    return ;\\n    v[row][col] = 1 ; \\n    if(row+1<h.size() && h[row+1][col]>=h[row][col])\\n    dfs(row+1,col,v,h);\\n    if(row-1>=0 && h[row-1][col]>=h[row][col])\\n    dfs(row-1,col,v,h);\\n    if(col+1<h[0].size() && h[row][col+1]>=h[row][col])\\n    dfs(row,col+1,v,h);\\n    if(col-1>=0 && h[row][col-1]>=h[row][col])\\n    dfs(row,col-1,v,h);\\n}\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& h) \\n    {   \\n        int n = h.size(), m = h[0].size(); \\n        vector<vector<int>> pac (n,vector<int>(m,0));\\n        vector<vector<int>> atl (n,vector<int>(m,0));\\n        vector<vector<int>> res;\\n\\n        for(int i = 0 ; i< m ; i++) // Upper & lower boundary\\n        {\\n            dfs(0,i,pac,h); // from upper pacific side\\n            dfs(n-1,i,atl,h);// from bottom atlantic side\\n        }\\n\\n        for(int i = 0 ; i< n ; i++) // left & right boundary \\n        {\\n            dfs(i,0,pac,h); // left pacific\\n            dfs(i,m-1,atl,h);// right atlantic\\n        }\\n\\n        for(int i = 0; i<n;i++)\\n        for(int j = 0 ; j<m;j++)\\n        if(pac[i][j] && atl[i][j])\\n        res.push_back({i,j});\\n         return res; \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid dfs(int row, int col,vector<vector<int>>& v, vector<vector<int>>& h )\\n{\\n    if(row<0 || col<0 || row>=h.size() || col>=h[0].size() || v[row][col])\\n    return ;\\n    v[row][col] = 1 ; \\n    if(row+1<h.size() && h[row+1][col]>=h[row][col])\\n    dfs(row+1,col,v,h);\\n    if(row-1>=0 && h[row-1][col]>=h[row][col])\\n    dfs(row-1,col,v,h);\\n    if(col+1<h[0].size() && h[row][col+1]>=h[row][col])\\n    dfs(row,col+1,v,h);\\n    if(col-1>=0 && h[row][col-1]>=h[row][col])\\n    dfs(row,col-1,v,h);\\n}\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& h) \\n    {   \\n        int n = h.size(), m = h[0].size(); \\n        vector<vector<int>> pac (n,vector<int>(m,0));\\n        vector<vector<int>> atl (n,vector<int>(m,0));\\n        vector<vector<int>> res;\\n\\n        for(int i = 0 ; i< m ; i++) // Upper & lower boundary\\n        {\\n            dfs(0,i,pac,h); // from upper pacific side\\n            dfs(n-1,i,atl,h);// from bottom atlantic side\\n        }\\n\\n        for(int i = 0 ; i< n ; i++) // left & right boundary \\n        {\\n            dfs(i,0,pac,h); // left pacific\\n            dfs(i,m-1,atl,h);// right atlantic\\n        }\\n\\n        for(int i = 0; i<n;i++)\\n        for(int j = 0 ; j<m;j++)\\n        if(pac[i][j] && atl[i][j])\\n        res.push_back({i,j});\\n         return res; \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429569,
                "title": "dfs-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n\\n        int n=heights.length;\\n        int m=heights[0].length;\\n\\n        int pacific[][]=new int[n][m];\\n        int atlantic[][]=new int[n][m];\\n\\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n\\n        for(int i=0;i<n;i++){\\n            dfs(i,0,heights,pacific,Integer.MIN_VALUE,delRow,delCol);//first col\\n            dfs(i,m-1,heights,atlantic,Integer.MIN_VALUE,delRow,delCol);//last col\\n        }\\n\\n        for(int j=0;j<m;j++){\\n            dfs(0,j,heights,pacific,Integer.MIN_VALUE,delRow,delCol);//first row\\n            dfs(n-1,j,heights,atlantic,Integer.MIN_VALUE,delRow,delCol);//last row\\n        }\\n\\n        List<List<Integer>>ans=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pacific[i][j]==1 && atlantic[i][j]==1){\\n                    List<Integer>res=new ArrayList<>();\\n                    res.add(i);\\n                    res.add(j);\\n                    ans.add(res);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    public void dfs(int i,int j,int [][]heights,int[][]visit,int height,int []delRow,int delCol[]){\\n        int n=heights.length;\\n        int m=heights[0].length;\\n         if(i<0 || i>=n || j<0 || j>=m || visit[i][j]==1 || heights[i][j] < height)\\n                return;\\n\\n        visit[i][j]=1;\\n        \\n        for(int k=0;k<4;k++){\\n            int nrow=i+delRow[k];\\n            int ncol=j+delCol[k];\\n\\n            dfs(nrow,ncol,heights,visit,heights[i][j],delRow,delCol);\\n\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n\\n        int n=heights.length;\\n        int m=heights[0].length;\\n\\n        int pacific[][]=new int[n][m];\\n        int atlantic[][]=new int[n][m];\\n\\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n\\n        for(int i=0;i<n;i++){\\n            dfs(i,0,heights,pacific,Integer.MIN_VALUE,delRow,delCol);//first col\\n            dfs(i,m-1,heights,atlantic,Integer.MIN_VALUE,delRow,delCol);//last col\\n        }\\n\\n        for(int j=0;j<m;j++){\\n            dfs(0,j,heights,pacific,Integer.MIN_VALUE,delRow,delCol);//first row\\n            dfs(n-1,j,heights,atlantic,Integer.MIN_VALUE,delRow,delCol);//last row\\n        }\\n\\n        List<List<Integer>>ans=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pacific[i][j]==1 && atlantic[i][j]==1){\\n                    List<Integer>res=new ArrayList<>();\\n                    res.add(i);\\n                    res.add(j);\\n                    ans.add(res);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n    public void dfs(int i,int j,int [][]heights,int[][]visit,int height,int []delRow,int delCol[]){\\n        int n=heights.length;\\n        int m=heights[0].length;\\n         if(i<0 || i>=n || j<0 || j>=m || visit[i][j]==1 || heights[i][j] < height)\\n                return;\\n\\n        visit[i][j]=1;\\n        \\n        for(int k=0;k<4;k++){\\n            int nrow=i+delRow[k];\\n            int ncol=j+delCol[k];\\n\\n            dfs(nrow,ncol,heights,visit,heights[i][j],delRow,delCol);\\n\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189866,
                "title": "c-solution-using-two-visited-arrays",
                "content": "# Code\\n```\\nint x[] = {1,-1,0,0};\\nint y[] = {0,0,-1,1};\\n\\nclass Solution {\\npublic:\\n\\nbool isValid(int i ,int j,int n,int m){\\n  if(i<n && i>=0 && j>=0 && j<m) return true;\\n  return false;\\n}\\n\\nvoid func(int i,int j,vector<vector<int> >& vis,vector<vector<int>> &mat,int n,int m){\\n  vis[i][j]=1;\\n\\n  for (int k = 0; k <4; k++){\\n    int x1= i+x[k];\\n    int y1= j+y[k];\\n    if(isValid(x1,y1,n,m) && !vis[x1][y1] ){\\n      if(mat[x1][y1] >= mat[i][j]) func(x1,y1,vis,mat,n,m);\\n    }\\n  }\\n}\\n\\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n    int n = mat.size();\\n    int m = mat[0].size();\\n\\n  vector<vector<int> > vis1(n,vector<int>(m,0));\\n  vector<vector<int> > vis2(n,vector<int>(m,0));\\n\\nfor (int i = 0; i <n; i++){\\n  if(vis1[i][0]==0) func(i,0,vis1,mat,n,m);\\n  if(vis2[i][m-1]==0) func(i,m-1,vis2,mat,n,m);\\n}\\nfor (int i = 0; i <m; i++){\\n  if(vis1[0][i]==0) func(0,i,vis1,mat,n,m);\\n  if(vis2[n-1][i]==0) func(n-1,i,vis2,mat,n,m);\\n}\\n\\n//**********************************************\\n\\nvector<vector<int>> ans;\\nfor (int i = 0; i <n; i++){\\n  for(int j=0;j<m;j++){\\n    // if we can reach both the ocean \\n    if(vis1[i][j] && vis2[i][j]) ans.push_back({i,j});\\n  }\\n}\\n  \\n    return ans;\\n}    \\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint x[] = {1,-1,0,0};\\nint y[] = {0,0,-1,1};\\n\\nclass Solution {\\npublic:\\n\\nbool isValid(int i ,int j,int n,int m){\\n  if(i<n && i>=0 && j>=0 && j<m) return true;\\n  return false;\\n}\\n\\nvoid func(int i,int j,vector<vector<int> >& vis,vector<vector<int>> &mat,int n,int m){\\n  vis[i][j]=1;\\n\\n  for (int k = 0; k <4; k++){\\n    int x1= i+x[k];\\n    int y1= j+y[k];\\n    if(isValid(x1,y1,n,m) && !vis[x1][y1] ){\\n      if(mat[x1][y1] >= mat[i][j]) func(x1,y1,vis,mat,n,m);\\n    }\\n  }\\n}\\n\\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n    int n = mat.size();\\n    int m = mat[0].size();\\n\\n  vector<vector<int> > vis1(n,vector<int>(m,0));\\n  vector<vector<int> > vis2(n,vector<int>(m,0));\\n\\nfor (int i = 0; i <n; i++){\\n  if(vis1[i][0]==0) func(i,0,vis1,mat,n,m);\\n  if(vis2[i][m-1]==0) func(i,m-1,vis2,mat,n,m);\\n}\\nfor (int i = 0; i <m; i++){\\n  if(vis1[0][i]==0) func(0,i,vis1,mat,n,m);\\n  if(vis2[n-1][i]==0) func(n-1,i,vis2,mat,n,m);\\n}\\n\\n//**********************************************\\n\\nvector<vector<int>> ans;\\nfor (int i = 0; i <n; i++){\\n  for(int j=0;j<m;j++){\\n    // if we can reach both the ocean \\n    if(vis1[i][j] && vis2[i][j]) ans.push_back({i,j});\\n  }\\n}\\n  \\n    return ans;\\n}    \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188146,
                "title": "intuitive-typescript-solution",
                "content": "```\\nfunction pacificAtlantic(heights: number[][]): number[][] {\\n  const rows = heights.length;\\n  const cols = heights[0].length;\\n  const pacific = new Set<string>();\\n  const atlantic = new Set<string>();\\n  const output: number[][] = [];\\n\\n  for (let c = 0; c < cols; c++) {\\n    dfs(heights, 0, c, heights[0][c], pacific);\\n    dfs(heights, rows - 1, c, heights[rows - 1][c], atlantic);\\n  }\\n\\n  for (let r = 0; r < rows; r++) {\\n    dfs(heights, r, 0, heights[r][0], pacific);\\n    dfs(heights, r, cols - 1, heights[r][cols - 1], atlantic);\\n  }\\n\\n  for (let r = 0; r < rows; r++) {\\n    for (let c = 0; c < cols; c++) {\\n      const key = encode(r, c);\\n      if (pacific.has(key) && atlantic.has(key)) {\\n        output.push([r, c]);\\n      }\\n    }\\n  }\\n\\n  return output;\\n};\\n\\nfunction dfs(grid: number[][], r: number, c: number, max: number, visited: Set<string>): void {\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n\\n  if (\\n    visited.has(encode(r, c)) ||\\n    (r < 0 || r >= rows) ||\\n    (c < 0 || c >= cols) ||\\n    grid[r][c] < max\\n  ) {\\n    return;\\n  }\\n  visited.add(encode(r, c));\\n\\n  dfs(grid, r + 1, c, grid[r][c], visited);\\n  dfs(grid, r - 1, c, grid[r][c], visited);\\n  dfs(grid, r, c + 1, grid[r][c], visited);\\n  dfs(grid, r, c - 1, grid[r][c], visited);\\n} \\n\\nfunction encode(x: number, y: number) {\\n  return `${x},${y}`;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction pacificAtlantic(heights: number[][]): number[][] {\\n  const rows = heights.length;\\n  const cols = heights[0].length;\\n  const pacific = new Set<string>();\\n  const atlantic = new Set<string>();\\n  const output: number[][] = [];\\n\\n  for (let c = 0; c < cols; c++) {\\n    dfs(heights, 0, c, heights[0][c], pacific);\\n    dfs(heights, rows - 1, c, heights[rows - 1][c], atlantic);\\n  }\\n\\n  for (let r = 0; r < rows; r++) {\\n    dfs(heights, r, 0, heights[r][0], pacific);\\n    dfs(heights, r, cols - 1, heights[r][cols - 1], atlantic);\\n  }\\n\\n  for (let r = 0; r < rows; r++) {\\n    for (let c = 0; c < cols; c++) {\\n      const key = encode(r, c);\\n      if (pacific.has(key) && atlantic.has(key)) {\\n        output.push([r, c]);\\n      }\\n    }\\n  }\\n\\n  return output;\\n};\\n\\nfunction dfs(grid: number[][], r: number, c: number, max: number, visited: Set<string>): void {\\n  const rows = grid.length;\\n  const cols = grid[0].length;\\n\\n  if (\\n    visited.has(encode(r, c)) ||\\n    (r < 0 || r >= rows) ||\\n    (c < 0 || c >= cols) ||\\n    grid[r][c] < max\\n  ) {\\n    return;\\n  }\\n  visited.add(encode(r, c));\\n\\n  dfs(grid, r + 1, c, grid[r][c], visited);\\n  dfs(grid, r - 1, c, grid[r][c], visited);\\n  dfs(grid, r, c + 1, grid[r][c], visited);\\n  dfs(grid, r, c - 1, grid[r][c], visited);\\n} \\n\\nfunction encode(x: number, y: number) {\\n  return `${x},${y}`;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2873550,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        boolean a[][]=new boolean[heights.length][heights[0].length];\\n        boolean b[][]=new boolean[heights.length][heights[0].length];\\n        for(int i=0;i<a.length;i++)\\n        {\\n            task(heights,a,i,0,Integer.MIN_VALUE);\\n            task(heights,b,i,a[0].length-1,Integer.MIN_VALUE);\\n        }\\n        for(int i=0;i<a[0].length;i++)\\n        {\\n            task(heights,a,0,i,Integer.MIN_VALUE);\\n            task(heights,b,a.length-1,i,Integer.MIN_VALUE);\\n        }\\n        List<List<Integer>> nm=new ArrayList<>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<a[0].length;j++)\\n            {\\n                if(a[i][j] && b[i][j])\\n                {\\n                    nm.add(Arrays.asList(i,j));\\n                }\\n            }\\n        }\\n        return nm;\\n    }\\n    public void task(int heights[][], boolean f[][], int i, int j, int val)\\n    {\\n        if(i<0 || j<0 || i>=f.length || j>=f[0].length || f[i][j]==true || heights[i][j]<val)\\n        {\\n            return;\\n        }\\n        f[i][j]=true;\\n        task(heights,f,i+1,j,heights[i][j]);\\n        task(heights,f,i-1,j,heights[i][j]);\\n        task(heights,f,i,j+1,heights[i][j]);\\n        task(heights,f,i,j-1,heights[i][j]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        boolean a[][]=new boolean[heights.length][heights[0].length];\\n        boolean b[][]=new boolean[heights.length][heights[0].length];\\n        for(int i=0;i<a.length;i++)\\n        {\\n            task(heights,a,i,0,Integer.MIN_VALUE);\\n            task(heights,b,i,a[0].length-1,Integer.MIN_VALUE);\\n        }\\n        for(int i=0;i<a[0].length;i++)\\n        {\\n            task(heights,a,0,i,Integer.MIN_VALUE);\\n            task(heights,b,a.length-1,i,Integer.MIN_VALUE);\\n        }\\n        List<List<Integer>> nm=new ArrayList<>();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<a[0].length;j++)\\n            {\\n                if(a[i][j] && b[i][j])\\n                {\\n                    nm.add(Arrays.asList(i,j));\\n                }\\n            }\\n        }\\n        return nm;\\n    }\\n    public void task(int heights[][], boolean f[][], int i, int j, int val)\\n    {\\n        if(i<0 || j<0 || i>=f.length || j>=f[0].length || f[i][j]==true || heights[i][j]<val)\\n        {\\n            return;\\n        }\\n        f[i][j]=true;\\n        task(heights,f,i+1,j,heights[i][j]);\\n        task(heights,f,i-1,j,heights[i][j]);\\n        task(heights,f,i,j+1,heights[i][j]);\\n        task(heights,f,i,j-1,heights[i][j]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653261,
                "title": "modified-and-simple-dfs-solution-with-comments-explaination-fast-and-easy-solution",
                "content": "```\\n/*\\n    In a naive approach, we would have to consider each cell \\n    and find if it is reachable to both the oceans by checking if it is able to reach : \\n    1. top or left edge(atlantic) and, \\n    2. bottom or right edge (pacific). \\n    This would take about O((mn)^2), which is not efficient.\\n*/\\n/*\\n    BEST SOLUTION: modified DFS\\n    We can observe that there are these cells which can reach -\\n        None\\n        Pacific\\n        Atlantic\\n        Both Pacific and Atlantic\\n\\n    1.   if we start from the cells connected to altantic ocean and \\n         visit all cells having height greater than current cell \\n         (water can only flow from a cell to another one with height equal or lower), \\n         we are able to reach some subset of cells (let\\'s call them A).\\n    2.   Next, we start from the cells connected to pacific ocean and repeat the same process,\\n         we find another subset (let\\'s call this one B).\\n    3.   The final answer we get will be the intersection of sets A and B (A \\u2229 B).\\n    \\n    So, we just need to iterate from edge cells, \\n    find cells reachable from atlantic (set A), cells reachable from pacific (set B) and return their intersection.\\n*/\\n\\nclass Solution {\\npublic:\\n    int n,m;\\n    // denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool>> atlantic, pacific; // vis matrix for both oceans\\n    vector<vector<int>> res;\\n    \\n    void dfs(vector<vector<int>> &heights, vector<vector<bool>> &vis, int i, int j){\\n        if(vis[i][j]) return;\\n        vis[i][j] = true; // visit\\n        \\n        // if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) res.push_back(vector<int>{i,j});\\n        \\n        // dfs from current cell only if height of next cell is greater\\n        if(i + 1 <  n && heights[i + 1][j] >= heights[i][j])    dfs(heights, vis, i + 1, j); // \\u2B07\\uFE0F\\n        if(i - 1 >= 0 && heights[i - 1][j] >= heights[i][j])    dfs(heights, vis, i - 1, j); // \\u2B06\\uFE0F\\n        if(j + 1 <  m && heights[i][j + 1] >= heights[i][j])    dfs(heights, vis, i, j + 1); // \\u27A1\\uFE0F\\n        if(j - 1 >= 0 && heights[i][j - 1] >= heights[i][j])    dfs(heights, vis, i, j - 1); // \\u2B05\\uFE0F\\n    }\\n    \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n        n = heights.size(), m = heights[0].size();\\n        if(n==0) return res;\\n        \\n        atlantic = pacific = vector<vector<bool> >(n, vector<bool>(m, false));\\n        \\n        // perform dfs from all edge cells (ocean-connected cells)\\n        for(int i=0; i<n; i++)  dfs(heights, pacific, i, 0), dfs(heights, atlantic, i, m-1);\\n        for(int i=0; i<m; i++)  dfs(heights, pacific, 0, i), dfs(heights, atlantic, n-1, i);\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int n,m;\\n    // denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool>> atlantic, pacific; // vis matrix for both oceans\\n    vector<vector<int>> res;\\n    \\n    void dfs(vector<vector<int>> &heights, vector<vector<bool>> &vis, int i, int j){\\n        if(vis[i][j]) return;\\n        vis[i][j] = true; // visit\\n        \\n        // if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) res.push_back(vector<int>{i,j}",
                "codeTag": "Java"
            },
            {
                "id": 2651566,
                "title": "python-iterative-bfs-sets-easy",
                "content": "\\n\\n# Approach\\n- We do a breath first search on the four boundaries of the grid rather than going through each element of the matrix and finding it\\'s neighbours.\\n\\n- We maintain two sets which can flow through pacific and atlantic repectively, we return the intersection of the two sets as a list. \\n\\n# Code\\n```\\nclass OceanType:\\n    def __init__(self):\\n        self.pacific = \\'Pacific Ocean\\'\\n        self.atlantic = \\'Atlantic Ocean\\'\\n\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        if not heights: return 0\\n\\n        rows, cols = len(heights), len(heights[0])\\n        po_visited, ao_visited = set(), set()\\n        ocean_directions = [[1,0], [-1,0], [0,1], [0,-1]]\\n        ocean_type = OceanType()\\n\\n        def handleOceanVisited(row, col, ocean):\\n            if ocean == ocean_type.pacific:\\n                po_visited.add((row,col))\\n            else:\\n                ao_visited.add((row,col))\\n        \\n        def getOceanVisitedSet(ocean):\\n            return po_visited if ocean == ocean_type.pacific else ao_visited\\n\\n        def bfs(row, col, ocean):\\n            queue = collections.deque()\\n            queue.append((row, col))\\n            handleOceanVisited(row, col, ocean)\\n\\n            while queue:\\n                row, col = queue.popleft()\\n                for dr, dc in ocean_directions:\\n                    r, c = row + dr, col + dc\\n                    if(r in range(rows) and \\n                    c in range(cols) and \\n                    heights[r][c] >= heights[row][col] and\\n                    (r, c) not in getOceanVisitedSet(ocean)\\n                    ):\\n                        queue.append((r, c))\\n                        handleOceanVisited(r, c, ocean)\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                # pacific ocean neighbours\\n                if row == 0 or col == 0:\\n                    bfs(row, col, ocean_type.pacific)\\n                # atlantic ocean neighbours\\n                if row == rows - 1 or col == cols - 1:\\n                    bfs(row, col, ocean_type.atlantic)\\n\\n        \\n        return list(po_visited.intersection(ao_visited))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass OceanType:\\n    def __init__(self):\\n        self.pacific = \\'Pacific Ocean\\'\\n        self.atlantic = \\'Atlantic Ocean\\'\\n\\nclass Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        if not heights: return 0\\n\\n        rows, cols = len(heights), len(heights[0])\\n        po_visited, ao_visited = set(), set()\\n        ocean_directions = [[1,0], [-1,0], [0,1], [0,-1]]\\n        ocean_type = OceanType()\\n\\n        def handleOceanVisited(row, col, ocean):\\n            if ocean == ocean_type.pacific:\\n                po_visited.add((row,col))\\n            else:\\n                ao_visited.add((row,col))\\n        \\n        def getOceanVisitedSet(ocean):\\n            return po_visited if ocean == ocean_type.pacific else ao_visited\\n\\n        def bfs(row, col, ocean):\\n            queue = collections.deque()\\n            queue.append((row, col))\\n            handleOceanVisited(row, col, ocean)\\n\\n            while queue:\\n                row, col = queue.popleft()\\n                for dr, dc in ocean_directions:\\n                    r, c = row + dr, col + dc\\n                    if(r in range(rows) and \\n                    c in range(cols) and \\n                    heights[r][c] >= heights[row][col] and\\n                    (r, c) not in getOceanVisitedSet(ocean)\\n                    ):\\n                        queue.append((r, c))\\n                        handleOceanVisited(r, c, ocean)\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                # pacific ocean neighbours\\n                if row == 0 or col == 0:\\n                    bfs(row, col, ocean_type.pacific)\\n                # atlantic ocean neighbours\\n                if row == rows - 1 or col == cols - 1:\\n                    bfs(row, col, ocean_type.atlantic)\\n\\n        \\n        return list(po_visited.intersection(ao_visited))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510167,
                "title": "dfs-approach",
                "content": "```\\nclass Solution {\\n  public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n    final int m = heights.length;\\n    final int n = heights[0].length;\\n    List<List<Integer>> ans = new ArrayList<>();\\n    boolean[][] visP = new boolean[m][n];\\n    boolean[][] visA = new boolean[m][n];\\n\\n    for (int i = 0; i < m; ++i) {\\n      dfs(heights, i, 0, 0, visP);\\n      dfs(heights, i, n - 1, 0, visA);\\n    }\\n\\n    for (int j = 0; j < n; ++j) {\\n      dfs(heights, 0, j, 0, visP);\\n      dfs(heights, m - 1, j, 0, visA);\\n    }\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (visP[i][j] && visA[i][j])\\n          ans.add(new ArrayList<>(Arrays.asList(i, j)));\\n\\n    return ans;\\n  }\\n\\n  private void dfs(final int[][] heights, int i, int j, int h, boolean[][] vis) {\\n    if (i < 0 || i == heights.length || j < 0 || j == heights[0].length)\\n      return;\\n    if (vis[i][j] || heights[i][j] < h)\\n      return;\\n\\n    vis[i][j] = true;\\n    dfs(heights, i + 1, j, heights[i][j], vis);\\n    dfs(heights, i - 1, j, heights[i][j], vis);\\n    dfs(heights, i, j + 1, heights[i][j], vis);\\n    dfs(heights, i, j - 1, heights[i][j], vis);\\n  }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n    final int m = heights.length;\\n    final int n = heights[0].length;\\n    List<List<Integer>> ans = new ArrayList<>();\\n    boolean[][] visP = new boolean[m][n];\\n    boolean[][] visA = new boolean[m][n];\\n\\n    for (int i = 0; i < m; ++i) {\\n      dfs(heights, i, 0, 0, visP);\\n      dfs(heights, i, n - 1, 0, visA);\\n    }\\n\\n    for (int j = 0; j < n; ++j) {\\n      dfs(heights, 0, j, 0, visP);\\n      dfs(heights, m - 1, j, 0, visA);\\n    }\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (visP[i][j] && visA[i][j])\\n          ans.add(new ArrayList<>(Arrays.asList(i, j)));\\n\\n    return ans;\\n  }\\n\\n  private void dfs(final int[][] heights, int i, int j, int h, boolean[][] vis) {\\n    if (i < 0 || i == heights.length || j < 0 || j == heights[0].length)\\n      return;\\n    if (vis[i][j] || heights[i][j] < h)\\n      return;\\n\\n    vis[i][j] = true;\\n    dfs(heights, i + 1, j, heights[i][j], vis);\\n    dfs(heights, i - 1, j, heights[i][j], vis);\\n    dfs(heights, i, j + 1, heights[i][j], vis);\\n    dfs(heights, i, j - 1, heights[i][j], vis);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508653,
                "title": "easy-bfs-solution-using-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n          \\n        int m=heights.size(),n=heights[0].size();\\n        \\n        vector<vector<int>>atlantic(m,vector<int>(n)),pacific(m,vector<int>(n)),vis(m,vector<int>(n));\\n        \\n        vector<vector<int>>result;\\n        \\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            pacific[i][0]=1;\\n            q.push({i,0});\\n        }\\n        \\n        for(int j=1;j<n;j++){\\n            pacific[0][j]=1;\\n            q.push({0,j});\\n        }\\n        \\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            int i=ele.first,j=ele.second;\\n                        \\n            if(i>0 && heights[i-1][j]>=heights[i][j] && !pacific[i-1][j]){\\n                pacific[i-1][j]=1;\\n                q.push({i-1,j});\\n            }\\n            \\n            if(j>0 && heights[i][j-1]>=heights[i][j] && !pacific[i][j-1]){\\n                pacific[i][j-1]=1;\\n                q.push({i,j-1});\\n            }\\n            \\n            if(i<m-1 && heights[i+1][j]>=heights[i][j] && !pacific[i+1][j]){\\n                pacific[i+1][j]=1;\\n                q.push({i+1,j});\\n            }\\n            \\n            if(j<n-1 && heights[i][j+1]>=heights[i][j] && !pacific[i][j+1]){\\n                pacific[i][j+1]=1;\\n                q.push({i,j+1});\\n            }\\n        }\\n        \\n        \\n        for(int i=m-1;i>=0;i--){\\n            atlantic[i][n-1]=1;\\n            q.push({i,n-1});\\n        }\\n        \\n        for(int j=n-2;j>=0;j--){\\n            atlantic[m-1][j]=1;\\n            q.push({m-1,j});\\n        }\\n        \\n        \\n        while(!q.empty()){\\n            auto ele=q.front();\\n            q.pop();\\n            int i=ele.first,j=ele.second;\\n                        \\n            if(i>0 && heights[i-1][j]>=heights[i][j] && !atlantic[i-1][j]){\\n                atlantic[i-1][j]=1;\\n                q.push({i-1,j});\\n            }\\n            \\n            if(j>0 && heights[i][j-1]>=heights[i][j] && !atlantic[i][j-1]){\\n                atlantic[i][j-1]=1;\\n                q.push({i,j-1});\\n            }\\n            \\n            if(i<m-1 && heights[i+1][j]>=heights[i][j] && !atlantic[i+1][j]){\\n                atlantic[i+1][j]=1;\\n                q.push({i+1,j});\\n            }\\n            \\n            if(j<n-1 && heights[i][j+1]>=heights[i][j] && !atlantic[i][j+1]){\\n                atlantic[i][j+1]=1;\\n                q.push({i,j+1});\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(atlantic[i][j] && pacific[i][j])result.push_back({i,j});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n  \\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\\n          \\n        int m=heights.size(),n=heights[0].size();\\n        \\n        vector<vector<int>>atlantic(m,vector<int>(n)),pacific(m,vector<int>(n)),vis(m,vector<int>(n));\\n        \\n        vector<vector<int>>result;\\n        \\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<m;i++){\\n            pacific[i][0]=1;\\n            q.push({i,0}",
                "codeTag": "Java"
            },
            {
                "id": 2508451,
                "title": "simply-written-java-code-dfs-linear-time-solution-explanation",
                "content": "```\\nclass Solution { // 5ms - 92.80% Faster\\n    int heights[][],m,n;\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        this.heights=heights; m=heights.length;n=heights[0].length;\\n        boolean FMPacific[][] = new boolean[m][n], FMAtlantic[][] = new boolean[m][n];\\n        dfsFlow(FMPacific,0,0,true); dfsFlow(FMAtlantic,m-1,n-1,false);\\n        List<List<Integer>> list = new ArrayList<List<Integer>>(); List<Integer> lis;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(FMPacific[i][j] && FMAtlantic[i][j]){ // if the cell\\'s rain can flow to both pacific and atlantic, then we are storing the position\\n                    lis = new ArrayList<Integer>();\\n                    lis.add(i); lis.add(j);\\n                    list.add(lis);\\n                }\\n        return list;\\n    }\\n    \\n    private void dfsFlow(boolean[][] flowMap, int i, int j, boolean isPacific){\\n        flowMap[i][j]=true;\\n        if(isPacific){ // this is the compulsory zone for flowing to the respective oceans directly (since it is in the boundary)\\n            if(i==0 && (j+1)<n) dfsFlow(flowMap,i,j+1,isPacific);\\n            if(j==0 && (i+1)<m) dfsFlow(flowMap,i+1,j,isPacific);\\n        }else{\\n            if(i==(m-1) && (j-1)>=0) dfsFlow(flowMap,i,j-1,isPacific);\\n            if(j==(n-1) && (i-1)>=0) dfsFlow(flowMap,i-1,j,isPacific);\\n        }\\n        if((j+1)<n && !flowMap[i][j+1] && heights[i][j]<=heights[i][j+1])  dfsFlow(flowMap,i,j+1,isPacific); // This is to check inside the boundary for valid flow structure\\n        if((i+1)<m && !flowMap[i+1][j] && heights[i][j]<=heights[i+1][j])  dfsFlow(flowMap,i+1,j,isPacific);\\n        if((j-1)>=0 && !flowMap[i][j-1] && heights[i][j]<=heights[i][j-1]) dfsFlow(flowMap,i,j-1,isPacific);\\n        if((i-1)>=0 && !flowMap[i-1][j] && heights[i][j]<=heights[i-1][j]) dfsFlow(flowMap,i-1,j,isPacific);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution { // 5ms - 92.80% Faster\\n    int heights[][],m,n;\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        this.heights=heights; m=heights.length;n=heights[0].length;\\n        boolean FMPacific[][] = new boolean[m][n], FMAtlantic[][] = new boolean[m][n];\\n        dfsFlow(FMPacific,0,0,true); dfsFlow(FMAtlantic,m-1,n-1,false);\\n        List<List<Integer>> list = new ArrayList<List<Integer>>(); List<Integer> lis;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(FMPacific[i][j] && FMAtlantic[i][j]){ // if the cell\\'s rain can flow to both pacific and atlantic, then we are storing the position\\n                    lis = new ArrayList<Integer>();\\n                    lis.add(i); lis.add(j);\\n                    list.add(lis);\\n                }\\n        return list;\\n    }\\n    \\n    private void dfsFlow(boolean[][] flowMap, int i, int j, boolean isPacific){\\n        flowMap[i][j]=true;\\n        if(isPacific){ // this is the compulsory zone for flowing to the respective oceans directly (since it is in the boundary)\\n            if(i==0 && (j+1)<n) dfsFlow(flowMap,i,j+1,isPacific);\\n            if(j==0 && (i+1)<m) dfsFlow(flowMap,i+1,j,isPacific);\\n        }else{\\n            if(i==(m-1) && (j-1)>=0) dfsFlow(flowMap,i,j-1,isPacific);\\n            if(j==(n-1) && (i-1)>=0) dfsFlow(flowMap,i-1,j,isPacific);\\n        }\\n        if((j+1)<n && !flowMap[i][j+1] && heights[i][j]<=heights[i][j+1])  dfsFlow(flowMap,i,j+1,isPacific); // This is to check inside the boundary for valid flow structure\\n        if((i+1)<m && !flowMap[i+1][j] && heights[i][j]<=heights[i+1][j])  dfsFlow(flowMap,i+1,j,isPacific);\\n        if((j-1)>=0 && !flowMap[i][j-1] && heights[i][j]<=heights[i][j-1]) dfsFlow(flowMap,i,j-1,isPacific);\\n        if((i-1)>=0 && !flowMap[i-1][j] && heights[i][j]<=heights[i-1][j]) dfsFlow(flowMap,i-1,j,isPacific);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570672,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1567567,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1565254,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1568773,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1566118,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1570380,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1566803,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1565696,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1575174,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1566905,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1570672,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1567567,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1565254,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1568773,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1566118,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1570380,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1566803,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1565696,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1575174,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1566905,
                "content": [
                    {
                        "username": "leweyM",
                        "content": "I was having trouble visualising the grid, especially for large data sets, so I made this tool to be able to play around with different inputs. \\n\\nhttps://editor.p5js.org/LeweyM/full/RpAxMlZL4\\n\\n![image](https://assets.leetcode.com/users/images/5569b199-fb17-4efe-985f-f634aa8eed26_1636967818.730621.png)\\n\\n![image](https://assets.leetcode.com/users/images/307719be-f6fe-4d35-bb52-809bcce6cb2a_1636967848.7110164.png)\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Thank you very much for this awesome tool, I have never been gratefull for someone\\'s this kind on tool.\\nThanks again."
                    },
                    {
                        "username": "onkark98",
                        "content": "very cool and helpful"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "you are admin now"
                    },
                    {
                        "username": "ranjanaashish",
                        "content": "One of the test case [30 X 30 matrix] was failing for me. And it was a pain to dry run that big test case. This tool saved my day. Thanks a ton [@leweyM](/leweyM)"
                    },
                    {
                        "username": "khanumar3",
                        "content": "amazing"
                    },
                    {
                        "username": "kaliprasad4035",
                        "content": "Broo that was lit ,awesome"
                    },
                    {
                        "username": "ryabkin",
                        "content": " Cool!"
                    },
                    {
                        "username": "tan_kau",
                        "content": "How is this problem not downvoted for insufficient explanation of the problem? I spent 15 min trying to understand the problem statement!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "It seems clear enough to me as well."
                    },
                    {
                        "username": "nikhila01",
                        "content": "Seems clear enough to me. No idea if they\\'ve updated it since you commented though."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I did not understand what does this sentence mean \"Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\", I wonder if you could help. thanks"
                    },
                    {
                        "username": "Samyak_Jain_",
                        "content": "[@ryabkin](/ryabkin) man it\\'s been some time since she asked\\uD83D\\uDE02. Still cool others can know."
                    },
                    {
                        "username": "ryabkin",
                        "content": "find all [x,y] cells with such a height which allows water flow to get to both oceans moving only up/down left/right"
                    },
                    {
                        "username": "cloudlearning22",
                        "content": "Height at [2,1] is 6. Water cannot flow from 6 to Pacific Ocean beacuse both its top and left neighbour are greater than 6. Am I missing some scenario or test case is wrong?\\n![image](https://assets.leetcode.com/users/images/05d03e2d-fa94-45f9-aa8a-fc50f9e2cd3d_1653653864.9070594.png)\\n"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Water can flow from 6 -> 5 -> 4 -> 3 -> Pacific. Water can flow in all 4 directions to reach any water body. In fact, this was the test case that made me realize that my approach was wrong. "
                    },
                    {
                        "username": "krishnansr_siva",
                        "content": "I had the same test case fail. It makes sense because [2,1] can flow into [2,2] (rightside) and then proceed top to [1,2] -> [0,2] -> Pacific ocean."
                    },
                    {
                        "username": "afsf11",
                        "content": "^ Topic? Can flow down to atlantic and up to pacific\\n"
                    },
                    {
                        "username": "thewal",
                        "content": "cell[3,3] and [3,4] => up and down setifys but why is not in ans ?\\n\\n![image](https://assets.leetcode.com/users/images/ae33c3b6-05df-4e7f-b8ba-8eb080226d03_1616666667.1620362.png)\\n\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "From 4, you are choosing the path to reach pacific is 4->3->4->3 \\nBut from 4 it can flow 4->3 but it can not flow from 3->4 as 3 is sma;ler than 4.\\n\\nSame for 5, it can flow 5->1 but it can not flow 1->4 as 1 is smaller than 4."
                    },
                    {
                        "username": "Adoni1203",
                        "content": "Hi,\\n\\nDid anyone solve this problem with DP? I find my output tend to miss one or two correct points and I don't know why"
                    },
                    {
                        "username": "Hariharan98",
                        "content": "[@Arjun Thakur](/thakurarjun247) is correct you cannot solve it using DP. The problem does not posses optimal substructure. Optimal substructure means you have all the solutions to problems that you need to arrive at the solution of the current problem. You cannot formulate this problem in a way it obeys optimal substructure property."
                    },
                    {
                        "username": "thakurarjun247",
                        "content": "This is because, in dp you considered only two directions to fill the matrix e.g. only right and bottom for pacific. You should consider all the three directions. It will get you into a n infinite loop though."
                    },
                    {
                        "username": "Spothedog1",
                        "content": "Can someone explain the problem a little better? From the example in the description, how can we go from [3,1] -> [2,2] or from [1,3]->[2,2] if water can only flow in 4 directions? That movement is a diagnol. Also what is the goal, to get from any cell touching the Pacific to any cell touching the Atlantic in both directions?"
                    },
                    {
                        "username": "rezeile21",
                        "content": "I\\'m convinced the value at point (2,1) cannot flow into the pacific ocean for the follwing input:\\n\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nThe value at row 2, column 1 (i.e. 6) will be blocked by 7 if it tried to flow left into the pacific ocean and will be blocked by 9 if it tried to flow into the pacific to the top. \\n\\nNonetheless, for this input: [[1,2,3],[8,9,4],[7,6,5]]\\n\\nThe pair [2,1] is part of the expected answer: [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]. \\n\\nWhat am I missing?"
                    },
                    {
                        "username": "andrehui09",
                        "content": "Note that water can flow in any direction. This means [2,1] can flow along the path: [2,1],[2,2],[1,2],[0,2], hence reaching the pacific."
                    },
                    {
                        "username": "sas330",
                        "content": "\"Water can only flow... from a cell to another one with height equal or lower.\"\\n\\nYet, in `[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]`, it flows over [3][1] whose height is 7. 7 is adjacent to 6 and 5 and water shouldn\\'t able to flow it from either of those cells.\\n\\nI don\\'t understand the general rule and even though I paid for premium, sadly there is no Solution. It would be like water flowing up a mountain!\\n\\nEDIT: I think the water starts flowing *from* the 7. So, imagine the 7 is a mountain with snow. The water is meltwater from the mountain, *not* water flowing in from the ocean."
                    },
                    {
                        "username": "snoopy0123",
                        "content": "Imagine it\\'s raining on ALL the cells"
                    }
                ]
            },
            {
                "id": 1567260,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1580285,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1573558,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1569444,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1804198,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1573418,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1572782,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1824641,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1770157,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1674285,
                "content": [
                    {
                        "username": "ccyangcc",
                        "content": "Cannot understand the flow direction,\\nIs the height is depth from the sea level, higher value means deeper? for example 4->5 works? Now I am thinking always think 5 -> 4 works."
                    },
                    {
                        "username": "sir_rishi",
                        "content": "Doing DFS on every cell may seem promising but the time complexity then would be O((N*M)^2) which might be slow for the given constraint. Why not start from the end? why not DFS from the Atlantic and pacific coasts. "
                    },
                    {
                        "username": "meesubra",
                        "content": "Why is (3,4) with the value 5 is not an answer? It can reach to the top and the right..??"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, it can reach the Atlantic to the right. But it can\\'t reach the Pacific to the top. The rain can flow from 5 -> 1, but then it can\\'t flow from 1 -> 4 because that\\'s uphill."
                    },
                    {
                        "username": "Jackson1",
                        "content": "Why [2,1]  in this answer, the answer is \\n[[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]"
                    },
                    {
                        "username": "rekkles_21",
                        "content": "Can someone explain why dfs from ocean works but a dfs from every cell to ocean wont work.\\n"
                    },
                    {
                        "username": "Prajan280496",
                        "content": "How can water flow from [1,4] to pacific in given example?\\nit can go from 4->4->3->2 and from 2->3 it cannot go. so no way in row journey\\nit cannot go in column journey as 4<5 for 4->5\\nQuestions says water can move from a cell to another cell with less or equal value but 2->3 it cannot make a move."
                    },
                    {
                        "username": "MagicTudou",
                        "content": "for the test:\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nwhy [2,1] is one pair of the answer?"
                    },
                    {
                        "username": "primkruskal",
                        "content": "Why doesn\\'t dynamic programming work for this problem? For example if a position x, y along a dfs path has proven to reach either ocean, store that in a matrix and the next time the dfs  comes across the position x, y return the value stored in the ocean matrix. Looking for any intuition on why this doesn\\'t work"
                    },
                    {
                        "username": "miraj2399",
                        "content": "If anyone tries a dp approach and it fails, here\\'s why-\\n\\ndp [i][j][k] is a boolean which represents if cell i,j can reach k (k=0 for pacific, k=1 for atlantic)\\n\\nThat above approach fails. When we\\'re at (i,j) we will decide if cell (i,j) is reachable from pacific by considering (i-1,j) and (i,j-1) cell. But it is possible that, (i,j) is reachable from (i+1,j) or (i,j+1). And when wer\\'e at (i,j) using dp approach, we don\\'t know if (i+1,j) and (i,j+1) is reachable from pacific yet. So, dynamic programming approach fails"
                    },
                    {
                        "username": "rr4546",
                        "content": "has anyone been able to get solution involving land to ocean with memoization to work?"
                    }
                ]
            },
            {
                "id": 1576411,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1576230,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1571695,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1571694,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 2046435,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 2021445,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1987012,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1970450,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1969917,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1952013,
                "content": [
                    {
                        "username": "wingerse",
                        "content": "My code is failing for this test case: https://leetcode.com/submissions/detail/643854445/testcase/\\nbecause my output includes both [35, 2] and [35, 3].  The test case expects only [35, 2].  \\n\\n![image](https://assets.leetcode.com/users/images/5bae7309-0207-4021-900c-2b05ce4fe567_1645181498.4315581.png)\\nI don\\'t see why it shouldn\\'t include [35, 3] :/?"
                    },
                    {
                        "username": "ayoj50796",
                        "content": "For example in the solution: [1,4] refers to a height of 4.\\nMeaning if we start in the top left corner, we go down 1 and right 4 which gives us this answer.\\n\\nHowever if we interpret x = 1, and y = 4 then the height is actually 1 after going right 1 and down 4.\\nI always thought x was the horizontal plane and y is the vertical.\\n\\nI think I am missing something really simple here and doubting everything I know about matricies and x/y coordinates. Can someone please clarify this?"
                    },
                    {
                        "username": "indish",
                        "content": "Hi, I submitted the solution but at a test case may be 37th test case, it failed\\n\\nGiven matrix:\\n1 2 3\\n8 9 4\\n7 6 5\\n\\nGenerated output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\n\\nExpected output : [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\n\\nWhy is the [2,1] included in expected output, it can't flow to pacific right ? i.e, the numbers left and top of 6 are both greater than 6. How is it possible ? Isn't the test case wrong here ?\\n\\nPlease clarify, thank you !!"
                    },
                    {
                        "username": "sculd",
                        "content": "I get the following response,\\nInput:\\n[[1]]\\nOutput:\\n[[4,0],[3,0],[3,1],[2,2],[0,4],[1,4],[1,3],[0,0]]\\nExpected:\\n[[0,0]]\\n\\nwhereas my code works fine as I checked on my laptop. Also, custom example result for [[1]] is [[0,0]] on the page."
                    },
                    {
                        "username": "faiq--",
                        "content": "i dont understand why we cant just start bfs from the left bottom corner and upper right corner (as they are the only two points where both pacific and atlantic ocean combines) and return the coordinates that were visited during the 2 traversals"
                    },
                    {
                        "username": "akanksha01",
                        "content": "in this test case [[1,2,3],[8,9,4],[7,6,5]], how come [2,1] is an answer? Water can flow to Atlantic but not to pacific. "
                    },
                    {
                        "username": "ozgrsvk",
                        "content": "Start from the sea levels, not the peaks, the cells which you can reach from both Atlantic and Pacific edges are the answers."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I do not know why people have so much hate for this question. Everything is intuitive about this question."
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "basically the problem wants us to find cells from where water can end up in pacific as well as atlantic ocean\\n"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bhagwan bachaye aise interview problem se!"
                    }
                ]
            },
            {
                "id": 1938433,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1933622,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1926356,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1917815,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1908713,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1841722,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1818050,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1772615,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1766766,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1761479,
                "content": [
                    {
                        "username": "A-reum",
                        "content": "the logic behind how to check different conditions to reach end and return the ans vector. is what makes it a 370k accepted question."
                    },
                    {
                        "username": "mohit6923",
                        "content": "I think it has wrong test cases!\\nfor e.g.\\nexample: [[10,10,10],[10,1,10],[10,10,10]]\\noutput: [[0,0],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]\\nwhy output does not contain [0,1]?\\nIdeally water can go to both neighbors and then into both oceans! \\n\\nI don\\'t get it! can somebody please explain?\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "How did you get that output? When I run your test case I get an output of `[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]`."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Maintain 2 visiting vector one for pacific and one for Atlantic. Index where we can travel both will be ans."
                    },
                    {
                        "username": "glard",
                        "content": "why does \"[3,0] -> [4,0] -> Atlantic Ocean\" work in the Example 1?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@glard](/glard) No problem. I\\'m ok answering simple questions when people actually appreciate the help. Most people never even respond."
                    },
                    {
                        "username": "glard",
                        "content": "[@nikhila01](/nikhila01) Thanks. I read it wrong. Sorry for the silly question-_-"
                    },
                    {
                        "username": "nikhila01",
                        "content": "`[3,0]` has a height of `6` and `[4,0]` has a height of `5`. Water can flow to a cell that has the same height or less, so it\\'s able to flow from `[3,0]` -> `[4,0]`.\\n\\nWater can flow from any cell adjacent to an ocean into the ocean. `[4,0]` is adjacent to the Atlantic Ocean so `[4,0]` -> Atlantic Ocean."
                    },
                    {
                        "username": "lost_wolf",
                        "content": "class Solution {\\npublic:\\n    int n=0,m=0;\\n    int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int i,int j,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<pair<bool,bool>>>&ocean)\\n    {\\n        vis[i][j]=true;\\n       \\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+d[k][0];\\n            int y=j+d[k][1];\\n            if(x<n && y<m && x>=0 && y>=0)\\n            {\\n                if(grid[x][y]<=grid[i][j])\\n                {\\n                    if(!vis[x][y])\\n                    {\\n                        dfs(x,y,grid,vis,ocean);\\n                    }\\n                    if(ocean[x][y].second) ocean[i][j].second=true;\\n                    if(ocean[x][y].first) ocean[i][j].first=true;\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));\\n        vector<vector<pair<bool,bool>>> ocean(n,vector<pair<bool,bool>> (m,{0,0}));\\n        for(int i=0;i<n;i++) \\n        {\\n            ocean[i][0].first=1;\\n            ocean[i][m-1].second=1;\\n        }\\n        for(int j=0;j<m;j++) \\n        {\\n            ocean[0][j].first=1;\\n            ocean[n-1][j].second=1;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j])\\n                {\\n                    dfs(i,j,grid,vis,ocean);\\n                }\\n            }\\n        }\\n        \\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(ocean[i][j].first && ocean[i][j].second)\\n                {\\n                    ans.push_back({i,j});\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n\\nwhat is wrong i this approach giving wrong answer on [[3,3,3,3,3,3],[3,0,3,3,0,3],[3,3,3,3,3,3]] not giving {0,1} land in answer.\\n\\ni have made a vector of pair of vector which have two bool values for each i and j for whether water flows in pacific or atlantic from that land or not.\\n i have travel from land to ocean via nodes with height less than or equal to and if i found any water body i update the ocean value and then backtrack to previous lands and also update their answer.\\nplease help and show me what is wrong in my logic or code. "
                    },
                    {
                        "username": "celesty",
                        "content": "I\\'m confused by the answer. There was this test case of 99x99 grid heights, the correct answer is [[0,97],[0,98],[0,99],[98,0],[99,0]], which mean cell [0,97] and [0,98] reach Atlantic by flowing to the right. However, when I look at the input heights, the last 3 numbers on the first row is 1731, 1011, 1739. How can [0,97] and [0,98] flow to the right and reach Atlantic then? Clearly it can\\'t reach by flowing down because answer would\\'ve included those cells."
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "Can someone please tell me how to know from where the island partition started. Like which cells of the grid are islands?"
                    },
                    {
                        "username": "data500",
                        "content": "pls correct my code\nwrong ans at test case 60\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& height) {\n        int n=height.size();\n        int m=height[0].size();\n        int pacific[n][m];\n     \n     for(int i=0;i<n;i++){\n         pacific[i][0]=1;\n     }\n\n     for(int j=0;j<m;j++){\n         pacific[0][j]=1;\n     }\n     \n        for(int i=1;i<n;i++){\n\n            for(int j=1;j<m;j++){\n               if(height[i][j-1]<=height[i][j]&&pacific[i][j-1]){\n                   pacific[i][j]=1;\n               }\n               else if(pacific[i-1][j]&&height[i-1][j]<=height[i][j]){\n                    pacific[i][j]=1;\n               }\n               else{\n                  pacific[i][j]=0; \n               }\n            }\n        }\n\n       int atlantic[n][m];\n\n       for(int i=0;i<n;i++){\n           atlantic[i][m-1]=1;\n       } \n\n       for(int i=0;i<m;i++){\n           atlantic[n-1][i]=1;\n       } \n\n       for(int i=n-2;i>=0;i--){\n           for(int j=m-2;j>=0;j--){\n               if(height[i][j]>=height[i][j+1]&& atlantic[i][j+1]){\n                   atlantic[i][j]=1;\n               }\n               else if(height[i][j]>=height[i+1][j]&& atlantic[i+1][j]){\n                   atlantic[i][j]=1;\n               }\n               else{\n                    atlantic[i][j]=0;\n               }\n           }\n       }\n vector<vector<int>>ans;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<m;j++){\n               int p=pacific[i][j];\n               int at=atlantic[i][j];\n\n            if(i+1<n&&height[i][j]>height[i+1][j]){\n             at=at|atlantic[i+1][j];\n            p=p| pacific[i+1][j];\n           }\n           else if(i-1>=0&&height[i][j]>height[i-1][j]){\n            at=at|atlantic[i-1][j];\n            p=p| pacific[i-1][j];\n           }\n           else if(j+1<m&&height[i][j]>height[i][j+1]){\n               at=at|atlantic[i][j+1];\n            p=p| pacific[i][j+1];\n           }\n           else if(j-1>=0&&height[i][j]>height[i][j-1]){\n             at=at|atlantic[i][j-1];\n            p=p| pacific[i][j-1];\n           }\n           if(at&&p){\n               vector<int>a;\n               a.push_back(i);\n               a.push_back(j);\n               ans.push_back(a);\n\n           }\n       }\n       }\nreturn ans;\n    }\n};\n"
                    },
                    {
                        "username": "soyukotoda",
                        "content": "Consider along one row, you have this height:\\n[3, 1, 7]\\nCan the water from 7 flows to left boundary? 7 can surely flow to 1, but although 1 is smaller than 3, 7 is not, so the 1 can be overflow then flow out."
                    },
                    {
                        "username": "soyukotoda",
                        "content": "The answer is no, need to check current height."
                    },
                    {
                        "username": "yaojintham",
                        "content": "Approach to consider: \\n1. Collect the top and left cells that are adjacent to the Pacific.\\n2. Traverse from these cells to cells that are higher or equal, marked these as able to flow to Pacific.\\n3. Do the same for right and bottom cells that are adjacent to the Atlantic.\\n4. For the cells marked, the intersections are the cells that can flow to both oceans"
                    }
                ]
            },
            {
                "id": 1753047,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1744418,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1741709,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1735981,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1730224,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1728745,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1726336,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1719400,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1705756,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            },
            {
                "id": 1696460,
                "content": [
                    {
                        "username": "pranmanral",
                        "content": "I still don\\'t understand the question. Why [[1,2,3],[8,9,4],[7,4,5]] is giving expected answer = [[0,2],[1,0],[1,1],[1,2],[2,0],[2,2]]\\nand [[1,2,3],[8,9,4],[7,6,5]] is giving [[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\\nin both cases, 4 and 6 are smaller than adjacent cells(7 and 9) to reach pacific."
                    },
                    {
                        "username": "neo9729",
                        "content": "Problem needs better explanation and case description where water can move forward or downward and still reach pacific ocean. "
                    },
                    {
                        "username": "aravindmurugan96",
                        "content": "can anyone please help me in understanding and visualizing the question , im having a hard time understanding the question itself..."
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Any idea what is the wrong with my solution ?\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        \\n        int rows = heights.length; int cols = heights[0].length;\\n        List<List<Integer>> result  = new ArrayList<>();\\n      \\n       \\n        for (int r = 0 ; r < rows ; r++){\\n            for(int c= 0 ;c < cols ; c ++){\\n                boolean [][] visited = new boolean[rows][cols];\\n                boolean status = dfs(heights, r, c , visited );\\n                System.out.println(status);\\n                if (status) result.add(Arrays.asList(r,c));\\n\\n            }\\n        }\\n        return result;\\n\\n\\n    }\\n\\n    private boolean dfs(int[][] heights, int r , int c , boolean [][] visited ){\\n  \\n    if (isHitOcean(heights , r,c)) return true;\\n    \\n    visited[r][c] = true;\\n     \\n\\n    boolean north = (isHitOcean(heights , r-1,c) || ( !isHitOcean(heights , r-1,c) && heights[r][c] >=  heights[r-1][c] && !visited[r-1][c] ) ) ? dfs(heights, r-1 , c , visited): false;\\n    boolean west =  (isHitOcean(heights , c-1,c) || (!isHitOcean(heights , c-1,c) && heights[r][c] >=  heights[r][c-1] && !visited[r][c-1]) ) ? dfs(heights, r , c-1 , visited):false;\\n\\n    boolean south  = (isHitOcean(heights , r+1,c) || (!isHitOcean(heights , r+1,c) && heights[r][c] >=  heights[r+1][c] && !visited[r+1][c]) ) ? dfs(heights, r+1 , c , visited):false; \\n    boolean east  = (!isHitOcean(heights , r,c+1) || (!isHitOcean(heights , r,c+1) && heights[r][c] >=  heights[r][c+1] && !visited[r][c+1]) ) ? dfs(heights, r , c+1 , visited):false;\\n    \\n    if ((north || west) && (south || east)) return true;\\n\\n    return false;\\n    }\\n\\n    private boolean isHitOcean(int[][] heights, int r , int c){\\n     if (r < 0 || c < 0 || r >= heights.length || c >= heights[0].length ){\\n       return true;\\n     }\\n     return false;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "him431",
                        "content": "**In the given input**\\nInput: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\\n\\nThe cell [3,3],[3,4] can also add water to both atlantic and pacific . **Why these are not covered in expected output????**"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "This should be a hard while [329. Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/) should be a medium imo since this involves a few tricks."
                    },
                    {
                        "username": "chatterjeerajiv7601",
                        "content": "Can anyone pls point out what\\'s wrong with my code?\\nit is failing for the testcase\\n[[1,2,3],[8,9,4],[7,6,5]]\\n\\nclass Solution {\\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\\n        int n=heights.length;\\n        int m=heights[0].length;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            boolean flag=false;\\n            for(int j=0;j<m;j++)\\n            {\\n                List<Integer> temp=new ArrayList<>();\\n                 flag=dfsA(i,j,heights,n,m)&&dfsP(i,j,heights,n,m);\\n                 if(flag==true){\\n                     \\n                    temp.add(i);\\n                    temp.add(j);\\n                     ans.add(temp);\\n                 }  \\n            }     \\n        }\\n        return ans;    \\n    }\\n    boolean dfsP(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==0||j==0)\\n        return true;\\n        if((heights[i-1][j]>heights[i][j])&&(heights[i][j-1]>heights[i][j]))\\n        return false;\\n        return dfsP(i-1,j,heights,n,m)||dfsP(i,j-1,heights,n,m);\\n    }\\n     boolean dfsA(int i,int j,int[][] heights,int n,int m)\\n    {\\n        if(i==n-1||j==m-1)\\n        return true;\\n        if((heights[i+1][j]>heights[i][j])&&(heights[i][j+1]>heights[i][j]))\\n        return false;\\n        return dfsA(i+1,j,heights,n,m)||dfsA(i,j+1,heights,n,m);\\n    }\\n}"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Didn\\'t understand this question one bit. They gave 7 solutions, but won\\'t all adjacent cells flow into the ocean? meaning 16 cells atleast?"
                    },
                    {
                        "username": "pythagoreantree",
                        "content": "It seems that the task is incorrect. If it is claimed, that the water can flow through cells that are equal to or less than current, then [3, 3] and [3, 4] are also suitable. \\n[3, 3] -> [2, 3] -> [1, 3] -> [0, 3] -> Pacific Ocean\\n[3, 3] -> [4, 3] -> Atlantic Ocean\\nand similarly for [3, 4].\\n\\nIf we need a decision as shown in the picture, we need to count only increasing cells. I mean we use paths with increasing height only, it can\\'t be like 3 -> 4 -> 3 -> 4. But there is no such information in the task description."
                    },
                    {
                        "username": "chxclyde",
                        "content": "Can anyone helps me with this problem? I think all should be fine but it cant pass the testcase 90/113\\n ```class Solution:\\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\\n        m, n = len(heights),len(heights[0])\\n        flow_pacific = [[True if (i==0 or j==0) else None for i in range(n)]  for j in range(m)]\\n        flow_atlantic = [[True if (i==n-1 or j==m-1) else None for i in range(n)]  for j in range(m)]\\n        visited=[[False for i in range(n)] for j in range(m) ]\\n        def dfs_pacific (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_pacific[x][y] != None:\\n                visited[x][y] = False\\n                return flow_pacific[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    flow_pacific[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if adjx>=m or adjy >=n:\\n                    continue\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_pacific(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_pacific[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_pacific[x][y] = False\\n            return False\\n        def dfs_atlantic (x,y): #x,y must be in range.\\n            visited[x][y] = True\\n            if flow_atlantic[x][y] != None:\\n                visited[x][y] = False\\n                return flow_atlantic[x][y]\\n            # start to search\\n            adj = [(x+1,y) , (x-1,y),(x,y+1),(x,y-1)]\\n            for adjx,adjy in adj:\\n                if adjx<0 or adjy<0:\\n                    continue\\n                if adjx>=m or adjy >=n:\\n                    flow_atlantic[x][y] = True #base case.\\n                    visited[x][y] = False\\n                    return True\\n                if heights[adjx][adjy] <= heights[x][y] and not visited[adjx][adjy]:\\n                    if dfs_atlantic(adjx,adjy):\\n                        visited[x][y] = False\\n                        flow_atlantic[x][y] = True\\n                        return True\\n            visited[x][y] = False\\n            flow_atlantic[x][y] = False\\n            return False\\n        for i in range(m):\\n            for j in range(n):\\n                dfs_pacific(i,j)\\n                dfs_atlantic(i,j)\\n        res = []\\n        for i in range(m):\\n            for j in range(n):\\n                if flow_atlantic[i][j] and flow_pacific[i][j]:\\n                    res.append([i,j])\\n        return res```"
                    }
                ]
            }
        ]
    }
]