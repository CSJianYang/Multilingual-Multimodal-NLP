[
    {
        "title": "Increasing Order Search Tree",
        "question_content": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.\n&nbsp;\nExample 1:\n\nInput: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\nExample 2:\n\nInput: root = [5,1,7]\nOutput: [1,null,5,null,7]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the given tree will be in the range [1, 100].\n\t0 <= Node.val <= 1000",
        "solutions": [
            {
                "id": 165885,
                "title": "c-java-python-self-explained-5-line-o-n",
                "content": "## **Intuition**\\nDon\\'t need the condition of BST, just in-order output the whole tree.\\n\\nStraight forward idea here:\\n`result = inorder(root.left) + root + inorder(root.right)`\\n<br>\\n\\n## **Explanation**\\n\\nRecursively call function `increasingBST(TreeNode root, TreeNode tail)`\\n`tail` is its next node in inorder,\\n\\uFF08the word `next` may be easier to understand, but it\\u2019s a keyword in python)\\n\\nIf `root == null`, the head will be `tail`, so we return `tail` directly.\\n\\nwe recursively call `increasingBST(root.left, root)`,\\nchange left subtree into the linked list + current node.\\n\\nwe recursively call `increasingBST(root.right, tail)`,\\nchange right subtree into the linked list + tail.\\n\\nNow the result will be in a format of linked list, with right child is next node.\\nSince it\\'s single linked list, so we set `root.left = null`.\\nOtherwise it will be TLE for Leetcode judgment to traverse over your tree.\\n\\nThe result now is `increasingBST(root.left) + root + increasingBST(root.right)`.\\n\\nOne tip here, we should arrange the old tree, not create a new tree.\\nThe leetcode judgment comparer only the values,\\nso it won\\'t take it as wrong answer if you return a new tree,\\nbut it is wrong.\\n<br>\\n\\n## **Complexity**\\n`O(N)` time traversal of all nodes\\n`O(height)` space\\n<br>\\n\\n**C++:**\\n```cpp\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n```\\n**Python:**\\n```python\\n    def increasingBST(self, root, tail = None):\\n        if not root: return tail\\n        res = self.increasingBST(root.left, root)\\n        root.left = None\\n        root.right = self.increasingBST(root.right, tail)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```\n```java\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n```\n```python\\n    def increasingBST(self, root, tail = None):\\n        if not root: return tail\\n        res = self.increasingBST(root.left, root)\\n        root.left = None\\n        root.right = self.increasingBST(root.right, tail)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 958108,
                "title": "c-inorder-traversal-o-n-easy-to-understand",
                "content": "```\\n  void inorder(TreeNode*& ans, TreeNode* root) {\\n        if (!root) return;\\n        inorder(ans, root->left);\\n        ans->right = new TreeNode(root->val);\\n        ans = ans->right;\\n        inorder(ans, root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* temp;\\n        TreeNode* ans = new TreeNode();\\n        temp = ans;\\n        inorder(ans, root);\\n        return temp->right;\\n    }\\n```\\n\\nRecursive inorder call, upvote if you like the solution",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  void inorder(TreeNode*& ans, TreeNode* root) {\\n        if (!root) return;\\n        inorder(ans, root->left);\\n        ans->right = new TreeNode(root->val);\\n        ans = ans->right;\\n        inorder(ans, root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* temp;\\n        TreeNode* ans = new TreeNode();\\n        temp = ans;\\n        inorder(ans, root);\\n        return temp->right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165941,
                "title": "inorder-traversal",
                "content": "```\\nclass Solution {\\n    private TreeNode result;\\n    private TreeNode pre;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (result == null) {\\n            result = root;\\n        } else {\\n            pre.right = root;\\n        }\\n        pre = root;\\n        root.left = null;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private TreeNode result;\\n    private TreeNode pre;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    private void inorder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left);\\n        if (result == null) {\\n            result = root;\\n        } else {\\n            pre.right = root;\\n        }\\n        pre = root;\\n        root.left = null;\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165870,
                "title": "java-simple-inorder-traversal-with-explanation",
                "content": "```\\n   TreeNode prev=null, head=null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;   \\n        increasingBST(root.left);  \\n        if(prev!=null) { \\n        \\troot.left=null; // we no  longer needs the left  side of the node, so set it to null\\n        \\tprev.right=root; \\n        }\\n        if(head==null) head=root; // record the most left node as it will be our root\\n        prev=root; //keep track of the prev node\\n        increasingBST(root.right); \\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   TreeNode prev=null, head=null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;   \\n        increasingBST(root.left);  \\n        if(prev!=null) { \\n        \\troot.left=null; // we no  longer needs the left  side of the node, so set it to null\\n        \\tprev.right=root; \\n        }\\n        if(head==null) head=root; // record the most left node as it will be our root\\n        prev=root; //keep track of the prev node\\n        increasingBST(root.right); \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958059,
                "title": "python-inorder-dfs-explained",
                "content": "Let us construct new tree, using already existing nodes. My `dfs` function will have two outputs: node with smallest value (root of tree) and node with biggest value (leaf of tree). Then, all we need to do is to run `dfs` recursively:\\n\\n1. First, we denote `l1 = node` and `r2 = node`, this is for the case, if we will not have left or right children.\\n2. If we have left children, we create straight tree for left subtree using recursion and attach our `node` as right children of leaf of this tree.\\n3. If we have right children, we againg create straigh tree for right subtree using recursion and attach `r1` as right children of `node`.\\n4. We put left children of node to `None` to avoid loops in our final tree.\\n5. Return `dfs(root)[0]`: only root of constructed tree, not need to return leaf.\\n\\n**Complexity**: time complexity is `O(n)`, because we visit each node exactly once. Space compexity is `O(h)`, height of our tree.\\n\\n```\\nclass Solution:\\n    def increasingBST(self, root):\\n        def dfs(node):\\n            l1, r2 = node, node\\n            \\n            if node.left: \\n                l1, l2 = dfs(node.left)\\n                l2.right = node\\n                \\n            if node.right:\\n                r1, r2 = dfs(node.right)\\n                node.right = r1\\n            \\n            node.left = None\\n            return (l1, r2)\\n        \\n        return dfs(root)[0]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root):\\n        def dfs(node):\\n            l1, r2 = node, node\\n            \\n            if node.left: \\n                l1, l2 = dfs(node.left)\\n                l2.right = node\\n                \\n            if node.right:\\n                r1, r2 = dfs(node.right)\\n                node.right = r1\\n            \\n            node.left = None\\n            return (l1, r2)\\n        \\n        return dfs(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958187,
                "title": "morris-in-order-traversal-python-3-o-n-time-o-1-space",
                "content": "Hi everyone and thank you for showing interest in reading this article \\uD83D\\uDE4C.\\n\\n**Morris In-order traversal algorithm**\\nHave you ever asked yourself why do we use the stack when it comes to traversing a tree? Lets answer to this question! Stacks are used in [traversal algorithms](https://en.wikipedia.org/wiki/Tree_traversal) to keep track of parent-nodes that are not explored completely. This algorithm gets rid of the need for a stack and uses ```left``` and ```right``` links instead. Usually, this algorithm is used to collect only values, but we can do a slight modification to do relinking among different subtrees.\\n\\n**The workflow**\\n* create variables ```dummy``` and ```tail``` that will hold a link to a new node\\n* start iterating the tree with a while loop\\n\\t* if the current node has left child\\n\\t\\t*  find the rightmost node in the left subtree (the predecessor)\\n\\t\\t*  make the current node as the sibling\\'s right child\\n\\t\\t*  delete the link between the current node and its left child\\n\\t\\t*  mark the left child as a current node\\n\\t* if the current node does not have left child\\n\\t\\t* make the current node as the right child of the ```tail```\\n\\t\\t* mark current node as the ```tail```\\n\\t\\t* mark the right child of the current node as a current node\\n5. return the right child of the ```dummy```\\n\\n**The code**\\n```\\nclass Solution:\\n    def increasingBST(self, node: TreeNode) -> TreeNode:\\n        dummy = tail = TreeNode()\\n        while node is not None:\\n            if node.left is not None:\\n                predecessor = node.left\\n                while predecessor.right is not None:\\n                    predecessor = predecessor.right\\n                \\n                predecessor.right = node\\n                left, node.left = node.left, None\\n                node = left\\n            else:\\n                tail.right = tail = node\\n                node = node.right\\n        \\n        return dummy.right\\n```\\n\\n**Complexity analysis**\\nO(n) time - we traverse each node at most two times\\nO(1) space - no additional data structures were used\\n\\n**In conclusion**\\nThis is one of the most remarkably interesting algorithms I have ever learned \\uD83D\\uDC98. This algorithm does not only give you the possibility to collect all the nodes\\' values of the tree (without using any space) but also can rearrange the whole tree where nodes are present in order and each node has only the right child.\\n\\n\\uD83D\\uDCE2 *If you think that that solution is good enough to be recommended to other LeetCoders then upvote.*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```left```\n```right```\n```dummy```\n```tail```\n```tail```\n```tail```\n```dummy```\n```\\nclass Solution:\\n    def increasingBST(self, node: TreeNode) -> TreeNode:\\n        dummy = tail = TreeNode()\\n        while node is not None:\\n            if node.left is not None:\\n                predecessor = node.left\\n                while predecessor.right is not None:\\n                    predecessor = predecessor.right\\n                \\n                predecessor.right = node\\n                left, node.left = node.left, None\\n                node = left\\n            else:\\n                tail.right = tail = node\\n                node = node.right\\n        \\n        return dummy.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314557,
                "title": "100-faster-easy-python-iterative-solution-without-the-dummy-tree-node",
                "content": "```\\n# Keep going to the left of the tree by appending the nodes to the stack and once you reach the \\n# leaf, then pop the stack and make the first popped node as root and then for rest of the nodes, \\n# append it to the right of the current root and make the left for each node as None \\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        stack = []\\n        temp = x = root\\n        i = 0\\n        while stack or temp:\\n            if temp:\\n                stack.append(temp)\\n                temp = temp.left\\n            else:\\n                node = stack.pop()\\n                if i==0:\\n                    root = x = node\\n                    i+=1\\n                else:\\n                    x.right = node\\n                    x = node\\n                    x.left = None\\n                temp = node.right\\n        return root\\t\\n\\t\\t\\n# If you like the solution, upvote it and do suggest if you have a better solution!!\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n# Keep going to the left of the tree by appending the nodes to the stack and once you reach the \\n# leaf, then pop the stack and make the first popped node as root and then for rest of the nodes, \\n# append it to the right of the current root and make the left for each node as None \\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        stack = []\\n        temp = x = root\\n        i = 0\\n        while stack or temp:\\n            if temp:\\n                stack.append(temp)\\n                temp = temp.left\\n            else:\\n                node = stack.pop()\\n                if i==0:\\n                    root = x = node\\n                    i+=1\\n                else:\\n                    x.right = node\\n                    x = node\\n                    x.left = None\\n                temp = node.right\\n        return root\\t\\n\\t\\t\\n# If you like the solution, upvote it and do suggest if you have a better solution!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200938,
                "title": "c-recursive-and-iterative",
                "content": "Recursive: \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* newroot, *curr;\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        \\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }\\n        \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n};\\n```\\nIterative:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }\\n            \\n            curr=curr->right;\\n        }\\n        \\n        return newroot;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* newroot, *curr;\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        \\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }\\n        \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }\\n            \\n            curr=curr->right;\\n        }\\n        \\n        return newroot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955033,
                "title": "simple-easy-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/d9beda34-fea7-4f11-88de-7f8a50562f2c_1650157442.741445.png)\\n\\n**Time complexcity O(n)**\\n**Space complexcity O(n) (recursion)**\\n```\\nTreeNode * inorder(TreeNode *root,TreeNode *tmp)\\n    {\\n        if(root==NULL) return tmp;\\n        tmp=inorder(root->left,tmp);\\n        tmp->right=root;\\n        root->left=NULL;\\n        tmp=root;\\n        return inorder(root->right,tmp);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        TreeNode* dummy=new TreeNode(0);\\n        TreeNode* tmp=dummy;\\n        inorder(root,tmp);\\n        return dummy->right;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode * inorder(TreeNode *root,TreeNode *tmp)\\n    {\\n        if(root==NULL) return tmp;\\n        tmp=inorder(root->left,tmp);\\n        tmp->right=root;\\n        root->left=NULL;\\n        tmp=root;\\n        return inorder(root->right,tmp);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        TreeNode* dummy=new TreeNode(0);\\n        TreeNode* tmp=dummy;\\n        inorder(root,tmp);\\n        return dummy->right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777069,
                "title": "easy-python-solution-beats-90-with-comments",
                "content": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        vals = []\\n        # Easy recursive Inorder Traversal to get our values to insert.\\n        def inord(node):\\n            if not node:\\n                return\\n            inord(node.left)\\n            vals.append(node.val)\\n            inord(node.right)\\n            \\n        inord(root)\\n        # Create a new tree to return.\\n        tree = TreeNode(val=vals[0])\\n\\t\\t# Use a sentinel so we dont lose our tree location in memory.\\n        tmp = tree\\n\\t\\t# Iterate through our vals, creating a new right node with the current val.\\n        for i in vals[1:]:\\n            tmp.right = TreeNode(val=i)\\n\\t\\t\\t# Move the sentinel to the next node.\\n            tmp = tmp.right\\n            \\n        return tree\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        vals = []\\n        # Easy recursive Inorder Traversal to get our values to insert.\\n        def inord(node):\\n            if not node:\\n                return\\n            inord(node.left)\\n            vals.append(node.val)\\n            inord(node.right)\\n            \\n        inord(root)\\n        # Create a new tree to return.\\n        tree = TreeNode(val=vals[0])\\n\\t\\t# Use a sentinel so we dont lose our tree location in memory.\\n        tmp = tree\\n\\t\\t# Iterate through our vals, creating a new right node with the current val.\\n        for i in vals[1:]:\\n            tmp.right = TreeNode(val=i)\\n\\t\\t\\t# Move the sentinel to the next node.\\n            tmp = tmp.right\\n            \\n        return tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251290,
                "title": "c-short-iterative",
                "content": "The iterative inorder traversal is a good way to solve this problem. Each time we meet a node, link it like a linked list using the `right` pointer. To facilitate the linking, create a dummy `head`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *head = new TreeNode(0), *pre = head;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            pre -> right = root;\\n            pre = pre -> right;\\n            root -> left = NULL;\\n            root = root -> right;\\n        }\\n        return head -> right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *head = new TreeNode(0), *pre = head;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            pre -> right = root;\\n            pre = pre -> right;\\n            root -> left = NULL;\\n            root = root -> right;\\n        }\\n        return head -> right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668493,
                "title": "c-inorder-traversal-with-detail-explanation-and-intuition-of-general-recursion-on-tree",
                "content": "Hello everyone, recursion on tree is hard to understand, but hope this answer can give you some intuition.\\n\\nI figure it will be helpful to **only think of a simplest tree** when it comes recusion on tree. Concretly, think **a node with only a left child node and right child node**. What would the code look like if we want to do inorder-traversal. Answer is:\\n```\\n// Because it is just a simplest tree, we can write like this.\\nvoid inorder(TreeNode *root){\\n\\tcout << root->left->val;\\n\\tcout << root->val;\\n\\tcout << root->right>val;\\n}\\n```\\nOk, so far so well. But remember, the tree in real question is always not so simple. And that\\'s why we use recursion.\\n\\nNow, we **keep** the operation we did **for the current node** and **replace** the **left and right** operation with **recursion as operation of current node**, because this time we see left and right as subtree rather than node. \\n\\nAnd every time we enter a subtree, we face the same situation as its parent, that\\'s why we keep the current node operation and replace others, **we only have to and only CAN deal with the current node directly**, we can\\'t deal with subtree directly. Code like this:\\n```\\n// This time we face a real complicated tree. And just deal with some edge case when root is nullptr.\\nvoid inorder(TreeNode *root){\\n\\tif(root == nullptr) return; // edge case and for the stop of recursion.\\n\\tinorder(root->left); // replace\\n\\tcout << root->val; // keep\\n\\tinorder(root->right); // replace\\n}\\n```\\nOK, take a breath and let\\'s look at this question. The first thing you should know is **the result of inorder-traversal of a BST is an ordered sequence**. Go and search google or check MIT OCW 6.006 lecture05 if you are not familiar with BST.\\n\\nWelcome back and we move on, just think of it is a simplest tree in this question, and code should be:\\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\n\\t\\nprivate:\\n\\tTreeNode *ret = nullptr; // record left-most TreeNode\\n\\tTreeNode *pre = nullptr; // record pre TreeNode\\n\\tvoid solve(TreeNode *root){\\n\\t\\tret = root->left; // ret is the left-most node.\\n\\t\\tpre = ret; // initialize pre\\n\\t\\tpre->right = root; // just keep right node of pre is current node.\\n\\t\\troot->left = nullptr; \\n\\t\\tpre = root; // we have go through root, let\\'s mark root as pre and move on.\\n\\t\\t// same operation bellow\\n\\t\\tpre->right = root->right;\\n\\t\\troot->right->left = nullptr;\\n\\t\\tpre = root->right;\\n\\t}\\n};\\n```\\n\\nOK, hope you have understood the solution for the simplest BST. There are just few things to do next.\\nFirst keep the operation for current node which are:\\n```\\n// in the view of current node, we have recorded pre node.\\npre->right = root;\\nroot->left = nullptr;\\npre = root;\\n```\\n**ret** is the left-most TreeNode, and we want to return it at last. How can we get it? At very beginning, we initialize **pre** as nullptr, that makes sense because there is no pre node. And after we see first current node, we assign current code to pre. \\n\\nSo we can use the state of pre to get ret. We check whether pre is nullptr or not, if it is, we know the node that we currently deal with is the first node (**first is also the left-most** based on the observation of simplest BST), and we assign it to ret. Code now looks like:\\n```\\nif(pre){\\n\\tpre->right = root;\\n}else{\\n\\tret = root;\\n}\\nroot->left = nullptr;\\npre = root;\\n```\\nThe rest code is just trivial. We add two recursion for left subtree and right subtree and the edge case to stop recursion. Total code is there:\\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\nprivate:\\n    TreeNode *ret = nullptr;\\n    TreeNode *pre = nullptr;\\n    void solve(TreeNode *root){\\n        if(root == nullptr) return; // edge case and for the stop of recursion.\\n        solve(root->left); // recursion on left subtree.\\n\\t\\tif(pre){\\n\\t\\t\\tpre->right = root;\\n\\t\\t}else{\\n\\t\\t\\tret = root;\\n\\t\\t}\\n\\t\\troot->left = nullptr;\\n\\t\\tpre = root;\\n        solve(root->right); //recursion on right subtree.\\n    }\\n};\\n```\\n\\nHave a good day.\\n\\nBy,\\nAincrad-Lyu",
                "solutionTags": [],
                "code": "```\\n// Because it is just a simplest tree, we can write like this.\\nvoid inorder(TreeNode *root){\\n\\tcout << root->left->val;\\n\\tcout << root->val;\\n\\tcout << root->right>val;\\n}\\n```\n```\\n// This time we face a real complicated tree. And just deal with some edge case when root is nullptr.\\nvoid inorder(TreeNode *root){\\n\\tif(root == nullptr) return; // edge case and for the stop of recursion.\\n\\tinorder(root->left); // replace\\n\\tcout << root->val; // keep\\n\\tinorder(root->right); // replace\\n}\\n```\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\n\\t\\nprivate:\\n\\tTreeNode *ret = nullptr; // record left-most TreeNode\\n\\tTreeNode *pre = nullptr; // record pre TreeNode\\n\\tvoid solve(TreeNode *root){\\n\\t\\tret = root->left; // ret is the left-most node.\\n\\t\\tpre = ret; // initialize pre\\n\\t\\tpre->right = root; // just keep right node of pre is current node.\\n\\t\\troot->left = nullptr; \\n\\t\\tpre = root; // we have go through root, let\\'s mark root as pre and move on.\\n\\t\\t// same operation bellow\\n\\t\\tpre->right = root->right;\\n\\t\\troot->right->left = nullptr;\\n\\t\\tpre = root->right;\\n\\t}\\n};\\n```\n```\\n// in the view of current node, we have recorded pre node.\\npre->right = root;\\nroot->left = nullptr;\\npre = root;\\n```\n```\\nif(pre){\\n\\tpre->right = root;\\n}else{\\n\\tret = root;\\n}\\nroot->left = nullptr;\\npre = root;\\n```\n```\\nclass Solution {\\n public:\\n\\tTreeNode* increasingBST(TreeNode* root) {\\n\\t\\tsolve(root);\\n\\t\\treturn ret;\\n\\t}\\nprivate:\\n    TreeNode *ret = nullptr;\\n    TreeNode *pre = nullptr;\\n    void solve(TreeNode *root){\\n        if(root == nullptr) return; // edge case and for the stop of recursion.\\n        solve(root->left); // recursion on left subtree.\\n\\t\\tif(pre){\\n\\t\\t\\tpre->right = root;\\n\\t\\t}else{\\n\\t\\t\\tret = root;\\n\\t\\t}\\n\\t\\troot->left = nullptr;\\n\\t\\tpre = root;\\n        solve(root->right); //recursion on right subtree.\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 280299,
                "title": "iterative-python-solution-faster-than-98-56",
                "content": "\\t\\'\\'\\'\\n\\tclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        new = head = TreeNode(0)\\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            new.right = root\\n            new = new.right\\n            root = root.right\\n            new.left = None\\n        \\n        return head.right\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\t\\'\\'\\'\\n\\tclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        new = head = TreeNode(0)\\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            new.right = root\\n            new = new.right\\n            root = root.right\\n            new.left = None\\n        \\n        return head.right\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1955036,
                "title": "c-easy-fast-single-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* nxt=NULL) {\\n        if(!root) return nxt;\\n        root->right=increasingBST(root->right,nxt);\\n        TreeNode* temp=increasingBST(root->left,root);\\n        root->left=NULL;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* nxt=NULL) {\\n        if(!root) return nxt;\\n        root->right=increasingBST(root->right,nxt);\\n        TreeNode* temp=increasingBST(root->left,root);\\n        root->left=NULL;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955141,
                "title": "python-2-way-9-line-simple-clean-code-with-explanation-beginner-level",
                "content": "**Please upvote me if you think this is helpful :) Much Appreciated!**\\n\\nMethod 1 --- Get the in order list of the tree, and generate the new tree\\n```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n        \\n        def sortBST(node):\\n            if not node:    return []\\n            \\n            # return the in order BST nodes in list\\n            return sortBST(node.left) + [node.val] + sortBST(node.right)\\n            \\n        # the in order sorted list of the tree nodes\\n        sorted_list = sortBST(root)\\n        \\n        # generate new tree: temp for update, ans for return the root\\n        ans = temp = TreeNode(sorted_list[0])\\n        \\n        # insert nodes to the right side of the new tree\\n        for i in range(1, len(sorted_list)):\\n            temp.right = TreeNode(sorted_list[i])\\n            temp = temp.right\\n            \\n        return ans\\n```\\n\\nMethod 2 --- Track the old tree in order and generate the new tree at the same time\\n```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n\\t\\n\\t\\t# generate new tree: self.cur for update, ans for return the root\\n        ans = self.cur = TreeNode()\\n        \\n        def inorder(node):\\n            if node:\\n\\t\\t\\t\\t# track the left side first\\n                inorder(node.left)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update the new tree\\n                self.cur.right = TreeNode(node.val)\\n                self.cur = self.cur.right\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# track the right side then\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        return ans.right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n        \\n        def sortBST(node):\\n            if not node:    return []\\n            \\n            # return the in order BST nodes in list\\n            return sortBST(node.left) + [node.val] + sortBST(node.right)\\n            \\n        # the in order sorted list of the tree nodes\\n        sorted_list = sortBST(root)\\n        \\n        # generate new tree: temp for update, ans for return the root\\n        ans = temp = TreeNode(sorted_list[0])\\n        \\n        # insert nodes to the right side of the new tree\\n        for i in range(1, len(sorted_list)):\\n            temp.right = TreeNode(sorted_list[i])\\n            temp = temp.right\\n            \\n        return ans\\n```\n```\\nclass Solution(object):\\n    \\n    def increasingBST(self, root):\\n\\t\\n\\t\\t# generate new tree: self.cur for update, ans for return the root\\n        ans = self.cur = TreeNode()\\n        \\n        def inorder(node):\\n            if node:\\n\\t\\t\\t\\t# track the left side first\\n                inorder(node.left)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update the new tree\\n                self.cur.right = TreeNode(node.val)\\n                self.cur = self.cur.right\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# track the right side then\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        return ans.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284841,
                "title": "simple-inorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* tree = new TreeNode(0); // make new node and initialize with 0 value\\n    TreeNode *h = tree; // another node pointing to the head of new node\\n    \\n    void inorder(TreeNode* root){\\n         if(root==NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left);\\n        tree->right= new TreeNode(root->val);  // make new node with root value \\n        tree->left=NULL;  \\n        tree=tree->right;  // move ahead in right direction\\n        \\n       inorder(root->right);\\n       \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {       \\n        \\n        inorder(root);\\n        return h->right; // move in right to skip the initial 0 value\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* tree = new TreeNode(0); // make new node and initialize with 0 value\\n    TreeNode *h = tree; // another node pointing to the head of new node\\n    \\n    void inorder(TreeNode* root){\\n         if(root==NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left);\\n        tree->right= new TreeNode(root->val);  // make new node with root value \\n        tree->left=NULL;  \\n        tree=tree->right;  // move ahead in right direction\\n        \\n       inorder(root->right);\\n       \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {       \\n        \\n        inorder(root);\\n        return h->right; // move in right to skip the initial 0 value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097619,
                "title": "simple-and-easy-to-understand-java-0-ms-faster-than-100-00-using-dfs",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n\\n    TreeNode curr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        //create a dummy node\\n        TreeNode first = new TreeNode(-1);\\n        \\n        //assign first\\n        curr = first;\\n        \\n\\t\\t//depth first search\\n        dfs(root);\\n        \\n        return first.right;\\n    }\\n    \\n    private void dfs(TreeNode node){\\n        if(node == null) return;\\n        \\n        //go to left child\\n        dfs(node.left);\\n        \\n        //create a new node, and assign to right\\n        curr.right = new TreeNode(node.val);\\n        \\n        //move the current pointer\\n        curr = curr.right;\\n        \\n        dfs(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    TreeNode curr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        //create a dummy node\\n        TreeNode first = new TreeNode(-1);\\n        \\n        //assign first\\n        curr = first;\\n        \\n\\t\\t//depth first search\\n        dfs(root);\\n        \\n        return first.right;\\n    }\\n    \\n    private void dfs(TreeNode node){\\n        if(node == null) return;\\n        \\n        //go to left child\\n        dfs(node.left);\\n        \\n        //create a new node, and assign to right\\n        curr.right = new TreeNode(node.val);\\n        \\n        //move the current pointer\\n        curr = curr.right;\\n        \\n        dfs(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957287,
                "title": "c-simple-solution-with-visual-explanation",
                "content": "**The idea:**\\nFirst, split any tree intro three parts:\\n1. \\tOriginal left child tree rooted at ```3```\\n2. \\tRoot node ```5```\\n3. \\tOriginal right child tree rooted at ```6```\\n```\\n\\n                5\\n              /   \\\\\\n            3       6\\n          /   \\\\      \\\\\\n         2     4      8\\n        /            / \\\\\\n       1            7   9\\n```\\n\\nSecond, convert the original left and right child trees into increasing order trees. \\n```\\n        1                                 6\\n         \\\\                                 \\\\        \\n          2                                 7 \\n           \\\\          +      5      +        \\\\\\n            3                                 8\\n             \\\\                                 \\\\\\n              4                                 9\\n```\\n\\nFinally, connect these three parts back.\\n```\\n           1      \\n            \\\\     \\n             2    \\n              \\\\   \\n               3  \\n                \\\\ \\n                 4   \\n                  \\\\\\n                   5\\n                    \\\\\\n                     6\\n                      \\\\\\n                       7\\n                        \\\\\\n                         8\\n                          \\\\\\n                           9\\n```\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n\\t\\t// Make both child nodes an increasing order search tree\\n        TreeNode* left = increasingBST(root->left);\\n        TreeNode* right = increasingBST(root->right);\\n        \\n\\t\\t// Disconnect the original left child node and connect to the right increasing order search tree\\n        root->left = nullptr;\\n        root->right = right;\\n        \\n\\t\\t// Left child node returns a nullptr so just return the root\\n        if (!left) {\\n            return root;\\n        }\\n        \\n\\t\\t// Otherwise we search for the rightmost child of the left increasing order search tree\\n        TreeNode* iter = left;\\n        while (iter && iter->right) {\\n            iter = iter->right;\\n        }\\n\\t\\t\\n\\t\\t// Connect to the root node\\n        iter->right = root;\\n        \\n\\t\\t// Now the left root node should be the root of the whole tree\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```3```\n```5```\n```6```\n```\\n\\n                5\\n              /   \\\\\\n            3       6\\n          /   \\\\      \\\\\\n         2     4      8\\n        /            / \\\\\\n       1            7   9\\n```\n```\\n        1                                 6\\n         \\\\                                 \\\\        \\n          2                                 7 \\n           \\\\          +      5      +        \\\\\\n            3                                 8\\n             \\\\                                 \\\\\\n              4                                 9\\n```\n```\\n           1      \\n            \\\\     \\n             2    \\n              \\\\   \\n               3  \\n                \\\\ \\n                 4   \\n                  \\\\\\n                   5\\n                    \\\\\\n                     6\\n                      \\\\\\n                       7\\n                        \\\\\\n                         8\\n                          \\\\\\n                           9\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n\\t\\t// Make both child nodes an increasing order search tree\\n        TreeNode* left = increasingBST(root->left);\\n        TreeNode* right = increasingBST(root->right);\\n        \\n\\t\\t// Disconnect the original left child node and connect to the right increasing order search tree\\n        root->left = nullptr;\\n        root->right = right;\\n        \\n\\t\\t// Left child node returns a nullptr so just return the root\\n        if (!left) {\\n            return root;\\n        }\\n        \\n\\t\\t// Otherwise we search for the rightmost child of the left increasing order search tree\\n        TreeNode* iter = left;\\n        while (iter && iter->right) {\\n            iter = iter->right;\\n        }\\n\\t\\t\\n\\t\\t// Connect to the root node\\n        iter->right = root;\\n        \\n\\t\\t// Now the left root node should be the root of the whole tree\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956051,
                "title": "java-0ms-naive-optimized-simple-inorder-traversal",
                "content": "\\n* **BELOW IS A NAIVE APPROACH**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        inorder(root, al);\\n        return buildTree(al);\\n    }\\n    \\n    private TreeNode buildTree(ArrayList<Integer> al){\\n        if(al.size() == 0) return null;\\n        TreeNode root = new TreeNode(al.remove(0));\\n        root.right = buildTree(al);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root, ArrayList<Integer> al){\\n        if(root == null) return;\\n        inorder(root.left, al);\\n        al.add(root.val);\\n        inorder(root.right, al);\\n    }\\n}\\n```\\n* **OPTIMIZED APPROACH**\\n```\\nclass Solution {\\n    \\n    private TreeNode head = null, parent = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        solve(root);\\n        return head;\\n    }\\n    \\n    private void solve(TreeNode root){\\n        if(root == null) return;\\n        solve(root.left);\\n        if(head == null) head = root;\\n        if(parent == null) parent = root;\\n        else {\\n            parent.right = root;\\n            parent = root;\\n            root.left = null;\\n        }\\n        solve(root.right); \\n    }\\n}\\n```\\n\\n```\\n* Always make helper functions ``` private ```.\\n* Because you shouldn\\'t expose them to the end party. Its an example of abstraction \\uD83D\\uDE00\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        ArrayList<Integer> al = new ArrayList<>();\\n        inorder(root, al);\\n        return buildTree(al);\\n    }\\n    \\n    private TreeNode buildTree(ArrayList<Integer> al){\\n        if(al.size() == 0) return null;\\n        TreeNode root = new TreeNode(al.remove(0));\\n        root.right = buildTree(al);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root, ArrayList<Integer> al){\\n        if(root == null) return;\\n        inorder(root.left, al);\\n        al.add(root.val);\\n        inorder(root.right, al);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private TreeNode head = null, parent = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n        solve(root);\\n        return head;\\n    }\\n    \\n    private void solve(TreeNode root){\\n        if(root == null) return;\\n        solve(root.left);\\n        if(head == null) head = root;\\n        if(parent == null) parent = root;\\n        else {\\n            parent.right = root;\\n            parent = root;\\n            root.left = null;\\n        }\\n        solve(root.right); \\n    }\\n}\\n```\n```\\n* Always make helper functions ```\n```.\\n* Because you shouldn\\'t expose them to the end party. Its an example of abstraction \\uD83D\\uDE00\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958097,
                "title": "c-two-very-simple-solutions",
                "content": "**Using a vector to store nodes in increasing order and then costructing a new tree from it:**\\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* new_head = new TreeNode();\\n        TreeNode* curr = new_head;\\n        inOrder(root);\\n        for (auto a : nodes) {\\n            curr->right = new TreeNode(a);\\n            curr = curr->right;\\n        }\\n        return new_head->right;\\n    }\\n    \\nprivate:\\n    vector<int> nodes;\\n};\\n```\\n**Another solution - without using a vector, just constructing the new tree while traversing original tree:**\\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        curr->right = new TreeNode(root->val);\\n        curr = curr->right;\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        new_head = new TreeNode();\\n        curr = new_head;\\n        inOrder(root);\\n        return new_head->right;\\n    }\\nprivate:\\n    TreeNode* new_head;\\n    TreeNode* curr;\\n};\\n```\\n**Time compexity: O(n), Space complexity: O(n)**\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* new_head = new TreeNode();\\n        TreeNode* curr = new_head;\\n        inOrder(root);\\n        for (auto a : nodes) {\\n            curr->right = new TreeNode(a);\\n            curr = curr->right;\\n        }\\n        return new_head->right;\\n    }\\n    \\nprivate:\\n    vector<int> nodes;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        curr->right = new TreeNode(root->val);\\n        curr = curr->right;\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        new_head = new TreeNode();\\n        curr = new_head;\\n        inOrder(root);\\n        return new_head->right;\\n    }\\nprivate:\\n    TreeNode* new_head;\\n    TreeNode* curr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375371,
                "title": "simple-c-solution",
                "content": "```\\nTreeNode* Solution::increasingBST(TreeNode* root)\\n{\\n    if(root == nullptr)\\n        return nullptr;\\n\\n    if(root->left == nullptr)\\n    {\\n        root->right = increasingBST(root->right);\\n        return root;\\n    }\\n    TreeNode* node = root->left;\\n    root->left = node->right;\\n    node->right = root;\\n    return increasingBST(node);\\n}\\n```\\n\\nRecursively use root->left replace root. when root has no left child, we get the result. Recursively do it to root->right",
                "solutionTags": [],
                "code": "```\\nTreeNode* Solution::increasingBST(TreeNode* root)\\n{\\n    if(root == nullptr)\\n        return nullptr;\\n\\n    if(root->left == nullptr)\\n    {\\n        root->right = increasingBST(root->right);\\n        return root;\\n    }\\n    TreeNode* node = root->left;\\n    root->left = node->right;\\n    node->right = root;\\n    return increasingBST(node);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165888,
                "title": "6-line-python-o-n-solution",
                "content": "```\\n    def increasingBST(self, root, tail=None):\\n        if root is None:\\n            return tail\\n        x = TreeNode(root.val)\\n        x.right = self.increasingBST(root.right, tail)\\n        return self.increasingBST(root.left, x)\\n```",
                "solutionTags": [],
                "code": "```\\n    def increasingBST(self, root, tail=None):\\n        if root is None:\\n            return tail\\n        x = TreeNode(root.val)\\n        x.right = self.increasingBST(root.right, tail)\\n        return self.increasingBST(root.left, x)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 399072,
                "title": "python-concise-simple-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef increasingBST(self, root):\\n\\t\\t\\tdef in_order(node):\\n\\t\\t\\t\\tif not node:\\n\\t\\t\\t\\t\\treturn []\\n\\t\\t\\t\\treturn in_order(node.left) + [node] + in_order(node.right)\\n\\n\\n\\t\\t\\t# get list of nodes in order\\n\\t\\t\\tnodelist = in_order(root)\\n\\n\\t\\t\\t# update node pointers\\n\\t\\t\\tfor i in xrange(len(nodelist)-1):\\n\\t\\t\\t\\tnodelist[i].left = None\\n\\t\\t\\t\\tnodelist[i].right = nodelist[i+1]\\n\\n\\t\\t\\tnodelist[-1].left = None\\n\\t\\t\\tnodelist[-1].right = None\\n\\n\\t\\t\\treturn nodelist[0]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef increasingBST(self, root):\\n\\t\\t\\tdef in_order(node):\\n\\t\\t\\t\\tif not node:\\n\\t\\t\\t\\t\\treturn []\\n\\t\\t\\t\\treturn in_order(node.left) + [node] + in_order(node.right)\\n\\n\\n\\t\\t\\t# get list of nodes in order\\n\\t\\t\\tnodelist = in_order(root)\\n\\n\\t\\t\\t# update node pointers\\n\\t\\t\\tfor i in xrange(len(nodelist)-1):\\n\\t\\t\\t\\tnodelist[i].left = None\\n\\t\\t\\t\\tnodelist[i].right = nodelist[i+1]\\n\\n\\t\\t\\tnodelist[-1].left = None\\n\\t\\t\\tnodelist[-1].right = None\\n\\n\\t\\t\\treturn nodelist[0]",
                "codeTag": "Java"
            },
            {
                "id": 1955921,
                "title": "day-17-daily-leetcode-challenge-problem-java-recursion-100-faster",
                "content": "\\nBy using inorder traversal , we costruct new Tree (for that we already declare two pointer type variables (root , temp) and on each function frame we create new node and point it to right side and update the temp) \\n\\n\\n#### ***JAVA***\\n\\n```\\nclass Solution {\\n    \\n       static TreeNode temp=null;\\n       static TreeNode newroot=null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        temp=null;\\n        \\n        inorder(root);\\n        \\n        return newroot;    \\n      }\\n    \\n    public static void inorder(TreeNode root){\\n        \\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(temp==null){\\n            TreeNode nn=new TreeNode(root.val);\\n            temp=nn;\\n            newroot=nn;\\n        }else{\\n            TreeNode nn1=new TreeNode(root.val);\\n            temp.right=nn1;\\n            temp=nn1;\\n        }\\n        \\n        inorder(root.right);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n       static TreeNode temp=null;\\n       static TreeNode newroot=null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        temp=null;\\n        \\n        inorder(root);\\n        \\n        return newroot;    \\n      }\\n    \\n    public static void inorder(TreeNode root){\\n        \\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(temp==null){\\n            TreeNode nn=new TreeNode(root.val);\\n            temp=nn;\\n            newroot=nn;\\n        }else{\\n            TreeNode nn1=new TreeNode(root.val);\\n            temp.right=nn1;\\n            temp=nn1;\\n        }\\n        \\n        inorder(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958092,
                "title": "0ms-beats-100-easy-explained-with-diagram-dry-run",
                "content": "If you like it, pls **Upvote** :)\\n\\t\\n\\tRun time: 0 ms, faster than 100.00%\\n\\t\\n## Code:\\n\\tNote: In order to understand the code better, follow the steps from 1.a) to 2.e) mentioned in the diagram.\\n\\tclass Solution {\\n\\t\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\t\\treturn increasingBST(root, null);\\n\\t\\t}\\n\\t\\tpublic TreeNode increasingBST(TreeNode node, TreeNode par) {\\n\\t\\t\\tif(node == null) return par;                                    // 1.a)\\n\\t\\t\\tTreeNode newRoot = increasingBST(node.left, node);              // 2.a)\\n\\t\\t\\tnode.left = null;                                               // 2.b)\\n\\t\\t\\tnode.right = increasingBST(node.right, par);                    // 2.c)  +  2.d)  \\n\\t\\t\\treturn newRoot;                                                 // 2.e)\\n\\t\\t}\\n\\t}\\n\\n## Dry Run:\\n![image](https://assets.leetcode.com/users/images/9a13037c-39d1-4475-9adc-114c5871f87a_1650217630.111815.png)\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\t\\treturn increasingBST(root, null);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1618344,
                "title": "easy-solution-100-faster-c-inorder-traversal",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root)\\n    {\\n        vector<int>v;\\n        inorder(root,v);\\n        TreeNode*temp=new TreeNode(v[0]);\\n        TreeNode* r=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\n**Upvote if it helped , Thanks :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root)\\n    {\\n        vector<int>v;\\n        inorder(root,v);\\n        TreeNode*temp=new TreeNode(v[0]);\\n        TreeNode* r=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468619,
                "title": "easy-to-understand-code-in-c-recursion",
                "content": "class Solution {\\npublic:\\n    TreeNode* node= new TreeNode(0);\\n    TreeNode* h=node;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return NULL;\\n        }\\n        \\n        increasingBST(root->left);\\n        node->right=new TreeNode(root->val);\\n        node=node->right;\\n        increasingBST(root->right);\\n        \\n        return h->right;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* node= new TreeNode(0);\\n    TreeNode* h=node;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1957531,
                "title": "c-100-beats-in-runtime",
                "content": "Run an inorder traversal and add each node value to your answer tree. As left will be always `null` so set value only for right. And at last return the root of new tree.\\nNote that I declared a dummy node 0 initially to make the code simple. That\\'s why I returned the the side of root of my answer tree.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *ans) {\\n        if (cur == nullptr) return ans;\\n        TreeNode *now = inorder(cur->left, ans);\\n        now->right = new TreeNode(cur->val);\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *cur = new TreeNode();\\n        inorder(root, cur);\\n        return cur->right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *ans) {\\n        if (cur == nullptr) return ans;\\n        TreeNode *now = inorder(cur->left, ans);\\n        now->right = new TreeNode(cur->val);\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *cur = new TreeNode();\\n        inorder(root, cur);\\n        return cur->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955831,
                "title": "c-simple-inorder-implementation-daily-leetcoding-challenge-april-day-17",
                "content": "**Please upvote if it helps**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* head = new TreeNode();\\n    TreeNode* it=head;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        // go to the extreme left\\n        inorder(root->left);\\n        \\n        // store that extreme left into the right of the new tree\\n        it->right = new TreeNode(root->val);\\n        \\n        // update the itr by itr->right\\n        it=it->right;\\n        \\n        // check the right if there is\\n        inorder(root->right);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        return head->right;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* head = new TreeNode();\\n    TreeNode* it=head;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        \\n        // go to the extreme left\\n        inorder(root->left);\\n        \\n        // store that extreme left into the right of the new tree\\n        it->right = new TreeNode(root->val);\\n        \\n        // update the itr by itr->right\\n        it=it->right;\\n        \\n        // check the right if there is\\n        inorder(root->right);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        return head->right;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954962,
                "title": "c-dfs-inorder-traversal-sentinel-node",
                "content": "Inorder Traversal using a sentinel node\\n\\n**Solved live on stream, everyday at 6pm PT. Link in profile.**\\n\\n```\\nclass Solution {\\n    \\n    void dfs(TreeNode* root, TreeNode*& sentinel) {\\n        if(!root) return;\\n        dfs(root->left, sentinel);\\n        TreeNode* newNode = new TreeNode(root->val);\\n        sentinel->right = newNode;\\n        sentinel = sentinel->right;\\n        dfs(root->right, sentinel);\\n        return;\\n    }\\n\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* sentinel = new TreeNode(0);\\n        TreeNode* ans = sentinel;\\n        dfs(root, sentinel);\\n        return ans->right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void dfs(TreeNode* root, TreeNode*& sentinel) {\\n        if(!root) return;\\n        dfs(root->left, sentinel);\\n        TreeNode* newNode = new TreeNode(root->val);\\n        sentinel->right = newNode;\\n        sentinel = sentinel->right;\\n        dfs(root->right, sentinel);\\n        return;\\n    }\\n\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* sentinel = new TreeNode(0);\\n        TreeNode* ans = sentinel;\\n        dfs(root, sentinel);\\n        return ans->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465015,
                "title": "increasing-order-search-tree-java-recursion-solution",
                "content": "Brute Force Approach:\\nTime Complexity - O(n), Space Complexity - O(n)\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root == null) return null;\\n        List<TreeNode> traversal = new ArrayList<>();\\n        inorder(root, traversal);\\n        reorder(traversal);\\n        return traversal.get(0);\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> traversal){\\n        if(root != null){\\n            inorder(root.left, traversal);\\n            traversal.add(root);\\n            inorder(root.right, traversal);\\n        }\\n    }\\n    \\n    public void reorder(List<TreeNode> traversal){\\n        for(int i=0; i<=traversal.size()-1; i++){\\n            TreeNode current = traversal.get(i);\\n            current.left = null;\\n            if(i<traversal.size()-1){\\n                current.right = traversal.get(i+1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\nOptimised Approach:\\nTime Complexity - O(n), Space Complexity - O(h)\\n```\\nclass Solution {\\n    private TreeNode previous, result;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            \\n            if (result == null) {\\n                result = root;\\n            } else {\\n                previous.right = root;\\n            }\\n            previous = root;\\n            root.left = null;\\n            \\n            inorder(root.right);\\n        }\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root == null) return null;\\n        List<TreeNode> traversal = new ArrayList<>();\\n        inorder(root, traversal);\\n        reorder(traversal);\\n        return traversal.get(0);\\n    }\\n    \\n    public void inorder(TreeNode root, List<TreeNode> traversal){\\n        if(root != null){\\n            inorder(root.left, traversal);\\n            traversal.add(root);\\n            inorder(root.right, traversal);\\n        }\\n    }\\n    \\n    public void reorder(List<TreeNode> traversal){\\n        for(int i=0; i<=traversal.size()-1; i++){\\n            TreeNode current = traversal.get(i);\\n            current.left = null;\\n            if(i<traversal.size()-1){\\n                current.right = traversal.get(i+1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private TreeNode previous, result;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            \\n            if (result == null) {\\n                result = root;\\n            } else {\\n                previous.right = root;\\n            }\\n            previous = root;\\n            root.left = null;\\n            \\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958007,
                "title": "python-simple-algorithm-o-n-space",
                "content": "**Inorder traversal gives the increasing order of the node values**\\n*Simple and easy python3 solution*\\n**\"comment below if you solve it in lesser space complexity and please upvote if you liked the solution\"**\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        #store the inorder references of the nodes in a list\\n        #as inorder traversal gives the increasing order of node values\\n        ans = []\\n        def inorder(node):\\n            if node is None:\\n                return \\n            inorder(node.left)\\n            ans.append(node)\\n            inorder(node.right)\\n        inorder(root)\\n        \\n        for i in range(len(ans) - 1):\\n            ans[i].left = None\\n            ans[i].right = ans[i + 1]\\n        ans[len(ans) - 1].left = None\\n        ans[len(ans) - 1].right = None\\n        return ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        #store the inorder references of the nodes in a list\\n        #as inorder traversal gives the increasing order of node values\\n        ans = []\\n        def inorder(node):\\n            if node is None:\\n                return \\n            inorder(node.left)\\n            ans.append(node)\\n            inorder(node.right)\\n        inorder(root)\\n        \\n        for i in range(len(ans) - 1):\\n            ans[i].left = None\\n            ans[i].right = ans[i + 1]\\n        ans[len(ans) - 1].left = None\\n        ans[len(ans) - 1].right = None\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653847,
                "title": "javascript-2-solutions",
                "content": "**Recursive:**\\n```\\nvar increasingBST = function(root) {\\n    let newRoot = null, newTree = null;\\n    \\n    const helper = (node) => {\\n        if(!node) return;\\n\\t\\t// left\\n        helper(node.left);\\n\\t\\t\\n\\t\\t// read/visit\\n        // while reading/visiting the node update newRoot/newTree\\n        if(!newRoot) {\\n            newRoot = newTree = node;\\n        } else {\\n            newTree.right = node;\\n            newTree = newTree.right;\\n            // set left to null to avoid duplication & to create skewed tree\\n            node.left = null;\\n        }\\n\\t\\t\\n\\t\\t// right\\n        helper(node.right);\\n    }\\n    \\n    helper(root);\\n    return newRoot;\\n};\\n```\\n**Iterative:**\\n```\\nvar increasingBST = function(root) {\\n    if(!root) return null;\\n    let stack = [], newRoot = null, newTree = null;\\n    \\n    while(root){\\n        // left\\n        while(root){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(stack.length > 0){\\n            // read/visit\\n            let node = stack.pop();\\n            if(!newRoot){\\n                newRoot = newTree = node;\\n            } else {\\n                newTree.right = node;\\n                newTree = newTree.right;\\n            }\\n            node.left = null;\\n            // right\\n            if(node.right){\\n                root = node.right;\\n                break;\\n            }\\n        }\\n    }\\n    return newRoot;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n    let newRoot = null, newTree = null;\\n    \\n    const helper = (node) => {\\n        if(!node) return;\\n\\t\\t// left\\n        helper(node.left);\\n\\t\\t\\n\\t\\t// read/visit\\n        // while reading/visiting the node update newRoot/newTree\\n        if(!newRoot) {\\n            newRoot = newTree = node;\\n        } else {\\n            newTree.right = node;\\n            newTree = newTree.right;\\n            // set left to null to avoid duplication & to create skewed tree\\n            node.left = null;\\n        }\\n\\t\\t\\n\\t\\t// right\\n        helper(node.right);\\n    }\\n    \\n    helper(root);\\n    return newRoot;\\n};\\n```\n```\\nvar increasingBST = function(root) {\\n    if(!root) return null;\\n    let stack = [], newRoot = null, newTree = null;\\n    \\n    while(root){\\n        // left\\n        while(root){\\n            stack.push(root);\\n            root = root.left;\\n        }\\n        while(stack.length > 0){\\n            // read/visit\\n            let node = stack.pop();\\n            if(!newRoot){\\n                newRoot = newTree = node;\\n            } else {\\n                newTree.right = node;\\n                newTree = newTree.right;\\n            }\\n            node.left = null;\\n            // right\\n            if(node.right){\\n                root = node.right;\\n                break;\\n            }\\n        }\\n    }\\n    return newRoot;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1733175,
                "title": "c-easiest-sol-using-inorder-traversal",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* increasingBST(TreeNode* root) {\\n\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tinorderTraversal(root, ans);\\n\\n\\t\\t\\tTreeNode* dummy = new TreeNode(-1);\\n\\t\\t\\tTreeNode* newroot = dummy;\\n\\n\\t\\t\\tfor(auto i : ans)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdummy->right = new TreeNode(i); //create a new node\\n\\t\\t\\t\\tdummy = dummy->right;           //setting the new node to right\\n\\t\\t\\t}\\n\\t\\t\\treturn newroot->right;\\n\\t\\t}\\n\\n\\t\\tvoid inorderTraversal(TreeNode* root, vector<int>&ans)\\n\\t\\t{\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tinorderTraversal(root->left, ans);\\n\\t\\t\\tans.push_back(root->val);\\n\\t\\t\\tinorderTraversal(root->right, ans);\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* increasingBST(TreeNode* root) {\\n\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tinorderTraversal(root, ans);\\n\\n\\t\\t\\tTreeNode* dummy = new TreeNode(-1);\\n\\t\\t\\tTreeNode* newroot = dummy;\\n\\n\\t\\t\\tfor(auto i : ans)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdummy->right = new TreeNode(i); //create a new node\\n\\t\\t\\t\\tdummy = dummy->right;           //setting the new node to right\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1723817,
                "title": "100-faster-inorder-traversal-recursion-solution",
                "content": "```\\nclass Solution {\\n    TreeNode res = null;\\n    TreeNode head = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n       if(root==null)\\n           return null;\\n        increasingBST(root.left);\\n        if(res==null){\\n            res = new TreeNode(root.val);\\n            head = res;\\n        }\\n        else{\\n         res.right = new TreeNode(root.val);\\n            res = res.right;\\n        }\\n        increasingBST(root.right);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode res = null;\\n    TreeNode head = null;\\n    public TreeNode increasingBST(TreeNode root) {\\n       if(root==null)\\n           return null;\\n        increasingBST(root.left);\\n        if(res==null){\\n            res = new TreeNode(root.val);\\n            head = res;\\n        }\\n        else{\\n         res.right = new TreeNode(root.val);\\n            res = res.right;\\n        }\\n        increasingBST(root.right);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958021,
                "title": "python-in-order-traversal",
                "content": "In-order traversal of a binary-search tree lists values in increasing order. Suppose that we construct a new tree with the dummy node `head`. While we do an in-order traversal starting from `root`, we add each value to the right of `head`. Since `head` is dummy, return `head.right`.\\n\\n```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            new_node[0].right = TreeNode(node.val)\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```\\n\\nThe version above builds a new tree. If we want to avoid that we need to reuse the existing nodes. Which requires the changing the two lines with comment.\\n\\n```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            node.left = None #clear left\\n            new_node[0].right = node #reuse node\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            new_node[0].right = TreeNode(node.val)\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```\n```python\\nclass Solution:\\n    def increasingBST(self, root):\\n        def recur(node):\\n            if not node: return\\n            recur(node.left)\\n            node.left = None #clear left\\n            new_node[0].right = node #reuse node\\n            new_node[0] = new_node[0].right\\n            recur(node.right)\\n            \\n        head = TreeNode(0)\\n        new_node = [head]\\n        recur(root)\\n        return head.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394874,
                "title": "javascript-simple-inorder-dfs",
                "content": "```\\nvar increasingBST = function(root) {\\n    let dummy = new TreeNode(); \\n    let node = dummy;\\n\\t\\n    const traverse = function(root) {\\n        if(!root) return; \\n        traverse(root.left); \\n        node.right = root; \\n        node = node.right; \\n        node.left = null;\\n        traverse(root.right);    \\n    }; \\n\\t\\n    traverse(root);\\n    return dummy.right;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar increasingBST = function(root) {\\n    let dummy = new TreeNode(); \\n    let node = dummy;\\n\\t\\n    const traverse = function(root) {\\n        if(!root) return; \\n        traverse(root.left); \\n        node.right = root; \\n        node = node.right; \\n        node.left = null;\\n        traverse(root.right);    \\n    }; \\n\\t\\n    traverse(root);\\n    return dummy.right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955865,
                "title": "faadu-100-faster-solution-0ms-cpp",
                "content": "```\\nvoid inorder(TreeNode* root,vector<int>&v){\\n\\t\\tif(!root)return;\\n        \\n        if(root->left){\\n            inorder(root->left,v);\\n        }\\n        if(root){\\n          v.push_back(root->val);\\n        }\\n        if(root->right){\\n            inorder(root->right,v);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)return NULL;\\n        vector<int>v;\\n        inorder(root,v);\\n            \\n        TreeNode * head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid inorder(TreeNode* root,vector<int>&v){\\n\\t\\tif(!root)return;\\n        \\n        if(root->left){\\n            inorder(root->left,v);\\n        }\\n        if(root){\\n          v.push_back(root->val);\\n        }\\n        if(root->right){\\n            inorder(root->right,v);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)return NULL;\\n        vector<int>v;\\n        inorder(root,v);\\n            \\n        TreeNode * head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849038,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n\\treturn dfs(root, nil)\\n}\\n\\nfunc dfs(root, tail *TreeNode) *TreeNode {\\n\\tif root == nil {\\n\\t\\treturn tail\\n\\t}\\n\\t\\n\\tres := dfs(root.Left, root)\\n\\troot.Left = nil\\n\\troot.Right = dfs(root.Right, tail)\\n\\t\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n\\treturn dfs(root, nil)\\n}\\n\\nfunc dfs(root, tail *TreeNode) *TreeNode {\\n\\tif root == nil {\\n\\t\\treturn tail\\n\\t}\\n\\t\\n\\tres := dfs(root.Left, root)\\n\\troot.Left = nil\\n\\troot.Right = dfs(root.Right, tail)\\n\\t\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724571,
                "title": "3-lines-only-0ms-100-faster-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = nullptr;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = nullptr;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354963,
                "title": "reverse-inorder-traversal-o-n-100ms-c-easy-to-understand",
                "content": "## Approach:\\n        \\n* We traverse the tree in reverse inorder and attach the previous nodes to the right of our our current node.\\n\\n* We keep the left in a temporary variable because it gets lost due to removal of left side of the tree.\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode *prevNode = NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        if(!root) return NULL;\\n        \\n        root->right = increasingBST(root->right);\\n        \\n        if(prevNode)\\n            root->right = prevNode;\\n        \\n        TreeNode *temp = root->left;\\n\\n        root->left = NULL;\\n        \\n        prevNode = root;\\n        \\n        increasingBST(temp);\\n        \\n        \\n        return prevNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    TreeNode *prevNode = NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        if(!root) return NULL;\\n        \\n        root->right = increasingBST(root->right);\\n        \\n        if(prevNode)\\n            root->right = prevNode;\\n        \\n        TreeNode *temp = root->left;\\n\\n        root->left = NULL;\\n        \\n        prevNode = root;\\n        \\n        increasingBST(temp);\\n        \\n        \\n        return prevNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1106048,
                "title": "c-inorder-traversal-simple-and-faster-than-100-submission",
                "content": "```\\nTreeNode* curr=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root==NULL){return NULL;}\\n        TreeNode* res = new TreeNode(0);\\n        curr = res;\\n        inorder(root);\\n        return res->right;\\n        \\n    }\\n    void inorder(TreeNode*root){\\n        \\n        if(root==NULL){return;}\\n        \\n        inorder(root->left);\\n        \\n        root->left = NULL;\\n        curr->right = root;\\n        curr = root;\\n        \\n        inorder(root->right);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nTreeNode* curr=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root==NULL){return NULL;}\\n        TreeNode* res = new TreeNode(0);\\n        curr = res;\\n        inorder(root);\\n        return res->right;\\n        \\n    }\\n    void inorder(TreeNode*root){\\n        \\n        if(root==NULL){return;}\\n        \\n        inorder(root->left);\\n        \\n        root->left = NULL;\\n        curr->right = root;\\n        curr = root;\\n        \\n        inorder(root->right);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959460,
                "title": "python-clear-easy-to-understand-solution",
                "content": "\\tdef inorderTraversal(root: TreeNode) -> List[int]: \\n\\t\\treturn [] if root is None else inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n\\t\\t\\t\\n\\tdef buildTree(lst: list) -> TreeNode:\\n\\t\\thead = TreeNode(lst[0])\\n\\t\\tptr = head\\n\\t\\tfor val in lst[1:]:\\n\\t\\t\\tptr.right = TreeNode(val)\\n\\t\\t\\tptr = ptr.right\\n\\t\\t\\t\\t\\n\\t\\treturn head\\n\\t\\n\\tclass Solution:\\n\\t\\tdef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\treturn buildTree(inorderTraversal(root))\\n\\nlike it? please upvote!...",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tdef inorderTraversal(root: TreeNode) -> List[int]: \\n\\t\\treturn [] if root is None else inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n\\t\\t\\t\\n\\tdef buildTree(lst: list) -> TreeNode:\\n\\t\\thead = TreeNode(lst[0])\\n\\t\\tptr = head\\n\\t\\tfor val in lst[1:]:\\n\\t\\t\\tptr.right = TreeNode(val)\\n\\t\\t\\tptr = ptr.right\\n\\t\\t\\t\\t\\n\\t\\treturn head\\n\\t\\n\\tclass Solution:\\n\\t\\tdef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\treturn buildTree(inorderTraversal(root))\\n\\nlike it? please upvote!...",
                "codeTag": "Java"
            },
            {
                "id": 958482,
                "title": "iterative-and-recursive-javascript-typescript",
                "content": "Iterative Solution: \\n```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    if (!root) {\\n        return null\\n    }\\n\\n    let stack: TreeNode[] = []\\n    let curr: TreeNode | null = root\\n\\n    const dummyHead = new TreeNode()\\n    let holdingPointer = dummyHead\\n    \\n\\n    while (stack.length || curr) {\\n        if (curr) {\\n            stack.push(curr)\\n            curr = curr.left\\n        } else {\\n            let temp = stack.pop()\\n            if (temp) {\\n                holdingPointer.right = new TreeNode(temp.val)\\n                holdingPointer = holdingPointer.right\\n                curr = temp.right\\n            }\\n            \\n        }\\n    }\\n    return dummyHead.right\\n};\\n```\\nRecursive Solution: \\n```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    const dummyHead = new TreeNode()\\n    let temp = dummyHead\\n    function inOrder(root:TreeNode | null) {\\n        if (!root) return\\n\\n        if (root.left) {\\n            inOrder(root.left)\\n        }\\n\\n        temp.right = new TreeNode(root.val)\\n        temp = temp.right\\n\\n        if (root.right) {\\n            inOrder(root.right)\\n        }\\n    }\\n\\n    inOrder(root)\\n\\n    return dummyHead.right\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    if (!root) {\\n        return null\\n    }\\n\\n    let stack: TreeNode[] = []\\n    let curr: TreeNode | null = root\\n\\n    const dummyHead = new TreeNode()\\n    let holdingPointer = dummyHead\\n    \\n\\n    while (stack.length || curr) {\\n        if (curr) {\\n            stack.push(curr)\\n            curr = curr.left\\n        } else {\\n            let temp = stack.pop()\\n            if (temp) {\\n                holdingPointer.right = new TreeNode(temp.val)\\n                holdingPointer = holdingPointer.right\\n                curr = temp.right\\n            }\\n            \\n        }\\n    }\\n    return dummyHead.right\\n};\\n```\n```\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n    const dummyHead = new TreeNode()\\n    let temp = dummyHead\\n    function inOrder(root:TreeNode | null) {\\n        if (!root) return\\n\\n        if (root.left) {\\n            inOrder(root.left)\\n        }\\n\\n        temp.right = new TreeNode(root.val)\\n        temp = temp.right\\n\\n        if (root.right) {\\n            inOrder(root.right)\\n        }\\n    }\\n\\n    inOrder(root)\\n\\n    return dummyHead.right\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 958288,
                "title": "java-100-no-recursion-commented-code",
                "content": "Recursive approach with class-level variable to keep previous node is fairly simple. I decided to do it without recursion to refresh on how in-order traversal is done iteratively using stack + extra pointer. Overall, this exercise has good take-aways:\\n* Pre-head pointer technique used in many problems, esp. linked list related\\n* Iterative in-order traversal mixed with custom logic\\n* Corner case analysis (easy to miss out to clear left child of the last node)\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode preRoot = new TreeNode();\\n        TreeNode prev = preRoot;\\n        \\n        TreeNode curr = root;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        // classic stack+current approach for non-recursive in-order traversal\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            curr = stack.pop();\\n            \\n            // link previous node with current one (and detach it from left branch)\\n            prev.right = curr;\\n            prev.left = null;\\n            \\n            // current node becomes previous\\n            prev = curr;\\n            \\n            // this is transition within in-order traversal\\n            // (next iteration will use either stack of switch over to curr if it\\'s not null)\\n            curr = curr.right;\\n        }\\n        // this is tricky corner case:\\n        prev.left = null;\\n        \\n        // prev.right is already null since it\\'s the last node within in-order traversal\\n\\n        return preRoot.right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode preRoot = new TreeNode();\\n        TreeNode prev = preRoot;\\n        \\n        TreeNode curr = root;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        \\n        // classic stack+current approach for non-recursive in-order traversal\\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            curr = stack.pop();\\n            \\n            // link previous node with current one (and detach it from left branch)\\n            prev.right = curr;\\n            prev.left = null;\\n            \\n            // current node becomes previous\\n            prev = curr;\\n            \\n            // this is transition within in-order traversal\\n            // (next iteration will use either stack of switch over to curr if it\\'s not null)\\n            curr = curr.right;\\n        }\\n        // this is tricky corner case:\\n        prev.left = null;\\n        \\n        // prev.right is already null since it\\'s the last node within in-order traversal\\n\\n        return preRoot.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352997,
                "title": "compilation-of-different-solutions",
                "content": "**Recursive Traversal** with Global variables\\n```\\npublic:\\n    TreeNode* newroot, *curr;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }   \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n```\\n\\n**Recursive traversal** without Global variables\\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n\\t\\t\\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;   \\n            in_order(root->right, cur);\\n        }\\n```\\n**Iterative Traversal** with stack\\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }   \\n            curr=curr->right;\\n        }   \\n        return newroot;\\n    }\\n```\\n\\n**Iterative Traversal** without stack(**Morrys Method**)\\n```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode dummy(0);\\n        TreeNode* cur = root, *prev = &dummy;\\n        while(cur) {\\n            if(!cur->left) {\\n                prev->right = cur;\\n                prev = cur;\\n                cur = cur->right;\\n            }else {\\n                TreeNode* pred = cur->left;\\n                while(pred->right && pred->right!= cur) pred = pred->right;\\n                if(!pred->right) {\\n                    pred->right = cur;\\n                    cur = cur->left;\\n                }else {\\n                    cur->left = nullptr;\\n                    prev->right = cur;\\n                    prev = cur;\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return dummy.right;\\n    }\\n```\\n**Recursive way** without Global variables and helper function\\n```\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```\\n\\nHappy Coding :)",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic:\\n    TreeNode* newroot, *curr;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        increasingBST(root->left);\\n        if (newroot == NULL) { \\n            newroot = new TreeNode(root->val);\\n            curr = newroot;\\n        }\\n        else {\\n            curr->right = new TreeNode(root->val);\\n            curr=curr->right;\\n        }   \\n        increasingBST(root->right);\\n        return newroot;\\n    }\\n```\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n\\t\\t\\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;   \\n            in_order(root->right, cur);\\n        }\\n```\n```\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) return NULL;\\n        TreeNode* newroot=NULL, *newcurr;\\n        stack<TreeNode*> stck;\\n        TreeNode* curr=root;\\n        while (curr || !stck.empty()) {\\n            while (curr) {\\n                stck.push(curr);\\n                curr=curr->left;\\n            }\\n            \\n            curr=stck.top();\\n            stck.pop();\\n            if (newroot == NULL) {\\n                newroot = new TreeNode(curr->val);\\n                newcurr = newroot;\\n            }\\n            else {\\n                newcurr->right = new TreeNode(curr->val);\\n                newcurr = newcurr->right;\\n            }   \\n            curr=curr->right;\\n        }   \\n        return newroot;\\n    }\\n```\n```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode dummy(0);\\n        TreeNode* cur = root, *prev = &dummy;\\n        while(cur) {\\n            if(!cur->left) {\\n                prev->right = cur;\\n                prev = cur;\\n                cur = cur->right;\\n            }else {\\n                TreeNode* pred = cur->left;\\n                while(pred->right && pred->right!= cur) pred = pred->right;\\n                if(!pred->right) {\\n                    pred->right = cur;\\n                    cur = cur->left;\\n                }else {\\n                    cur->left = nullptr;\\n                    prev->right = cur;\\n                    prev = cur;\\n                    cur = cur->right;\\n                }\\n            }\\n        }\\n        return dummy.right;\\n    }\\n```\n```\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail = NULL) {\\n        if (!root) return tail;\\n        TreeNode* res = increasingBST(root->left, root);\\n        root->left = NULL;\\n        root->right = increasingBST(root->right, tail);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331974,
                "title": "javascript-clean-recursive-solution",
                "content": "```\\nvar increasingBST = function(root) {\\n  if (!root) {\\n    return root;\\n  }\\n  \\n  const leftRoot = increasingBST(root.left);\\n  root.left = null;\\n  root.right = increasingBST(root.right);\\n  \\n  if (!leftRoot) {\\n    return root;\\n  }\\n  \\n  let lastLeftNode = leftRoot;\\n  while (lastLeftNode.right) {\\n    lastLeftNode = lastLeftNode.right;\\n  }\\n  \\n  lastLeftNode.right = root;\\n  return leftRoot;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n  if (!root) {\\n    return root;\\n  }\\n  \\n  const leftRoot = increasingBST(root.left);\\n  root.left = null;\\n  root.right = increasingBST(root.right);\\n  \\n  if (!leftRoot) {\\n    return root;\\n  }\\n  \\n  let lastLeftNode = leftRoot;\\n  while (lastLeftNode.right) {\\n    lastLeftNode = lastLeftNode.right;\\n  }\\n  \\n  lastLeftNode.right = root;\\n  return leftRoot;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169107,
                "title": "c-easy-solution-using-in-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        \\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n        \\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        delete tmp;\\n            \\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            \\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;\\n            \\n            in_order(root->right, cur);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        \\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* cur = tmp;\\n        \\n        in_order(root, cur);\\n        \\n        cur = tmp->right;\\n        delete tmp;\\n            \\n        return cur;\\n    }\\n    \\n    void in_order(TreeNode* root, TreeNode* &cur) {\\n        if (root) {\\n            in_order(root->left, cur);\\n            \\n            cur->right = root;\\n            root->left = NULL;\\n            cur = cur->right;\\n            \\n            in_order(root->right, cur);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511732,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n    if (root == nullptr)\\n      return tail;\\n    TreeNode* ans = increasingBST(root->left, root);\\n    root->left = nullptr;\\n    root->right = increasingBST(root->right, tail);\\n    return ans;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def dfsInorder(self, root):\\n        if root is None: return\\n        self.dfsInorder(root.left)\\n        self.represented.append(root.val)\\n        self.dfsInorder(root.right)\\n\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        self.represented = []\\n        self.dfsInorder(root)\\n\\n        pointer = answer = TreeNode(self.represented[0])\\n        for node in self.represented[1:]:\\n            pointer.right = TreeNode(node)\\n            pointer = pointer.right\\n\\n        return answer\\n```\\n\\n```Java []\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  TreeNode* increasingBST(TreeNode* root, TreeNode* tail = nullptr) {\\n    if (root == nullptr)\\n      return tail;\\n    TreeNode* ans = increasingBST(root->left, root);\\n    root->left = nullptr;\\n    root->right = increasingBST(root->right, tail);\\n    return ans;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def dfsInorder(self, root):\\n        if root is None: return\\n        self.dfsInorder(root.left)\\n        self.represented.append(root.val)\\n        self.dfsInorder(root.right)\\n\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        self.represented = []\\n        self.dfsInorder(root)\\n\\n        pointer = answer = TreeNode(self.represented[0])\\n        for node in self.represented[1:]:\\n            pointer.right = TreeNode(node)\\n            pointer = pointer.right\\n\\n        return answer\\n```\n```Java []\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440812,
                "title": "89-tc-and-76-sc-easy-python-solution",
                "content": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\tarr = []\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn \\n\\t\\tdfs(node.left)\\n\\t\\tarr.append(node.val)\\n\\t\\tdfs(node.right)\\n\\n\\tdfs(root)\\n\\troot = curr = TreeNode(arr[0])\\n\\tfor i in arr[1:]:\\n\\t\\tcurr.right = TreeNode(i)\\n\\t\\tcurr = curr.right\\n\\treturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n\\tarr = []\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn \\n\\t\\tdfs(node.left)\\n\\t\\tarr.append(node.val)\\n\\t\\tdfs(node.right)\\n\\n\\tdfs(root)\\n\\troot = curr = TreeNode(arr[0])\\n\\tfor i in arr[1:]:\\n\\t\\tcurr.right = TreeNode(i)\\n\\t\\tcurr = curr.right\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2269176,
                "title": "includes-explanation-95-efficient-easy-understanding",
                "content": "# Upvote, it matters \\n**Explanation:**\\n* To find solve out the respective task as given in the question,\\n* Find out the inOrder Traversal of the tree.\\n* Re-draw the entire tree such that left part of each node takes **None**\\n\\n\\n```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \\n        res = self.inOrder(root)        \\n        newTree = TreeNode(res[0])\\n        temp = newTree\\n        for i in range(1,len(res)):\\n            newNode = TreeNode(res[i])\\n            temp.right = newNode\\n            temp = temp.right\\n        return newTree\\n        \\n    def inOrder(self,root):\\n        if(root == None):\\n            return []\\n        return self.inOrder(root.left)+[root.val]+self.inOrder(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \\n        res = self.inOrder(root)        \\n        newTree = TreeNode(res[0])\\n        temp = newTree\\n        for i in range(1,len(res)):\\n            newNode = TreeNode(res[i])\\n            temp.right = newNode\\n            temp = temp.right\\n        return newTree\\n        \\n    def inOrder(self,root):\\n        if(root == None):\\n            return []\\n        return self.inOrder(root.left)+[root.val]+self.inOrder(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957606,
                "title": "c-o-1-space-rotations-in-a-tree-dsw-algorithm",
                "content": "The question may be easy, but it has an elegant constant space solution. I\\'m really impressed that nobody wrote about it. \\n\\nIf you\\'d heard of the [DSW algorithm](https://en.wikipedia.org/wiki/Day\\u2013Stout\\u2013Warren_algorithm) for balancing a BST, you could recognize that the problem asks for the first step of the algorithm, which creates a \"vine\" from the tree.\\n\\nThe idea is simple if you know about [rotations in a tree](https://en.wikipedia.org/wiki/Tree_rotation), as we can apply \"right rotations\" until we no longer have left children in our tree.\\n\\nWhat are those \"right rotations\", and why do they work for this problem?\\nRight rotations are used to make a left child of a node the parent of that node. These rotations work really well when working with BSTs, as a left child always has a value less than the node\\'s value, so if we make our node as a right child for the left child, the BST property remains (see the image below where we rotate the E node to the right):\\n\\n![image](https://assets.leetcode.com/users/images/ed7b4770-3b66-4289-8070-89d58f9f583f_1650206049.1359787.png)\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        TreeNode *prev = NULL, *node = root;\\n        \\n        while(node != NULL) {\\n            \\n            if(node->left == NULL) {\\n                prev = node;\\n                node = node->right;\\n                continue;\\n            }\\n            \\n            TreeNode *child = node->left;\\n            TreeNode *left = child->right;\\n            \\n            child->right = node;\\n            node->left = left;\\n            \\n            if(prev == NULL)\\n                root = child;\\n            else\\n                prev->right = child;\\n            \\n            node = child;\\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        TreeNode *prev = NULL, *node = root;\\n        \\n        while(node != NULL) {\\n            \\n            if(node->left == NULL) {\\n                prev = node;\\n                node = node->right;\\n                continue;\\n            }\\n            \\n            TreeNode *child = node->left;\\n            TreeNode *left = child->right;\\n            \\n            child->right = node;\\n            node->left = left;\\n            \\n            if(prev == NULL)\\n                root = child;\\n            else\\n                prev->right = child;\\n            \\n            node = child;\\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957363,
                "title": "kotlin-recursive-tree-walk-reuse-nodes",
                "content": "Starting from the largest element, reconnect the nodes as requested.\\n```\\nclass Solution {\\n    fun increasingBST(root: TreeNode?): TreeNode? {\\n        var p: TreeNode? = null\\n        \\n        fun walk(node: TreeNode?) {\\n            node?.run {\\n                walk(right)\\n                right = p\\n                p = this\\n                walk(left)\\n                left = null\\n            }\\n        }\\n        \\n        walk(root)\\n        return p       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun increasingBST(root: TreeNode?): TreeNode? {\\n        var p: TreeNode? = null\\n        \\n        fun walk(node: TreeNode?) {\\n            node?.run {\\n                walk(right)\\n                right = p\\n                p = this\\n                walk(left)\\n                left = null\\n            }\\n        }\\n        \\n        walk(root)\\n        return p       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956214,
                "title": "c-2-solutions-with-w-o-creating-new-tree-inorder-w-o-vector",
                "content": "**1. By creating a new tree**\\nTime - O(n)\\nSpace - O(n) (new tree)\\n```\\n    TreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        r2->right=new TreeNode(root->val);\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```\\n\\n**2. Witout creating a new tree / rearranging the given tree**\\nTime - O(n)\\nSpace - O(h) (recursion stack)\\n\\n**Note :** Don\\'t forget to set left of root node as NULL after visiting left subtree . I got error due to this & was stuck for about 10 minutes \\uD83D\\uDE29 .\\n\\n```\\n\\tTreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        root->left=NULL;\\n        r2->right=root;\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    TreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        r2->right=new TreeNode(root->val);\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```\n```\\n\\tTreeNode* r2;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        \\n        root->left=NULL;\\n        r2->right=root;\\n        r2=r2->right;\\n        \\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        r2=new TreeNode();\\n        TreeNode* r3=r2;\\n        \\n        inorder(root);\\n        \\n        return r3->right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955004,
                "title": "python-3-iterative-in-order-traversal-explanation",
                "content": "### Explanation\\n- Perform an in-order traversal\\n- Let the right child of the previous/smaller node be the current node\\n- Remove the left child to avoid cycle\\n- Return the smallest node\\n### Implementation\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        node = root\\n        stack = []\\n        prev = None\\n        lowest = None\\n        while stack or node:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:    \\n                node = stack.pop()\\n                if not lowest:\\n                    lowest = node\\n                node.left = None\\n                if prev:\\n                    prev.right = node\\n                prev = node\\n                node = node.right\\n        return lowest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        node = root\\n        stack = []\\n        prev = None\\n        lowest = None\\n        while stack or node:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:    \\n                node = stack.pop()\\n                if not lowest:\\n                    lowest = node\\n                node.left = None\\n                if prev:\\n                    prev.right = node\\n                prev = node\\n                node = node.right\\n        return lowest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488013,
                "title": "c-easy-to-understand-fast-2-methods-with-and-without-using-extra-space",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Time complexity O(N)\\nSpace complexity O(N)**\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     for(int i=0;i<v.size()-1;i++)\\n     {\\n         v[i]->right=v[i+1];\\n         v[i]->left=NULL;\\n     }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```\\n**Time complexity O(N)\\nspace complexity O(1)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* curr;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left);\\n        root->left=NULL;\\n        curr->right=root;\\n        curr=root;\\n        if(root->right)\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n    if(root==NULL)\\n    return NULL;\\n     TreeNode* dummy=new TreeNode(0);\\n     curr=dummy;\\n     inorder(root);\\n     return dummy->right;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     for(int i=0;i<v.size()-1;i++)\\n     {\\n         v[i]->right=v[i+1];\\n         v[i]->left=NULL;\\n     }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* curr;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left);\\n        root->left=NULL;\\n        curr->right=root;\\n        curr=root;\\n        if(root->right)\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n    if(root==NULL)\\n    return NULL;\\n     TreeNode* dummy=new TreeNode(0);\\n     curr=dummy;\\n     inorder(root);\\n     return dummy->right;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223949,
                "title": "c-increasing-order-search-tree-inorder-traversal-explanation",
                "content": "First we do an inorder traversal and store it in a vector. Due to inorder traversal, the elements of the tree are sorted in ascending inside the vector.\\nNext function then is used to create a  new node recursively so as to create a tree where the leftmost node is the root node and all the node have no left-child.\\nElements for the new tree are obtained from the vector\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* build(vector<int>&vec,int start)\\n    {\\n        if(start>vec.size()-1)\\n            return NULL;\\n        TreeNode* newNode=new TreeNode(vec[start]);//new node is created with the value from the vector\\n        start++;\\n        newNode->left=NULL;//left part of the node points to null\\n        newNode->right=build(vec,start);//right part of the node points to the new node which is created by calling the function again\\n        return newNode;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n            return NULL;\\n        vector<int>vec;\\n        inorder(root,vec);\\n        return build(vec,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* build(vector<int>&vec,int start)\\n    {\\n        if(start>vec.size()-1)\\n            return NULL;\\n        TreeNode* newNode=new TreeNode(vec[start]);//new node is created with the value from the vector\\n        start++;\\n        newNode->left=NULL;//left part of the node points to null\\n        newNode->right=build(vec,start);//right part of the node points to the new node which is created by calling the function again\\n        return newNode;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n            return NULL;\\n        vector<int>vec;\\n        inorder(root,vec);\\n        return build(vec,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204963,
                "title": "easy-java-solution-faster-than-100",
                "content": "The approach can be divided into 2 parts :\\n1. Obtain the InOrder traversal of the given tree.\\n2. Convert the InOrder list to a Tree\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<Integer> inorderList = inorder(root);\\n        return getBST(inorderList);\\n    }\\n    public TreeNode getBST(List<Integer> mlist)\\n    {\\n        TreeNode temp = new TreeNode(0);\\n        TreeNode ans= temp;\\n        for(int i=0;i<mlist.size();i++)\\n        {\\n          TreeNode node = new TreeNode(mlist.get(i));\\n          ans.right = node;\\n          ans = ans.right;  \\n        }\\n        return temp.right;\\n     \\n    }\\n    public List<Integer> inorder(TreeNode root)\\n    {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root == null)\\n            return ans;\\n        \\n      List<Integer> left = inorder(root.left);\\n      List<Integer> right = inorder(root.right);\\n      ans.addAll(left);\\n      ans.add(root.val);\\n      ans.addAll(right);\\n        \\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<Integer> inorderList = inorder(root);\\n        return getBST(inorderList);\\n    }\\n    public TreeNode getBST(List<Integer> mlist)\\n    {\\n        TreeNode temp = new TreeNode(0);\\n        TreeNode ans= temp;\\n        for(int i=0;i<mlist.size();i++)\\n        {\\n          TreeNode node = new TreeNode(mlist.get(i));\\n          ans.right = node;\\n          ans = ans.right;  \\n        }\\n        return temp.right;\\n     \\n    }\\n    public List<Integer> inorder(TreeNode root)\\n    {\\n        List<Integer> ans = new ArrayList<>();\\n        if(root == null)\\n            return ans;\\n        \\n      List<Integer> left = inorder(root.left);\\n      List<Integer> right = inorder(root.right);\\n      ans.addAll(left);\\n      ans.add(root.val);\\n      ans.addAll(right);\\n        \\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958798,
                "title": "javascript-solution",
                "content": "```\\nvar increasingBST = function(root) {\\n    let arr = []\\n    const getTree = (root) => {\\n        if(!root) return\\n        if (root.left) getTree(root.left)\\n        arr.push(root.val)\\n        if (root.right) getTree(root.right)\\n        \\n    }\\n\\t\\n    getTree(root)\\n\\t\\n    const buildTree = (arr) => {\\n        if (arr.length === 0) return null\\n        let tree = new TreeNode()\\n        tree.val = arr.shift()\\n        tree.right = buildTree(arr)\\n        return tree\\n    }\\n    \\n    return buildTree(arr)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n    let arr = []\\n    const getTree = (root) => {\\n        if(!root) return\\n        if (root.left) getTree(root.left)\\n        arr.push(root.val)\\n        if (root.right) getTree(root.right)\\n        \\n    }\\n\\t\\n    getTree(root)\\n\\t\\n    const buildTree = (arr) => {\\n        if (arr.length === 0) return null\\n        let tree = new TreeNode()\\n        tree.val = arr.shift()\\n        tree.right = buildTree(arr)\\n        return tree\\n    }\\n    \\n    return buildTree(arr)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 958357,
                "title": "c-in-order-traverse",
                "content": "```\\n/*\\nIdea[1]: in-order output the whole tree.\\nStraight forward traverse the tree: result = inorder(root.left) + root + inorder(root.right)\\n*/\\n\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail =NULL) {\\n        if(!root) return tail;        \\n        TreeNode* res= increasingBST(root->left, root);  // step1: left child\\n        root->left = NULL;                               // step2: root\\n        root->right= increasingBST(root->right, tail);   // step3: right child\\n        return res;\\n    }\\n};\\n//Referecen:\\n//[1] https://leetcode.com/problems/increasing-order-search-tree/discuss/165885/C%2B%2BJavaPython-Self-Explained-5-line-O(N)\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nIdea[1]: in-order output the whole tree.\\nStraight forward traverse the tree: result = inorder(root.left) + root + inorder(root.right)\\n*/\\n\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, TreeNode* tail =NULL) {\\n        if(!root) return tail;        \\n        TreeNode* res= increasingBST(root->left, root);  // step1: left child\\n        root->left = NULL;                               // step2: root\\n        root->right= increasingBST(root->right, tail);   // step3: right child\\n        return res;\\n    }\\n};\\n//Referecen:\\n//[1] https://leetcode.com/problems/increasing-order-search-tree/discuss/165885/C%2B%2BJavaPython-Self-Explained-5-line-O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556967,
                "title": "rust-0ms",
                "content": "```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn increasing_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(node) = root.clone() {\\n            let mut vals = Solution::walk(root.clone());\\n            vals.reverse();\\n            let fst = vals.pop().unwrap();\\n            *node.borrow_mut() = TreeNode::new(fst);\\n            node.borrow_mut().right = Solution::inc_bst(vals)\\n        }\\n        root\\n    }\\n\\n    fn inc_bst(mut vals: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if vals.is_empty() {\\n            return None;\\n        }\\n        let v = vals.pop().unwrap();\\n        let node = Rc::new(RefCell::new(TreeNode::new(v)));\\n        node.borrow_mut().right = Solution::inc_bst(vals);\\n        Some(node)\\n    }\\n\\n    fn walk(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut vals: Vec<i32> = vec![];\\n        if let Some(node) = root {\\n            let node = node.borrow();\\n            vals.extend(Solution::walk(node.left.clone()));\\n            vals.push(node.val);\\n            vals.extend(Solution::walk(node.right.clone()));\\n        }\\n        vals\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn increasing_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(node) = root.clone() {\\n            let mut vals = Solution::walk(root.clone());\\n            vals.reverse();\\n            let fst = vals.pop().unwrap();\\n            *node.borrow_mut() = TreeNode::new(fst);\\n            node.borrow_mut().right = Solution::inc_bst(vals)\\n        }\\n        root\\n    }\\n\\n    fn inc_bst(mut vals: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if vals.is_empty() {\\n            return None;\\n        }\\n        let v = vals.pop().unwrap();\\n        let node = Rc::new(RefCell::new(TreeNode::new(v)));\\n        node.borrow_mut().right = Solution::inc_bst(vals);\\n        Some(node)\\n    }\\n\\n    fn walk(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {\\n        let mut vals: Vec<i32> = vec![];\\n        if let Some(node) = root {\\n            let node = node.borrow();\\n            vals.extend(Solution::walk(node.left.clone()));\\n            vals.push(node.val);\\n            vals.extend(Solution::walk(node.right.clone()));\\n        }\\n        vals\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526258,
                "title": "python-o-n-sol-by-dfs-90-w-diagram",
                "content": "Python O(n) sol by DFS\\n\\n---\\n\\n**Goal**: \\n\\n**Convert binary search tree** into a **right-skewed linked list** with ascending order.\\n\\n---\\n\\n**Hint**:\\n\\nTake advantage of the **well-order property** of **in-order traveresal in binary search tree**.\\n\\nIn-order traversal in binary search tree yields the sorted sequence with ascending order.\\nSimilarly, the reversed in-order traversal in BST yields the sorted sequence with descending order.\\n\\n---\\n\\n**Algorithm**:\\n\\nMaintain a global node, called **previous traversal node**, initialized to *None*, and update as current node on each DFS traversal.\\n\\n**Previous traversal node** always points to **next larger element for current node**\\n\\nDFS traversal with the ordering: ( Right node, Current node, Left node )\\n\\nStep_#1. Change current node\\'s **right child** as **previous traversal node**.\\n\\nStep_#2. If previous traversal node is not a empty node, change previous traversal node\\'s **left child** as **None**(i.e., NULL)\\n\\nStep_#3. **Update previous traversal node** as current node\\n\\n---\\n\\n**Observation**:\\n\\nFor Current node, Right node is its previous traversal node (i.e., next larger element ).\\nFor Left node, Current node is its previous traversal node (i.e., next larger element ).\\n\\n---\\n\\n**Abstract Model**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583122482.png)\\n\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583122492.png)\\n\\n\\n\\t \\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        prev_node = None\\n        \\n        def helper( node: TreeNode):\\n                           \\n            if node.right:\\n                helper( node.right )\\n\\n            # prev_novde always points to next larger element for current node\\n            nonlocal prev_node\\n\\n            # update right link points to next larger element\\n            node.right = prev_node\\n\\n            # break the left link of next larger element\\n            if prev_node:\\n                prev_node.left = None\\n\\n            # update previous node as current node\\n            prev_node = node\\n\\n            if node.left:\\n                helper( node.left)\\n                \\n        # ---------------------------------------\\n        helper( root )\\n        \\n        return prev_node\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #114 Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)\\n\\n[Leetcode #538 Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/)\\n[Leetcode #1038 Binary Search Tree to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)\\n\\nNote:\\n#538 and #1038 are twin-challenges, basically, they are identical to the other one.\\n\\n[Leetcode #173 Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: in-order traversal in binary search tree](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        prev_node = None\\n        \\n        def helper( node: TreeNode):\\n                           \\n            if node.right:\\n                helper( node.right )\\n\\n            # prev_novde always points to next larger element for current node\\n            nonlocal prev_node\\n\\n            # update right link points to next larger element\\n            node.right = prev_node\\n\\n            # break the left link of next larger element\\n            if prev_node:\\n                prev_node.left = None\\n\\n            # update previous node as current node\\n            prev_node = node\\n\\n            if node.left:\\n                helper( node.left)\\n                \\n        # ---------------------------------------\\n        helper( root )\\n        \\n        return prev_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244939,
                "title": "swift-88ms",
                "content": "```\\n    var prev: TreeNode?\\n    var head: TreeNode?\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        guard let r = root else { return nil }\\n        increasingBST(r.left)\\n        \\n        if head == nil { head = r }\\n        \\n        r.left = nil\\n        prev?.right = r\\n        prev = r\\n        \\n        increasingBST(r.right)\\n        \\n        return head\\n    }",
                "solutionTags": [],
                "code": "```\\n    var prev: TreeNode?\\n    var head: TreeNode?\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        guard let r = root else { return nil }\\n        increasingBST(r.left)\\n        \\n        if head == nil { head = r }\\n        \\n        r.left = nil\\n        prev?.right = r\\n        prev = r\\n        \\n        increasingBST(r.right)\\n        \\n        return head\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 201081,
                "title": "java-recursive-without-global-variable",
                "content": "We can simplify the problem by assuming that we have solution for left subtree and right subtree for a given node. This means that left subtree has the following structure 1->2->3->4 and right subtree has the following structure 6->7->8->9. Now we only have to link 4 to 5 and 5 to 6 and we are done.\\nOn solving the subproblem we return the leftmost node and rightmost node in an array. This is useful as we need rightmost node of the left subtree and leftmost node of right subtree to link the two subproblems.\\nTBH this was not an easy problem. What do you guys think?\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root)[0];\\n    }\\n    \\n    private TreeNode[] helper(TreeNode node) {\\n        if (node == null) { \\n            return new TreeNode[]{null, null};\\n        }\\n        TreeNode[] leftSubtree = helper(node.left);\\n        if (leftSubtree[1] != null) {\\n            leftSubtree[1].right = node;\\n        }\\n        if (leftSubtree[0] == null) {\\n            leftSubtree[0] = node;\\n        }\\n        \\n        node.left = null;\\n        \\n        TreeNode[] rightSubTree = helper(node.right);\\n        if (rightSubTree[0] != null) {\\n            node.right = rightSubTree[0];\\n        }\\n        if (rightSubTree[1] == null) {\\n            rightSubTree[1] = node;\\n        }\\n        \\n        return new TreeNode[]{leftSubtree[0], rightSubTree[1]};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root)[0];\\n    }\\n    \\n    private TreeNode[] helper(TreeNode node) {\\n        if (node == null) { \\n            return new TreeNode[]{null, null};\\n        }\\n        TreeNode[] leftSubtree = helper(node.left);\\n        if (leftSubtree[1] != null) {\\n            leftSubtree[1].right = node;\\n        }\\n        if (leftSubtree[0] == null) {\\n            leftSubtree[0] = node;\\n        }\\n        \\n        node.left = null;\\n        \\n        TreeNode[] rightSubTree = helper(node.right);\\n        if (rightSubTree[0] != null) {\\n            node.right = rightSubTree[0];\\n        }\\n        if (rightSubTree[1] == null) {\\n            rightSubTree[1] = node;\\n        }\\n        \\n        return new TreeNode[]{leftSubtree[0], rightSubTree[1]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185131,
                "title": "python-easy-to-understand-solution",
                "content": "Traverse then reform the entire tree.\n\n    def increasingBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n\n        def mid_order(node, L):\n            if node is None:\n                return\n            mid_order(node.left, L)\n            L.append(node.val)\n            mid_order(node.right, L)\n\n        L = []\n        mid_order(root, L)\n\n        ans = current = TreeNode(None) \n        for value in L:\n            current.right = TreeNode(value)\n            current = current.right \n        return ans.right",
                "solutionTags": [],
                "code": "    def increasingBST(self, root):\n        def mid_order(node, L):\n            mid_order(node.left, L)\n            L.append(node.val)\n            mid_order(node.right, L)\n        L = []\n        mid_order(root, L)\n        ans = current = TreeNode(None) \n            current.right = TreeNode(value)\n            current = current.right ",
                "codeTag": "Python3"
            },
            {
                "id": 165902,
                "title": "python-o-n-time-o-log-n-stack-space-with-explanation-uses-generator-yield",
                "content": "The idea is simple. We effectively build up a linked list, taking the nodes from an inorder-traversal generator. In order to make it in-place, the generator needs to save the right node before yielding the current node, otherwise it\\'d be overwritten by the caller. We don\\'t need to save the left node, because it\\'ll be fully processed before the current node is returned (due to this being an inorder traversal).\\n\\nBy using a generator, we\\'re seperating the \"tree\" logic from the \"linked list\" logic.\\n\\nNote that it does use extra space on the stack. This is unavoidable, even for an iterative solution.\\n\\n```\\nclass Solution:\\n    \\n    def increasingBST(self, root):\\n        \\n        dummy_head = TreeNode(None)\\n        current_node = dummy_head\\n        \\n        for node in self.inorder_iterator(root):\\n            current_node.right = node\\n            current_node = node\\n            current_node.left = None\\n        return dummy_head.right\\n                \\n        \\n    def inorder_iterator(self, root):\\n        if root != None:\\n            yield from self.inorder_iterator(root.left)\\n            right = root.right #Gotta save this as it\\'ll be overwritten.\\n            yield root\\n            yield from self.inorder_iterator(right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def increasingBST(self, root):\\n        \\n        dummy_head = TreeNode(None)\\n        current_node = dummy_head\\n        \\n        for node in self.inorder_iterator(root):\\n            current_node.right = node\\n            current_node = node\\n            current_node.left = None\\n        return dummy_head.right\\n                \\n        \\n    def inorder_iterator(self, root):\\n        if root != None:\\n            yield from self.inorder_iterator(root.left)\\n            right = root.right #Gotta save this as it\\'ll be overwritten.\\n            yield root\\n            yield from self.inorder_iterator(right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409910,
                "title": "python3-beats-99-52-21ms-simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    First create a sorted list from BST then create another\\n    BST by using values from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. First we apply inorder traversal on the BST.\\n    2. Append the root value in each traversal in a list.\\n    3. As it is a binary search tree , therefore we have a sorted list.\\n    4. Then we reverse the list and create a new BST with root having\\n    the smallest value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    O(n)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        if not root:\\n            return None\\n\\n        def create_list(root,list1):\\n            \\n            if not root:\\n                return None\\n                \\n            create_list(root.left,list1)\\n            list1.append(root.val)\\n            create_list(root.right,list1)\\n\\n        list1=[]\\n        create_list(root,list1)\\n\\n        def inorder(list1):\\n            list1.reverse()\\n            prev=None\\n            for i in list1:\\n                new=TreeNode(i)\\n                new.right=prev\\n                prev=new\\n            return new\\n        return inorder(list1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        \\n        if not root:\\n            return None\\n\\n        def create_list(root,list1):\\n            \\n            if not root:\\n                return None\\n                \\n            create_list(root.left,list1)\\n            list1.append(root.val)\\n            create_list(root.right,list1)\\n\\n        list1=[]\\n        create_list(root,list1)\\n\\n        def inorder(list1):\\n            list1.reverse()\\n            prev=None\\n            for i in list1:\\n                new=TreeNode(i)\\n                new.right=prev\\n                prev=new\\n            return new\\n        return inorder(list1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384693,
                "title": "java-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n import java.util.*;\\nclass Solution {\\n\\n    TreeNode ans = new TreeNode(-1);\\n    TreeNode current = ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n\\n        inorder(root);\\n        \\n        return ans.right;\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        TreeNode newnode = new TreeNode(root.val);\\n        current.right = newnode;\\n        current = current.right;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n import java.util.*;\\nclass Solution {\\n\\n    TreeNode ans = new TreeNode(-1);\\n    TreeNode current = ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n\\n        inorder(root);\\n        \\n        return ans.right;\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n\\n        inorder(root.left);\\n\\n        TreeNode newnode = new TreeNode(root.val);\\n        current.right = newnode;\\n        current = current.right;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205041,
                "title": "simple-easy-to-understand-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void getInorder(TreeNode* root, vector<int>& num){\\n        if(root==NULL) return;\\n\\n        getInorder(root->left, num);\\n        num.push_back(root->val);\\n        getInorder(root->right, num);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        vector<int>num;\\n        getInorder(root,num);\\n        TreeNode* head = new TreeNode(num[0],NULL, NULL);\\n        TreeNode* temp = head;\\n        for(int i=1;i<num.size();i++){\\n            temp->right = new TreeNode(num[i],NULL,NULL);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void getInorder(TreeNode* root, vector<int>& num){\\n        if(root==NULL) return;\\n\\n        getInorder(root->left, num);\\n        num.push_back(root->val);\\n        getInorder(root->right, num);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        vector<int>num;\\n        getInorder(root,num);\\n        TreeNode* head = new TreeNode(num[0],NULL, NULL);\\n        TreeNode* temp = head;\\n        for(int i=1;i<num.size();i++){\\n            temp->right = new TreeNode(num[i],NULL,NULL);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941701,
                "title": "easy-c-solution-recursive-approach-vector-approach",
                "content": "# Intuition\\n\\n# Approach\\nThe approach is very simple. firstly we are creating a vector in which we\\'ll be going to store the nodes of current tree inorderly.\\nThen, we\\'ll create a tree in which left will point to NULL and right will print recursively till the size of i will equal to the size of vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans){\\n        if(root == NULL){\\n            return;\\n        }\\n        solve(root -> left,ans);\\n        ans.push_back(root -> val);\\n        solve(root -> right,ans);\\n    }\\n    TreeNode* newTree(vector<int> &ans, int i, int &n){\\n        if(i == n)\\n        return NULL;\\n\\n            TreeNode* temp = new TreeNode(ans[i]);\\n            temp -> left = NULL;\\n            temp -> right = newTree(ans, i+1,n);\\n            return temp;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        int n = ans.size();\\n        return newTree(ans,0,n);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, vector<int> &ans){\\n        if(root == NULL){\\n            return;\\n        }\\n        solve(root -> left,ans);\\n        ans.push_back(root -> val);\\n        solve(root -> right,ans);\\n    }\\n    TreeNode* newTree(vector<int> &ans, int i, int &n){\\n        if(i == n)\\n        return NULL;\\n\\n            TreeNode* temp = new TreeNode(ans[i]);\\n            temp -> left = NULL;\\n            temp -> right = newTree(ans, i+1,n);\\n            return temp;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        int n = ans.size();\\n        return newTree(ans,0,n);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798195,
                "title": "c-solution-increasing-order-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        // BST to sorted LL logic\\n        \\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        TreeNode* newRoot = new TreeNode(inorderVal[0]);\\n        TreeNode* curr = newRoot;\\n        \\n        for(int i = 1 ; i < inorderVal.size() ; i++){\\n            TreeNode* temp = new TreeNode(inorderVal[i]);\\n            \\n            curr->left = NULL;\\n            curr->right = temp;\\n            curr = temp;\\n        }\\n        \\n        //last node\\n        curr->left = NULL;\\n        curr->right = NULL;\\n        \\n        return newRoot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n        \\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        // BST to sorted LL logic\\n        \\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        TreeNode* newRoot = new TreeNode(inorderVal[0]);\\n        TreeNode* curr = newRoot;\\n        \\n        for(int i = 1 ; i < inorderVal.size() ; i++){\\n            TreeNode* temp = new TreeNode(inorderVal[i]);\\n            \\n            curr->left = NULL;\\n            curr->right = temp;\\n            curr = temp;\\n        }\\n        \\n        //last node\\n        curr->left = NULL;\\n        curr->right = NULL;\\n        \\n        return newRoot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655082,
                "title": "java-100-fast-easy-code-beginner-friendly-recursion-increasing-order-search-tree",
                "content": "**Kindly upvote, if it is useful!!!**\\n\\n```\\nclass Solution {\\n    TreeNode tree = new TreeNode();\\n    TreeNode head = tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        increasingBST(root.left);\\n        \\n        tree=tree.right=new TreeNode(root.val);\\n        increasingBST(root.right);\\n        return head.right;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tree = new TreeNode();\\n    TreeNode head = tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        increasingBST(root.left);\\n        \\n        tree=tree.right=new TreeNode(root.val);\\n        increasingBST(root.right);\\n        return head.right;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307332,
                "title": "javascript-easy-solution",
                "content": "```\\nvar increasingBST = function(root) {\\n    let data=[]\\n    function dfs(root){\\n        if(!root) return null\\n        dfs(root.left)\\n        data.push(root.val)\\n        dfs(root.right)\\n    }\\n    dfs(root)\\n    let node = new TreeNode(data[0])\\n    let curr=node\\n    for(let i =1; i<data.length; i++){\\n        curr.right=new TreeNode(data[i])\\n        curr=curr.right\\n   }\\n    return node\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar increasingBST = function(root) {\\n    let data=[]\\n    function dfs(root){\\n        if(!root) return null\\n        dfs(root.left)\\n        data.push(root.val)\\n        dfs(root.right)\\n    }\\n    dfs(root)\\n    let node = new TreeNode(data[0])\\n    let curr=node\\n    for(let i =1; i<data.length; i++){\\n        curr.right=new TreeNode(data[i])\\n        curr=curr.right\\n   }\\n    return node\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957273,
                "title": "c-intuitive-recursive-in-order-traversal",
                "content": "![image](https://assets.leetcode.com/users/images/357424fc-c6af-4130-b03d-e68b01280227_1650198162.2402177.png)\\nLet\\'s quickly wrap up example test case 1.\\nWhen we traverse our BST through inorder(Left - Root - Right) traversal, we come across nodes in an increasing order, this shall prompt us that  we have to use inorder traversal. Great!! \\nLet\\'s run inorder in our example test case : 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9\\nBut then the  question is how can we then rearrage our given tree in this manner. \\n\\nWhile doing inorder traversal, when we are at the left most node, we will make it our root node. So in this example when we\\'ll be at 1, that will be our new root node, it\\'s left node will be marked as \\'NULL\\'. For every other node we have to do two things: \\n\\ntake the case of \\'2\\', we have to connect it to the right of prev node(i.e. 1) and it\\'s left should be marked as \\'NULL\\'. For \\'3\\', we have to connect it to the right of prev node(i.e. 2) and it\\'s left should be marked as \\'NULL\\'. We have to do this till we reach our right most node.\\n\\nexample code: \\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *result, *prev;\\n    //result holds the new updated root node and prev holds previous node.\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inOrder(root);\\n        return result;\\n    }\\nprivate: \\n    void inOrder(TreeNode* root) {\\n        if(root == NULL) return;\\n        inOrder(root -> left);\\n        \\n        if(result == NULL) {\\n            result = root;\\n        } else {\\n            prev -> right = root;\\n        }\\n        \\n        prev = root;\\n        root -> left = NULL;\\n        \\n        inOrder(root -> right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *result, *prev;\\n    //result holds the new updated root node and prev holds previous node.\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inOrder(root);\\n        return result;\\n    }\\nprivate: \\n    void inOrder(TreeNode* root) {\\n        if(root == NULL) return;\\n        inOrder(root -> left);\\n        \\n        if(result == NULL) {\\n            result = root;\\n        } else {\\n            prev -> right = root;\\n        }\\n        \\n        prev = root;\\n        root -> left = NULL;\\n        \\n        inOrder(root -> right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956724,
                "title": "python-inorder",
                "content": "**Please upvote if it helps. Thank you!**\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        dummy = rtree = TreeNode()\\n        \\n        def inorder(node):\\n            nonlocal rtree\\n            if node:\\n                inorder(node.left)\\n                rtree.right = TreeNode(node.val)\\n                rtree = rtree.right\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        return dummy.right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        dummy = rtree = TreeNode()\\n        \\n        def inorder(node):\\n            nonlocal rtree\\n            if node:\\n                inorder(node.left)\\n                rtree.right = TreeNode(node.val)\\n                rtree = rtree.right\\n                inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        return dummy.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955041,
                "title": "python-clean-inorder-traversal",
                "content": "```\\nfrom typing import Optional\\n\\n\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(rt: Optional[TreeNode], node: TreeNode) -> TreeNode:\\n            if rt is not None:\\n                node = inorder(rt.left, node)\\n\\n                node.right = TreeNode(val=rt.val)\\n                node = node.right\\n\\n                node = inorder(rt.right, node)\\n\\n            return node\\n\\n        dummy_node = TreeNode()\\n        inorder(root, dummy_node)\\n\\n        return dummy_node.right\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nfrom typing import Optional\\n\\n\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(rt: Optional[TreeNode], node: TreeNode) -> TreeNode:\\n            if rt is not None:\\n                node = inorder(rt.left, node)\\n\\n                node.right = TreeNode(val=rt.val)\\n                node = node.right\\n\\n                node = inorder(rt.right, node)\\n\\n            return node\\n\\n        dummy_node = TreeNode()\\n        inorder(root, dummy_node)\\n\\n        return dummy_node.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826130,
                "title": "c-inorder-recursion",
                "content": "```\\n//We have declare two global varibale which head is main head of final tree and res which store the current state of tree\\n TreeNode*res=NULL;\\n    TreeNode*head=NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n\\t//if root is NULL we return for NULL\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//Moving left as per inorder traversal\\n        increasingBST(root->left);\\n\\t\\t//if res is null means currently No node is find  then we create a node\\n        if(res==NULL){\\n            res=new TreeNode(root->val);\\n\\t\\t\\t//create a node and make it update to head as it become the root of tree\\n            head=res;\\n        }\\n        else{\\n\\t\\t//IF res is not null means we have to place the next node to the res->right asper question and update the res= res->right because place for nect upcoming nodes.\\n\\t\\t    res->right= new TreeNode(root->val);\\n            res=res->right;\\n        }\\n       increasingBST(root->right);\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//We have declare two global varibale which head is main head of final tree and res which store the current state of tree\\n TreeNode*res=NULL;\\n    TreeNode*head=NULL;\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n\\t//if root is NULL we return for NULL\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//Moving left as per inorder traversal\\n        increasingBST(root->left);\\n\\t\\t//if res is null means currently No node is find  then we create a node\\n        if(res==NULL){\\n            res=new TreeNode(root->val);\\n\\t\\t\\t//create a node and make it update to head as it become the root of tree\\n            head=res;\\n        }\\n        else{\\n\\t\\t//IF res is not null means we have to place the next node to the res->right asper question and update the res= res->right because place for nect upcoming nodes.\\n\\t\\t    res->right= new TreeNode(root->val);\\n            res=res->right;\\n        }\\n       increasingBST(root->right);\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764863,
                "title": "c-100-faster-using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    stack<TreeNode*> st;\\n    //reverse inorder traversal\\n    void reverse_inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        reverse_inorder(root->right);\\n        st.push(root);\\n        reverse_inorder(root->left);\\n    }\\n    \\n    // creation of Increasing Order Search Tree with the values of stack st\\n    TreeNode* iost() //iost: Increasing Order Search Tree\\n    {\\n        if(st.empty())\\n            return NULL;\\n        TreeNode* root=new TreeNode(st.top()->val);\\n        st.pop();\\n        root->right=iost();\\n        return root;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* ans;\\n        reverse_inorder(root);\\n        ans=iost();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    stack<TreeNode*> st;\\n    //reverse inorder traversal\\n    void reverse_inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        reverse_inorder(root->right);\\n        st.push(root);\\n        reverse_inorder(root->left);\\n    }\\n    \\n    // creation of Increasing Order Search Tree with the values of stack st\\n    TreeNode* iost() //iost: Increasing Order Search Tree\\n    {\\n        if(st.empty())\\n            return NULL;\\n        TreeNode* root=new TreeNode(st.top()->val);\\n        st.pop();\\n        root->right=iost();\\n        return root;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* ans;\\n        reverse_inorder(root);\\n        ans=iost();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423875,
                "title": "golang-inorder",
                "content": "```\\nvar prev *TreeNode\\n\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n    ans := &TreeNode{}\\n    prev = ans\\n    \\n    inOrder(root)\\n\\n    return ans.Right\\n}\\n\\nfunc inOrder(root *TreeNode) {\\n    if root == nil {\\n        return \\n    }\\n    \\n    inOrder(root.Left)\\n    \\n    // switch\\n    prev.Right = root\\n    prev = root\\n    prev.Left = nil\\n    \\n    inOrder(root.Right)\\n    return \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar prev *TreeNode\\n\\nfunc increasingBST(root *TreeNode) *TreeNode {\\n    ans := &TreeNode{}\\n    prev = ans\\n    \\n    inOrder(root)\\n\\n    return ans.Right\\n}\\n\\nfunc inOrder(root *TreeNode) {\\n    if root == nil {\\n        return \\n    }\\n    \\n    inOrder(root.Left)\\n    \\n    // switch\\n    prev.Right = root\\n    prev = root\\n    prev.Left = nil\\n    \\n    inOrder(root.Right)\\n    return \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1380845,
                "title": "easy-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root!=NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root);\\n            inorder(root->right);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            v[i]->left=NULL;\\n            v[i]->right=v[i+1];\\n        }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root!=NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root);\\n            inorder(root->right);\\n        }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        inorder(root);\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            v[i]->left=NULL;\\n            v[i]->right=v[i+1];\\n        }\\n        v[v.size()-1]->left=NULL;\\n        v[v.size()-1]->right=NULL;\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108197,
                "title": "c-simple-faster-than-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode * node, TreeNode *& res)\\n    {\\n        if(!node) return;\\n        helper(node->left, res);\\n        res->right= new TreeNode(node->val);\\n        res = res->right;\\n        helper(node->right, res);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode * res = new TreeNode(0);\\n        TreeNode * tmp = res;\\n        helper(root, tmp);\\n        return res->right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode * node, TreeNode *& res)\\n    {\\n        if(!node) return;\\n        helper(node->left, res);\\n        res->right= new TreeNode(node->val);\\n        res = res->right;\\n        helper(node->right, res);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode * res = new TreeNode(0);\\n        TreeNode * tmp = res;\\n        helper(root, tmp);\\n        return res->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958819,
                "title": "c-recursive-in-order-solution-explained-100-time-65-space",
                "content": "Nice one, I wanted to play with it with an in-order traversal; I might find better solutions later, but for now this one works.\\n\\nFirst of all we declare 3 extra node variables:\\n* `left` and `right` will take the value of recursive calls to our main function if we have a left or right branch respectively, `NULL` otherwise;\\n* `tmp` will store the current `root`.\\n\\nNow, one important bit we need to do now (and that I initially forgot here giving me an endless cycle), is to cut the current left branch away from `root` before proceeding further.\\n\\nIf we have a `left` (which is going to be already in-order by this time), then we turn it into the new `root` and navigate it to the end, attach the previous root (stored as `tmp`) and move on to attach `right` (similarly to `left`, already sorted by now).\\n\\nFinally, we can return `root` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode *increasingBST(TreeNode *root) {\\n        // support variables and recursively parsing the tree in order\\n        TreeNode *left = root->left ? increasingBST(root->left) : NULL,\\n            *right = root->right ? increasingBST(root->right) : NULL, *tmp = root;\\n        // cutting left node branch from roo\\n        root->left = NULL;\\n        if (left) {\\n            root = left;\\n            // moving to the last element of left\\n            while (left->right) left = left->right;\\n            left->right = tmp;\\n        }\\n        if (right) tmp->right = right;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode *increasingBST(TreeNode *root) {\\n        // support variables and recursively parsing the tree in order\\n        TreeNode *left = root->left ? increasingBST(root->left) : NULL,\\n            *right = root->right ? increasingBST(root->right) : NULL, *tmp = root;\\n        // cutting left node branch from roo\\n        root->left = NULL;\\n        if (left) {\\n            root = left;\\n            // moving to the last element of left\\n            while (left->right) left = left->right;\\n            left->right = tmp;\\n        }\\n        if (right) tmp->right = right;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958453,
                "title": "python-dfs-recursion",
                "content": "I was having a hard time undertanding the LC write for the recurive relinking solution. So I wanted to rewrite it in a way that was more understandable. We can assing an empty tree structure outside our dfs caller. We write our dfs the usual in order way making changes to this tree outside. In our DFS call, we examine a node and set its left to None. We also set its right to the node we are at, but also move our pointer in our tree outside te caller. Then we decsend right. Since we allocated an empty tree at first, we need to return the right subtree.\\n\\n```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        newTree = TreeNode(None)\\n        self.temp = newTree\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            node.left = None\\n            self.temp.right = node\\n            self.temp = node\\n            dfs(node.right)\\n        dfs(root)\\n        return newTree.right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        newTree = TreeNode(None)\\n        self.temp = newTree\\n        def dfs(node):\\n            if not node:\\n                return\\n            dfs(node.left)\\n            node.left = None\\n            self.temp.right = node\\n            self.temp = node\\n            dfs(node.right)\\n        dfs(root)\\n        return newTree.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958112,
                "title": "simple-java-solution-o-h-space-o-n-time-0ms-100-faster",
                "content": "here only space taken is call stack space.\\n```\\nclass Solution {\\n    private TreeNode head = new TreeNode(-1);\\n    private TreeNode temp = head;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inOrder(root);\\n        return head.right;\\n    }\\n    private void inOrder(TreeNode root){\\n        if(root!=null) {\\n            inOrder(root.left);\\n            temp.right=root;\\n            root.left=null;\\n            temp=root;\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode head = new TreeNode(-1);\\n    private TreeNode temp = head;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inOrder(root);\\n        return head.right;\\n    }\\n    private void inOrder(TreeNode root){\\n        if(root!=null) {\\n            inOrder(root.left);\\n            temp.right=root;\\n            root.left=null;\\n            temp=root;\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845950,
                "title": "c-iterative-solution",
                "content": "```\\npublic class Solution {\\n    public TreeNode IncreasingBST(TreeNode root) {                \\n        TreeNode dummy = new TreeNode(-1);\\n        TreeNode curr = dummy;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.Push(root);    \\n        \\n        while(stack.Count > 0)\\n        {\\n            while(root.left != null)\\n            {\\n                stack.Push(root.left);\\n                root = root.left;\\n            }\\n            \\n            TreeNode node = stack.Pop();\\n            curr.right = new TreeNode(node.val);\\n            curr = curr.right;\\n            \\n            if(node.right != null)\\n            {\\n                stack.Push(node.right);\\n                root = node.right;\\n            }\\n        }       \\n        \\n        return dummy.right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\npublic class Solution {\\n    public TreeNode IncreasingBST(TreeNode root) {                \\n        TreeNode dummy = new TreeNode(-1);\\n        TreeNode curr = dummy;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.Push(root);    \\n        \\n        while(stack.Count > 0)\\n        {\\n            while(root.left != null)\\n            {\\n                stack.Push(root.left);\\n                root = root.left;\\n            }\\n            \\n            TreeNode node = stack.Pop();\\n            curr.right = new TreeNode(node.val);\\n            curr = curr.right;\\n            \\n            if(node.right != null)\\n            {\\n                stack.Push(node.right);\\n                root = node.right;\\n            }\\n        }       \\n        \\n        return dummy.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830539,
                "title": "simple-recursive-solution-in-c",
                "content": "class Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* res = tmp;\\n        dfs(root, tmp);\\n        return res->right;\\n    }\\n    \\n    TreeNode* dfs(TreeNode* root, TreeNode* res){\\n        if(!root) return res;\\n\\n        res = dfs(root->left, res);\\n        res->right=new TreeNode(root->val);\\n        res=res->right;\\n        res = dfs(root->right, res);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* tmp = new TreeNode(-1);\\n        TreeNode* res = tmp;\\n        dfs(root, tmp);\\n        return res->right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 570684,
                "title": "2-java-solutions-beat-100-memory-and-complexity",
                "content": "1)\\n```\\nclass Solution {\\n    TreeNode tmp, res;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        return res;\\n    }\\n    \\n    void rec(TreeNode root) {\\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        if (tmp == null) {\\n            res = new TreeNode(root.val);\\n            tmp = res;\\n        } else {\\n            tmp.right = new TreeNode(root.val);;\\n            tmp = tmp.right;\\n        }\\n        \\n        if (root.right != null)\\n            rec(root.right);\\n        \\n    }\\n}\\n```\\n2)\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        TreeNode res = null;\\n        TreeNode tmp = null;\\n        \\n        for(Integer i : l) {\\n            if (res == null) {\\n                res = new TreeNode(i);\\n                tmp = res;\\n            } else {\\n                tmp.right = new TreeNode(i);\\n                tmp = tmp.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    List<Integer> l = new ArrayList<>();\\n    \\n    void rec(TreeNode root) {\\n        \\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        l.add(root.val);\\n        \\n        if (root.right != null)\\n           rec(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tmp, res;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        return res;\\n    }\\n    \\n    void rec(TreeNode root) {\\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        if (tmp == null) {\\n            res = new TreeNode(root.val);\\n            tmp = res;\\n        } else {\\n            tmp.right = new TreeNode(root.val);;\\n            tmp = tmp.right;\\n        }\\n        \\n        if (root.right != null)\\n            rec(root.right);\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        rec(root);\\n        \\n        TreeNode res = null;\\n        TreeNode tmp = null;\\n        \\n        for(Integer i : l) {\\n            if (res == null) {\\n                res = new TreeNode(i);\\n                tmp = res;\\n            } else {\\n                tmp.right = new TreeNode(i);\\n                tmp = tmp.right;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    List<Integer> l = new ArrayList<>();\\n    \\n    void rec(TreeNode root) {\\n        \\n        if (root.left != null)\\n            rec(root.left);\\n        \\n        l.add(root.val);\\n        \\n        if (root.right != null)\\n           rec(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500809,
                "title": "intuitive-javascript-solution-with-relinking",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    // Relink\\n    // start with a fake new root to connect the rest and \\n    // assign the pointer to the current node to the new root\\n    const newRoot = new TreeNode(undefined);\\n    let cur = newRoot;\\n    const inorder = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        inorder(node.left);\\n        // for current node, we want to only link the node to the right\\n        node.left = null;\\n        cur.right = node;\\n        // reassign node to cur for the next operation\\n        cur = node;\\n        inorder(node.right);\\n    }\\n    inorder(root)\\n    return newRoot.right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    // Relink\\n    // start with a fake new root to connect the rest and \\n    // assign the pointer to the current node to the new root\\n    const newRoot = new TreeNode(undefined);\\n    let cur = newRoot;\\n    const inorder = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        inorder(node.left);\\n        // for current node, we want to only link the node to the right\\n        node.left = null;\\n        cur.right = node;\\n        // reassign node to cur for the next operation\\n        cur = node;\\n        inorder(node.right);\\n    }\\n    inorder(root)\\n    return newRoot.right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331799,
                "title": "java-solution",
                "content": "**Recursive:**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n}\\n```\\n\\nRuntime: 2 ms, faster than 99.97% of Java online submissions for Increasing Order Search Tree.\\nMemory Usage: 39 MB, less than 80.50% of Java online submissions for Increasing Order Search Tree.\\n\\n**Iterative:**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode dummy = new TreeNode(0), p = dummy;\\n        while(root != null || !stack.empty()){\\n            if(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            else{\\n                TreeNode cur = stack.pop();\\n                root = cur.right;\\n                cur.left = null;\\n                p.right = cur;\\n                p = p.right;\\n            }\\n        }\\n        return dummy.right;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root, dummy = new TreeNode(0), tree = dummy;   \\n        while(cur != null || !stack.empty()){\\n            while(cur != null){\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            cur.left = null;\\n            tree.right = cur;\\n            cur = cur.right;\\n            tree = tree.right;\\n        }\\n        return dummy.right;\\n    }\\n}\\n```\\n\\nRuntime: 5 ms, faster than 13.11% of Java online submissions for Increasing Order Search Tree.\\nMemory Usage: 44.3 MB, less than 43.05% of Java online submissions for Increasing Order Search Tree.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return increasingBST(root, null);\\n    }\\n\\n    public TreeNode increasingBST(TreeNode root, TreeNode tail) {\\n        if (root == null) return tail;\\n        TreeNode res = increasingBST(root.left, root);\\n        root.left = null;\\n        root.right = increasingBST(root.right, tail);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode dummy = new TreeNode(0), p = dummy;\\n        while(root != null || !stack.empty()){\\n            if(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            else{\\n                TreeNode cur = stack.pop();\\n                root = cur.right;\\n                cur.left = null;\\n                p.right = cur;\\n                p = p.right;\\n            }\\n        }\\n        return dummy.right;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode cur = root, dummy = new TreeNode(0), tree = dummy;   \\n        while(cur != null || !stack.empty()){\\n            while(cur != null){\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            cur = stack.pop();\\n            cur.left = null;\\n            tree.right = cur;\\n            cur = cur.right;\\n            tree = tree.right;\\n        }\\n        return dummy.right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166019,
                "title": "python-iterative-solution",
                "content": "Algorithm:\\n1. Store the inorder of tree in an array\\n2. Create nodes based on the values in array and then connect them to each other on node.right\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        # get inorder list\\n        res = []\\n        stack = []\\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n\\n        # adjust node.right\\n        dummy = pre = TreeNode(-1)\\n        i = 0\\n        while i < len(res):\\n            pre.right = TreeNode(res[i])\\n            pre = pre.right\\n            i += 1\\n        return dummy.right\\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        # get inorder list\\n        res = []\\n        stack = []\\n        while root or stack:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                res.append(node.val)\\n                root = node.right\\n\\n        # adjust node.right\\n        dummy = pre = TreeNode(-1)\\n        i = 0\\n        while i < len(res):\\n            pre.right = TreeNode(res[i])\\n            pre = pre.right\\n            i += 1\\n        return dummy.right\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653822,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode ans=new TreeNode(-1);\\n    TreeNode curr=ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return ans.right;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n\\n        inorder(root.left);\\n        TreeNode newnode= new TreeNode(root.val);\\n        curr.right=newnode;\\n        curr=curr.right;\\n\\n        inorder(root.right);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode ans=new TreeNode(-1);\\n    TreeNode curr=ans;\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return ans.right;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n\\n        inorder(root.left);\\n        TreeNode newnode= new TreeNode(root.val);\\n        curr.right=newnode;\\n        curr=curr.right;\\n\\n        inorder(root.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496673,
                "title": "c-solution-easy-to-understand-beats-100",
                "content": "# Intuition\\nWe will take the help of a vector to store the **in-order** traversal and then create a chain of tree nodes, only with the right children.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inOrder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return ;\\n        }\\n\\n        inOrder(root->left,vct);\\n        vct.push_back(root->val);\\n        inOrder(root->right,vct);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> vct;\\n        \\n        inOrder(root,vct);\\n\\n        TreeNode* ans = new TreeNode(vct[0],NULL,NULL);\\n        TreeNode* temp = ans;\\n\\n        for(int i = 1; i < vct.size(); ++i){\\n            TreeNode* newNode = new TreeNode(vct[i]);\\n            temp->right = newNode;\\n            temp = temp->right;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inOrder(TreeNode* root, vector<int> &vct){\\n        if(root == NULL){\\n            return ;\\n        }\\n\\n        inOrder(root->left,vct);\\n        vct.push_back(root->val);\\n        inOrder(root->right,vct);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> vct;\\n        \\n        inOrder(root,vct);\\n\\n        TreeNode* ans = new TreeNode(vct[0],NULL,NULL);\\n        TreeNode* temp = ans;\\n\\n        for(int i = 1; i < vct.size(); ++i){\\n            TreeNode* newNode = new TreeNode(vct[i]);\\n            temp->right = newNode;\\n            temp = temp->right;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411224,
                "title": "c-2-approach-stack-iterative-solution-recursive-solution-well-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &tail)   {\\n        if(!root)   return;\\n        inorder(root->left, tail);\\n        root -> left = NULL;\\n        tail -> right = root;\\n        tail = tail -> right;\\n        inorder(root -> right, tail);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* head = new TreeNode(0);\\n        TreeNode* tail = head;\\n        inorder(root, tail);\\n        return head -> right;\\n    }\\n};\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstack - iterative solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root)   return NULL;\\n        TreeNode* head = NULL;\\n        TreeNode* tail = head;\\n        stack<TreeNode*> st;\\n        \\n        while(!st.empty() || root) {\\n            if(root)    {\\n                st.push(root);\\n                root = root -> left;\\n            }\\n            else    {\\n                root = st.top();\\n                st.pop();\\n                if(!head)   {\\n                    head = new TreeNode(root->val);\\n                    tail = head;\\n                }\\n                else    {\\n                    tail -> right = new TreeNode(root -> val);\\n                    tail = tail -> right;\\n                }\\n                root = root -> right;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &tail)   {\\n        if(!root)   return;\\n        inorder(root->left, tail);\\n        root -> left = NULL;\\n        tail -> right = root;\\n        tail = tail -> right;\\n        inorder(root -> right, tail);\\n    }\\n\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* head = new TreeNode(0);\\n        TreeNode* tail = head;\\n        inorder(root, tail);\\n        return head -> right;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root)   return NULL;\\n        TreeNode* head = NULL;\\n        TreeNode* tail = head;\\n        stack<TreeNode*> st;\\n        \\n        while(!st.empty() || root) {\\n            if(root)    {\\n                st.push(root);\\n                root = root -> left;\\n            }\\n            else    {\\n                root = st.top();\\n                st.pop();\\n                if(!head)   {\\n                    head = new TreeNode(root->val);\\n                    tail = head;\\n                }\\n                else    {\\n                    tail -> right = new TreeNode(root -> val);\\n                    tail = tail -> right;\\n                }\\n                root = root -> right;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386991,
                "title": "use-queue-stack-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nqueue\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, queue<TreeNode*>& q) {\\n        if (!root) return;\\n        inorder(root->left, q);\\n        q.push(root);\\n        inorder(root->right, q);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) return nullptr;\\n        queue<TreeNode*> q;\\n        inorder(root, q);\\n        TreeNode* newRoot = q.front();\\n        TreeNode* node = newRoot;\\n        q.pop();\\n        while (!q.empty()) {\\n            node->left = nullptr;\\n            node->right = q.front();\\n            node = node->right;\\n            q.pop();\\n        }\\n        node->left = nullptr;\\n        node->right = nullptr;\\n        return newRoot;\\n    }\\n};\\n//stack\\nclass Solution {\\npublic:\\n    stack<TreeNode*> st;\\n    void dfs(TreeNode*root){\\n        if(root==nullptr)\\n            return;\\n        if(root->right)\\n            dfs(root->right);\\n        st.push(root);\\n        if(root->left)\\n            dfs(root->left);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        dfs(root);\\n        if(st.empty())\\n            return nullptr;\\n        TreeNode *res = st.top();\\n        st.pop();\\n        TreeNode* temp = res;\\n        while(temp && !st.empty()){\\n            temp->right = st.top();\\n            temp->left=nullptr;\\n            st.pop();\\n            temp = temp->right;\\n        }\\n        temp->left=nullptr;\\n        temp->right=nullptr;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode* root, queue<TreeNode*>& q) {\\n        if (!root) return;\\n        inorder(root->left, q);\\n        q.push(root);\\n        inorder(root->right, q);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3302485,
                "title": "simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<TreeNode> arr=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        for(int i=0;i<arr.size()-1;i++){\\n            arr.get(i).right=arr.get(i+1);\\n            arr.get(i).left=null;\\n        }\\n        arr.get(arr.size()-1).left=null;\\n        arr.get(arr.size()-1).right=null;\\n        return arr.get(0);\\n    }\\n    void inorder(TreeNode node){\\n        if(node==null) return;\\n        inorder(node.left);\\n        arr.add(node);\\n        inorder(node.right);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<TreeNode> arr=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        for(int i=0;i<arr.size()-1;i++){\\n            arr.get(i).right=arr.get(i+1);\\n            arr.get(i).left=null;\\n        }\\n        arr.get(arr.size()-1).left=null;\\n        arr.get(arr.size()-1).right=null;\\n        return arr.get(0);\\n    }\\n    void inorder(TreeNode node){\\n        if(node==null) return;\\n        inorder(node.left);\\n        arr.add(node);\\n        inorder(node.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301317,
                "title": "c-fastest-possible-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>v;\\n    dfs(root,v);\\n    TreeNode* ans= NULL;\\n    TreeNode* temp;\\n    for(auto x: v)\\n    {\\n        if(ans == NULL)\\n        {\\n            ans = new TreeNode(x);\\n            temp = ans;\\n        }\\n        else\\n        {\\n        temp->right= new TreeNode(x);\\n        temp = temp->right;\\n        }\\n        \\n    }\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node,vector<int>&v)\\n    {\\n        if(node==NULL)return;\\n\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>v;\\n    dfs(root,v);\\n    TreeNode* ans= NULL;\\n    TreeNode* temp;\\n    for(auto x: v)\\n    {\\n        if(ans == NULL)\\n        {\\n            ans = new TreeNode(x);\\n            temp = ans;\\n        }\\n        else\\n        {\\n        temp->right= new TreeNode(x);\\n        temp = temp->right;\\n        }\\n        \\n    }\\n        return ans;\\n    }\\n\\n    void dfs(TreeNode* node,vector<int>&v)\\n    {\\n        if(node==NULL)return;\\n\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227033,
                "title": "javascript-solution-beats-96-46-inorder-traversal-approach",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    const result = new TreeNode();\\n    let auxPointer = result;\\n    const inorderTraversal = (node) => {\\n        if (!node) return;\\n        inorderTraversal(node.left);\\n        auxPointer.right = new TreeNode(node.val);\\n        auxPointer = auxPointer.right;\\n        inorderTraversal(node.right);\\n    };\\n    inorderTraversal(root);\\n    return result.right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar increasingBST = function(root) {\\n    const result = new TreeNode();\\n    let auxPointer = result;\\n    const inorderTraversal = (node) => {\\n        if (!node) return;\\n        inorderTraversal(node.left);\\n        auxPointer.right = new TreeNode(node.val);\\n        auxPointer = auxPointer.right;\\n        inorderTraversal(node.right);\\n    };\\n    inorderTraversal(root);\\n    return result.right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3213293,
                "title": "java-easy-0ms-beats-100-simple-inorder",
                "content": "# Code\\n```\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode arr = new TreeNode(0, null, null);\\n    TreeNode pointer = arr;\\n    public TreeNode increasingBST(TreeNode root) {\\n        func(root);\\n        return arr.right;\\n    }\\n    void func (TreeNode root) {\\n        if (root==null) return;\\n        func(root.left);\\n        TreeNode temp = new TreeNode (root.val, null, null);\\n        pointer.right = temp;\\n        pointer = pointer.right;\\n        func(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213234,
                "title": "python-simple-tree-creation-inorder-traversal-modified",
                "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880173,
                "title": "0-ms-faster-than-100-java-solution",
                "content": "# Runtime: 0 ms, faster than 100.00% of Java online submissions for Increasing Order Search Tree.\\nMemory Usage: 39.7 MB, less than 94.59% of Java online submissions for Increasing Order Search Tree.\\n# class Solution {\\n    ArrayList<TreeNode> a=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        TreeNode t=a.get(0);\\n        TreeNode trav=t;\\n        int i=1;\\n        while(i<a.size())\\n        {\\n           trav.right=a.get(i);\\n            trav=trav.right;\\n            trav.left=null;\\n            i++;\\n        }\\n        return t;\\n    }\\n    public void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            a.add(root);\\n            inorder(root.right);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    ArrayList<TreeNode> a=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        if(root==null) return null;\\n        inorder(root);\\n        TreeNode t=a.get(0);\\n        TreeNode trav=t;\\n        int i=1;\\n        while(i<a.size())\\n        {\\n           trav.right=a.get(i);\\n            trav=trav.right;\\n            trav.left=null;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2681240,
                "title": "92-accepted-solution-simple-and-easy-approach-python",
                "content": "**Yes**, this is not optimized solution but easy to understand for beginners\\nIf you have any **doubts** or **suggestions** put in comments.\\n```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        def dfs(root, ans):\\n            if not root: return\\n            dfs(root.left, ans)\\n            ans.append(root.val)\\n            dfs(root.right, ans)\\n            return ans\\n        ans = dfs(root, [])\\n        root = right = TreeNode(0)\\n        for i in range(len(ans)):\\n            right.right = TreeNode(ans[i])\\n            right = right.right\\n        return root.right\\n```\\nPlease **UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def increasingBST(self, root):\\n        def dfs(root, ans):\\n            if not root: return\\n            dfs(root.left, ans)\\n            ans.append(root.val)\\n            dfs(root.right, ans)\\n            return ans\\n        ans = dfs(root, [])\\n        root = right = TreeNode(0)\\n        for i in range(len(ans)):\\n            right.right = TreeNode(ans[i])\\n            right = right.right\\n        return root.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518597,
                "title": "python-dfs-iterative",
                "content": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n        \"\"\"\\n        Without extra space\\n        Time -> O(logn)\\n        Space -> O(1) + O(n) (for new TreeNode)\\n        \"\"\"\\n        new = TreeNode()\\n        head = new\\n        def dfs(node):\\n            nonlocal new\\n            if node is None:\\n                return\\n            dfs(node.left)\\n            new.right = TreeNode(node.val)\\n            new = new.right\\n            dfs(node.right)\\n        dfs(root)\\n        return head.right\\n    \\n        \"\"\"\\n        With extra Space\\n        Time -> O(logn)\\n        x -> Number of not null element\\n        Space -> O(x) + O(n) (For new TreeNode)\\n            \"\"\"\\n        # q = []\\n        # def dfs(node):\\n        #     if node is None:\\n        #         return\\n        #     dfs(node.left)\\n        #     q.append(node.val)\\n        #     new = new.right\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # new = TreeNode(q.pop(0))\\n        # head = new\\n        # while q:\\n        #     new.right = TreeNode(q.pop(0))\\n        #     new = new.right\\n        # return head\\n```\\n\\n### \\uD83D\\uDE02 Random Dev Meme\\n<img src=\"https://random-memer.herokuapp.com/\" width=\"512px\"/>",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\ndef increasingBST(self, root: TreeNode) -> TreeNode:\\n        \"\"\"\\n        Without extra space\\n        Time -> O(logn)\\n        Space -> O(1) + O(n) (for new TreeNode)\\n        \"\"\"\\n        new = TreeNode()\\n        head = new\\n        def dfs(node):\\n            nonlocal new\\n            if node is None:\\n                return\\n            dfs(node.left)\\n            new.right = TreeNode(node.val)\\n            new = new.right\\n            dfs(node.right)\\n        dfs(root)\\n        return head.right\\n    \\n        \"\"\"\\n        With extra Space\\n        Time -> O(logn)\\n        x -> Number of not null element\\n        Space -> O(x) + O(n) (For new TreeNode)\\n            \"\"\"\\n        # q = []\\n        # def dfs(node):\\n        #     if node is None:\\n        #         return\\n        #     dfs(node.left)\\n        #     q.append(node.val)\\n        #     new = new.right\\n        #     dfs(node.right)\\n        # dfs(root)\\n        # new = TreeNode(q.pop(0))\\n        # head = new\\n        # while q:\\n        #     new.right = TreeNode(q.pop(0))\\n        #     new = new.right\\n        # return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2516557,
                "title": "c-solution-inorder-traversal-tree-building-easy-approach",
                "content": "Difficulty lvl : 3/10\\nConcept use : Inorder traversal & building binary tree\\nsource : \\n[https://www.youtube.com/watch?v=Z_NEgBgbRVI]\\n \\n```\\n// if it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left,ans);\\n        ans.push_back(root->val);\\n        inorder(root->right,ans);\\n    }\\n    \\n    TreeNode* helper(TreeNode* root,int num){\\n        // base case\\n        if(root == NULL){\\n            root = new TreeNode(num);\\n            return root;\\n        }\\n        \\n        if(root->val < num){\\n            root->right = helper(root->right,num);\\n        }\\n        else{\\n            root->left = helper(root->left,num);\\n        }\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root,ans);\\n        \\n        TreeNode* node = NULL;\\n        for(int i=0;i<ans.size();i++){\\n            int num = ans[i];\\n            node = helper(node,num);\\n        }\\n        \\n        return node;\\n    }\\n};\\n// if it help plz upvote :)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n// if it help plz upvote :)\\n\\nclass Solution {\\nprivate:\\n    void inorder(TreeNode* root,vector<int> &ans){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        inorder(root->left,ans);\\n        ans.push_back(root->val);\\n        inorder(root->right,ans);\\n    }\\n    \\n    TreeNode* helper(TreeNode* root,int num){\\n        // base case\\n        if(root == NULL){\\n            root = new TreeNode(num);\\n            return root;\\n        }\\n        \\n        if(root->val < num){\\n            root->right = helper(root->right,num);\\n        }\\n        else{\\n            root->left = helper(root->left,num);\\n        }\\n        \\n        return root;\\n    }\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root,ans);\\n        \\n        TreeNode* node = NULL;\\n        for(int i=0;i<ans.size();i++){\\n            int num = ans[i];\\n            node = helper(node,num);\\n        }\\n        \\n        return node;\\n    }\\n};\\n// if it help plz upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300088,
                "title": "0ms-c-inorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* main = new TreeNode(0);\\n    TreeNode* temp = main;\\n    void fill(TreeNode* root){\\n        if(root == NULL) return;\\n        fill(root -> left);\\n        main -> right = new TreeNode(root -> val);\\n        main -> left = NULL;\\n        main = main -> right;\\n        fill(root -> right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        fill(root);\\n        return temp -> right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* main = new TreeNode(0);\\n    TreeNode* temp = main;\\n    void fill(TreeNode* root){\\n        if(root == NULL) return;\\n        fill(root -> left);\\n        main -> right = new TreeNode(root -> val);\\n        main -> left = NULL;\\n        main = main -> right;\\n        fill(root -> right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        fill(root);\\n        return temp -> right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241653,
                "title": "c-solution-faster-than-100",
                "content": "```\\n void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* insert(TreeNode* root, int val)\\n    {\\n        if(root==NULL)\\n        {\\n            root = new TreeNode(val);\\n            return root;\\n        }\\n        if(root->val>val)\\n            root->left = insert(root->left,val);\\n        else\\n            root->right = insert(root->right,val);\\n        return root;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>vec;\\n        inorder(root,vec);\\n        root = NULL;\\n        for(int i=0;i<vec.size();i++)\\n            root = insert(root,vec[i]);\\n        return root;\\n    }\\n```\\n\\nIF YOU LIKE THE CODE, DO UPVOTE.",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n void inorder(TreeNode* root,vector<int>&vec)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,vec);\\n        vec.push_back(root->val);\\n        inorder(root->right,vec);\\n    }\\n    TreeNode* insert(TreeNode* root, int val)\\n    {\\n        if(root==NULL)\\n        {\\n            root = new TreeNode(val);\\n            return root;\\n        }\\n        if(root->val>val)\\n            root->left = insert(root->left,val);\\n        else\\n            root->right = insert(root->right,val);\\n        return root;\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        vector<int>vec;\\n        inorder(root,vec);\\n        root = NULL;\\n        for(int i=0;i<vec.size();i++)\\n            root = insert(root,vec[i]);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2215089,
                "title": "java-beats-java-submissions-0-ms",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n```\\nclass Solution {\\n    TreeNode prev;\\n    TreeNode ans;\\n    \\n    public TreeNode increasingBST(TreeNode node) {\\n        \\n        \\n        if (node==null){\\n            return null;\\n        }\\n        \\n        increasingBST(node.left);\\n               \\n        if (ans==null){\\n            ans=node;\\n        }\\n        else{\\n            prev.right=node;\\n        }\\n        \\n        prev=node;\\n        node.left=null;        \\n        \\n        increasingBST(node.right);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev;\\n    TreeNode ans;\\n    \\n    public TreeNode increasingBST(TreeNode node) {\\n        \\n        \\n        if (node==null){\\n            return null;\\n        }\\n        \\n        increasingBST(node.left);\\n               \\n        if (ans==null){\\n            ans=node;\\n        }\\n        else{\\n            prev.right=node;\\n        }\\n        \\n        prev=node;\\n        node.left=null;        \\n        \\n        increasingBST(node.right);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144503,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) ->  TreeNode:\\n        \\n        q = [root]\\n        lst = []\\n        \\n        while q:\\n            lst.append(q[0].val)\\n            \\n            if q[0].left:\\n                q.append(q[0].left)\\n                \\n            if q[0].right:\\n                q.append(q[0].right)\\n                \\n            q.pop(0)\\n            \\n        l = sorted(lst)\\n        root1 = TreeNode(l[0])\\n        \\n        def insert(root1 , val):\\n            if root1.right:\\n                return insert(root1.right , val)\\n            else:\\n                root1.right = TreeNode(val)\\n            \\n        for i in l[1:]:\\n            insert(root1,i)\\n        \\n        \\n        return root1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) ->  TreeNode:\\n        \\n        q = [root]\\n        lst = []\\n        \\n        while q:\\n            lst.append(q[0].val)\\n            \\n            if q[0].left:\\n                q.append(q[0].left)\\n                \\n            if q[0].right:\\n                q.append(q[0].right)\\n                \\n            q.pop(0)\\n            \\n        l = sorted(lst)\\n        root1 = TreeNode(l[0])\\n        \\n        def insert(root1 , val):\\n            if root1.right:\\n                return insert(root1.right , val)\\n            else:\\n                root1.right = TreeNode(val)\\n            \\n        for i in l[1:]:\\n            insert(root1,i)\\n        \\n        \\n        return root1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959751,
                "title": "simpler-java-solution-using-recursion-and-global-variable",
                "content": "start adding nodes as they come in inorder traversal to tempNode global variable. and keep building answer.\\n\\n```\\nclass Solution {\\n    private TreeNode newRoot = new TreeNode(-1);\\n\\tprivate TreeNode temp = newRoot;\\n\\n\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\thelper(root);\\n\\t\\treturn newRoot.right;\\n\\t}\\n\\n\\tprivate void helper(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\thelper(root.left);\\n\\t\\t//prepare templist\\n\\t\\ttemp.right = root;\\n\\t\\t//to avoid loop set left child false. it is already visited.\\n\\t\\troot.left = null;\\n\\t\\t//move temp list \\n\\t\\ttemp = temp.right;\\n\\t\\thelper(root.right);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode newRoot = new TreeNode(-1);\\n\\tprivate TreeNode temp = newRoot;\\n\\n\\tpublic TreeNode increasingBST(TreeNode root) {\\n\\t\\thelper(root);\\n\\t\\treturn newRoot.right;\\n\\t}\\n\\n\\tprivate void helper(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\thelper(root.left);\\n\\t\\t//prepare templist\\n\\t\\ttemp.right = root;\\n\\t\\t//to avoid loop set left child false. it is already visited.\\n\\t\\troot.left = null;\\n\\t\\t//move temp list \\n\\t\\ttemp = temp.right;\\n\\t\\thelper(root.right);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958177,
                "title": "typescript-recursive-solution",
                "content": "```\\nfunction findBiggest(root: TreeNode): TreeNode {\\n  if (root.right != null) {\\n    return findBiggest(root.right);\\n  }\\n\\n  return root;\\n}\\n\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n  if (root == null) {\\n    return null;\\n  }\\n\\n  let newRoot = root.left;\\n\\n  if (newRoot != null) {\\n    let newRootBiggest = findBiggest(newRoot);\\n    newRootBiggest.right = root;\\n    root.left = null;\\n\\n    return increasingBST(newRoot);\\n  }\\n\\n  root.right = increasingBST(root.right);\\n\\n  return root;\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction findBiggest(root: TreeNode): TreeNode {\\n  if (root.right != null) {\\n    return findBiggest(root.right);\\n  }\\n\\n  return root;\\n}\\n\\nfunction increasingBST(root: TreeNode | null): TreeNode | null {\\n  if (root == null) {\\n    return null;\\n  }\\n\\n  let newRoot = root.left;\\n\\n  if (newRoot != null) {\\n    let newRootBiggest = findBiggest(newRoot);\\n    newRootBiggest.right = root;\\n    root.left = null;\\n\\n    return increasingBST(newRoot);\\n  }\\n\\n  root.right = increasingBST(root.right);\\n\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1957849,
                "title": "java-100-faster-inorder-traversal",
                "content": "```\\nclass Solution {\\n    TreeNode tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        BST(root);\\n        return tree;\\n    }\\n    \\n    public void BST(TreeNode root) {\\n        if(root == null)  return;\\n        BST(root.right);\\n        tree = new TreeNode(root.val, null, tree);\\n        BST(root.left);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode tree;\\n    public TreeNode increasingBST(TreeNode root) {\\n        BST(root);\\n        return tree;\\n    }\\n    \\n    public void BST(TreeNode root) {\\n        if(root == null)  return;\\n        BST(root.right);\\n        tree = new TreeNode(root.val, null, tree);\\n        BST(root.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957605,
                "title": "897-increasing-order-search-tree-two-solution-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n \\n \\n \\n \\n \\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n\\t\\t\\n        TreeNode dummy= new TreeNode();\\n        TreeNode preNode = dummy;\\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(root!=null || !s.isEmpty()){\\n            \\n            while(root!=null){\\n                s.push(root);\\n                root=root.left;\\n            }\\n            \\n            if(!s.isEmpty()){\\n                root = s.pop();\\n                \\n                preNode.right = root;\\n                preNode = root;\\n                preNode.left = null;\\n                \\n                root=root.right;\\n                \\n            }\\n            \\n        }\\n        return dummy.right;\\n    }\\n    \\n    \\n \\n second using  inorder \\n    \\n       \\n//         List<Integer> ans = new ArrayList<>();\\n//         inorder(root,ans);\\n//         TreeNode result = new TreeNode(0);\\n//         TreeNode curr=result;\\n//         for(int i:ans){\\n//             curr.right=new TreeNode(i);\\n//             curr = curr.right;\\n//         }\\n        \\n//        return result.right;  \\n        \\n        \\n//     }\\n//     public void inorder(TreeNode root,List<Integer> ans ){\\n//         if(root==null) return ;\\n//         inorder(root.left,ans);\\n//         ans.add(root.val);\\n//         inorder(root.right,ans);\\n        \\n//     }\\n    \\n    \\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n \\n \\n \\n \\n \\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n\\t\\t\\n        TreeNode dummy= new TreeNode();\\n        TreeNode preNode = dummy;\\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(root!=null || !s.isEmpty()){\\n            \\n            while(root!=null){\\n                s.push(root);\\n                root=root.left;\\n            }\\n            \\n            if(!s.isEmpty()){\\n                root = s.pop();\\n                \\n                preNode.right = root;\\n                preNode = root;\\n                preNode.left = null;\\n                \\n                root=root.right;\\n                \\n            }\\n            \\n        }\\n        return dummy.right;\\n    }\\n    \\n    \\n \\n second using  inorder \\n    \\n       \\n//         List<Integer> ans = new ArrayList<>();\\n//         inorder(root,ans);\\n//         TreeNode result = new TreeNode(0);\\n//         TreeNode curr=result;\\n//         for(int i:ans){\\n//             curr.right=new TreeNode(i);\\n//             curr = curr.right;\\n//         }\\n        \\n//        return result.right;  \\n        \\n        \\n//     }\\n//     public void inorder(TreeNode root,List<Integer> ans ){\\n//         if(root==null) return ;\\n//         inorder(root.left,ans);\\n//         ans.add(root.val);\\n//         inorder(root.right,ans);\\n        \\n//     }\\n    \\n    \\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957514,
                "title": "increasing-order-search-tree",
                "content": "Simple c++ solution ---->\\n Using recursion\\n\\n\\n```\\n\\n       TreeNode* temp=NULL, *res = NULL;\\n     \\n    void inOrder(TreeNode* root){\\n               if(root==NULL) return;\\n        \\n        inOrder(root->left);\\n          \\n        if(res==NULL){\\n            res = new TreeNode(root->val);\\n            temp = res;\\n        }\\n        else {\\n            temp -> right = new TreeNode(root->val);\\n            temp= temp->right;\\n        }\\n        \\n    \\n         inOrder(root->right);\\n\\n        \\n    }\\n    \\n          \\n    TreeNode* increasingBST(TreeNode* root) {\\n           \\n           if(root==NULL) return NULL;\\n        inOrder(root);\\n        \\n        return res;\\n        \\n          \\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n       TreeNode* temp=NULL, *res = NULL;\\n     \\n    void inOrder(TreeNode* root){\\n               if(root==NULL) return;\\n        \\n        inOrder(root->left);\\n          \\n        if(res==NULL){\\n            res = new TreeNode(root->val);\\n            temp = res;\\n        }\\n        else {\\n            temp -> right = new TreeNode(root->val);\\n            temp= temp->right;\\n        }\\n        \\n    \\n         inOrder(root->right);\\n\\n        \\n    }\\n    \\n          \\n    TreeNode* increasingBST(TreeNode* root) {\\n           \\n           if(root==NULL) return NULL;\\n        inOrder(root);\\n        \\n        return res;\\n        \\n          \\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956490,
                "title": "2-solutions-c-explained-o-n",
                "content": "2  Approaches while solving this problem :\\n\\n1) using stack:\\n\\n*do reverse inorder traversal of elements and store them in stack (right->root->left) this will get all elements in stack in sorted order ->[1 2 3 4 5 6 7 8 9]\\n*iterate over stack elements, pop out top element->(1), make next top element as its right(1->2),and set its left to NULL\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        stack<TreeNode*> s;\\n        makestack(root,s);\\n        TreeNode *mainroot=s.top();\\n        while(!s.empty()){ //clear stack one by one  \\n            TreeNode *tempnode=s.top(); s.pop();\\n           if(!s.empty()) {\\n               tempnode->right=s.top();\\n               tempnode->left=NULL;\\n           }\\n            //when last element has been popped out \\n            else {\\n                tempnode->right=NULL;\\n                tempnode->left=NULL;\\n            }\\n        \\n        }\\n        return mainroot;\\n    }\\n    \\n    void makestack(TreeNode *root,stack<TreeNode*> &s){\\n        if(!root ) return ;\\n        makestack(root->right,s);\\n        s.push(root);\\n        makestack(root->left,s);\\n    }\\n};\\n```\\n\\n2) Using pointer to previous nodes :\\n```\\nclass Solution {\\npublic:\\n    TreeNode *mainroot=NULL;\\n    TreeNode *prev=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        return mainroot;\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        \\n        if(!root) return ;\\n        inorder(root->left);\\n\\t\\t//mainroot is the head of the new binary tree(leftmost node) \\n        if(!mainroot){\\n            mainroot=root;\\n            prev=root;\\n        }\\n        else {\\n\\t\\t//prev is the node traversed before current node \\n            prev->right=root;\\n\\t\\t//update prev for next traversal \\n            prev=root;\\n        }\\n        root->left=NULL;\\n        inorder(root->right);\\n    }\\n};\\n```\\n\\nPlease upvote if you found it helpful :)",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        stack<TreeNode*> s;\\n        makestack(root,s);\\n        TreeNode *mainroot=s.top();\\n        while(!s.empty()){ //clear stack one by one  \\n            TreeNode *tempnode=s.top(); s.pop();\\n           if(!s.empty()) {\\n               tempnode->right=s.top();\\n               tempnode->left=NULL;\\n           }\\n            //when last element has been popped out \\n            else {\\n                tempnode->right=NULL;\\n                tempnode->left=NULL;\\n            }\\n        \\n        }\\n        return mainroot;\\n    }\\n    \\n    void makestack(TreeNode *root,stack<TreeNode*> &s){\\n        if(!root ) return ;\\n        makestack(root->right,s);\\n        s.push(root);\\n        makestack(root->left,s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode *mainroot=NULL;\\n    TreeNode *prev=NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        return mainroot;\\n    }\\n    \\n    void inorder(TreeNode* root){\\n        \\n        if(!root) return ;\\n        inorder(root->left);\\n\\t\\t//mainroot is the head of the new binary tree(leftmost node) \\n        if(!mainroot){\\n            mainroot=root;\\n            prev=root;\\n        }\\n        else {\\n\\t\\t//prev is the node traversed before current node \\n            prev->right=root;\\n\\t\\t//update prev for next traversal \\n            prev=root;\\n        }\\n        root->left=NULL;\\n        inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956173,
                "title": "c-easy-soln-using-parent-pointer-recursive-inorder-traversal",
                "content": "```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *newRoot, *parent = nullptr;\\n        constructTree(root, &parent, &newRoot);\\n        parent->left = nullptr;/*Now parent have the last node.. so we make its left as null to avoid loop*/\\n        \\n        return newRoot;\\n    }\\n    /* This fn will do inorder traversal and update the nodes using parent pointer*/\\n    void constructTree(TreeNode* root, TreeNode** parent, TreeNode** newRoot) {\\n        if(root == nullptr) return;\\n        constructTree(root->left, parent, newRoot);///\\n        \\n        if(*parent != nullptr) { /* parent will have the just prev node in the inorder traversal\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*so its right should point to currNode.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*/\\n            (*parent)->right = root;\\n            (*parent)->left  = nullptr;\\n        }\\n        else /* If parent is null then this is the new root */\\n            *newRoot = root;\\n        *parent = root;\\n        \\n        constructTree(root->right, parent, newRoot);///\\n    }\\n```\\n**Upvote if u liked** :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *newRoot, *parent = nullptr;\\n        constructTree(root, &parent, &newRoot);\\n        parent->left = nullptr;/*Now parent have the last node.. so we make its left as null to avoid loop*/\\n        \\n        return newRoot;\\n    }\\n    /* This fn will do inorder traversal and update the nodes using parent pointer*/\\n    void constructTree(TreeNode* root, TreeNode** parent, TreeNode** newRoot) {\\n        if(root == nullptr) return;\\n        constructTree(root->left, parent, newRoot);///\\n        \\n        if(*parent != nullptr) { /* parent will have the just prev node in the inorder traversal\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*so its right should point to currNode.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t*/\\n            (*parent)->right = root;\\n            (*parent)->left  = nullptr;\\n        }\\n        else /* If parent is null then this is the new root */\\n            *newRoot = root;\\n        *parent = root;\\n        \\n        constructTree(root->right, parent, newRoot);///\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956113,
                "title": "inorder-traversal-c-with-and-without-extra-array",
                "content": "**APPROACH: 1 (USING EXTRA ARRAY)**\\n* Traverse the tree in inorder fashion, fill the array bucket.\\n* Inorder gives the sorted order.\\n* Create a new tree and Return its root.\\n\\n```\\n void inorder(TreeNode*root,vector<int>&in)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n        return;\\n    } \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        \\n        vector<int>in;\\n        inorder(root,in);\\n        TreeNode*curr=new TreeNode(in[0]);\\n        TreeNode*ans=curr;\\n        curr->left=NULL;\\n        for(int i=1;i<in.size();i++)\\n        {\\n           \\n            TreeNode*n=new TreeNode(in[i]);\\n            curr->right=n;\\n            curr->left=NULL;\\n            curr=curr->right;\\n        }\\n        return ans;\\n\\n        \\n    }\\n```\\n\\n**\\t**APPROACH 2: (WITHOUR ARRAY ONE TRAVERSAL)****\\n* Take a ans variable with dummy value which will move as current node of required tree.\\n* take a another res variable to store the root address of ans.\\n* Traverse the tree in inorderer fashion and attach the root->val to right of ans (ans->right)  and left equal to null.\\n* after completing return the right node of res  variable. (as first one is dummy node).\\n\\n\\n```\\n\\n    TreeNode* ans=new TreeNode(0);\\n    TreeNode* res=ans;\\n    \\n    void helper(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left);\\n        TreeNode*newt=new TreeNode(root->val);\\n        ans->right=newt;\\n        ans->left=NULL;\\n        ans=ans->right;\\n        helper(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        helper(root);\\n        return res->right;\\n    }\\n\\t```\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n void inorder(TreeNode*root,vector<int>&in)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n        return;\\n    } \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        \\n        vector<int>in;\\n        inorder(root,in);\\n        TreeNode*curr=new TreeNode(in[0]);\\n        TreeNode*ans=curr;\\n        curr->left=NULL;\\n        for(int i=1;i<in.size();i++)\\n        {\\n           \\n            TreeNode*n=new TreeNode(in[i]);\\n            curr->right=n;\\n            curr->left=NULL;\\n            curr=curr->right;\\n        }\\n        return ans;\\n\\n        \\n    }\\n```\n```\\n\\n    TreeNode* ans=new TreeNode(0);\\n    TreeNode* res=ans;\\n    \\n    void helper(TreeNode*root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left);\\n        TreeNode*newt=new TreeNode(root->val);\\n        ans->right=newt;\\n        ans->left=NULL;\\n        ans=ans->right;\\n        helper(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        helper(root);\\n        return res->right;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1956015,
                "title": "inorder-solution",
                "content": "First of all, we should notice that it follows Inorder traversal.\\nDeclare a global node variable, so that we may access throughout our program.\\nWe do our Inorder traversal as follow:-\\nvoid Inorder(root){\\n\\tif(root == NULL)\\n\\t\\t\\treturn;\\n\\t//we do recursive call upto leftmost node\\n\\tInorder(root->left)\\n\\t**//ab hmko process krna hai....**\\n\\t// chlo suru krte hai\\n    Inorder(root-> right)\\n}\\nyrr chl ab **process** krte hai..\\nJb recursively hm leftmost root pe pahuchte hai toh ...first make left of that root to **NULL**\\ni.e **root->left = NULL:**\\nab jo hmne global node bna rkha tha uske right me this root assign kr denge.\\ni.e **x->right = NULL;**\\nand then make sure ab uska right assign krdo..\\ni.e **x = x->right;**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *f;\\n    void inorder(TreeNode *root){\\n        if(root == NULL)\\n                return;\\n        inorder(root->left);\\n        root->left = NULL;\\n        f -> right = root;\\n        f = f->right;\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *temp = new TreeNode(0);\\n        f = temp;\\n        // temp = root;\\n        inorder(root);\\n        return temp->right;\\n        \\n    }\\n};\\n```\\n\\nDo upvote if u understand.",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *f;\\n    void inorder(TreeNode *root){\\n        if(root == NULL)\\n                return;\\n        inorder(root->left);\\n        root->left = NULL;\\n        f -> right = root;\\n        f = f->right;\\n        inorder(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode *temp = new TreeNode(0);\\n        f = temp;\\n        // temp = root;\\n        inorder(root);\\n        return temp->right;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955997,
                "title": "c-very-easy-to-understand-inorder-traversal",
                "content": "The idea is that we collect all node\\'s value in a vector in inorder.and make a new tree and return its root .\\n```\\nvoid inorder(TreeNode*root,vector<int>&v){\\n        if(!root) return ; \\n        if(root ->left) inorder(root ->left ,v) ;\\n        if(root) v.push_back(root -> val) ;\\n        if(root ->right)  inorder(root ->right,v) ;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == nullptr) return root ;\\n        vector<int> v ;\\n        inorder(root ,v);\\n        TreeNode *head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid inorder(TreeNode*root,vector<int>&v){\\n        if(!root) return ; \\n        if(root ->left) inorder(root ->left ,v) ;\\n        if(root) v.push_back(root -> val) ;\\n        if(root ->right)  inorder(root ->right,v) ;\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root == nullptr) return root ;\\n        vector<int> v ;\\n        inorder(root ,v);\\n        TreeNode *head = new TreeNode(v[0]);\\n        TreeNode * temp = head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right = new TreeNode(v[i]);\\n            temp = temp->right;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955975,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nTreeNode* ans = nullptr;\\nTreeNode* p = nullptr;\\nvoid solve(TreeNode* root){\\n\\tif(root==nullptr) return;\\n\\tincreasingBST(root->left);\\n\\tif(ans==nullptr){\\n\\t\\tans = new TreeNode(root->val);\\n\\t\\tp=ans;\\n\\t}\\n\\telse{\\n\\t\\tp->right = new TreeNode(root->val);\\n\\t\\tp=p->right;\\n\\t}\\n\\tcout<<root->val<<\" \";\\n\\tincreasingBST(root->right);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tsolve(root);\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nTreeNode* ans = nullptr;\\nTreeNode* p = nullptr;\\nvoid solve(TreeNode* root){\\n\\tif(root==nullptr) return;\\n\\tincreasingBST(root->left);\\n\\tif(ans==nullptr){\\n\\t\\tans = new TreeNode(root->val);\\n\\t\\tp=ans;\\n\\t}\\n\\telse{\\n\\t\\tp->right = new TreeNode(root->val);\\n\\t\\tp=p->right;\\n\\t}\\n\\tcout<<root->val<<\" \";\\n\\tincreasingBST(root->right);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tsolve(root);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1955897,
                "title": "python-recursive-iterative-stack-solutions-template-explained-similar-questions",
                "content": "My first thought regarding this problem is obviously the keyword `inorder`. This question asks us to convert the tree as a single linked-list-like structure.\\n\\nThis made me immediately thinking about the question that facebook used to ask during phone interviews: **0426.\\xA0Convert Binary Search Tree to Sorted Doubly Linked List** \\nWe use the `head`, `prev` pointer to track the process and easily re-construct the tree **in place** as a different structure: linked-list, which is almost the same as this question.\\n\\nSo in this question we also need to return the root of the new tree, which could be treated as the head of the linked-list.\\nBoth those two questions share similar structures after you find the similarity between them. \\n\\nThe only difference is that in this question, we should make sure it\\'s not a doubly-linked list and cannot have circle. Therefore, everytime we are dealing with the current node, we should: \\n* make sure `node.left == None`.\\n* When we are out of the loop and prev is pointing to the last node, we make sure to call `prev.left == None` again.\\n* For iterative and recursive solutions, making sure you have your own template to do both. It\\'s good to know both approaches and then you could easily refractor one to the other. I quote the \"dealing with current node part\" for both approaches so it\\'s easy to see the template. Hope this is helpful.\\n\\n**Iterative** - \\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n\\t\\t\\t# deal with current node\\n            if head == None:\\n                head = root\\n                head.left = None\\n            \\n            else:\\n                prev.left = None\\n                prev.right = root\\n            \\n            prev = root          \\n\\t\\t\\t# end of dealing with current node\\t\\t\\t\\n\\t\\t\\t\\n            root = root.right\\n        \\n        prev.left = None\\n        \\n        return head\\n```\\n\\n**Recursive** - \\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        def inorder(node):\\n            nonlocal head, prev\\n            \\n            if not node:\\n                return\\n            \\n            inorder(node.left)\\n            \\n            # dealing with current node\\n            if head == None:\\n                head = node\\n            \\n            else:\\n                prev.left = None\\n                prev.right = node\\n            \\n            prev = node\\n            # end of dealing with current node\\n            \\n            inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        prev.left = None\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        stack = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            \\n\\t\\t\\t# deal with current node\\n            if head == None:\\n                head = root\\n                head.left = None\\n            \\n            else:\\n                prev.left = None\\n                prev.right = root\\n            \\n            prev = root          \\n\\t\\t\\t# end of dealing with current node\\t\\t\\t\\n\\t\\t\\t\\n            root = root.right\\n        \\n        prev.left = None\\n        \\n        return head\\n```\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        # prev, curr\\n        if not root:\\n            return\\n        \\n        head, prev = None, None\\n        \\n        def inorder(node):\\n            nonlocal head, prev\\n            \\n            if not node:\\n                return\\n            \\n            inorder(node.left)\\n            \\n            # dealing with current node\\n            if head == None:\\n                head = node\\n            \\n            else:\\n                prev.left = None\\n                prev.right = node\\n            \\n            prev = node\\n            # end of dealing with current node\\n            \\n            inorder(node.right)\\n        \\n        inorder(root)\\n        \\n        prev.left = None\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955876,
                "title": "inorder-c-solution",
                "content": "```\\n void inorder(TreeNode*root,vector<int>&v){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return root;\\n        }\\n        vector<int>v;\\n        inorder(root,v);\\n       \\n        TreeNode* head= new TreeNode(v[0]);\\n        TreeNode*temp=head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n void inorder(TreeNode*root,vector<int>&v){\\n        if(root==NULL){\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL){\\n            return root;\\n        }\\n        vector<int>v;\\n        inorder(root,v);\\n       \\n        TreeNode* head= new TreeNode(v[0]);\\n        TreeNode*temp=head;\\n        for(int i=1;i<v.size();i++){\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1955671,
                "title": "cpp-2-sol-runtime-0-ms-faster-than-100-00",
                "content": "**Vector  approch**\\nclass Solution {\\npublic:\\n\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return ;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n         inorder(root);\\n        TreeNode *head = new TreeNode();\\n        TreeNode *it=head;\\n        for(auto x:v){\\n            it=it->right=new TreeNode(x);\\n        }\\n        return head->right;\\n    }\\n};\\n\\n**Inorder **\\nclass Solution {\\npublic:\\n\\n    TreeNode *head = new TreeNode();\\n    TreeNode *it=head;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return ;\\n        inorder(root->left);\\n        it->right = new TreeNode(root->val);\\n        it=it->right;\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* increasingBST(TreeNode* root) {\\n         inorder(root);\\n        return head->right;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return ;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1955584,
                "title": "increasing-order-search-tree-few-line",
                "content": "```\\nTreeNode *cur=new TreeNode();\\n    void ans(TreeNode *root){\\n        if(root==nullptr)return ;\\n        ans(root->left);\\n        auto newcur=new TreeNode();\\n        newcur->val=root->val;\\n        cur->right=newcur;\\n        cur=cur->right;\\n        ans(root->right);\\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        auto n = cur;\\n        ans(root);\\n        return n->right;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode *cur=new TreeNode();\\n    void ans(TreeNode *root){\\n        if(root==nullptr)return ;\\n        ans(root->left);\\n        auto newcur=new TreeNode();\\n        newcur->val=root->val;\\n        cur->right=newcur;\\n        cur=cur->right;\\n        ans(root->right);\\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        auto n = cur;\\n        ans(root);\\n        return n->right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1955547,
                "title": "simple-java-solution-100-faster-code",
                "content": "\\'\\'\\'\\n class Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root,null);\\n    }\\n    \\n    private TreeNode helper(TreeNode node,TreeNode next){\\n        if(next!=null){\\n            next.left=null;\\n        }\\n        if(node==null){\\n            return next;\\n        }\\n        node.right=helper(node.right,next);\\n        return helper(node.left,node);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        return helper(root,null);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1955051,
                "title": "java-inorder-tc-o-n-100-no-stack",
                "content": "```\\nclass Solution {\\n    TreeNode ret = null;\\n    TreeNode prev = null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) return null;\\n        increasingBST(root.left);\\n        \\n        if (ret == null) {\\n            ret = root;\\n            prev = root;\\n        }\\n        else if (prev != null) {\\n            prev.right = new TreeNode(root.val);\\n            prev = prev.right;\\n        }\\n                \\n        increasingBST(root.right);\\n        return ret;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode ret = null;\\n    TreeNode prev = null;\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) return null;\\n        increasingBST(root.left);\\n        \\n        if (ret == null) {\\n            ret = root;\\n            prev = root;\\n        }\\n        else if (prev != null) {\\n            prev.right = new TreeNode(root.val);\\n            prev = prev.right;\\n        }\\n                \\n        increasingBST(root.right);\\n        return ret;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955042,
                "title": "runtime-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root) return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root) return NULL;\\n        solve(root);\\n        TreeNode* n=new TreeNode(ans[0]);\\n        TreeNode* p=n;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            TreeNode* q=new TreeNode(ans[i]);\\n            p->right=q;\\n            p=q;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root) return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(!root) return NULL;\\n        solve(root);\\n        TreeNode* n=new TreeNode(ans[0]);\\n        TreeNode* p=n;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            TreeNode* q=new TreeNode(ans[i]);\\n            p->right=q;\\n            p=q;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752348,
                "title": "c-solution-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(TreeNode* root){ // finding inorder //\\n        if(!root)return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }\\n    \\n    TreeNode* tree(vector<int> &ans,int i,int &n){ // creating a tree with values present in vector\\n        if(i==n)return NULL; \\n        TreeNode* root = new TreeNode(ans[i]);\\n        root->left = nullptr;\\n        root->right = tree(ans,i+1,n);\\n        return root;\\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        solve(root);\\n        int n = ans.size();\\n        return tree(ans,0,n);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(TreeNode* root){ // finding inorder //\\n        if(!root)return;\\n        solve(root->left);\\n        ans.push_back(root->val);\\n        solve(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1744038,
                "title": "beginner-friendly-java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode collect;\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode res = new TreeNode();\\n        collect = res;\\n        BST(root);\\n        return res.right;\\n    }\\n    \\n    private void BST(TreeNode root){\\n        if(root == null)    return;\\n        BST(root.left);\\n        collect.right = new TreeNode(root.val);\\n        collect = collect.right;\\n        BST(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode collect;\\n    public TreeNode increasingBST(TreeNode root) {\\n        TreeNode res = new TreeNode();\\n        collect = res;\\n        BST(root);\\n        return res.right;\\n    }\\n    \\n    private void BST(TreeNode root){\\n        if(root == null)    return;\\n        BST(root.left);\\n        collect.right = new TreeNode(root.val);\\n        collect = collect.right;\\n        BST(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735569,
                "title": "another-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var array = [Int]()\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        helper(root)\\n        \\n        let first = TreeNode(0)\\n        var current: TreeNode? = first\\n        \\n        for val in array {\\n            current?.right = TreeNode(val)\\n            current = current?.right\\n        }\\n        \\n        return first.right\\n    }\\n    \\n    func helper(_ node: TreeNode?) {\\n        guard let node = node else { return }\\n        \\n        helper(node.left)\\n        array.append(node.val)\\n        helper(node.right)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var array = [Int]()\\n    \\n    func increasingBST(_ root: TreeNode?) -> TreeNode? {\\n        helper(root)\\n        \\n        let first = TreeNode(0)\\n        var current: TreeNode? = first\\n        \\n        for val in array {\\n            current?.right = TreeNode(val)\\n            current = current?.right\\n        }\\n        \\n        return first.right\\n    }\\n    \\n    func helper(_ node: TreeNode?) {\\n        guard let node = node else { return }\\n        \\n        helper(node.left)\\n        array.append(node.val)\\n        helper(node.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731515,
                "title": "c-simple-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    TreeNode *prev = NULL, *head = NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return root;\\n        \\n        increasingBST(root->left);\\n        \\n        if(prev == NULL)\\n            head = root;\\n        else\\n        {\\n            root->left = NULL;\\n            prev->right = root;\\n        }\\n        prev = root;\\n        \\n        increasingBST(root->right);\\n        \\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode *prev = NULL, *head = NULL;\\n    TreeNode* increasingBST(TreeNode* root) {\\n        \\n        if(root == NULL)\\n            return root;\\n        \\n        increasingBST(root->left);\\n        \\n        if(prev == NULL)\\n            head = root;\\n        else\\n        {\\n            root->left = NULL;\\n            prev->right = root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1593940,
                "title": "java-uzbcoder-100-understandable",
                "content": "```\\nclass Solution {\\n   TreeNode cur;\\n    public TreeNode increasingBST(TreeNode root) {   \\n         TreeNode result = new TreeNode(0); //new tree to return as result\\n         cur = result;            //we pass throw tree and tree will not change(go throw tree with reference) \\n        inorder(root, result);//inorder traversal\\n        return result.right;\\n    }\\n    public void insert(TreeNode result,int v){            \\n            cur.right = new TreeNode(v);\\n            cur.right.val=v; \\n            cur = cur.right;       \\n    }\\n    public void inorder(TreeNode node, TreeNode result) {\\n        if (node == null) return;\\n        inorder(node.left, result);\\n        insert(result, node.val);\\n        inorder(node.right, result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   TreeNode cur;\\n    public TreeNode increasingBST(TreeNode root) {   \\n         TreeNode result = new TreeNode(0); //new tree to return as result\\n         cur = result;            //we pass throw tree and tree will not change(go throw tree with reference) \\n        inorder(root, result);//inorder traversal\\n        return result.right;\\n    }\\n    public void insert(TreeNode result,int v){            \\n            cur.right = new TreeNode(v);\\n            cur.right.val=v; \\n            cur = cur.right;       \\n    }\\n    public void inorder(TreeNode node, TreeNode result) {\\n        if (node == null) return;\\n        inorder(node.left, result);\\n        insert(result, node.val);\\n        inorder(node.right, result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490540,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    List<Integer> temp=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        TreeNode node=new TreeNode(0);\\n        TreeNode curr=node;\\n        for(Integer x:temp){\\n            curr.right=new TreeNode(x);\\n            curr=curr.right;\\n        }\\n        return node.right;\\n    }\\n    public void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            temp.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<Integer> temp=new ArrayList<>();\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        TreeNode node=new TreeNode(0);\\n        TreeNode curr=node;\\n        for(Integer x:temp){\\n            curr.right=new TreeNode(x);\\n            curr=curr.right;\\n        }\\n        return node.right;\\n    }\\n    public void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            temp.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439968,
                "title": "basic-solution-python-recursion",
                "content": "```\\ndef inorder(root):\\n\\tif root==None:\\n\\t\\treturn\\n\\telse:\\n\\t\\tinorder(root.left)\\n\\t\\tarr.append(root.val)\\n\\t\\tinorder(root.right)\\ndef increasing(arr,root2,start):\\n\\tflag=0\\n\\tfor i in range(0,len(arr)):\\n\\t\\tele=TreeNode(arr[i])\\n\\t\\tele.left=None\\n\\t\\tele.right=None\\n\\t\\tif flag==0:\\n\\t\\t\\troot2=ele\\n\\t\\t\\tstart=ele\\n\\t\\t\\tflag=1\\n\\t\\telse:\\n\\t\\t\\tstart.right=ele\\n\\t\\t\\tstart=start.right\\n\\treturn root2\\narr=[]\\ninorder(root)\\nroot2=None\\nstart=None\\nroot=increasing(arr,root2,start)\\nreturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef inorder(root):\\n\\tif root==None:\\n\\t\\treturn\\n\\telse:\\n\\t\\tinorder(root.left)\\n\\t\\tarr.append(root.val)\\n\\t\\tinorder(root.right)\\ndef increasing(arr,root2,start):\\n\\tflag=0\\n\\tfor i in range(0,len(arr)):\\n\\t\\tele=TreeNode(arr[i])\\n\\t\\tele.left=None\\n\\t\\tele.right=None\\n\\t\\tif flag==0:\\n\\t\\t\\troot2=ele\\n\\t\\t\\tstart=ele\\n\\t\\t\\tflag=1\\n\\t\\telse:\\n\\t\\t\\tstart.right=ele\\n\\t\\t\\tstart=start.right\\n\\treturn root2\\narr=[]\\ninorder(root)\\nroot2=None\\nstart=None\\nroot=increasing(arr,root2,start)\\nreturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1397864,
                "title": "to-rearrange-the-tree-and-not-to-create-a-new-tree",
                "content": "The question is to rearrange the tree, and not to create a new tree. The optimized (space and time) solution.\\nP.S: Please don\\'t make it ugly with global variables\\n\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        TreeNode leftTree = increasingBST(root.left);\\n        if (leftTree != null) {\\n            TreeNode end = leftTree;\\n            while (end.right != null) {\\n                end = end.right;\\n            }\\n            end.right = root;\\n        } else {\\n            leftTree = root;\\n        }\\n        TreeNode rightTree = increasingBST(root.right);\\n        root.right = rightTree;\\n        root.left = null;\\n        return leftTree;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        TreeNode leftTree = increasingBST(root.left);\\n        if (leftTree != null) {\\n            TreeNode end = leftTree;\\n            while (end.right != null) {\\n                end = end.right;\\n            }\\n            end.right = root;\\n        } else {\\n            leftTree = root;\\n        }\\n        TreeNode rightTree = increasingBST(root.right);\\n        root.right = rightTree;\\n        root.left = null;\\n        return leftTree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304019,
                "title": "c-self-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root){\\n        if (root != NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root->val);\\n            inorder(root->right);\\n       }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        TreeNode *t=new TreeNode(0);\\n        TreeNode *q=t;\\n        for(int i=0;i<v.size();i++){\\n            t->right=new TreeNode(v[i],NULL,NULL);\\n            t=t->right;\\n        }\\n        return q->right;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root){\\n        if (root != NULL)\\n        {\\n            inorder(root->left);\\n            v.push_back(root->val);\\n            inorder(root->right);\\n       }\\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        inorder(root);\\n        TreeNode *t=new TreeNode(0);\\n        TreeNode *q=t;\\n        for(int i=0;i<v.size();i++){\\n            t->right=new TreeNode(v[i],NULL,NULL);\\n            t=t->right;\\n        }\\n        return q->right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229980,
                "title": "c-in-place-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        TreeNode* L=increasingBST(root->left);\\n        TreeNode* R=increasingBST(root->right);\\n        root->left=NULL;\\n        root->right=R;\\n        TreeNode *start=root,*end=root;\\n        if(L!=NULL){\\n            start=L,end=L;\\n            while(end->right!=NULL) end=end->right;\\n            end->right=root;\\n        }\\n        return start;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        TreeNode* L=increasingBST(root->left);\\n        TreeNode* R=increasingBST(root->right);\\n        root->left=NULL;\\n        root->right=R;\\n        TreeNode *start=root,*end=root;\\n        if(L!=NULL){\\n            start=L,end=L;\\n            while(end->right!=NULL) end=end->right;\\n            end->right=root;\\n        }\\n        return start;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218515,
                "title": "scala-immutable-recursion",
                "content": "\\n```scala\\nobject Solution {\\n\\n  def increasingBST(root: TreeNode): TreeNode = {\\n    def traverse(r: TreeNode, acc: List[Int] = Nil): List[Int] =\\n      if (r != null) traverse(r.left, acc) ++ List(r.value) ++ traverse(r.right, acc)\\n      else acc\\n\\n    def convert(xs: List[Int]): TreeNode = xs match {\\n      case Nil        => null\\n      case head :: tl => new TreeNode(head, null, convert(tl))\\n    }\\n\\n    convert(traverse(root))\\n  }\\n}\\n```\\n\\nNot as efficient in terms of space since we construct a List, but I think it\\'s quite readable.",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n\\n  def increasingBST(root: TreeNode): TreeNode = {\\n    def traverse(r: TreeNode, acc: List[Int] = Nil): List[Int] =\\n      if (r != null) traverse(r.left, acc) ++ List(r.value) ++ traverse(r.right, acc)\\n      else acc\\n\\n    def convert(xs: List[Int]): TreeNode = xs match {\\n      case Nil        => null\\n      case head :: tl => new TreeNode(head, null, convert(tl))\\n    }\\n\\n    convert(traverse(root))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1212169,
                "title": "c-0ms-solution-with-intuition",
                "content": "## Intuition\\nThe question is to return the tree in inorder, with every node having null as their left child and only the right child. To return the correct order, we will need to return the leftmost node of the left subtree of the root, and modify the children, so that the right child points to the next node in the order.\\n\\nFor any node, there can be four cases:\\n\\n**1. It is a leaf node:**\\nIn this case, we have to link its right pointer to either its parent (if it was a left child) or to its grandparent (if it was a right child). For this purpose, we have a pointer prev that points to the required node to be assigned as the right child of the current node.\\n\\n**2. It only has left child:**\\nIn this case, the current node will become the right child of it\\'s left child, and the parent of the node pointed to by prev. We return the leftmost node in root\\'s left subtree as the answer.\\n\\n**3.  It only has right child:**\\nIn this case, we just call the function recursively on the right subtree with prev as root\\'s value of prev, so that it gets its grandparent (if root was a left child), or great-grandfather (if root was a right child), and set the result as the right child of the current node.\\n\\n**4. It has both left and right children:**\\nIn this case, we combine both the previous cases, we recurse on the left subtree, get the leftmost node of the left subtree returned from it (which will be returned as the new root), and recurse on the right subtree with prev as the second parameter, and set its result to be the right child of the current node.\\n\\nTry dry-running it on some test-cases if you are finding it difficult to understand.\\n<br> \\n\\n## Code\\t\\n```\\nTreeNode *inorder(TreeNode *root, TreeNode *prev) {\\n\\tif(!root) return root;\\n\\tif(!root->left && !root->right) {\\n\\t\\troot->right = prev;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->left) {\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->right) {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\troot->right = prev;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n\\telse {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n}\\n\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *newRoot = inorder(root, nullptr);\\n\\treturn newRoot;\\n}\\n```\\n\\n<br>\\n\\n## Complexity\\n\\n**Time: O(n)** as we traverse the whole tree just once.\\n**Space: O(n)** again, as we will call the function once for each node, so stack space is O(n), other than that the space used is O(1).\\n\\n\\n## Conclusion\\nIn conclusion, this wasn\\'t such an easy problem, but not a hard one either. It should have been a medium problem.\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode *inorder(TreeNode *root, TreeNode *prev) {\\n\\tif(!root) return root;\\n\\tif(!root->left && !root->right) {\\n\\t\\troot->right = prev;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->left) {\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn root;\\n\\t}\\n\\telse if(!root->right) {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\troot->right = prev;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n\\telse {\\n\\t\\tTreeNode *leftLeftmost = inorder(root->left, root);\\n\\t\\tTreeNode *rightLeftmost = inorder(root->right, prev);\\n\\t\\troot->right = rightLeftmost;\\n\\t\\troot->left = nullptr;\\n\\t\\treturn leftLeftmost;\\n\\t}\\n}\\n\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *newRoot = inorder(root, nullptr);\\n\\treturn newRoot;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174964,
                "title": "rust",
                "content": "```rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn increasing_bst(mut root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut stack = Vec::new();\\n        let mut dm = Rc::new(RefCell::new(TreeNode::new(0)));\\n        let mut cur = Rc::clone(&dm);\\n\\n        while !stack.is_empty() || root.is_some() {\\n            while let Some(node) = root {\\n                root = node.borrow_mut().left.take();\\n                stack.push(node);\\n            }\\n\\n            if let Some(node) = stack.pop() {\\n                root = node.borrow_mut().right.take();\\n                node.borrow_mut().left = None;\\n                cur.borrow_mut().right = Some(Rc::clone(&node));\\n                cur = node;\\n            }\\n        }\\n\\n        let head = dm.borrow_mut().right.take();\\n        head\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust []\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn increasing_bst(mut root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut stack = Vec::new();\\n        let mut dm = Rc::new(RefCell::new(TreeNode::new(0)));\\n        let mut cur = Rc::clone(&dm);\\n\\n        while !stack.is_empty() || root.is_some() {\\n            while let Some(node) = root {\\n                root = node.borrow_mut().left.take();\\n                stack.push(node);\\n            }\\n\\n            if let Some(node) = stack.pop() {\\n                root = node.borrow_mut().right.take();\\n                node.borrow_mut().left = None;\\n                cur.borrow_mut().right = Some(Rc::clone(&node));\\n                cur = node;\\n            }\\n        }\\n\\n        let head = dm.borrow_mut().right.take();\\n        head\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170797,
                "title": "java-0ms-inorder-traversal",
                "content": "```\\nclass Solution {\\n    TreeNode prev,first;\\n    public Solution(){\\n        prev=new TreeNode(-1,null,null);\\n        first=null;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root!=null)\\n        {\\n            inorder(root.left);           \\n            prev.right=new TreeNode(root.val,null,null);\\n            prev=prev.right;\\n            first=(first==null)?prev:first;\\n            inorder(root.right);\\n        }\\n    }\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode prev,first;\\n    public Solution(){\\n        prev=new TreeNode(-1,null,null);\\n        first=null;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root!=null)\\n        {\\n            inorder(root.left);           \\n            prev.right=new TreeNode(root.val,null,null);\\n            prev=prev.right;\\n            first=(first==null)?prev:first;\\n            inorder(root.right);\\n        }\\n    }\\n    public TreeNode increasingBST(TreeNode root) {\\n        inorder(root);\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113461,
                "title": "java-solution-using-list-and-iterative-pointer-relinking",
                "content": "**Using List**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<TreeNode> list = new ArrayList<>();\\n        helper(root, list);\\n        \\n        TreeNode head = new TreeNode(-1);\\n        TreeNode dummy = head;\\n        for (TreeNode node : list){\\n            dummy.right = node;\\n            dummy = dummy.right;\\n            dummy.left = null;\\n        }\\n        return head.right;\\n    }\\n    \\n    public void helper(TreeNode node, List<TreeNode> list){\\n        if (node == null) return;\\n        helper(node.left, list);\\n        list.add(node);\\n        helper(node.right, list);\\n    }\\n}\\n```\\n\\n**Iterative Solution**\\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        if (root == null)        return null;\\n        \\n        LinkedList<TreeNode> stack = new LinkedList<>();\\n        TreeNode node = root;\\n        TreeNode prevNode = null;\\n        TreeNode head = null;\\n        \\n        while (!stack.isEmpty() || node != null){\\n            // go all the way to the left\\n            \\n            while(node != null){\\n                stack.push(node);\\n                node = node.left;\\n            }\\n            \\n            // get the current node\\n            // you can print or add to result for inorder\\n            node = stack.pop();\\n               \\n            if (head == null) head = node;\\n            if (prevNode != null){\\n                prevNode.right = node;\\n                node.left = null;\\n            }\\n            prevNode = node;\\n            // make the node point to the right\\n            node = node.right;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        List<TreeNode> list = new ArrayList<>();\\n        helper(root, list);\\n        \\n        TreeNode head = new TreeNode(-1);\\n        TreeNode dummy = head;\\n        for (TreeNode node : list){\\n            dummy.right = node;\\n            dummy = dummy.right;\\n            dummy.left = null;\\n        }\\n        return head.right;\\n    }\\n    \\n    public void helper(TreeNode node, List<TreeNode> list){\\n        if (node == null) return;\\n        helper(node.left, list);\\n        list.add(node);\\n        helper(node.right, list);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        \\n        if (root == null)        return null;\\n        \\n        LinkedList<TreeNode> stack = new LinkedList<>();\\n        TreeNode node = root;\\n        TreeNode prevNode = null;\\n        TreeNode head = null;\\n        \\n        while (!stack.isEmpty() || node != null){\\n            // go all the way to the left\\n            \\n            while(node != null){\\n                stack.push(node);\\n                node = node.left;\\n            }\\n            \\n            // get the current node\\n            // you can print or add to result for inorder\\n            node = stack.pop();\\n               \\n            if (head == null) head = node;\\n            if (prevNode != null){\\n                prevNode.right = node;\\n                node.left = null;\\n            }\\n            prevNode = node;\\n            // make the node point to the right\\n            node = node.right;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018084,
                "title": "simple-c-without-creating-new-node",
                "content": "```\\nvoid inorder(TreeNode *root,TreeNode *&prev)\\n{\\n\\tif(root==NULL)\\n\\t\\treturn ;\\n\\tinorder(root->left,prev);\\n\\tif(prev!=NULL)\\n\\t{\\n\\t\\tprev->right=root;\\n\\t\\troot->left=NULL;\\n\\t}\\n\\tprev=root;\\n\\tinorder(root->right,prev);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *prev=NULL,*node=root;\\n\\twhile(node->left!=NULL)\\n\\t\\tnode=node->left;\\n\\tinorder(root,prev);\\n\\treturn node;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid inorder(TreeNode *root,TreeNode *&prev)\\n{\\n\\tif(root==NULL)\\n\\t\\treturn ;\\n\\tinorder(root->left,prev);\\n\\tif(prev!=NULL)\\n\\t{\\n\\t\\tprev->right=root;\\n\\t\\troot->left=NULL;\\n\\t}\\n\\tprev=root;\\n\\tinorder(root->right,prev);\\n}\\nTreeNode* increasingBST(TreeNode* root) {\\n\\tTreeNode *prev=NULL,*node=root;\\n\\twhile(node->left!=NULL)\\n\\t\\tnode=node->left;\\n\\tinorder(root,prev);\\n\\treturn node;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959065,
                "title": "java-stack-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> s  = new Stack<>(); \\n        TreeNode res=null;\\n        TreeNode prev = null ;\\n        while(!s.isEmpty() || root!=null){\\n            while(root!=null){\\n                s.push(root); \\n                root = root.left;\\n            }\\n            root = s.pop(); \\n            if(prev ==null) {\\n                prev = root;\\n                res = root; \\n                }\\n            else{\\n                root.left = null ; \\n                prev.right = root; \\n                prev = prev.right; \\n            }\\n            root = root.right; \\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode increasingBST(TreeNode root) {\\n        Stack<TreeNode> s  = new Stack<>(); \\n        TreeNode res=null;\\n        TreeNode prev = null ;\\n        while(!s.isEmpty() || root!=null){\\n            while(root!=null){\\n                s.push(root); \\n                root = root.left;\\n            }\\n            root = s.pop(); \\n            if(prev ==null) {\\n                prev = root;\\n                res = root; \\n                }\\n            else{\\n                root.left = null ; \\n                prev.right = root; \\n                prev = prev.right; \\n            }\\n            root = root.right; \\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959035,
                "title": "0ms-o-n-c-inorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &start)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,start);\\n        start->right=new TreeNode(root->val);\\n        start=start->right;\\n        inorder(root->right,start);\\n        \\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* start=new TreeNode(0);\\n        TreeNode* ans=start;\\n        inorder(root,start);\\n        return ans->right;\\n        \\n    }\\n};\\n```\\n*Using pass by reference, the runtime is further reduced.*\\nUpvote if you like the solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, TreeNode* &start)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,start);\\n        start->right=new TreeNode(root->val);\\n        start=start->right;\\n        inorder(root->right,start);\\n        \\n        \\n    }\\n    TreeNode* increasingBST(TreeNode* root) {\\n        TreeNode* start=new TreeNode(0);\\n        TreeNode* ans=start;\\n        inorder(root,start);\\n        return ans->right;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958986,
                "title": "python-3-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=vABwsgqI-_4)\\nhttps://www.youtube.com/watch?v=vABwsgqI-_4\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        if not root:\\n            return None\\n        \\n        dummy = curr = TreeNode()\\n        stack = []\\n        \\n        while stack or root:\\n            \\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            curr.right = root\\n            \\n            curr = curr.right\\n            root = root.right\\n            \\n            curr.left = None\\n        \\n        return dummy.right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        if not root:\\n            return None\\n        \\n        dummy = curr = TreeNode()\\n        stack = []\\n        \\n        while stack or root:\\n            \\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            curr.right = root\\n            \\n            curr = curr.right\\n            root = root.right\\n            \\n            curr.left = None\\n        \\n        return dummy.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958857,
                "title": "java-in-order-traversal-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    //dummy goes down the TreeNode\\n    public TreeNode dummy = new TreeNode(0);\\n    public TreeNode increasingBST(TreeNode root) {\\n        //strategy: In Order Traversal\\n        TreeNode answer = dummy;\\n        //traverse each node\\n        helper(root);\\n        return answer.right;\\n    }\\n    public void helper(TreeNode root) {\\n        //not possible\\n        if (root == null) {\\n            return;\\n        }\\n        //first go to the left\\n        helper(root.left);\\n        //set up right and left\\n        dummy.right = new TreeNode(root.val);\\n        dummy.left = null;\\n        //move dummy to the right\\n        dummy = dummy.right;\\n        //traverse right\\n        helper(root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    //dummy goes down the TreeNode\\n    public TreeNode dummy = new TreeNode(0);\\n    public TreeNode increasingBST(TreeNode root) {\\n        //strategy: In Order Traversal\\n        TreeNode answer = dummy;\\n        //traverse each node\\n        helper(root);\\n        return answer.right;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 958809,
                "title": "ruby-o-n",
                "content": "```\\ndef increasing_bst(root, tail = nil)\\n  return tail unless root\\n  \\n  result = increasing_bst(root.left, root)\\n  root.left = nil\\n  root.right = increasing_bst(root.right, tail)\\n  \\n  result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef increasing_bst(root, tail = nil)\\n  return tail unless root\\n  \\n  result = increasing_bst(root.left, root)\\n  root.left = nil\\n  root.right = increasing_bst(root.right, tail)\\n  \\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 927045,
                "title": "java-inverse-inorder-traversal-100-faster",
                "content": "\\nSince you already might know, an inorder traversal prints elements in an increasing order i.e. `root.left` -> `root` -> `root.right`, the inverse would print in the decreasing order i.e. `root.right` -> `root` -> `root.left`. \\n\\nYou can imagine the output to be a descending order list, with every element pointing to its previous element.\\nSo, all we have to do is bind the previous node to its right and point the left to `null`.\\n\\nBelow is the code.\\n\\n```\\nclass Solution {\\n    \\n    private TreeNode prevNode = null;\\n    \\n    private void inorderTraversal(TreeNode root) {\\n        \\n        if(root != null) {\\n            \\n            inorderTraversal(root.right);\\n\\t\\t\\t\\n            root.right = prevNode;\\n            prevNode = root;\\n\\t\\t\\t\\n            inorderTraversal(root.left);\\n\\t\\t\\t\\n            root.left = null;\\n        }\\n        \\n    }\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        inorderTraversal(root);\\n        return prevNode;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private TreeNode prevNode = null;\\n    \\n    private void inorderTraversal(TreeNode root) {\\n        \\n        if(root != null) {\\n            \\n            inorderTraversal(root.right);\\n\\t\\t\\t\\n            root.right = prevNode;\\n            prevNode = root;\\n\\t\\t\\t\\n            inorderTraversal(root.left);\\n\\t\\t\\t\\n            root.left = null;\\n        }\\n        \\n    }\\n    \\n    public TreeNode increasingBST(TreeNode root) {\\n        inorderTraversal(root);\\n        return prevNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914176,
                "title": "c-100-faster-runtime-sadly-at-the-cost-of-some-space",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        vector<int> node_values;\\n        helper(root, node_values);\\n        \\n        TreeNode *def = new TreeNode(0);\\n        TreeNode *res = def;\\n        \\n        for(auto node_val : node_values )\\n        {\\n            res->right = new TreeNode(node_val);\\n            res = res->right;\\n        }\\n        \\n        return def->right;\\n        \\n    }\\n    \\n    void helper(TreeNode *root, vector<int> &temp)\\n    {\\n        if(!root) return;\\n        \\n        helper(root->left, temp);\\n        temp.push_back(root->val);\\n        helper(root->right, temp);\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) \\n    {\\n        vector<int> node_values;\\n        helper(root, node_values);\\n        \\n        TreeNode *def = new TreeNode(0);\\n        TreeNode *res = def;\\n        \\n        for(auto node_val : node_values )\\n        {\\n            res->right = new TreeNode(node_val);\\n            res = res->right;\\n        }\\n        \\n        return def->right;\\n        \\n    }\\n    \\n    void helper(TreeNode *root, vector<int> &temp)\\n    {\\n        if(!root) return;\\n        \\n        helper(root->left, temp);\\n        temp.push_back(root->val);\\n        helper(root->right, temp);\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848267,
                "title": "explan-every-step-easley",
                "content": "# idea is reach  left side until None  and pop one by one node and next reach right side of pop node \\n\\n```\\nif (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n\\n```\\n# this part try to reach left side where low value is available\\n```\\nnode=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n\\n```\\n# above section when i reach last left position then required pop the value from stack and make a tree\\n# i==0 means we come here first time and put the value root which i return and with dummy variable for pointing next node\\n```\\n\\nx.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n\\n```\\n# when i came here second time we need set the node right side according to questions and next time pop  node attached this node so (x=node) and this most careful thing when youe add pop node then this node come with his left node that reason (x.left=None)\\n\\n# ( temp=node.right) searching right side of pop node \\n\\n```\\n# python code iterative way\\n\\n        if root==None:\\n            return root\\n        stack=[]\\n        x=temp=root\\n        i=0\\n        while(stack or temp):\\n            if (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n            else:\\n                node=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n                else:\\n                    x.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n        return root\\n            \\n```\\n\\n```\\n# Recursive way\\ndef inorder(node):\\n            if node:\\n                inorder(node.left)\\n                node.left = None\\n                self.cur.right =  node\\n                self.cur = node\\n                inorder(node.right)\\n                \\n        self.cur = ans = TreeNode(None)        \\n        inorder(root)\\n        return ans.right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nif (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n\\n```\n```\\nnode=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n\\n```\n```\\n\\nx.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n\\n```\n```\\n# python code iterative way\\n\\n        if root==None:\\n            return root\\n        stack=[]\\n        x=temp=root\\n        i=0\\n        while(stack or temp):\\n            if (temp):\\n                stack.append(temp)\\n                temp=temp.left\\n            else:\\n                node=stack.pop()\\n                if i==0:\\n                    x=root=node\\n                    i+=1\\n                else:\\n                    x.right=node\\n                    x=node\\n                    x.left=None\\n                temp=node.right\\n        return root\\n            \\n```\n```\\n# Recursive way\\ndef inorder(node):\\n            if node:\\n                inorder(node.left)\\n                node.left = None\\n                self.cur.right =  node\\n                self.cur = node\\n                inorder(node.right)\\n                \\n        self.cur = ans = TreeNode(None)        \\n        inorder(root)\\n        return ans.right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 844808,
                "title": "c-0ms-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) return nullptr;\\n        else if (!root->left && !root->right) return root;\\n        else if (!root->left) {\\n            root->right = increasingBST(root->right);\\n            return root;\\n        }\\n        else {\\n            TreeNode* newroot = increasingBST(root->left);\\n            root->left = nullptr;\\n            TreeNode* tmp = newroot;\\n            while (tmp->right) {\\n                tmp = tmp->right;\\n            }\\n            tmp->right = increasingBST(root);\\n            return newroot;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root) {\\n        if (!root) return nullptr;\\n        else if (!root->left && !root->right) return root;\\n        else if (!root->left) {\\n            root->right = increasingBST(root->right);\\n            return root;\\n        }\\n        else {\\n            TreeNode* newroot = increasingBST(root->left);\\n            root->left = nullptr;\\n            TreeNode* tmp = newroot;\\n            while (tmp->right) {\\n                tmp = tmp->right;\\n            }\\n            tmp->right = increasingBST(root);\\n            return newroot;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565100,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567121,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567397,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1566533,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572470,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1783474,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1573055,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1728240,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1683393,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572115,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1565100,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567121,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1567397,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1566533,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572470,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1783474,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1573055,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1728240,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1683393,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            },
            {
                "id": 1572115,
                "content": [
                    {
                        "username": "NewbieIntern",
                        "content": "Hi all, this might be a stupid question, but I am just so stuck.\\nSo I got an TLE error when submitting my code. The test case input is\\n[379\\n826]\\n(in this format). So what does this mean? I used this input and got error as follows:\\n\\nYour answer\\nJSON string [[379] is not a full JSON packet, more bytes expected.\\nExpected answer\\nLine 59: ValueError: Expecting object: line 1 column 4 (char 3)\\n\\nThis is so confusing, what does this test case mean?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/increasing-order-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** In-Order Traversal\n\n  \n**Approach 2:** Traversal with Relinking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "sunnypatel165",
                        "content": "The statement says that the input is a BST whereas its not. The following is an input, where the LeftChild>root and the sample input says LeftChild < root. \\n![image](https://assets.leetcode.com/users/sunnypatel165/image_1563546858.png)\\n"
                    },
                    {
                        "username": "myleetc",
                        "content": "Input:\\n[379, 826]\\nVisualize\\nOutput:\\n[379,null,826]\\nVisualize\\nExpected:\\n[826,null,379]\\nVisualize\\n"
                    },
                    {
                        "username": "turkuzan",
                        "content": "Input\\n[379,826]\\nOutput\\n[379,null,826]\\nExpected\\n[826,null,379]\\n\\nisn\\'t it increasing order?????\\nMy output is correct but expected is not correct.\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "Neuroprophet",
                        "content": "37 out of 38 test cases passed.\\nAt 38th I got \"Error - Found cycle in the TreeNode\".\\n\\nWhat is it and why did I get it?"
                    },
                    {
                        "username": "furrukhkhan10",
                        "content": "same problem. did you figure out the issue?"
                    },
                    {
                        "username": "souravedu87",
                        "content": "Did you figure out the issue ?"
                    },
                    {
                        "username": "dasavisha10",
                        "content": "One of the input is wrong in this example.\\n[379,826]  -- this input should actually be [379, null, 826] since the input is Binary Search Tree."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "Hi!, How can I implement this problem? I have successfully traversed using dfs and I am getting this output:\\n\\n5-->3-->2-->1-->4-->6-->8-->7-->9-->\\n\\nBut now how can I make this as an increasing order BST?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I guess you have applied `PreOrder Traversal`, while you should have applied `InOrder Traversal`. "
                    },
                    {
                        "username": "mochiball",
                        "content": "I used DFS in-order traversal"
                    },
                    {
                        "username": "tonymugendi",
                        "content": "[@Prajju22](/Prajju22) Use DFS In-order traversal"
                    },
                    {
                        "username": "Prajju22",
                        "content": "first either sort or traverse in left root right way to get sorted element and then form right skewed tree\\n"
                    },
                    {
                        "username": "code_report",
                        "content": "Hopefully this contest will go unrated, I am sure many finished the question shortly after the update."
                    }
                ]
            }
        ]
    },
    {
        "title": "Get Watched Videos by Your Friends",
        "question_content": "<p>There are <code>n</code> people, each person has a unique <em>id</em> between <code>0</code> and <code>n-1</code>. Given the arrays <code>watchedVideos</code> and <code>friends</code>, where <code>watchedVideos[i]</code> and <code>friends[i]</code> contain the list of watched videos and the list of friends respectively for the person with <code>id = i</code>.</p>\n\n<p>Level <strong>1</strong> of videos are all watched videos by your&nbsp;friends, level <strong>2</strong> of videos are all watched videos by the friends of your&nbsp;friends and so on. In general, the level <code>k</code> of videos are all&nbsp;watched videos by people&nbsp;with the shortest path <strong>exactly</strong> equal&nbsp;to&nbsp;<code>k</code> with you. Given your&nbsp;<code>id</code> and the <code>level</code> of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_1.png\" style=\"width: 144px; height: 200px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\n<strong>Output:</strong> [&quot;B&quot;,&quot;C&quot;] \n<strong>Explanation:</strong> \nYou have id = 0 (green color in the figure) and your friends are (yellow color in the figure):\nPerson with id = 1 -&gt; watchedVideos = [&quot;C&quot;]&nbsp;\nPerson with id = 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;]&nbsp;\nThe frequencies of watchedVideos by your friends are:&nbsp;\nB -&gt; 1&nbsp;\nC -&gt; 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_2.png\" style=\"width: 144px; height: 200px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\n<strong>Output:</strong> [&quot;D&quot;]\n<strong>Explanation:</strong> \nYou have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == watchedVideos.length ==&nbsp;friends.length</code></li>\n\t<li><code>2 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;watchedVideos[i][j].length &lt;= 8</code></li>\n\t<li><code>0 &lt;= friends[i].length &lt; n</code></li>\n\t<li><code>0 &lt;= friends[i][j]&nbsp;&lt; n</code></li>\n\t<li><code>0 &lt;= id &lt; n</code></li>\n\t<li><code>1 &lt;= level &lt; n</code></li>\n\t<li>if&nbsp;<code>friends[i]</code> contains <code>j</code>, then <code>friends[j]</code> contains <code>i</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 470695,
                "title": "c-bfs-sort",
                "content": "**Observation**\\nWe can use a simple BFS to get to the required level of the graph nodes and any type of sorting to yeild resulting `watchedVideos` sorted by frequencies.\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    queue<int> q;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<bool> visited(friends.size(),false);      //To track the visited `friends`\\n        unordered_map<string,int> count;        // Stores the frequency of all the  `watchedVideos` by a freind at required level\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> result;\\n        q.push(id);                  //Push initial node/friend id.\\n        visited[id]=true;            \\n        while(!q.empty()&&level--)\\t{\\t\\t\\t//BFS to get to the level.\\n            for(int i=q.size();i;q.pop(),i--) {\\n                for(int &i:friends[q.front()])\\n                    if(!visited[i]) {\\n                        visited[i]=true;\\n                        q.push(i);\\n                    }\\n            }\\n        }\\n        while(!q.empty()) {                      //The queue at this moment will only have all the friends at required level\\n            for(string &s:watchedVideos[q.front()])\\n                count[s]++;\\n            q.pop();\\n        }\\n        for(auto it=count.begin();it!=count.end();it++) //Add results to the vector to sort by frequency first and then the string.\\n            resultPairs.push_back({it->second,it->first});\\n        sort(resultPairs.begin(),resultPairs.end());\\n        transform(resultPairs.begin(),resultPairs.end(),back_inserter(result),[](pair<int,string>&p){return p.second;}); //Transform the pairs to result\\n        return result;            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    queue<int> q;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<bool> visited(friends.size(),false);      //To track the visited `friends`\\n        unordered_map<string,int> count;        // Stores the frequency of all the  `watchedVideos` by a freind at required level\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> result;\\n        q.push(id);                  //Push initial node/friend id.\\n        visited[id]=true;            \\n        while(!q.empty()&&level--)\\t{\\t\\t\\t//BFS to get to the level.\\n            for(int i=q.size();i;q.pop(),i--) {\\n                for(int &i:friends[q.front()])\\n                    if(!visited[i]) {\\n                        visited[i]=true;\\n                        q.push(i);\\n                    }\\n            }\\n        }\\n        while(!q.empty()) {                      //The queue at this moment will only have all the friends at required level\\n            for(string &s:watchedVideos[q.front()])\\n                count[s]++;\\n            q.pop();\\n        }\\n        for(auto it=count.begin();it!=count.end();it++) //Add results to the vector to sort by frequency first and then the string.\\n            resultPairs.push_back({it->second,it->first});\\n        sort(resultPairs.begin(),resultPairs.end());\\n        transform(resultPairs.begin(),resultPairs.end(),back_inserter(result),[](pair<int,string>&p){return p.second;}); //Transform the pairs to result\\n        return result;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470743,
                "title": "python-6-lines-bfs-solution",
                "content": "```python\\nimport collections\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        bfs,visited={id},{id}\\n        for _ in range(level):\\n            bfs={j for i in bfs for j in friends[i] if j not in visited}\\n            visited|=bfs\\n        freq=collections.Counter([v for idx in bfs for v in watchedVideos[idx]])\\n        return sorted(freq.keys(),key=lambda x:(freq[x],x))\\n```",
                "solutionTags": [],
                "code": "```python\\nimport collections\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        bfs,visited={id},{id}\\n        for _ in range(level):\\n            bfs={j for i in bfs for j in friends[i] if j not in visited}\\n            visited|=bfs\\n        freq=collections.Counter([v for idx in bfs for v in watchedVideos[idx]])\\n        return sorted(freq.keys(),key=lambda x:(freq[x],x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470820,
                "title": "java-bfs-sort-easy-to-understand",
                "content": "```\\n    public List<String> watchedVideosByFriends2(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n\\n        int N = friends.length;\\n        boolean[] visited = new boolean[N]; // keeping list of visited frnds\\n        visited[id] = true;// i\\'m my own frnd\\n\\n        ArrayList<Integer> q = new ArrayList<>();\\n        q.add(id);\\n\\n        for (int k = 0; k < level; k++) {// depth less than level\\n            ArrayList<Integer> newQ = new ArrayList<>();\\n            for (int v : q) {\\n                for (int w : friends[v]) {// this is frnds of frnds\\n                    if (!visited[w]) {\\n                        visited[w] = true;\\n                        newQ.add(w);\\n                    }\\n                }\\n            }\\n            q = newQ;//change the list to own frnd of frnd\\n        }\\n\\n        HashMap<String, Integer> freq = new HashMap<>();\\n\\n        for (int person : q) {\\n            for (String v : watchedVideos.get(person)) {\\n                freq.put(v, 1 + freq.getOrDefault(v, 0));\\n            }\\n        }\\n\\n        List<String> ans = new ArrayList<>(freq.keySet());\\n\\n        ans.sort((a, b) -> {// custom sort\\n            int fa = freq.get(a);\\n            int fb = freq.get(b);\\n            if (fa != fb) {\\n                return fa - fb;\\n            } else {\\n                return a.compareTo(b);\\n            }\\n        });\\n\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> watchedVideosByFriends2(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n\\n        int N = friends.length;\\n        boolean[] visited = new boolean[N]; // keeping list of visited frnds\\n        visited[id] = true;// i\\'m my own frnd\\n\\n        ArrayList<Integer> q = new ArrayList<>();\\n        q.add(id);\\n\\n        for (int k = 0; k < level; k++) {// depth less than level\\n            ArrayList<Integer> newQ = new ArrayList<>();\\n            for (int v : q) {\\n                for (int w : friends[v]) {// this is frnds of frnds\\n                    if (!visited[w]) {\\n                        visited[w] = true;\\n                        newQ.add(w);\\n                    }\\n                }\\n            }\\n            q = newQ;//change the list to own frnd of frnd\\n        }\\n\\n        HashMap<String, Integer> freq = new HashMap<>();\\n\\n        for (int person : q) {\\n            for (String v : watchedVideos.get(person)) {\\n                freq.put(v, 1 + freq.getOrDefault(v, 0));\\n            }\\n        }\\n\\n        List<String> ans = new ArrayList<>(freq.keySet());\\n\\n        ans.sort((a, b) -> {// custom sort\\n            int fa = freq.get(a);\\n            int fb = freq.get(b);\\n            if (fa != fb) {\\n                return fa - fb;\\n            } else {\\n                return a.compareTo(b);\\n            }\\n        });\\n\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470748,
                "title": "bfs-hash-map-set",
                "content": "This is not a hard problem - it just has many steps:\\n- BFS to find level-degree friends\\n- Count movies to determine frequency\\n- Sort the movies by the frequency\\n\\nSo, we need a queue for BFS, hash map for frequency, and map to sort.\\n```\\nvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n  unordered_set<int> visited = { id };\\n  vector<int> q1 = { id };\\n  vector<string> res;\\n  while (level-- > 0) {\\n    vector<int> q2;\\n    for (auto i : q1) {\\n      for (auto j : friends[i])\\n        if (visited.insert(j).second)\\n          q2.push_back(j);\\n    }\\n    swap(q1, q2);\\n  }\\n  unordered_map<string, int> freq;\\n  for (auto i : q1)\\n    for (auto& vid : watchedVideos[i])\\n      ++freq[vid];\\n  set<pair<int, string>> s;\\n  for (auto& p : freq)\\n    s.insert({ p.second, p.first });\\n  for (auto& p : s)\\n    res.push_back(p.second);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n  unordered_set<int> visited = { id };\\n  vector<int> q1 = { id };\\n  vector<string> res;\\n  while (level-- > 0) {\\n    vector<int> q2;\\n    for (auto i : q1) {\\n      for (auto j : friends[i])\\n        if (visited.insert(j).second)\\n          q2.push_back(j);\\n    }\\n    swap(q1, q2);\\n  }\\n  unordered_map<string, int> freq;\\n  for (auto i : q1)\\n    for (auto& vid : watchedVideos[i])\\n      ++freq[vid];\\n  set<pair<int, string>> s;\\n  for (auto& p : freq)\\n    s.insert({ p.second, p.first });\\n  for (auto& p : s)\\n    res.push_back(p.second);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470719,
                "title": "java-bfs-hashmap-sort-clean-code",
                "content": "```java\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(id);\\n        boolean[] visited = new boolean[n];\\n        visited[id] = true;\\n        while (level-- > 0) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                for (int f : friends[q.poll()]) {\\n                    if (!visited[f]) {\\n                        visited[f] = true;\\n                        q.offer(f);\\n                    }\\n                }\\n            }\\n        }\\n\\n        HashMap<String, Integer> freq = new HashMap<>();\\n        while (!q.isEmpty()) {\\n            for (String s : watchedVideos.get(q.poll()))\\n                freq.put(s, freq.getOrDefault(s, 0) + 1);\\n        }\\n        List<String> ans = new ArrayList<>(freq.keySet());\\n        ans.sort(new Comparator<String>() {\\n            @Override\\n            public int compare(String s1, String s2) {\\n                int f1 = freq.get(s1), f2 = freq.get(s2);\\n                if (f1 == f2) return s1.compareTo(s2);\\n                return f1 - f2;\\n            }\\n        });\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(id);\\n        boolean[] visited = new boolean[n];\\n        visited[id] = true;\\n        while (level-- > 0) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                for (int f : friends[q.poll()]) {\\n                    if (!visited[f]) {\\n                        visited[f] = true;\\n                        q.offer(f);\\n                    }\\n                }\\n            }\\n        }\\n\\n        HashMap<String, Integer> freq = new HashMap<>();\\n        while (!q.isEmpty()) {\\n            for (String s : watchedVideos.get(q.poll()))\\n                freq.put(s, freq.getOrDefault(s, 0) + 1);\\n        }\\n        List<String> ans = new ArrayList<>(freq.keySet());\\n        ans.sort(new Comparator<String>() {\\n            @Override\\n            public int compare(String s1, String s2) {\\n                int f1 = freq.get(s1), f2 = freq.get(s2);\\n                if (f1 == f2) return s1.compareTo(s2);\\n                return f1 - f2;\\n            }\\n        });\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471352,
                "title": "short-python",
                "content": "```\\ndef watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n    curr = seen = {id}\\n    for _ in range(level):\\n        curr = {f for p in curr for f in friends[p]} - seen\\n        seen |= curr\\n    ctr = collections.Counter(v for p in curr for v in watchedVideos[p])\\n    return sorted(sorted(ctr), key=ctr.get)\\n```",
                "solutionTags": [],
                "code": "```\\ndef watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n    curr = seen = {id}\\n    for _ in range(level):\\n        curr = {f for p in curr for f in friends[p]} - seen\\n        seen |= curr\\n    ctr = collections.Counter(v for p in curr for v in watchedVideos[p])\\n    return sorted(sorted(ctr), key=ctr.get)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 470765,
                "title": "java-bfs-sort",
                "content": "1. Bfs to find friends in that level.\\n2. Count the friends\\' video freq using map.\\n3. Add map\\'s keys into list and sort.\\n\\n```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(id);\\n        int count = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(id);\\n        while (!q.isEmpty()) {\\n            if (count == level) {\\n                break;\\n            }\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int p = q.poll();\\n                for (int f : friends[p]) {\\n                    if (!visited.contains(f)) {\\n                        q.add(f);\\n                        visited.add(f);\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        Map<String, Integer> map = new HashMap<>();\\n        List<String> res = new ArrayList<>();\\n        while (!q.isEmpty()) {\\n            int p = q.poll();\\n            List<String> vs = watchedVideos.get(p);\\n            for (String v : vs) {\\n                map.put(v, map.getOrDefault(v, 0) + 1);\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            res.add(key);\\n        }\\n        Collections.sort(res, (a, b)->(map.get(a) == map.get(b) ? a.compareTo(b) : map.get(a) - map.get(b)));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(id);\\n        int count = 0;\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(id);\\n        while (!q.isEmpty()) {\\n            if (count == level) {\\n                break;\\n            }\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int p = q.poll();\\n                for (int f : friends[p]) {\\n                    if (!visited.contains(f)) {\\n                        q.add(f);\\n                        visited.add(f);\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        Map<String, Integer> map = new HashMap<>();\\n        List<String> res = new ArrayList<>();\\n        while (!q.isEmpty()) {\\n            int p = q.poll();\\n            List<String> vs = watchedVideos.get(p);\\n            for (String v : vs) {\\n                map.put(v, map.getOrDefault(v, 0) + 1);\\n            }\\n        }\\n        for (String key : map.keySet()) {\\n            res.add(key);\\n        }\\n        Collections.sort(res, (a, b)->(map.get(a) == map.get(b) ? a.compareTo(b) : map.get(a) - map.get(b)));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470760,
                "title": "python-bfs-level-order-traversal",
                "content": "```\\nfrom queue import Queue\\n        \\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        q = Queue()\\n        dict_freq = {}\\n        lev = 0 \\n        fr_set = set()\\n        visited = [False]*len(friends)\\n    \\n        q.put(id) \\n        \\n        while True:\\n            size = q.qsize()  \\n            for i in range(size):\\n                fr_id = q.get()\\n                for fr in friends[fr_id]:\\n                    if visited[fr]!=True:\\n                        q.put(fr)\\n                        visited[fr] = True\\n      \\n            lev = lev + 1\\n            if lev == level:\\n                break\\n                \\n        while not q.empty():\\n            fr = q.get()\\n            if(fr!=id):\\n                fr_set.add(fr)\\n        \\n        for fr in fr_set:\\n            for mov in watchedVideos[fr]:\\n                dict_freq[mov] = dict_freq.get(mov,0) + 1\\n        ans = [k for k, v in sorted(dict_freq.items(), key=lambda item: (item[1],item[0]))]\\n        \\n        return ans\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom queue import Queue\\n        \\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        q = Queue()\\n        dict_freq = {}\\n        lev = 0 \\n        fr_set = set()\\n        visited = [False]*len(friends)\\n    \\n        q.put(id) \\n        \\n        while True:\\n            size = q.qsize()  \\n            for i in range(size):\\n                fr_id = q.get()\\n                for fr in friends[fr_id]:\\n                    if visited[fr]!=True:\\n                        q.put(fr)\\n                        visited[fr] = True\\n      \\n            lev = lev + 1\\n            if lev == level:\\n                break\\n                \\n        while not q.empty():\\n            fr = q.get()\\n            if(fr!=id):\\n                fr_set.add(fr)\\n        \\n        for fr in fr_set:\\n            for mov in watchedVideos[fr]:\\n                dict_freq[mov] = dict_freq.get(mov,0) + 1\\n        ans = [k for k, v in sorted(dict_freq.items(), key=lambda item: (item[1],item[0]))]\\n        \\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247416,
                "title": "bfs-based-solution-breaking-bad-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& friends, int id, int level) {\\n        \\n        vector<vector<int>>graph(friends.size());\\n        \\n     \\n        vector<int>ans;\\n        vector<int>visited(friends.size(),0);\\n        visited[id]=1;\\n        queue<pair<int,int>>q;\\n        q.push({id,0});\\n        \\n        while(q.size())//bfs\\n        {\\n            int val=q.front().first;\\n            int lev=q.front().second;\\n            q.pop();\\n            \\n            if(lev==level)\\n            {\\n                // cout<<val<<endl;\\n                ans.push_back(val);\\n            }\\n            \\n            for(auto x:friends[val])\\n            {\\n                if(visited[x]==0)\\n                {\\n                    visited[x]=1;\\n                    q.push({x,lev+1});\\n                }\\n            }\\n        }\\n        \\n        unordered_map<string,int>mp;\\n   \\n        for(auto x:ans)\\n        {\\n            for(auto y: w[x])\\n            {\\n                mp[y]++;\\n            }\\n        }\\n        \\n        vector<pair<int,string>>res;\\n        for(auto x:mp)\\n        {\\n              res.push_back({x.second,x.first});\\n        }\\n        sort(res.begin(),res.end());\\n       \\n        vector<string>fin;\\n        for(auto x:res)\\n        {\\n            fin.push_back(x.second);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& friends, int id, int level) {\\n        \\n        vector<vector<int>>graph(friends.size());\\n        \\n     \\n        vector<int>ans;\\n        vector<int>visited(friends.size(),0);\\n        visited[id]=1;\\n        queue<pair<int,int>>q;\\n        q.push({id,0});\\n        \\n        while(q.size())//bfs\\n        {\\n            int val=q.front().first;\\n            int lev=q.front().second;\\n            q.pop();\\n            \\n            if(lev==level)\\n            {\\n                // cout<<val<<endl;\\n                ans.push_back(val);\\n            }\\n            \\n            for(auto x:friends[val])\\n            {\\n                if(visited[x]==0)\\n                {\\n                    visited[x]=1;\\n                    q.push({x,lev+1});\\n                }\\n            }\\n        }\\n        \\n        unordered_map<string,int>mp;\\n   \\n        for(auto x:ans)\\n        {\\n            for(auto y: w[x])\\n            {\\n                mp[y]++;\\n            }\\n        }\\n        \\n        vector<pair<int,string>>res;\\n        for(auto x:mp)\\n        {\\n              res.push_back({x.second,x.first});\\n        }\\n        sort(res.begin(),res.end());\\n       \\n        vector<string>fin;\\n        for(auto x:res)\\n        {\\n            fin.push_back(x.second);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2126446,
                "title": "c-explained-briefly-each-and-every-point",
                "content": "```\\n// First of All Please Try This Question. This Is A bit Complex to Understand But Once you Will get it\\n// You will Implement it easily.\\n// See What the Question States that you are given some id You Need to Go to Its Next levels And How Levels Are Mentioned of friends that you can see in friends Array.\\n// So Go to id friends that\\' level = 1 then further go \\n// to their frinds that would be level =2.\\n// And correspondingly do so. So Upto here I did BFS And Reached to its next to next levels Correspondingly.\\n// So After That When I reached level given in question I break out \\n// of bfs at this situation my queue is stored with all the friends \\n// which come in that level for given id.\\n// And then after here I just traversed the watchedVideos Array \\n// stored the string frequency in map and t At last since i need to sort with\\n// Frequency And then I Also Need to sort accordingly so i made a \\n// priority queue of pair and sort both frequency and val according to cmp class\\n// as i made it above.\\n\\nstruct cmp\\n{\\n    bool operator()(pair<int,string> const&a , pair<int,string> const&b){\\n        if(a.first==b.first)\\n        {\\n            return a.second > b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    typedef pair<int,string>pd;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& nums, vector<vector<int>>& friends, int id, int level) {\\n        int n = nums.size();\\n        vector<int>vis(n+1,0);\\n        queue<int>q;\\n        q.push(id);\\n        vis[id] = 1;\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            lvl++;\\n            if(lvl == level)\\n            {\\n                break;\\n            }\\n            while(sz--)\\n            {\\n                int val = q.front();\\n                q.pop();\\n                for(int i = 0 ; i < friends[val].size() ; i++)\\n                {\\n                    if(!vis[friends[val][i]])\\n                    {\\n                        q.push(friends[val][i]);\\n                        vis[friends[val][i]] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        map<string,int>seen;\\n        while(!q.empty())\\n        {\\n            int val = q.front();\\n            for(int i = 0 ; i < nums[val].size() ; i++)\\n            {\\n                seen[nums[val][i]]++;\\n            }\\n            q.pop();\\n        }\\n        priority_queue<pd , vector<pd>, cmp>pq;\\n        for(auto it : seen)\\n        {\\n             pq.push({it.second,it.first});\\n        }\\n        vector<string>ans;\\n        while(!pq.empty())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if You Like the Solution And Explanation....!!.If you Have Query Then Ask in comment , I will be happy to answer them all.... Thanks!!\\uD83D\\uDE0A\\uD83D\\uDE0A\\u2714\\uFE0F\\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// First of All Please Try This Question. This Is A bit Complex to Understand But Once you Will get it\\n// You will Implement it easily.\\n// See What the Question States that you are given some id You Need to Go to Its Next levels And How Levels Are Mentioned of friends that you can see in friends Array.\\n// So Go to id friends that\\' level = 1 then further go \\n// to their frinds that would be level =2.\\n// And correspondingly do so. So Upto here I did BFS And Reached to its next to next levels Correspondingly.\\n// So After That When I reached level given in question I break out \\n// of bfs at this situation my queue is stored with all the friends \\n// which come in that level for given id.\\n// And then after here I just traversed the watchedVideos Array \\n// stored the string frequency in map and t At last since i need to sort with\\n// Frequency And then I Also Need to sort accordingly so i made a \\n// priority queue of pair and sort both frequency and val according to cmp class\\n// as i made it above.\\n\\nstruct cmp\\n{\\n    bool operator()(pair<int,string> const&a , pair<int,string> const&b){\\n        if(a.first==b.first)\\n        {\\n            return a.second > b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n};\\nclass Solution {\\npublic:\\n    typedef pair<int,string>pd;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& nums, vector<vector<int>>& friends, int id, int level) {\\n        int n = nums.size();\\n        vector<int>vis(n+1,0);\\n        queue<int>q;\\n        q.push(id);\\n        vis[id] = 1;\\n        int lvl = -1;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            lvl++;\\n            if(lvl == level)\\n            {\\n                break;\\n            }\\n            while(sz--)\\n            {\\n                int val = q.front();\\n                q.pop();\\n                for(int i = 0 ; i < friends[val].size() ; i++)\\n                {\\n                    if(!vis[friends[val][i]])\\n                    {\\n                        q.push(friends[val][i]);\\n                        vis[friends[val][i]] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        map<string,int>seen;\\n        while(!q.empty())\\n        {\\n            int val = q.front();\\n            for(int i = 0 ; i < nums[val].size() ; i++)\\n            {\\n                seen[nums[val][i]]++;\\n            }\\n            q.pop();\\n        }\\n        priority_queue<pd , vector<pd>, cmp>pq;\\n        for(auto it : seen)\\n        {\\n             pq.push({it.second,it.first});\\n        }\\n        vector<string>ans;\\n        while(!pq.empty())\\n        {\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470965,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& videos, vector<vector<int>>& friends, int id, int level) {\\n        vector<int> dp(friends.size(),INT_MAX);\\n        int distance = 0;\\n        queue<int> q;\\n        q.push(id);\\n        unordered_map<string,int> count;\\n        while(q.size()){\\n            int size = q.size();\\n            for(int i = 0;i<size;i++){\\n                int x = q.front();\\n                q.pop();\\n                if(distance < dp[x]){\\n                    dp[x] = distance; \\n                    if(dp[x] == level){\\n                        for(auto& v : videos[x]){\\n                            count[v]++;\\n                        }\\n                        continue;\\n                    }\\n                    for(int j : friends[x]){\\n                        q.push(j);\\n                    }\\n                }\\n            }\\n            distance++;\\n        }\\n        vector<pair<int,string>> tmp;\\n        for(auto& ptr : count){\\n            tmp.push_back({ptr.second,ptr.first});\\n        }\\n        sort(tmp.begin(),tmp.end(),[](auto& a, auto& b){\\n            if(a.first != b.first){\\n                return a.first < b.first;\\n            }\\n            return a.second < b.second;\\n        });\\n        vector<string> ret;\\n        for(auto& ptr : tmp){\\n            ret.push_back(ptr.second);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& videos, vector<vector<int>>& friends, int id, int level) {\\n        vector<int> dp(friends.size(),INT_MAX);\\n        int distance = 0;\\n        queue<int> q;\\n        q.push(id);\\n        unordered_map<string,int> count;\\n        while(q.size()){\\n            int size = q.size();\\n            for(int i = 0;i<size;i++){\\n                int x = q.front();\\n                q.pop();\\n                if(distance < dp[x]){\\n                    dp[x] = distance; \\n                    if(dp[x] == level){\\n                        for(auto& v : videos[x]){\\n                            count[v]++;\\n                        }\\n                        continue;\\n                    }\\n                    for(int j : friends[x]){\\n                        q.push(j);\\n                    }\\n                }\\n            }\\n            distance++;\\n        }\\n        vector<pair<int,string>> tmp;\\n        for(auto& ptr : count){\\n            tmp.push_back({ptr.second,ptr.first});\\n        }\\n        sort(tmp.begin(),tmp.end(),[](auto& a, auto& b){\\n            if(a.first != b.first){\\n                return a.first < b.first;\\n            }\\n            return a.second < b.second;\\n        });\\n        vector<string> ret;\\n        for(auto& ptr : tmp){\\n            ret.push_back(ptr.second);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470774,
                "title": "26ms-java-with-bellman-ford-shortest-path-algorithm",
                "content": "It is difficult for me to use Dijkstra Algorithm, but the Bellman Ford algorithm is easy to implement.\\n```\\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int[] distance = new int[friends.length];\\n        Arrays.fill(distance,1000);\\n        distance[id] = 0;\\n        for(int m = 0;m<level;m++){\\n            for(int i = 0;i<friends.length;i++){\\n                for(int j = 0;j<friends[i].length;j++){\\n                    int idFriend = friends[i][j];\\n                    if(distance[idFriend] > distance[i] + 1){\\n                        distance[idFriend] = distance[i] + 1;\\n                    }\\n                }\\n            }\\n        }\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0;i<distance.length;i++){\\n            if(distance[i] != level) continue;\\n            List<String> videoList = watchedVideos.get(i);\\n            for(String s: videoList){\\n                int count = map.getOrDefault(s,0);\\n                map.put(s,count+1);\\n            }\\n        }\\n        List<String> ans = new ArrayList<>(map.keySet());\\n        ans.sort((s1,s2) -> {\\n            if(map.get(s1) != map.get(s2)) return map.get(s1) - map.get(s2);\\n            else return s1.compareTo(s2);\\n        });\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int[] distance = new int[friends.length];\\n        Arrays.fill(distance,1000);\\n        distance[id] = 0;\\n        for(int m = 0;m<level;m++){\\n            for(int i = 0;i<friends.length;i++){\\n                for(int j = 0;j<friends[i].length;j++){\\n                    int idFriend = friends[i][j];\\n                    if(distance[idFriend] > distance[i] + 1){\\n                        distance[idFriend] = distance[i] + 1;\\n                    }\\n                }\\n            }\\n        }\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(int i = 0;i<distance.length;i++){\\n            if(distance[i] != level) continue;\\n            List<String> videoList = watchedVideos.get(i);\\n            for(String s: videoList){\\n                int count = map.getOrDefault(s,0);\\n                map.put(s,count+1);\\n            }\\n        }\\n        List<String> ans = new ArrayList<>(map.keySet());\\n        ans.sort((s1,s2) -> {\\n            if(map.get(s1) != map.get(s2)) return map.get(s1) - map.get(s2);\\n            else return s1.compareTo(s2);\\n        });\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491936,
                "title": "python3-breadth-first-search",
                "content": "Algorithm:\\n`friends` is a graph, for which we traverse it by level. At given level, we count the frequencies of each movies, and output the result. \\n\\nImplementation (296ms, 85.93%): \\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        queue = [id]\\n        count = 0\\n        seen = set(queue)\\n        while queue and count < level: #bfs\\n            count += 1\\n            temp = set()\\n            for i in queue: \\n                for j in friends[i]:\\n                    if j not in seen: \\n                        temp.add(j)\\n                        seen.add(j)\\n            queue = temp\\n        \\n        movies = dict()\\n        for i in queue: \\n            for m in watchedVideos[i]: \\n                movies[m] = movies.get(m, 0) + 1\\n        return [k for _, k in sorted((v, k) for k, v in movies.items())]\\n```\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(N)`\\n\\nAlternatively, a more concise implementation is given in this [thread](https://leetcode.com/problems/get-watched-videos-by-your-friends/discuss/470743/Python-6-lines-bfs-solution), which is repeated here. \\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        queue, seen = {id}, {id}\\n        for _ in range(level):\\n            queue = {j for i in queue for j in friends[i] if j not in seen}\\n            seen |= queue \\n        freq = Counter(v for i in queue for v in watchedVideos[i])\\n        return sorted(freq.keys(), key=lambda x: (freq[x], x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        queue = [id]\\n        count = 0\\n        seen = set(queue)\\n        while queue and count < level: #bfs\\n            count += 1\\n            temp = set()\\n            for i in queue: \\n                for j in friends[i]:\\n                    if j not in seen: \\n                        temp.add(j)\\n                        seen.add(j)\\n            queue = temp\\n        \\n        movies = dict()\\n        for i in queue: \\n            for m in watchedVideos[i]: \\n                movies[m] = movies.get(m, 0) + 1\\n        return [k for _, k in sorted((v, k) for k, v in movies.items())]\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        queue, seen = {id}, {id}\\n        for _ in range(level):\\n            queue = {j for i in queue for j in friends[i] if j not in seen}\\n            seen |= queue \\n        freq = Counter(v for i in queue for v in watchedVideos[i])\\n        return sorted(freq.keys(), key=lambda x: (freq[x], x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470785,
                "title": "python-bfs-counter",
                "content": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        def find_level_friend(lvl, ids, visited):\\n            if lvl == 0:\\n                return list(ids)\\n            ids_next_level = set()\\n            for i in ids:\\n                for j in friends[i]:\\n                    if j not in visited:\\n                        ids_next_level.add(j)\\n                        visited.add(j)\\n            return find_level_friend(lvl-1, list(ids_next_level), visited)\\n        \\n        friends_at_level = find_level_friend(level, [id], set([id]))\\n        counts = collections.Counter([vd for i in friends_at_level for vd in watchedVideos[i]])\\n        return [count[1] for count in sorted([(counts[vd], vd) for vd in sorted(counts.keys())])]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        def find_level_friend(lvl, ids, visited):\\n            if lvl == 0:\\n                return list(ids)\\n            ids_next_level = set()\\n            for i in ids:\\n                for j in friends[i]:\\n                    if j not in visited:\\n                        ids_next_level.add(j)\\n                        visited.add(j)\\n            return find_level_friend(lvl-1, list(ids_next_level), visited)\\n        \\n        friends_at_level = find_level_friend(level, [id], set([id]))\\n        counts = collections.Counter([vd for i in friends_at_level for vd in watchedVideos[i]])\\n        return [count[1] for count in sorted([(counts[vd], vd) for vd in sorted(counts.keys())])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578440,
                "title": "bfs-map-sorting-based-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<string,int>&p1,pair<string,int>&p2)\\n    {\\n        if(p1.second==p2.second)\\n        {\\n            return p1.first<p2.first;\\n        }\\n        return p1.second<p2.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        int count=0;\\n        queue<int>q;\\n        q.push(id);\\n        vector<int>visited(n,0);\\n        visited[id]=1;\\n        q.push(-1);\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            if(x==-1)\\n            {\\n               count++;\\n               if(count==level)\\n               break;\\n                q.push(-1);\\n                continue;\\n            }\\n            for(auto it:friends[x])\\n            {\\n                if(visited[it]==0)\\n                {\\n                    visited[it]=1;\\n                    q.push(it);\\n                }\\n                \\n            }\\n        }\\n        unordered_map<string,int>m;\\n        while(q.size()>0)\\n        {\\n            int x=q.front();\\n            q.pop();\\n            for(auto it:watched[x])\\n            {\\n                m[it]++;\\n            }\\n        }\\n        vector<pair<string,int>>p;\\n        for(auto it:m)\\n        {\\n            p.push_back({it.first,it.second});\\n        }\\n        sort(p.begin(),p.end(),cmp);\\n        vector<string>ans;\\n        for(auto it:p)\\n        {\\n            ans.push_back(it.first);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<string,int>&p1,pair<string,int>&p2)\\n    {\\n        if(p1.second==p2.second)\\n        {\\n            return p1.first<p2.first;\\n        }\\n        return p1.second<p2.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        int count=0;\\n        queue<int>q;\\n        q.push(id);\\n        vector<int>visited(n,0);\\n        visited[id]=1;\\n        q.push(-1);\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            if(x==-1)\\n            {\\n               count++;\\n               if(count==level)\\n               break;\\n                q.push(-1);\\n                continue;\\n            }\\n            for(auto it:friends[x])\\n            {\\n                if(visited[it]==0)\\n                {\\n                    visited[it]=1;\\n                    q.push(it);\\n                }\\n                \\n            }\\n        }\\n        unordered_map<string,int>m;\\n        while(q.size()>0)\\n        {\\n            int x=q.front();\\n            q.pop();\\n            for(auto it:watched[x])\\n            {\\n                m[it]++;\\n            }\\n        }\\n        vector<pair<string,int>>p;\\n        for(auto it:m)\\n        {\\n            p.push_back({it.first,it.second});\\n        }\\n        sort(p.begin(),p.end(),cmp);\\n        vector<string>ans;\\n        for(auto it:p)\\n        {\\n            ans.push_back(it.first);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480779,
                "title": "java-8-using-streams-and-lambdas",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        return getFriendsAtLevel(friends, id, level)\\n            .stream()\\n            .map(watchedVideos::get)\\n            .flatMap(List<String>::stream) \\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .sorted(\\n                    Comparator.comparing(Map.Entry<String, Long>::getValue)\\n                              .thenComparing(Comparator.comparing(Map.Entry<String, Long>::getKey)))\\n            .map(Map.Entry<String,Long>::getKey)\\n            .collect(Collectors.toList());\\n    }\\n    \\n    private List<Integer> getFriendsAtLevel(int[][] friends, int id, int level) {\\n        final LinkedList<Integer> q = new LinkedList<>();\\n        q.offer(id);\\n        final boolean[] visited = new boolean[friends.length];\\n        visited[id] = true;\\n        while (level-- > 0) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                for (int f : friends[q.poll()]) {\\n                    if (!visited[f]) {\\n                        visited[f] = true;\\n                        q.offer(f);\\n                    }\\n                }\\n            }\\n        }\\n        return q;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        return getFriendsAtLevel(friends, id, level)\\n            .stream()\\n            .map(watchedVideos::get)\\n            .flatMap(List<String>::stream) \\n            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))\\n            .entrySet()\\n            .stream()\\n            .sorted(\\n                    Comparator.comparing(Map.Entry<String, Long>::getValue)\\n                              .thenComparing(Comparator.comparing(Map.Entry<String, Long>::getKey)))\\n            .map(Map.Entry<String,Long>::getKey)\\n            .collect(Collectors.toList());\\n    }\\n    \\n    private List<Integer> getFriendsAtLevel(int[][] friends, int id, int level) {\\n        final LinkedList<Integer> q = new LinkedList<>();\\n        q.offer(id);\\n        final boolean[] visited = new boolean[friends.length];\\n        visited[id] = true;\\n        while (level-- > 0) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                for (int f : friends[q.poll()]) {\\n                    if (!visited[f]) {\\n                        visited[f] = true;\\n                        q.offer(f);\\n                    }\\n                }\\n            }\\n        }\\n        return q;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470838,
                "title": "python-bfs-sorting",
                "content": "```python\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        res = []\\n        d = defaultdict(int)\\n        n = len(watchedVideos)\\n        dist = [-1]*n\\n        q = deque([id])\\n        dist[id] = 0\\n        while len(q) != 0:\\n            u = q.popleft()\\n            for v in friends[u]:\\n                if dist[v] == -1:\\n                    dist[v] = dist[u] + 1\\n                    if dist[v] == level:\\n                        for e in watchedVideos[v]:\\n                            d[e] += 1\\n                    if dist[v] > level:\\n                        break\\n                    q.append(v)\\n        for e in sorted(zip(d.values(), d.keys())):\\n            res.append(e[1])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        res = []\\n        d = defaultdict(int)\\n        n = len(watchedVideos)\\n        dist = [-1]*n\\n        q = deque([id])\\n        dist[id] = 0\\n        while len(q) != 0:\\n            u = q.popleft()\\n            for v in friends[u]:\\n                if dist[v] == -1:\\n                    dist[v] = dist[u] + 1\\n                    if dist[v] == level:\\n                        for e in watchedVideos[v]:\\n                            d[e] += 1\\n                    if dist[v] > level:\\n                        break\\n                    q.append(v)\\n        for e in sorted(zip(d.values(), d.keys())):\\n            res.append(e[1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470726,
                "title": "java-bfs-and-sort",
                "content": "```java\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        boolean[] visited = new boolean[friends.length];\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(id);\\n        visited[id] = true;\\n        while (!queue.isEmpty() && level-- > 0) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int cur = queue.poll();\\n                for (int i : friends[cur]) {\\n                    if (!visited[i]) {\\n                        queue.offer(i);\\n                        visited[i] = true;\\n                    }\\n                }\\n            }\\n        }\\n        if (queue.isEmpty() || level > 0) return new ArrayList<>();\\n        Map<String, Integer> freq = new HashMap<>();\\n        for (int i : queue) {\\n            for (String video : watchedVideos.get(i)) {\\n                freq.put(video, freq.getOrDefault(video, 0) + 1);\\n            }\\n        }\\n        List<String> res = new ArrayList<>(freq.keySet());\\n        Collections.sort(res, (e1, e2) -> freq.get(e1) == freq.get(e2) ? e1.compareTo(e2) : Integer.compare(freq.get(e1), freq.get(e2)));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        boolean[] visited = new boolean[friends.length];\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(id);\\n        visited[id] = true;\\n        while (!queue.isEmpty() && level-- > 0) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int cur = queue.poll();\\n                for (int i : friends[cur]) {\\n                    if (!visited[i]) {\\n                        queue.offer(i);\\n                        visited[i] = true;\\n                    }\\n                }\\n            }\\n        }\\n        if (queue.isEmpty() || level > 0) return new ArrayList<>();\\n        Map<String, Integer> freq = new HashMap<>();\\n        for (int i : queue) {\\n            for (String video : watchedVideos.get(i)) {\\n                freq.put(video, freq.getOrDefault(video, 0) + 1);\\n            }\\n        }\\n        List<String> res = new ArrayList<>(freq.keySet());\\n        Collections.sort(res, (e1, e2) -> freq.get(e1) == freq.get(e2) ? e1.compareTo(e2) : Integer.compare(freq.get(e1), freq.get(e2)));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008225,
                "title": "self-explanatory-bfs-solution",
                "content": "# Intuition\\nWe basically need to count the frequencies of the movies of nodes $$i$$ which are at a distance of $$level$$ from $$id$$.\\n\\n# Approach\\n1. Make a graph out of the friends array.\\n2. Start a bfs from id, till level.\\n3. Store in map, freq of all movies of nodes at level.\\n4. Transfer them to a set to essentially sort them.\\n5. Transfer them to a vector of string to obtain the ans.    \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n + n + m + nlogn)$$\\nTime taken to build the adjacency list, ( since $$friends.size == n$$ and $$friends[i].size == n$$ )\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int> adj[n];\\n        for(int i = 0; i < friends.size(); i++) {\\n            for(auto& it : friends[i]) {\\n                adj[i].push_back(it);\\n            }\\n        }\\n\\n        unordered_map<string, int> mp;\\n        queue<int> q;\\n        vector<bool> visited(n, false);\\n        q.push(id);\\n        visited[id] = true;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            if(level == 0) break;\\n            while(sz--) {\\n                int temp = q.front();\\n                q.pop();\\n                for(auto& it : adj[temp]) {\\n                    if(!visited[it]) {\\n                        visited[it] = true;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            level--;\\n        }\\n\\n        while(!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n            for(auto& it : watchedVideos[temp]) {\\n                mp[it]++;\\n            }\\n        }\\n\\n        set<pair<int, string>> s;\\n        for(auto& it : mp) {\\n            s.insert({it.second, it.first});\\n        }\\n\\n        vector<string> ans;\\n        for(auto& it : s) {\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int> adj[n];\\n        for(int i = 0; i < friends.size(); i++) {\\n            for(auto& it : friends[i]) {\\n                adj[i].push_back(it);\\n            }\\n        }\\n\\n        unordered_map<string, int> mp;\\n        queue<int> q;\\n        vector<bool> visited(n, false);\\n        q.push(id);\\n        visited[id] = true;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            if(level == 0) break;\\n            while(sz--) {\\n                int temp = q.front();\\n                q.pop();\\n                for(auto& it : adj[temp]) {\\n                    if(!visited[it]) {\\n                        visited[it] = true;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            level--;\\n        }\\n\\n        while(!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n            for(auto& it : watchedVideos[temp]) {\\n                mp[it]++;\\n            }\\n        }\\n\\n        set<pair<int, string>> s;\\n        for(auto& it : mp) {\\n            s.insert({it.second, it.first});\\n        }\\n\\n        vector<string> ans;\\n        for(auto& it : s) {\\n            ans.push_back(it.second);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660529,
                "title": "dfs-not-working",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int> ff; \\n    \\n    void dfs(vector<int> adj[],int node,int parent,int level){\\n            if(level == 0){\\n                    ff.insert(node);\\n                    return;\\n            }\\n            for(int child : adj[node]){\\n                    if(child != parent){\\n                            dfs(adj,child,node,level-1);\\n                    }\\n            }\\n            \\n    }    \\n        \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) {\\n            \\n            \\n            vector<int> adj[100];\\n            for(int i = 0;i<friends.size();i++){\\n                    \\n                    for(auto a : friends[i]){\\n                            adj[i].push_back(a);\\n                    }\\n            }\\n            \\n            \\n            dfs(adj,id,id,level);\\n            map<string,int> mp;\\n            \\n            for(auto a : ff){\\n                    for(string s : watched[a])\\n                            mp[s]++;\\n            }\\n            \\n            vector<pair<int,string>> v;\\n            for(auto [a,b] : mp){\\n                    v.push_back({b,a});\\n            }\\n            sort(v.begin(),v.end());\\n            vector<string> ans;\\n            for(auto a : v)\\n                    ans.push_back(a.second);\\n            return ans;\\n            \\n            \\n            \\n            \\n        \\n    }\\n};\\n```\\n\\n\\nDONT KNOW WHY IT FAILING ON TESTCASE 32\\n\\n\\n[[\"vjprcq\",\"auc\",\"ttwl\",\"qeyfweny\",\"c\",\"uxwzjv\",\"xlljn\",\"polktwn\",\"zew\",\"iuwinspt\",\"j\",\"lpeoeuwp\",\"hky\",\"vr\",\"fznunj\",\"htaup\",\"cipxmo\",\"n\",\"pqeke\",\"xmdd\",\"epuqzo\",\"peb\",\"wmku\",\"pjbnc\",\"askm\",\"hjnlo\",\"vxidvl\",\"xsdt\",\"aikdm\",\"jrilepbd\",\"okaouhe\",\"egpfjl\",\"uywv\",\"tbto\",\"vvoop\",\"nnchlb\",\"dvmrww\",\"kegczipp\",\"korcptix\",\"ws\",\"ncx\",\"mdn\",\"earv\",\"dc\",\"dvsrul\",\"vmcnuoj\",\"omtrteo\",\"mdkiueiv\",\"d\",\"xvb\",\"k\",\"bfnota\"],[\"dvmbaeh\",\"umkejtes\",\"rey\",\"shx\",\"agpr\",\"zlpunqan\",\"wmit\",\"y\",\"dzqyhn\",\"eqosy\",\"idxxxc\",\"molnvq\",\"pmrabpky\",\"dalc\",\"wpd\",\"eoxc\",\"uiy\",\"wlfhbjuo\",\"tjhajpeg\",\"fjci\",\"muz\",\"xyfom\",\"zl\",\"hazrtf\",\"tejmekki\",\"e\",\"igua\",\"u\",\"o\",\"hqyud\",\"te\",\"fanf\",\"okb\",\"tqlwjser\",\"h\",\"op\",\"qkdv\",\"eiuni\",\"aa\",\"qfbkfb\",\"a\",\"haxjp\",\"kscgflwx\",\"lgo\",\"oltschh\",\"hc\",\"qlcds\",\"hrjyuj\",\"fw\",\"goeygcn\",\"me\",\"jitq\",\"mddvlopv\",\"gskeuik\",\"tbvm\",\"kzdue\"],[\"puksbb\",\"eopqygzi\",\"tejdk\",\"kkgy\",\"ng\",\"yeqrcma\",\"emltyqm\",\"xvc\",\"ygpp\",\"ywkiraq\",\"amxqm\",\"fti\",\"nd\",\"mbpcschk\",\"tvvklwv\",\"hneyh\",\"txbhgse\",\"fdygnb\",\"rywllv\",\"hlymcho\",\"lul\",\"oq\",\"myicoov\",\"iww\",\"z\",\"nhlwoz\",\"oqyaez\"],[\"zwdh\",\"lhsfo\",\"lwbwvf\",\"rllvrsn\",\"qiocb\",\"ri\",\"zgnrs\",\"hicn\",\"vqjjtpc\",\"hwgpdql\",\"bc\",\"hocgbo\",\"cvp\",\"zb\",\"pew\",\"npjatiru\",\"tc\",\"bhrvre\",\"y\",\"bekvmrz\",\"ty\",\"jkgnpcmy\",\"zauvu\",\"jx\",\"ssma\",\"cuschcn\",\"rjqybepp\",\"erdgir\",\"p\",\"eekmoito\",\"wmyvts\",\"ag\",\"htvl\",\"rydcayh\",\"hxgqfr\",\"qf\",\"j\",\"swvkl\",\"lygatsp\",\"fma\",\"ail\",\"nvgz\",\"nvsg\",\"smbfsau\",\"dbje\",\"tlfsyvf\",\"qep\",\"of\",\"ilohs\",\"x\",\"ugzz\",\"hzxwn\",\"whlzp\",\"zgoqvqz\",\"bhhren\",\"rc\",\"nqmtodz\",\"bmgr\",\"nqxq\",\"yludmuvy\",\"qzlkf\",\"vzrhgch\",\"iv\",\"xhpuibm\",\"mongbj\",\"eekv\",\"tsonv\",\"lxkih\",\"mxkbsygz\",\"vu\",\"hle\",\"ymiankek\",\"gm\",\"mtqr\",\"gdezmdmy\",\"oypr\",\"fy\",\"l\",\"s\",\"eypmgxgt\",\"k\",\"pixf\",\"qxqnbega\",\"nwcfu\",\"m\",\"qejef\",\"qhzzv\",\"zotgq\",\"wbgt\",\"klvmybv\",\"cfpeljf\",\"w\"],[\"llltqxrg\",\"hnz\",\"hi\",\"rokuo\",\"p\",\"eanmfjrw\",\"gsvmzxw\",\"h\",\"klojcbqk\",\"ebl\",\"htuwbbap\",\"oynhmfdh\",\"jhadg\",\"vjpyizj\",\"uo\",\"ikz\",\"srkbj\",\"ioqx\",\"yako\",\"cn\",\"ibewwu\",\"lzkmf\",\"o\",\"fthpft\",\"rmdjyct\",\"fsnpuexc\",\"r\",\"strehbrz\",\"nzvso\",\"slrkq\",\"sbfnhp\",\"vixxyh\",\"ti\",\"qybjp\",\"wfcvsqrg\",\"s\",\"jcrths\",\"evx\",\"utkuwgt\",\"vfaygbac\",\"zlngfan\",\"m\",\"ll\",\"mqu\",\"xk\",\"uaohmrcn\",\"alqjhmp\",\"lbbntns\",\"wek\",\"epnk\",\"l\",\"lxczym\",\"wub\",\"bxj\",\"kbcee\",\"kgyf\",\"gnlejzsf\",\"asfxudbx\",\"nvj\",\"bctq\",\"xiwproo\",\"sk\"],[\"hybhd\",\"fuym\",\"ueshrug\",\"wsuevxuy\",\"mo\",\"vatzpu\",\"ybhtjfqt\",\"cxkciwzq\",\"verub\",\"ceqwef\",\"t\",\"b\",\"yr\",\"pbvquv\"],[\"oo\",\"i\",\"oclcff\",\"s\",\"gsvhepd\",\"qvptdx\",\"qjd\",\"ctdsk\",\"sxsjojyq\",\"zzrosejs\",\"cvjbs\",\"wepsuyx\",\"vidsjn\",\"hmrs\",\"mv\",\"ibv\",\"yhkci\",\"dehpkon\",\"qs\",\"bngmssvy\",\"ttyee\",\"bauboal\",\"kzfwvgxo\",\"vgmk\",\"iifjvcyt\",\"qt\",\"ssrhdpdo\",\"dwu\",\"qwzmsh\",\"zo\",\"dycp\",\"sqjak\",\"hneqsoc\",\"inxzrsrc\",\"md\",\"mbcrl\",\"pxvuufmb\",\"mvmmo\",\"w\",\"recp\",\"gdywwog\",\"umnazia\",\"p\",\"eytfxgq\",\"jcrbnwe\",\"fjbujsjb\",\"jbpcfx\",\"wupioza\",\"bjyblgk\",\"hec\",\"d\",\"jkp\",\"amsrmhxq\",\"ryd\",\"rmhrats\",\"nzmruv\",\"enfd\",\"xj\",\"lpp\",\"siu\",\"icwq\",\"huztrh\",\"yfueb\",\"lethjxbn\",\"pxbfrmzv\",\"uxkjiflv\",\"cynhwl\",\"lh\",\"lv\"],[\"bslqa\",\"vdaasfo\",\"gl\",\"qe\",\"fotdqiw\",\"zflvedue\",\"um\",\"fhz\",\"dbtga\",\"azuo\",\"tmje\",\"ltmdzt\",\"kano\",\"faqi\",\"hzccgtxe\",\"zhwr\",\"qqasqg\",\"bdfnevzp\",\"hblf\",\"nrh\",\"lyyuz\",\"jshd\",\"k\",\"rfxen\",\"rjtayu\",\"akpb\",\"mdow\",\"prrgyyo\",\"vu\",\"yyuf\",\"twiac\",\"azgqkiu\",\"ypre\",\"bmqmmbub\",\"lhxgo\",\"pbyrgdkw\",\"nxzhw\",\"isi\",\"dvwlnq\",\"ophdfqt\",\"tobdcmmy\",\"guvps\",\"tmrqzd\",\"h\",\"miticfmd\",\"g\",\"ffjsdh\",\"n\",\"feset\",\"rgdkvp\",\"jtwz\",\"w\",\"fkvq\",\"gund\",\"sswifa\",\"mrmmc\",\"keiito\",\"ogm\",\"cyowdrfi\",\"njxzj\",\"luwe\",\"rudz\",\"giyrrvu\",\"evzs\",\"zk\",\"x\",\"iuwbvbth\",\"cfvfgg\",\"q\"],[\"v\",\"pyubrhq\",\"vdkn\",\"bqt\",\"jlaokmo\",\"plxufnbv\",\"isbame\",\"gmrtxofh\",\"t\",\"nox\",\"g\",\"s\",\"cwqmaez\",\"wmkg\",\"um\",\"btcgll\",\"u\",\"sjnjuqf\",\"zqs\",\"vwa\",\"n\",\"zhod\",\"rjq\",\"xvfztsmg\",\"kdudr\",\"pb\",\"lrbdoib\",\"xoejob\",\"jrd\",\"uc\",\"nqcnlrs\",\"wsp\",\"wuwtqynj\",\"ohgszrge\",\"i\",\"y\",\"ovfgjrje\",\"fq\",\"vf\",\"nfg\",\"zikyver\",\"nkxy\",\"fujb\",\"ht\",\"q\",\"f\",\"z\",\"xxnuelmh\",\"wruidqxj\",\"j\",\"c\",\"ldvqoi\",\"b\",\"klhyi\",\"iyychnmp\",\"tno\",\"hoyqucx\",\"mggtebu\",\"oll\",\"ih\",\"javino\",\"ukzww\",\"wx\",\"wehtltm\",\"h\",\"hvd\",\"dgxu\",\"bnxk\",\"xva\",\"utgbtzbw\",\"bg\",\"cmstgv\",\"mjftjj\",\"slhhd\",\"eljltqs\",\"bqbcnk\",\"rhjqjm\",\"ferdvt\",\"vhw\"],[\"niqutzv\",\"joobor\",\"asdjtqf\",\"dh\",\"olvjei\",\"xe\",\"krhlbbdf\",\"ovqcmbsx\",\"cja\",\"htzxhgwe\",\"esweflv\",\"l\",\"x\",\"ocbwwoze\",\"uiybbqb\",\"htx\",\"qdysj\",\"bsd\",\"eyidrzcv\",\"ezhhks\",\"zlsywvas\",\"xi\",\"axr\",\"tjrfua\",\"rflszqlw\",\"pplndvc\",\"zh\",\"gbwzts\",\"s\",\"hyytzn\",\"bvbnyzx\",\"vslwc\",\"kf\",\"mofxfn\",\"gaqxfgvu\",\"vct\",\"c\",\"oibz\",\"inxhodc\"],[\"gafn\",\"okfvgncm\",\"lcqvoq\",\"g\",\"llagh\",\"klvtoow\",\"xr\",\"u\",\"ykcn\",\"wvyhb\",\"djsez\",\"lqczjco\",\"fhsaragz\",\"ktcs\",\"nqzumvs\",\"mojqlg\",\"ruj\",\"xp\",\"mwfvbc\",\"vbmesxef\",\"xm\",\"qmyl\",\"fnsihyx\",\"tqazzy\",\"jqyie\",\"yobz\",\"dxvcb\",\"pe\"],[\"tmhvbnfb\",\"obequ\",\"guwf\",\"eamu\",\"y\",\"tllkekk\",\"ubkoyy\",\"cax\",\"p\",\"gm\",\"tdiqnbz\",\"gbrawxjn\",\"kl\",\"btviega\",\"obt\",\"wdrbqfw\",\"caraehar\",\"q\",\"twnw\",\"pl\",\"fxvghc\",\"fwjc\",\"wg\",\"xco\",\"lhefs\",\"nclq\",\"yby\",\"i\",\"r\",\"ngszdlwk\",\"fxsjz\",\"pqkqu\",\"dbccjtn\",\"lkscwer\",\"qnhrzixn\",\"ujfbdx\",\"od\",\"ywlidkmd\",\"qxr\",\"xzqcpksd\",\"dydrhp\",\"pkbf\",\"a\",\"vkjrtxh\",\"evyxyc\",\"ybfy\",\"nvigfg\",\"yqffhoe\",\"skfvk\",\"hzgfj\",\"e\",\"anb\",\"woengf\",\"xfxcwi\",\"kbqjve\",\"ubzouynt\",\"aa\",\"lgob\",\"h\",\"gryfg\",\"lrgx\",\"swd\",\"frzuov\"],[\"r\",\"caokslln\",\"wdd\",\"vzkfucma\",\"avytejzi\",\"bppbs\",\"zap\",\"bhdxmvr\",\"s\",\"aahqw\",\"iulxagt\",\"gxoqybe\",\"ubdmd\",\"p\",\"edwpifbd\",\"cfkoyrfw\",\"xliwyjpf\",\"qafhd\",\"cdjzzwd\",\"vhfyv\",\"dodkqr\",\"os\",\"cqtdotp\",\"mopmm\",\"mk\",\"c\",\"pna\",\"xm\",\"byaqua\",\"xqfojwnc\",\"nkpy\",\"umvuasw\",\"fy\",\"rzeigpx\",\"kxx\",\"ft\",\"ajbvrdip\",\"nil\",\"kifqs\",\"ttrd\",\"idg\",\"v\",\"qyu\",\"xurdrryh\",\"nnt\",\"bkw\",\"k\",\"elh\",\"w\",\"ufksguh\",\"jisuqqws\",\"hyyfwcsh\",\"emfawdxb\",\"t\",\"yoxapiji\",\"pdcjumn\",\"hqec\",\"gzdly\",\"ehllf\",\"dx\",\"jhuc\",\"gltvwcy\",\"okvjkvyq\",\"q\"],[\"faa\",\"gywv\",\"jufdmqq\",\"t\",\"cgfk\",\"yzxk\",\"ilmw\",\"bogyvd\",\"emmgkkhp\",\"mxaoluup\",\"bomvtw\",\"pwvjbqoh\"],[\"ufogi\",\"rjx\",\"agstpaj\",\"zricy\",\"bsrwbgw\",\"ygmkjptq\",\"wzitf\",\"mpzrhhn\",\"cwymbawg\",\"gdwbpg\",\"v\",\"kbv\"],[\"ggznq\",\"sf\",\"beawy\",\"s\",\"xfke\",\"wms\",\"a\",\"quyagc\",\"ocfiqazn\",\"srsgf\",\"dxsjwj\",\"sqda\",\"ggyhr\",\"pkmz\",\"xdlcoipx\",\"pwahre\",\"m\",\"hb\",\"tlddi\",\"xehrx\",\"pbn\",\"waakunjp\",\"x\",\"knuafilh\",\"et\",\"mrrswj\",\"lzpetg\",\"gdycfau\",\"c\",\"qscflqzr\",\"fxn\",\"od\",\"p\",\"mxesle\",\"mkgz\",\"jo\",\"svoe\",\"bfgwp\",\"bmul\",\"qnhgyuca\",\"zpt\",\"pimd\",\"dl\",\"gvn\",\"niyqu\",\"mnbb\",\"lmky\",\"iowmfew\",\"lwvlsyl\",\"blydkbg\",\"frysxj\",\"rfnllaff\",\"zwwpuo\",\"dkux\",\"n\",\"ojni\",\"rg\",\"dubywary\",\"hbtp\",\"ggdawy\",\"uiwde\",\"onkzyw\",\"q\",\"cohfs\",\"qjys\"],[\"jvidruif\",\"qxt\",\"nwj\",\"mhfnfrr\",\"hgyejw\",\"uc\",\"dujy\",\"e\",\"mubdtbe\",\"mjhfphus\",\"tiqy\",\"zosswje\",\"beu\",\"saq\",\"rrfwb\",\"prztfh\",\"uyufwg\",\"zsp\",\"egbq\",\"zhmowi\",\"dbc\",\"j\",\"bdujztlz\",\"hgigfk\",\"vxklb\",\"gf\",\"uogtaom\",\"lvlptta\",\"xczvb\",\"nlzwmfj\",\"ytcj\",\"n\",\"o\",\"m\",\"rtpz\",\"atwxg\",\"vuey\",\"zhuikb\",\"jauoana\",\"fv\",\"amto\",\"ycg\",\"ynss\",\"lcxzhg\",\"et\",\"lwxkn\",\"nlvhc\",\"zhuiuaqt\",\"glsvjl\",\"vlkr\",\"ncmgx\",\"xsggkpoa\",\"qmc\",\"rsekk\",\"puvseih\",\"mwsl\",\"qwluaepp\",\"b\",\"uwnxdgv\",\"xlnomnc\",\"fqvgfdxn\",\"hfmwsl\",\"ervfzz\",\"irhu\",\"zc\",\"snpy\",\"k\",\"cnck\",\"zph\",\"xssgzj\",\"oyx\",\"va\",\"ir\",\"zdxjg\",\"xhxanyck\",\"ooruhnim\",\"sm\",\"ddlyllm\",\"pgugzezg\",\"xa\",\"pki\",\"cgywt\",\"zvi\",\"dsyj\"],[\"ksrleqo\",\"ukgr\",\"eremwj\",\"a\",\"n\",\"bqosxv\",\"uqjrmmvy\",\"ipcaze\",\"culbbu\",\"kgenhjk\",\"h\",\"imjp\",\"pytoyia\",\"ooqnxztg\",\"unffvs\",\"rltqagxd\",\"xbuwoc\",\"udcqlh\",\"ke\",\"lhih\",\"sbaiyxi\",\"dpvnidbl\",\"lrtignxm\",\"syu\",\"crojpx\",\"gkmylf\",\"lirxehxf\",\"vwadeg\",\"rqb\",\"yeekpod\",\"m\",\"mcx\",\"cqi\",\"esxxk\",\"so\",\"qy\",\"g\",\"wodgas\",\"z\",\"ju\",\"rtt\",\"xfbas\",\"gfxw\",\"ul\",\"v\",\"dtfga\",\"nsh\",\"aqo\",\"bepioryw\",\"sktvon\",\"xlop\",\"agkgdkob\",\"ivr\",\"owne\",\"szb\",\"pxvwjr\",\"iqqmh\",\"kjis\",\"smihtt\",\"up\",\"zyy\",\"rvsfrt\",\"op\",\"kcrqgh\",\"lkr\",\"fuy\",\"sggr\"],[\"gonkvak\",\"ehn\",\"fqddsdat\",\"fcrcewan\",\"gluou\"],[\"zotpousi\",\"kk\",\"os\",\"imkcjei\",\"e\",\"ftm\",\"hm\",\"wjl\",\"mdt\",\"lhadgwy\",\"casllmd\",\"tyf\",\"gohq\",\"oip\",\"maad\",\"bhk\",\"dnpeub\",\"slwgr\",\"pejxja\",\"paytzh\",\"brvr\",\"fpjrc\",\"dfsa\",\"eqxexb\",\"fhev\",\"ruhh\",\"qtnhx\",\"msv\",\"vfm\",\"qevdsqe\",\"vfph\",\"ckbpeoeq\",\"mdzafgt\",\"itmi\",\"b\",\"oucyynen\",\"taai\",\"h\",\"wgv\",\"siufqxgi\",\"mtazym\",\"rx\",\"jajdgpd\",\"uhvtft\",\"u\",\"msbfure\",\"ptxme\",\"lx\",\"thitffou\",\"gmucgwzn\",\"obc\",\"v\",\"eng\",\"qdknzvz\",\"jwgnbby\",\"impjck\",\"bcb\",\"pkn\",\"o\",\"xp\",\"gmfnh\",\"mywdwp\",\"kzuxxuv\",\"bcix\",\"s\",\"ngrt\",\"bcju\",\"ta\",\"y\",\"ofb\",\"hgra\",\"hnhuelbq\",\"nbzlxa\",\"psmg\",\"iflujdaz\",\"rmtssud\",\"xfi\",\"byzjgm\",\"ob\",\"vbe\",\"ofe\",\"sek\",\"tdli\",\"bf\",\"bt\",\"bjer\",\"w\",\"obn\",\"d\",\"cbz\",\"k\",\"tozixprd\",\"hjyr\",\"pajyswp\",\"gxvmefzf\",\"kg\",\"wadkxzaq\",\"tvhzeg\",\"gxkfyn\"],[\"mll\",\"igzld\",\"tvwfxs\",\"ifq\",\"shhuo\",\"uviv\",\"uvpkf\",\"jauaqt\",\"ynjwlee\",\"cs\",\"yd\",\"hlb\",\"lnny\",\"omuza\",\"yyowsm\",\"ls\",\"lo\",\"dnyjz\",\"noegzltx\",\"meqk\",\"f\",\"cu\",\"aupz\",\"pnftkx\",\"byjc\",\"b\",\"v\",\"htkktkde\",\"ziuyz\",\"tm\",\"pukfsj\",\"j\",\"arrtgey\",\"xr\",\"yikddlnx\",\"nmbtrkad\",\"mhwj\",\"nvlmoonc\",\"pjpce\",\"dv\",\"yfylyfc\",\"qahzyns\",\"qco\",\"g\",\"kdehua\",\"fpjgsizt\",\"objkc\",\"opblopla\",\"gwzecc\",\"nnkiv\",\"dmhxc\",\"zefrqrlh\",\"cyyfo\",\"yzogmb\",\"iakuf\",\"ytmjg\",\"wylwp\"],[\"xougy\",\"gjmb\",\"r\",\"lm\",\"yhvcxb\",\"uqur\",\"znwkkr\",\"byiio\",\"tsmybrt\",\"bqyvh\",\"bxmvg\",\"oiyzmj\",\"rq\",\"zfqo\",\"aynrb\",\"fkbgzy\",\"phprvuc\",\"wnfwsr\",\"dkcgbd\",\"dgr\",\"tzeomj\",\"y\",\"elproupv\",\"mxcbrrlu\",\"kpn\",\"l\",\"bl\",\"gvbx\",\"jxqxmuv\",\"e\",\"whsm\",\"lotlbz\",\"d\",\"xz\",\"eb\",\"z\",\"an\"],[\"svhrqh\",\"ooto\",\"abyzjgj\",\"ikis\",\"cirgnf\",\"eshmakm\",\"wn\",\"qp\",\"pcyf\",\"svwis\",\"lwvhry\",\"djhwimr\",\"zirggxfr\",\"hjuz\",\"cx\",\"hgslg\",\"uem\",\"cqseggpo\",\"kbb\",\"qweg\",\"tzy\",\"bskohgcm\",\"calqw\",\"kjp\",\"idojlqgn\",\"xy\",\"yhyxn\",\"dgsgi\",\"laaupkd\",\"whrwcd\",\"bn\",\"bstbl\",\"kok\",\"u\",\"bwqquuuy\",\"m\",\"zn\",\"vz\",\"mndejm\",\"motu\",\"xrpnfdu\",\"h\",\"bp\",\"fxhsuu\",\"swbynzol\",\"wfgtp\",\"okgd\",\"xfb\",\"vg\",\"hmcnloo\",\"tdzwoaw\",\"bzbmvbu\",\"nkbstopi\",\"vxpwzfs\",\"ek\",\"mh\",\"tjvglo\",\"qgdd\",\"nunuv\",\"hezii\",\"advz\",\"y\",\"qedtvx\",\"tksicthj\",\"jffujhf\",\"hov\",\"lvaskmbl\",\"kypa\",\"lqccyebo\",\"lw\",\"heiqx\",\"mpufpz\",\"rxngis\",\"orycagl\",\"bf\",\"tpmuhnpl\",\"haqyfufo\",\"shd\",\"w\",\"kesw\",\"vxes\",\"cyeovix\",\"lrwrhwbf\",\"ireqzx\",\"cqpehh\",\"xlht\",\"dwkxte\",\"eolyi\",\"boxqint\",\"bvyuzl\",\"zhxbx\",\"q\",\"uigd\",\"psydra\",\"glmd\",\"htfz\",\"oh\",\"sala\",\"bfcpzg\"],[\"bivoa\",\"yfqe\",\"lsfyzup\",\"ktcydtys\",\"bldgown\",\"vgvbsme\",\"lubx\",\"kjgbko\",\"japb\",\"blrjnjn\",\"bmugu\",\"x\",\"ddxb\",\"xgjxns\",\"bvykudcz\",\"z\",\"rlvybe\",\"fxdiywn\",\"ags\",\"njyknfy\",\"wtdeb\",\"o\",\"wq\",\"jtwrf\",\"hfawjrid\",\"s\",\"qal\",\"tt\",\"l\",\"qaq\",\"nmy\",\"anqccafz\",\"qmjfwh\",\"u\",\"yhqv\",\"sbc\",\"gcjdk\",\"cbtarzna\",\"uer\",\"jm\",\"fjx\",\"fejkqvy\",\"yttpiqj\",\"yyjaazzl\",\"zfmnn\",\"pqbrzhho\",\"bdos\",\"nruvliv\",\"kmuymas\",\"beuskjaw\",\"zcnuzqm\",\"xg\",\"ccbrqw\",\"kcvwi\",\"du\",\"f\",\"rtzbq\",\"r\",\"fsgait\",\"nxmngtf\",\"fcgshqau\",\"hovs\",\"phr\",\"cxflkogc\",\"dbvtbysl\",\"je\",\"lhfzdc\",\"gcvelf\",\"hw\"],[\"fpudcpdq\",\"vnnklb\",\"qkobff\",\"dfj\",\"hvuhtl\",\"s\",\"yseycc\",\"suzqlp\",\"zlyuczou\",\"bmgxrjb\",\"hvmxam\",\"njogumsi\",\"ez\",\"h\",\"kkcjvefa\",\"qxqb\",\"zpdik\",\"iluyh\",\"tocr\",\"mered\",\"udjebe\",\"w\",\"wwfhcgi\",\"epfnljam\",\"iz\",\"spa\",\"vzzfl\",\"cia\",\"kvy\",\"qruved\",\"oivu\",\"ygog\",\"cn\",\"ntrvofp\",\"dgjdu\",\"jlcagk\",\"tg\",\"vmmyrghn\",\"zeliuld\",\"wlpsyfk\",\"to\",\"jxrn\",\"meggayf\",\"ejkcva\",\"b\",\"qggrh\",\"qysmgz\",\"jd\",\"dixl\",\"icg\",\"yalncg\",\"a\",\"yjrhzqya\",\"ofzozxr\",\"jpt\",\"zuuuyrwb\",\"hgcanzea\",\"r\",\"kchar\",\"dlu\",\"ipfx\"],[\"terkfmsg\",\"tvvio\",\"efffpnxk\",\"tye\",\"ruxvu\",\"m\",\"ufrlx\",\"ri\",\"f\",\"acuasra\",\"rnltyefb\",\"l\",\"bd\",\"eai\",\"sxsg\",\"ln\",\"xpmqgi\",\"xnzh\",\"gdkfmvh\",\"rlzzbg\",\"kjt\",\"dafywrlg\",\"iyf\",\"gm\",\"jgcjpqo\",\"txbi\",\"msxeuk\",\"ofqdzo\",\"eam\",\"edr\",\"udby\",\"hrmwljch\",\"xadiij\",\"fnwpk\",\"irymgnl\",\"wr\",\"jjmlwvaj\",\"dxk\",\"vhqs\",\"etblfs\",\"qumwb\",\"jkkq\",\"a\",\"jadesjd\",\"i\",\"z\",\"pbggxbli\",\"qhkkpb\",\"esg\",\"wbcb\",\"g\",\"nzzzxf\",\"zygl\",\"hank\",\"ekvuedo\",\"xmzmz\",\"gw\",\"wslwmm\",\"jcpbpxdk\",\"zfk\",\"esfwfxz\",\"mctgtx\",\"xxp\",\"iwfjpb\",\"etzojkt\",\"ly\",\"hdaodkt\",\"tgdqayyr\",\"ngknu\",\"fxzz\",\"bpn\",\"fa\",\"c\",\"snlgqblp\",\"lf\",\"hwcqirs\",\"s\",\"eyqinhk\",\"grdglrp\",\"ykm\",\"hx\",\"nomtjwe\",\"karc\",\"kn\",\"p\"],[\"au\",\"vhpvtjml\",\"zryyz\",\"wwwr\",\"w\",\"vd\",\"bc\",\"xjn\",\"c\",\"gt\",\"oaf\",\"ggfx\",\"l\",\"h\",\"t\",\"fzd\",\"zneg\",\"bcvljj\",\"g\",\"acqbzcpg\",\"ud\",\"b\",\"yyodbar\",\"dvijf\",\"bdrkke\",\"crirtco\",\"db\",\"e\",\"nvju\",\"jucq\",\"ti\",\"yoypt\",\"nnhal\",\"xf\",\"qwe\",\"ftatanmk\",\"tsjaxaac\",\"whw\",\"gdcidgxe\",\"ekere\",\"sw\",\"phbzohr\",\"sgxjgzlj\",\"u\",\"qxfuymsv\",\"wevio\",\"fstaojn\",\"snynmfx\",\"ggcuovv\",\"hxwymy\",\"jd\",\"ma\",\"tmro\",\"ichmdqj\",\"vjinqohl\",\"hlzvai\",\"yp\",\"jbbirm\",\"fsckiak\",\"yhqdm\",\"vqlkipgq\",\"bmnrvk\",\"adktoowx\",\"ie\",\"avvv\",\"raceaxrv\",\"a\",\"uo\",\"xmlnagfa\",\"scg\",\"hapk\",\"senm\",\"gmiqujyh\",\"zla\",\"ildwllf\",\"cczhhuz\",\"ekytg\",\"p\",\"twdh\"],[\"q\",\"acpbq\",\"dunmmsl\",\"lvkoyxui\",\"zzy\",\"dne\",\"gw\",\"ynwsjqv\",\"bkfsgskm\",\"otzer\",\"hexwxks\",\"hmwa\",\"wvjexyvs\",\"kkix\",\"a\",\"hm\",\"qsr\",\"uhhq\",\"nkbwua\",\"kxkfxhpa\",\"bjrnaje\",\"uma\",\"ptwegwd\",\"upnyck\",\"gcgtnz\",\"zs\",\"reqmnno\",\"thtnshvc\",\"k\",\"hiunkv\",\"lhg\",\"pff\",\"vhr\",\"y\",\"lkpzrll\",\"pnoh\",\"ve\",\"etsh\",\"kno\",\"odvgaoym\",\"gstoucsf\",\"jbmytwjf\",\"ojv\",\"appjl\",\"kccprfov\",\"gxyvkix\",\"imk\",\"t\",\"or\",\"lxypjmjd\",\"w\",\"aif\",\"p\",\"snkmqge\",\"n\",\"qmvuhh\",\"epgu\",\"bfcfva\",\"jwbvntg\",\"pvaq\",\"vyuth\",\"zk\",\"ghofyfe\",\"old\",\"vjtn\",\"ovamenq\",\"mtljx\",\"zpxtsud\",\"ydfejw\",\"cyo\",\"ntdqrupy\",\"rmljjop\",\"jipyhkgv\",\"jdrbkmv\",\"dzcdokjm\",\"lg\",\"ccolykvj\",\"ym\",\"g\",\"xpdjlhdp\",\"nbb\",\"b\",\"iw\",\"gd\",\"satqr\",\"jt\",\"xwo\",\"fxx\",\"gzms\",\"utvccvep\",\"ibigtq\",\"qrq\",\"ofr\",\"wneshaj\",\"f\",\"oevqtgx\",\"gderdvij\",\"r\",\"zkvxjq\"],[\"k\",\"a\",\"ofvttmg\",\"x\",\"xvep\",\"l\",\"nfpywff\",\"owd\",\"asia\",\"ucknzl\",\"nticyujp\",\"yqstvsuo\",\"ojje\",\"bdgphzu\",\"n\",\"vfexk\",\"h\",\"slsdvi\",\"xnbtud\",\"fssm\",\"g\",\"hcqgrg\",\"enralnde\",\"nkduorni\",\"o\",\"ajkxem\",\"rpwckq\",\"brzaqop\",\"hsz\",\"yk\",\"gu\",\"hvl\",\"uebnj\",\"incqx\",\"i\",\"jb\",\"iubd\",\"gahaxoog\",\"yxxxeylq\",\"dhi\",\"cyxb\",\"fdxewafw\",\"zwteabmc\",\"zmrjw\",\"qlwcw\",\"ubai\",\"si\",\"otqifg\",\"y\",\"rttq\",\"izmrwhj\",\"dwhidp\",\"mtlrlso\",\"nhqls\",\"ffw\",\"clg\",\"nvwc\",\"pmmf\",\"mslhf\",\"dzdnmmc\",\"eqfcwxo\",\"xg\",\"mie\",\"rrk\",\"ytiwed\",\"whfbif\",\"gfr\",\"q\"],[\"bxrjkgxq\",\"fptnyg\",\"n\",\"lqwi\",\"q\",\"sdhbxp\",\"tbprv\",\"wmyuqmr\",\"bijrog\",\"g\",\"fpsij\",\"ujvyus\",\"jqqsceky\",\"ykeah\",\"rxfcd\",\"wfnfgjgu\",\"woyocl\",\"uwfcy\",\"gykimk\",\"sqmg\",\"yslzlqd\",\"amyiyj\",\"uvzjqfep\",\"zbkyoh\",\"borwtfh\",\"tmdv\",\"hul\",\"oqeprxfa\",\"jrpaxvb\",\"jcmuyyf\",\"brw\",\"fafn\",\"eiarkc\",\"j\",\"ekrl\",\"whfv\",\"kjbdl\",\"bpczp\",\"hfvkiuyk\",\"pvc\",\"kfxdymxb\",\"bofr\",\"h\",\"s\",\"bvtwlt\",\"hhj\",\"bkeqdhq\",\"sclx\",\"hiz\",\"qtsvjaez\",\"ontktd\",\"gql\",\"ool\",\"dontitz\",\"a\",\"mdglfb\",\"sa\",\"yyzvayrh\",\"ufimddbs\",\"rk\",\"qgoo\",\"kbn\",\"hd\",\"emuxwp\",\"i\",\"yh\",\"jf\",\"ub\"],[\"g\",\"csnywr\",\"hsucajbz\",\"chzxo\",\"jswjwi\",\"sqtiqcvl\",\"xzumcs\",\"f\",\"c\",\"moz\",\"hdzhes\",\"k\",\"wmdn\",\"biqdge\",\"m\",\"vntfr\",\"zis\",\"q\",\"lcoftm\",\"ikuog\",\"lp\",\"jtejvw\",\"n\",\"xs\",\"ut\",\"qsogiqiy\",\"gipvcefr\",\"kuie\",\"qy\",\"uer\",\"aeevzaz\",\"gkoksp\",\"sx\",\"hocy\",\"xtzzh\",\"bjrumdn\",\"rvaiy\",\"i\",\"mtmn\",\"lhca\",\"kg\",\"tfol\",\"qnlna\",\"rtbdtvm\",\"oxacbtqv\",\"ezqkfz\",\"xbrkgdyw\",\"trh\",\"fcomyr\",\"uqskjr\",\"oeyuz\",\"qivk\",\"kricqh\",\"jbwjpnk\",\"qpprdphu\",\"vq\",\"iyemic\",\"yniipis\",\"lxkl\",\"wf\",\"kaxkvkjv\",\"cgqxwko\",\"smqxudzq\",\"s\",\"ugqg\",\"cbgvjf\",\"tja\"],[\"xiv\",\"h\",\"r\",\"cctjw\",\"oexo\",\"ddcuaaq\",\"citos\",\"ks\",\"pqwkd\",\"bh\",\"pxgmspla\",\"irygzi\",\"trx\",\"jtax\",\"hqydm\",\"ehlgojs\",\"tru\",\"motuandq\",\"nl\",\"m\",\"htr\",\"jr\",\"ta\",\"tzurlmu\",\"ywceyvkc\",\"qeizry\",\"vqs\",\"vux\",\"uaxy\",\"tix\",\"hualrle\",\"hcfomp\",\"nnjn\",\"dlzhrdb\",\"ipysnwgh\",\"guf\",\"vyxqptfc\",\"jrdnvoa\",\"xtzlh\",\"aexrptb\",\"zxnllz\",\"zcl\",\"bb\",\"juf\",\"geyr\",\"mkvqncs\",\"leexudh\",\"uoqmly\",\"qeff\",\"jhhwp\",\"yfl\",\"usw\",\"tojeb\",\"jjzhd\",\"vxecuy\",\"tzjix\",\"kknoabwx\",\"bmune\",\"wdunp\",\"dpdyzvc\",\"ojwuhrt\",\"xaiej\",\"eujwuofn\",\"wvwig\",\"vhd\",\"apseumj\",\"lefr\",\"olerpji\",\"tzronke\",\"zaqtjd\",\"hmxahz\",\"wxtek\",\"mzv\",\"fdwogyuu\",\"dcctlxps\",\"ronlfg\",\"pcrpkry\",\"k\",\"cwlulwe\",\"iq\",\"merx\"],[\"qsyesc\",\"lpxv\",\"wb\",\"v\",\"fiqypqx\",\"mur\",\"zzd\",\"ebcxoegr\",\"cfj\",\"wxxoo\",\"tbtpjkeu\",\"ihoxlbum\",\"jqmsk\",\"hogixlxh\",\"hwv\",\"pez\",\"xwret\",\"qsfjqu\",\"ankkyoj\",\"jtqjv\",\"bt\",\"pc\",\"wpqfle\",\"yqwecuie\",\"e\",\"wf\",\"aeszt\",\"r\",\"f\",\"xruh\",\"mzekh\",\"soxsbpj\",\"dfkw\",\"yt\",\"mk\",\"cyuefc\",\"aficur\",\"nevfwp\",\"ph\"],[\"mgdekuy\",\"v\",\"udrj\",\"sgu\",\"wxoybsq\",\"mmqoeyr\",\"ikiv\",\"k\",\"qubqspx\",\"hx\",\"eaxf\",\"n\",\"iyaxd\",\"t\",\"frivanp\",\"jiw\",\"xpl\",\"izwh\",\"gobzzi\",\"ypvggn\",\"ykp\",\"z\",\"rwnigrkf\",\"sjfwungg\"],[\"ug\",\"lny\",\"vgao\",\"qszbjq\",\"dhz\",\"uf\",\"odskaqu\",\"bnkqx\"],[\"zsemv\",\"ylk\",\"erw\",\"upxtmmxf\",\"zomkt\",\"lct\",\"adz\",\"ivjg\",\"s\",\"m\",\"o\",\"oe\",\"rtdyv\",\"xfc\",\"wd\",\"qxa\",\"sdwxylte\",\"q\",\"k\",\"ysftfpvd\",\"yfkul\",\"qdap\",\"ibt\",\"sr\",\"kjkli\",\"jtx\",\"mwgzulw\",\"uo\",\"crmiu\",\"goohv\",\"anjyuizb\",\"g\",\"ihvolkn\",\"qvaif\",\"avceu\",\"xps\",\"ji\",\"tkdcsud\",\"lcd\",\"rttt\",\"yutstb\",\"hlec\",\"qdh\",\"gpi\",\"luqdkws\",\"iqfc\",\"dawevmzx\",\"ivtbd\",\"jawy\",\"apfgvv\",\"neo\",\"eldzbubv\",\"sly\",\"ckkulcb\",\"erpii\",\"ek\",\"hou\",\"wstyrch\",\"prmvw\",\"ahws\",\"nkvbdaa\",\"mdlgn\",\"qz\",\"tztewgwv\",\"d\",\"ldpjxk\",\"f\",\"b\",\"r\",\"hfxsu\",\"n\",\"wktrw\",\"awmr\"],[\"vz\",\"v\",\"lsagloa\",\"vms\",\"mdkatgdj\",\"o\",\"arr\",\"ucfmyuyr\",\"wtjhkfmj\",\"hkc\",\"jdmnhyhh\",\"hkxmtotp\",\"ycer\",\"afgsbd\",\"boyk\",\"gagsl\",\"upswld\",\"d\",\"nxagmcr\",\"ndugwcid\",\"bew\",\"sdrg\",\"wzgjs\",\"vtifmka\",\"mdybxh\",\"zfi\",\"qxvew\",\"eoowlp\",\"uwvz\",\"zfkpa\",\"mxenruky\",\"aqx\",\"cuygabd\",\"dhf\",\"tibvxib\",\"ulz\",\"qvfspy\",\"euvbqc\",\"sjpjog\",\"vt\",\"gpi\",\"sutbq\",\"fl\",\"exgai\",\"nlomewm\",\"obxj\",\"ibvsy\",\"mohr\",\"ierx\",\"bzapde\",\"buq\"],[\"yaqat\",\"vmsd\",\"wnqegc\",\"to\",\"ycqaqgdb\",\"f\",\"zpivtptj\",\"wtjwxas\",\"lpihzqy\",\"lfwwac\",\"liozmhk\",\"xwzn\",\"dfs\",\"xo\",\"eav\",\"gajcgr\",\"itakvz\",\"klcszliq\",\"kbh\",\"jr\",\"pp\",\"gsnghu\",\"hog\",\"s\",\"utlh\",\"wyqe\",\"svxy\",\"i\",\"aw\",\"qawyay\",\"if\",\"ng\",\"mqjwt\",\"z\",\"nfotqiw\",\"aic\"],[\"gnmidgfy\",\"cafsch\",\"wj\",\"dckagg\",\"qamjip\",\"wbt\",\"ppargdq\",\"oefph\",\"se\",\"gjnnnu\",\"zro\",\"vama\",\"fveo\",\"xxzx\",\"zorzy\",\"qgy\",\"fyfqq\",\"az\",\"iyafjqy\",\"tnscl\",\"q\",\"ndoulo\",\"unwcvu\",\"k\",\"jhw\",\"eaq\",\"xtxyavgn\",\"pdt\",\"iz\",\"gvocnmn\",\"poums\",\"lb\",\"hlgdmmtd\",\"ngxfbcx\",\"blmfcue\",\"eye\",\"towposl\",\"bpmmu\",\"quducpw\",\"btwod\",\"swfap\",\"u\",\"wpar\",\"kpjoqlfk\",\"mjbraj\",\"qjgmbkns\",\"vrq\",\"elc\",\"n\",\"orrnrucr\",\"a\",\"gdkl\",\"jxcxle\",\"c\",\"rqiltgfz\",\"ezoo\",\"nwwconn\",\"y\",\"wste\",\"bnbzews\",\"pinbobm\",\"sc\",\"kedjjih\",\"e\",\"jcrlkex\",\"bc\",\"qmwwgspe\",\"f\",\"kmlmtqi\",\"otm\",\"jlhbt\",\"tvuiceq\",\"lxqz\",\"pzlvd\",\"bwwagl\",\"auepbxw\",\"ttdty\",\"mlzsi\",\"uwrpln\",\"tgrt\",\"vhva\",\"cfgraxi\",\"ori\",\"ze\",\"sifc\",\"nwrhi\",\"gxca\",\"ebuh\",\"vzxd\",\"pucj\",\"troorwso\",\"ywk\",\"yedee\",\"qhnvm\",\"ttn\",\"pby\",\"nn\",\"zu\"],[\"bzvgb\",\"t\",\"rmk\",\"pqhl\",\"kxusgwwf\",\"rdn\",\"bdpfmi\",\"manppy\",\"hwgpqj\",\"fp\",\"cdmka\",\"kb\",\"rcng\",\"ko\",\"dsnqkcgr\",\"zzfrlfb\",\"cfvhgiao\",\"klpm\",\"h\",\"izc\",\"nrmha\",\"sfda\",\"xjrczjbh\",\"c\",\"cz\",\"qydo\",\"xwwzis\",\"zci\",\"vq\",\"x\",\"mu\",\"o\",\"pbbevadv\",\"fcixmwo\",\"u\",\"auehjyea\",\"pahoflb\",\"yp\",\"elqllg\",\"yf\",\"roeiav\",\"xdziogtc\",\"g\",\"zflpon\",\"kpm\",\"dxbw\",\"ncirsk\",\"l\",\"d\",\"hsb\",\"wnr\",\"nlq\",\"xzfyi\",\"k\",\"lbubvak\",\"vdwfpxa\",\"tdlske\",\"bfj\",\"oeptbllx\",\"kbdyzm\",\"pzowugg\",\"br\",\"p\",\"thqwr\",\"mr\",\"ydrhmj\",\"navbix\",\"kq\",\"kbs\",\"lk\",\"iyuyifpj\",\"agw\",\"vei\",\"dspiefab\",\"lhr\",\"arrr\",\"swhps\",\"hngaewzg\",\"ial\",\"jjulepyk\",\"ylayfbqv\",\"ne\",\"kjusffp\",\"bfuelxd\",\"njskzfm\",\"pnhhm\",\"euct\",\"tnpgyr\",\"vsvhq\",\"cgbenf\",\"otdofhyr\",\"trvyqg\",\"vj\",\"yvhyzajk\",\"gfply\"],[\"fpnynxcn\",\"s\",\"xpd\",\"jlnnj\",\"wyppwei\",\"mbjejj\",\"byv\",\"zcrsiqf\",\"mbtrofo\",\"bjzpdtcu\",\"wcolhnk\",\"vv\",\"lwqcqxb\",\"ncrb\",\"gnd\",\"ggnroqk\",\"lbxy\",\"rbjzorvg\",\"yxrija\",\"lqzwkp\",\"kgjk\",\"pfhpsns\",\"pyxkbe\",\"nwrbseln\",\"wvzzh\",\"z\",\"ftxfhpx\",\"uerx\",\"upe\"],[\"p\",\"gyz\",\"houzewi\"],[\"eyed\",\"viwtvpqz\",\"eovrucew\",\"sactnm\",\"q\",\"xjtkur\",\"t\",\"hev\",\"azholcbl\",\"h\",\"dxuvzo\",\"jpoelgz\",\"f\",\"wmmudlm\",\"qao\",\"ni\",\"m\",\"jbnliai\",\"vyb\",\"xlac\",\"jhahxwo\",\"kk\",\"tbv\",\"hryjx\",\"yit\",\"ggalak\",\"gzmivzc\",\"mhncgq\",\"fgar\",\"c\",\"pngpkf\",\"zsu\",\"lkce\",\"axcgtlwg\",\"hyawq\",\"gjy\",\"jfbkgyh\",\"usfrbuqs\",\"umtmbwic\",\"ks\",\"vxjnrpt\",\"zkwmuahz\",\"p\",\"ljhtgdfw\",\"aequgwp\",\"fjhqofm\",\"nbp\",\"zg\",\"qmh\"],[\"yfot\",\"rqoiq\",\"hgncss\",\"xbbehmg\",\"yrjjx\",\"gjfxqtcm\",\"jvoetnv\",\"vvojqoj\",\"dnyf\",\"cqwvu\",\"nxpjnpxx\",\"oz\",\"jfksxit\",\"pisogyw\",\"mtq\",\"y\",\"imqajzmd\",\"swxta\",\"jbs\",\"j\",\"mygkan\",\"tqlkth\",\"kqecblp\",\"hfucle\",\"dwp\",\"ep\",\"g\",\"jdxe\",\"dh\",\"f\",\"nd\",\"jvjcp\",\"orl\",\"lwz\",\"qzy\",\"tnznoze\",\"pefigm\",\"rww\",\"fxtda\",\"zrfs\",\"tuh\",\"vswzpfsq\",\"hs\",\"lkyt\",\"mkpejmc\",\"rqfqitq\",\"mwxt\",\"fqrwxqoh\",\"pfmk\",\"ucspb\",\"teikq\",\"qgamdor\",\"djldvmql\",\"uptrf\",\"htr\",\"etsnqhce\",\"zlbeyfm\",\"znsm\",\"ysrfvgm\",\"wwkehwr\",\"ktnfvuxs\",\"d\",\"mnta\",\"ybyg\",\"dndgwklv\",\"jopuyl\",\"eoa\",\"kgsbid\",\"ewrkaoe\",\"fwl\",\"flf\",\"pldbnjmg\",\"hxcqo\",\"boincann\",\"bbhidxx\",\"tkihurez\",\"cupaornn\",\"opnzbamc\",\"b\",\"qdv\",\"w\",\"gfiurvro\",\"p\"],[\"rdnxar\",\"nszmxqz\",\"ly\",\"oqdqo\",\"gunwv\",\"dnzyp\",\"fl\",\"npqsr\",\"mjcoq\",\"v\",\"gmigzal\",\"njklfyjs\",\"fansrxhk\",\"zl\",\"shldua\",\"yroum\",\"akiidjku\",\"kiqtgn\",\"xcgzqfsx\",\"kegqhue\",\"ax\",\"yx\",\"pfasuoip\",\"va\",\"ehorh\",\"jf\",\"m\",\"eln\",\"nccyp\",\"r\",\"qyleqwm\",\"jx\",\"qbxfug\",\"n\",\"mnrnn\",\"wznldtn\"],[\"e\",\"eyxx\",\"fluav\",\"usmkvic\",\"gm\",\"lgerc\",\"c\",\"mmztt\",\"daxa\",\"yucyjgl\",\"exk\",\"kfuxfj\",\"ahcqy\",\"loklbdum\",\"edjbvrm\",\"izumin\",\"u\",\"jjkjhrpu\",\"tqttke\",\"wc\",\"bf\",\"synprmt\",\"wuv\",\"mr\",\"lcmx\",\"j\",\"uidn\",\"rvfget\",\"i\",\"itdibyfn\",\"qh\",\"jzpf\",\"tgqjtn\",\"gk\",\"rvin\",\"sih\",\"ykmcm\",\"tlj\",\"hm\",\"zffdcd\",\"iki\",\"fymxxvam\",\"ddyjrtih\",\"geu\",\"pvwgd\"],[\"ppy\",\"zfndbys\",\"knigx\",\"ml\",\"xrk\",\"w\",\"xedbgr\",\"id\",\"ay\",\"kekuqlo\",\"nnxrlg\",\"ohwvbxme\",\"zpd\",\"evuahj\",\"qutrwott\",\"uy\",\"iwoi\",\"i\",\"bdaw\",\"yqynxfld\",\"nyhhk\",\"qqku\",\"ytrt\",\"wf\",\"qloi\",\"v\",\"aaytlfld\",\"gviun\",\"q\",\"ar\",\"jq\",\"felq\",\"zpvo\",\"dbv\",\"tmhac\",\"a\",\"jpi\",\"s\",\"do\",\"uck\",\"e\",\"mx\",\"osjw\",\"gs\",\"xgma\",\"frteyp\",\"nkwip\",\"nqwfcg\",\"aza\",\"n\",\"vhmvnpd\",\"ippgkem\",\"pxpc\",\"eercvp\",\"izv\",\"pylub\",\"vzokgasl\",\"kl\",\"vxx\",\"xz\",\"b\",\"wi\",\"zbozkt\",\"knm\",\"blfh\",\"tntquag\",\"wiagfoln\",\"oyqq\",\"bezo\",\"kzh\",\"tli\",\"dy\",\"zat\",\"iow\",\"ermus\",\"thqffwk\",\"guajus\",\"vl\",\"ecb\",\"vby\",\"oq\",\"bcehopq\",\"rdgmydc\",\"jimkbb\",\"xh\",\"oc\",\"nco\"],[\"dzdg\",\"wvhik\",\"e\",\"omml\",\"rdpqf\",\"tioty\",\"t\",\"elf\",\"npraml\",\"gaoelk\",\"ja\",\"pdfco\",\"hxyj\",\"h\",\"bbuwooj\",\"wwt\",\"pizce\",\"uclh\",\"dau\",\"b\",\"dbs\",\"lu\",\"ds\",\"wpyc\",\"p\",\"qhekm\",\"qw\",\"pdwg\",\"gx\",\"wf\",\"eggph\",\"sczwwvq\",\"tdj\",\"df\",\"sd\",\"l\",\"unmkvluu\",\"oacqhj\",\"mzffx\",\"kz\",\"acxti\",\"gr\",\"ppwpwbt\",\"tkx\",\"bzxvy\",\"cwycrwl\",\"u\",\"xwgfzq\",\"nqhjun\",\"uauuipd\",\"yi\",\"ezzmwu\",\"cjvqp\",\"hnigso\",\"phjgws\",\"ob\",\"ccpwsil\",\"morqlzr\",\"o\",\"lidxfhi\",\"ymrde\",\"vigxzuc\",\"cpymbdg\",\"okqkgoxz\",\"mcghu\",\"wr\",\"zq\",\"nfidyyad\",\"mottt\",\"uglbaymo\",\"nlhuk\",\"xhw\",\"uywv\",\"cspukhav\",\"qnhuq\",\"hrwfjmgp\",\"ap\",\"owsunwds\",\"ltijio\",\"xi\",\"pa\",\"pwxtip\",\"guydmcik\",\"crg\",\"jiogsz\",\"g\",\"yrantf\",\"uogcx\",\"zgd\",\"ib\",\"et\"],[\"hg\",\"q\",\"sjfpmyk\",\"vnyujcfp\",\"ivfndo\",\"uhljndcc\",\"jpggmj\",\"qiqfxgo\",\"lxgsrvu\",\"lktx\"],[\"msymhf\",\"o\",\"s\",\"ubucsa\",\"suoyxbym\",\"owefypt\",\"mvf\",\"kz\",\"ffmo\",\"qgp\",\"jenhpmem\",\"ufyjwcji\",\"tsxgheia\",\"bqv\",\"mjdjckq\",\"wxe\",\"bi\",\"mctn\",\"svjbchp\",\"svalyg\",\"rf\",\"okji\",\"i\",\"fcaac\",\"am\",\"kyujid\",\"hl\",\"fjadaqt\",\"edro\",\"hiyu\",\"xbz\",\"y\",\"gmvy\",\"tpulhcb\",\"dmxrxgnk\",\"px\",\"oacines\",\"z\",\"gmfeno\",\"wagtzlvz\",\"pzacgh\",\"xe\",\"hqsq\",\"ldeepq\",\"hyoffeeb\",\"xsbl\",\"chb\",\"hpz\",\"thccemp\",\"ru\",\"lb\",\"qel\",\"hmrxruun\",\"ze\",\"qgchrhoo\",\"vadgz\",\"e\",\"wkwke\",\"u\",\"il\",\"emoqk\",\"fkg\",\"fnik\",\"wysy\",\"sakluw\",\"kxyswlaq\",\"p\",\"xows\",\"mhltzglr\",\"slg\",\"lsklp\",\"k\",\"ymoxhzh\",\"cwgjknk\",\"apszy\",\"lp\",\"foi\",\"fcjnds\",\"mkvflt\",\"b\",\"swjyxt\",\"dinpw\",\"sn\",\"ivzx\",\"dhacxffh\",\"x\",\"lch\",\"zlt\",\"wa\",\"rvtwlv\",\"iprjcg\"],[\"bjehuqnc\",\"jrnn\",\"ndhnb\",\"gqqp\",\"ypmdjqmp\",\"qrtlv\",\"dpnwcb\",\"uodhgmoh\",\"vr\",\"razibg\",\"ov\",\"poo\",\"dmbl\",\"sda\",\"zc\",\"p\",\"onigk\",\"dwdopd\",\"bpsh\",\"cslwub\",\"phvrj\",\"hc\",\"tphnp\",\"xfamcep\",\"atopup\",\"wep\",\"ogv\",\"wurqumc\",\"gkvh\",\"vzpjq\",\"nnjkw\",\"owutwnmo\",\"gfgz\",\"gonrzz\",\"n\",\"zhzuc\",\"qruojqfq\",\"lpzx\",\"ixziptn\",\"xebuy\",\"uym\",\"hhuihm\",\"axcu\",\"tolmunph\",\"yykbwp\",\"fvvgky\",\"obgnikyk\",\"fly\",\"oamuqnn\",\"mzbemiqk\",\"akhuwa\",\"s\",\"e\",\"jxsbwep\",\"ph\",\"zrs\",\"gugqrygj\",\"qvldbq\",\"mrnxt\",\"t\",\"pcbiean\",\"xcrvuf\",\"lgi\",\"lcqqavi\",\"dqqr\",\"ut\",\"mo\",\"bv\",\"rmdfim\",\"smswqjg\",\"abcsi\",\"yytgk\",\"xjaxedrn\",\"gho\",\"banoxg\"],[\"ab\",\"idvecxv\",\"pqxdbhbf\",\"epl\",\"uqg\",\"hq\",\"wt\",\"h\",\"prcfwr\",\"ifgugc\",\"xhfzfcew\",\"gionyw\",\"qk\",\"b\",\"yxp\",\"bndes\",\"mqriwta\",\"epww\",\"qsiblhpc\",\"caelq\",\"qp\",\"iuusxswh\",\"rtgz\",\"gawwbh\",\"hprav\",\"nhwg\",\"tsccadjt\",\"ic\",\"quik\",\"kctit\",\"nanpcpy\",\"u\",\"xqx\",\"lxgm\",\"dtkkt\",\"fmwigv\",\"qlgdfb\",\"cirgqpz\",\"szckg\",\"kyw\",\"wghu\",\"szmltbbt\",\"kpb\",\"nntwxa\",\"ze\",\"r\",\"mnj\",\"c\",\"zhu\",\"izn\",\"yjcqkjzd\",\"xl\",\"ofuvpvc\",\"iadbcxt\",\"fmlnwqqj\",\"sq\",\"iolks\",\"lrffbwt\",\"hhrrrwg\",\"hi\",\"mrd\",\"wdomfuhs\",\"yf\",\"nmztql\",\"dnqpg\",\"tninf\",\"aguj\",\"rdgrdybj\",\"veak\",\"jybykgsw\",\"oagi\",\"ausucpe\",\"ru\",\"m\",\"xp\",\"bs\",\"iyv\",\"nzxubcff\",\"zwy\",\"o\",\"vga\"],[\"vajsdzax\",\"dxrquzro\",\"is\",\"luxuvqjj\",\"qoxeqmk\",\"v\",\"vz\",\"gbtde\",\"upeaxrwv\",\"wmkakss\",\"n\",\"fncgyy\",\"jsxzdgd\",\"fiivivd\",\"hgyzfxzz\",\"o\",\"boqi\",\"xkuakbf\",\"bkjkcmn\",\"fv\",\"cbke\",\"dfebt\",\"jjpm\",\"hmqg\",\"loqmgb\",\"hyxbzoaq\",\"jfnw\",\"ekyrht\",\"ujujjiqi\",\"qivhuoas\",\"odknxgdz\",\"tcjweip\",\"bbsk\",\"q\",\"bocnes\",\"ukdxpj\",\"dylm\",\"qeni\",\"xfc\",\"jccbede\",\"itv\",\"mlbsq\",\"qvgi\"],[\"rye\",\"txtcupu\",\"bvqrl\",\"tkyibn\",\"eyqmaue\",\"jctwn\",\"jhfoihfr\",\"qfz\",\"fjsnn\",\"iwrfl\",\"lgibxre\",\"cngc\",\"hmkujslv\",\"f\",\"udua\",\"wpnup\",\"psvsy\",\"fldsibh\",\"onnm\",\"pjzvi\",\"ta\",\"ehix\",\"lacb\",\"g\",\"xcsv\",\"pqsis\",\"aypgnzt\",\"aoqitkd\",\"ze\",\"i\",\"zcqcq\",\"vr\",\"blt\",\"amdi\",\"xlmqrr\",\"pua\",\"lejp\",\"wnocztq\",\"kzjmdnr\",\"rr\",\"jz\",\"zpv\",\"ibojwdlc\",\"o\",\"otig\",\"dowioug\",\"jfmxy\",\"pgc\",\"t\",\"nxtrruao\",\"jfur\",\"zmoplb\",\"hbkrv\",\"ohwt\",\"dnurtzs\",\"ccxvrcb\",\"slfljhih\",\"fm\",\"tvqqd\",\"jwyuycnq\",\"rjf\",\"zmdc\",\"svn\",\"punaah\"],[\"xtkc\",\"wqldor\",\"gypnt\",\"patv\",\"e\",\"aduvdf\",\"z\",\"rugqp\",\"xiyd\",\"bnztdp\",\"whhr\",\"dlloq\",\"sr\",\"sklinw\",\"trgrmy\",\"vrccpnr\",\"xsu\",\"s\",\"jdhuyw\",\"k\",\"nhk\",\"ecwxx\",\"nsy\",\"dzogfrbd\",\"b\",\"ruxftedt\",\"qzmubsv\",\"bjvvcma\",\"tbuexx\",\"ox\",\"klev\",\"q\",\"u\",\"kuq\",\"ubfas\",\"pnandszg\",\"ksvn\",\"vfce\",\"bzm\",\"zp\",\"rzaz\",\"yaikkatu\",\"ohoc\",\"eujx\",\"l\",\"nfdk\",\"y\",\"lj\",\"ixo\",\"bimnk\",\"v\",\"ypfb\",\"izhgd\",\"n\",\"flplskcf\",\"nip\",\"njx\",\"mtig\",\"lvfjcpv\",\"kuggace\",\"jfdiy\",\"amsp\",\"bewnpr\",\"phxi\",\"facmg\",\"ycp\",\"tinqtyl\",\"dih\",\"zrl\",\"dhpixrez\",\"nfpzchsl\",\"gcc\",\"mrbp\",\"x\",\"gcz\"],[\"o\",\"q\",\"cc\",\"ezoep\",\"wklrx\",\"zt\",\"rbo\",\"qxctbz\",\"otmzrkn\",\"i\",\"hb\",\"oscyv\",\"oqgjtkpb\",\"ronsbg\",\"wpeadaiz\",\"kut\",\"cu\"],[\"ua\",\"u\",\"j\",\"unh\",\"fu\",\"zzanmic\",\"y\",\"vlo\",\"tssqjhrz\",\"cvmadnl\",\"bd\"],[\"u\",\"vqrrj\",\"aq\",\"zm\",\"nliiw\",\"b\",\"op\",\"sur\",\"zmvjyrp\",\"uzd\",\"wdfuie\",\"wiq\",\"tu\",\"cqruaif\",\"blcg\",\"ikav\",\"trbc\",\"z\",\"gflws\"],[\"mgvo\",\"b\",\"v\",\"wdpwfut\",\"pzkohqdn\",\"hs\",\"mmgrcw\",\"jq\",\"iymucwgc\",\"zzbuml\",\"q\",\"pvcnha\",\"uihlvhq\",\"cakmupph\",\"urggrtl\",\"fkfkvumj\",\"exdcbc\",\"om\",\"mtgczd\",\"xoawcqub\",\"sgmlp\",\"wxnmbk\",\"ejqzp\",\"bzscd\",\"lkgxgyf\",\"f\",\"da\",\"hnrqe\",\"ptdlwxk\",\"jrttwgmf\",\"ei\",\"k\",\"loktiwm\",\"ktco\",\"hqyhjwcs\",\"vpfksv\",\"nnaq\",\"gozmrtf\",\"lt\",\"gtwlojc\",\"cowyr\",\"wnc\",\"o\",\"ly\",\"prbgczgh\",\"qcyfr\",\"qfbruv\",\"m\",\"dgsotgp\",\"kzlli\",\"w\",\"utiepy\",\"yvyhc\",\"lqkgv\",\"xmhfsbm\",\"oywzb\",\"myagutw\",\"vlvqrwpx\",\"vuvc\",\"vemqwifa\",\"yumjw\",\"nui\",\"xntljtp\",\"zhnuj\",\"zmzal\",\"ksyk\",\"vsmbrjv\",\"mba\",\"bjxjnzo\"],[\"exhawx\",\"a\",\"aidj\",\"atgtnuog\",\"nv\",\"hoijsvis\"]]\\n[[59,8,9,20,41,37,57,17,4,40,43,47,58,1,24,50,15,34,48,6,10,7,54,55,52,16,45,30,3,14,5,38,13,11,56,39,35,12,32,53,21,23,33,25,22,27,44,2,46,31,36,19,28],[6,26,27,15,19,32,50,41,25,34,30,59,48,23,5,31,39,0,42,2,33,7,58,43,8,3,56,4,37,16,21,24,45,10,52,49,9,17,35,38,55,51,44,12,36,14,13,29,11,22],[32,53,50,21,16,8,15,25,18,22,47,45,31,55,12,41,5,29,20,7,1,39,34,51,36,40,52,3,10,30,37,49,59,11,35,4,6,33,58,28,46,44,9,38,27,0,17,26,57],[41,15,7,58,6,27,21,17,24,5,51,8,59,43,38,50,37,42,0,26,16,36,44,57,2,1,18,35,40,29,23,46,49,34,9,31,30,47,28,10,48],[19,40,15,28,57,0,44,10,22,45,9,11,58,27,21,41,47,6,34,24,26,43,20,7,17,18,14,53,1,8,23,54,38,29,5,25,51,2,56,49,37,33,48,32,55,36,59,12],[45,21,48,35,58,31,32,42,24,7,12,3,43,11,9,1,17,2,55,14,29,40,0,19,28,49,16,25,56,10,4,26,20,33,51,13,23,47,59,38,44,34,39,18,50,36,37],[1,53,19,32,38,3,28,30,24,37,31,55,20,57,41,44,21,51,47,27,26,52,4,0,22,39,54,29,34,17,10,13,50,36,11,48,2,18,23,46,49,8,9,12,33,40,58],[46,32,3,8,52,35,59,38,5,41,57,43,56,27,37,48,12,16,23,34,42,2,30,25,9,0,1,51,4,55,31,18,29,22,19,58,49,44,36,45,11,54,26,14,24,40,47,17,28],[15,0,56,23,7,52,12,27,16,43,2,9,44,45,3,39,55,33,17,13,59,21,1,28,49,4,46,51,30,24,58,35,29,20,11,18,42,6,32,47,40,25,31,34,48,54,14],[44,54,0,49,51,16,8,48,21,26,53,55,5,20,38,4,28,33,12,7,18,15,10,43,32,25,30,42,36,13,1,3,29,35,34,24,41,17,56,50,45,57,27,2,19,6,40,58,22,11],[21,37,44,42,16,47,17,4,29,33,53,36,34,9,0,32,23,46,50,2,6,54,20,18,22,49,1,5,45,48,25,30,41,38,14,43,15,24,11,12,35,3,39,31,58,56],[49,51,59,28,44,47,5,36,4,26,39,48,25,57,55,31,42,37,0,38,24,30,2,54,6,40,7,46,41,8,12,19,13,29,10,52,53,17,43,14,1,23,9],[27,28,23,22,48,8,21,5,24,35,56,7,59,45,2,41,13,53,49,26,44,9,54,36,30,19,42,43,52,0,25,14,50,29,17,31,11,40,20,34,38,10,1,57,6,55,15,58,4],[39,52,47,49,14,15,37,54,21,38,51,53,12,40,41,22,8,43,55,16,29,58,59,18,31,0,35,6,27,9,44,28,34,17,19,50,32,57,11,5,23,30,1,48],[19,34,38,17,13,44,55,20,24,15,39,47,5,43,48,40,51,25,0,4,33,54,30,58,59,41,21,53,12,36,28,46,18,16,7,26,10,23,35,1,56,52,22,11,8,32],[8,1,18,3,43,59,4,44,13,30,14,2,46,23,38,24,40,55,57,27,33,48,0,22,53,47,17,9,26,36,34,29,42,49,41,10,20,21,56,51,12,16,58,28,52],[54,58,50,35,9,2,37,8,10,31,7,21,47,13,49,0,22,3,46,1,20,30,36,24,5,41,38,18,42,56,34,14,26,29,59,52,17,57,53,15,33,23,51,55],[28,14,52,41,59,3,0,10,44,56,36,45,5,18,48,29,8,15,40,22,55,25,58,47,50,37,4,54,38,6,51,26,23,31,1,13,12,30,39,9,49,7,16,11,53,35,43,2,27,34,57,33],[28,58,36,15,19,54,41,29,2,22,45,17,48,53,50,25,9,52,23,31,13,35,20,4,3,7,10,37,33,56,16,6,14,34,39,8,57,43,24,51,5,27,30,47],[29,14,6,47,33,1,58,4,18,45,44,49,24,30,43,27,48,56,12,25,5,54,26,7,35,13,59,31,32,40,11,23,55,22,34,9,37,42,0,46,52],[26,0,23,44,34,30,28,48,27,14,47,46,59,6,52,9,2,35,37,54,25,4,18,41,42,24,16,10,45,5,31,43,8,12,53,38,36,56,58,51,15,33,32,39,29,40],[37,5,24,54,10,59,26,12,2,39,3,41,9,32,13,52,6,22,50,16,46,4,38,42,23,35,8,51,56,31,55,1,44,14,0,28,34,53,29,48,47,58,15,40,30,43],[55,12,44,39,52,54,18,2,59,4,35,37,51,21,13,27,15,38,57,40,45,17,6,16,33,36,41,43,30,7,50,29,10,58,0,47,32,19,31,56,24,14,53,1,9],[49,25,12,26,59,8,20,54,30,29,56,15,1,48,7,57,39,42,40,37,21,10,18,38,24,33,3,17,4,58,0,46,47,6,44,19,31,13,14,5,32,28,45,11,16,35],[51,21,43,39,6,5,14,3,12,56,15,19,45,25,27,34,0,59,53,55,4,57,29,23,38,40,30,20,1,37,11,16,54,42,8,52,47,26,44,41,9,33,10,7,18,32,22,49],[45,23,33,47,40,38,43,1,37,51,2,24,49,35,11,7,18,39,17,20,14,59,19,57,26,9,48,5,12,4,10,36,53,41,0,52,29,30,50,44,27,31,55,42,28,8,34],[1,54,20,23,53,21,34,58,45,33,9,51,49,11,37,36,12,41,44,6,52,15,4,3,25,17,57,19,43,38,30,5,24,7,42,14,28,56,16,59,39,46,31,50,48,47,35,2,27],[12,1,42,8,48,20,40,3,35,28,59,7,34,41,15,24,45,6,4,22,19,54,36,31,32,37,55,47,33,49,29,57,38,56,13,52,30,51,53,0,25,9,44,2,18,39,17,26],[17,18,12,37,11,6,51,4,20,42,27,39,38,36,9,43,29,30,53,41,47,32,50,8,57,5,35,13,46,58,21,14,45,52,26,2,59,3,23,25,48,7,15,54,40,0],[19,54,55,53,38,52,18,46,23,50,10,48,32,39,44,56,57,2,28,17,31,42,5,13,24,6,49,3,27,7,22,4,15,30,12,9,8,25,21,11,35,34,16,20,1,51,58,33,45],[45,54,34,6,20,56,55,43,15,23,52,1,47,58,19,7,28,53,0,12,14,41,24,2,16,22,9,46,36,8,11,50,26,29,10,27,32,51,3,17,25,31,38,13,48,57,49,18,21,44,39],[36,53,5,41,57,35,37,33,54,6,2,16,1,38,34,39,47,44,45,40,29,27,43,50,18,11,13,48,21,7,55,17,32,19,20,3,52,12,59,23,30,25,26,22,8,0,10,49,46,58],[2,7,53,6,42,5,1,45,54,47,29,36,48,21,46,44,57,10,27,52,28,9,0,43,38,34,56,31,19,30,37,13,40,4,20,24,22,8,39,23,49,55,35,14],[55,25,19,50,57,26,31,43,10,56,34,15,8,59,9,39,1,22,23,14,35,27,51,54,52,37,18,41,47,45,5,2,0,58,38,24,42,4,20,53,6,36,29,16,40,17],[30,14,52,35,47,26,20,49,1,44,37,27,40,33,24,55,31,42,39,7,0,45,4,10,2,57,54,6,50,53,15,56,43,38,32,13,58,3,36,16,21,18,9,59,12,29,19,5,8,25,17],[46,36,5,51,54,34,7,16,31,57,27,53,12,41,22,25,20,40,18,21,33,47,43,3,38,59,0,13,28,19,2,1,8,9,56,37,49,29,14,44,58,48,10,17,50,26,23,32],[18,35,31,56,52,51,48,49,32,38,11,17,28,26,41,10,27,46,50,15,12,2,59,22,3,54,16,43,30,9,14,7,6,25,34,20,53,37,39,58,1,42,4,55,40,33,0,44,5],[21,42,28,0,50,10,40,55,16,25,31,13,6,7,34,45,22,53,26,49,23,20,59,3,48,27,17,11,44,51,1,2,24,52,58,18,33,32,41,57,4,35,36,54,47,38,19,5],[44,14,6,25,29,7,41,58,15,36,31,13,28,9,22,21,47,3,23,46,0,24,52,17,45,35,27,48,11,34,16,32,4,55,49,26,1,54,39,40,33,20,50,10,59,57,12,30,42,5,56,37,2,51],[13,22,24,40,21,43,14,57,29,8,1,28,31,49,34,44,48,11,23,59,33,50,2,6,25,58,47,0,52,51,38,18,17,36,26,20,32,53,5,27,54,45,10,55,56,30],[52,4,25,42,46,37,27,39,0,34,15,44,13,31,41,14,35,23,22,17,59,2,55,5,24,3,47,57,54,43,56,11,12,19,38,50,32,7,45,48,8,9,49,21,36,6,20,33,28],[3,42,56,59,47,0,31,17,1,18,38,21,7,35,51,6,27,12,54,2,50,26,13,36,40,4,55,57,28,20,22,30,44,48,16,53,49,14,33,58,25,10,11,43,37,15,24,9,52,45,46],[45,41,32,27,37,47,40,5,10,46,28,51,53,34,1,56,58,7,49,23,29,57,21,43,3,11,12,20,9,24,15,54,16,26,59,33,8,38,48,36,25,19,52],[15,24,54,25,39,8,30,52,7,33,5,0,48,19,49,3,28,14,13,31,42,4,12,9,1,35,22,53,36,32,55,34,26,40,20,47,41,10,18,50,45,11,57,17,21],[9,22,51,38,20,11,14,15,10,34,8,47,4,19,17,6,29,32,31,39,40,12,26,46,50,55,37,3,52,41,57,48,21,13,7,24,23,49,25,0,35,45,1,2,27,54,5,30,36],[30,42,5,25,32,19,8,26,18,37,58,2,4,12,24,55,17,31,27,59,34,22,50,0,38,48,1,47,51,10,20,7,33,28,44,40,9,54,43,39,41,23,53,29],[7,35,55,47,40,42,29,20,50,15,54,32,56,21,57,36,44,10,38,16,49,3,8,30,28,23,14,11,6,59,2,58,26,0,48,41,19,31],[13,19,46,41,25,34,59,42,11,50,10,20,44,2,32,0,30,53,31,6,14,15,4,38,16,28,17,39,27,58,35,40,45,55,33,24,23,43,52,3,51,49,21,37,22,7,5,56,8,26,18],[12,5,27,20,36,9,50,51,29,7,1,32,43,23,15,39,58,17,11,55,18,54,53,56,14,0,19,37,31,45,38,41,44,25,52,10,6,21,57,4,42,35,30,40,49,26,46,28,3,8,13],[23,11,13,9,34,36,19,25,26,39,43,59,12,42,37,16,29,51,8,46,27,2,50,5,3,10,41,1,38,7,15,4,58,47,44,35,53,6,17,30,48,40,24,52,32,31],[33,2,37,1,16,47,46,29,48,57,0,41,21,39,18,45,36,44,3,31,53,58,10,17,28,34,49,22,6,30,51,12,13,54,38,40,25,9,26,43,5,35],[24,44,58,11,35,28,9,36,25,54,48,3,42,41,26,52,13,22,6,55,14,2,7,21,49,37,17,39,33,8,45,4,50,30,27,5,1,47,53,59,20,56,18,15,29,38,16],[40,13,34,17,8,7,36,29,22,43,30,20,51,21,26,6,58,18,0,32,54,2,38,39,44,59,12,37,48,27,1,24,33,28,31,25,47,56,11,16,41,57,49,14,42,19,15],[2,59,6,32,26,29,31,55,35,9,42,54,10,57,13,37,12,47,18,15,48,24,58,28,30,50,56,4,34,43,0,41,14,25,21,27,20,36,49,51,11,33,39,17,16,22,45],[29,9,26,30,21,35,16,32,18,43,23,22,51,13,31,53,46,41,56,48,27,20,12,0,6,34,52,17,59,14,19,36,10,24,33,4,40,11,42,58,38,7,50,57,37,45,44,39,28,8,55],[33,22,29,46,14,37,30,53,9,6,15,2,34,45,8,48,5,41,51,24,13,17,0,11,40,44,7,27,58,31,21,43,38,47,1,56,57,19,4,25,12,36,39,32,54,16],[41,57,8,36,30,24,7,23,12,33,17,29,42,46,54,48,53,19,58,0,21,1,27,34,5,32,59,18,16,4,40,55,35,20,26,52,51,9,47,15,38,14,22,39,10],[56,31,0,35,4,7,33,39,50,6,15,53,23,29,32,46,22,59,42,41,24,11,34,3,25,28,27,44,26,40,55,13,54,37,48,18,38,9,12,52,30,16,43,2,58,17],[18,51,5,19,3,26,16,38,45,0,30,42,4,48,53,52,13,39,17,50,1,59,56,47,55,14,28,37,7,8,34,23,41,54,22,33,49,20,2,21,46,36,35,9,6,29,15,12,10,57,31],[53,0,41,23,21,11,47,15,7,17,27,1,22,20,12,3,49,33,45,24,39,57,40,37,13,25,36,8,54,58,52,14,35,2,56,19,42,31,38,34,51,46,16,28,26,5,4]]\\n20\\n2",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> ff; \\n    \\n    void dfs(vector<int> adj[],int node,int parent,int level){\\n            if(level == 0){\\n                    ff.insert(node);\\n                    return;\\n            }\\n            for(int child : adj[node]){\\n                    if(child != parent){\\n                            dfs(adj,child,node,level-1);\\n                    }\\n            }\\n            \\n    }    \\n        \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) {\\n            \\n            \\n            vector<int> adj[100];\\n            for(int i = 0;i<friends.size();i++){\\n                    \\n                    for(auto a : friends[i]){\\n                            adj[i].push_back(a);\\n                    }\\n            }\\n            \\n            \\n            dfs(adj,id,id,level);\\n            map<string,int> mp;\\n            \\n            for(auto a : ff){\\n                    for(string s : watched[a])\\n                            mp[s]++;\\n            }\\n            \\n            vector<pair<int,string>> v;\\n            for(auto [a,b] : mp){\\n                    v.push_back({b,a});\\n            }\\n            sort(v.begin(),v.end());\\n            vector<string> ans;\\n            for(auto a : v)\\n                    ans.push_back(a.second);\\n            return ans;\\n            \\n            \\n            \\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301489,
                "title": "easy-c-soltuion-bfs-fast-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& nums, vector<vector<int>>& f, int id, int level) {\\n        vector<int> ans;\\n        vector<pair<int ,string>> res;\\n        vector<string> ans1;\\n        map<string,int> m;\\n        queue<pair<int,int>> q;\\n        q.push({id,level});\\n        vector<int> vis(f.size()+1,0);\\n        vis[id]=1;\\n        while(!q.empty())\\n        {\\n                int node = q.front().first;\\n                int x = q.front().second;\\n                q.pop();\\n                if(x==0)\\n                {\\n                   ans.push_back(node); \\n                }\\n                for(int j=0;j<f[node].size();j++)     \\n                { \\n                    if(vis[f[node][j]]==0)\\n                    {\\n                        q.push({f[node][j],x-1});\\n                        vis[f[node][j]]=1;\\n                    }                        \\n                }\\n            \\n        }\\n      for(auto it: ans)\\n      {\\n         for(int i=0;i<nums[it].size();i++)\\n         {\\n             m[nums[it][i]]++;\\n         }\\n      }\\n        for(auto it: m)\\n        {\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            res.push_back({it.second,it.first});\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            ans1.push_back(res[i].second);\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& nums, vector<vector<int>>& f, int id, int level) {\\n        vector<int> ans;\\n        vector<pair<int ,string>> res;\\n        vector<string> ans1;\\n        map<string,int> m;\\n        queue<pair<int,int>> q;\\n        q.push({id,level});\\n        vector<int> vis(f.size()+1,0);\\n        vis[id]=1;\\n        while(!q.empty())\\n        {\\n                int node = q.front().first;\\n                int x = q.front().second;\\n                q.pop();\\n                if(x==0)\\n                {\\n                   ans.push_back(node); \\n                }\\n                for(int j=0;j<f[node].size();j++)     \\n                { \\n                    if(vis[f[node][j]]==0)\\n                    {\\n                        q.push({f[node][j],x-1});\\n                        vis[f[node][j]]=1;\\n                    }                        \\n                }\\n            \\n        }\\n      for(auto it: ans)\\n      {\\n         for(int i=0;i<nums[it].size();i++)\\n         {\\n             m[nums[it][i]]++;\\n         }\\n      }\\n        for(auto it: m)\\n        {\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            res.push_back({it.second,it.first});\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i=0;i<res.size();i++)\\n        {\\n            ans1.push_back(res[i].second);\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3083063,
                "title": "fast-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find all the videos that are watched by the friends of a given person (id) within a certain level of friendship. To solve this problem, we can use a breadth-first search algorithm to find all the friends within the specified level and then keep track of the videos that are watched by these friends using a frequency map.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a frequency map to keep track of the number of times each video is watched by the friends.\\n- Use a breadth-first search algorithm to find all the friends within the specified level.\\n- For each friend found in step 2, add their watched videos to the frequency map.\\n- Sort the frequency map by the number of times each video is watched.\\n- Return the videos in the frequency map in sorted order.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        unordered_map<string, int> freq;\\n        vector<bool> visited(friends.size(), false);\\n        queue<int> q;\\n        q.push(id);\\n        visited[id] = true;\\n        while (!q.empty() && level-- > 0) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int f = q.front(); q.pop();\\n                for (int j : friends[f]) {\\n                    if (!visited[j]) {\\n                        q.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n            }\\n        }\\n        while (!q.empty()) {\\n            for (string& video : watchedVideos[q.front()]) freq[video]++;\\n            q.pop();\\n        }\\n        vector<pair<int, string>> pairs;\\n        for (auto& p : freq) pairs.push_back({p.second, p.first});\\n        sort(pairs.begin(), pairs.end());\\n        vector<string> res;\\n        for (auto& p : pairs) res.push_back(p.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        unordered_map<string, int> freq;\\n        vector<bool> visited(friends.size(), false);\\n        queue<int> q;\\n        q.push(id);\\n        visited[id] = true;\\n        while (!q.empty() && level-- > 0) {\\n            for (int i = q.size(); i > 0; i--) {\\n                int f = q.front(); q.pop();\\n                for (int j : friends[f]) {\\n                    if (!visited[j]) {\\n                        q.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n            }\\n        }\\n        while (!q.empty()) {\\n            for (string& video : watchedVideos[q.front()]) freq[video]++;\\n            q.pop();\\n        }\\n        vector<pair<int, string>> pairs;\\n        for (auto& p : freq) pairs.push_back({p.second, p.first});\\n        sort(pairs.begin(), pairs.end());\\n        vector<string> res;\\n        for (auto& p : pairs) res.push_back(p.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028949,
                "title": "simple-python-solution-using-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        dct=defaultdict(lambda :0)\\n        n=len(friends)\\n        st=[(id,0)]\\n        visited=[0]*n\\n        visited[id]=1\\n        while st:\\n            x,d=st.pop(0)\\n            for i in friends[x]:\\n                if visited[i]==0 and d+1<=level:\\n                    if d+1==level:\\n                        for j in watchedVideos[i]:\\n                            dct[j]+=1\\n                    st.append((i,d+1))\\n                    visited[i]=1\\n        lst=sorted(dct,key=lambda x: (dct[x],x))\\n        return lst\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        dct=defaultdict(lambda :0)\\n        n=len(friends)\\n        st=[(id,0)]\\n        visited=[0]*n\\n        visited[id]=1\\n        while st:\\n            x,d=st.pop(0)\\n            for i in friends[x]:\\n                if visited[i]==0 and d+1<=level:\\n                    if d+1==level:\\n                        for j in watchedVideos[i]:\\n                            dct[j]+=1\\n                    st.append((i,d+1))\\n                    visited[i]=1\\n        lst=sorted(dct,key=lambda x: (dct[x],x))\\n        return lst\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883809,
                "title": "python-easy-logic-bfs-using-deque-set-defaultdict-codeplug",
                "content": "**Upvote if it helped :)**\\n\\n# Intuition\\nWe need to visit the nearest neighbours when we talk about level, this suggests that we should be using BFS with queue.\\n\\n# Approach\\nWe reduce the level as we iterate and when the level is 1, we count all the videos watched by friends at that level using a defaultdict.\\n\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        videos = defaultdict(int)\\n        q = deque([id])\\n        visited = set([id])\\n\\n        while level > 0:\\n            for _ in range(len(q)):\\n                person = q.popleft()\\n\\n                for friend in friends[person]:\\n                    if friend not in visited:\\n                        visited.add(friend)\\n                        q.append(friend)\\n\\n                        if level == 1:\\n                            for vid in watchedVideos[friend]:\\n                                videos[vid] += 1\\n            \\n            level -= 1\\n\\n        return sorted(list(videos.keys()), key = lambda k: (videos[k], k))\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        videos = defaultdict(int)\\n        q = deque([id])\\n        visited = set([id])\\n\\n        while level > 0:\\n            for _ in range(len(q)):\\n                person = q.popleft()\\n\\n                for friend in friends[person]:\\n                    if friend not in visited:\\n                        visited.add(friend)\\n                        q.append(friend)\\n\\n                        if level == 1:\\n                            for vid in watchedVideos[friend]:\\n                                videos[vid] += 1\\n            \\n            level -= 1\\n\\n        return sorted(list(videos.keys()), key = lambda k: (videos[k], k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801951,
                "title": "short-c-solution-based-on-bfs-with-explanation",
                "content": "The solution is absed on BFS. \\nWe traverse the given graph `friends` and when we reach the given level `level` we stopped (// 1). As we stopped our queue will contain the list of friends (BFS property) on a given level, so we then building a freq table using the `watchedVideos` (// 2). At the last stage we sorting the elements using temp vector and return the answer (// 3).\\n```\\nvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n\\tqueue<int> q;\\n\\tunordered_set<int> visited;\\n\\tint l = 0;\\n\\tq.push(id);\\n\\tvisited.insert(id);\\n\\twhile (!q.empty()) { // 1\\n\\t\\tif (l++ == level) break;\\n\\t\\tfor (int i = q.size(); i > 0; i--) {\\n\\t\\t\\tauto node = q.front(); q.pop();\\n\\t\\t\\tfor (auto next : friends[node]) {\\n\\t\\t\\t\\tif (visited.count(next)) continue;\\n\\t\\t\\t\\tq.push(next);\\n\\t\\t\\t\\tvisited.insert(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tunordered_map<string, int> freq; // 2\\n\\twhile (!q.empty()) {\\n\\t\\tauto n = q.front(); q.pop();\\n\\t\\tfor (auto& v : watchedVideos[n]) freq[v]++;\\n\\t}\\n\\tvector<pair<int, string>> temp; // 3\\n\\tfor (auto& [str, fr] : freq) temp.push_back({fr, str});\\n\\tsort(temp.begin(), temp.end());\\n\\tvector<string> res;\\n\\tfor (auto& [_, str] : temp) res.push_back(str);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n\\tqueue<int> q;\\n\\tunordered_set<int> visited;\\n\\tint l = 0;\\n\\tq.push(id);\\n\\tvisited.insert(id);\\n\\twhile (!q.empty()) { // 1\\n\\t\\tif (l++ == level) break;\\n\\t\\tfor (int i = q.size(); i > 0; i--) {\\n\\t\\t\\tauto node = q.front(); q.pop();\\n\\t\\t\\tfor (auto next : friends[node]) {\\n\\t\\t\\t\\tif (visited.count(next)) continue;\\n\\t\\t\\t\\tq.push(next);\\n\\t\\t\\t\\tvisited.insert(next);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tunordered_map<string, int> freq; // 2\\n\\twhile (!q.empty()) {\\n\\t\\tauto n = q.front(); q.pop();\\n\\t\\tfor (auto& v : watchedVideos[n]) freq[v]++;\\n\\t}\\n\\tvector<pair<int, string>> temp; // 3\\n\\tfor (auto& [str, fr] : freq) temp.push_back({fr, str});\\n\\tsort(temp.begin(), temp.end());\\n\\tvector<string> res;\\n\\tfor (auto& [_, str] : temp) res.push_back(str);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431209,
                "title": "find-friends-of-friends-84-speed",
                "content": "Runtime: 276 ms, faster than 84.09% of Python3 online submissions for Get Watched Videos by Your Friends.\\nMemory Usage: 16.2 MB, less than 20.45% of Python3 online submissions for Get Watched Videos by Your Friends.\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        friends = [set(lst) for lst in friends]\\n        row = friends[id]\\n        previous_friends = {id}\\n        for _ in range(1, level):\\n            previous_friends.update(row)\\n            new_row = set()\\n            for friend in row:\\n                new_row.update(friends[friend])\\n            row = new_row - previous_friends\\n        videos = defaultdict(int)\\n        for friend in row:\\n            for video in watchedVideos[friend]:\\n                videos[video] += 1\\n        return [v for _, v in sorted((freq, v) for v, freq in videos.items())]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        friends = [set(lst) for lst in friends]\\n        row = friends[id]\\n        previous_friends = {id}\\n        for _ in range(1, level):\\n            previous_friends.update(row)\\n            new_row = set()\\n            for friend in row:\\n                new_row.update(friends[friend])\\n            row = new_row - previous_friends\\n        videos = defaultdict(int)\\n        for friend in row:\\n            for video in watchedVideos[friend]:\\n                videos[video] += 1\\n        return [v for _, v in sorted((freq, v) for v, freq in videos.items())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231752,
                "title": "f-r-i-e-n-d-s",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) \\n    {\\n        int n=watched.size();\\n        vector<int>kth;\\n        int l=0;\\n        queue<int>q;\\n        vector<bool>vis(n);\\n        vis[id]=true;\\n        q.push(id);\\n        while(!q.empty() && l<=level)\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front();q.pop();\\n                if(l==level)\\n                    kth.push_back(i);\\n                for(auto f:friends[i])\\n                {\\n                    if(!vis[f])\\n                    {\\n                        q.push(f);\\n                        vis[f]=true;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        \\n        unordered_map<string,int>count;\\n        for(auto i:kth)\\n        {\\n            for(auto v:watched[i])\\n                count[v]++;\\n        }\\n        vector<pair<int,string>>temp;\\n        for(auto p:count)\\n        {\\n            temp.push_back({p.second,p.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<string>res;\\n        for(auto p:temp)\\n            res.push_back(p.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) \\n    {\\n        int n=watched.size();\\n        vector<int>kth;\\n        int l=0;\\n        queue<int>q;\\n        vector<bool>vis(n);\\n        vis[id]=true;\\n        q.push(id);\\n        while(!q.empty() && l<=level)\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front();q.pop();\\n                if(l==level)\\n                    kth.push_back(i);\\n                for(auto f:friends[i])\\n                {\\n                    if(!vis[f])\\n                    {\\n                        q.push(f);\\n                        vis[f]=true;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        \\n        unordered_map<string,int>count;\\n        for(auto i:kth)\\n        {\\n            for(auto v:watched[i])\\n                count[v]++;\\n        }\\n        vector<pair<int,string>>temp;\\n        for(auto p:count)\\n        {\\n            temp.push_back({p.second,p.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        vector<string>res;\\n        for(auto p:temp)\\n            res.push_back(p.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151313,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<Integer> que=new LinkedList<Integer>();\\n        que.add(id);\\n        boolean[] visited=new boolean[friends.length];\\n        visited[id]=true;\\n        while(level>0){\\n            int size=que.size();\\n            while(size>0){\\n                for(int f:friends[que.poll()]){\\n                    if(!visited[f]){\\n                        visited[f]=true;\\n                        que.add(f);\\n                    }\\n                }\\n                size--;\\n            }\\n            level--;\\n}\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        while(que.size()>0){\\n            for(String s:watchedVideos.get(que.poll())){\\n            hm.put(s,hm.getOrDefault(s,0)+1);\\n            }\\n        }\\n                \\n        List<String> ans=new ArrayList<>(hm.keySet());\\n     ans.sort((a,b)->{\\n            int x=hm.get(a);\\n            int y=hm.get(b);\\n            if(x==y)\\n               return a.compareTo(b);\\n            else\\n            return x-y;});\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<Integer> que=new LinkedList<Integer>();\\n        que.add(id);\\n        boolean[] visited=new boolean[friends.length];\\n        visited[id]=true;\\n        while(level>0){\\n            int size=que.size();\\n            while(size>0){\\n                for(int f:friends[que.poll()]){\\n                    if(!visited[f]){\\n                        visited[f]=true;\\n                        que.add(f);\\n                    }\\n                }\\n                size--;\\n            }\\n            level--;\\n}\\n        HashMap<String,Integer> hm=new HashMap<>();\\n        while(que.size()>0){\\n            for(String s:watchedVideos.get(que.poll())){\\n            hm.put(s,hm.getOrDefault(s,0)+1);\\n            }\\n        }\\n                \\n        List<String> ans=new ArrayList<>(hm.keySet());\\n     ans.sort((a,b)->{\\n            int x=hm.get(a);\\n            int y=hm.get(b);\\n            if(x==y)\\n               return a.compareTo(b);\\n            else\\n            return x-y;});\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079501,
                "title": "java-solution-with-bfs-and-treemap",
                "content": "```\\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n\\n    Queue<Integer> persons = new LinkedList<>();\\n    int currLevel = 0;\\n    Set<Integer> visited = new HashSet<>();\\n    Map<String, Integer> movieFrequency = new HashMap<>();\\n    List<String> result = new ArrayList<>();\\n    persons.offer(id);\\n    visited.add(id);\\n    while (!persons.isEmpty() && currLevel <= level) {\\n\\n      int size = persons.size();\\n      for (int j = 0 ;j < size; j++) {\\n        int curr = persons.poll();\\n        \\n        if (currLevel == level && watchedVideos.get(curr) != null) {\\n          for (String movie : watchedVideos.get(curr)) {\\n            movieFrequency.put(movie, movieFrequency.getOrDefault(movie, 0) + 1);\\n          }\\n        }\\n        for (int i = 0; i < friends[curr].length; i++) {\\n          int index = friends[curr][i];\\n          if (!visited.contains(index)) {\\n              visited.add(index);\\n            persons.offer(index);\\n          }\\n        }\\n\\n      }\\n      currLevel++;\\n    }\\n    Map<Integer, List<String>> sortedFrequencyMovieMap = new TreeMap<>();\\n\\n    for (String movie: movieFrequency.keySet()) {\\n      sortedFrequencyMovieMap.putIfAbsent(movieFrequency.get(movie), new ArrayList<>());\\n      sortedFrequencyMovieMap.get(movieFrequency.get(movie)).add(movie);\\n    }\\n    for (int key:sortedFrequencyMovieMap.keySet()) {\\n      List<String> temp = sortedFrequencyMovieMap.get(key);\\n      Collections.sort(temp);\\n\\n      result.addAll(temp);\\n    }\\n    return result;\\n  }\\n  ```\\n",
                "solutionTags": [],
                "code": "```\\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n\\n    Queue<Integer> persons = new LinkedList<>();\\n    int currLevel = 0;\\n    Set<Integer> visited = new HashSet<>();\\n    Map<String, Integer> movieFrequency = new HashMap<>();\\n    List<String> result = new ArrayList<>();\\n    persons.offer(id);\\n    visited.add(id);\\n    while (!persons.isEmpty() && currLevel <= level) {\\n\\n      int size = persons.size();\\n      for (int j = 0 ;j < size; j++) {\\n        int curr = persons.poll();\\n        \\n        if (currLevel == level && watchedVideos.get(curr) != null) {\\n          for (String movie : watchedVideos.get(curr)) {\\n            movieFrequency.put(movie, movieFrequency.getOrDefault(movie, 0) + 1);\\n          }\\n        }\\n        for (int i = 0; i < friends[curr].length; i++) {\\n          int index = friends[curr][i];\\n          if (!visited.contains(index)) {\\n              visited.add(index);\\n            persons.offer(index);\\n          }\\n        }\\n\\n      }\\n      currLevel++;\\n    }\\n    Map<Integer, List<String>> sortedFrequencyMovieMap = new TreeMap<>();\\n\\n    for (String movie: movieFrequency.keySet()) {\\n      sortedFrequencyMovieMap.putIfAbsent(movieFrequency.get(movie), new ArrayList<>());\\n      sortedFrequencyMovieMap.get(movieFrequency.get(movie)).add(movie);\\n    }\\n    for (int key:sortedFrequencyMovieMap.keySet()) {\\n      List<String> temp = sortedFrequencyMovieMap.get(key);\\n      Collections.sort(temp);\\n\\n      result.addAll(temp);\\n    }\\n    return result;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1013668,
                "title": "python-bfs-w-comment",
                "content": "The problem description might be hard to read or to understand, but when we see \"shortest\", we might know BFS is the right way to go,\\nthen the solution would be straightforward\\n```py\\n\\'\\'\\'\\nw: shortest path --> BFS\\nh: 1) start from the given id\\n   2) traverse level by level  \\n      1) put the friend connected to current node to the queue\\n      2) if we are at the correct level, we count the frequency \\n            of video for all the friends at this level\\n\\'\\'\\'\\nimport  collections\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        # 1. construct the graph from the list\\n\\t\\t# and define all the variable needed\\n\\t\\t# you might need to be very familiary of how to\\n\\t\\t# constrcut a graph from the relation- list\\n        graph = collections.defaultdict(list)\\n        for idx, f in  enumerate(friends):\\n            graph[idx] += f\\n        freq = collections.defaultdict(int)\\n        seen = set([id])\\n        dq = collections.deque([id])\\n        lv = 0\\n        \\n        while dq and lv < level:\\n            curSize = len(dq)\\n            lv += 1\\n            # traverse level by level\\n            for _ in range(curSize):\\n                node = dq.popleft()\\n                for nei in graph[node]:\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        dq.append(nei)\\n                        if lv == level: # we are at the desired level\\n                            for video in watchedVideos[nei]:\\n                                freq[video] += 1\\n  \\n        freq = {k: v for k, v in sorted(freq.items(), key=lambda item: (item[1],item[0]))}\\n        return freq.keys()\\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: shortest path --> BFS\\nh: 1) start from the given id\\n   2) traverse level by level  \\n      1) put the friend connected to current node to the queue\\n      2) if we are at the correct level, we count the frequency \\n            of video for all the friends at this level\\n\\'\\'\\'\\nimport  collections\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        # 1. construct the graph from the list\\n\\t\\t# and define all the variable needed\\n\\t\\t# you might need to be very familiary of how to\\n\\t\\t# constrcut a graph from the relation- list\\n        graph = collections.defaultdict(list)\\n        for idx, f in  enumerate(friends):\\n            graph[idx] += f\\n        freq = collections.defaultdict(int)\\n        seen = set([id])\\n        dq = collections.deque([id])\\n        lv = 0\\n        \\n        while dq and lv < level:\\n            curSize = len(dq)\\n            lv += 1\\n            # traverse level by level\\n            for _ in range(curSize):\\n                node = dq.popleft()\\n                for nei in graph[node]:\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        dq.append(nei)\\n                        if lv == level: # we are at the desired level\\n                            for video in watchedVideos[nei]:\\n                                freq[video] += 1\\n  \\n        freq = {k: v for k, v in sorted(freq.items(), key=lambda item: (item[1],item[0]))}\\n        return freq.keys()\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 999830,
                "title": "java-with-some-comments-hashmap-bfs-custom-sort",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        // BFS\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        q.offer(id);\\n        seen.add(id);\\n        // we only loop \"level\" times to get friends who is on \"level\".\\n        for(int i = 0; i < level; i++) {\\n            int size = q.size();\\n            for(int j = 0; j < size; j++) {\\n                int curr = q.poll();\\n                // put all \"curr\\'s\" friends in the queue\\n                for(int friend: friends[curr]) {\\n                    // if already see it before, we skip it.\\n                    if(seen.contains(friend)) {\\n                        continue;\\n                    }\\n                    q.offer(friend);\\n                    seen.add(friend);\\n                }\\n            }\\n        }\\n        \\n        // (Movie Name, freq)\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int ID: q) {\\n            for(String movie: watchedVideos.get(ID)) {\\n                map.put(movie, map.getOrDefault(movie, 1) + 1);\\n            }\\n        }\\n        \\n        // take the \"map entry\" as type\\n        List<Map.Entry<String,Integer>> ls = new ArrayList<>(map.entrySet());\\n        Collections.sort(ls, new Comp());\\n        \\n        List<String> result = new ArrayList<>();\\n        for(Map.Entry<String,Integer> entry: ls) {\\n            result.add(entry.getKey());\\n        }\\n        return result;\\n        \\n    }\\n    \\n    public class Comp implements Comparator<Map.Entry<String,Integer> > {\\n        public int compare(Map.Entry<String,Integer> a, Map.Entry<String,Integer> b) {\\n            // if the frequency is same, we sort it by \"Key\" in increasing order\\n            if(a.getValue() == b.getValue()) {\\n                return a.getKey().compareTo(b.getKey());\\n            }\\n            return a.getValue() - b.getValue();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        // BFS\\n        Queue<Integer> q = new LinkedList<>();\\n        Set<Integer> seen = new HashSet<>();\\n        q.offer(id);\\n        seen.add(id);\\n        // we only loop \"level\" times to get friends who is on \"level\".\\n        for(int i = 0; i < level; i++) {\\n            int size = q.size();\\n            for(int j = 0; j < size; j++) {\\n                int curr = q.poll();\\n                // put all \"curr\\'s\" friends in the queue\\n                for(int friend: friends[curr]) {\\n                    // if already see it before, we skip it.\\n                    if(seen.contains(friend)) {\\n                        continue;\\n                    }\\n                    q.offer(friend);\\n                    seen.add(friend);\\n                }\\n            }\\n        }\\n        \\n        // (Movie Name, freq)\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int ID: q) {\\n            for(String movie: watchedVideos.get(ID)) {\\n                map.put(movie, map.getOrDefault(movie, 1) + 1);\\n            }\\n        }\\n        \\n        // take the \"map entry\" as type\\n        List<Map.Entry<String,Integer>> ls = new ArrayList<>(map.entrySet());\\n        Collections.sort(ls, new Comp());\\n        \\n        List<String> result = new ArrayList<>();\\n        for(Map.Entry<String,Integer> entry: ls) {\\n            result.add(entry.getKey());\\n        }\\n        return result;\\n        \\n    }\\n    \\n    public class Comp implements Comparator<Map.Entry<String,Integer> > {\\n        public int compare(Map.Entry<String,Integer> a, Map.Entry<String,Integer> b) {\\n            // if the frequency is same, we sort it by \"Key\" in increasing order\\n            if(a.getValue() == b.getValue()) {\\n                return a.getKey().compareTo(b.getKey());\\n            }\\n            return a.getValue() - b.getValue();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917203,
                "title": "my-java-solution-using-bfs-sort",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(id);\\n        boolean [] visited = new boolean[n];\\n        visited[id] = true;\\n        // bfs\\n        while (level-- > 0) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                for (int friend: friends[queue.poll()]) {\\n                    if (!visited[friend]) {\\n                        visited[friend] = true;\\n                        queue.offer(friend);\\n                    }\\n                }\\n            }\\n        }\\n        // now get the frequenecy using hashmap\\n        Map<String, Integer> map = new HashMap<>();\\n        while (!queue.isEmpty()) {\\n            for (String s: watchedVideos.get(queue.poll()))\\n                map.put(s, map.getOrDefault(s, 0) + 1);\\n        }\\n        List<String> result = new ArrayList<>(map.keySet());\\n        // now we need to sort them using a compartor\\n        result.sort((a, b) -> {\\n            int first = map.get(a);\\n            int second = map.get(b);\\n            if (first != second)\\n                return first - second;\\n            else\\n                return a.compareTo(b);\\n        });\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(id);\\n        boolean [] visited = new boolean[n];\\n        visited[id] = true;\\n        // bfs\\n        while (level-- > 0) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                for (int friend: friends[queue.poll()]) {\\n                    if (!visited[friend]) {\\n                        visited[friend] = true;\\n                        queue.offer(friend);\\n                    }\\n                }\\n            }\\n        }\\n        // now get the frequenecy using hashmap\\n        Map<String, Integer> map = new HashMap<>();\\n        while (!queue.isEmpty()) {\\n            for (String s: watchedVideos.get(queue.poll()))\\n                map.put(s, map.getOrDefault(s, 0) + 1);\\n        }\\n        List<String> result = new ArrayList<>(map.keySet());\\n        // now we need to sort them using a compartor\\n        result.sort((a, b) -> {\\n            int first = map.get(a);\\n            int second = map.get(b);\\n            if (first != second)\\n                return first - second;\\n            else\\n                return a.compareTo(b);\\n        });\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876732,
                "title": "rust-translated-32ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn watched_videos_by_friends(\\n        watched_videos: Vec<Vec<String>>,\\n        friends: Vec<Vec<i32>>,\\n        id: i32,\\n        level: i32,\\n    ) -> Vec<String> {\\n        use std::collections::HashMap;\\n\\n        let n = friends.len();\\n        let mut visited = vec![false; n];\\n        visited[id as usize] = true;\\n        let mut q = Vec::<i32>::new();\\n        q.push(id);\\n\\n        for _ in 0..level {\\n            let mut q2 = Vec::<i32>::new();\\n            for v in q {\\n                for &w in &friends[v as usize] {\\n                    if !visited[w as usize] {\\n                        visited[w as usize] = true;\\n                        q2.push(w);\\n                    }\\n                }\\n            }\\n            q = q2;\\n        }\\n\\n        let mut freq = HashMap::<String, i32>::new();\\n        for person in q {\\n            for s in &watched_videos[person as usize] {\\n                *freq.entry(s.to_owned()).or_default() += 1;\\n            }\\n        }\\n\\n        let mut ans = Vec::<(i32, String)>::new();\\n        for (key, val) in freq {\\n            ans.push((val, key));\\n        }\\n        ans.sort();\\n        ans.iter().map(|x| x.1.to_owned()).collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_watched_videos_by_friends() {\\n        assert_eq!(\\n            Solution::watched_videos_by_friends(\\n                vec![\\n                    vec![\"A\".to_owned(), \"B\".to_owned()],\\n                    vec![\"C\".to_owned()],\\n                    vec![\"B\".to_owned(), \"C\".to_owned()],\\n                    vec![\"D\".to_owned()]\\n                ],\\n                vec![vec![1, 2], vec![0, 3], vec![0, 3], vec![1, 2]],\\n                0,\\n                1\\n            ),\\n            vec![\"B\".to_owned(), \"C\".to_owned()]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_watched_videos_by_friends_02() {\\n        assert_eq!(\\n            Solution::watched_videos_by_friends(\\n                vec![\\n                    vec![\"A\".to_owned(), \"B\".to_owned()],\\n                    vec![\"C\".to_owned()],\\n                    vec![\"B\".to_owned(), \"C\".to_owned()],\\n                    vec![\"D\".to_owned()]\\n                ],\\n                vec![vec![1, 2], vec![0, 3], vec![0, 3], vec![1, 2]],\\n                0,\\n                2\\n            ),\\n            vec![\"D\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn watched_videos_by_friends(\\n        watched_videos: Vec<Vec<String>>,\\n        friends: Vec<Vec<i32>>,\\n        id: i32,\\n        level: i32,\\n    ) -> Vec<String> {\\n        use std::collections::HashMap;\\n\\n        let n = friends.len();\\n        let mut visited = vec![false; n];\\n        visited[id as usize] = true;\\n        let mut q = Vec::<i32>::new();\\n        q.push(id);\\n\\n        for _ in 0..level {\\n            let mut q2 = Vec::<i32>::new();\\n            for v in q {\\n                for &w in &friends[v as usize] {\\n                    if !visited[w as usize] {\\n                        visited[w as usize] = true;\\n                        q2.push(w);\\n                    }\\n                }\\n            }\\n            q = q2;\\n        }\\n\\n        let mut freq = HashMap::<String, i32>::new();\\n        for person in q {\\n            for s in &watched_videos[person as usize] {\\n                *freq.entry(s.to_owned()).or_default() += 1;\\n            }\\n        }\\n\\n        let mut ans = Vec::<(i32, String)>::new();\\n        for (key, val) in freq {\\n            ans.push((val, key));\\n        }\\n        ans.sort();\\n        ans.iter().map(|x| x.1.to_owned()).collect()\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_watched_videos_by_friends() {\\n        assert_eq!(\\n            Solution::watched_videos_by_friends(\\n                vec![\\n                    vec![\"A\".to_owned(), \"B\".to_owned()],\\n                    vec![\"C\".to_owned()],\\n                    vec![\"B\".to_owned(), \"C\".to_owned()],\\n                    vec![\"D\".to_owned()]\\n                ],\\n                vec![vec![1, 2], vec![0, 3], vec![0, 3], vec![1, 2]],\\n                0,\\n                1\\n            ),\\n            vec![\"B\".to_owned(), \"C\".to_owned()]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_watched_videos_by_friends_02() {\\n        assert_eq!(\\n            Solution::watched_videos_by_friends(\\n                vec![\\n                    vec![\"A\".to_owned(), \"B\".to_owned()],\\n                    vec![\"C\".to_owned()],\\n                    vec![\"B\".to_owned(), \"C\".to_owned()],\\n                    vec![\"D\".to_owned()]\\n                ],\\n                vec![vec![1, 2], vec![0, 3], vec![0, 3], vec![1, 2]],\\n                0,\\n                2\\n            ),\\n            vec![\"D\".to_owned()]\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 740767,
                "title": "python-bfs-soln",
                "content": "```\\nclass Solution(object):\\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n        \"\"\"\\n        :type watchedVideos: List[List[str]]\\n        :type friends: List[List[int]]\\n        :type id: int\\n        :type level: int\\n        :rtype: List[str]\\n        \"\"\"\\n        n = len(friends)\\n\\n        queue = collections.deque()\\n        queue.append((id, 0))\\n        res = collections.defaultdict(int)\\n        seen = set()\\n        seen.add(id)\\n        \\n        while queue:\\n            # print queue\\n            node, lvl = queue.popleft()\\n            if lvl == level:\\n                for video in watchedVideos[node]:\\n                    res[video] += 1\\n                # print res\\n                # return\\n            for friend in friends[node]:\\n                if friend not in seen:\\n                    queue.append((friend, lvl + 1))\\n                    seen.add(friend)\\n        \\n        # print res\\n        return sorted(res, key = lambda x : (res[x], x))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n        \"\"\"\\n        :type watchedVideos: List[List[str]]\\n        :type friends: List[List[int]]\\n        :type id: int\\n        :type level: int\\n        :rtype: List[str]\\n        \"\"\"\\n        n = len(friends)\\n\\n        queue = collections.deque()\\n        queue.append((id, 0))\\n        res = collections.defaultdict(int)\\n        seen = set()\\n        seen.add(id)\\n        \\n        while queue:\\n            # print queue\\n            node, lvl = queue.popleft()\\n            if lvl == level:\\n                for video in watchedVideos[node]:\\n                    res[video] += 1\\n                # print res\\n                # return\\n            for friend in friends[node]:\\n                if friend not in seen:\\n                    queue.append((friend, lvl + 1))\\n                    seen.add(friend)\\n        \\n        # print res\\n        return sorted(res, key = lambda x : (res[x], x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668360,
                "title": "c-bfs-easy-to-understand-and-clean",
                "content": "```\\n#define pb push_back\\n#define fs first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    // custom cmp function for sort vector for given condition\\n\\t\\n    static bool cmp(pair<string, int> A, pair<string, int> B)\\n    {\\n        if(A.ss < B.ss)return true;\\n        else if(A.ss == B.ss)\\n            if(A.fs < B.fs)return true;\\n        return false;\\n    }\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& ws, vector<vector<int>>& fr, int id, int level) \\n    {    \\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n  \\n//here we are using map to store strings with frequency\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t// here goes our BFS until we get all the friends with requires level\\n\\t\\t\\n        int fg = 0;\\n        int lvl[101] = {0};\\n        bool vis[101] = {0};\\n        queue<int> q;\\n        q.push(id); vis[id]=1; lvl[id] = 0;\\n        \\n        while(q.size())\\n        {\\n            int p = q.front(); q.pop();\\n            for(const auto& elem : fr[p])\\n            {\\n                if(lvl[elem]>level){fg = 1; break;}\\n                if(!vis[elem])\\n                {\\n                    q.push(elem);\\n                    lvl[elem] = lvl[p]+1;\\n                    vis[elem] = 1;\\n                    \\n                    if(lvl[elem]==level)\\n                        for(auto& st: ws[elem])mp[st]++;\\n                }\\n            }\\n            if(fg)break;\\n        }\\n        \\n        vector<pair<string, int>> vp;\\n        vector<string> ans;\\n        \\n        for(auto it : mp)\\n        {cout<<it.fs<<\" \"<<it.ss<<\\'\\\\n\\';\\n            vp.pb({it.fs,it.ss});}\\n        \\n        sort(vp.begin(),vp.end(), cmp);\\n        \\n\\t\\t//after sorting we only neest vector of string to store and return\\n\\t\\t\\n        for(auto pr : vp)\\n            ans.pb(pr.fs);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n#define pb push_back\\n#define fs first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    // custom cmp function for sort vector for given condition\\n\\t\\n    static bool cmp(pair<string, int> A, pair<string, int> B)\\n    {\\n        if(A.ss < B.ss)return true;\\n        else if(A.ss == B.ss)\\n            if(A.fs < B.fs)return true;\\n        return false;\\n    }\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& ws, vector<vector<int>>& fr, int id, int level) \\n    {    \\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\\n  \\n//here we are using map to store strings with frequency\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t// here goes our BFS until we get all the friends with requires level\\n\\t\\t\\n        int fg = 0;\\n        int lvl[101] = {0};\\n        bool vis[101] = {0};\\n        queue<int> q;\\n        q.push(id); vis[id]=1; lvl[id] = 0;\\n        \\n        while(q.size())\\n        {\\n            int p = q.front(); q.pop();\\n            for(const auto& elem : fr[p])\\n            {\\n                if(lvl[elem]>level){fg = 1; break;}\\n                if(!vis[elem])\\n                {\\n                    q.push(elem);\\n                    lvl[elem] = lvl[p]+1;\\n                    vis[elem] = 1;\\n                    \\n                    if(lvl[elem]==level)\\n                        for(auto& st: ws[elem])mp[st]++;\\n                }\\n            }\\n            if(fg)break;\\n        }\\n        \\n        vector<pair<string, int>> vp;\\n        vector<string> ans;\\n        \\n        for(auto it : mp)\\n        {cout<<it.fs<<\" \"<<it.ss<<\\'\\\\n\\';\\n            vp.pb({it.fs,it.ss});}\\n        \\n        sort(vp.begin(),vp.end(), cmp);\\n        \\n\\t\\t//after sorting we only neest vector of string to store and return\\n\\t\\t\\n        for(auto pr : vp)\\n            ans.pb(pr.fs);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 634928,
                "title": "dfs-simple-step-by-step-commented-code-cpp-solution",
                "content": "Runtime: 240 ms, faster than 25.31% of C++ online submissions for Get Watched Videos by Your Friends.\\nMemory Usage: 57.1 MB, less than 100.00% of C++ online submissions for Get Watched Videos by Your Friends.\\n```\\n//keeping track of freq of movies \\nstruct MyPair{\\n    string movie;\\n    int freq;\\n};\\n//function for sorting\\nbool compare(MyPair const &m1, MyPair const &m2){\\n        if(m1.freq == m2.freq){\\n            return m1.movie < m2.movie;\\n        }\\n        return m1.freq < m2.freq; \\n} \\n  \\nclass Solution {\\n    void helper(vector<vector<int>> friends , int level , int id, vector<int>& reqdFriends, unordered_map<int,int>& u){\\n        int i;\\n        u[id]++;\\n        if(level == 1){\\n            for(i = 0; i < friends[id].size(); i++){\\n                if(u.find(friends[id][i]) == u.end()){\\n                    //wont add friends found on previous level\\n                    reqdFriends.push_back(friends[id][i]);\\n                }\\n                u[friends[id][i]] ++;\\n            }\\n            return;\\n        }\\n        for(i = 0; i < friends[id].size() ; i++){\\n            u[friends[id][i]]++;// if reqd level is 3 and 0 has friend 1 and 1 has friend 2 and 2 has friend 1 then we wont count 1 as its zeroes 1 level friend so keeping track of friends\\n        }\\n        for(i = 0; i < friends[id].size() ; i++){\\n            helper(friends, level - 1, friends[id][i], reqdFriends, u);\\n        }\\n    }\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        vector<int> reqdFriends;// friends whose interest is to be found\\n        vector<string> output;// my final output\\n        unordered_map<int,int> u;\\n        unordered_map<string,int> map;\\n        vector<MyPair> res;\\n        int i;\\n        helper(friends, level, id, reqdFriends, u);//to fill reqdFriends array\\n        for(i = 0; i < reqdFriends.size(); i++){\\n            if(reqdFriends[i] == id){\\n                continue;\\n            }\\n            for(int j = 0; j < watchedVideos[reqdFriends[i]].size(); j++){\\n                    map[watchedVideos[reqdFriends[i]][j]] ++;//keeping count of movies\\n            }\\n        }\\n        for(auto it : map){\\n            if(to_string(id) == it.first){\\n                continue;\\n            }\\n            MyPair m;\\n            m.movie = it.first;\\n            m.freq = it.second;\\n            // for ordering I am storing the movie and its freq in MyPair\\n            res.push_back(m);\\n        }\\n        sort(res.begin(), res.end(), compare);//sorting as needed\\n        for(i = 0 ; i < res.size(); i++){\\n            //inserting movies as asked\\n            output.push_back(res[i].movie);\\n        }\\n        return output;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    void helper(vector<vector<int>> friends , int level , int id, vector<int>& reqdFriends, unordered_map<int,int>& u){\\n        int i;\\n        u[id]++;\\n        if(level == 1){\\n            for(i = 0; i < friends[id].size(); i++){\\n                if(u.find(friends[id][i]) == u.end()){\\n                    //wont add friends found on previous level\\n                    reqdFriends.push_back(friends[id][i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 487330,
                "title": "bfs-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n          Map<Integer, Set<Integer>> map = new HashMap<>();\\n          for(int i=0;i<friends.length;i++){\\n              if(map.containsKey(i)==false){\\n                  map.put(i, new HashSet<>());\\n              }\\n              \\n              for(int ele: friends[i]){\\n                  map.get(i).add(ele);\\n                  if(map.containsKey(ele)==false){\\n                      map.put(ele, new HashSet<>());\\n                  }\\n                  map.get(ele).add(i);\\n              }\\n          }\\n        \\n        \\n          Queue<Integer> queue = new LinkedList<>();\\n          queue.offer(id);\\n          Set<Integer> set = new HashSet<>();\\n          set.add(id);\\n          \\n           \\n          int step = 0;\\n          while(queue.size()!=0){\\n               int size = queue.size();\\n              \\n               while(size--!=0){\\n                   int cur = queue.poll();\\n                   \\n                   for(int next: map.get(cur)){\\n                       if(set.contains(next)==false){\\n                           set.add(next);\\n                           queue.add(next);\\n                       }\\n                   }\\n               }\\n              \\n               step++;\\n               if(step == level){\\n                   break;\\n               }\\n          }\\n        \\n        \\n          Map<String, Integer> count = new HashMap<>();\\n          while(queue.size()!=0){\\n              int cur = queue.poll();\\n              List<String> list = watchedVideos.get(cur);\\n              for(String str: list){\\n                  count.put(str, count.getOrDefault(str, 0)+1);\\n              }\\n          }\\n        \\n          List<String> res = new ArrayList<>();\\n          for(String key: count.keySet()){\\n              res.add(key);\\n          }\\n        \\n          Collections.sort(res, new Comparator<String>(){\\n                public int compare(String a, String b){\\n                    int ele1 = count.get(a);\\n                    int ele2 = count.get(b);\\n                    \\n                    if(ele1!=ele2){\\n                        return ele1 - ele2;\\n                    }\\n                    \\n                    return a.compareTo(b);\\n                } \\n          });\\n          \\n          return res;\\n          \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n          Map<Integer, Set<Integer>> map = new HashMap<>();\\n          for(int i=0;i<friends.length;i++){\\n              if(map.containsKey(i)==false){\\n                  map.put(i, new HashSet<>());\\n              }\\n              \\n              for(int ele: friends[i]){\\n                  map.get(i).add(ele);\\n                  if(map.containsKey(ele)==false){\\n                      map.put(ele, new HashSet<>());\\n                  }\\n                  map.get(ele).add(i);\\n              }\\n          }\\n        \\n        \\n          Queue<Integer> queue = new LinkedList<>();\\n          queue.offer(id);\\n          Set<Integer> set = new HashSet<>();\\n          set.add(id);\\n          \\n           \\n          int step = 0;\\n          while(queue.size()!=0){\\n               int size = queue.size();\\n              \\n               while(size--!=0){\\n                   int cur = queue.poll();\\n                   \\n                   for(int next: map.get(cur)){\\n                       if(set.contains(next)==false){\\n                           set.add(next);\\n                           queue.add(next);\\n                       }\\n                   }\\n               }\\n              \\n               step++;\\n               if(step == level){\\n                   break;\\n               }\\n          }\\n        \\n        \\n          Map<String, Integer> count = new HashMap<>();\\n          while(queue.size()!=0){\\n              int cur = queue.poll();\\n              List<String> list = watchedVideos.get(cur);\\n              for(String str: list){\\n                  count.put(str, count.getOrDefault(str, 0)+1);\\n              }\\n          }\\n        \\n          List<String> res = new ArrayList<>();\\n          for(String key: count.keySet()){\\n              res.add(key);\\n          }\\n        \\n          Collections.sort(res, new Comparator<String>(){\\n                public int compare(String a, String b){\\n                    int ele1 = count.get(a);\\n                    int ele2 = count.get(b);\\n                    \\n                    if(ele1!=ele2){\\n                        return ele1 - ele2;\\n                    }\\n                    \\n                    return a.compareTo(b);\\n                } \\n          });\\n          \\n          return res;\\n          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472400,
                "title": "c-easy-to-understand-bfs-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n\\t\\t\\tint n=friends.size();\\n\\t\\t\\tvector<int> visited(n,-1);\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tqueue<int> qu;\\n\\t\\t\\tqu.push(id);\\n\\t\\t\\tvisited[id]=0;\\n\\t\\t\\twhile(!qu.empty()){\\n\\t\\t\\t\\tint cur=qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tfor(auto v:friends[cur]){\\n\\t\\t\\t\\t\\tif(visited[v]!=-1) continue;\\n\\t\\t\\t\\t\\tvisited[v]=visited[cur]+1;\\n\\t\\t\\t\\t\\tqu.push(v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tunordered_map<string,int> table;\\n\\t\\t\\tfor(int i=0;i<visited.size();i++){\\n\\t\\t\\t\\tif(visited[i]==level){\\n\\t\\t\\t\\t\\tfor(auto x:watchedVideos[i]){\\n\\t\\t\\t\\t\\t\\ttable[x]+=1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<pair<int,string>> temp;\\n\\t\\t\\tfor(auto v:table){\\n\\t\\t\\t\\ttemp.push_back({v.second,v.first});\\n\\t\\t\\t}\\n\\n\\t\\t\\tsort(temp.begin(),temp.end());\\n\\t\\t\\tfor(auto x:temp){\\n\\t\\t\\t\\tans.push_back(x.second);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n\\t\\t\\tint n=friends.size();\\n\\t\\t\\tvector<int> visited(n,-1);\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tqueue<int> qu;\\n\\t\\t\\tqu.push(id);\\n\\t\\t\\tvisited[id]=0;\\n\\t\\t\\twhile(!qu.empty()){\\n\\t\\t\\t\\tint cur=qu.front();\\n\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\tfor(auto v:friends[cur]){\\n\\t\\t\\t\\t\\tif(visited[v]!=-1) continue;\\n\\t\\t\\t\\t\\tvisited[v]=visited[cur]+1;\\n\\t\\t\\t\\t\\tqu.push(v);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 472180,
                "title": "javascript-what-s-wrong-with-my-javascript-bfs-sort",
                "content": "Appreciate if anyone can enlighten me! I\\'m stuck at test case #39:\\n\\n```javascript\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    const graph = [];\\n    for (let i = 0; i < friends.length; i++) {\\n        graph[i] = [];\\n        for (const friend of friends[i]) {\\n            graph[i].push(friend);\\n        }\\n    }\\n    const targetFriends = [];\\n    const freq = {};\\n    const res = new Set();\\n    bfs();\\n    for (const id of targetFriends) {\\n        for (const vid of watchedVideos[id]) {\\n            if (typeof freq[vid] === \\'undefined\\') freq[vid] = 0;\\n            freq[vid]++;\\n            res.add(vid);\\n        }\\n    }\\n    return Array.from(res).sort((a, b) => freq[a] - freq[b] || a.localeCompare(b));\\n    \\n    function bfs() {\\n        const visited = [];\\n        const queue = [];\\n        queue.push([id, 0]);\\n        while (queue.length > 0 && queue[0][1] <= level) {\\n            const front = queue.shift();\\n            if (front[1] === level) {\\n                targetFriends.push(front[0]);\\n            } else {\\n                for (const adj of graph[front[0]]) {\\n                    if (visited[adj]) continue;\\n                    queue.push([adj, front[1] + 1]);\\n                }\\n            }\\n            visited[front[0]] = true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    const graph = [];\\n    for (let i = 0; i < friends.length; i++) {\\n        graph[i] = [];\\n        for (const friend of friends[i]) {\\n            graph[i].push(friend);\\n        }\\n    }\\n    const targetFriends = [];\\n    const freq = {};\\n    const res = new Set();\\n    bfs();\\n    for (const id of targetFriends) {\\n        for (const vid of watchedVideos[id]) {\\n            if (typeof freq[vid] === \\'undefined\\') freq[vid] = 0;\\n            freq[vid]++;\\n            res.add(vid);\\n        }\\n    }\\n    return Array.from(res).sort((a, b) => freq[a] - freq[b] || a.localeCompare(b));\\n    \\n    function bfs() {\\n        const visited = [];\\n        const queue = [];\\n        queue.push([id, 0]);\\n        while (queue.length > 0 && queue[0][1] <= level) {\\n            const front = queue.shift();\\n            if (front[1] === level) {\\n                targetFriends.push(front[0]);\\n            } else {\\n                for (const adj of graph[front[0]]) {\\n                    if (visited[adj]) continue;\\n                    queue.push([adj, front[1] + 1]);\\n                }\\n            }\\n            visited[front[0]] = true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 470998,
                "title": "python-3-six-lines",
                "content": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, W: List[List[str]], F: List[List[int]], ID: int, K: int) -> List[str]:\\n        A, V = set(F[ID]), set([ID])\\n        for _ in range(K-1):\\n            A = set(sum([F[a] for a in A],[])) - V - A\\n            V = V.union(A)\\n        C = collections.Counter(sorted(sum([W[a] for a in A], [])))\\n        return sorted(C.keys(), key = lambda x: C[x])\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, W: List[List[str]], F: List[List[int]], ID: int, K: int) -> List[str]:\\n        A, V = set(F[ID]), set([ID])\\n        for _ in range(K-1):\\n            A = set(sum([F[a] for a in A],[])) - V - A\\n            V = V.union(A)\\n        C = collections.Counter(sorted(sum([W[a] for a in A], [])))\\n        return sorted(C.keys(), key = lambda x: C[x])\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 470691,
                "title": "bfs-with-custom-comparator",
                "content": "```\\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(friends[id]);\\n        Set<Integer> visited = new HashSet<>();\\n \\n        visited.add(id);\\n        Map<String,Integer> sol = new HashMap<>();\\n        \\n        while(!q.isEmpty()){\\n            level--;\\n            sol = new HashMap<>();\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int[] poll = q.poll();\\n                \\n                for(int x: poll){\\n                    if(visited.add(x)){\\n                        q.add(friends[x]);\\n                        List<String> temp = watchedVideos.get(x);\\n                        for(String s: temp)\\n                            sol.put(s,sol.getOrDefault(s,0)+1);\\n                    }\\n                }\\n            }\\n            \\n            if(level == 0) break;\\n        }\\n        \\n        List<Custom> res = new ArrayList<>();\\n        for(String s: sol.keySet()){\\n            res.add(new Custom(sol.get(s),s));\\n        }\\n        \\n        \\n        // sort the result            \\n        Collections.sort(res, new Comparator<Custom>(){\\n                    public int compare(Custom a, Custom b){\\n                        if(a.freq != b.freq) return a.freq - b.freq;                      \\n                        return a.c.compareTo(b.c);\\n                    }\\n        });\\n        \\n        // copy the output solution\\n        \\n        List<String> ans = new ArrayList<>();\\n        \\n        for(Custom c: res)\\n            ans.add(c.c);\\n                \\n        return ans;\\n\\n    }\\n    \\n    \\n    private class Custom {\\n        int freq;\\n        String c;\\n        \\n        public Custom(int f, String c){\\n            this.freq = f;\\n            this.c = c;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(friends[id]);\\n        Set<Integer> visited = new HashSet<>();\\n \\n        visited.add(id);\\n        Map<String,Integer> sol = new HashMap<>();\\n        \\n        while(!q.isEmpty()){\\n            level--;\\n            sol = new HashMap<>();\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int[] poll = q.poll();\\n                \\n                for(int x: poll){\\n                    if(visited.add(x)){\\n                        q.add(friends[x]);\\n                        List<String> temp = watchedVideos.get(x);\\n                        for(String s: temp)\\n                            sol.put(s,sol.getOrDefault(s,0)+1);\\n                    }\\n                }\\n            }\\n            \\n            if(level == 0) break;\\n        }\\n        \\n        List<Custom> res = new ArrayList<>();\\n        for(String s: sol.keySet()){\\n            res.add(new Custom(sol.get(s),s));\\n        }\\n        \\n        \\n        // sort the result            \\n        Collections.sort(res, new Comparator<Custom>(){\\n                    public int compare(Custom a, Custom b){\\n                        if(a.freq != b.freq) return a.freq - b.freq;                      \\n                        return a.c.compareTo(b.c);\\n                    }\\n        });\\n        \\n        // copy the output solution\\n        \\n        List<String> ans = new ArrayList<>();\\n        \\n        for(Custom c: res)\\n            ans.add(c.c);\\n                \\n        return ans;\\n\\n    }\\n    \\n    \\n    private class Custom {\\n        int freq;\\n        String c;\\n        \\n        public Custom(int f, String c){\\n            this.freq = f;\\n            this.c = c;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007029,
                "title": "simple-level-order-traversal-explanation-why-dfs-did-not-worked",
                "content": "# Intuition\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/465d0cd5-6009-46fa-9dcd-c6207bb3e0ea_1693940077.7598846.png)\\n\\n**Example:**\\n\\nGiven the following structure:\\n\\n```\\n[[1, 2], [2, 3], []]\\n```\\n\\nWe have the following parameters:\\n\\n- `id = 0`\\n- `level = 2`\\n\\nWhen we perform Depth-First Search (DFS) on the tree, it proceeds as follows:\\n\\n `0 -> 1 -> 2/3`\\n `0 -> 2`\\n\\nDuring the first case, the level of node 2 is `2`, whereas in the second case, the level of node 2 is `1`.\\n \\nWe need not to count for node 2 but during DFS we committed this mistake.\\n\\n---\\n\\n# Code\\n```class Solution {\\npublic:\\n    unordered_map<string,int> freq;\\n    void helper(vector<vector<string>>& watched,vector<vector<int>>& friends,vector<int>&vis, int node,int level, int k){\\n       \\n        vis[node]=k;\\n        if(vis[node]==level){\\n            for(auto c : watched[node] )\\n                freq[c]++;\\n            return ;\\n        }\\n        for(auto u : friends[node]){\\n            if(vis[u]==0) helper(watched,friends,vis,u,level,k+1);\\n        }\\n\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int>vis(n,0);\\n        // helper(watchedVideos,friends,vis,id,level+1,1);\\n        queue<int> q;\\n        q.push(id);\\n        vis[id]=1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            if(level==0) break;\\n            \\n            for(int i=0;i<size;i++){\\n                int node = q.front();\\n                q.pop();\\n\\n                for(auto u : friends[node]){\\n                    if(!vis[u]){\\n                        vis[u]=1;\\n                        q.push(u);\\n                    }\\n                }\\n\\n            }\\n            level--;\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            for(auto c : watched[node] )\\n                freq[c]++;\\n            q.pop();\\n        }\\n        vector<pair<int,string>> ans;\\n        for(auto m : freq) ans.push_back({m.second,m.first});\\n        sort(ans.begin(),ans.end());\\n        vector<string> answer;\\n        for(auto a : ans) answer.push_back(a.second);\\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n[[1, 2], [2, 3], []]\\n```\n```class Solution {\\npublic:\\n    unordered_map<string,int> freq;\\n    void helper(vector<vector<string>>& watched,vector<vector<int>>& friends,vector<int>&vis, int node,int level, int k){\\n       \\n        vis[node]=k;\\n        if(vis[node]==level){\\n            for(auto c : watched[node] )\\n                freq[c]++;\\n            return ;\\n        }\\n        for(auto u : friends[node]){\\n            if(vis[u]==0) helper(watched,friends,vis,u,level,k+1);\\n        }\\n\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watched, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int>vis(n,0);\\n        // helper(watchedVideos,friends,vis,id,level+1,1);\\n        queue<int> q;\\n        q.push(id);\\n        vis[id]=1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            if(level==0) break;\\n            \\n            for(int i=0;i<size;i++){\\n                int node = q.front();\\n                q.pop();\\n\\n                for(auto u : friends[node]){\\n                    if(!vis[u]){\\n                        vis[u]=1;\\n                        q.push(u);\\n                    }\\n                }\\n\\n            }\\n            level--;\\n        }\\n        while(!q.empty()){\\n            int node = q.front();\\n            for(auto c : watched[node] )\\n                freq[c]++;\\n            q.pop();\\n        }\\n        vector<pair<int,string>> ans;\\n        for(auto m : freq) ans.push_back({m.second,m.first});\\n        sort(ans.begin(),ans.end());\\n        vector<string> answer;\\n        for(auto a : ans) answer.push_back(a.second);\\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986581,
                "title": "python3-clean-bfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, wv: List[List[str]], fnds: List[List[int]], id: int, level: int) -> List[str]:\\n        \\n        \\n        n=len(wv)\\n        adj=defaultdict(list)\\n        \\n        for i in range(n):\\n            for x in fnds[i]:\\n                adj[i].append(x)\\n        \\n        \\n        q=deque([id])\\n        seen=set([id])\\n        h=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n                curr=q.popleft()\\n                for child in adj[curr]:\\n                    if child not in seen:\\n                        seen.add(child)\\n                        q.append(child)\\n            \\n            h+=1\\n            if h==level:\\n                break\\n            \\n        \\n        count=Counter()\\n        for friend in q:\\n            for video in wv[friend]:\\n                count[video]+=1\\n        \\n        return sorted(count.keys(), key=lambda x:(count[x],x))\\n    \\n                \\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, wv: List[List[str]], fnds: List[List[int]], id: int, level: int) -> List[str]:\\n        \\n        \\n        n=len(wv)\\n        adj=defaultdict(list)\\n        \\n        for i in range(n):\\n            for x in fnds[i]:\\n                adj[i].append(x)\\n        \\n        \\n        q=deque([id])\\n        seen=set([id])\\n        h=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n                curr=q.popleft()\\n                for child in adj[curr]:\\n                    if child not in seen:\\n                        seen.add(child)\\n                        q.append(child)\\n            \\n            h+=1\\n            if h==level:\\n                break\\n            \\n        \\n        count=Counter()\\n        for friend in q:\\n            for video in wv[friend]:\\n                count[video]+=1\\n        \\n        return sorted(count.keys(), key=lambda x:(count[x],x))\\n    \\n                \\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924779,
                "title": "c-bfs-hashmap-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is that we just need to do the level order traversal starting from level 0 till level **\"level\"** and then get the videos watched by the **friends at this level** in the desired order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, I\\'m using the **queue** data structure to store the pair<int,int> denoting **{level,friends}** and then do a simple **BFS** at all the friends at adjacent level and when we reach at level **\"level\"**, we are storing the friends in the array **nodes**. Also, to keep track of the already visited friends, we are using a visited array and then finally, to get the final array of strings in the desired order, I\\'m creating a hashmap to get the frequency of the videos and then using a set to have them sorted in the order of their frequencies and lexicographically for videos having same frequency.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n\\n        int n = friends.size();\\n\\n        queue<pair<int,int>> q;\\n        vector<bool> visited(n,false);\\n        q.push({0,id});\\n        visited[id] = true;\\n\\n        vector<int> nodes;\\n\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n\\n            int curr_level = it.first;\\n            int curr_id = it.second;\\n\\n            if(curr_level == level) {\\n                nodes.push_back(curr_id);\\n                continue;\\n            }\\n\\n            for(auto &i:friends[curr_id]) {\\n                if(visited[i]) continue;\\n                q.push({curr_level+1,i});\\n                visited[i] = true;\\n            }\\n        }\\n\\n        unordered_map<string,int> frequency;\\n        for(auto &i:nodes) {\\n            for(auto &j:watchedVideos[i]) frequency[j]++;\\n        }\\n\\n        set<pair<int,string>> st;\\n        for(auto &i:frequency) st.insert({i.second,i.first});\\n\\n        vector<string> ans;\\n        for(auto &i:st) ans.push_back(i.second);\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n\\n        int n = friends.size();\\n\\n        queue<pair<int,int>> q;\\n        vector<bool> visited(n,false);\\n        q.push({0,id});\\n        visited[id] = true;\\n\\n        vector<int> nodes;\\n\\n        while(!q.empty()) {\\n            auto it = q.front();\\n            q.pop();\\n\\n            int curr_level = it.first;\\n            int curr_id = it.second;\\n\\n            if(curr_level == level) {\\n                nodes.push_back(curr_id);\\n                continue;\\n            }\\n\\n            for(auto &i:friends[curr_id]) {\\n                if(visited[i]) continue;\\n                q.push({curr_level+1,i});\\n                visited[i] = true;\\n            }\\n        }\\n\\n        unordered_map<string,int> frequency;\\n        for(auto &i:nodes) {\\n            for(auto &j:watchedVideos[i]) frequency[j]++;\\n        }\\n\\n        set<pair<int,string>> st;\\n        for(auto &i:frequency) st.insert({i.second,i.first});\\n\\n        vector<string> ans;\\n        for(auto &i:st) ans.push_back(i.second);\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805992,
                "title": "fastest-unique-solution-very-easy-to-understand-bfs-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        queue<int> friendQue;\\n        vector<string> ans;\\n        vector<bool> visited(friends.size(), false);\\n        map<string, int> videoFreq;\\n        map<int, vector<string>> freqVideos;\\n\\n        friendQue.push(id);\\n        visited[id] = true;\\n        int size, curr;\\n        while(!friendQue.empty() && level--){\\n            size = friendQue.size();\\n            while(size--){\\n                curr = friendQue.front();\\n                friendQue.pop();\\n                for(int &f: friends[curr]){\\n                    if(!visited[f]){\\n                        visited[f] = true;\\n                        friendQue.push(f);\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!friendQue.empty()){\\n            curr = friendQue.front();\\n            friendQue.pop();\\n            for(string &video: watchedVideos[curr]){\\n                videoFreq[video]++;\\n            }\\n        }\\n\\n        for(auto &vfreq: videoFreq){\\n            freqVideos[vfreq.second].push_back(vfreq.first);\\n        }\\n\\n        for(auto &fv: freqVideos){\\n            for(auto &video: fv.second){\\n                ans.push_back(video);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        queue<int> friendQue;\\n        vector<string> ans;\\n        vector<bool> visited(friends.size(), false);\\n        map<string, int> videoFreq;\\n        map<int, vector<string>> freqVideos;\\n\\n        friendQue.push(id);\\n        visited[id] = true;\\n        int size, curr;\\n        while(!friendQue.empty() && level--){\\n            size = friendQue.size();\\n            while(size--){\\n                curr = friendQue.front();\\n                friendQue.pop();\\n                for(int &f: friends[curr]){\\n                    if(!visited[f]){\\n                        visited[f] = true;\\n                        friendQue.push(f);\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!friendQue.empty()){\\n            curr = friendQue.front();\\n            friendQue.pop();\\n            for(string &video: watchedVideos[curr]){\\n                videoFreq[video]++;\\n            }\\n        }\\n\\n        for(auto &vfreq: videoFreq){\\n            freqVideos[vfreq.second].push_back(vfreq.first);\\n        }\\n\\n        for(auto &fv: freqVideos){\\n            for(auto &video: fv.second){\\n                ans.push_back(video);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740431,
                "title": "bfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        queue<int> q;\\n        vector<bool> vis(n, false);\\n        vis[id]= true;\\n        for(auto x : friends[id]){\\n            q.push(x);\\n            vis[x] = true;\\n        }\\n        \\n        int k=1;\\n        while(level != k){\\n            int sz= q.size();\\n            for(int i=0; i<sz; i++){\\n                int v = q.front();\\n                q.pop();\\n                for(auto u : friends[v]){\\n                    if(!vis[u]) {\\n                        q.push(u);\\n                        vis[u] = true;\\n                    }\\n                }\\n            }\\n            k++;\\n        }\\n        unordered_map<string, int> mp;\\n        while(!q.empty()){\\n            int v= q.front();\\n            q.pop();\\n            for(auto s : watchedVideos[v]){\\n                mp[s]++;\\n            }\\n        }\\n        vector<pair<int, string>> vec;\\n        for(auto p : mp){\\n           vec.push_back({p.second, p.first});\\n        }\\n\\n        sort(vec.begin(), vec.end());\\n        vector<string> ans;\\n        for(auto p : vec){\\n            ans.push_back(p.second);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        queue<int> q;\\n        vector<bool> vis(n, false);\\n        vis[id]= true;\\n        for(auto x : friends[id]){\\n            q.push(x);\\n            vis[x] = true;\\n        }\\n        \\n        int k=1;\\n        while(level != k){\\n            int sz= q.size();\\n            for(int i=0; i<sz; i++){\\n                int v = q.front();\\n                q.pop();\\n                for(auto u : friends[v]){\\n                    if(!vis[u]) {\\n                        q.push(u);\\n                        vis[u] = true;\\n                    }\\n                }\\n            }\\n            k++;\\n        }\\n        unordered_map<string, int> mp;\\n        while(!q.empty()){\\n            int v= q.front();\\n            q.pop();\\n            for(auto s : watchedVideos[v]){\\n                mp[s]++;\\n            }\\n        }\\n        vector<pair<int, string>> vec;\\n        for(auto p : mp){\\n           vec.push_back({p.second, p.first});\\n        }\\n\\n        sort(vec.begin(), vec.end());\\n        vector<string> ans;\\n        for(auto p : vec){\\n            ans.push_back(p.second);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734132,
                "title": "bellman-ford-bfs-2-solutions",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    ////////////////////////////////////////////// Bellman Ford /////////////////////////////////////////////////\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& f, int id, int level) {\\n        set<int>ans;\\n        int n=f.size();\\n        vector<vector<int>>dp(level+1,vector<int>(n,INT_MAX));\\n        for(int i=0;i<level+1;i++){\\n            dp[i][id]=0;\\n        }\\n        for(int i=1;i<level+1;i++){\\n            for(int l=0;l<f.size();l++){\\n                int u=l;\\n                for(int m=0;m<f[l].size();m++){\\n                    int v=f[l][m];\\n                    if(dp[i-1][u]!=INT_MAX){\\n                        dp[i][v]=min(dp[i][v],dp[i-1][u]+1);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<=level;i++){\\n            for(int j=0;j<n;j++){\\n                if(dp[i][j]==level) ans.insert(j);\\n            }\\n        }\\n        map<string,int>m;\\n        vector<string>s;\\n        for(auto x:ans){\\n            for(auto y:w[x]) m[y]++;\\n        }\\n        vector<pair<int,string>>temp;\\n        for(auto x:m){\\n            temp.push_back({x.second,x.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<temp.size();i++){\\n            s.push_back(temp[i].second);\\n        }\\n        return s;\\n    }\\n\\n    ////////////////////////////////////////////////// BFS /////////////////////////////////////////////////////\\n    vector<string> watchedVideosByFriendsBFS(vector<vector<string>>& w, vector<vector<int>>& f, int id, int l) {\\n        int n=f.size();\\n        queue<int>q;\\n        q.push(id);\\n        int x=0;\\n        vector<int>dist(n,INT_MAX);\\n        dist[id]=0;\\n        while(!q.empty()){\\n            int y=q.front();q.pop();\\n            for(int i=0;i<f[y].size();i++){\\n                if(dist[f[y][i]]>dist[y]+1){\\n                    dist[f[y][i]]=dist[y]+1;\\n                    q.push(f[y][i]);\\n                }\\n            }\\n        }\\n        map<string,int>m;\\n        vector<string>s;\\n        for(int i=0;i<dist.size();i++){\\n            if(dist[i]==l){\\n                for(auto x:w[i]) m[x]++;\\n            }\\n        }\\n        vector<pair<int,string>>temp;\\n        for(auto x:m){\\n            temp.push_back({x.second,x.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<temp.size();i++){\\n            s.push_back(temp[i].second);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ////////////////////////////////////////////// Bellman Ford /////////////////////////////////////////////////\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& f, int id, int level) {\\n        set<int>ans;\\n        int n=f.size();\\n        vector<vector<int>>dp(level+1,vector<int>(n,INT_MAX));\\n        for(int i=0;i<level+1;i++){\\n            dp[i][id]=0;\\n        }\\n        for(int i=1;i<level+1;i++){\\n            for(int l=0;l<f.size();l++){\\n                int u=l;\\n                for(int m=0;m<f[l].size();m++){\\n                    int v=f[l][m];\\n                    if(dp[i-1][u]!=INT_MAX){\\n                        dp[i][v]=min(dp[i][v],dp[i-1][u]+1);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<=level;i++){\\n            for(int j=0;j<n;j++){\\n                if(dp[i][j]==level) ans.insert(j);\\n            }\\n        }\\n        map<string,int>m;\\n        vector<string>s;\\n        for(auto x:ans){\\n            for(auto y:w[x]) m[y]++;\\n        }\\n        vector<pair<int,string>>temp;\\n        for(auto x:m){\\n            temp.push_back({x.second,x.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<temp.size();i++){\\n            s.push_back(temp[i].second);\\n        }\\n        return s;\\n    }\\n\\n    ////////////////////////////////////////////////// BFS /////////////////////////////////////////////////////\\n    vector<string> watchedVideosByFriendsBFS(vector<vector<string>>& w, vector<vector<int>>& f, int id, int l) {\\n        int n=f.size();\\n        queue<int>q;\\n        q.push(id);\\n        int x=0;\\n        vector<int>dist(n,INT_MAX);\\n        dist[id]=0;\\n        while(!q.empty()){\\n            int y=q.front();q.pop();\\n            for(int i=0;i<f[y].size();i++){\\n                if(dist[f[y][i]]>dist[y]+1){\\n                    dist[f[y][i]]=dist[y]+1;\\n                    q.push(f[y][i]);\\n                }\\n            }\\n        }\\n        map<string,int>m;\\n        vector<string>s;\\n        for(int i=0;i<dist.size();i++){\\n            if(dist[i]==l){\\n                for(auto x:w[i]) m[x]++;\\n            }\\n        }\\n        vector<pair<int,string>>temp;\\n        for(auto x:m){\\n            temp.push_back({x.second,x.first});\\n        }\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<temp.size();i++){\\n            s.push_back(temp[i].second);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731436,
                "title": "get-watched-videos-by-your-friends-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        var graph = constructGraph(watchedVideos, friends);\\n\\n        return breadthFirstSearch(graph, id, level);\\n    }\\n\\n    private static List<String> breadthFirstSearch(Graph graph, int id, int level) {\\n        var watchedVideosByPeopleToWatchCountMap = new HashMap<String, Integer>();\\n\\n        var bfsQueue = new LinkedList<Integer>();\\n        bfsQueue.add(id);\\n\\n        var visited = new boolean[graph.getSize()];\\n\\n        var numberOfLevelsConsidered = 0;\\n\\n        while (!bfsQueue.isEmpty()) {\\n            var queueSize = bfsQueue.size();\\n\\n            for (var i = 0; i < queueSize; i++) {\\n                var currentPersonId = bfsQueue.remove();\\n\\n                if (visited[currentPersonId]) {\\n                    continue;\\n                }\\n\\n                visited[currentPersonId] = true;\\n\\n                if (numberOfLevelsConsidered == level) {\\n                    var videosWatchedByCurrentPerson = graph.getVideosWatchedById(currentPersonId);\\n\\n                    for (var videoWatchedByCurrentPerson : videosWatchedByCurrentPerson) {\\n                        if (!watchedVideosByPeopleToWatchCountMap.containsKey(videoWatchedByCurrentPerson)) {\\n                            watchedVideosByPeopleToWatchCountMap.put(videoWatchedByCurrentPerson, 1);\\n                        } else {\\n                            var videoWatchedByCurrentFriendCurrentWatchCount = watchedVideosByPeopleToWatchCountMap.get(videoWatchedByCurrentPerson);\\n                            watchedVideosByPeopleToWatchCountMap.put(videoWatchedByCurrentPerson, videoWatchedByCurrentFriendCurrentWatchCount + 1);\\n                        }\\n                    }\\n                }\\n\\n                var friendIdsOfCurrentPerson = graph.getFriendsOfId(currentPersonId);\\n\\n                bfsQueue.addAll(friendIdsOfCurrentPerson);\\n            }\\n\\n            if (numberOfLevelsConsidered == level) {\\n                break;\\n            }\\n\\n            numberOfLevelsConsidered++;\\n        }\\n\\n        return sortWatchedVideosByPeople(watchedVideosByPeopleToWatchCountMap.entrySet());\\n    }\\n\\n    private static Graph constructGraph(List<List<String>> watchedVideos, int[][] friends) {\\n        var graph = new Graph();\\n\\n        for (var id = 0; id < friends.length; id++) {\\n            var friendsOfCurrentId = new ArrayList<Integer>();\\n\\n            for (var friend = 0; friend < friends[id].length; friend++) {\\n                friendsOfCurrentId.add(friends[id][friend]);\\n            }\\n\\n            graph.addFriendsOfId(id, friendsOfCurrentId);\\n\\n            var videosWatchedByCurrentId = watchedVideos.get(id);\\n\\n            graph.addVideosWatchedById(id, videosWatchedByCurrentId);\\n        }\\n\\n        return graph;\\n    }\\n\\n    private static List<String> sortWatchedVideosByPeople(Set<Map.Entry<String, Integer>> watchedVideosByPeopleToWatchCountMap) {\\n        var sortedWatchedVideosByPeopleToWatchCountMapAsList = new ArrayList<>(watchedVideosByPeopleToWatchCountMap.stream().toList());\\n\\n        sortedWatchedVideosByPeopleToWatchCountMapAsList.sort((firstEntry, secondEntry) -> {\\n            var firstVideoName = firstEntry.getKey();\\n            var firstVideoWatchCount = firstEntry.getValue();\\n            var secondVideoName = secondEntry.getKey();\\n            var secondVideoWatchCount = secondEntry.getValue();\\n\\n            if (Objects.equals(firstVideoWatchCount, secondVideoWatchCount)) {\\n                return firstVideoName.compareTo(secondVideoName);\\n            }\\n\\n            if (firstVideoWatchCount > secondVideoWatchCount) {\\n                return 1;\\n            }\\n\\n            return -1;\\n        });\\n\\n        return new ArrayList<>(sortedWatchedVideosByPeopleToWatchCountMapAsList.stream().map(Map.Entry::getKey).toList());\\n    }\\n\\n    private static class Graph {\\n        private final Map<Integer, List<Integer>> friendsById;\\n\\n        private final Map<Integer, List<String>> videosWatchedById;\\n\\n        public Graph() {\\n            this.friendsById = new HashMap<>();\\n            this.videosWatchedById = new HashMap<>();\\n        }\\n\\n        public void addFriendsOfId(int id, List<Integer> friendsOfId) {\\n            this.friendsById.put(id, friendsOfId);\\n        }\\n\\n        public void addVideosWatchedById(int id, List<String> videosWatchedById) {\\n            this.videosWatchedById.put(id, videosWatchedById);\\n        }\\n\\n        public List<Integer> getFriendsOfId(int id) {\\n            return this.friendsById.get(id);\\n        }\\n\\n        public List<String> getVideosWatchedById(int id) {\\n            return this.videosWatchedById.get(id);\\n        }\\n\\n        public int getSize() {\\n            return this.friendsById.size();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        var graph = constructGraph(watchedVideos, friends);\\n\\n        return breadthFirstSearch(graph, id, level);\\n    }\\n\\n    private static List<String> breadthFirstSearch(Graph graph, int id, int level) {\\n        var watchedVideosByPeopleToWatchCountMap = new HashMap<String, Integer>();\\n\\n        var bfsQueue = new LinkedList<Integer>();\\n        bfsQueue.add(id);\\n\\n        var visited = new boolean[graph.getSize()];\\n\\n        var numberOfLevelsConsidered = 0;\\n\\n        while (!bfsQueue.isEmpty()) {\\n            var queueSize = bfsQueue.size();\\n\\n            for (var i = 0; i < queueSize; i++) {\\n                var currentPersonId = bfsQueue.remove();\\n\\n                if (visited[currentPersonId]) {\\n                    continue;\\n                }\\n\\n                visited[currentPersonId] = true;\\n\\n                if (numberOfLevelsConsidered == level) {\\n                    var videosWatchedByCurrentPerson = graph.getVideosWatchedById(currentPersonId);\\n\\n                    for (var videoWatchedByCurrentPerson : videosWatchedByCurrentPerson) {\\n                        if (!watchedVideosByPeopleToWatchCountMap.containsKey(videoWatchedByCurrentPerson)) {\\n                            watchedVideosByPeopleToWatchCountMap.put(videoWatchedByCurrentPerson, 1);\\n                        } else {\\n                            var videoWatchedByCurrentFriendCurrentWatchCount = watchedVideosByPeopleToWatchCountMap.get(videoWatchedByCurrentPerson);\\n                            watchedVideosByPeopleToWatchCountMap.put(videoWatchedByCurrentPerson, videoWatchedByCurrentFriendCurrentWatchCount + 1);\\n                        }\\n                    }\\n                }\\n\\n                var friendIdsOfCurrentPerson = graph.getFriendsOfId(currentPersonId);\\n\\n                bfsQueue.addAll(friendIdsOfCurrentPerson);\\n            }\\n\\n            if (numberOfLevelsConsidered == level) {\\n                break;\\n            }\\n\\n            numberOfLevelsConsidered++;\\n        }\\n\\n        return sortWatchedVideosByPeople(watchedVideosByPeopleToWatchCountMap.entrySet());\\n    }\\n\\n    private static Graph constructGraph(List<List<String>> watchedVideos, int[][] friends) {\\n        var graph = new Graph();\\n\\n        for (var id = 0; id < friends.length; id++) {\\n            var friendsOfCurrentId = new ArrayList<Integer>();\\n\\n            for (var friend = 0; friend < friends[id].length; friend++) {\\n                friendsOfCurrentId.add(friends[id][friend]);\\n            }\\n\\n            graph.addFriendsOfId(id, friendsOfCurrentId);\\n\\n            var videosWatchedByCurrentId = watchedVideos.get(id);\\n\\n            graph.addVideosWatchedById(id, videosWatchedByCurrentId);\\n        }\\n\\n        return graph;\\n    }\\n\\n    private static List<String> sortWatchedVideosByPeople(Set<Map.Entry<String, Integer>> watchedVideosByPeopleToWatchCountMap) {\\n        var sortedWatchedVideosByPeopleToWatchCountMapAsList = new ArrayList<>(watchedVideosByPeopleToWatchCountMap.stream().toList());\\n\\n        sortedWatchedVideosByPeopleToWatchCountMapAsList.sort((firstEntry, secondEntry) -> {\\n            var firstVideoName = firstEntry.getKey();\\n            var firstVideoWatchCount = firstEntry.getValue();\\n            var secondVideoName = secondEntry.getKey();\\n            var secondVideoWatchCount = secondEntry.getValue();\\n\\n            if (Objects.equals(firstVideoWatchCount, secondVideoWatchCount)) {\\n                return firstVideoName.compareTo(secondVideoName);\\n            }\\n\\n            if (firstVideoWatchCount > secondVideoWatchCount) {\\n                return 1;\\n            }\\n\\n            return -1;\\n        });\\n\\n        return new ArrayList<>(sortedWatchedVideosByPeopleToWatchCountMapAsList.stream().map(Map.Entry::getKey).toList());\\n    }\\n\\n    private static class Graph {\\n        private final Map<Integer, List<Integer>> friendsById;\\n\\n        private final Map<Integer, List<String>> videosWatchedById;\\n\\n        public Graph() {\\n            this.friendsById = new HashMap<>();\\n            this.videosWatchedById = new HashMap<>();\\n        }\\n\\n        public void addFriendsOfId(int id, List<Integer> friendsOfId) {\\n            this.friendsById.put(id, friendsOfId);\\n        }\\n\\n        public void addVideosWatchedById(int id, List<String> videosWatchedById) {\\n            this.videosWatchedById.put(id, videosWatchedById);\\n        }\\n\\n        public List<Integer> getFriendsOfId(int id) {\\n            return this.friendsById.get(id);\\n        }\\n\\n        public List<String> getVideosWatchedById(int id) {\\n            return this.videosWatchedById.get(id);\\n        }\\n\\n        public int getSize() {\\n            return this.friendsById.size();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716901,
                "title": "python-bfs-sorting",
                "content": "# Intuition\\nThink of this as graph problem where each person is graph node, do the simple BFS and count levels, measure frequency of values on target level. Sort the way it is explained in problem statement.\\nI did level start from 1 so I don\\'t need to use L+1 in comparisons to children (node to) level!\\n\\n# Complexity\\n- Time complexity:\\n$$O(nV)$$ - n is number of nodes in graph, V is number of videos watched by each of nodes\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], root: int, level: int) -> List[str]:\\n        seen, qu, count, L = {root}, [root], Counter(), 1\\n        while qu:\\n            new_qu = []\\n            for node in qu:\\n                for to in friends[node]:\\n                    if to not in seen and L <= level:                         \\n                        new_qu.append(to)\\n                        seen.add(to)\\n                        if L == level: count += Counter(watchedVideos[to])\\n            L += 1\\n            qu = new_qu\\n\\n        return sorted(count, key=lambda x: (count[x], x))\\n           \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sort",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], root: int, level: int) -> List[str]:\\n        seen, qu, count, L = {root}, [root], Counter(), 1\\n        while qu:\\n            new_qu = []\\n            for node in qu:\\n                for to in friends[node]:\\n                    if to not in seen and L <= level:                         \\n                        new_qu.append(to)\\n                        seen.add(to)\\n                        if L == level: count += Counter(watchedVideos[to])\\n            L += 1\\n            qu = new_qu\\n\\n        return sorted(count, key=lambda x: (count[x], x))\\n           \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676028,
                "title": "simple-c-code-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& f, int id, int level) {\\n        int n = wv.size();\\n        vector<int>dis(n,1e8);\\n        queue<pair<int,int>>q;\\n        q.push({0,id});\\n        dis[id] = 0;\\n        while(!q.empty()){\\n            int node = q.front().second;\\n            int wt = q.front().first;\\n            q.pop();\\n            for(auto it:f[node]){\\n                if(wt + 1<dis[it]){\\n                    dis[it] = wt + 1;\\n                    cout<<it<<\" \";\\n                    q.push({1+wt,it});\\n                }\\n            }\\n        }\\n        unordered_map<string,int>mp;\\n        for(int i = 0;i<n;i++){\\n            if(dis[i]==level){\\n                for(auto it:wv[i]){\\n                    mp[it]++;\\n                }\\n            }\\n        }\\n        vector<pair<int, string>> pairs;\\n        for(auto it:mp){\\n            pairs.push_back({it.second,it.first});\\n        }\\n        sort(pairs.begin(), pairs.end());\\n        vector<string> res;\\n        for (auto p : pairs) res.push_back(p.second);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& f, int id, int level) {\\n        int n = wv.size();\\n        vector<int>dis(n,1e8);\\n        queue<pair<int,int>>q;\\n        q.push({0,id});\\n        dis[id] = 0;\\n        while(!q.empty()){\\n            int node = q.front().second;\\n            int wt = q.front().first;\\n            q.pop();\\n            for(auto it:f[node]){\\n                if(wt + 1<dis[it]){\\n                    dis[it] = wt + 1;\\n                    cout<<it<<\" \";\\n                    q.push({1+wt,it});\\n                }\\n            }\\n        }\\n        unordered_map<string,int>mp;\\n        for(int i = 0;i<n;i++){\\n            if(dis[i]==level){\\n                for(auto it:wv[i]){\\n                    mp[it]++;\\n                }\\n            }\\n        }\\n        vector<pair<int, string>> pairs;\\n        for(auto it:mp){\\n            pairs.push_back({it.second,it.first});\\n        }\\n        sort(pairs.begin(), pairs.end());\\n        vector<string> res;\\n        for (auto p : pairs) res.push_back(p.second);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3634613,
                "title": "java-8-streams-bfs",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        \\n        Set<Integer> result = new HashSet<>();\\n\\n        result.add(id);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(id);\\n        \\n        while(level > 0){\\n            \\n            List<Integer> temp = new ArrayList<>();\\n            \\n            for(int key: result){\\n                for(int friend: friends[key]){\\n                    if(!visited.contains(friend)){\\n                        temp.add(friend);\\n                    }\\n                }\\n            }\\n            \\n            level--;\\n            result.clear();\\n            result.addAll(temp);\\n            visited.addAll(temp);\\n            \\n        }\\n        \\n        Map<String, Integer> movies = new HashMap<>();\\n        \\n        for(int friend: result){\\n            for(String watchedVideo: watchedVideos.get(friend)){\\n                movies.put(watchedVideo, movies.getOrDefault(watchedVideo, 0 ) + 1);\\n            }\\n        }\\n        \\n        // System.out.println(movies);\\n        \\n        return movies.entrySet()\\n                        .stream()\\n                        .sorted((i1, i2) -> {\\n                            int compareResult = i1.getValue().compareTo(i2.getValue());\\n                            if(compareResult == 0){\\n                                return i1.getKey().compareTo(i2.getKey());\\n                            }\\n                            return compareResult;\\n                        })\\n                        .map(i -> i.getKey())\\n                        .collect(Collectors.toList());\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        \\n        Set<Integer> result = new HashSet<>();\\n\\n        result.add(id);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(id);\\n        \\n        while(level > 0){\\n            \\n            List<Integer> temp = new ArrayList<>();\\n            \\n            for(int key: result){\\n                for(int friend: friends[key]){\\n                    if(!visited.contains(friend)){\\n                        temp.add(friend);\\n                    }\\n                }\\n            }\\n            \\n            level--;\\n            result.clear();\\n            result.addAll(temp);\\n            visited.addAll(temp);\\n            \\n        }\\n        \\n        Map<String, Integer> movies = new HashMap<>();\\n        \\n        for(int friend: result){\\n            for(String watchedVideo: watchedVideos.get(friend)){\\n                movies.put(watchedVideo, movies.getOrDefault(watchedVideo, 0 ) + 1);\\n            }\\n        }\\n        \\n        // System.out.println(movies);\\n        \\n        return movies.entrySet()\\n                        .stream()\\n                        .sorted((i1, i2) -> {\\n                            int compareResult = i1.getValue().compareTo(i2.getValue());\\n                            if(compareResult == 0){\\n                                return i1.getKey().compareTo(i2.getKey());\\n                            }\\n                            return compareResult;\\n                        })\\n                        .map(i -> i.getKey())\\n                        .collect(Collectors.toList());\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604204,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n\\tvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n\\t{\\n\\t\\tint size_of_friends = friends.size();\\n\\t\\tint oth_param = -1;\\n\\t\\tint clr_var = 0;\\n    int ctrl_flag = -1;\\n\\n\\t\\tvector<string> my_v1;\\n\\t\\tqueue<int> my_q1;\\n\\n\\t\\tvector<int> visited(size_of_friends, oth_param);\\n\\t\\tmy_q1.push(id);\\n\\t\\tvisited[id] = clr_var;\\n\\n\\t\\tfor (; !my_q1.empty(); my_q1.pop())\\n    {\\n\\t\\t\\tint var_1 = my_q1.front();\\n\\n\\t\\t\\tfor(auto v:friends[var_1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ctrl_flag != visited[v])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t continue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[v] = visited[var_1] +1 ;\\n\\t\\t\\t\\tmy_q1.push(v);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tunordered_map<string,int> table;\\n\\n\\t\\tfor(int i=0;i<visited.size();i++)\\n\\t\\t{\\n\\t\\t\\tif(visited[i]==level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(auto x:watchedVideos[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttable[x]+=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<pair<int,string>> my_v2;\\n\\n\\t\\tfor(auto v:table){\\n\\t\\t\\tmy_v2.push_back({v.second,v.first});\\n\\t\\t}\\n\\t\\tsort(my_v2.begin(),my_v2.end());\\n\\t\\tfor(auto x:my_v2){\\n\\t\\t\\tmy_v1.push_back(x.second);\\n\\t\\t}\\n\\t\\treturn my_v1;\\n\\t}\\n};\\n```\\n\\n```Python3 []\\nimport collections\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        bfs,visited={id},{id}\\n        for _ in range(level):\\n            bfs={j for i in bfs for j in friends[i] if j not in visited}\\n            visited|=bfs\\n        freq=collections.Counter([v for idx in bfs for v in watchedVideos[idx]])\\n        return sorted(freq.keys(),key=lambda x:(freq[x],x))\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        LinkedList<Integer> queue = new LinkedList<Integer>();\\n        queue.offer(id);\\n        int layer = -1;\\n        int[] levels = new int[friends.length];\\n        Arrays.fill(levels, -1);\\n        while (!queue.isEmpty()) {\\n            layer++;\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int person = queue.poll();\\n                levels[person] = layer;\\n                queue.offer(person);\\n            }\\n            for (int i = 0; i < size; i++) {\\n                int person = queue.poll();\\n                for (int j = 0; j < friends[person].length; j++) {\\n                    if (levels[friends[person][j]] == -1) {\\n                        queue.offer(friends[person][j]);\\n                    }\\n                }\\n            }\\n            if (layer == level) {\\n                break;\\n            }\\n        }\\n        List<Integer> personList = new ArrayList<Integer>();\\n        for (int i = 0; i < levels.length; i++) {\\n            if (levels[i] == level) {\\n                personList.add(i);\\n            }\\n        }\\n        if (personList.size() == 0) {\\n            return new ArrayList<String>();\\n        }\\n        Map<String, Integer> frequencyMap = new HashMap<String, Integer>();\\n        for (Integer person : personList) {\\n            for (String video : watchedVideos.get(person)) {\\n                frequencyMap.put(video, \\n                frequencyMap.getOrDefault(video, 0) + 1);\\n            }\\n        }\\n        Map<Integer, Set<String>> reverseMap = \\n        new TreeMap<Integer, Set<String>>();\\n        for (String video : frequencyMap.keySet()) {\\n            reverseMap.putIfAbsent(frequencyMap.get(video), \\n            new TreeSet<String>());\\n            reverseMap.get(frequencyMap.get(video)).add(video);\\n        }\\n        List<String> resultList = new ArrayList<String>();\\n        for (Integer frequency : reverseMap.keySet()) {\\n            for (String video : reverseMap.get(frequency)) {\\n                resultList.add(video);\\n            }\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\tvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n\\t{\\n\\t\\tint size_of_friends = friends.size();\\n\\t\\tint oth_param = -1;\\n\\t\\tint clr_var = 0;\\n    int ctrl_flag = -1;\\n\\n\\t\\tvector<string> my_v1;\\n\\t\\tqueue<int> my_q1;\\n\\n\\t\\tvector<int> visited(size_of_friends, oth_param);\\n\\t\\tmy_q1.push(id);\\n\\t\\tvisited[id] = clr_var;\\n\\n\\t\\tfor (; !my_q1.empty(); my_q1.pop())\\n    {\\n\\t\\t\\tint var_1 = my_q1.front();\\n\\n\\t\\t\\tfor(auto v:friends[var_1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ctrl_flag != visited[v])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t continue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvisited[v] = visited[var_1] +1 ;\\n\\t\\t\\t\\tmy_q1.push(v);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tunordered_map<string,int> table;\\n\\n\\t\\tfor(int i=0;i<visited.size();i++)\\n\\t\\t{\\n\\t\\t\\tif(visited[i]==level)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(auto x:watchedVideos[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttable[x]+=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<pair<int,string>> my_v2;\\n\\n\\t\\tfor(auto v:table){\\n\\t\\t\\tmy_v2.push_back({v.second,v.first});\\n\\t\\t}\\n\\t\\tsort(my_v2.begin(),my_v2.end());\\n\\t\\tfor(auto x:my_v2){\\n\\t\\t\\tmy_v1.push_back(x.second);\\n\\t\\t}\\n\\t\\treturn my_v1;\\n\\t}\\n};\\n```\n```Python3 []\\nimport collections\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        bfs,visited={id},{id}\\n        for _ in range(level):\\n            bfs={j for i in bfs for j in friends[i] if j not in visited}\\n            visited|=bfs\\n        freq=collections.Counter([v for idx in bfs for v in watchedVideos[idx]])\\n        return sorted(freq.keys(),key=lambda x:(freq[x],x))\\n```\n```Java []\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        LinkedList<Integer> queue = new LinkedList<Integer>();\\n        queue.offer(id);\\n        int layer = -1;\\n        int[] levels = new int[friends.length];\\n        Arrays.fill(levels, -1);\\n        while (!queue.isEmpty()) {\\n            layer++;\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int person = queue.poll();\\n                levels[person] = layer;\\n                queue.offer(person);\\n            }\\n            for (int i = 0; i < size; i++) {\\n                int person = queue.poll();\\n                for (int j = 0; j < friends[person].length; j++) {\\n                    if (levels[friends[person][j]] == -1) {\\n                        queue.offer(friends[person][j]);\\n                    }\\n                }\\n            }\\n            if (layer == level) {\\n                break;\\n            }\\n        }\\n        List<Integer> personList = new ArrayList<Integer>();\\n        for (int i = 0; i < levels.length; i++) {\\n            if (levels[i] == level) {\\n                personList.add(i);\\n            }\\n        }\\n        if (personList.size() == 0) {\\n            return new ArrayList<String>();\\n        }\\n        Map<String, Integer> frequencyMap = new HashMap<String, Integer>();\\n        for (Integer person : personList) {\\n            for (String video : watchedVideos.get(person)) {\\n                frequencyMap.put(video, \\n                frequencyMap.getOrDefault(video, 0) + 1);\\n            }\\n        }\\n        Map<Integer, Set<String>> reverseMap = \\n        new TreeMap<Integer, Set<String>>();\\n        for (String video : frequencyMap.keySet()) {\\n            reverseMap.putIfAbsent(frequencyMap.get(video), \\n            new TreeSet<String>());\\n            reverseMap.get(frequencyMap.get(video)).add(video);\\n        }\\n        List<String> resultList = new ArrayList<String>();\\n        for (Integer frequency : reverseMap.keySet()) {\\n            for (String video : reverseMap.get(frequency)) {\\n                resultList.add(video);\\n            }\\n        }\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595982,
                "title": "easy-to-understand-javascript-solution-bfs",
                "content": "```\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    const visited = new Set([id]);\\n    const queue = [id];\\n\\n    while (queue.length && level > 0) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const id = queue.shift();\\n            const friend = friends[id];\\n\\n            friend.forEach(friendId => {\\n                if (visited.has(friendId)) return;\\n                queue.push(friendId);\\n                visited.add(friendId);\\n            });\\n        }\\n        level -= 1;\\n    }\\n    const videosMap = queue.reduce((map, id) => {\\n        const videos = watchedVideos[id];\\n\\n        videos.forEach(video => {\\n            const count = map.get(video) ?? 0;\\n            map.set(video, count + 1);\\n        });\\n        return map;\\n    }, new Map());\\n    const videos = [...videosMap.entries()].sort((a, b) => a[1] - b[1] || a[0].localeCompare(b[0]));\\n\\n    return videos.map(([video]) => video);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    const visited = new Set([id]);\\n    const queue = [id];\\n\\n    while (queue.length && level > 0) {\\n        const size = queue.length;\\n\\n        for (let index = 0; index < size; index++) {\\n            const id = queue.shift();\\n            const friend = friends[id];\\n\\n            friend.forEach(friendId => {\\n                if (visited.has(friendId)) return;\\n                queue.push(friendId);\\n                visited.add(friendId);\\n            });\\n        }\\n        level -= 1;\\n    }\\n    const videosMap = queue.reduce((map, id) => {\\n        const videos = watchedVideos[id];\\n\\n        videos.forEach(video => {\\n            const count = map.get(video) ?? 0;\\n            map.set(video, count + 1);\\n        });\\n        return map;\\n    }, new Map());\\n    const videos = [...videosMap.entries()].sort((a, b) => a[1] - b[1] || a[0].localeCompare(b[0]));\\n\\n    return videos.map(([video]) => video);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591397,
                "title": "simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static bool cmp(pair<int,string>& a, pair<int,string>&b){\\n        if(a.first==b.first){\\n            return a.second < b.second;\\n        }\\n        return a.first < b.first;\\n    }\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        queue<pair<int,int>> q;\\n        q.push({id,0});\\n        vector<pair<int,string>> v;\\n        vector<int> vis(friends.size(),0);\\n        vector<int> kthFriends;\\n        vis[id] = 1;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int id1 = it.first;\\n            int level1 = it.second;\\n            if(level1==level){\\n                kthFriends.push_back(id1);\\n            }\\n            else if(level1<level){\\n                 for(auto it : friends[id1]){\\n                    if(vis[it]==0){\\n                        vis[it] = 1;\\n                        q.push({it,level1+1});\\n                    }\\n                }\\n            }\\n\\n        }\\n        unordered_map<string,int> mp;\\n        for(auto it : kthFriends){\\n            for(auto movie : watchedVideos[it]){\\n                mp[movie]++;\\n            }\\n        }\\n        for(auto it : mp){\\n            v.push_back({it.second,it.first});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<string> ans;\\n        for(auto it : v){\\n            ans.push_back(it.second);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(pair<int,string>& a, pair<int,string>&b){\\n        if(a.first==b.first){\\n            return a.second < b.second;\\n        }\\n        return a.first < b.first;\\n    }\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        queue<pair<int,int>> q;\\n        q.push({id,0});\\n        vector<pair<int,string>> v;\\n        vector<int> vis(friends.size(),0);\\n        vector<int> kthFriends;\\n        vis[id] = 1;\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int id1 = it.first;\\n            int level1 = it.second;\\n            if(level1==level){\\n                kthFriends.push_back(id1);\\n            }\\n            else if(level1<level){\\n                 for(auto it : friends[id1]){\\n                    if(vis[it]==0){\\n                        vis[it] = 1;\\n                        q.push({it,level1+1});\\n                    }\\n                }\\n            }\\n\\n        }\\n        unordered_map<string,int> mp;\\n        for(auto it : kthFriends){\\n            for(auto movie : watchedVideos[it]){\\n                mp[movie]++;\\n            }\\n        }\\n        for(auto it : mp){\\n            v.push_back({it.second,it.first});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        vector<string> ans;\\n        for(auto it : v){\\n            ans.push_back(it.second);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588710,
                "title": "python3-bfs-hash-table",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        graph, visited, dist = {}, [], []\\n        n, mx = len(watchedVideos), float(\"inf\")\\n\\n        for i in range(n):\\n            graph[i] = [] \\n            visited.append(0)\\n            dist.append(mx)\\n\\n        for i in range(n):\\n            for neighbor in friends[i]:\\n                graph[i].append(neighbor)\\n                graph[neighbor].append(i)\\n\\n        queue, idx = [id], 0\\n        visited[id], dist[id], total = 1, 0, []\\n        while idx < len(queue):\\n            src = queue[idx]\\n            idx += 1\\n            for neighbor in graph[src]:\\n                if not visited[neighbor]:\\n                    visited[neighbor] = 1\\n                    queue.append(neighbor)\\n                    dist[neighbor] = dist[src] + 1\\n\\n        for i in range(n):\\n            if dist[i] == level:\\n                total += watchedVideos[i]\\n\\n        freq, unique, combined = Counter(total), set(), {}\\n        for i in freq.keys():\\n            unique.add(freq[i])\\n            if combined.get(freq[i]) == None:\\n                combined[freq[i]] = [i]\\n            else:\\n                combined[freq[i]].append(i)\\n\\n        for i in combined.keys():\\n            combined[i].sort()\\n        unique, ans = list(unique), []\\n        unique.sort()\\n\\n        for i in unique:\\n            ans += combined[i]\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        graph, visited, dist = {}, [], []\\n        n, mx = len(watchedVideos), float(\"inf\")\\n\\n        for i in range(n):\\n            graph[i] = [] \\n            visited.append(0)\\n            dist.append(mx)\\n\\n        for i in range(n):\\n            for neighbor in friends[i]:\\n                graph[i].append(neighbor)\\n                graph[neighbor].append(i)\\n\\n        queue, idx = [id], 0\\n        visited[id], dist[id], total = 1, 0, []\\n        while idx < len(queue):\\n            src = queue[idx]\\n            idx += 1\\n            for neighbor in graph[src]:\\n                if not visited[neighbor]:\\n                    visited[neighbor] = 1\\n                    queue.append(neighbor)\\n                    dist[neighbor] = dist[src] + 1\\n\\n        for i in range(n):\\n            if dist[i] == level:\\n                total += watchedVideos[i]\\n\\n        freq, unique, combined = Counter(total), set(), {}\\n        for i in freq.keys():\\n            unique.add(freq[i])\\n            if combined.get(freq[i]) == None:\\n                combined[freq[i]] = [i]\\n            else:\\n                combined[freq[i]].append(i)\\n\\n        for i in combined.keys():\\n            combined[i].sort()\\n        unique, ans = list(unique), []\\n        unique.sort()\\n\\n        for i in unique:\\n            ans += combined[i]\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576920,
                "title": "bfs-hashmap",
                "content": "# Approach\\nFind level level of friends by BFS.\\nThen count the occurences of each movie.\\nSort by frequency then name.\\n\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, w: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        S = {id}\\n        q = [id]\\n\\n        for _ in range(level):\\n            p = q\\n            q = []\\n\\n            for u in p:\\n                for v in friends[u]:\\n                    if v not in S:\\n                        q.append(v)\\n                        S.add(v)\\n        \\n        L = []\\n\\n        for i in q:\\n            L.extend(w[i])\\n        \\n        D = Counter(L)\\n        return [x[0] for x in sorted(D.items(), key = itemgetter(1, 0))]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, w: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        S = {id}\\n        q = [id]\\n\\n        for _ in range(level):\\n            p = q\\n            q = []\\n\\n            for u in p:\\n                for v in friends[u]:\\n                    if v not in S:\\n                        q.append(v)\\n                        S.add(v)\\n        \\n        L = []\\n\\n        for i in q:\\n            L.extend(w[i])\\n        \\n        D = Counter(L)\\n        return [x[0] for x in sorted(D.items(), key = itemgetter(1, 0))]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566352,
                "title": "simple-to-understand-python-code-with-comments-and-explanation",
                "content": "\\n# Code\\n```python\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        #Here is what I think:\\n        #    - Find all friends in level k\\n        #    - Count the frequency of each video\\n        #    - Sort the videos based on freq\\n        # First let us build k_level friends\\n        # Level 0 friends include myself\\n        level_friends = [id]\\n        visited = set()\\n        visited.add(id)\\n        for i in range(level):\\n            next_level_friends = []\\n            for friend in level_friends:\\n                # We are doing a BFS to find the next level of friends\\n                for ff in friends[friend]:\\n                    # To eliminate duplicate processing\\n                    if ff not in visited:\\n                        visited.add(ff)\\n                        next_level_friends.append(ff)\\n            level_friends = next_level_friends\\n        # Now we should find the freq of each video\\n        freq = {}\\n        for person in level_friends:\\n            # We increment the video freq count for each video watched\\n            for video in watchedVideos[person]:\\n                freq[video] = freq.get(video, 0)+1\\n        # Now lets make a list of videos and their freq. Since we want to sort based on freq, put freq first\\n        ar = []\\n        for k,v in freq.items():\\n            ar.append([v,k])\\n        ar.sort()\\n        ans = []\\n        for cnt, video in ar:\\n            ans.append(video)\\n        return ans\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        #Here is what I think:\\n        #    - Find all friends in level k\\n        #    - Count the frequency of each video\\n        #    - Sort the videos based on freq\\n        # First let us build k_level friends\\n        # Level 0 friends include myself\\n        level_friends = [id]\\n        visited = set()\\n        visited.add(id)\\n        for i in range(level):\\n            next_level_friends = []\\n            for friend in level_friends:\\n                # We are doing a BFS to find the next level of friends\\n                for ff in friends[friend]:\\n                    # To eliminate duplicate processing\\n                    if ff not in visited:\\n                        visited.add(ff)\\n                        next_level_friends.append(ff)\\n            level_friends = next_level_friends\\n        # Now we should find the freq of each video\\n        freq = {}\\n        for person in level_friends:\\n            # We increment the video freq count for each video watched\\n            for video in watchedVideos[person]:\\n                freq[video] = freq.get(video, 0)+1\\n        # Now lets make a list of videos and their freq. Since we want to sort based on freq, put freq first\\n        ar = []\\n        for k,v in freq.items():\\n            ar.append([v,k])\\n        ar.sort()\\n        ans = []\\n        for cnt, video in ar:\\n            ans.append(video)\\n        return ans\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560288,
                "title": "fully-explained-easiest-solution-c-bfs-queue",
                "content": "# Intuition\\nwe can find the level of all nodes with respect to the id node and store the videos watched by them and then we can sort them and report the answer\\n\\n# Approach\\nfor finding the level we can use simple bfs we will use a queue to find level of all nodes and write a check condition if the node is equal to the level given in question then we will store all the vidoes in the map and increase their frequency \\n\\n# Complexity\\n- Time complexity:\\nO(V+E) for the bfs traversal and for sorting it will be O(VlogV)  \\n\\n- Space complexity: \\nO(V+E) for the adjcency list \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wat, vector<vector<int>>& f, int id, int l) {\\n        int n=f.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<f[i].size(); j++){\\n                int x=i;\\n                int y=f[i][j];\\n                adj[x].push_back(y);\\n                adj[y].push_back(x);\\n            }\\n        }\\n        queue<int> q;\\n        vector<int> vis(n,0);\\n        vector<int> lvl(n,0);\\n        q.push(id);\\n        lvl[id]=0;\\n        vis[id]=1;\\n        map<string,int> m;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto child:adj[node]){\\n                if(!vis[child]){\\n                    cout<<child<<\" \";\\n                    lvl[child]=lvl[node]+1;\\n                    vis[child]=1;\\n                    q.push(child);\\n                }\\n            }\\n            cout<<endl;\\n            // checking the node \\n            if(lvl[node]==l){\\n        \\n                for(int i=0; i<wat[node].size(); i++){\\n                 m[wat[node][i]]++;\\n                }\\n            }\\n            \\n        }\\n        // cout<<m.size()<<endl;\\n        vector<pair<int,string>> v;\\n        for(auto it:m){\\n            v.push_back({it.second,it.first});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<string> ans;\\n        for(int i=0; i<v.size(); i++){\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wat, vector<vector<int>>& f, int id, int l) {\\n        int n=f.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<f[i].size(); j++){\\n                int x=i;\\n                int y=f[i][j];\\n                adj[x].push_back(y);\\n                adj[y].push_back(x);\\n            }\\n        }\\n        queue<int> q;\\n        vector<int> vis(n,0);\\n        vector<int> lvl(n,0);\\n        q.push(id);\\n        lvl[id]=0;\\n        vis[id]=1;\\n        map<string,int> m;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto child:adj[node]){\\n                if(!vis[child]){\\n                    cout<<child<<\" \";\\n                    lvl[child]=lvl[node]+1;\\n                    vis[child]=1;\\n                    q.push(child);\\n                }\\n            }\\n            cout<<endl;\\n            // checking the node \\n            if(lvl[node]==l){\\n        \\n                for(int i=0; i<wat[node].size(); i++){\\n                 m[wat[node][i]]++;\\n                }\\n            }\\n            \\n        }\\n        // cout<<m.size()<<endl;\\n        vector<pair<int,string>> v;\\n        for(auto it:m){\\n            v.push_back({it.second,it.first});\\n        }\\n        sort(v.begin(),v.end());\\n        vector<string> ans;\\n        for(int i=0; i<v.size(); i++){\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3551536,
                "title": "c-simple-bfs-traversal-bfs-sorting-easy-understanding",
                "content": "### C++ Simple BFS Traversal || BFS - Sorting || Easy Understanding \\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            adj[i].insert(adj[i].end(),friends[i].begin(),friends[i].end());\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({0,id});\\n        map<string,int> mp;\\n        vector<int> vis(n,false);\\n        vis[id]=true;\\n        while(q.size()!=0){\\n            int node = q.front().second;\\n            int wt = q.front().first;\\n            q.pop();\\n            \\n            if(wt==level){\\n                for(auto it:watchedVideos[node]) mp[it]++;\\n            }\\n            \\n            for(auto it:adj[node]){\\n                if(!vis[it]&&wt+1<=level){\\n                    vis[it]=true;\\n                    q.push({wt+1,it});\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int,string>> temp;\\n        for(auto it:mp) temp.push_back({it.second,it.first});\\n        sort(temp.begin(),temp.end());\\n        vector<string> ans;\\n        for(auto it:temp) ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            adj[i].insert(adj[i].end(),friends[i].begin(),friends[i].end());\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({0,id});\\n        map<string,int> mp;\\n        vector<int> vis(n,false);\\n        vis[id]=true;\\n        while(q.size()!=0){\\n            int node = q.front().second;\\n            int wt = q.front().first;\\n            q.pop();\\n            \\n            if(wt==level){\\n                for(auto it:watchedVideos[node]) mp[it]++;\\n            }\\n            \\n            for(auto it:adj[node]){\\n                if(!vis[it]&&wt+1<=level){\\n                    vis[it]=true;\\n                    q.push({wt+1,it});\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int,string>> temp;\\n        for(auto it:mp) temp.push_back({it.second,it.first});\\n        sort(temp.begin(),temp.end());\\n        vector<string> ans;\\n        for(auto it:temp) ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453587,
                "title": "bfs-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<string> ans;\\n        vector<int> adj[friends.size()];\\n        vector<int> vis(friends.size(),0);\\n        for(int x=0; x<friends.size(); x++)\\n        {\\n            for(int y=0; y<friends[x].size(); y++)\\n            {\\n                adj[x].push_back(friends[x][y]);\\n                adj[friends[x][y]].push_back(x);\\n            }\\n        }\\n        queue<int> q;\\n        q.push(id);\\n        vis[id]=1;\\n        int l=0;\\n        while(!q.empty())\\n        {\\n            int qs=q.size();\\n            map<string,int> m;\\n            l++;\\n            for(int x=0; x<qs; x++)\\n            {\\n                int node=q.front();\\n                q.pop();\\n                for(auto it: adj[node])\\n                {\\n                    if(!vis[it]) \\n                    {\\n                        vis[it]=1;\\n                        q.push(it);\\n                        for(auto i: watchedVideos[it])\\n                        {\\n                            m[i]++;\\n                        }\\n                    }\\n                }\\n            }\\n            if(l==level)\\n            {\\n                vector<pair<int,string>> v;\\n                for(auto it: m)\\n                {\\n                    v.push_back({it.second,it.first});\\n                }\\n                sort(v.begin(),v.end());\\n                for(auto it: v) ans.push_back(it.second);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<string> ans;\\n        vector<int> adj[friends.size()];\\n        vector<int> vis(friends.size(),0);\\n        for(int x=0; x<friends.size(); x++)\\n        {\\n            for(int y=0; y<friends[x].size(); y++)\\n            {\\n                adj[x].push_back(friends[x][y]);\\n                adj[friends[x][y]].push_back(x);\\n            }\\n        }\\n        queue<int> q;\\n        q.push(id);\\n        vis[id]=1;\\n        int l=0;\\n        while(!q.empty())\\n        {\\n            int qs=q.size();\\n            map<string,int> m;\\n            l++;\\n            for(int x=0; x<qs; x++)\\n            {\\n                int node=q.front();\\n                q.pop();\\n                for(auto it: adj[node])\\n                {\\n                    if(!vis[it]) \\n                    {\\n                        vis[it]=1;\\n                        q.push(it);\\n                        for(auto i: watchedVideos[it])\\n                        {\\n                            m[i]++;\\n                        }\\n                    }\\n                }\\n            }\\n            if(l==level)\\n            {\\n                vector<pair<int,string>> v;\\n                for(auto it: m)\\n                {\\n                    v.push_back({it.second,it.first});\\n                }\\n                sort(v.begin(),v.end());\\n                for(auto it: v) ans.push_back(it.second);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452146,
                "title": "go-bfs-beat-100",
                "content": "\\n# Code\\n```\\nfunc watchedVideosByFriends(watchedVideos [][]string, friends [][]int, id int, level int) []string {\\n    n := len(friends)\\n    visited := make([]int, n)\\n    freq := make(map[string]int)\\n    queue := make([]int, 0, 10)\\n    queue = append(queue, friends[id]...)\\n    visited[id] = 1\\n    for _, f := range friends[id] {\\n        visited[f] = 1\\n    }\\n    for len(queue) > 0 && level > 0 {\\n        level--\\n        for i := len(queue)-1; i >= 0; i-- {\\n            f := queue[0]\\n            queue = queue[1:]\\n            if level == 0 {\\n                for _, v := range watchedVideos[f] {\\n                    freq[v]++\\n                }\\n            }\\n            for _, fof := range friends[f] {\\n                if visited[fof] == 0 {\\n                    queue = append(queue, fof)\\n                    visited[fof] = 1\\n                }\\n            } \\n        }  \\n    }\\n    ans := make([]string, 0, len(freq))\\n    for k, _ := range freq {\\n        ans = append(ans, k)\\n    }\\n    sort.Slice(ans, func(i, j int) bool {\\n        if freq[ans[i]] == freq[ans[j]] {\\n            return ans[i] < ans[j]\\n        }\\n        return freq[ans[i]] < freq[ans[j]]\\n    })\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc watchedVideosByFriends(watchedVideos [][]string, friends [][]int, id int, level int) []string {\\n    n := len(friends)\\n    visited := make([]int, n)\\n    freq := make(map[string]int)\\n    queue := make([]int, 0, 10)\\n    queue = append(queue, friends[id]...)\\n    visited[id] = 1\\n    for _, f := range friends[id] {\\n        visited[f] = 1\\n    }\\n    for len(queue) > 0 && level > 0 {\\n        level--\\n        for i := len(queue)-1; i >= 0; i-- {\\n            f := queue[0]\\n            queue = queue[1:]\\n            if level == 0 {\\n                for _, v := range watchedVideos[f] {\\n                    freq[v]++\\n                }\\n            }\\n            for _, fof := range friends[f] {\\n                if visited[fof] == 0 {\\n                    queue = append(queue, fof)\\n                    visited[fof] = 1\\n                }\\n            } \\n        }  \\n    }\\n    ans := make([]string, 0, len(freq))\\n    for k, _ := range freq {\\n        ans = append(ans, k)\\n    }\\n    sort.Slice(ans, func(i, j int) bool {\\n        if freq[ans[i]] == freq[ans[j]] {\\n            return ans[i] < ans[j]\\n        }\\n        return freq[ans[i]] < freq[ans[j]]\\n    })\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443954,
                "title": "python-3-with-bfs",
                "content": "# Complexity\\n- Time complexity: O(V + E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V + E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\n        graph = defaultdict(list)\\n        for i, f in enumerate(friends):\\n            graph[i] = f\\n\\n        levels = {i: None for i in range(len(graph))}\\n        levels[id] = 0\\n\\n        queue = deque([id])\\n        k = 0\\n\\n        while queue and k <= level:\\n            curr_node = queue.popleft()\\n\\n            for next_node in graph[curr_node]:\\n                if levels[next_node] is None:\\n                    k = levels[curr_node] + 1\\n                    levels[next_node] = levels[curr_node] + 1\\n                    queue.append(next_node)\\n\\n        levels = [k for k in levels if levels[k] == level]\\n\\n        videos = defaultdict(int)\\n        for i in levels:\\n            for video in watchedVideos[i]:\\n                videos[video] += 1\\n\\n        return sorted(videos, key=lambda x: (videos[x], x))\\n\\n            \\n        \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\n        graph = defaultdict(list)\\n        for i, f in enumerate(friends):\\n            graph[i] = f\\n\\n        levels = {i: None for i in range(len(graph))}\\n        levels[id] = 0\\n\\n        queue = deque([id])\\n        k = 0\\n\\n        while queue and k <= level:\\n            curr_node = queue.popleft()\\n\\n            for next_node in graph[curr_node]:\\n                if levels[next_node] is None:\\n                    k = levels[curr_node] + 1\\n                    levels[next_node] = levels[curr_node] + 1\\n                    queue.append(next_node)\\n\\n        levels = [k for k in levels if levels[k] == level]\\n\\n        videos = defaultdict(int)\\n        for i in levels:\\n            for video in watchedVideos[i]:\\n                videos[video] += 1\\n\\n        return sorted(videos, key=lambda x: (videos[x], x))\\n\\n            \\n        \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384939,
                "title": "pure-c-bfs-set",
                "content": "# Intuition\\n1. create a list about target level friends\\n2. acording to friends list create a set of vedios with it freq\\n3. return vedios set\\n\\n# Approach\\n1. use BFS to traverse friends tree, id as root.\\n2. put vedios into a prepared array and sort.\\n3. return\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#define SIZE 100\\n\\nint queue[SIZE];\\nint rear = 0;\\nint front = 0;\\n\\ntypedef struct vlist {\\n    char name[9];\\n    int freq;\\n} vlist_t;\\n\\nint isEmpty() {\\n    return rear == front ? 1 : 0;\\n}\\n\\nint isFull() {\\n    int ret;\\n    if (front == 0) {\\n        if (rear == (SIZE - 1))\\n            ret = 1;\\n        else\\n            ret = 0;\\n    } else {\\n        if (rear == (front - 1))\\n            ret = 1;\\n        else \\n            ret = 0;\\n    }\\n    return  ret;\\n}\\n\\nint dequeue() {\\n    int ret;\\n    if (isEmpty()) {\\n        printf(\"Queue is Empty!!\\\\n\");\\n        return -1;\\n    } else {\\n        ret = queue[front++];\\n        front %= SIZE;\\n        return ret;\\n    }\\n}\\n\\nvoid enqueue(int input) {\\n    if (isFull()) {\\n        printf(\"Queue is Full, Something Wrong!!\\\\n\");\\n    } else {\\n        queue[rear++] = input;\\n        rear %= SIZE;\\n    }\\n}\\n\\nint size() {\\n    int ret = rear >= front ? rear - front : SIZE - front + rear;\\n    return ret;\\n}\\n\\nint cmpfunc (const void * a1, const void * a2) {\\n    vlist_t *x = (vlist_t *)a1;\\n    vlist_t *y = (vlist_t *)a2;\\n    if (x->freq != y->freq) {\\n        return x->freq - y->freq;\\n    } else {\\n        int i = 0;\\n        while (x->name[i] == y->name[i]) {\\n            ++i;\\n        }\\n        return (int)(x->name[i] - y->name[i]);\\n    }\\n}\\n\\nchar ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }\\n            }\\n        }\\n        level--;\\n    }\\n    free(visited);\\n    vcount = 0;\\n    while (!isEmpty()) {\\n        int id = dequeue();\\n        char vname[9];\\n        // printf(\"process id:%d\\\\n\", id);\\n        for (int i = 0; i < watchedVideosColSize[id]; ++i) {\\n            strcpy(vname, watchedVideos[id][i]);\\n            int checkin = 1;\\n            for (int j = 0; j < vcount; ++j) {\\n                if (!strcmp(vname, vlist[j].name)) {\\n                    checkin = 0;\\n                    vlist[j].freq += 1;\\n                    break;\\n                }\\n            }\\n            if (checkin) {\\n                strcpy(vlist[vcount].name, vname);\\n                vlist[vcount].freq = 1;\\n                vcount++;\\n            }\\n        }\\n    }\\n    qsort(vlist, vcount, sizeof(vlist_t), cmpfunc);\\n\\n    *returnSize = vcount;\\n    ret = malloc(sizeof(char*) * (vcount));\\n    for (int i = 0; i < vcount; ++i) {\\n        int strsize = strlen(vlist[i].name)+1;\\n        ret[i] = malloc(sizeof(char) * strsize);\\n        strcpy(ret[i], vlist[i].name);\\n    }\\n    free(vlist);\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#define SIZE 100\\n\\nint queue[SIZE];\\nint rear = 0;\\nint front = 0;\\n\\ntypedef struct vlist {\\n    char name[9];\\n    int freq;\\n} vlist_t;\\n\\nint isEmpty() {\\n    return rear == front ? 1 : 0;\\n}\\n\\nint isFull() {\\n    int ret;\\n    if (front == 0) {\\n        if (rear == (SIZE - 1))\\n            ret = 1;\\n        else\\n            ret = 0;\\n    } else {\\n        if (rear == (front - 1))\\n            ret = 1;\\n        else \\n            ret = 0;\\n    }\\n    return  ret;\\n}\\n\\nint dequeue() {\\n    int ret;\\n    if (isEmpty()) {\\n        printf(\"Queue is Empty!!\\\\n\");\\n        return -1;\\n    } else {\\n        ret = queue[front++];\\n        front %= SIZE;\\n        return ret;\\n    }\\n}\\n\\nvoid enqueue(int input) {\\n    if (isFull()) {\\n        printf(\"Queue is Full, Something Wrong!!\\\\n\");\\n    } else {\\n        queue[rear++] = input;\\n        rear %= SIZE;\\n    }\\n}\\n\\nint size() {\\n    int ret = rear >= front ? rear - front : SIZE - front + rear;\\n    return ret;\\n}\\n\\nint cmpfunc (const void * a1, const void * a2) {\\n    vlist_t *x = (vlist_t *)a1;\\n    vlist_t *y = (vlist_t *)a2;\\n    if (x->freq != y->freq) {\\n        return x->freq - y->freq;\\n    } else {\\n        int i = 0;\\n        while (x->name[i] == y->name[i]) {\\n            ++i;\\n        }\\n        return (int)(x->name[i] - y->name[i]);\\n    }\\n}\\n\\nchar ** watchedVideosByFriends(char *** watchedVideos, int watchedVideosSize, int* watchedVideosColSize, int** friends, int friendsSize, int* friendsColSize, int id, int level, int* returnSize){\\n    char **ret;\\n    int target, fid, vcount;\\n    int *visited;\\n    vlist_t *vlist;\\n    \\n    visited = calloc(sizeof(int), friendsSize);\\n    vlist = calloc(sizeof(vlist_t), friendsSize * 100);\\n    enqueue(id);\\n    visited[id] = 1;\\n\\n    // push target level to queue\\n    while (level > 0 && !isEmpty()) {\\n        int end = size();\\n        for (int i = 0; i < end; ++i) {\\n            target = dequeue();\\n            for (int j = 0; j < friendsColSize[target]; ++j) {\\n                fid = friends[target][j];\\n                if (!visited[fid]) {\\n                    visited[fid] = 1;\\n                    enqueue(fid);\\n                }\\n            }\\n        }\\n        level--;\\n    }\\n    free(visited);\\n    vcount = 0;\\n    while (!isEmpty()) {\\n        int id = dequeue();\\n        char vname[9];\\n        // printf(\"process id:%d\\\\n\", id);\\n        for (int i = 0; i < watchedVideosColSize[id]; ++i) {\\n            strcpy(vname, watchedVideos[id][i]);\\n            int checkin = 1;\\n            for (int j = 0; j < vcount; ++j) {\\n                if (!strcmp(vname, vlist[j].name)) {\\n                    checkin = 0;\\n                    vlist[j].freq += 1;\\n                    break;\\n                }\\n            }\\n            if (checkin) {\\n                strcpy(vlist[vcount].name, vname);\\n                vlist[vcount].freq = 1;\\n                vcount++;\\n            }\\n        }\\n    }\\n    qsort(vlist, vcount, sizeof(vlist_t), cmpfunc);\\n\\n    *returnSize = vcount;\\n    ret = malloc(sizeof(char*) * (vcount));\\n    for (int i = 0; i < vcount; ++i) {\\n        int strsize = strlen(vlist[i].name)+1;\\n        ret[i] = malloc(sizeof(char) * strsize);\\n        strcpy(ret[i], vlist[i].name);\\n    }\\n    free(vlist);\\n    return ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3360354,
                "title": "get-watched-videos-by-your-friends",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class pair{\\n        int vertex;\\n        int l;\\n        pair(int vertex,int l){\\n            this.vertex=vertex;\\n            this.l=l;\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < watchedVideos.size(); i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i< friends.length;i++) {\\n            for (int j = 0; j < friends[i].length; j++) {\\n                adj.get(i).add(friends[i][j]);\\n            }\\n        }\\n\\n        ArrayList<String>ans=new ArrayList<>();\\n        HashSet<Integer>hs=new HashSet<>();\\n        Queue<pair>q=new ArrayDeque<>();\\n        Map<String, Integer> videoFreq = new HashMap<>();\\n        q.add(new pair(id,0));\\n        while(q.size()>0){\\n            pair p=q.poll();\\n            if(hs.contains(p.vertex)){\\n                continue;\\n            }\\n            hs.add(p.vertex);\\n            if(p.l==level){\\n                for(String s:watchedVideos.get(p.vertex)){\\n                    videoFreq.put(s, videoFreq.getOrDefault(s,0)+1);\\n                }\\n            }\\n            else{\\n                for(int i: adj.get(p.vertex)){\\n                    if(!hs.contains(i)){\\n                        q.add(new pair(i,p.l+1));\\n                    }\\n                }\\n            }\\n        }\\n        List<Map.Entry<String, Integer>> videoFreqList= new ArrayList<>(videoFreq.entrySet()); // Convert map to a list\\n        Collections.sort(videoFreqList, (e1, e2)-> e1.getValue()==e2.getValue()?e1.getKey().compareTo(e2.getKey()):e1.getValue()-e2.getValue()); // Sort based on frequency i.e. value if both are same then based on the movie i.e. key\\n        for(Map.Entry<String, Integer> e: videoFreqList){\\n            ans.add(e.getKey()); // Store all the movies in the asn list\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class pair{\\n        int vertex;\\n        int l;\\n        pair(int vertex,int l){\\n            this.vertex=vertex;\\n            this.l=l;\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < watchedVideos.size(); i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i< friends.length;i++) {\\n            for (int j = 0; j < friends[i].length; j++) {\\n                adj.get(i).add(friends[i][j]);\\n            }\\n        }\\n\\n        ArrayList<String>ans=new ArrayList<>();\\n        HashSet<Integer>hs=new HashSet<>();\\n        Queue<pair>q=new ArrayDeque<>();\\n        Map<String, Integer> videoFreq = new HashMap<>();\\n        q.add(new pair(id,0));\\n        while(q.size()>0){\\n            pair p=q.poll();\\n            if(hs.contains(p.vertex)){\\n                continue;\\n            }\\n            hs.add(p.vertex);\\n            if(p.l==level){\\n                for(String s:watchedVideos.get(p.vertex)){\\n                    videoFreq.put(s, videoFreq.getOrDefault(s,0)+1);\\n                }\\n            }\\n            else{\\n                for(int i: adj.get(p.vertex)){\\n                    if(!hs.contains(i)){\\n                        q.add(new pair(i,p.l+1));\\n                    }\\n                }\\n            }\\n        }\\n        List<Map.Entry<String, Integer>> videoFreqList= new ArrayList<>(videoFreq.entrySet()); // Convert map to a list\\n        Collections.sort(videoFreqList, (e1, e2)-> e1.getValue()==e2.getValue()?e1.getKey().compareTo(e2.getKey()):e1.getValue()-e2.getValue()); // Sort based on frequency i.e. value if both are same then based on the movie i.e. key\\n        for(Map.Entry<String, Integer> e: videoFreqList){\\n            ans.add(e.getKey()); // Store all the movies in the asn list\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348860,
                "title": "c-dijkstra-bfs-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int start,unordered_map<int,vector<int>>&ourmap,vector<int>&distance,int n){\\n        \\n        priority_queue<pair<int,int>> minheap;\\n        minheap.push({0,start});\\n        while(minheap.size()!=0){\\n            \\n            pair<int,int> front=minheap.top();\\n            minheap.pop();\\n            int node=front.second;\\n            int d=front.first;\\n            vector<int> temp=ourmap[node];\\n            for(int i=0;i<temp.size();i++){\\n                if(d+1<distance[temp[i]]){\\n                    distance[temp[i]]=d+1;\\n                    minheap.push({distance[temp[i]],temp[i]});\\n                }\\n            }\\n        }\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedvideos, vector<vector<int>>& friends, int id, int k) {\\n        \\n        unordered_map<int,vector<int>> ourmap;\\n        for(int i=0;i<friends.size();i++){ \\n            int a=i;\\n            for(int j=0;j<friends[i].size();j++){\\n                ourmap[a].push_back(friends[i][j]);\\n            }\\n        }\\n        unordered_map<int,vector<string>> mp;\\n        for(int i=0;i<watchedvideos.size();i++){\\n            vector<string> temp=watchedvideos[i];\\n            mp[i]=temp;\\n        }\\n        int n=friends.size();\\n        vector<int> distance(n,INT_MAX);\\n        distance[id]=0;\\n        helper(id,ourmap,distance,n);\\n        unordered_map<string,int> hp;\\n        for(int i=0;i<n;i++){\\n            if(distance[i]==k){\\n                vector<string> temp=mp[i];\\n                for(int j=0;j<temp.size();j++){\\n                    hp[temp[j]]++;\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        vector<pair<int,string>> temp;\\n        auto it=hp.begin();\\n        while(it!=hp.end()){\\n            \\n            int freq=it->second;\\n            string t=it->first;\\n            temp.push_back({freq,t});\\n            it++;\\n        }\\n        sort(temp.begin(),temp.end());\\n        for(int i=0;i<temp.size();i++){\\n            \\n            ans.push_back(temp[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void helper(int start,unordered_map<int,vector<int>>&ourmap,vector<int>&distance,int n){\\n        \\n        priority_queue<pair<int,int>> minheap;\\n        minheap.push({0,start}",
                "codeTag": "Java"
            },
            {
                "id": 3339717,
                "title": "bfs-hashmap-hashset-some-mind-submission-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class pair{\\n        int vertex;\\n        int l;\\n        pair(int vertex,int l){\\n            this.vertex=vertex;\\n            this.l=l;\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < watchedVideos.size(); i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i< friends.length;i++) {\\n            for (int j = 0; j < friends[i].length; j++) {\\n                adj.get(i).add(friends[i][j]);\\n            }\\n        }\\n\\n        ArrayList<String>ans=new ArrayList<>();\\n        HashSet<Integer>hs=new HashSet<>();\\n        Queue<pair>q=new ArrayDeque<>();\\n        Map<String, Integer> videoFreq = new HashMap<>();\\n        q.add(new pair(id,0));\\n        while(q.size()>0){\\n            pair p=q.poll();\\n            if(hs.contains(p.vertex)){\\n                continue;\\n            }\\n            hs.add(p.vertex);\\n            if(p.l==level){\\n                for(String s:watchedVideos.get(p.vertex)){\\n                    videoFreq.put(s, videoFreq.getOrDefault(s,0)+1);\\n                }\\n            }\\n            else{\\n                for(int i: adj.get(p.vertex)){\\n                    if(!hs.contains(i)){\\n                        q.add(new pair(i,p.l+1));\\n                    }\\n                }\\n            }\\n        }\\n        List<Map.Entry<String, Integer>> videoFreqList= new ArrayList<>(videoFreq.entrySet()); // Convert map to a list\\n        Collections.sort(videoFreqList, (e1, e2)-> e1.getValue()==e2.getValue()?e1.getKey().compareTo(e2.getKey()):e1.getValue()-e2.getValue()); // Sort based on frequency i.e. value if both are same then based on the movie i.e. key\\n        for(Map.Entry<String, Integer> e: videoFreqList){\\n            ans.add(e.getKey()); // Store all the movies in the asn list\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class pair{\\n        int vertex;\\n        int l;\\n        pair(int vertex,int l){\\n            this.vertex=vertex;\\n            this.l=l;\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < watchedVideos.size(); i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i< friends.length;i++) {\\n            for (int j = 0; j < friends[i].length; j++) {\\n                adj.get(i).add(friends[i][j]);\\n            }\\n        }\\n\\n        ArrayList<String>ans=new ArrayList<>();\\n        HashSet<Integer>hs=new HashSet<>();\\n        Queue<pair>q=new ArrayDeque<>();\\n        Map<String, Integer> videoFreq = new HashMap<>();\\n        q.add(new pair(id,0));\\n        while(q.size()>0){\\n            pair p=q.poll();\\n            if(hs.contains(p.vertex)){\\n                continue;\\n            }\\n            hs.add(p.vertex);\\n            if(p.l==level){\\n                for(String s:watchedVideos.get(p.vertex)){\\n                    videoFreq.put(s, videoFreq.getOrDefault(s,0)+1);\\n                }\\n            }\\n            else{\\n                for(int i: adj.get(p.vertex)){\\n                    if(!hs.contains(i)){\\n                        q.add(new pair(i,p.l+1));\\n                    }\\n                }\\n            }\\n        }\\n        List<Map.Entry<String, Integer>> videoFreqList= new ArrayList<>(videoFreq.entrySet()); // Convert map to a list\\n        Collections.sort(videoFreqList, (e1, e2)-> e1.getValue()==e2.getValue()?e1.getKey().compareTo(e2.getKey()):e1.getValue()-e2.getValue()); // Sort based on frequency i.e. value if both are same then based on the movie i.e. key\\n        for(Map.Entry<String, Integer> e: videoFreqList){\\n            ans.add(e.getKey()); // Store all the movies in the asn list\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333752,
                "title": "c-simple-bfs-self-explanatory-code",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<string, int> &p1, pair<string, int> &p2)\\n    {\\n        if(p1.second == p2.second)return p1.first < p2.first;\\n        return p1.second < p2.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        map<string, int> ans;\\n        vector<bool> IsVisited(watchedVideos.size(), false);\\n        IsVisited[id] = true;\\n        priority_queue<pair<int,int> , vector<pair<int,int> >, greater<pair<int,int> >> pq;\\n        pq.push({id, 0});\\n        while(!pq.empty())\\n        {\\n            int a = pq.top().first;\\n            int lvl = pq.top().second;\\n            pq.pop();\\n            if(lvl != level)\\n            {\\n                for(auto &x : friends[a])\\n                {\\n                    if(!IsVisited[x])\\n                     {\\n                        IsVisited[x] = true;\\n                        pq.push({x, lvl+1});\\n                        if(lvl+1 == level)for(auto &y : watchedVideos[x])ans[y]++;\\n                     }\\n                }\\n            }\\n        }\\n        vector<pair<string, int>> sol;\\n        for(auto &x : ans)sol.push_back(x);\\n        sort(sol.begin(),sol.end(),comp);\\n        vector<string> vdo;\\n        for(auto &x : sol)vdo.push_back(x.first);\\n        return vdo;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<string, int> &p1, pair<string, int> &p2)\\n    {\\n        if(p1.second == p2.second)return p1.first < p2.first;\\n        return p1.second < p2.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        map<string, int> ans;\\n        vector<bool> IsVisited(watchedVideos.size(), false);\\n        IsVisited[id] = true;\\n        priority_queue<pair<int,int> , vector<pair<int,int> >, greater<pair<int,int> >> pq;\\n        pq.push({id, 0});\\n        while(!pq.empty())\\n        {\\n            int a = pq.top().first;\\n            int lvl = pq.top().second;\\n            pq.pop();\\n            if(lvl != level)\\n            {\\n                for(auto &x : friends[a])\\n                {\\n                    if(!IsVisited[x])\\n                     {\\n                        IsVisited[x] = true;\\n                        pq.push({x, lvl+1});\\n                        if(lvl+1 == level)for(auto &y : watchedVideos[x])ans[y]++;\\n                     }\\n                }\\n            }\\n        }\\n        vector<pair<string, int>> sol;\\n        for(auto &x : ans)sol.push_back(x);\\n        sort(sol.begin(),sol.end(),comp);\\n        vector<string> vdo;\\n        for(auto &x : sol)vdo.push_back(x.first);\\n        return vdo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333553,
                "title": "c-bfs-sort",
                "content": "C++ BFS \\n\\n```\\nclass Solution {\\npublic:\\n  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        queue<int> pq;\\n        int n = friends.size();\\n        vector<int> vis(n, 0);\\n        vis[id]=1;\\n        int st = id;\\n        pq.push(st);\\n        int sz = 1;\\n        int lv = 1;\\n\\n        map<string, int> mp;\\n        vector<string> ans;\\n\\n        while (!pq.empty()) {\\n\\n            for (int i = 0; i < sz; ++i) {\\n                auto x = pq.front();\\n                pq.pop();\\n              \\n\\n                for (auto el : friends[x]) {\\n                    if (!vis[el]) {\\n                        vis[el] = true;\\n                        if (lv == level) {\\n                          \\n                            for(auto c:watchedVideos[el]){\\n                                mp[c]++;                                \\n                            }\\n                        }\\n                        pq.push(el);\\n                    }\\n                }\\n            }\\n\\n            if (lv == level) {\\n                vector<pair<int, string>> vec;\\n                for (auto el : mp) {\\n                    vec.push_back({el.second, el.first});\\n                }\\n                   \\n                sort(vec.begin(), vec.end());\\n            \\n                for (auto el : vec) {\\n                    ans.push_back(el.second);\\n                }\\n\\n                break;\\n            }\\n\\n            lv++;\\n            sz = pq.size();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        queue<int> pq;\\n        int n = friends.size();\\n        vector<int> vis(n, 0);\\n        vis[id]=1;\\n        int st = id;\\n        pq.push(st);\\n        int sz = 1;\\n        int lv = 1;\\n\\n        map<string, int> mp;\\n        vector<string> ans;\\n\\n        while (!pq.empty()) {\\n\\n            for (int i = 0; i < sz; ++i) {\\n                auto x = pq.front();\\n                pq.pop();\\n              \\n\\n                for (auto el : friends[x]) {\\n                    if (!vis[el]) {\\n                        vis[el] = true;\\n                        if (lv == level) {\\n                          \\n                            for(auto c:watchedVideos[el]){\\n                                mp[c]++;                                \\n                            }\\n                        }\\n                        pq.push(el);\\n                    }\\n                }\\n            }\\n\\n            if (lv == level) {\\n                vector<pair<int, string>> vec;\\n                for (auto el : mp) {\\n                    vec.push_back({el.second, el.first});\\n                }\\n                   \\n                sort(vec.begin(), vec.end());\\n            \\n                for (auto el : vec) {\\n                    ans.push_back(el.second);\\n                }\\n\\n                break;\\n            }\\n\\n            lv++;\\n            sz = pq.size();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332172,
                "title": "bfs-and-hash-table-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watch_v, vector<vector<int>>& friends, int id, int k) {\\n        queue<int> q;\\n        q.push(id);\\n        int s=1;\\n        vector<bool> visited(friends.size(),0);\\n        visited[id]=1;\\n        while(q.size() && k--){\\n            s=q.size();\\n            while(s--){\\n                int node=q.front();\\n                q.pop();\\n                for(auto& f: friends[node]){\\n                    if(visited[f]==0){\\n                        // cout<<f<<\" \";\\n                        visited[f]=1;\\n                        q.push(f);\\n                    }\\n                }\\n            }\\n            s=q.size();\\n        }\\n        vector<string> ans;\\n        map<int,set<string>> mp;\\n        map<string,int> mp1;\\n        while(q.size()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto& ele: watch_v[node]){\\n                mp1[ele]++;\\n                if(mp1[ele]-1) mp[mp1[ele]-1].erase(ele);\\n                mp[mp1[ele]].insert(ele);\\n            }\\n        }\\n        for(auto& ele: mp){\\n            for(auto i: ele.second){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watch_v, vector<vector<int>>& friends, int id, int k) {\\n        queue<int> q;\\n        q.push(id);\\n        int s=1;\\n        vector<bool> visited(friends.size(),0);\\n        visited[id]=1;\\n        while(q.size() && k--){\\n            s=q.size();\\n            while(s--){\\n                int node=q.front();\\n                q.pop();\\n                for(auto& f: friends[node]){\\n                    if(visited[f]==0){\\n                        // cout<<f<<\" \";\\n                        visited[f]=1;\\n                        q.push(f);\\n                    }\\n                }\\n            }\\n            s=q.size();\\n        }\\n        vector<string> ans;\\n        map<int,set<string>> mp;\\n        map<string,int> mp1;\\n        while(q.size()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto& ele: watch_v[node]){\\n                mp1[ele]++;\\n                if(mp1[ele]-1) mp[mp1[ele]-1].erase(ele);\\n                mp[mp1[ele]].insert(ele);\\n            }\\n        }\\n        for(auto& ele: mp){\\n            for(auto i: ele.second){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3312808,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou just find all friends level away from id running BFS and stop at level.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStandard BFS algo.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        def bfs(graph, id, level):\\n            q = deque([id])\\n            visited = set([id])\\n            cur_lev = 0\\n            while q:\\n                n_friends = len(q) # number of friends at this level\\n                if cur_lev == level: # once you reach level return all friends\\n                    return q\\n                for _ in range(n_friends):\\n                    curr = q.popleft()\\n                    for friend in graph[curr]:\\n                        if friend not in visited:\\n                            visited.add(friend)\\n                            q.append(friend)\\n                cur_lev += 1 \\n\\n        friends_at_level = bfs(friends, id, level)\\n        videos = itertools.chain.from_iterable([watchedVideos[curr] for curr in friends_at_level])\\n        videos = sorted(collections.Counter(videos).items(), key=lambda x:(x[1], x[0]))\\n        return [video for video, _ in videos]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        def bfs(graph, id, level):\\n            q = deque([id])\\n            visited = set([id])\\n            cur_lev = 0\\n            while q:\\n                n_friends = len(q) # number of friends at this level\\n                if cur_lev == level: # once you reach level return all friends\\n                    return q\\n                for _ in range(n_friends):\\n                    curr = q.popleft()\\n                    for friend in graph[curr]:\\n                        if friend not in visited:\\n                            visited.add(friend)\\n                            q.append(friend)\\n                cur_lev += 1 \\n\\n        friends_at_level = bfs(friends, id, level)\\n        videos = itertools.chain.from_iterable([watchedVideos[curr] for curr in friends_at_level])\\n        videos = sorted(collections.Counter(videos).items(), key=lambda x:(x[1], x[0]))\\n        return [video for video, _ in videos]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287020,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public IList<string> WatchedVideosByFriends(IList<IList<string>> watchedVideos, int[][] friends, int id, int level)\\n    {\\n        var dijkstra = new Dijkstra();\\n        var freq = new Dictionary<string, int>();\\n\\n        var levels = dijkstra.FindShortestDistance(friends, id);\\n\\n        for(int i = 0; i < levels.Length; i++)\\n        {\\n            if (levels[i] == level)\\n            {\\n                foreach(var video in watchedVideos[i])\\n                {\\n                    if (!freq.ContainsKey(video))\\n                        freq[video] = 0;\\n\\n                    freq[video]++;\\n                }\\n            }\\n        }\\n\\n        var res = freq.OrderBy(item => item, Comparer<KeyValuePair<string, int>>.Create((a, b) =>\\n        {\\n            if (a.Value == b.Value)\\n                return a.Key.CompareTo(b.Key);\\n            return a.Value.CompareTo(b.Value);\\n        })).ToDictionary(x => x.Key, y => y.Value);\\n\\n        return res.Keys.ToList();\\n    }\\n}\\n\\npublic class Dijkstra\\n{\\n    public int[] FindShortestDistance(int[][] edges, int node)\\n    {\\n        var n = edges.Length;\\n        var dist = new int[n];\\n        var visited = new bool[n];\\n        var pq = new PriorityQueue<int, int>();\\n\\n        for (int i = 0; i < n; i++)\\n            dist[i] = int.MaxValue;\\n\\n        dist[node] = 0;\\n        pq.Enqueue(node, 0);\\n\\n        while (pq.Count > 0)\\n        {\\n            var temp = pq.Dequeue();\\n            if (visited[temp])\\n                continue;\\n\\n            foreach (var vertex in edges[temp])\\n            {\\n                if (!visited[vertex])\\n                {\\n                    var distance = dist[temp] + 1;\\n                    if (distance < dist[vertex])\\n                    {\\n                        dist[vertex] = distance;\\n                        pq.Enqueue(vertex, distance);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dist;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Graph"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> WatchedVideosByFriends(IList<IList<string>> watchedVideos, int[][] friends, int id, int level)\\n    {\\n        var dijkstra = new Dijkstra();\\n        var freq = new Dictionary<string, int>();\\n\\n        var levels = dijkstra.FindShortestDistance(friends, id);\\n\\n        for(int i = 0; i < levels.Length; i++)\\n        {\\n            if (levels[i] == level)\\n            {\\n                foreach(var video in watchedVideos[i])\\n                {\\n                    if (!freq.ContainsKey(video))\\n                        freq[video] = 0;\\n\\n                    freq[video]++;\\n                }\\n            }\\n        }\\n\\n        var res = freq.OrderBy(item => item, Comparer<KeyValuePair<string, int>>.Create((a, b) =>\\n        {\\n            if (a.Value == b.Value)\\n                return a.Key.CompareTo(b.Key);\\n            return a.Value.CompareTo(b.Value);\\n        })).ToDictionary(x => x.Key, y => y.Value);\\n\\n        return res.Keys.ToList();\\n    }\\n}\\n\\npublic class Dijkstra\\n{\\n    public int[] FindShortestDistance(int[][] edges, int node)\\n    {\\n        var n = edges.Length;\\n        var dist = new int[n];\\n        var visited = new bool[n];\\n        var pq = new PriorityQueue<int, int>();\\n\\n        for (int i = 0; i < n; i++)\\n            dist[i] = int.MaxValue;\\n\\n        dist[node] = 0;\\n        pq.Enqueue(node, 0);\\n\\n        while (pq.Count > 0)\\n        {\\n            var temp = pq.Dequeue();\\n            if (visited[temp])\\n                continue;\\n\\n            foreach (var vertex in edges[temp])\\n            {\\n                if (!visited[vertex])\\n                {\\n                    var distance = dist[temp] + 1;\\n                    if (distance < dist[vertex])\\n                    {\\n                        dist[vertex] = distance;\\n                        pq.Enqueue(vertex, distance);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dist;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232309,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = watchedVideos.size() ;\\n        queue<int>q ;\\n        q.push(id) ;\\n        vector<bool>visited(n) ;\\n        int step = 0 ;\\n        vector<int>person ;\\n        visited[id] = true ;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            step++ ;\\n            for(int i = 0; i < size; i++){\\n                int cur = q.front() ;\\n                q.pop() ;\\n                for(auto& f : friends [cur]){\\n                    if(visited[f])\\n                        continue ;\\n                    visited[f] = true ;\\n                    if(step == level)\\n                        person.push_back(f) ;\\n                    q.push(f) ;\\n                }\\n            }\\n            if(step == level)\\n                break ;\\n        }\\n        \\n        unordered_map<string, int>Map ;\\n        for(auto p : person){\\n            for(auto v : watchedVideos[p]){\\n                Map[v]++ ;\\n            }\\n        }\\n        vector<pair<int, string>>data ;\\n        for(auto m : Map){\\n            data.push_back({m.second, m.first}) ;\\n        }\\n        \\n        sort(data.begin(), data.end()) ;\\n        vector<string>ret ;\\n        for(auto d : data){\\n            ret.push_back(d.second) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = watchedVideos.size() ;\\n        queue<int>q ;\\n        q.push(id) ;\\n        vector<bool>visited(n) ;\\n        int step = 0 ;\\n        vector<int>person ;\\n        visited[id] = true ;\\n        while(!q.empty()){\\n            int size = q.size() ;\\n            step++ ;\\n            for(int i = 0; i < size; i++){\\n                int cur = q.front() ;\\n                q.pop() ;\\n                for(auto& f : friends [cur]){\\n                    if(visited[f])\\n                        continue ;\\n                    visited[f] = true ;\\n                    if(step == level)\\n                        person.push_back(f) ;\\n                    q.push(f) ;\\n                }\\n            }\\n            if(step == level)\\n                break ;\\n        }\\n        \\n        unordered_map<string, int>Map ;\\n        for(auto p : person){\\n            for(auto v : watchedVideos[p]){\\n                Map[v]++ ;\\n            }\\n        }\\n        vector<pair<int, string>>data ;\\n        for(auto m : Map){\\n            data.push_back({m.second, m.first}) ;\\n        }\\n        \\n        sort(data.begin(), data.end()) ;\\n        vector<string>ret ;\\n        for(auto d : data){\\n            ret.push_back(d.second) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177735,
                "title": "c-bfs-and-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int, string> a, pair<int, string> b){\\n        if (a.first != b.first) return a.first < b.first;\\n        return a.second < b.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        unordered_map<int, vector<int>> graph;\\n        for (int i = 0; i < friends.size(); ++i)\\n            for (auto& n : friends[i]){\\n                graph[i].push_back(n);\\n                graph[n].push_back(i);\\n            }\\n        queue<int> bfs;\\n        bfs.push(id);\\n        unordered_set<int> v = {id};\\n        while (level-- > 0 && !bfs.empty()){\\n            for (int i = bfs.size(); i > 0; --i){\\n                int n = bfs.front();\\n                bfs.pop();\\n                for (auto& e : graph[n])\\n                    if (v.find(e) == v.end()){\\n                        bfs.push(e);\\n                        v.insert(e);\\n                    }\\n            }\\n        }\\n        // queue will have all the friends and then grab ids\\n        unordered_map<string, int> videoFreq;\\n        while (!bfs.empty()){\\n            for (auto& str : watchedVideos[bfs.front()])\\n                ++videoFreq[str];\\n            bfs.pop();\\n        }\\n        vector<pair<int, string>> sortedFreq;\\n        for (auto& [f,s] : videoFreq)\\n            sortedFreq.push_back({s, f});\\n        sort(sortedFreq.begin(), sortedFreq.end(), compare);\\n        vector<string> ans;\\n        for (auto& [f, s] : sortedFreq) ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int, string> a, pair<int, string> b){\\n        if (a.first != b.first) return a.first < b.first;\\n        return a.second < b.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        unordered_map<int, vector<int>> graph;\\n        for (int i = 0; i < friends.size(); ++i)\\n            for (auto& n : friends[i]){\\n                graph[i].push_back(n);\\n                graph[n].push_back(i);\\n            }\\n        queue<int> bfs;\\n        bfs.push(id);\\n        unordered_set<int> v = {id};\\n        while (level-- > 0 && !bfs.empty()){\\n            for (int i = bfs.size(); i > 0; --i){\\n                int n = bfs.front();\\n                bfs.pop();\\n                for (auto& e : graph[n])\\n                    if (v.find(e) == v.end()){\\n                        bfs.push(e);\\n                        v.insert(e);\\n                    }\\n            }\\n        }\\n        // queue will have all the friends and then grab ids\\n        unordered_map<string, int> videoFreq;\\n        while (!bfs.empty()){\\n            for (auto& str : watchedVideos[bfs.front()])\\n                ++videoFreq[str];\\n            bfs.pop();\\n        }\\n        vector<pair<int, string>> sortedFreq;\\n        for (auto& [f,s] : videoFreq)\\n            sortedFreq.push_back({s, f});\\n        sort(sortedFreq.begin(), sortedFreq.end(), compare);\\n        vector<string> ans;\\n        for (auto& [f, s] : sortedFreq) ans.push_back(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165917,
                "title": "simple-explained-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    queue<int> q;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<bool> visited(friends.size(),false);      //To track the visited `friends`\\n        unordered_map<string,int> count;        // Stores the frequency of all the  `watchedVideos` by a freind at required level\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> result;\\n        q.push(id);                  //Push initial node/friend id.\\n        visited[id]=true;            \\n        while(!q.empty()&&level--)\\t{\\t\\t\\t//BFS to get to the level.\\n            for(int i=q.size();i;q.pop(),i--) {\\n                for(int &i:friends[q.front()])\\n                    if(!visited[i]) {\\n                        visited[i]=true;\\n                        q.push(i);\\n                    }\\n            }\\n        }\\n        while(!q.empty()) {                      //The queue at this moment will only have all the friends at required level\\n            for(string &s:watchedVideos[q.front()])\\n                count[s]++;\\n            q.pop();\\n        }\\n        for(auto it=count.begin();it!=count.end();it++) //Add results to the vector to sort by frequency first and then the string.\\n            resultPairs.push_back({it->second,it->first});\\n        sort(resultPairs.begin(),resultPairs.end());\\n        transform(resultPairs.begin(),resultPairs.end(),back_inserter(result),[](pair<int,string>&p){return p.second;}); //Transform the pairs to result\\n        return result;            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Bash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    queue<int> q;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<bool> visited(friends.size(),false);      //To track the visited `friends`\\n        unordered_map<string,int> count;        // Stores the frequency of all the  `watchedVideos` by a freind at required level\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> result;\\n        q.push(id);                  //Push initial node/friend id.\\n        visited[id]=true;            \\n        while(!q.empty()&&level--)\\t{\\t\\t\\t//BFS to get to the level.\\n            for(int i=q.size();i;q.pop(),i--) {\\n                for(int &i:friends[q.front()])\\n                    if(!visited[i]) {\\n                        visited[i]=true;\\n                        q.push(i);\\n                    }\\n            }\\n        }\\n        while(!q.empty()) {                      //The queue at this moment will only have all the friends at required level\\n            for(string &s:watchedVideos[q.front()])\\n                count[s]++;\\n            q.pop();\\n        }\\n        for(auto it=count.begin();it!=count.end();it++) //Add results to the vector to sort by frequency first and then the string.\\n            resultPairs.push_back({it->second,it->first});\\n        sort(resultPairs.begin(),resultPairs.end());\\n        transform(resultPairs.begin(),resultPairs.end(),back_inserter(result),[](pair<int,string>&p){return p.second;}); //Transform the pairs to result\\n        return result;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135402,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    queue<int> q;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<bool> visited(friends.size(),false);      //To track the visited `friends`\\n        unordered_map<string,int> count;        // Stores the frequency of all the  `watchedVideos` by a freind at required level\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> result;\\n        q.push(id);                  //Push initial node/friend id.\\n        visited[id]=true;            \\n        while(!q.empty()&&level--)\\t{\\t\\t\\t//BFS to get to the level.\\n            for(int i=q.size();i;q.pop(),i--) {\\n                for(int &i:friends[q.front()])\\n                    if(!visited[i]) {\\n                        visited[i]=true;\\n                        q.push(i);\\n                    }\\n            }\\n        }\\n        while(!q.empty()) {                      //The queue at this moment will only have all the friends at required level\\n            for(string &s:watchedVideos[q.front()])\\n                count[s]++;\\n            q.pop();\\n        }\\n        for(auto it=count.begin();it!=count.end();it++) //Add results to the vector to sort by frequency first and then the string.\\n            resultPairs.push_back({it->second,it->first});\\n        sort(resultPairs.begin(),resultPairs.end());\\n        transform(resultPairs.begin(),resultPairs.end(),back_inserter(result),[](pair<int,string>&p){return p.second;}); //Transform the pairs to result\\n        return result;            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    queue<int> q;\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) \\n    {\\n        vector<bool> visited(friends.size(),false);      //To track the visited `friends`\\n        unordered_map<string,int> count;        // Stores the frequency of all the  `watchedVideos` by a freind at required level\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> result;\\n        q.push(id);                  //Push initial node/friend id.\\n        visited[id]=true;            \\n        while(!q.empty()&&level--)\\t{\\t\\t\\t//BFS to get to the level.\\n            for(int i=q.size();i;q.pop(),i--) {\\n                for(int &i:friends[q.front()])\\n                    if(!visited[i]) {\\n                        visited[i]=true;\\n                        q.push(i);\\n                    }\\n            }\\n        }\\n        while(!q.empty()) {                      //The queue at this moment will only have all the friends at required level\\n            for(string &s:watchedVideos[q.front()])\\n                count[s]++;\\n            q.pop();\\n        }\\n        for(auto it=count.begin();it!=count.end();it++) //Add results to the vector to sort by frequency first and then the string.\\n            resultPairs.push_back({it->second,it->first});\\n        sort(resultPairs.begin(),resultPairs.end());\\n        transform(resultPairs.begin(),resultPairs.end(),back_inserter(result),[](pair<int,string>&p){return p.second;}); //Transform the pairs to result\\n        return result;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132233,
                "title": "simple-bfs-hashmap-solution-and-approach-cpp-bfs-sorting-graph",
                "content": "# Intuition and Approach\\n* simple bfs approach.\\n* initialize bfs using queue.\\n* when reach at desired level stop bfs.\\n* all the nodes in queue which are not visited and node!=-1 are our nodes at the desired level.\\n* count the frequency of each string in all nodes.\\n* ** keep in mind that same nodes should\\'nt be repeated.\\n* now push the string in to array acc. to frequency.\\n* at the end return the array.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& f, int id, int l) {\\n        int n=w.size();\\n        map<string,int>mp;\\n        vector<int>vis(n,0);\\n        queue<int>q;\\n        int cl=0;\\n        q.push(id);\\n        q.push(-1);\\n        while(cl<l && !q.empty()){\\n            int temp=q.front();\\n            q.pop();\\n            if(temp==-1){\\n                q.push(-1);\\n                cl++;\\n                continue;\\n            }\\n            if(vis[temp])continue;\\n            vis[temp]=1;\\n            for(int i:f[temp])q.push(i);\\n        }\\n        while(!q.empty()){\\n            int temp=q.front();\\n            q.pop();\\n            if(temp==-1 || vis[temp])continue;\\n            vis[temp]=1;\\n            for(string s:w[temp])mp[s]++;\\n        }\\n        vector<pair<int,string>>mp2;\\n        vector<string>ans;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)mp2.push_back({itr->second,itr->first});\\n        sort(mp2.begin(),mp2.end());\\n        for(int i=0;i<mp2.size();i++){\\n            cout<<mp2[i].first<<\"__\"<<mp2[i].second<<\"\\\\n\";\\n            ans.push_back(mp2[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& f, int id, int l) {\\n        int n=w.size();\\n        map<string,int>mp;\\n        vector<int>vis(n,0);\\n        queue<int>q;\\n        int cl=0;\\n        q.push(id);\\n        q.push(-1);\\n        while(cl<l && !q.empty()){\\n            int temp=q.front();\\n            q.pop();\\n            if(temp==-1){\\n                q.push(-1);\\n                cl++;\\n                continue;\\n            }\\n            if(vis[temp])continue;\\n            vis[temp]=1;\\n            for(int i:f[temp])q.push(i);\\n        }\\n        while(!q.empty()){\\n            int temp=q.front();\\n            q.pop();\\n            if(temp==-1 || vis[temp])continue;\\n            vis[temp]=1;\\n            for(string s:w[temp])mp[s]++;\\n        }\\n        vector<pair<int,string>>mp2;\\n        vector<string>ans;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)mp2.push_back({itr->second,itr->first});\\n        sort(mp2.begin(),mp2.end());\\n        for(int i=0;i<mp2.size();i++){\\n            cout<<mp2[i].first<<\"__\"<<mp2[i].second<<\"\\\\n\";\\n            ans.push_back(mp2[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3096430,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn watched_videos_by_friends(watched_videos: Vec<Vec<String>>, friends: Vec<Vec<i32>>, id: i32, level: i32) -> Vec<String> {\\n        let mut visited = vec![false; friends.len()];\\n        let mut queue = vec![id as usize];\\n        visited[id as usize] = true;\\n        let mut level = level;\\n        while level > 0 {\\n            let mut next_queue = Vec::new();\\n            for i in queue {\\n                for j in &friends[i] {\\n                    if !visited[*j as usize] {\\n                        visited[*j as usize] = true;\\n                        next_queue.push(*j as usize);\\n                    }\\n                }\\n            }\\n            queue = next_queue;\\n            level -= 1;\\n        }\\n        let mut freq = std::collections::HashMap::new();\\n        for i in queue {\\n            for j in &watched_videos[i] {\\n                *freq.entry(j).or_insert(0) += 1;\\n            }\\n        }\\n        let mut freq = freq.into_iter().collect::<Vec<_>>();\\n        freq.sort_by(|a, b| if a.1 == b.1 { a.0.cmp(b.0) } else { a.1.cmp(&b.1) });\\n        freq.into_iter().map(|x| x.0.to_string()).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn watched_videos_by_friends(watched_videos: Vec<Vec<String>>, friends: Vec<Vec<i32>>, id: i32, level: i32) -> Vec<String> {\\n        let mut visited = vec![false; friends.len()];\\n        let mut queue = vec![id as usize];\\n        visited[id as usize] = true;\\n        let mut level = level;\\n        while level > 0 {\\n            let mut next_queue = Vec::new();\\n            for i in queue {\\n                for j in &friends[i] {\\n                    if !visited[*j as usize] {\\n                        visited[*j as usize] = true;\\n                        next_queue.push(*j as usize);\\n                    }\\n                }\\n            }\\n            queue = next_queue;\\n            level -= 1;\\n        }\\n        let mut freq = std::collections::HashMap::new();\\n        for i in queue {\\n            for j in &watched_videos[i] {\\n                *freq.entry(j).or_insert(0) += 1;\\n            }\\n        }\\n        let mut freq = freq.into_iter().collect::<Vec<_>>();\\n        freq.sort_by(|a, b| if a.1 == b.1 { a.0.cmp(b.0) } else { a.1.cmp(&b.1) });\\n        freq.into_iter().map(|x| x.0.to_string()).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3081475,
                "title": "java-easy-solution-bfs-sort",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int l) {\\n        int n = friends.length;\\n        \\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(id);\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int level=0;\\n        int vis[] = new int[n];\\n        vis[id]=1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            \\n            for(int i=0;i<size;i++){\\n                int node = q.poll();\\n                if(level == l){\\n                    for(String s:watchedVideos.get(node))hm.put(s,hm.getOrDefault(s,0)+1);\\n                    continue;\\n                }\\n                for(int it:friends[node])if(vis[it]!=1){\\n                    vis[it]=1;\\n                    q.add(it);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        List<String> ans = new ArrayList<>(hm.keySet());\\n        \\n        Collections.sort(ans,(a,b)->hm.get(a)==hm.get(b)?a.compareTo(b):hm.get(a)-hm.get(b));\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int l) {\\n        int n = friends.length;\\n        \\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(id);\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int level=0;\\n        int vis[] = new int[n];\\n        vis[id]=1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            \\n            for(int i=0;i<size;i++){\\n                int node = q.poll();\\n                if(level == l){\\n                    for(String s:watchedVideos.get(node))hm.put(s,hm.getOrDefault(s,0)+1);\\n                    continue;\\n                }\\n                for(int it:friends[node])if(vis[it]!=1){\\n                    vis[it]=1;\\n                    q.add(it);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        List<String> ans = new ArrayList<>(hm.keySet());\\n        \\n        Collections.sort(ans,(a,b)->hm.get(a)==hm.get(b)?a.compareTo(b):hm.get(a)-hm.get(b));\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060856,
                "title": "10-lines-scala-immutable-bfs-also-beats-100-despite-inefficient-groupby",
                "content": "# Code\\n```\\nobject Solution {\\n  def watchedVideosByFriends(watchedVideos: List[List[String]], friends: Array[Array[Int]], id: Int, level: Int): List[String] = {\\n    lazy val group = friends.iterator.zipWithIndex.map{case (fs, i) => i -> fs.toSet}.toMap\\n    def impl(lvl: Int, prev: Set[Int], visited: Set[Int]): Set[Int] = {\\n      def reducer(a: Set[Int], b: Set[Int]) = a ++ b\\n      lazy val next = prev.map(i => (group(i) -- visited).toSet).foldLeft(Set.empty[Int])(reducer)\\n      if(lvl == level) next\\n      else impl(lvl+1, next, visited ++ next)\\n    }\\n    lazy val x0 = impl(1, Set(id), Set(id))\\n    watchedVideos.zipWithIndex.filter{case (_,i) => x0.contains(i)}.flatMap(_._1)\\n      .groupBy(identity).mapValues(_.size).map{ case (x, y) => (y, x) }.toList.sorted.map(_._2)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def watchedVideosByFriends(watchedVideos: List[List[String]], friends: Array[Array[Int]], id: Int, level: Int): List[String] = {\\n    lazy val group = friends.iterator.zipWithIndex.map{case (fs, i) => i -> fs.toSet}.toMap\\n    def impl(lvl: Int, prev: Set[Int], visited: Set[Int]): Set[Int] = {\\n      def reducer(a: Set[Int], b: Set[Int]) = a ++ b\\n      lazy val next = prev.map(i => (group(i) -- visited).toSet).foldLeft(Set.empty[Int])(reducer)\\n      if(lvl == level) next\\n      else impl(lvl+1, next, visited ++ next)\\n    }\\n    lazy val x0 = impl(1, Set(id), Set(id))\\n    watchedVideos.zipWithIndex.filter{case (_,i) => x0.contains(i)}.flatMap(_._1)\\n      .groupBy(identity).mapValues(_.size).map{ case (x, y) => (y, x) }.toList.sorted.map(_._2)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3055405,
                "title": "javascript-bfs-with-lots-of-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    \\n    const visited = new Set();\\n    const queue = [id];\\n    visited.add(id);\\n    let lvl = 0\\n\\n    //traverse the list of friends using BFS and level order traversal so that\\n    //the last level of queue will equal all friends at \"level\" level\\n    while (queue.length && lvl < level){\\n      \\n        const length = queue.length;\\n        for (let i = 0; i < length; i ++){\\n            const current = queue.shift();\\n            \\n            for (let friend of friends[current]){\\n                if (visited.has(friend)) continue;\\n                visited.add(friend);\\n                queue.push(friend);\\n            }\\n        };\\n        lvl++;\\n    };\\n    \\n    //for the remaining friends in the queue, create a list of\\n    //all movies watched and the number of times they were watched\\n    const moviesAndNumWatched = {};\\n    for (let friend of queue){\\n        for (let mov of watchedVideos[friend]){\\n            if (!(mov in moviesAndNumWatched)){\\n                moviesAndNumWatched[mov] = 1;\\n            }else{\\n                moviesAndNumWatched[mov] ++;\\n            };\\n        };\\n    };\\n    \\n    //convert the list of moviesAndNumWatched into an array where\\n    //the index in the array represents the number of times watched and\\n    //each element in the array shows all (unsorted) movies watched that number of times\\n    const array = [];\\n    for (let vid in moviesAndNumWatched){\\n        const index = moviesAndNumWatched[vid];\\n        if (!array[index]){\\n            array[index] = [];\\n        }\\n        array[index].push(vid);\\n       \\n    };\\n    \\n    //now sort each element in the array, take every video within that element and\\n    //push that video into the final array\\n    const final = [];\\n    for (let item of array){\\n        if (item){\\n            const sorted = (item.sort())\\n            for (let vid of sorted){\\n                final.push(vid);\\n            };\\n        };\\n    };\\n    return (final)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    \\n    const visited = new Set();\\n    const queue = [id];\\n    visited.add(id);\\n    let lvl = 0\\n\\n    //traverse the list of friends using BFS and level order traversal so that\\n    //the last level of queue will equal all friends at \"level\" level\\n    while (queue.length && lvl < level){\\n      \\n        const length = queue.length;\\n        for (let i = 0; i < length; i ++){\\n            const current = queue.shift();\\n            \\n            for (let friend of friends[current]){\\n                if (visited.has(friend)) continue;\\n                visited.add(friend);\\n                queue.push(friend);\\n            }\\n        };\\n        lvl++;\\n    };\\n    \\n    //for the remaining friends in the queue, create a list of\\n    //all movies watched and the number of times they were watched\\n    const moviesAndNumWatched = {};\\n    for (let friend of queue){\\n        for (let mov of watchedVideos[friend]){\\n            if (!(mov in moviesAndNumWatched)){\\n                moviesAndNumWatched[mov] = 1;\\n            }else{\\n                moviesAndNumWatched[mov] ++;\\n            };\\n        };\\n    };\\n    \\n    //convert the list of moviesAndNumWatched into an array where\\n    //the index in the array represents the number of times watched and\\n    //each element in the array shows all (unsorted) movies watched that number of times\\n    const array = [];\\n    for (let vid in moviesAndNumWatched){\\n        const index = moviesAndNumWatched[vid];\\n        if (!array[index]){\\n            array[index] = [];\\n        }\\n        array[index].push(vid);\\n       \\n    };\\n    \\n    //now sort each element in the array, take every video within that element and\\n    //push that video into the final array\\n    const final = [];\\n    for (let item of array){\\n        if (item){\\n            const sorted = (item.sort())\\n            for (let vid of sorted){\\n                final.push(vid);\\n            };\\n        };\\n    };\\n    return (final)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043170,
                "title": "my-solution-not-fast",
                "content": "``` \\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();  \\n        Map<String,Integer> freqMap = new TreeMap<>();\\n         \\n        Queue<Integer> q = new LinkedList<>(); \\n        Set<Integer> v = new HashSet<>(); \\n        q.offer(id);  \\n        int lvl = level;\\n        \\n        while(!q.isEmpty() && lvl>0) {  \\n            lvl--;\\n            int size = q.size();  \\n            for(int i =  0; i < size; i++) { \\n                Integer curr = q.poll();   \\n                if(v.add(curr)) {  \\n                    for(Integer child : friends[curr]) {  \\n                        if(!v.contains(child)) q.offer(child);\\n                    }\\n                }\\n            } \\n        } \\n         \\n    \\n        Set<Integer> qSet = new HashSet<>(q); \\n        for(Integer p : qSet) { \\n            if(v.contains(p)) continue; \\n            List<String> wv = watchedVideos.get(p);  \\n            for(String video : wv) {  \\n                freqMap.put(video,(freqMap.containsKey(video) ? freqMap.get(video) : 0)+1);\\n            }\\n        } \\n        \\n        Set<String> videos = new TreeSet<>((String s1, String s2) -> { \\n            return  \\n                freqMap.get(s1) == freqMap.get(s2) ? s1.compareTo(s2) : freqMap.get(s1) -  \\n                freqMap.get(s2);\\n        }); \\n        for(String video : freqMap.keySet()) { \\n            videos.add(video);\\n        }\\n        return new ArrayList<>(videos);\\n    } \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();  \\n        Map<String,Integer> freqMap = new TreeMap<>();\\n         \\n        Queue<Integer> q = new LinkedList<>(); \\n        Set<Integer> v = new HashSet<>(); \\n        q.offer(id);  \\n        int lvl = level;\\n        \\n        while(!q.isEmpty() && lvl>0) {  \\n            lvl--;\\n            int size = q.size();  \\n            for(int i =  0; i < size; i++) { \\n                Integer curr = q.poll();   \\n                if(v.add(curr)) {  \\n                    for(Integer child : friends[curr]) {  \\n                        if(!v.contains(child)) q.offer(child);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3033739,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        q.add(id);\\n        boolean [] visited = new boolean[n];\\n        HashMap<String, Integer> map = new HashMap<>();\\n        visited[id] = true;\\n        int lev = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int frnd = q.poll();\\n                if(lev == level){\\n                    for(String s : watchedVideos.get(frnd)){\\n                        map.put(s, map.getOrDefault(s, 0) + 1);\\n                    }\\n                }\\n                else {\\n                    for(int f : friends[frnd]){\\n                        if(visited[f] == false){\\n                            visited[f] = true;\\n                            q.add(f);\\n                        }\\n                    }\\n                }\\n            }\\n            lev++;\\n        }\\n        List<String> ans = new ArrayList<>(map.keySet());\\n        ans.sort((a, b) -> {\\n            int fa = map.get(a);\\n            int fb = map.get(b);\\n            if (fa != fb) {\\n                return fa - fb;\\n            } else {\\n                return a.compareTo(b);\\n            }\\n        });\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        q.add(id);\\n        boolean [] visited = new boolean[n];\\n        HashMap<String, Integer> map = new HashMap<>();\\n        visited[id] = true;\\n        int lev = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                int frnd = q.poll();\\n                if(lev == level){\\n                    for(String s : watchedVideos.get(frnd)){\\n                        map.put(s, map.getOrDefault(s, 0) + 1);\\n                    }\\n                }\\n                else {\\n                    for(int f : friends[frnd]){\\n                        if(visited[f] == false){\\n                            visited[f] = true;\\n                            q.add(f);\\n                        }\\n                    }\\n                }\\n            }\\n            lev++;\\n        }\\n        List<String> ans = new ArrayList<>(map.keySet());\\n        ans.sort((a, b) -> {\\n            int fa = map.get(a);\\n            int fb = map.get(b);\\n            if (fa != fb) {\\n                return fa - fb;\\n            } else {\\n                return a.compareTo(b);\\n            }\\n        });\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032158,
                "title": "simple-c-solution-using-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>&w,vector<vector<int>>&g,int id,int level) {\\n        vector<int>visit(g.size(),0);\\n        queue<pair<int,int>>q;\\n        q.push({id,0});\\n        visit[id]=1;\\n        map<string,int>m;\\n        while(!q.empty()){\\n            int node=q.front().first;\\n            int lev=q.front().second;\\n            q.pop();\\n            if(lev==level){\\n                for(int i=0;i<w[node].size();++i)\\n                   m[w[node][i]]++;\\n                continue;\\n            }\\n            for(int i=0;i<g[node].size();++i){\\n                if(visit[g[node][i]]==0){\\n                    q.push({g[node][i],lev+1});\\n                    visit[g[node][i]]=1;\\n                }\\n            }\\n        }\\n        multimap<int,string>mp;\\n        for(auto it:m){\\n            mp.insert({it.second,it.first});\\n        }\\n        vector<string>ans;\\n        for(auto it:mp)\\n           ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>&w,vector<vector<int>>&g,int id,int level) {\\n        vector<int>visit(g.size(),0);\\n        queue<pair<int,int>>q;\\n        q.push({id,0});\\n        visit[id]=1;\\n        map<string,int>m;\\n        while(!q.empty()){\\n            int node=q.front().first;\\n            int lev=q.front().second;\\n            q.pop();\\n            if(lev==level){\\n                for(int i=0;i<w[node].size();++i)\\n                   m[w[node][i]]++;\\n                continue;\\n            }\\n            for(int i=0;i<g[node].size();++i){\\n                if(visit[g[node][i]]==0){\\n                    q.push({g[node][i],lev+1});\\n                    visit[g[node][i]]=1;\\n                }\\n            }\\n        }\\n        multimap<int,string>mp;\\n        for(auto it:m){\\n            mp.insert({it.second,it.first});\\n        }\\n        vector<string>ans;\\n        for(auto it:mp)\\n           ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004647,
                "title": "very-easy-bfs-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size(), l = 0;\\n        vector<bool> vis(n,false);\\n        unordered_map<string,int> freq;\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> res;\\n        queue<int> q;\\n        q.push(id);\\n        vis[id] = true;\\n        while(!q.empty() and level--){\\n            int sz = q.size();\\n            while(sz--){ \\n                auto node=q.front();q.pop(); \\n                for(auto &i:friends[node]){\\n                    if(!vis[i]){\\n                        vis[i] = true;\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            auto node=q.front();q.pop();\\n            for(auto &v:watchedVideos[node])\\n                freq[v]++;\\n        }\\n\\n        for(auto &[key,val]:freq){\\n            resultPairs.push_back({val,key});\\n        }\\n\\n        sort(resultPairs.begin(),end(resultPairs));\\n        for(auto &it:resultPairs){\\\\\\n            res.push_back(it.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size(), l = 0;\\n        vector<bool> vis(n,false);\\n        unordered_map<string,int> freq;\\n        vector<pair<int,string>> resultPairs;\\n        vector<string> res;\\n        queue<int> q;\\n        q.push(id);\\n        vis[id] = true;\\n        while(!q.empty() and level--){\\n            int sz = q.size();\\n            while(sz--){ \\n                auto node=q.front();q.pop(); \\n                for(auto &i:friends[node]){\\n                    if(!vis[i]){\\n                        vis[i] = true;\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!q.empty()){\\n            auto node=q.front();q.pop();\\n            for(auto &v:watchedVideos[node])\\n                freq[v]++;\\n        }\\n\\n        for(auto &[key,val]:freq){\\n            resultPairs.push_back({val,key});\\n        }\\n\\n        sort(resultPairs.begin(),end(resultPairs));\\n        for(auto &it:resultPairs){\\\\\\n            res.push_back(it.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993776,
                "title": "bfs-hashmap-sorting-better-than-80-java",
                "content": "# Code\\n```\\nclass Solution {\\n    private final Set<Integer> visited = new HashSet<>();\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        HashSet<Integer> friendsAtLevel = getFriendsAtLevel(id,level,friends);\\n        Map<String,Integer> videosFreq = getVideosFreq(friendsAtLevel,watchedVideos);\\n        return sortVideos(videosFreq);\\n    }\\n\\n    private HashSet<Integer> getFriendsAtLevel(int start, int distance, int[][] friends) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(start);\\n        visited.add(start);\\n        while (!queue.isEmpty() && distance>0) {\\n            distance--;\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int current = queue.remove();\\n                visited.add(current);\\n                for (int friend: friends[current])\\n                    if(!visited.contains(friend))\\n                        queue.add(friend);\\n            }\\n        }\\n        return new HashSet<>(queue);\\n    }\\n\\n    private Map<String, Integer> getVideosFreq(HashSet<Integer> friendsAtLevel, List<List<String>> watchedVideos) {\\n        Map<String, Integer> videosFreq = new HashMap<>();\\n        for (int friend: friendsAtLevel) {\\n            if(visited.contains(friend)) continue;\\n            for (String video : watchedVideos.get(friend))\\n                videosFreq.put(video, videosFreq.containsKey(video) ? videosFreq.get(video) + 1 : 1);\\n        }\\n        return videosFreq;\\n    }\\n\\n    private List<String> sortVideos(Map<String, Integer> videosFreq) {\\n        Map<Integer, List<String>> sortedVideos = new HashMap<>();\\n        for (Map.Entry<String,Integer> entry: videosFreq.entrySet()) {\\n            if(sortedVideos.containsKey(entry.getValue())) sortedVideos.get(entry.getValue()).add(entry.getKey());\\n            else {\\n                List<String> list = new ArrayList<>();\\n                list.add(entry.getKey());\\n                sortedVideos.put(entry.getValue(),list);\\n            }\\n        }\\n        List<String> result = new ArrayList<>();\\n        for (Integer freq: sortedVideos.keySet().stream().sorted().collect(Collectors.toCollection(LinkedHashSet::new))) {\\n            Collections.sort(sortedVideos.get(freq));\\n            result.addAll(sortedVideos.get(freq));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final Set<Integer> visited = new HashSet<>();\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        HashSet<Integer> friendsAtLevel = getFriendsAtLevel(id,level,friends);\\n        Map<String,Integer> videosFreq = getVideosFreq(friendsAtLevel,watchedVideos);\\n        return sortVideos(videosFreq);\\n    }\\n\\n    private HashSet<Integer> getFriendsAtLevel(int start, int distance, int[][] friends) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(start);\\n        visited.add(start);\\n        while (!queue.isEmpty() && distance>0) {\\n            distance--;\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int current = queue.remove();\\n                visited.add(current);\\n                for (int friend: friends[current])\\n                    if(!visited.contains(friend))\\n                        queue.add(friend);\\n            }\\n        }\\n        return new HashSet<>(queue);\\n    }\\n\\n    private Map<String, Integer> getVideosFreq(HashSet<Integer> friendsAtLevel, List<List<String>> watchedVideos) {\\n        Map<String, Integer> videosFreq = new HashMap<>();\\n        for (int friend: friendsAtLevel) {\\n            if(visited.contains(friend)) continue;\\n            for (String video : watchedVideos.get(friend))\\n                videosFreq.put(video, videosFreq.containsKey(video) ? videosFreq.get(video) + 1 : 1);\\n        }\\n        return videosFreq;\\n    }\\n\\n    private List<String> sortVideos(Map<String, Integer> videosFreq) {\\n        Map<Integer, List<String>> sortedVideos = new HashMap<>();\\n        for (Map.Entry<String,Integer> entry: videosFreq.entrySet()) {\\n            if(sortedVideos.containsKey(entry.getValue())) sortedVideos.get(entry.getValue()).add(entry.getKey());\\n            else {\\n                List<String> list = new ArrayList<>();\\n                list.add(entry.getKey());\\n                sortedVideos.put(entry.getValue(),list);\\n            }\\n        }\\n        List<String> result = new ArrayList<>();\\n        for (Integer freq: sortedVideos.keySet().stream().sorted().collect(Collectors.toCollection(LinkedHashSet::new))) {\\n            Collections.sort(sortedVideos.get(freq));\\n            result.addAll(sortedVideos.get(freq));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959577,
                "title": "simple-explanation-in-four-steps-which-is-faster-than-95",
                "content": "# Intuition\\n Intution was to \\n    1) store all the friends at that k level\\n    2) then store in hashmap all the movies of those friends\\n    3) then store in priorityQueue which is prioritized by 2 steps \\n       i) by frequency;\\n       ii) by string;\\n    4) store in arraylist till priorityqueue is not empty\\n\\n\\n# Complexity\\n- Time complexity:\\nits time complexity is O(n2)\\n\\n- Space complexity:\\nits space complexity is O(n)\\n# Code\\n```\\nclass Solution {\\npublic class find{\\n    String na;\\n    int ja;\\n    find(String na,int ja)\\n    {this.na=na;this.ja=ja;}\\n} \\n\\n    public List<String> watchedVideosByFriends(List<List<String>> wv, int[][] f, int id, int level) {\\n   List<String>ans=new ArrayList<String>();\\n   Queue<Integer>q=new LinkedList<Integer>();\\n   HashSet<Integer>h=new HashSet<Integer>();\\n      q.add(id);h.add(id);\\n      int l=0;\\n\\n      while(!q.isEmpty())\\n          {\\n            int s=q.size();l++;\\n                for(int i=0;i<s;i++)\\n                    {\\n                        int w=q.remove();\\n                        for(int k:f[w])\\n                            {if(!h.contains(k)){q.add(k);h.add(k);}}\\n                    }\\n            if(l==level)break;\\n          }\\n   HashMap<String,Integer>m=new HashMap<String,Integer>();\\n       while(!q.isEmpty())\\n            {\\n                int s=q.remove();\\n                for(String g:wv.get(s))\\n                    {\\n                         if(!m.containsKey(g)){m.put(g,1);}\\n                         else{m.put(g,m.get(g)+1);}\\n                    }\\n            }\\n   PriorityQueue<find>pq=new PriorityQueue<find>\\n   (\\n   new Comparator<find>()\\n   {\\n      public int compare(find a,find b)\\n        {\\n        if(a.ja>b.ja)return 1;\\n        else if(a.ja<b.ja)return -1;\\n        else{if(a.na.compareTo(b.na)>0){return 1;}else{ return -1;}}\\n        }\\n   }\\n   );\\n\\n\\n    for (Map.Entry<String,Integer> e : m.entrySet())\\n         {pq.add(new find(e.getKey(),e.getValue()));}\\n\\n\\n    while(!pq.isEmpty())\\n         {find v=pq.remove();ans.add(v.na);}\\n   \\n   \\n   return ans;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic class find{\\n    String na;\\n    int ja;\\n    find(String na,int ja)\\n    {this.na=na;this.ja=ja;}\\n} \\n\\n    public List<String> watchedVideosByFriends(List<List<String>> wv, int[][] f, int id, int level) {\\n   List<String>ans=new ArrayList<String>();\\n   Queue<Integer>q=new LinkedList<Integer>();\\n   HashSet<Integer>h=new HashSet<Integer>();\\n      q.add(id);h.add(id);\\n      int l=0;\\n\\n      while(!q.isEmpty())\\n          {\\n            int s=q.size();l++;\\n                for(int i=0;i<s;i++)\\n                    {\\n                        int w=q.remove();\\n                        for(int k:f[w])\\n                            {if(!h.contains(k)){q.add(k);h.add(k);}}\\n                    }\\n            if(l==level)break;\\n          }\\n   HashMap<String,Integer>m=new HashMap<String,Integer>();\\n       while(!q.isEmpty())\\n            {\\n                int s=q.remove();\\n                for(String g:wv.get(s))\\n                    {\\n                         if(!m.containsKey(g)){m.put(g,1);}\\n                         else{m.put(g,m.get(g)+1);}\\n                    }\\n            }\\n   PriorityQueue<find>pq=new PriorityQueue<find>\\n   (\\n   new Comparator<find>()\\n   {\\n      public int compare(find a,find b)\\n        {\\n        if(a.ja>b.ja)return 1;\\n        else if(a.ja<b.ja)return -1;\\n        else{if(a.na.compareTo(b.na)>0){return 1;}else{ return -1;}}\\n        }\\n   }\\n   );\\n\\n\\n    for (Map.Entry<String,Integer> e : m.entrySet())\\n         {pq.add(new find(e.getKey(),e.getValue()));}\\n\\n\\n    while(!pq.isEmpty())\\n         {find v=pq.remove();ans.add(v.na);}\\n   \\n   \\n   return ans;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955545,
                "title": "use-simple-bfs-beats-75",
                "content": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        video_map = {}\\n        edge_map = {}\\n        watched_video_map = {}\\n\\n        for i, vid_list in enumerate(watchedVideos):\\n            video_map[i] = vid_list\\n        for i, friend_list in enumerate(friends):\\n            edge_map[i] = set(friend_list)\\n        \\n        que = deque([id])\\n        visited = set({id})\\n        while len(que):\\n            if not level:\\n                break\\n            for _ in range(len(que)):\\n                friend = que.popleft()\\n                for nei in edge_map[friend]:\\n                    if nei not in visited:\\n                        que.append(nei)\\n                        visited.add(nei)\\n            level -= 1\\n        for _ in range(len(que)):\\n            friend = que.popleft()\\n            for vid in video_map[friend]:\\n                watched_video_map[vid] = watched_video_map.get(vid, 0) + 1\\n        sorted_vid = [item[0] for item in sorted(watched_video_map.items(), key=lambda x: (x[1], x[0]))]\\n        return sorted_vid\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        video_map = {}\\n        edge_map = {}\\n        watched_video_map = {}\\n\\n        for i, vid_list in enumerate(watchedVideos):\\n            video_map[i] = vid_list\\n        for i, friend_list in enumerate(friends):\\n            edge_map[i] = set(friend_list)\\n        \\n        que = deque([id])\\n        visited = set({id})\\n        while len(que):\\n            if not level:\\n                break\\n            for _ in range(len(que)):\\n                friend = que.popleft()\\n                for nei in edge_map[friend]:\\n                    if nei not in visited:\\n                        que.append(nei)\\n                        visited.add(nei)\\n            level -= 1\\n        for _ in range(len(que)):\\n            friend = que.popleft()\\n            for vid in video_map[friend]:\\n                watched_video_map[vid] = watched_video_map.get(vid, 0) + 1\\n        sorted_vid = [item[0] for item in sorted(watched_video_map.items(), key=lambda x: (x[1], x[0]))]\\n        return sorted_vid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897528,
                "title": "c-beats-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGraph is given \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS Approach Simple!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO ( V + E )\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& adjList, int id, int level) {\\n        queue<int>q;\\n        vector<bool>visited(adjList.size(), false);\\n        q.push(id);\\n        visited[id] = true;\\n       \\n        map<string, int>mp;\\n        while(!q.empty()){\\n            int sz = q.size();\\n\\n            while(sz--){\\n                int curr = q.front();\\n                q.pop();\\n\\n                if(level==0){\\n                    for(int i=0;i<watchedVideos[curr].size();++i){\\n                        mp[watchedVideos[curr][i]]++;\\n                    }\\n                }\\n\\n                for(int i=0;i<adjList[curr].size();++i){\\n                    if(visited[adjList[curr][i]]==false){\\n                        q.push({adjList[curr][i]});\\n                        visited[adjList[curr][i]] = true;\\n                    }\\n                    \\n                }\\n            }\\n\\n            level--;\\n        }\\n        \\n        vector<pair<int, string>>vect;\\n        for(auto it:mp){\\n            vect.push_back({it.second, it.first});\\n        }\\n        sort(vect.begin(), vect.end());\\n        vector<string>ans;\\n        for(int i=0;i<vect.size();++i){\\n            ans.push_back(vect[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& adjList, int id, int level) {\\n        queue<int>q;\\n        vector<bool>visited(adjList.size(), false);\\n        q.push(id);\\n        visited[id] = true;\\n       \\n        map<string, int>mp;\\n        while(!q.empty()){\\n            int sz = q.size();\\n\\n            while(sz--){\\n                int curr = q.front();\\n                q.pop();\\n\\n                if(level==0){\\n                    for(int i=0;i<watchedVideos[curr].size();++i){\\n                        mp[watchedVideos[curr][i]]++;\\n                    }\\n                }\\n\\n                for(int i=0;i<adjList[curr].size();++i){\\n                    if(visited[adjList[curr][i]]==false){\\n                        q.push({adjList[curr][i]});\\n                        visited[adjList[curr][i]] = true;\\n                    }\\n                    \\n                }\\n            }\\n\\n            level--;\\n        }\\n        \\n        vector<pair<int, string>>vect;\\n        for(auto it:mp){\\n            vect.push_back({it.second, it.first});\\n        }\\n        sort(vect.begin(), vect.end());\\n        vector<string>ans;\\n        for(int i=0;i<vect.size();++i){\\n            ans.push_back(vect[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882966,
                "title": "c-easy-bfs-hashmap",
                "content": "# Intuition\\n<!--  -->\\nBFS (Breadth First Search)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start BFS from start ID, then find all the IDs of the friends at level = \"level\"\\n- Traverse the list and store the frequencies of all strings in a HashMap\\n- Traverse the map and sort first on the basis of freq, then on the basis of string (alphabetical order)\\n\\n# Complexity\\n- Time complexity: **O(VlogV + E)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: **O(V+E)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nbool comp(pair<string, int>& a, pair<string, int>& b){\\n    if((a.second < b.second) || (a.second == b.second && a.first < b.first))\\n        return true;\\n    else return false;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        int i, j;\\n        int n = friends.size();\\n        vector<int> vis(n, 0);\\n\\n        queue<pair<int, int>> q;\\n        q.push({id, 0});\\n        vis[id] = 1;\\n\\n        vector<int> friend_ids;\\n\\n        while(!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n\\n            if(curr.second == level){\\n                friend_ids.push_back(curr.first);\\n            }\\n\\n            for(auto it:friends[curr.first]){\\n                if(!vis[it]){\\n                    vis[it] = 1;\\n                    q.push({it, curr.second + 1});\\n                }\\n            }\\n\\n        }\\n\\n        unordered_map<string, int> m;\\n        for(i=0; i < friend_ids.size(); i++){\\n            for(auto it:watchedVideos[friend_ids[i]]){\\n                m[it]++;\\n            }\\n        }\\n\\n        vector<pair<string, int>> v;\\n        for(auto it:m){\\n            v.push_back({it.first, it.second});\\n        }\\n\\n        sort(v.begin(), v.end(), comp);\\n\\n        vector<string> ans;\\n\\n        for(i=0; i<v.size(); i++){\\n            ans.push_back(v[i].first);\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nbool comp(pair<string, int>& a, pair<string, int>& b){\\n    if((a.second < b.second) || (a.second == b.second && a.first < b.first))\\n        return true;\\n    else return false;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        int i, j;\\n        int n = friends.size();\\n        vector<int> vis(n, 0);\\n\\n        queue<pair<int, int>> q;\\n        q.push({id, 0});\\n        vis[id] = 1;\\n\\n        vector<int> friend_ids;\\n\\n        while(!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n\\n            if(curr.second == level){\\n                friend_ids.push_back(curr.first);\\n            }\\n\\n            for(auto it:friends[curr.first]){\\n                if(!vis[it]){\\n                    vis[it] = 1;\\n                    q.push({it, curr.second + 1});\\n                }\\n            }\\n\\n        }\\n\\n        unordered_map<string, int> m;\\n        for(i=0; i < friend_ids.size(); i++){\\n            for(auto it:watchedVideos[friend_ids[i]]){\\n                m[it]++;\\n            }\\n        }\\n\\n        vector<pair<string, int>> v;\\n        for(auto it:m){\\n            v.push_back({it.first, it.second});\\n        }\\n\\n        sort(v.begin(), v.end(), comp);\\n\\n        vector<string> ans;\\n\\n        for(i=0; i<v.size(); i++){\\n            ans.push_back(v[i].first);\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839831,
                "title": "bfs-sorting-approach-java-solution",
                "content": "```java\\nclass Solution {\\n    <K,V> void sortByValue(Map<K,V> mp,Comparator<Map.Entry<K,V>> c){\\n        List<Map.Entry<K,V>> ls = new ArrayList<>(mp.entrySet());\\n        \\n        Collections.sort(ls, c);\\n         \\n        mp.clear();\\n        \\n        for(var ent:ls){\\n            mp.put(ent.getKey(),ent.getValue());\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean visit[] = new boolean[friends.length];\\n        q.add(id);\\n        for(int i = 0;i < level;i++){\\n            int size = q.size();\\n            for(;size != 0;--size){\\n                int n = q.poll();\\n                visit[n] = true;\\n                for(var c:friends[n]){\\n                    if(!visit[c]){\\n                        q.add(c);\\n                        visit[c] = true;\\n                    }\\n                }\\n            }\\n        }\\n        Map<String,Integer> mp = new LinkedHashMap<>();\\n        for(var f:q){\\n            for(var s:watchedVideos.get(f)){\\n                mp.put(s,mp.getOrDefault(s,0) + 1);\\n            }\\n        }\\n        sortByValue(mp,(e1,e2) -> {\\n            if(e1.getValue() != e2.getValue()) return e1.getValue() - e2.getValue();\\n            return e1.getKey().compareTo(e2.getKey());\\n        });\\n        return new ArrayList<>(mp.keySet());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    <K,V> void sortByValue(Map<K,V> mp,Comparator<Map.Entry<K,V>> c){\\n        List<Map.Entry<K,V>> ls = new ArrayList<>(mp.entrySet());\\n        \\n        Collections.sort(ls, c);\\n         \\n        mp.clear();\\n        \\n        for(var ent:ls){\\n            mp.put(ent.getKey(),ent.getValue());\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean visit[] = new boolean[friends.length];\\n        q.add(id);\\n        for(int i = 0;i < level;i++){\\n            int size = q.size();\\n            for(;size != 0;--size){\\n                int n = q.poll();\\n                visit[n] = true;\\n                for(var c:friends[n]){\\n                    if(!visit[c]){\\n                        q.add(c);\\n                        visit[c] = true;\\n                    }\\n                }\\n            }\\n        }\\n        Map<String,Integer> mp = new LinkedHashMap<>();\\n        for(var f:q){\\n            for(var s:watchedVideos.get(f)){\\n                mp.put(s,mp.getOrDefault(s,0) + 1);\\n            }\\n        }\\n        sortByValue(mp,(e1,e2) -> {\\n            if(e1.getValue() != e2.getValue()) return e1.getValue() - e2.getValue();\\n            return e1.getKey().compareTo(e2.getKey());\\n        });\\n        return new ArrayList<>(mp.keySet());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790407,
                "title": "python-bfs-sort",
                "content": "```\\ndef watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\td = defaultdict(list)\\n\\tdef bfs(id):\\n\\t\\tk = 0\\n\\t\\tqueue = [(id, k)] #id, level\\n\\t\\tvisited = set()\\n\\t\\twhile queue:\\n\\t\\t\\tnode, k = heappop(queue)\\n\\t\\t\\tif not node in visited:\\n\\t\\t\\t\\td[k] += watchedVideos[node]\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\tif k < level:\\n\\t\\t\\t\\tk += 1 \\n\\t\\t\\t\\tfor neighbor in friends[node]:\\n\\t\\t\\t\\t\\tif not neighbor in visited:\\n\\t\\t\\t\\t\\t\\theappush(queue, (neighbor, k))\\n\\tbfs(id)\\n\\ts = sorted(Counter(d[level]).items(), key=lambda kv: (kv[1], kv[0]))\\n\\tresult = []\\n\\tfor k, v in s:\\n\\t\\tresult.append(k)\\n\\treturn result\\n",
                "solutionTags": [],
                "code": "```\\ndef watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\td = defaultdict(list)\\n\\tdef bfs(id):\\n\\t\\tk = 0\\n\\t\\tqueue = [(id, k)] #id, level\\n\\t\\tvisited = set()\\n\\t\\twhile queue:\\n\\t\\t\\tnode, k = heappop(queue)\\n\\t\\t\\tif not node in visited:\\n\\t\\t\\t\\td[k] += watchedVideos[node]\\n\\t\\t\\tvisited.add(node)\\n\\t\\t\\tif k < level:\\n\\t\\t\\t\\tk += 1 \\n\\t\\t\\t\\tfor neighbor in friends[node]:\\n\\t\\t\\t\\t\\tif not neighbor in visited:\\n\\t\\t\\t\\t\\t\\theappush(queue, (neighbor, k))\\n\\tbfs(id)\\n\\ts = sorted(Counter(d[level]).items(), key=lambda kv: (kv[1], kv[0]))\\n\\tresult = []\\n\\tfor k, v in s:\\n\\t\\tresult.append(k)\\n\\treturn result\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2779957,
                "title": "python3-dijkstra-frequency-map",
                "content": "# Intuition\\nFind shortest Path from particular node to all other nodes means Dijkstra Algorithm.\\n\\n# Approach\\nFind Shortest path from given node to all nodes and keep checking if level == k  or not . if level == k then store all videos watched by that node in freq map.\\n\\n# Complexity\\n- Time complexity:\\nO(n) for traversing graph and O(logn) for each push operation into priority Queue ~ O(nlogn).\\n\\n- Space complexity:\\nO(n) for storing visited nodes and O(n) for priority Queue ~ O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        def comparator(a,b):\\n            if a[1] > b[1]:\\n                return 1\\n            elif a[1] < b[1]:\\n                return -1\\n            else:\\n                if a[0] > b[0]:\\n                    return 1\\n                else:\\n                    return -1\\n        vis = set()\\n        freq = defaultdict(int)\\n        pq = [[0,id]]\\n        while pq:\\n            dist,node = heappop(pq)\\n            if node not in vis:\\n                if dist == level:\\n                    for videos in watchedVideos[node]:\\n                        freq[videos]+=1\\n                else:\\n                    for it in friends[node]:\\n                        heappush(pq,[dist+1,it])\\n                vis.add(node)\\n        sorted_keys = sorted(freq.items(),key = cmp_to_key(comparator))\\n        ans = [key[0] for key in sorted_keys]\\n        return ans\\n            \\n\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        def comparator(a,b):\\n            if a[1] > b[1]:\\n                return 1\\n            elif a[1] < b[1]:\\n                return -1\\n            else:\\n                if a[0] > b[0]:\\n                    return 1\\n                else:\\n                    return -1\\n        vis = set()\\n        freq = defaultdict(int)\\n        pq = [[0,id]]\\n        while pq:\\n            dist,node = heappop(pq)\\n            if node not in vis:\\n                if dist == level:\\n                    for videos in watchedVideos[node]:\\n                        freq[videos]+=1\\n                else:\\n                    for it in friends[node]:\\n                        heappush(pq,[dist+1,it])\\n                vis.add(node)\\n        sorted_keys = sorted(freq.items(),key = cmp_to_key(comparator))\\n        ans = [key[0] for key in sorted_keys]\\n        return ans\\n            \\n\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752319,
                "title": "python-bfs-sort-the-hashmap-easy-to-understand-and-commented",
                "content": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        n, q = len(watchedVideos), deque([id])\\n        freq, visited = {}, set([id])\\n        current_level = 0\\n        \\n        # BFS for reaching the \"level\" of required friends\\n        while q and current_level < level:\\n            k = len(q)\\n            for _ in range(k):\\n                node = q.popleft()\\n                for nei in friends[node]:\\n                    if nei not in visited:\\n                        q.append(nei)\\n                        visited.add(nei)\\n            current_level += 1\\n        \\n        # Maintaining a map of videos watched by kth level friends and keeping their count\\n        while q:\\n            node = q.popleft()\\n            for vid in watchedVideos[node]:\\n                freq[vid] = 1 + freq.get(vid, 0)\\n        \\n        return sorted(freq.keys(), key = lambda x : (freq[x],x))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        n, q = len(watchedVideos), deque([id])\\n        freq, visited = {}, set([id])\\n        current_level = 0\\n        \\n        # BFS for reaching the \"level\" of required friends\\n        while q and current_level < level:\\n            k = len(q)\\n            for _ in range(k):\\n                node = q.popleft()\\n                for nei in friends[node]:\\n                    if nei not in visited:\\n                        q.append(nei)\\n                        visited.add(nei)\\n            current_level += 1\\n        \\n        # Maintaining a map of videos watched by kth level friends and keeping their count\\n        while q:\\n            node = q.popleft()\\n            for vid in watchedVideos[node]:\\n                freq[vid] = 1 + freq.get(vid, 0)\\n        \\n        return sorted(freq.keys(), key = lambda x : (freq[x],x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709976,
                "title": "swift-solution",
                "content": "```\\n// Get Watched Videos by Your Friends\\n// https://www.hackerrank.com/challenges/get-watched-videos-by-your-friends\\n\\nclass Solution {\\n    func watchedVideosByFriends(_ watchedVideos: [[String]], _ friends: [[Int]], _ id: Int, _ level: Int) -> [String] {\\n        var visited = [Bool](repeating: false, count: friends.count)\\n        var queue = [Int]()\\n        var result = [String]()\\n        var count = [String: Int]()\\n        queue.append(id)\\n        visited[id] = true\\n        var currentLevel = 0\\n        while !queue.isEmpty {\\n            let size = queue.count\\n            for _ in 0..<size {\\n                let current = queue.removeFirst()\\n                if currentLevel == level {\\n                    for video in watchedVideos[current] {\\n                        count[video, default: 0] += 1\\n                    }\\n                } else {\\n                    for friend in friends[current] {\\n                        if !visited[friend] {\\n                            queue.append(friend)\\n                            visited[friend] = true\\n                        }\\n                    }\\n                }\\n            }\\n            currentLevel += 1\\n        }\\n        result = count.sorted { $0.value == $1.value ? $0.key < $1.key : $0.value < $1.value }.map { $0.key }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// Get Watched Videos by Your Friends\\n// https://www.hackerrank.com/challenges/get-watched-videos-by-your-friends\\n\\nclass Solution {\\n    func watchedVideosByFriends(_ watchedVideos: [[String]], _ friends: [[Int]], _ id: Int, _ level: Int) -> [String] {\\n        var visited = [Bool](repeating: false, count: friends.count)\\n        var queue = [Int]()\\n        var result = [String]()\\n        var count = [String: Int]()\\n        queue.append(id)\\n        visited[id] = true\\n        var currentLevel = 0\\n        while !queue.isEmpty {\\n            let size = queue.count\\n            for _ in 0..<size {\\n                let current = queue.removeFirst()\\n                if currentLevel == level {\\n                    for video in watchedVideos[current] {\\n                        count[video, default: 0] += 1\\n                    }\\n                } else {\\n                    for friend in friends[current] {\\n                        if !visited[friend] {\\n                            queue.append(friend)\\n                            visited[friend] = true\\n                        }\\n                    }\\n                }\\n            }\\n            currentLevel += 1\\n        }\\n        result = count.sorted { $0.value == $1.value ? $0.key < $1.key : $0.value < $1.value }.map { $0.key }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701736,
                "title": "easy-to-understand-c-solution-with-comments-upvote-for-more",
                "content": "```\\n \\n vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        queue<int> q;\\n        vector<int> vis(friends.size(), 0);\\n        q.push(id);\\n        vis[id] = 1;\\n        int k, person;\\n        \\n        // find all the friends at given level\\n        while(level-- && q.size())\\n        {\\n            k = q.size();\\n            while(k--)\\n            {\\n                person=q.front(); q.pop();\\n                for(int frnd : friends[person])\\n                {\\n                    if(!vis[frnd])\\n                    {\\n                        vis[frnd] = 1;\\n                        q.push(frnd);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // now our queue contains all the friends at the level at which movies have to be selected\\n        \\n        map<string,int> freq;\\n        while(q.size())\\n        {\\n            k = q.front(); q.pop();\\n            for(string video : watchedVideos[k])\\n                freq[video]++;\\n        }\\n        vector<pair<int,string>> v;\\n        // for sorting them on the basis of their frequency store them in vector pair\\n        for(auto it : freq)\\n        {\\n            v.push_back({it.second, it.first});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        // now make another array to store the result\\n        vector<string> ans;\\n        for(auto it : v)\\n        {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\n \\n vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        queue<int> q;\\n        vector<int> vis(friends.size(), 0);\\n        q.push(id);\\n        vis[id] = 1;\\n        int k, person;\\n        \\n        // find all the friends at given level\\n        while(level-- && q.size())\\n        {\\n            k = q.size();\\n            while(k--)\\n            {\\n                person=q.front(); q.pop();\\n                for(int frnd : friends[person])\\n                {\\n                    if(!vis[frnd])\\n                    {\\n                        vis[frnd] = 1;\\n                        q.push(frnd);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // now our queue contains all the friends at the level at which movies have to be selected\\n        \\n        map<string,int> freq;\\n        while(q.size())\\n        {\\n            k = q.front(); q.pop();\\n            for(string video : watchedVideos[k])\\n                freq[video]++;\\n        }\\n        vector<pair<int,string>> v;\\n        // for sorting them on the basis of their frequency store them in vector pair\\n        for(auto it : freq)\\n        {\\n            v.push_back({it.second, it.first});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        // now make another array to store the result\\n        vector<string> ans;\\n        for(auto it : v)\\n        {\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683627,
                "title": "python-super-easy-bfs",
                "content": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        \\n        graph = collections.defaultdict(set)\\n        \\n        for i in range(len(friends)):\\n            graph[i].update(set(friends[i]))\\n            \\n            \\n        visit = set()\\n        queue = [id]\\n        \\n        l = 0\\n        count = collections.defaultdict(int)\\n        while queue:\\n            size = len(queue)\\n            for i in range(size):\\n                node = queue.pop(0)\\n                visit.add(node)\\n                for v in graph[node]:\\n                    if v not in visit:\\n                        queue.append(v)\\n                        visit.add(v)\\n            l +=1\\n            if l ==  level:\\n                break\\n        \\n        for q in queue:\\n            for w in watchedVideos[q]:\\n                count[w] +=1\\n                \\n        return sorted(count.keys(),key=lambda x:(count[x],x))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        \\n        graph = collections.defaultdict(set)\\n        \\n        for i in range(len(friends)):\\n            graph[i].update(set(friends[i]))\\n            \\n            \\n        visit = set()\\n        queue = [id]\\n        \\n        l = 0\\n        count = collections.defaultdict(int)\\n        while queue:\\n            size = len(queue)\\n            for i in range(size):\\n                node = queue.pop(0)\\n                visit.add(node)\\n                for v in graph[node]:\\n                    if v not in visit:\\n                        queue.append(v)\\n                        visit.add(v)\\n            l +=1\\n            if l ==  level:\\n                break\\n        \\n        for q in queue:\\n            for w in watchedVideos[q]:\\n                count[w] +=1\\n                \\n        return sorted(count.keys(),key=lambda x:(count[x],x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678321,
                "title": "python-bfs-sort-solution",
                "content": "```\\ndef watchedVideosByFriends(self, videos: List[List[str]], friends: List[List[int]], idx: int, level: int) -> List[str]:\\n\\td = [len(videos)+10]*len(videos)\\n\\td[idx] = 0\\n\\tq, step = deque([idx]), 1\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\ti = q.popleft()\\n\\t\\t\\tfor n in friends[i]:\\n\\t\\t\\t\\tif d[n]>step:\\n\\t\\t\\t\\t\\tq.append(n)\\n\\t\\t\\t\\t\\td[n] = step\\n\\t\\tstep += 1\\n\\n\\tcnter = defaultdict(int)\\n\\tfor i in range(len(videos)):\\n\\t\\tif d[i] == level:\\n\\t\\t\\tfor v in videos[i]:\\n\\t\\t\\t\\tcnter[v] += 1\\n\\treturn sorted(cnter.keys(),key=lambda x:(cnter[x],x))\\n```",
                "solutionTags": [],
                "code": "```\\ndef watchedVideosByFriends(self, videos: List[List[str]], friends: List[List[int]], idx: int, level: int) -> List[str]:\\n\\td = [len(videos)+10]*len(videos)\\n\\td[idx] = 0\\n\\tq, step = deque([idx]), 1\\n\\twhile(q):\\n\\t\\tfor _ in range(len(q)):\\n\\t\\t\\ti = q.popleft()\\n\\t\\t\\tfor n in friends[i]:\\n\\t\\t\\t\\tif d[n]>step:\\n\\t\\t\\t\\t\\tq.append(n)\\n\\t\\t\\t\\t\\td[n] = step\\n\\t\\tstep += 1\\n\\n\\tcnter = defaultdict(int)\\n\\tfor i in range(len(videos)):\\n\\t\\tif d[i] == level:\\n\\t\\t\\tfor v in videos[i]:\\n\\t\\t\\t\\tcnter[v] += 1\\n\\treturn sorted(cnter.keys(),key=lambda x:(cnter[x],x))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2671395,
                "title": "bfs-c-sorting-easy-solution",
                "content": "# Intuition BFS+Map Sorting \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   static  bool cmp(pair<string,int>&a,pair<string,int>&b){\\n    if(a.second>b.second){\\n        return false;\\n    }\\n    if(a.second==b.second){\\n        return a.first<b.first;\\n    }\\n    return true;\\n}\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        map<string,int> m;\\n        vector<int> vis(n,0);\\n        queue<int>q;\\n        q.push(id);\\n        vis[id]=1;\\n        int count=0;\\n        while(!q.empty()){\\n            int a=q.size();\\n            if(count!=level){\\n            while(a--){\\n                int x= q.front();\\n                q.pop();\\n                for(auto it: friends[x]){\\n             if(vis[it]==0){\\n                 q.push(it);\\n                 vis[it]=1;\\n             }\\n                }\\n            }}else{\\n             while(a--){\\n                int p=q.front();\\n                q.pop();\\n                for(int i=0;i<watchedVideos[p].size();i++ ){\\n                    m[watchedVideos[p][i]]++;\\n                }\\n                \\n                }\\n                break;;\\n            }\\n\\n            count++;\\n        }\\n        \\n        vector<pair<string ,int>> v;\\n        for(auto it : m){\\n            v.push_back({it.first,it.second});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n vector<string> ans;\\n for(auto it : v){\\n     ans.push_back(it.first);\\n }\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n   static  bool cmp(pair<string,int>&a,pair<string,int>&b){\\n    if(a.second>b.second){\\n        return false;\\n    }\\n    if(a.second==b.second){\\n        return a.first<b.first;\\n    }\\n    return true;\\n}\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        map<string,int> m;\\n        vector<int> vis(n,0);\\n        queue<int>q;\\n        q.push(id);\\n        vis[id]=1;\\n        int count=0;\\n        while(!q.empty()){\\n            int a=q.size();\\n            if(count!=level){\\n            while(a--){\\n                int x= q.front();\\n                q.pop();\\n                for(auto it: friends[x]){\\n             if(vis[it]==0){\\n                 q.push(it);\\n                 vis[it]=1;\\n             }\\n                }\\n            }}else{\\n             while(a--){\\n                int p=q.front();\\n                q.pop();\\n                for(int i=0;i<watchedVideos[p].size();i++ ){\\n                    m[watchedVideos[p][i]]++;\\n                }\\n                \\n                }\\n                break;;\\n            }\\n\\n            count++;\\n        }\\n        \\n        vector<pair<string ,int>> v;\\n        for(auto it : m){\\n            v.push_back({it.first,it.second});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n vector<string> ans;\\n for(auto it : v){\\n     ans.push_back(it.first);\\n }\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671302,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<string, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    static bool cmp(const pi&a, const pi&b){\\n        return (a.second==b.second?a.first<b.first:a.second<b.second);\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>&vid, vector<vector<int>>&f, int id, int level) {\\n        vi(bool)vis(f.size());\\n        list<ll>l={id};\\n        vis[id]=true;\\n        for(ll k=0;k<level;++k){\\n            ll sz=l.size();\\n            while(sz--){\\n                ll nd=l.front();\\n                l.pop_front();\\n                vis[nd]=true;\\n                for(ll child:f[nd]){\\n                    if(!vis[child]){\\n                        l.pb(child);\\n                        vis[child]=true;\\n                    }\\n                }\\n            }\\n        }\\n        unordered_map<string, ll>ump;\\n        for(ll nd:l){\\n                for(const string&v:vid[nd]){\\n                    ++ump[v];\\n                }\\n        }\\n        vi(pi)v(begin(ump), end(ump));\\n        sort(begin(v), end(v), cmp);\\n        vi(string)res(v.size());\\n        for(ll i=0;i<v.size();++i){\\n            res[i]=v[i].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\ntypedef pair<string, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    static bool cmp(const pi&a, const pi&b){\\n        return (a.second==b.second?a.first<b.first:a.second<b.second);\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>&vid, vector<vector<int>>&f, int id, int level) {\\n        vi(bool)vis(f.size());\\n        list<ll>l={id};\\n        vis[id]=true;\\n        for(ll k=0;k<level;++k){\\n            ll sz=l.size();\\n            while(sz--){\\n                ll nd=l.front();\\n                l.pop_front();\\n                vis[nd]=true;\\n                for(ll child:f[nd]){\\n                    if(!vis[child]){\\n                        l.pb(child);\\n                        vis[child]=true;\\n                    }\\n                }\\n            }\\n        }\\n        unordered_map<string, ll>ump;\\n        for(ll nd:l){\\n                for(const string&v:vid[nd]){\\n                    ++ump[v];\\n                }\\n        }\\n        vi(pi)v(begin(ump), end(ump));\\n        sort(begin(v), end(v), cmp);\\n        vi(string)res(v.size());\\n        for(ll i=0;i<v.size();++i){\\n            res[i]=v[i].first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664409,
                "title": "python-simple-bfs-hashmap",
                "content": "\\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n        stack, total, visited = [id], 0, {id}\\n        \\n        while stack and total < level:\\n            temp = set()\\n            \\n            for i in stack:\\n                for j in friends[i]:\\n                    if j not in visited:\\n                        temp.add(j)\\n                        visited.add(j)\\n                        \\n            total += 1\\n            stack = temp\\n            \\n        res = []\\n        \\n        for i in stack:\\n            res.extend(watchedVideos[i])\\n            \\n        dict1 = Counter(res)\\n        \\n        ans = [(val,key) for key,val in dict1.items()]\\n        \\n        ans.sort(key = lambda x: (x[0],x[1]))\\n        \\n        return [i[1] for i in ans]",
                "solutionTags": [],
                "code": "\\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n        stack, total, visited = [id], 0, {id}\\n        \\n        while stack and total < level:\\n            temp = set()\\n            \\n            for i in stack:\\n                for j in friends[i]:\\n                    if j not in visited:\\n                        temp.add(j)\\n                        visited.add(j)\\n                        \\n            total += 1\\n            stack = temp\\n            \\n        res = []\\n        \\n        for i in stack:\\n            res.extend(watchedVideos[i])\\n            \\n        dict1 = Counter(res)\\n        \\n        ans = [(val,key) for key,val in dict1.items()]\\n        \\n        ans.sort(key = lambda x: (x[0],x[1]))\\n        \\n        return [i[1] for i in ans]",
                "codeTag": "Python3"
            },
            {
                "id": 2640208,
                "title": "c-bfs-sol-easy-sorting-sol-using-unordered-map-sol",
                "content": "```\\nclass Solution {\\n    static bool sortfreq(const pair<int,string> &a,const pair<int,string> &b){\\n        return a.first==b.first? a.second<b.second: a.first<b.first;\\n    }\\n    \\n    unordered_map<string,int> bfs(vector<vector<int>>& friends, int level,int id,vector<vector<string>>& watchedVideos){\\n        queue<int> q;q.push(id);\\n        unordered_map<int,bool> vis;\\n        vis[id] = true;int c = 0;\\n        while(q.size()){\\n            int sz = q.size();\\n            while(sz--){\\n                if(c==level) {\\n                    unordered_map<string,int> mp;\\n                    while(q.size()){\\n                        int x = q.front();q.pop();\\n                        for(auto it:watchedVideos[x])mp[it]++;\\n                    }return mp;\\n                }\\n                int x = q.front(); q.pop();\\n                for(auto frnd:friends[x])if(vis.find(frnd)==vis.end()) q.push(frnd),vis[frnd]=true;\\n            }c++;\\n        }return {};\\n        \\n    }\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        unordered_map<string,int> frndList = bfs(friends,level,id,watchedVideos);\\n\\t\\tvector<pair<int,string>> sortans; vector<string> ans;\\n        for(auto it:frndList) sortans.push_back({it.second,it.first});\\n        sort(sortans.begin(),sortans.end(),sortfreq);\\n        for(auto it:sortans) ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool sortfreq(const pair<int,string> &a,const pair<int,string> &b){\\n        return a.first==b.first? a.second<b.second: a.first<b.first;\\n    }\\n    \\n    unordered_map<string,int> bfs(vector<vector<int>>& friends, int level,int id,vector<vector<string>>& watchedVideos){\\n        queue<int> q;q.push(id);\\n        unordered_map<int,bool> vis;\\n        vis[id] = true;int c = 0;\\n        while(q.size()){\\n            int sz = q.size();\\n            while(sz--){\\n                if(c==level) {\\n                    unordered_map<string,int> mp;\\n                    while(q.size()){\\n                        int x = q.front();q.pop();\\n                        for(auto it:watchedVideos[x])mp[it]++;\\n                    }return mp;\\n                }\\n                int x = q.front(); q.pop();\\n                for(auto frnd:friends[x])if(vis.find(frnd)==vis.end()) q.push(frnd),vis[frnd]=true;\\n            }c++;\\n        }return {};\\n        \\n    }\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        unordered_map<string,int> frndList = bfs(friends,level,id,watchedVideos);\\n\\t\\tvector<pair<int,string>> sortans; vector<string> ans;\\n        for(auto it:frndList) sortans.push_back({it.second,it.first});\\n        sort(sortans.begin(),sortans.end(),sortfreq);\\n        for(auto it:sortans) ans.push_back(it.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632046,
                "title": "python-solution-straightforward-bfs",
                "content": "```\\nclass Solution:\\n    # Again, another BFS question\\n    # Just traverse friends level by level, record the videos watched when we reach k and return the sorted list\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        dq, n, l, hash_table = deque(), len(friends), 0, {}\\n        visited = [False for i in range(n)]\\n        dq.append(id)\\n        visited[id] = True\\n        while dq:\\n            for i in range(len(dq)):\\n                fd = dq.popleft()\\n                if l == level:\\n                    for vid in watchedVideos[fd]:\\n                        hash_table[vid] = hash_table.get(vid,0) + 1\\n                for nxt in friends[fd]:\\n                    if not visited[nxt]:\\n                        visited[nxt] = True\\n                        dq.append(nxt)\\n            if l == level:\\n                key_values = sorted([[k, v] for k, v in hash_table.items()], key = lambda x: [x[1], x[0]])\\n                return [x[0] for x in key_values]\\n            l += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Again, another BFS question\\n    # Just traverse friends level by level, record the videos watched when we reach k and return the sorted list\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        dq, n, l, hash_table = deque(), len(friends), 0, {}\\n        visited = [False for i in range(n)]\\n        dq.append(id)\\n        visited[id] = True\\n        while dq:\\n            for i in range(len(dq)):\\n                fd = dq.popleft()\\n                if l == level:\\n                    for vid in watchedVideos[fd]:\\n                        hash_table[vid] = hash_table.get(vid,0) + 1\\n                for nxt in friends[fd]:\\n                    if not visited[nxt]:\\n                        visited[nxt] = True\\n                        dq.append(nxt)\\n            if l == level:\\n                key_values = sorted([[k, v] for k, v in hash_table.items()], key = lambda x: [x[1], x[0]])\\n                return [x[0] for x in key_values]\\n            l += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603113,
                "title": "python3-bfs-solution",
                "content": "```\\nfrom collections import deque, defaultdict\\nfrom functools import cmp_to_key\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, WV: List[List[str]], F: List[List[int]], id: int, k: int) -> List[str]:\\n        N = len(WV)\\n        q = deque([(0, id)])\\n        used = [False for _ in range(N)]\\n        mem = defaultdict(int)\\n        while len(q) > 0:\\n            level, i = q.popleft()\\n            if used[i]:\\n                continue\\n            used[i] = True\\n            \\n            if level == k:\\n                for v in WV[i]:\\n                    mem[v] += 1\\n                continue\\n                      \\n            for j in F[i]:\\n                if used[j]:\\n                    continue\\n                q.append((level + 1, j))                    \\n        \\n        ret = list(mem.keys())\\n            \\n        def comp(a, b):\\n            if mem[a] < mem[b]:\\n                return -1\\n            elif mem[a] > mem[b]:\\n                return 1\\n            else:\\n                if a <= b:\\n                    return -1\\n                else:\\n                    return 1\\n                \\n        ret.sort(key=cmp_to_key(comp))\\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque, defaultdict\\nfrom functools import cmp_to_key\\n\\nclass Solution:\\n    def watchedVideosByFriends(self, WV: List[List[str]], F: List[List[int]], id: int, k: int) -> List[str]:\\n        N = len(WV)\\n        q = deque([(0, id)])\\n        used = [False for _ in range(N)]\\n        mem = defaultdict(int)\\n        while len(q) > 0:\\n            level, i = q.popleft()\\n            if used[i]:\\n                continue\\n            used[i] = True\\n            \\n            if level == k:\\n                for v in WV[i]:\\n                    mem[v] += 1\\n                continue\\n                      \\n            for j in F[i]:\\n                if used[j]:\\n                    continue\\n                q.append((level + 1, j))                    \\n        \\n        ret = list(mem.keys())\\n            \\n        def comp(a, b):\\n            if mem[a] < mem[b]:\\n                return -1\\n            elif mem[a] > mem[b]:\\n                return 1\\n            else:\\n                if a <= b:\\n                    return -1\\n                else:\\n                    return 1\\n                \\n        ret.sort(key=cmp_to_key(comp))\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540070,
                "title": "why-you-need-sorted-smh",
                "content": "# Still wondering why they needed sorted answer (T T)\\n\\n```\\ntypedef pair<int, string> pi;\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& videos, vector<vector<int>>& graph, int id, int level) {\\n        queue<int> q; q.push(id);\\n        int lvl = 0, n = videos.size();\\n        vector<int> v(n,0);\\n        v[id] = 1;\\n        while(lvl < level){\\n            int sz = q.size();\\n            while(sz--){\\n                int src = q.front();\\n                q.pop();\\n                for(int i=0; i<graph[src].size(); i++){\\n                    int dst = graph[src][i];\\n                    if(!v[dst]){\\n                        v[dst] = 1;\\n                        q.push(dst);\\n                    }\\n                }\\n            }\\n            lvl++;\\n        }\\n        map<string, int> m;\\n        while(!q.empty()){\\n            int v = q.front(); q.pop();\\n            for(int i=0; i<videos[v].size(); i++){\\n                m[videos[v][i]]++;\\n            }\\n        }\\n\\t\\t// Use any data structure you want, you can use\\n\\t\\t// vector of pairs -> sort\\n\\t\\t// set of pairs\\n\\t\\t// multimap\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        for(auto i:m){\\n            pq.push({i.second, i.first});\\n        }\\n        vector<string> ans;\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef pair<int, string> pi;\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& videos, vector<vector<int>>& graph, int id, int level) {\\n        queue<int> q; q.push(id);\\n        int lvl = 0, n = videos.size();\\n        vector<int> v(n,0);\\n        v[id] = 1;\\n        while(lvl < level){\\n            int sz = q.size();\\n            while(sz--){\\n                int src = q.front();\\n                q.pop();\\n                for(int i=0; i<graph[src].size(); i++){\\n                    int dst = graph[src][i];\\n                    if(!v[dst]){\\n                        v[dst] = 1;\\n                        q.push(dst);\\n                    }\\n                }\\n            }\\n            lvl++;\\n        }\\n        map<string, int> m;\\n        while(!q.empty()){\\n            int v = q.front(); q.pop();\\n            for(int i=0; i<videos[v].size(); i++){\\n                m[videos[v][i]]++;\\n            }\\n        }\\n\\t\\t// Use any data structure you want, you can use\\n\\t\\t// vector of pairs -> sort\\n\\t\\t// set of pairs\\n\\t\\t// multimap\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        for(auto i:m){\\n            pq.push({i.second, i.first});\\n        }\\n        vector<string> ans;\\n        while(!pq.empty()){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477325,
                "title": "java-simple-solution-using-bfs",
                "content": "```\\nclass Solution {\\n    public void bfs(List<List<String>> watchedVideos, int[][] friends, int id, int level, boolean[] visited, Map<String, Integer> videoFreq) {\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.addLast(new int[] {id,0}); // Storing id and level\\n        visited[id] = true; // Marking as visited\\n        while(!queue.isEmpty()){\\n            int[] personId = queue.pollFirst();\\n            if(personId[1]==level){ // If this is the required level increase all the watched moves frequency by 1 in map\\n                List<String> videos = watchedVideos.get(personId[0]);\\n                for(String video: videos){\\n                    videoFreq.put(video, videoFreq.getOrDefault(video,0)+1);\\n                }\\n            }\\n            else{ // No need to go to a level beyond required level\\n                for(int friend: friends[personId[0]]){ // BFS\\n                    if(!visited[friend]){ // If not visited the add it to queue\\n                        queue.addLast(new int[] {friend,personId[1]+1});\\n                        visited[friend] = true; // Marking as visited\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Map<String, Integer> videoFreq = new HashMap<>();\\n        boolean[] visited = new boolean[friends.length];\\n        bfs(watchedVideos, friends, id, level, visited, videoFreq);\\n        List<Map.Entry<String, Integer>> videoFreqList= new ArrayList<>(videoFreq.entrySet()); // Convert map to a list\\n        Collections.sort(videoFreqList, (e1, e2)-> e1.getValue()==e2.getValue()?e1.getKey().compareTo(e2.getKey()):e1.getValue()-e2.getValue()); // Sort based on frequency i.e. value if both are same then based on the movie i.e. key\\n        List<String> ans = new ArrayList<>();\\n        for(Map.Entry<String, Integer> e: videoFreqList){\\n            ans.add(e.getKey()); // Store all the movies in the asn list\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public void bfs(List<List<String>> watchedVideos, int[][] friends, int id, int level, boolean[] visited, Map<String, Integer> videoFreq) {\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.addLast(new int[] {id,0}); // Storing id and level\\n        visited[id] = true; // Marking as visited\\n        while(!queue.isEmpty()){\\n            int[] personId = queue.pollFirst();\\n            if(personId[1]==level){ // If this is the required level increase all the watched moves frequency by 1 in map\\n                List<String> videos = watchedVideos.get(personId[0]);\\n                for(String video: videos){\\n                    videoFreq.put(video, videoFreq.getOrDefault(video,0)+1);\\n                }\\n            }\\n            else{ // No need to go to a level beyond required level\\n                for(int friend: friends[personId[0]]){ // BFS\\n                    if(!visited[friend]){ // If not visited the add it to queue\\n                        queue.addLast(new int[] {friend,personId[1]+1});\\n                        visited[friend] = true; // Marking as visited\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Map<String, Integer> videoFreq = new HashMap<>();\\n        boolean[] visited = new boolean[friends.length];\\n        bfs(watchedVideos, friends, id, level, visited, videoFreq);\\n        List<Map.Entry<String, Integer>> videoFreqList= new ArrayList<>(videoFreq.entrySet()); // Convert map to a list\\n        Collections.sort(videoFreqList, (e1, e2)-> e1.getValue()==e2.getValue()?e1.getKey().compareTo(e2.getKey()):e1.getValue()-e2.getValue()); // Sort based on frequency i.e. value if both are same then based on the movie i.e. key\\n        List<String> ans = new ArrayList<>();\\n        for(Map.Entry<String, Integer> e: videoFreqList){\\n            ans.add(e.getKey()); // Store all the movies in the asn list\\n         }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438590,
                "title": "c-solution-bfs",
                "content": "\\n```\\n vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& f, int id, int level) \\n    {\\n         vector<int>q ;\\n        q.push_back(id) ;\\n        vector<bool>vis(f.size(),false) ;\\n        vis[id]=true ;\\n        int temp=0 ;\\n        while(q.size()!=0 && temp!=level)\\n        {\\n            int i=0 ;vector<int>t;\\n            while(q.size()>i)\\n            {\\n                vector<int>ds=f[q[i]] ;\\n                for(int j=0;j<ds.size();j++)\\n                {\\n                    if(vis[ds[j]]==false)\\n                    {vis[ds[j]]=true ;\\n                        t.push_back(ds[j]) ;\\n                    }\\n                }\\n                i++ ;\\n            }\\n            temp++ ;\\n            q=t ;\\n        }\\n     cout<<q.size();\\n        map<string,int>st ;\\n        int i=0 ;\\n        while(i<q.size())\\n        {\\n            int x=q[i] ;\\n            vector<string>ds=wv[x] ;\\n            for(int k=0;k<ds.size();k++)\\n                st[ds[k]]++ ;\\n            \\n            i++ ;\\n        }\\n\\n        priority_queue<pair<int,string>,vector<pair<int,string>>, greater<pair<int,string>>>sp ;\\n        for(auto it=st.begin();it!=st.end();it++)\\n        {\\n            sp.push(make_pair(it->second,it->first)) ;\\n        }\\n        vector<string>dp ;\\n        while(!sp.empty())\\n        {\\n            pair<int,string>a=sp.top() ;\\n            sp.pop() ;\\n            dp.push_back(a.second) ;\\n        }\\n        return dp ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& f, int id, int level) \\n    {\\n         vector<int>q ;\\n        q.push_back(id) ;\\n        vector<bool>vis(f.size(),false) ;\\n        vis[id]=true ;\\n        int temp=0 ;\\n        while(q.size()!=0 && temp!=level)\\n        {\\n            int i=0 ;vector<int>t;\\n            while(q.size()>i)\\n            {\\n                vector<int>ds=f[q[i]] ;\\n                for(int j=0;j<ds.size();j++)\\n                {\\n                    if(vis[ds[j]]==false)\\n                    {vis[ds[j]]=true ;\\n                        t.push_back(ds[j]) ;\\n                    }\\n                }\\n                i++ ;\\n            }\\n            temp++ ;\\n            q=t ;\\n        }\\n     cout<<q.size();\\n        map<string,int>st ;\\n        int i=0 ;\\n        while(i<q.size())\\n        {\\n            int x=q[i] ;\\n            vector<string>ds=wv[x] ;\\n            for(int k=0;k<ds.size();k++)\\n                st[ds[k]]++ ;\\n            \\n            i++ ;\\n        }\\n\\n        priority_queue<pair<int,string>,vector<pair<int,string>>, greater<pair<int,string>>>sp ;\\n        for(auto it=st.begin();it!=st.end();it++)\\n        {\\n            sp.push(make_pair(it->second,it->first)) ;\\n        }\\n        vector<string>dp ;\\n        while(!sp.empty())\\n        {\\n            pair<int,string>a=sp.top() ;\\n            sp.pop() ;\\n            dp.push_back(a.second) ;\\n        }\\n        return dp ;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2429622,
                "title": "clean-solution-using-bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    queue<int> bfs(int node, vector<vector<int>>& adj, int n, int level) {\\n        vector<int> vis(n, 0);\\n        queue<int>q;\\n        \\n        q.push(node);\\n        int dist = 0;\\n        vis[node] = 1;\\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            if(dist == level) break;\\n            dist++;\\n            \\n            for(int i = 0; i < size; i++) {\\n                auto u = q.front();\\n                q.pop();\\n                \\n                for(auto &v: adj[u]) {\\n                    if(!vis[v]) {\\n                        q.push(v);\\n                        vis[v] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return q;\\n    }\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        int n = friends.size();\\n        vector<string>ans;\\n        set<pair<int, string>>v;\\n        queue<int>levelFriends = bfs(id, friends, n, level);\\n        unordered_map<string, int>m;\\n        \\n        \\n        while(!levelFriends.empty()) {\\n            int i = levelFriends.front();\\n            levelFriends.pop();\\n            for(auto &it: watchedVideos[i]) m[it]++;\\n        }\\n          \\n        for(auto &it: m) {\\n            v.insert({it.second, it.first});\\n        }\\n        \\n        for(auto &it: v) {\\n            ans.push_back(it.second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    queue<int> bfs(int node, vector<vector<int>>& adj, int n, int level) {\\n        vector<int> vis(n, 0);\\n        queue<int>q;\\n        \\n        q.push(node);\\n        int dist = 0;\\n        vis[node] = 1;\\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            if(dist == level) break;\\n            dist++;\\n            \\n            for(int i = 0; i < size; i++) {\\n                auto u = q.front();\\n                q.pop();\\n                \\n                for(auto &v: adj[u]) {\\n                    if(!vis[v]) {\\n                        q.push(v);\\n                        vis[v] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return q;\\n    }\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        int n = friends.size();\\n        vector<string>ans;\\n        set<pair<int, string>>v;\\n        queue<int>levelFriends = bfs(id, friends, n, level);\\n        unordered_map<string, int>m;\\n        \\n        \\n        while(!levelFriends.empty()) {\\n            int i = levelFriends.front();\\n            levelFriends.pop();\\n            for(auto &it: watchedVideos[i]) m[it]++;\\n        }\\n          \\n        for(auto &it: m) {\\n            v.insert({it.second, it.first});\\n        }\\n        \\n        for(auto &it: v) {\\n            ans.push_back(it.second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427750,
                "title": "c-bfs",
                "content": "```\\nvector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>&fd, int id, int level) {\\n        \\n        vector<string>res;\\n        unordered_map<int,vector<int> >mp;\\n        int n=wv.size();\\n        vector<bool>vis(n,false);\\n        \\n        for(int i=0;i<n;i++){\\n           \\n            for(auto x:fd[i])\\n                mp[i].push_back(x);\\n            \\n        }\\n        \\n        queue<int>q;\\n        q.push(id);\\n         vis[id]=true;\\n        \\n        vector<int>a;\\n        \\n        int l=0;\\n        while(!q.empty()){                        \\n            \\n           int n=q.size();\\n            \\n            while(n--){\\n                \\n                 int u=q.front();\\n                 q.pop();\\n            \\n                \\n                if(l==level){\\n                    a.push_back(u);\\n                    continue;\\n                }\\n                for(auto x:mp[u]){\\n                    if(vis[x]==false){\\n                        vis[x]=true;\\n                        q.push(x);\\n                    }\\n                }\\n                \\n            }\\n            if(l==level)break;\\n            l++;\\n        }\\n        \\n        unordered_map<string,int>mpp;\\n        \\n        for(auto x:a){\\n            \\n            for(auto y:wv[x]){\\n                mpp[y]++;\\n            }\\n        }\\n        \\n        vector< pair<int,string> >pr;\\n        \\n        for(auto x:mpp){\\n            \\n            pr.push_back({x.second,x.first});\\n            \\n        }\\n        sort(pr.begin(),pr.end());\\n        \\n        for(auto x:pr)res.push_back(x.second);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>&fd, int id, int level) {\\n        \\n        vector<string>res;\\n        unordered_map<int,vector<int> >mp;\\n        int n=wv.size();\\n        vector<bool>vis(n,false);\\n        \\n        for(int i=0;i<n;i++){\\n           \\n            for(auto x:fd[i])\\n                mp[i].push_back(x);\\n            \\n        }\\n        \\n        queue<int>q;\\n        q.push(id);\\n         vis[id]=true;\\n        \\n        vector<int>a;\\n        \\n        int l=0;\\n        while(!q.empty()){                        \\n            \\n           int n=q.size();\\n            \\n            while(n--){\\n                \\n                 int u=q.front();\\n                 q.pop();\\n            \\n                \\n                if(l==level){\\n                    a.push_back(u);\\n                    continue;\\n                }\\n                for(auto x:mp[u]){\\n                    if(vis[x]==false){\\n                        vis[x]=true;\\n                        q.push(x);\\n                    }\\n                }\\n                \\n            }\\n            if(l==level)break;\\n            l++;\\n        }\\n        \\n        unordered_map<string,int>mpp;\\n        \\n        for(auto x:a){\\n            \\n            for(auto y:wv[x]){\\n                mpp[y]++;\\n            }\\n        }\\n        \\n        vector< pair<int,string> >pr;\\n        \\n        for(auto x:mpp){\\n            \\n            pr.push_back({x.second,x.first});\\n            \\n        }\\n        sort(pr.begin(),pr.end());\\n        \\n        for(auto x:pr)res.push_back(x.second);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2404741,
                "title": "python-simple-bfs-then-sort",
                "content": "```\\nclass Solution(object):\\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n        \"\"\"\\n        :type watchedVideos: List[List[str]]\\n        :type friends: List[List[int]]\\n        :type id: int\\n        :type level: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        \\n        \\n        \\n        \\n        def bfs(start):\\n            q = collections.deque([start])\\n            seen = set([start])\\n            \\n            lvln = 0\\n            while q:\\n                \\n                lq = len(q)\\n                \\n                lvl = []\\n\\n\\n                for i in range(lq):\\n                    curr = q.popleft()\\n                    \\n                    \\n                    \\n                    if lvln == level:\\n                        lvl.append(curr)\\n                        \\n                        \\n                        \\n                        \\n                    for idx in friends[curr]:\\n                        if idx not in seen:\\n                            q.append(idx)\\n                            seen.add(idx)\\n                    \\n                    \\n                    \\n                if lvln == level:\\n                    return lvl\\n                    \\n                    \\n                lvln+=1\\n        \\n        freq={}\\n        for friendid in bfs(id):\\n            \\n            for video in watchedVideos[friendid]:\\n                freq[video] = freq.get(video,0)+1\\n                \\n                \\n        \\n        return [v[0] for v in sorted(freq.items(),key = lambda x:(x[1],x[0])) ]\\n            \\n                    \\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution(object):\\n    def watchedVideosByFriends(self, watchedVideos, friends, id, level):\\n        \"\"\"\\n        :type watchedVideos: List[List[str]]\\n        :type friends: List[List[int]]\\n        :type id: int\\n        :type level: int\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        \\n        \\n        \\n        \\n        def bfs(start):\\n            q = collections.deque([start])\\n            seen = set([start])\\n            \\n            lvln = 0\\n            while q:\\n                \\n                lq = len(q)\\n                \\n                lvl = []\\n\\n\\n                for i in range(lq):\\n                    curr = q.popleft()\\n                    \\n                    \\n                    \\n                    if lvln == level:\\n                        lvl.append(curr)\\n                        \\n                        \\n                        \\n                        \\n                    for idx in friends[curr]:\\n                        if idx not in seen:\\n                            q.append(idx)\\n                            seen.add(idx)\\n                    \\n                    \\n                    \\n                if lvln == level:\\n                    return lvl\\n                    \\n                    \\n                lvln+=1\\n        \\n        freq={}",
                "codeTag": "Java"
            },
            {
                "id": 2389234,
                "title": "c-bfs",
                "content": "class Solution {\\npublic:\\n    static bool cmp(const pair<int,string> &a,const pair<int,string> &b){\\n        if (a.first==b.first){\\n            return a.second<b.second;\\n        }\\n        else{\\n            return a.first<b.first;\\n        }\\n    }\\n    vector<int> adj[1005];\\n    int vis[1005];\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& video, vector<vector<int>>& v, int id, int level) {\\n        int i,j;\\n        for (i=0; i<v.size(); i++){\\n            for (j=0; j<v[i].size(); j++){\\n                adj[i].push_back(v[i][j]);\\n                adj[v[i][j]].push_back(i);\\n            }\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({id,0});\\n        map<string,int> mp;\\n        while (!q.empty()){\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            if (p.second==level){\\n              for (auto it=video[p.first].begin();it!=video[p.first].end();it++){\\n                    \\n                    mp[*it]++;\\n                }\\n                continue;\\n            }\\n            vis[p.first]=1;\\n            for(auto it: adj[p.first]){\\n                if (!vis[it]){\\n                  q.push({it,p.second+1});\\n                 vis[it]=1;\\n                }\\n            }\\n        }\\n        vector<pair<int,string>> temp;\\n        for (auto it: mp){\\n            temp.push_back({it.second,it.first});\\n        }\\n        sort(temp.begin(),temp.end(),cmp);\\n        vector<string> ans;\\n        for (auto it: temp){\\n            ans.push_back(it.second);\\n        }\\n        \\n     return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    static bool cmp(const pair<int,string> &a,const pair<int,string> &b){\\n        if (a.first==b.first){\\n            return a.second<b.second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2355161,
                "title": "python-3-level-by-level-bfs",
                "content": "\\tclass Solution:\\n\\t\\tdef watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\t\\t\\tq=[id]\\n\\t\\t\\tvis=set([id])\\n\\t\\t\\tl=0\\n\\t\\t\\twhile l<level:\\n\\t\\t\\t\\tnew_q=[]\\n\\t\\t\\t\\tfor x in q:\\n\\t\\t\\t\\t\\tfor friend in friends[x]:\\n\\t\\t\\t\\t\\t\\tif not friend in vis:\\n\\t\\t\\t\\t\\t\\t\\tvis.add(friend)\\n\\t\\t\\t\\t\\t\\t\\tnew_q.append(friend)\\n\\t\\t\\t\\tq=new_q\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\ta=Counter()\\n\\t\\t\\tfor x in q:\\n\\t\\t\\t\\tfor vids in watchedVideos[x]:\\n\\t\\t\\t\\t\\ta[vids]+=1\\n\\t\\t\\tA=sorted([[a[x],x] for x in a])\\n\\t\\t\\treturn [x[1] for x in A]",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\t\\t\\tq=[id]\\n\\t\\t\\tvis=set([id])\\n\\t\\t\\tl=0\\n\\t\\t\\twhile l<level:\\n\\t\\t\\t\\tnew_q=[]\\n\\t\\t\\t\\tfor x in q:\\n\\t\\t\\t\\t\\tfor friend in friends[x]:\\n\\t\\t\\t\\t\\t\\tif not friend in vis:\\n\\t\\t\\t\\t\\t\\t\\tvis.add(friend)\\n\\t\\t\\t\\t\\t\\t\\tnew_q.append(friend)\\n\\t\\t\\t\\tq=new_q\\n\\t\\t\\t\\tl+=1\\n\\t\\t\\ta=Counter()\\n\\t\\t\\tfor x in q:\\n\\t\\t\\t\\tfor vids in watchedVideos[x]:\\n\\t\\t\\t\\t\\ta[vids]+=1\\n\\t\\t\\tA=sorted([[a[x],x] for x in a])\\n\\t\\t\\treturn [x[1] for x in A]",
                "codeTag": "Java"
            },
            {
                "id": 2333965,
                "title": "bfs-hashing-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++){\\n            for(int j : friends[i]){\\n                adj[i].push_back(j);\\n            }\\n        }\\n        queue<int> q;\\n        vector<bool> vis(n,false);\\n        vis[id] = true;\\n        int cur = 0;\\n        q.push(id);\\n        while(!q.empty()){\\n            int s=q.size();\\n            if(cur  == level){ \\n                // vector<string> test;\\n                // test.push_back(to_string(99));\\n                // return test;\\n                break;\\n            }\\n\\n            while(s--){\\n                int u = q.front();\\n                q.pop();\\n                for(int v:adj[u]){\\n                    if(vis[v] == false){\\n                        vis[v] = true;\\n                        q.push(v);\\n                    }\\n                }\\n            }            \\n            cur++;\\n        }\\n        \\n        map<string,int> m;\\n        while(!q.empty()){\\n            vector<string> v = watchedVideos[q.front()];\\n            q.pop();\\n            for(string st : v)\\n                m[st]++;\\n        }\\n        \\n        vector<pair<int,string>> v;\\n        for(auto a:m){\\n            v.push_back({a.second,a.first});\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        vector<string> ans;\\n        for(auto p:v){\\n            ans.push_back(p.second);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++){\\n            for(int j : friends[i]){\\n                adj[i].push_back(j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2260333,
                "title": "java-bfs-stream",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int currlevel = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> hs = new HashSet<>();\\n        hs.add(id);\\n        for(int i = 0; i < friends[id].length; i++) {\\n            queue.offer(friends[id][i]);\\n            hs.add(friends[id][i]);\\n        }\\n        Map<String, Integer> freq = new HashMap<>();\\n        while(currlevel != level) {\\n            int size = queue.size();\\n            while(size > 0) {\\n                int polledId = queue.poll();\\n                if(currlevel + 1 == level) {\\n                    for(int i = 0; i < watchedVideos.get(polledId).size(); i++) {\\n                        freq.put(watchedVideos.get(polledId).get(i), freq.getOrDefault(watchedVideos.get(polledId).get(i), 0) + 1);\\n                    }\\n                } else {\\n                    // push into queue\\n                    for(int i = 0; i < friends[polledId].length; i++) {\\n                        if(!hs.contains(friends[polledId][i])) {\\n                            queue.offer(friends[polledId][i]);\\n                            hs.add(friends[polledId][i]);\\n                        } \\n                    }\\n                }\\n                size--;\\n            }\\n            currlevel++;\\n        }\\n        \\n        Comparator<Map.Entry<String, Integer>> comparator = (e1, e2) -> {\\n            int i = e1.getValue().compareTo(e2.getValue());\\n            if (i == 0) {\\n                return e1.getKey().compareTo(e2.getKey());\\n            } else {\\n                return i;\\n            }\\n        };\\n        \\n        List<String> ans = freq.entrySet()\\n                .stream()\\n                .sorted(comparator)\\n                .map(e -> e.getKey())\\n                .collect(Collectors.toList());\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int currlevel = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        Set<Integer> hs = new HashSet<>();\\n        hs.add(id);\\n        for(int i = 0; i < friends[id].length; i++) {\\n            queue.offer(friends[id][i]);\\n            hs.add(friends[id][i]);\\n        }\\n        Map<String, Integer> freq = new HashMap<>();\\n        while(currlevel != level) {\\n            int size = queue.size();\\n            while(size > 0) {\\n                int polledId = queue.poll();\\n                if(currlevel + 1 == level) {\\n                    for(int i = 0; i < watchedVideos.get(polledId).size(); i++) {\\n                        freq.put(watchedVideos.get(polledId).get(i), freq.getOrDefault(watchedVideos.get(polledId).get(i), 0) + 1);\\n                    }\\n                } else {\\n                    // push into queue\\n                    for(int i = 0; i < friends[polledId].length; i++) {\\n                        if(!hs.contains(friends[polledId][i])) {\\n                            queue.offer(friends[polledId][i]);\\n                            hs.add(friends[polledId][i]);\\n                        } \\n                    }\\n                }\\n                size--;\\n            }\\n            currlevel++;\\n        }\\n        \\n        Comparator<Map.Entry<String, Integer>> comparator = (e1, e2) -> {\\n            int i = e1.getValue().compareTo(e2.getValue());\\n            if (i == 0) {\\n                return e1.getKey().compareTo(e2.getKey());\\n            } else {\\n                return i;\\n            }\\n        };\\n        \\n        List<String> ans = freq.entrySet()\\n                .stream()\\n                .sorted(comparator)\\n                .map(e -> e.getKey())\\n                .collect(Collectors.toList());\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227183,
                "title": "c-code-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(const pair<int,string> &a,const pair<int,string> &b){\\n        if (a.first==b.first){\\n            return a.second<b.second;\\n        }\\n        else{\\n            return a.first<b.first;\\n        }\\n    }\\n    \\n    vector<int> adj[1005];\\n    int vis[1005];\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& video, vector<vector<int>>& v, int id, int level) {\\n        int i,j;\\n        \\n        for (i=0; i<v.size(); i++){\\n            for (j=0; j<v[i].size(); j++){\\n                adj[i].push_back(v[i][j]);\\n                adj[v[i][j]].push_back(i);\\n            }\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        q.push({id,0});\\n        map<string,int> mp;\\n        \\n        while (!q.empty()){\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            \\n            if (p.second==level){\\n              //  cout<<p.first<<\" \"<<p.second<<endl;\\n                for (auto it: video[p.first]){\\n                    mp[it]++;\\n                }\\n                continue;\\n            }\\n            \\n            vis[p.first]=1;\\n            \\n            for(auto it: adj[p.first]){\\n                if (!vis[it]){\\n                  q.push({it,p.second+1});\\n                 vis[it]=1;\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int,string>> temp;\\n        for (auto it: mp){\\n            temp.push_back({it.second,it.first});\\n        }\\n        \\n        sort(temp.begin(),temp.end(),cmp);\\n        \\n        vector<string> ans;\\n        for (auto it: temp){\\n            ans.push_back(it.second);\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(const pair<int,string> &a,const pair<int,string> &b){\\n        if (a.first==b.first){\\n            return a.second<b.second;\\n        }\\n        else{\\n            return a.first<b.first;\\n        }\\n    }\\n    \\n    vector<int> adj[1005];\\n    int vis[1005];\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& video, vector<vector<int>>& v, int id, int level) {\\n        int i,j;\\n        \\n        for (i=0; i<v.size(); i++){\\n            for (j=0; j<v[i].size(); j++){\\n                adj[i].push_back(v[i][j]);\\n                adj[v[i][j]].push_back(i);\\n            }\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        q.push({id,0});\\n        map<string,int> mp;\\n        \\n        while (!q.empty()){\\n            pair<int,int> p=q.front();\\n            q.pop();\\n            \\n            if (p.second==level){\\n              //  cout<<p.first<<\" \"<<p.second<<endl;\\n                for (auto it: video[p.first]){\\n                    mp[it]++;\\n                }\\n                continue;\\n            }\\n            \\n            vis[p.first]=1;\\n            \\n            for(auto it: adj[p.first]){\\n                if (!vis[it]){\\n                  q.push({it,p.second+1});\\n                 vis[it]=1;\\n                }\\n            }\\n        }\\n        \\n        vector<pair<int,string>> temp;\\n        for (auto it: mp){\\n            temp.push_back({it.second,it.first});\\n        }\\n        \\n        sort(temp.begin(),temp.end(),cmp);\\n        \\n        vector<string> ans;\\n        for (auto it: temp){\\n            ans.push_back(it.second);\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2210479,
                "title": "bfs",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos,            vector<vector<int>>& friends, int id, int level) {\\n        \\n        int i;\\n        int n=watchedVideos.size();\\n       \\n        int j;     \\n        queue<int> q;\\n        int level1=0;\\n        q.push(id);\\n        int k;\\n       \\n        vector<int> visited(n);\\n        for(i=0;i<n;i++){\\n            visited[i]=0;\\n        }\\n        visited[id]=1;\\n        unordered_map<string ,int> mp;\\n        while(q.empty()!=1||level1!=level){\\n            int i;\\n            int n=q.size();\\n            \\n            level1++;\\n           \\n            for(i=0;i<n;i++){\\n                int c=q.front();\\n                q.pop();\\n               \\n                if(level1==level){\\n                    \\n                    for(j=0;j<friends[c].size();j++){\\n                        int d=friends[c][j];\\n                        if(visited[d]==0){\\n                            visited[d]=1;\\n                               for(k=0;k<watchedVideos[d].size();k++){\\n                          mp[watchedVideos[d][k]]++;\\n                      }\\n                        }\\n                            \\n                    }\\n                    \\n                }\\n                else if(level1!=level){\\n                    for(j=0;j<friends[c].size();j++){\\n                        if(visited[friends[c][j]]==0){\\n                            visited[friends[c][j]]=1;\\n                              q.push(friends[c][j]);\\n                        }\\n                      \\n                    }\\n                }\\n                    \\n            }\\n            if(level1==level){\\n                \\n                break;\\n            }\\n                   \\n        }\\n        vector<string> v;\\n        vector<pair<int,string>> v1;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            v1.push_back(make_pair(it->second,it->first));\\n        }\\n        sort(v1.begin(),v1.end());\\n        for(i=0;i<v1.size();i++){\\n            v.push_back(v1[i].second);\\n        }\\n        \\n        return v;\\n        \\n        \\n        \\n        \\n        \\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos,            vector<vector<int>>& friends, int id, int level) {\\n        \\n        int i;\\n        int n=watchedVideos.size();\\n       \\n        int j;     \\n        queue<int> q;\\n        int level1=0;\\n        q.push(id);\\n        int k;\\n       \\n        vector<int> visited(n);\\n        for(i=0;i<n;i++){\\n            visited[i]=0;\\n        }\\n        visited[id]=1;\\n        unordered_map<string ,int> mp;\\n        while(q.empty()!=1||level1!=level){\\n            int i;\\n            int n=q.size();\\n            \\n            level1++;\\n           \\n            for(i=0;i<n;i++){\\n                int c=q.front();\\n                q.pop();\\n               \\n                if(level1==level){\\n                    \\n                    for(j=0;j<friends[c].size();j++){\\n                        int d=friends[c][j];\\n                        if(visited[d]==0){\\n                            visited[d]=1;\\n                               for(k=0;k<watchedVideos[d].size();k++){\\n                          mp[watchedVideos[d][k]]++;\\n                      }\\n                        }\\n                            \\n                    }\\n                    \\n                }\\n                else if(level1!=level){\\n                    for(j=0;j<friends[c].size();j++){\\n                        if(visited[friends[c][j]]==0){\\n                            visited[friends[c][j]]=1;\\n                              q.push(friends[c][j]);\\n                        }\\n                      \\n                    }\\n                }\\n                    \\n            }\\n            if(level1==level){\\n                \\n                break;\\n            }\\n                   \\n        }\\n        vector<string> v;\\n        vector<pair<int,string>> v1;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            v1.push_back(make_pair(it->second,it->first));\\n        }\\n        sort(v1.begin(),v1.end());\\n        for(i=0;i<v1.size();i++){\\n            v.push_back(v1[i].second);\\n        }\\n        \\n        return v;\\n        \\n        \\n        \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2208159,
                "title": "very-good-problem",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        boolean[] visited = new boolean[n];\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<friends[i].length;j++){\\n                graph.get(i).add(friends[i][j]);\\n            }\\n        }\\n        // System.out.println(graph.get(0));\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(id);\\n        visited[id] = true;\\n        Map<String,Integer> answer = new HashMap<>();\\n        while(!queue.isEmpty() && level>0){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int vertex = queue.remove();\\n                for(int child: graph.get(vertex)){\\n                    if(!visited[child]){\\n                        //   if(level == 1) System.out.println(watchedVideos.get(child));\\n                        if(level == 1) {\\n                            for(String a: watchedVideos.get(child)){\\n                                answer.put(a,answer.getOrDefault(a,0)+1);\\n                            }\\n                        }\\n                        visited[child] = true;\\n                        queue.offer(child);\\n                    }\\n                }\\n            }\\n            level--;\\n        }\\n        Queue<String[]> sortedQueue = new PriorityQueue<>((a,b)->{\\n            if(a[1].equals(b[1])) return a[0].compareTo(b[0]);\\n            return Integer.parseInt(a[1])-Integer.parseInt(b[1]);\\n        });\\n        for(String key: answer.keySet()){\\n            sortedQueue.offer(new String[]{key,Integer.toString(answer.get(key))});\\n        }\\n        List<String> finalAnswer = new ArrayList<>();\\n        while(!sortedQueue.isEmpty()) finalAnswer.add(sortedQueue.remove()[0]);\\n        return finalAnswer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n = friends.length;\\n        boolean[] visited = new boolean[n];\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<friends[i].length;j++){\\n                graph.get(i).add(friends[i][j]);\\n            }\\n        }\\n        // System.out.println(graph.get(0));\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.offer(id);\\n        visited[id] = true;\\n        Map<String,Integer> answer = new HashMap<>();\\n        while(!queue.isEmpty() && level>0){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int vertex = queue.remove();\\n                for(int child: graph.get(vertex)){\\n                    if(!visited[child]){\\n                        //   if(level == 1) System.out.println(watchedVideos.get(child));\\n                        if(level == 1) {\\n                            for(String a: watchedVideos.get(child)){\\n                                answer.put(a,answer.getOrDefault(a,0)+1);\\n                            }\\n                        }\\n                        visited[child] = true;\\n                        queue.offer(child);\\n                    }\\n                }\\n            }\\n            level--;\\n        }\\n        Queue<String[]> sortedQueue = new PriorityQueue<>((a,b)->{\\n            if(a[1].equals(b[1])) return a[0].compareTo(b[0]);\\n            return Integer.parseInt(a[1])-Integer.parseInt(b[1]);\\n        });\\n        for(String key: answer.keySet()){\\n            sortedQueue.offer(new String[]{key,Integer.toString(answer.get(key))});\\n        }\\n        List<String> finalAnswer = new ArrayList<>();\\n        while(!sortedQueue.isEmpty()) finalAnswer.add(sortedQueue.remove()[0]);\\n        return finalAnswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183307,
                "title": "c-solution-based-on-bfs",
                "content": "Btw, i think the expression of this problem is so terrible...\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        int n = friends.size();\\n        vector<int> marked(n, -1);  marked[id] = 1;\\n        int l = 0;\\n        queue<int> units; units.push(id);\\n        while(l < level){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                int node = units.front(); units.pop();\\n                for (int j = 0; j < friends[node].size(); j++){\\n                    int to_node = friends[node][j];\\n                    if (marked[to_node] == -1){\\n                        marked[to_node] = 1;\\n                        units.push(to_node);\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        unordered_map<string, int> records;\\n        while(!units.empty()){\\n            int node = units.front();   units.pop();\\n            for (int i = 0; i < watchedVideos[node].size(); i++){\\n                string name = watchedVideos[node][i];\\n                if (records.count(name) == 0){\\n                    records.insert({name, 1});\\n                }\\n                else{\\n                    records[name]++;\\n                }\\n            }\\n        }\\n        vector<pair<int, string>> pairs;\\n        for (auto it = records.begin(); it!=records.end(); it++){\\n            pairs.push_back({it->second, it->first});\\n        }\\n        sort(pairs.begin(), pairs.end());\\n        vector<string> result(pairs.size());\\n        for (int i = 0; i < pairs.size(); i++){\\n            result[i] = pairs[i].second;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        \\n        int n = friends.size();\\n        vector<int> marked(n, -1);  marked[id] = 1;\\n        int l = 0;\\n        queue<int> units; units.push(id);\\n        while(l < level){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                int node = units.front(); units.pop();\\n                for (int j = 0; j < friends[node].size(); j++){\\n                    int to_node = friends[node][j];\\n                    if (marked[to_node] == -1){\\n                        marked[to_node] = 1;\\n                        units.push(to_node);\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        unordered_map<string, int> records;\\n        while(!units.empty()){\\n            int node = units.front();   units.pop();\\n            for (int i = 0; i < watchedVideos[node].size(); i++){\\n                string name = watchedVideos[node][i];\\n                if (records.count(name) == 0){\\n                    records.insert({name, 1});\\n                }\\n                else{\\n                    records[name]++;\\n                }\\n            }\\n        }\\n        vector<pair<int, string>> pairs;\\n        for (auto it = records.begin(); it!=records.end(); it++){\\n            pairs.push_back({it->second, it->first});\\n        }\\n        sort(pairs.begin(), pairs.end());\\n        vector<string> result(pairs.size());\\n        for (int i = 0; i < pairs.size(); i++){\\n            result[i] = pairs[i].second;\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181204,
                "title": "java-using-queue-set",
                "content": "```\\n        Queue<Integer> currentPeople = new ArrayDeque<>(List.of(id));\\n        Set<Integer> history = new HashSet<>(List.of(id));\\n        for (int i = 1; i <= level; i++){\\n            int currentPeopleSize = currentPeople.size();\\n            for (int j = 0; j < currentPeopleSize; j++){\\n                int currentPerson = currentPeople.poll();\\n                int[] currentFriends = friends[currentPerson];\\n                for (int currentFriend: currentFriends){\\n                    if (!history.contains(currentFriend)){\\n                        currentPeople.offer(currentFriend);\\n                        history.add(currentFriend);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        Map<String, Integer> mapWatchedVideo = new HashMap<>();\\n        while (currentPeople.size() > 0){\\n            int currentPerson = currentPeople.poll();\\n            List<String> videos = watchedVideos.get(currentPerson);\\n            for (String video: videos){\\n                mapWatchedVideo.merge(video, 1, (oldValue, defaultValue) -> oldValue + 1);\\n            }\\n        }\\n        \\n        List<String> result = mapWatchedVideo.entrySet().stream().sorted((entry1, entry2) -> {\\n           if (entry1.getValue().equals(entry2.getValue())){\\n               return entry1.getKey().compareTo(entry2.getKey());\\n           }\\n           else {\\n               return entry1.getValue().compareTo(entry2.getValue());\\n           }\\n        }).map(Map.Entry::getKey).collect(Collectors.toList());\\n        \\n        return result;\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n        Queue<Integer> currentPeople = new ArrayDeque<>(List.of(id));\\n        Set<Integer> history = new HashSet<>(List.of(id));\\n        for (int i = 1; i <= level; i++){\\n            int currentPeopleSize = currentPeople.size();\\n            for (int j = 0; j < currentPeopleSize; j++){\\n                int currentPerson = currentPeople.poll();\\n                int[] currentFriends = friends[currentPerson];\\n                for (int currentFriend: currentFriends){\\n                    if (!history.contains(currentFriend)){\\n                        currentPeople.offer(currentFriend);\\n                        history.add(currentFriend);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        Map<String, Integer> mapWatchedVideo = new HashMap<>();\\n        while (currentPeople.size() > 0){\\n            int currentPerson = currentPeople.poll();\\n            List<String> videos = watchedVideos.get(currentPerson);\\n            for (String video: videos){\\n                mapWatchedVideo.merge(video, 1, (oldValue, defaultValue) -> oldValue + 1);\\n            }\\n        }\\n        \\n        List<String> result = mapWatchedVideo.entrySet().stream().sorted((entry1, entry2) -> {\\n           if (entry1.getValue().equals(entry2.getValue())){\\n               return entry1.getKey().compareTo(entry2.getKey());\\n           }\\n           else {\\n               return entry1.getValue().compareTo(entry2.getValue());\\n           }\\n        }).map(Map.Entry::getKey).collect(Collectors.toList());\\n        \\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168850,
                "title": "bad-problem-description-bfs-minheap-implementation-java",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        int n= friends.length;\\n        boolean[] visited= new boolean[n];\\n        List<Integer> vertexAtLevel= new ArrayList<>();\\n        \\n        //using bfs to compute the friends id at a certain level\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(id);\\n        visited[id]=true;\\n        \\n        int lvl=0;\\n        while(!q.isEmpty() && lvl<=level){\\n            \\n            int size= q.size();\\n            for(int j=0; j<size; j++){\\n                int vtx= q.poll();\\n                if(lvl== level){\\n                    //add into list\\n                    vertexAtLevel.add(vtx);\\n                }\\n            \\n                //add neighbours\\n                for(int i=0; i<friends[vtx].length; i++){\\n                    int nbr= friends[vtx][i];\\n                    if(!visited[nbr]){\\n                        q.add(nbr);\\n                        visited[nbr]= true;\\n                    } \\n                }\\n            }\\n            lvl++;  \\n        }\\n        \\n        //fill watchedMovies in HashMap using vertexAtLevel list\\n        HashMap<String,Integer> map= new HashMap<>();\\n        for(int i=0; i<vertexAtLevel.size(); i++){\\n            List<String> movies= watchedVideos.get(vertexAtLevel.get(i));\\n            for(int j=0; j<movies.size(); j++){\\n                map.put(movies.get(j), map.getOrDefault(movies.get(j),0)+1);\\n            }\\n        }\\n        \\n        //add the hashMap movies in a PriorityQueue\\n        PriorityQueue<String> pq= new PriorityQueue<>(new Comparator<String>(){\\n            public int compare(String s1, String s2){\\n                \\n                int f1= map.get(s1);\\n                int f2= map.get(s2);\\n                if(f1==f2){\\n                    return s1.compareTo(s2);\\n                }else\\n                    return f1-f2;\\n            }\\n        });\\n        \\n        for(String movie: map.keySet())\\n            pq.add(movie);\\n        \\n        List<String> ans= new ArrayList<>();\\n        while(!pq.isEmpty())\\n            ans.add(pq.poll());\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        int n= friends.length;\\n        boolean[] visited= new boolean[n];\\n        List<Integer> vertexAtLevel= new ArrayList<>();\\n        \\n        //using bfs to compute the friends id at a certain level\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(id);\\n        visited[id]=true;\\n        \\n        int lvl=0;\\n        while(!q.isEmpty() && lvl<=level){\\n            \\n            int size= q.size();\\n            for(int j=0; j<size; j++){\\n                int vtx= q.poll();\\n                if(lvl== level){\\n                    //add into list\\n                    vertexAtLevel.add(vtx);\\n                }\\n            \\n                //add neighbours\\n                for(int i=0; i<friends[vtx].length; i++){\\n                    int nbr= friends[vtx][i];\\n                    if(!visited[nbr]){\\n                        q.add(nbr);\\n                        visited[nbr]= true;\\n                    } \\n                }\\n            }\\n            lvl++;  \\n        }\\n        \\n        //fill watchedMovies in HashMap using vertexAtLevel list\\n        HashMap<String,Integer> map= new HashMap<>();\\n        for(int i=0; i<vertexAtLevel.size(); i++){\\n            List<String> movies= watchedVideos.get(vertexAtLevel.get(i));\\n            for(int j=0; j<movies.size(); j++){\\n                map.put(movies.get(j), map.getOrDefault(movies.get(j),0)+1);\\n            }\\n        }\\n        \\n        //add the hashMap movies in a PriorityQueue\\n        PriorityQueue<String> pq= new PriorityQueue<>(new Comparator<String>(){\\n            public int compare(String s1, String s2){\\n                \\n                int f1= map.get(s1);\\n                int f2= map.get(s2);\\n                if(f1==f2){\\n                    return s1.compareTo(s2);\\n                }else\\n                    return f1-f2;\\n            }\\n        });\\n        \\n        for(String movie: map.keySet())\\n            pq.add(movie);\\n        \\n        List<String> ans= new ArrayList<>();\\n        while(!pq.isEmpty())\\n            ans.add(pq.poll());\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167715,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    void bfs(int source, vector<vector<int>>& friends, vector<int>&level, vector<int>&vis)\\n    {\\n        queue<int>q;\\n        q.push(source);\\n        vis[source] = 1;\\n        level[source] = 0;\\n        while(!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n            for(auto child : friends[curr])\\n            {\\n                if(vis[child] == 1) continue;\\n                q.push(child);\\n                level[child] = level[curr]+1;\\n                vis[child] = 1;\\n            }\\n        }\\n        \\n    }\\n    \\n    \\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level)       {\\n        vector<int>lvl(friends.size(), 0);\\n        vector<int>vis(friends.size(), 0);\\n        vector<string>ans;\\n        bfs(id, friends, lvl, vis);\\n        vector<int>selected;\\n        for(int i=0;i<lvl.size();i++)\\n        {\\n            if(lvl[i] == level)\\n            {\\n                selected.push_back(i);\\n            }\\n        }\\n        \\n        \\n//         for(int i=0;i<lvl.size();i++)\\n//         {\\n//             cout<<lvl[i]<<\" \";\\n//         }\\n//         cout<<\"\\\\n\";\\n        \\n        \\n//         for(int i=0;i<selected.size();i++)\\n//         {\\n//             cout<<selected[i]<<\"\\\\n\";\\n//         }\\n        \\n        unordered_map<string,int>m;\\n        for(int i=0;i<selected.size();i++)\\n        {\\n            int frnd = selected[i];\\n            for(int j = 0; j<watchedVideos[frnd].size();j++)\\n            {\\n                m[watchedVideos[frnd][j]]++;\\n            }\\n        }\\n        \\n        multiset<pair<int,string>>freq;\\n        \\n        for(auto it = m.begin() ;it != m.end(); it++)\\n        {\\n            freq.insert({it->second, it->first});\\n        }\\n        \\n        \\n        for(auto it = freq.begin(); it!= freq.end(); it++)\\n        {\\n            ans.push_back(it->second);\\n        }\\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    void bfs(int source, vector<vector<int>>& friends, vector<int>&level, vector<int>&vis)\\n    {\\n        queue<int>q;\\n        q.push(source);\\n        vis[source] = 1;\\n        level[source] = 0;\\n        while(!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n            for(auto child : friends[curr])\\n            {\\n                if(vis[child] == 1) continue;\\n                q.push(child);\\n                level[child] = level[curr]+1;\\n                vis[child] = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2106030,
                "title": "python-faster-than-98-memory-usage-less-than-100-bfs",
                "content": "\\t  class Solution:\\n\\t\\tdef watchedVideosByFriends(self, w: List[List[str]], f: List[List[int]], id: int, l: int):\\n\\t\\t\\td=deque([(id,0)])\\n\\t\\t\\tv={id}\\n\\t\\t\\tq={}\\n\\t\\t\\twhile d:\\n\\t\\t\\t\\tx,y=d.popleft()\\n\\t\\t\\t\\tif y<l:\\n\\t\\t\\t\\t\\tfor j in f[x]:\\n\\t\\t\\t\\t\\t\\tif j not in v:\\n\\t\\t\\t\\t\\t\\t\\tv.add(j)\\n\\t\\t\\t\\t\\t\\t\\td.append((j,y+1))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfor j in w[x]:\\n\\t\\t\\t\\t\\t\\tq[j]=q.get(j,0)+1\\n\\t\\t\\ts=sorted([j,q[j]]for j in q)\\n\\t\\t\\ts.sort(key=lambda x:x[1])\\n\\t\\t\\treturn [i[0] for i in s]",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n\\t\\tdef watchedVideosByFriends(self, w: List[List[str]], f: List[List[int]], id: int, l: int):\\n\\t\\t\\td=deque([(id,0)])\\n\\t\\t\\tv={id}",
                "codeTag": "Java"
            },
            {
                "id": 2076276,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=watchedVideos.size();\\n        \\n        vector<bool> visited(n,false);\\n        map<string,int> watched;\\n        \\n        priority_queue<pair<int/*dist*/,int/*index*/>,vector<pair<int,int>>, std::greater<pair<int,int>>> q;\\n        q.push({0,id});\\n        \\n        while(!q.empty()) {\\n            auto t=q.top(); q.pop();\\n            \\n            int id=t.second;\\n            if(visited[id]) continue;\\n            visited[id]=true;       \\n            \\n            if(t.first==level)  {\\n              for(auto&w:watchedVideos[id])\\n                 watched[w]++;\\n                \\n                continue;\\n            }\\n            \\n            for(auto&f: friends[id])\\n             if(!visited[f])\\n               q.push({t.first+1,f});\\n        }\\n        \\n        vector<string> r;\\n        \\n        map<int,set<string>> ws;\\n        for(auto&s:watched) ws[s.second].insert(s.first);\\n        \\n        for(auto& p:ws)\\n            for(auto&k:p.second) r.push_back(k);\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=watchedVideos.size();\\n        \\n        vector<bool> visited(n,false);\\n        map<string,int> watched;\\n        \\n        priority_queue<pair<int/*dist*/,int/*index*/>,vector<pair<int,int>>, std::greater<pair<int,int>>> q;\\n        q.push({0,id});\\n        \\n        while(!q.empty()) {\\n            auto t=q.top(); q.pop();\\n            \\n            int id=t.second;\\n            if(visited[id]) continue;\\n            visited[id]=true;       \\n            \\n            if(t.first==level)  {\\n              for(auto&w:watchedVideos[id])\\n                 watched[w]++;\\n                \\n                continue;\\n            }\\n            \\n            for(auto&f: friends[id])\\n             if(!visited[f])\\n               q.push({t.first+1,f});\\n        }\\n        \\n        vector<string> r;\\n        \\n        map<int,set<string>> ws;\\n        for(auto&s:watched) ws[s.second].insert(s.first);\\n        \\n        for(auto& p:ws)\\n            for(auto&k:p.second) r.push_back(k);\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021060,
                "title": "python-java-bfs-sort",
                "content": "\\tclass Solution:\\n\\t\\tdef watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\t\\t\\tvideos = collections.defaultdict(int)\\n\\t\\t\\tcurLevel = [id]\\n\\t\\t\\tseen = {id}\\n\\t\\t\\tres = []\\n\\t\\t\\tfor _ in range(level):\\n\\t\\t\\t\\tnextLevel = []\\n\\t\\t\\t\\tfor people in curLevel:\\n\\t\\t\\t\\t\\tfor friend in friends[people]:\\n\\t\\t\\t\\t\\t\\tif friend not in seen:\\n\\t\\t\\t\\t\\t\\t\\tnextLevel.append(friend)\\n\\t\\t\\t\\t\\t\\t\\tseen.add(friend)\\n\\t\\t\\t\\tcurLevel = nextLevel\\n\\t\\t\\tfor people in curLevel:\\n\\t\\t\\t\\tfor video in watchedVideos[people]:\\n\\t\\t\\t\\t\\tvideos[video] += 1\\n\\t\\t\\tfor k, v in videos.items():\\n\\t\\t\\t\\tres.append((v, k))\\n\\t\\t\\treturn [video for freq, video in sorted(res)]\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n\\t\\t\\tMap<String, Integer> videos = new HashMap<>();\\n\\t\\t\\tList<Integer> curLevel = new ArrayList<>();\\n\\t\\t\\tcurLevel.add(id);\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\tseen.add(id);\\n\\t\\t\\tList<String> res = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < level; i ++) {\\n\\t\\t\\t\\tList<Integer> nextLevel = new ArrayList<>();\\n\\t\\t\\t\\tfor (int people: curLevel) {\\n\\t\\t\\t\\t\\tfor (int friend: friends[people]) {\\n\\t\\t\\t\\t\\t\\tif (!seen.contains(friend)) {\\n\\t\\t\\t\\t\\t\\t\\tnextLevel.add(friend);\\n\\t\\t\\t\\t\\t\\t\\tseen.add(friend);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurLevel = nextLevel;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int people: curLevel) {\\n\\t\\t\\t\\tfor (String watchedVideo: watchedVideos.get(people)) {\\n\\t\\t\\t\\t\\tvideos.put(watchedVideo, videos.getOrDefault(watchedVideo, 0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (String video: videos.keySet()) {\\n\\t\\t\\t\\tres.add(video);\\n\\t\\t\\t}\\n\\t\\t\\tCollections.sort(res, (a, b) -> videos.get(a) == videos.get(b)? a.compareTo(b): videos.get(a) - videos.get(b));\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n\\t\\t\\tvideos = collections.defaultdict(int)\\n\\t\\t\\tcurLevel = [id]\\n\\t\\t\\tseen = {id}",
                "codeTag": "Java"
            },
            {
                "id": 2008904,
                "title": "java-bfs-minheap-solution-with-explanation",
                "content": "You are given 4 things as part of input. \\n\\n(1) A list of `friends`  - size `n`\\n\\n(2) A list of videos each friend can watch - `watchedVideos` - also of size `n`\\n\\n(3) You are also told your `id` - essentially the index in the friends array\\n\\n(4) You are also given a `level` (Can be thought of as time)\\nAt t = 0s, all your immediate friends will be able to watch the video\\nAt t = 1s, friends of those friends will be able to watch the video\\nAt t = 2s, friends of friends of friends  will be able to watch the video and so on.\\n\\nGiven the above information, you need to find the list of videos watched at `xth ` time unit.\\n\\nNote :\\n(1) The expected answer should only contain the videos watched at the `xth` level. And not for levels \"upto\" x\\n\\n(2) The expected answer (list of videos) needs to be sorted as per number of times the video was watched at the `xth` level. If there is a tie, sort the videos lexicographically.\\n\\n```\\nclass Solution {\\n    \\n    // friends is actually an undirected graph of nodes, represented as an adjacency matrix\\n    \\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n    \\n        // 1. friends is actually an undirected graph of nodes, represented as an adjacency matrix\\n        \\n        // 2. Perform a BFS starting with my \"id\"\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(id);\\n        Set<Integer> visited = new HashSet<>();\\n\\n        Map<String, Integer> watchedVideosToFrequency = new HashMap<>();\\n        int currentLevel = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int queueSize = queue.size();\\n            \\n            for (int i = 0; i < queueSize; i++) {\\n                int v = queue.poll();\\n                if (visited.contains(v)) \\n\\t\\t\\t\\t\\tcontinue;\\n                visited.add(v);\\n                \\n                if (v != id && currentLevel == level) {\\n                    // Get all videos watched by current vertex (current friend)\\n                    List<String> videosWatchedByV = watchedVideos.get(v);\\n                    for (String video: videosWatchedByV) {\\n                        watchedVideosToFrequency.put(video, 1 + watchedVideosToFrequency.getOrDefault(video, 0));\\n                    }\\n                }\\n\\n\\t\\t\\t\\t// Add the unvisited neighbors\\n                for (int nbr: friends[v]) {\\n                    if (!visited.contains(nbr)) {\\n                        queue.add(nbr);\\n                    }\\n                }\\n            }\\n            currentLevel++;  \\n            if (currentLevel > level) {\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// To satisfy the requirements of Note #2,  a minheap is an obvious choice.\\n        // Define a minheap\\n        PriorityQueue<Map.Entry<String, Integer>> minheap = new PriorityQueue<>((e1, e2) -> {\\n         \\n            if (e1.getValue() == e2.getValue()) {\\n                // Frequencies are same => Sort lexicographically\\n                return e1.getKey().compareTo(e2.getKey());\\n            } else {\\n\\t\\t\\t\\t// Sort by the frequency\\n                return Integer.compare(e1.getValue(), e2.getValue());\\n            }\\n        });\\n        \\n        // Add all elements from watchedVideosToFrequency to minheap\\n        minheap.addAll(watchedVideosToFrequency.entrySet());\\n\\n\\t\\t// Build the result list\\n        List<String> result = new ArrayList<>();\\n        while (!minheap.isEmpty()) {\\n            result.add(minheap.poll().getKey());\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    \\n    // friends is actually an undirected graph of nodes, represented as an adjacency matrix\\n    \\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n    \\n        // 1. friends is actually an undirected graph of nodes, represented as an adjacency matrix\\n        \\n        // 2. Perform a BFS starting with my \"id\"\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(id);\\n        Set<Integer> visited = new HashSet<>();\\n\\n        Map<String, Integer> watchedVideosToFrequency = new HashMap<>();\\n        int currentLevel = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int queueSize = queue.size();\\n            \\n            for (int i = 0; i < queueSize; i++) {\\n                int v = queue.poll();\\n                if (visited.contains(v)) \\n\\t\\t\\t\\t\\tcontinue;\\n                visited.add(v);\\n                \\n                if (v != id && currentLevel == level) {\\n                    // Get all videos watched by current vertex (current friend)\\n                    List<String> videosWatchedByV = watchedVideos.get(v);\\n                    for (String video: videosWatchedByV) {\\n                        watchedVideosToFrequency.put(video, 1 + watchedVideosToFrequency.getOrDefault(video, 0));\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1952447,
                "title": "java-bfs-hashmap-priority-queue-beats-98",
                "content": "*Idea:  To use BFS to get friends at the level specified. Add all videos of these friends in Map. Sort this map with the help of Priority Queue. Alternatively we can sort map directly with Collections Library*\\n**Upvote if found Useful**\\n![image](https://assets.leetcode.com/users/images/dcb296cb-3b8d-4cf3-9519-1e10d1853e3c_1650095596.122275.png)\\n```\\nclass MapElement {\\n    String key;\\n    int value;\\n    MapElement(String key, int value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n}\\n\\nclass MapElementComparator implements Comparator<MapElement> {\\n    @Override\\n    public int compare(MapElement me1, MapElement me2) {\\n        if(me1.value != me2.value) {\\n            return me1.value - me2.value;\\n        }\\n        return me1.key.compareTo(me2.key);\\n    }\\n}\\n\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        HashMap<String,Integer> freqMap = new HashMap<>();\\n        boolean[] visited = new boolean[watchedVideos.size()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(id);\\n        visited[id] = true;\\n        while(level >= 0 && !queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int current = queue.poll();\\n                for(int friend: friends[current]) {\\n                    if(visited[friend]) {\\n                        continue;\\n                    }\\n                    queue.offer(friend);\\n                    visited[friend] = true;\\n                }\\n                if(level == 0) {\\n                    for(String video: watchedVideos.get(current)) {\\n                        freqMap.put(video, freqMap.getOrDefault(video, 0) + 1);\\n                    }\\n                }\\n            }\\n            level--;\\n        }\\n        PriorityQueue<MapElement> priorityQueue = new PriorityQueue<>(new MapElementComparator());\\n        for(String key: freqMap.keySet()) {\\n            priorityQueue.offer(new MapElement(key, freqMap.get(key)));\\n        }\\n        List<String> answer = new ArrayList<>();\\n        while(!priorityQueue.isEmpty()) {\\n            answer.add(priorityQueue.poll().key);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MapElement {\\n    String key;\\n    int value;\\n    MapElement(String key, int value) {\\n        this.key = key;\\n        this.value = value;\\n    }\\n}\\n\\nclass MapElementComparator implements Comparator<MapElement> {\\n    @Override\\n    public int compare(MapElement me1, MapElement me2) {\\n        if(me1.value != me2.value) {\\n            return me1.value - me2.value;\\n        }\\n        return me1.key.compareTo(me2.key);\\n    }\\n}\\n\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        HashMap<String,Integer> freqMap = new HashMap<>();\\n        boolean[] visited = new boolean[watchedVideos.size()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(id);\\n        visited[id] = true;\\n        while(level >= 0 && !queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size-- > 0) {\\n                int current = queue.poll();\\n                for(int friend: friends[current]) {\\n                    if(visited[friend]) {\\n                        continue;\\n                    }\\n                    queue.offer(friend);\\n                    visited[friend] = true;\\n                }\\n                if(level == 0) {\\n                    for(String video: watchedVideos.get(current)) {\\n                        freqMap.put(video, freqMap.getOrDefault(video, 0) + 1);\\n                    }\\n                }\\n            }\\n            level--;\\n        }\\n        PriorityQueue<MapElement> priorityQueue = new PriorityQueue<>(new MapElementComparator());\\n        for(String key: freqMap.keySet()) {\\n            priorityQueue.offer(new MapElement(key, freqMap.get(key)));\\n        }\\n        List<String> answer = new ArrayList<>();\\n        while(!priorityQueue.isEmpty()) {\\n            answer.add(priorityQueue.poll().key);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944197,
                "title": "c-bfs-and-hashmap-solution-explained",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n        So if we observe carefully this is a standard BFS algorithm question as here we need to find the k level friends of ours.\\n        This can be easily achieved by BFS algorithm.\\n        \\n        So what we do is we run BFS algorithm for level no of times and get the friends which are at distance k from us and from here only we need to find their most watched videos.\\n        \\n        so we simply use a hash map to store the movies watched by our k level friends and its frequecy because in answer we need to sort them according to the frequency of the watched videos.\\n        \\n        after that we take a vector and sort it according to the frequency of watched videos. and last we return the result.\\n        \\n        Please Upvote if you like the solution.\\n        for any changes please comment.\\n    */\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        queue<int> q;\\n        vector<bool> visited(n,false);\\n        q.push(id);\\n        visited[id]=true;\\n        while(level--)\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int cur=q.front();\\n                q.pop();\\n                for(auto child:friends[cur])\\n                {\\n                    if(!visited[child])\\n                    {\\n                        visited[child]=true;\\n                        q.push(child);\\n                    }\\n                }\\n            }\\n        }\\n        unordered_map<string,int> mp;\\n        while(!q.empty())\\n        {\\n            vector<string> temp=watchedVideos[q.front()];\\n            q.pop();\\n            for(auto i:temp)\\n                mp[i]++;\\n        }\\n        vector<pair<int,string> > res;\\n        for(auto i:mp)\\n            res.push_back({i.second,i.first});\\n        sort(res.begin(),res.end());\\n        vector<string> ans;\\n        for(auto i:res)\\n            ans.push_back(i.second);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n        So if we observe carefully this is a standard BFS algorithm question as here we need to find the k level friends of ours.\\n        This can be easily achieved by BFS algorithm.\\n        \\n        So what we do is we run BFS algorithm for level no of times and get the friends which are at distance k from us and from here only we need to find their most watched videos.\\n        \\n        so we simply use a hash map to store the movies watched by our k level friends and its frequecy because in answer we need to sort them according to the frequency of the watched videos.\\n        \\n        after that we take a vector and sort it according to the frequency of watched videos. and last we return the result.\\n        \\n        Please Upvote if you like the solution.\\n        for any changes please comment.\\n    */\\n    \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n=friends.size();\\n        queue<int> q;\\n        vector<bool> visited(n,false);\\n        q.push(id);\\n        visited[id]=true;\\n        while(level--)\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int cur=q.front();\\n                q.pop();\\n                for(auto child:friends[cur])\\n                {\\n                    if(!visited[child])\\n                    {\\n                        visited[child]=true;\\n                        q.push(child);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1929452,
                "title": "go-bfs-faster-100",
                "content": "```\\ntype FriendsGraph struct {\\n    SelfId      int\\n    AdjList     [][]int\\n    N           int\\n    Level       int\\n}\\n\\ntype QElem struct {\\n    Id      int\\n    Dist    int\\n}\\n\\ntype MovieCntElem struct {\\n    movie string\\n    cnt int\\n}\\n\\ntype MovieSorter struct {\\n    movies []MovieCntElem\\n}\\n\\nfunc (ms *MovieSorter) Len() int {\\n    return len(ms.movies)\\n}\\n\\nfunc (ms *MovieSorter) Less(i, j int) bool {\\n    if ms.movies[i].cnt != ms.movies[j].cnt {\\n        return ms.movies[i].cnt < ms.movies[j].cnt\\n    }\\n    return ms.movies[i].movie < ms.movies[j].movie\\n}\\n\\nfunc (ms *MovieSorter) Swap(i, j int) {\\n    ms.movies[i], ms.movies[j] = ms.movies[j], ms.movies[i]\\n}\\n\\nfunc NewFriendsGraph(sid, n, level int) *FriendsGraph {\\n    adjList := make([][]int, n)\\n    for i:=0; i<n; i++ {\\n        adjList[i] = make([]int, 0)\\n    }\\n    return &FriendsGraph{\\n        SelfId:     sid,\\n        AdjList:    adjList,\\n        N:          n,\\n        Level:      level,\\n    }\\n}\\n\\nfunc (g *FriendsGraph) AddEdge(src int, dest int) {\\n    g.AdjList[src] = append(g.AdjList[src], dest)\\n}\\n\\nfunc readFrom(ch chan QElem) QElem {\\n    if len(ch) == 0 {\\n        panic(\"reading from an empty channel/queue\")\\n    }\\n    r := QElem{}\\n    select {\\n        case r = <- ch:\\n        default:\\n        panic(\"read block\")\\n    }\\n    return r\\n}\\n\\nfunc writeTo(ch chan QElem, write QElem) {\\n    select {\\n        case ch <- write:\\n        default:\\n        panic(\"write block\")\\n    }\\n}\\n\\nfunc (g *FriendsGraph) GrabAtLevel() []int {\\n    q := make(chan QElem, 100000)\\n    visitedMap := make(map[int]bool)\\n    writeTo(q, QElem{Id: g.SelfId, Dist: 0})\\n    grabbed := make(map[int]bool)\\n    for len(q) > 0 {\\n        current := readFrom(q)\\n        _, ok := visitedMap[current.Id]\\n        if ok {\\n            continue\\n        }\\n        visitedMap[current.Id] = true\\n        if current.Dist > g.Level {\\n            continue\\n        } else if current.Dist == g.Level {\\n            grabbed[current.Id] = true\\n            continue\\n        } else {\\n            // Iterate through neighbours.\\n            for _, neighbour := range g.AdjList[current.Id] {\\n                _, ok := visitedMap[neighbour]\\n                if !ok {\\n                    writeTo(q, QElem{Id: neighbour, Dist: current.Dist+1})\\n                }\\n            }\\n        }\\n    }\\n    result := make([]int, 0)\\n    for k, _ := range grabbed {\\n        result = append(result, k)\\n    }\\n    return result\\n}\\n\\nfunc watchedVideosByFriends(watchedVideos [][]string, friends [][]int, id int, level int) []string {\\n    fg := NewFriendsGraph(id, len(watchedVideos), level)\\n    for id, frRow := range friends {\\n        for _, friend := range frRow {\\n            fg.AddEdge(id, friend)\\n        }\\n    }\\n    levelGrab := fg.GrabAtLevel()\\n    //fmt.Println(\"Friends: \", levelGrab)\\n    \\n    movieMap := make(map[string]int)\\n    for _, lid := range levelGrab {\\n        for _, wv := range watchedVideos[lid] {\\n            v, _ := movieMap[wv]\\n            movieMap[wv] = v+1\\n        }\\n    }\\n    \\n    mList := make([]MovieCntElem, 0)\\n    for k, v := range movieMap {\\n        mList = append(mList, MovieCntElem{k, v})\\n    }\\n    //fmt.Println(\"MList: \", mList)\\n    mSorter := MovieSorter{mList} \\n    sort.Sort(&mSorter)\\n    \\n    result := make([]string, 0)\\n    for _, mv := range mSorter.movies {\\n        result = append(result, mv.movie)\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype FriendsGraph struct {\\n    SelfId      int\\n    AdjList     [][]int\\n    N           int\\n    Level       int\\n}\\n\\ntype QElem struct {\\n    Id      int\\n    Dist    int\\n}\\n\\ntype MovieCntElem struct {\\n    movie string\\n    cnt int\\n}\\n\\ntype MovieSorter struct {\\n    movies []MovieCntElem\\n}\\n\\nfunc (ms *MovieSorter) Len() int {\\n    return len(ms.movies)\\n}\\n\\nfunc (ms *MovieSorter) Less(i, j int) bool {\\n    if ms.movies[i].cnt != ms.movies[j].cnt {\\n        return ms.movies[i].cnt < ms.movies[j].cnt\\n    }\\n    return ms.movies[i].movie < ms.movies[j].movie\\n}\\n\\nfunc (ms *MovieSorter) Swap(i, j int) {\\n    ms.movies[i], ms.movies[j] = ms.movies[j], ms.movies[i]\\n}\\n\\nfunc NewFriendsGraph(sid, n, level int) *FriendsGraph {\\n    adjList := make([][]int, n)\\n    for i:=0; i<n; i++ {\\n        adjList[i] = make([]int, 0)\\n    }\\n    return &FriendsGraph{\\n        SelfId:     sid,\\n        AdjList:    adjList,\\n        N:          n,\\n        Level:      level,\\n    }\\n}\\n\\nfunc (g *FriendsGraph) AddEdge(src int, dest int) {\\n    g.AdjList[src] = append(g.AdjList[src], dest)\\n}\\n\\nfunc readFrom(ch chan QElem) QElem {\\n    if len(ch) == 0 {\\n        panic(\"reading from an empty channel/queue\")\\n    }\\n    r := QElem{}\\n    select {\\n        case r = <- ch:\\n        default:\\n        panic(\"read block\")\\n    }\\n    return r\\n}\\n\\nfunc writeTo(ch chan QElem, write QElem) {\\n    select {\\n        case ch <- write:\\n        default:\\n        panic(\"write block\")\\n    }\\n}\\n\\nfunc (g *FriendsGraph) GrabAtLevel() []int {\\n    q := make(chan QElem, 100000)\\n    visitedMap := make(map[int]bool)\\n    writeTo(q, QElem{Id: g.SelfId, Dist: 0})\\n    grabbed := make(map[int]bool)\\n    for len(q) > 0 {\\n        current := readFrom(q)\\n        _, ok := visitedMap[current.Id]\\n        if ok {\\n            continue\\n        }\\n        visitedMap[current.Id] = true\\n        if current.Dist > g.Level {\\n            continue\\n        } else if current.Dist == g.Level {\\n            grabbed[current.Id] = true\\n            continue\\n        } else {\\n            // Iterate through neighbours.\\n            for _, neighbour := range g.AdjList[current.Id] {\\n                _, ok := visitedMap[neighbour]\\n                if !ok {\\n                    writeTo(q, QElem{Id: neighbour, Dist: current.Dist+1})\\n                }\\n            }\\n        }\\n    }\\n    result := make([]int, 0)\\n    for k, _ := range grabbed {\\n        result = append(result, k)\\n    }\\n    return result\\n}\\n\\nfunc watchedVideosByFriends(watchedVideos [][]string, friends [][]int, id int, level int) []string {\\n    fg := NewFriendsGraph(id, len(watchedVideos), level)\\n    for id, frRow := range friends {\\n        for _, friend := range frRow {\\n            fg.AddEdge(id, friend)\\n        }\\n    }\\n    levelGrab := fg.GrabAtLevel()\\n    //fmt.Println(\"Friends: \", levelGrab)\\n    \\n    movieMap := make(map[string]int)\\n    for _, lid := range levelGrab {\\n        for _, wv := range watchedVideos[lid] {\\n            v, _ := movieMap[wv]\\n            movieMap[wv] = v+1\\n        }\\n    }\\n    \\n    mList := make([]MovieCntElem, 0)\\n    for k, v := range movieMap {\\n        mList = append(mList, MovieCntElem{k, v})\\n    }\\n    //fmt.Println(\"MList: \", mList)\\n    mSorter := MovieSorter{mList} \\n    sort.Sort(&mSorter)\\n    \\n    result := make([]string, 0)\\n    for _, mv := range mSorter.movies {\\n        result = append(result, mv.movie)\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1838202,
                "title": "bfs-multimap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& friends, int id, int level) {\\n        int nodes=friends.size();\\n        vector<int> vis(nodes,0);\\n        int lev=0;\\n        map<string,int> m;\\n        queue<int> q;\\n        q.push(id);\\n        while(!q.empty()){\\n            lev++;\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                int n=q.front();\\n                q.pop();\\n                vis[n]=1;\\n               for(auto it: friends[n]){\\n                   if(!vis[it]){\\n                       if(lev==level){       //if level is equal to lev then we push all the movies watched by friends at level lev into the map\\n                           for(auto x:w[it]){  \\n                               m[x]++;    \\n                           } \\n                       }\\n                       q.push(it); \\n                   }\\n                   vis[it]=1;\\n               }\\n            }\\n        }\\n            \\n        multimap<int, string> MM;   //we use multimap here to sort the movies alphabetically and frequency wise\\n        vector<string> ans;\\n        for (auto& it : m) {\\n            MM.insert({ it.second, it.first });\\n        }\\n\\n        for (auto& it : MM) {\\n          ans.push_back(it.second);\\n         }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& w, vector<vector<int>>& friends, int id, int level) {\\n        int nodes=friends.size();\\n        vector<int> vis(nodes,0);\\n        int lev=0;\\n        map<string,int> m;\\n        queue<int> q;\\n        q.push(id);\\n        while(!q.empty()){\\n            lev++;\\n            int s=q.size();\\n            for(int i=0;i<s;i++){\\n                int n=q.front();\\n                q.pop();\\n                vis[n]=1;\\n               for(auto it: friends[n]){\\n                   if(!vis[it]){\\n                       if(lev==level){       //if level is equal to lev then we push all the movies watched by friends at level lev into the map\\n                           for(auto x:w[it]){  \\n                               m[x]++;    \\n                           } \\n                       }\\n                       q.push(it); \\n                   }\\n                   vis[it]=1;\\n               }\\n            }\\n        }\\n            \\n        multimap<int, string> MM;   //we use multimap here to sort the movies alphabetically and frequency wise\\n        vector<string> ans;\\n        for (auto& it : m) {\\n            MM.insert({ it.second, it.first });\\n        }\\n\\n        for (auto& it : MM) {\\n          ans.push_back(it.second);\\n         }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826855,
                "title": "java-simple-solution-using-bfs-hashmap-sorting",
                "content": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Map<String, Integer> freq = new TreeMap<>();\\n        \\n        int l = 0;\\n        \\n        boolean[] visited = new boolean[friends.length];\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        q.offer(id);\\n        q.offer(null);\\n        \\n        while(!q.isEmpty()){\\n            Integer u = q.poll();\\n            \\n            if(u != null){\\n                if(visited[u])\\n                    continue;\\n                \\n                visited[u] = true;\\n                \\n                if(l > level)\\n                    break;\\n                \\n                if(l == level){\\n                    for(String watchedVideo: watchedVideos.get(u)){\\n                        if(freq.containsKey(watchedVideo))\\n                            freq.put(watchedVideo, freq.get(watchedVideo)+1);\\n                        else\\n                            freq.put(watchedVideo, 1);\\n                    }\\n                }\\n                \\n                for(int i: friends[u]){\\n                    if(!visited[i])\\n                        q.offer(i);\\n                }\\n            }\\n            else{\\n                l++;\\n                \\n                if(!q.isEmpty())\\n                    q.offer(null);\\n            }\\n        }\\n        \\n        Map<String, Integer> sorted = sort(freq);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for(Map.Entry<String, Integer> map: sorted.entrySet())\\n            res.add(map.getKey());\\n        \\n        return res;\\n    }\\n    \\n    public HashMap<String, Integer> sort(Map<String, Integer> hm){\\n        List<Map.Entry<String, Integer>> l = new LinkedList<>(hm.entrySet());\\n        \\n        Collections.sort(l, new Comparator<Map.Entry<String, Integer>>(){\\n            public int compare(Map.Entry<String, Integer> i1, Map.Entry<String, Integer> i2){\\n                    return i1.getValue() - i2.getValue();\\n            }\\n        });\\n        \\n        HashMap<String, Integer> sorted = new LinkedHashMap<>();\\n        \\n        for(Map.Entry<String, Integer> it: l)\\n            sorted.put(it.getKey(), it.getValue());\\n        \\n        return sorted;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        Map<String, Integer> freq = new TreeMap<>();\\n        \\n        int l = 0;\\n        \\n        boolean[] visited = new boolean[friends.length];\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        q.offer(id);\\n        q.offer(null);\\n        \\n        while(!q.isEmpty()){\\n            Integer u = q.poll();\\n            \\n            if(u != null){\\n                if(visited[u])\\n                    continue;\\n                \\n                visited[u] = true;\\n                \\n                if(l > level)\\n                    break;\\n                \\n                if(l == level){\\n                    for(String watchedVideo: watchedVideos.get(u)){\\n                        if(freq.containsKey(watchedVideo))\\n                            freq.put(watchedVideo, freq.get(watchedVideo)+1);\\n                        else\\n                            freq.put(watchedVideo, 1);\\n                    }\\n                }\\n                \\n                for(int i: friends[u]){\\n                    if(!visited[i])\\n                        q.offer(i);\\n                }\\n            }\\n            else{\\n                l++;\\n                \\n                if(!q.isEmpty())\\n                    q.offer(null);\\n            }\\n        }\\n        \\n        Map<String, Integer> sorted = sort(freq);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for(Map.Entry<String, Integer> map: sorted.entrySet())\\n            res.add(map.getKey());\\n        \\n        return res;\\n    }\\n    \\n    public HashMap<String, Integer> sort(Map<String, Integer> hm){\\n        List<Map.Entry<String, Integer>> l = new LinkedList<>(hm.entrySet());\\n        \\n        Collections.sort(l, new Comparator<Map.Entry<String, Integer>>(){\\n            public int compare(Map.Entry<String, Integer> i1, Map.Entry<String, Integer> i2){\\n                    return i1.getValue() - i2.getValue();\\n            }\\n        });\\n        \\n        HashMap<String, Integer> sorted = new LinkedHashMap<>();\\n        \\n        for(Map.Entry<String, Integer> it: l)\\n            sorted.put(it.getKey(), it.getValue());\\n        \\n        return sorted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782279,
                "title": "c-bsf-and-map",
                "content": "- visit level by level\\n - keep a visited array, and mark IDs as visited just after pushing to stack.\\n - in last level you will have all the IDs, now compute frequency and sort them to build the final answer.\\n **See below code**\\n```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int> vis(n, 0);\\n        int lvl=0;\\n        set<int> q;\\n        q.insert(id);\\n        vis[id]=1;\\n        while(lvl!=level and !q.empty()){\\n            set<int> tmp;\\n            for(auto a: q){\\n                for(auto i: friends[a]){\\n                    if(vis[i]==0){\\n                        tmp.insert(i);\\n                        vis[i]=1;\\n                    }\\n                }\\n            }\\n            q = tmp;\\n            lvl++;\\n        }\\n        map<string, int> mp;\\n        for(auto a: q){\\n            for(auto video: watchedVideos[a]){\\n                mp[video]++;\\n            }\\n        }\\n        vector<pair<int,string>> l;\\n        for(auto [video, cnt]: mp){\\n            l.push_back({cnt, video});\\n        }\\n        sort(l.begin(), l.end());\\n        vector<string> ans;\\n        for(auto a: l){\\n            ans.push_back(a.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        int n = friends.size();\\n        vector<int> vis(n, 0);\\n        int lvl=0;\\n        set<int> q;\\n        q.insert(id);\\n        vis[id]=1;\\n        while(lvl!=level and !q.empty()){\\n            set<int> tmp;\\n            for(auto a: q){\\n                for(auto i: friends[a]){\\n                    if(vis[i]==0){\\n                        tmp.insert(i);\\n                        vis[i]=1;\\n                    }\\n                }\\n            }\\n            q = tmp;\\n            lvl++;\\n        }\\n        map<string, int> mp;\\n        for(auto a: q){\\n            for(auto video: watchedVideos[a]){\\n                mp[video]++;\\n            }\\n        }\\n        vector<pair<int,string>> l;\\n        for(auto [video, cnt]: mp){\\n            l.push_back({cnt, video});\\n        }\\n        sort(l.begin(), l.end());\\n        vector<string> ans;\\n        for(auto a: l){\\n            ans.push_back(a.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781305,
                "title": "java-solution-bfs-hashmap-heap",
                "content": "```\\nclass Solution {\\n    static class Pair\\n    {\\n        String key;\\n        int value;\\n        Pair(String key,int value)\\n        {\\n            this.key=key;\\n            this.value=value;\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        int n=watchedVideos.size();\\n        HashMap<String,Integer> freq=new HashMap<>();\\n        boolean vis[]=new boolean[n];\\n        Queue<Integer> queue=new LinkedList<>();\\n        queue.offer(id);\\n        vis[id]=true;\\n        while(level>=0&&!queue.isEmpty())\\n        {\\n            int size=queue.size();\\n            while(size-->0)\\n            {\\n                int curr=queue.poll();\\n                for(int friend:friends[curr])\\n                {\\n                    if(vis[friend])\\n                        continue;\\n                    queue.add(friend);\\n                    vis[friend]=true;\\n                }\\n                if(level==0)\\n                {\\n                    for(String video:watchedVideos.get(curr))\\n                        freq.put(video,freq.getOrDefault(video,0)+1);\\n                }\\n            }\\n            --level;\\n            \\n        }\\n        PriorityQueue<Pair> pQueue=new PriorityQueue<>((a,b)->{\\n            if(a.value!=b.value)\\n                return a.value-b.value;\\n            return a.key.compareTo(b.key);\\n        });\\n        for(String key:freq.keySet())\\n        {\\n            int times=freq.get(key);\\n            pQueue.add(new Pair(key,times));\\n        }\\n        List<String> ans=new LinkedList<>();\\n        while(!pQueue.isEmpty())\\n            ans.add(pQueue.poll().key);\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static class Pair\\n    {\\n        String key;\\n        int value;\\n        Pair(String key,int value)\\n        {\\n            this.key=key;\\n            this.value=value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1771859,
                "title": "javascript-bfs-sort",
                "content": "```\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n  const queue = [];\\n  queue.push([id, 0]);\\n  const seen = new Set();\\n  const map = {};\\n  \\n  while (queue.length > 0) {\\n    const [id, _level] = queue.shift();\\n    if (seen.has(id)) {\\n      continue;\\n    }\\n    seen.add(id);\\n    if (_level == level) {\\n      for (const video of watchedVideos[id]) {\\n        if (!map[video]) {\\n          map[video] = 1\\n        } else {\\n          map[video] += 1;\\n        }\\n      }\\n      continue;\\n    }\\n    \\n    for (const f of friends[id]) {\\n      queue.push([f, _level + 1]);\\n    }\\n  }\\n  \\n  return Object.keys(map).sort((a, b) => {\\n    const diff = map[a] - map[b];\\n    if (diff == 0) {\\n      return a.localeCompare(b);\\n    }\\n    return diff;\\n  })\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n  const queue = [];\\n  queue.push([id, 0]);\\n  const seen = new Set();\\n  const map = {};\\n  \\n  while (queue.length > 0) {\\n    const [id, _level] = queue.shift();\\n    if (seen.has(id)) {\\n      continue;\\n    }\\n    seen.add(id);\\n    if (_level == level) {\\n      for (const video of watchedVideos[id]) {\\n        if (!map[video]) {\\n          map[video] = 1\\n        } else {\\n          map[video] += 1;\\n        }\\n      }\\n      continue;\\n    }\\n    \\n    for (const f of friends[id]) {\\n      queue.push([f, _level + 1]);\\n    }\\n  }\\n  \\n  return Object.keys(map).sort((a, b) => {\\n    const diff = map[a] - map[b];\\n    if (diff == 0) {\\n      return a.localeCompare(b);\\n    }\\n    return diff;\\n  })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1751281,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        \\n        queue=deque([[id,0]])\\n        freq={} # video->freq map\\n        seenNodes=set()\\n        \\n        # BFS to find the videos watched by friends at level=\"level\"\\n        # O(n) time        \\n        while queue:\\n            node,lvl=queue.popleft()\\n            \\n            if lvl>level or node in seenNodes:continue\\n            if lvl==level:\\n                for video in watchedVideos[node]:\\n                    freq[video]=freq.get(video,0)+1\\n            \\n            seenNodes.add(node)\\n            for friend in friends[node]:\\n                if friend in seenNodes:continue\\n                queue.append([friend,lvl+1])\\n        \\n        # v = # of videos \\n        byFreq={} # freq->video map # O(v)       \\n        for k,v in freq.items():\\n            byFreq[v]=byFreq.get(v, [])+[k]\\n    \\n        byFreq={f:sorted(byFreq[f]) for f in sorted(byFreq.keys())} # O(vlogv)      \\n        \\n        # flatten out the list of videos by freq\\n        ans=[]\\n        [ans.extend(v) for f, v in byFreq.items()]\\n                        \\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        \\n        queue=deque([[id,0]])\\n        freq={}",
                "codeTag": "Java"
            },
            {
                "id": 1711042,
                "title": "c-faster-than-100-less-memory-than-100",
                "content": "```c#\\npublic class Solution {\\n    private HashSet<int> seenFriends;\\n    private HashSet<int> levelFriends;\\n    \\n    public IList<string> WatchedVideosByFriends(IList<IList<string>> watchedVideos, int[][] friends, int id, int level) {\\n        // we start at level 0.\\n        // maintain two sets: one for friends we have seen ever (including at previous levels)\\n        // and one for friends that are always at this level.\\n        seenFriends = new HashSet<int>(new [] { id });\\n        levelFriends = new HashSet<int>(new [] { id });\\n        \\n        // figure out our friends at the given level...\\n        for (var index = 0; index < level; index++) {\\n            var nextLevelFriends = new HashSet<int>();\\n            foreach (var friend in levelFriends) {\\n                \\n                // we want all friends of friends from the previous level that we haven\\'t\\n                // already found at a prior level.\\n                foreach (var nextFriend in friends[friend]) {\\n                    if (seenFriends.Add(nextFriend)) {\\n                        nextLevelFriends.Add(nextFriend);\\n                    }\\n                }\\n            }\\n            levelFriends = nextLevelFriends;\\n        }\\n        \\n        // LINQ is great.  Long live LINQ.\\n        return levelFriends\\n            .SelectMany(friend => watchedVideos[friend])\\n            .GroupBy(video => video)\\n            .OrderBy(g => g.Count())\\n            .ThenBy(g => g.Key)\\n            .Select(g => g.Key)\\n            .ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```c#\\npublic class Solution {\\n    private HashSet<int> seenFriends;\\n    private HashSet<int> levelFriends;\\n    \\n    public IList<string> WatchedVideosByFriends(IList<IList<string>> watchedVideos, int[][] friends, int id, int level) {\\n        // we start at level 0.\\n        // maintain two sets: one for friends we have seen ever (including at previous levels)\\n        // and one for friends that are always at this level.\\n        seenFriends = new HashSet<int>(new [] { id });\\n        levelFriends = new HashSet<int>(new [] { id });\\n        \\n        // figure out our friends at the given level...\\n        for (var index = 0; index < level; index++) {\\n            var nextLevelFriends = new HashSet<int>();\\n            foreach (var friend in levelFriends) {\\n                \\n                // we want all friends of friends from the previous level that we haven\\'t\\n                // already found at a prior level.\\n                foreach (var nextFriend in friends[friend]) {\\n                    if (seenFriends.Add(nextFriend)) {\\n                        nextLevelFriends.Add(nextFriend);\\n                    }\\n                }\\n            }\\n            levelFriends = nextLevelFriends;\\n        }\\n        \\n        // LINQ is great.  Long live LINQ.\\n        return levelFriends\\n            .SelectMany(friend => watchedVideos[friend])\\n            .GroupBy(video => video)\\n            .OrderBy(g => g.Count())\\n            .ThenBy(g => g.Key)\\n            .Select(g => g.Key)\\n            .ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618633,
                "title": "concise-bfs-sort-c",
                "content": "```\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& vids, \\n                                          vector<vector<int>>& frens, int id, int lvl) {\\n        \\n        vector<vector<int>> g(vids.size());\\n        for(int i = 0 ; i < frens.size() ; i++)\\n            for(auto n : frens[i]) g[i].push_back(n);\\n         \\n        map<string, int> res; queue<int> q; q.push(id); \\n        set<int> vis; int k = 0;\\n        \\n        while(q.size() && k <= lvl) {\\n            \\n            int sz = q.size();\\n            while(sz--) {\\n                \\n                auto n = q.front(); q.pop();\\n                if(vis.count(n)) continue;\\n                vis.insert(n);\\n                if(k == lvl) for(auto v : vids[n]) res[v]++;\\n                for(auto nbr : g[n]) q.push(nbr);\\n            }\\n            \\n            k++;\\n        }\\n        \\n        vector<string> v;\\n        for(auto e : res) v.push_back(e.first);\\n        sort(v.begin(), v.end(), [&](auto& a, auto& b) {\\n            if(res[a] == res[b]) return a < b;\\n            return res[a] < res[b];\\n        });\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& vids, \\n                                          vector<vector<int>>& frens, int id, int lvl) {\\n        \\n        vector<vector<int>> g(vids.size());\\n        for(int i = 0 ; i < frens.size() ; i++)\\n            for(auto n : frens[i]) g[i].push_back(n);\\n         \\n        map<string, int> res; queue<int> q; q.push(id); \\n        set<int> vis; int k = 0;\\n        \\n        while(q.size() && k <= lvl) {\\n            \\n            int sz = q.size();\\n            while(sz--) {\\n                \\n                auto n = q.front(); q.pop();\\n                if(vis.count(n)) continue;\\n                vis.insert(n);\\n                if(k == lvl) for(auto v : vids[n]) res[v]++;\\n                for(auto nbr : g[n]) q.push(nbr);\\n            }\\n            \\n            k++;\\n        }\\n        \\n        vector<string> v;\\n        for(auto e : res) v.push_back(e.first);\\n        sort(v.begin(), v.end(), [&](auto& a, auto& b) {\\n            if(res[a] == res[b]) return a < b;\\n            return res[a] < res[b];\\n        });\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1574158,
                "title": "python-level-order-traversal-counter",
                "content": "There is two stages:\\n1. Finding all friends of specified level\\n2. Sorting videos for popularity\\n\\n```\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        visited = set([id])\\n        level_items = [id]\\n        cur_level = 0\\n        \\n        while level_items and cur_level < level:\\n            next_level_items = []\\n            \\n            # adding next level of friends\\n            for cur_id in level_items:\\n                for friend_id in friends[cur_id]:\\n                    if friend_id not in visited:\\n                        next_level_items.append(friend_id)\\n                        visited.add(friend_id)\\n            cur_level += 1\\n            level_items = next_level_items\\n            \\n        # we have needed level of friends\\n        counter = collections.Counter()\\n        for cur_id in level_items:\\n            counter.update(watchedVideos[cur_id])\\n        result_items = sorted(counter.items(), key=lambda x: (x[1], x[0]))\\n        return [x[0] for x in result_items]       \\n```\\t",
                "solutionTags": [],
                "code": "```\\n    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:\\n        visited = set([id])\\n        level_items = [id]\\n        cur_level = 0\\n        \\n        while level_items and cur_level < level:\\n            next_level_items = []\\n            \\n            # adding next level of friends\\n            for cur_id in level_items:\\n                for friend_id in friends[cur_id]:\\n                    if friend_id not in visited:\\n                        next_level_items.append(friend_id)\\n                        visited.add(friend_id)\\n            cur_level += 1\\n            level_items = next_level_items\\n            \\n        # we have needed level of friends\\n        counter = collections.Counter()\\n        for cur_id in level_items:\\n            counter.update(watchedVideos[cur_id])\\n        result_items = sorted(counter.items(), key=lambda x: (x[1], x[0]))\\n        return [x[0] for x in result_items]       \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1529501,
                "title": "c-84ms-74-bfs-double-hash",
                "content": "Runtime: 84 ms, faster than 73.98% of C++ online submissions for Get Watched Videos by Your Friends.\\nMemory Usage: 42.6 MB, less than 5.69% of C++ online submissions for Get Watched Videos by Your Friends.\\n```\\nclass Solution {\\npublic:\\n  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n    vector<vector<int>>graph(watchedVideos.size());\\n    \\n    for(int i = 0;i != friends.size(); i++)\\n      for(auto &f: friends[i])\\n        graph[f].push_back(i), graph[i].push_back(f);\\n    \\n    int tmp_level = 0;\\n    vector<int>vis(watchedVideos.size(),0);\\n    vector<string>ans;\\n    \\n    queue<int>q;\\n    q.push(id);\\n    while(!q.empty()){\\n      if(tmp_level++ == level){\\n        unordered_map<string,int>mp;\\n        while(!q.empty()){\\n          int t = q.front(); q.pop();\\n          if(vis[t])continue;\\n          vis[t] = 1;\\n          for(auto &v: watchedVideos[t]) mp[v]++;\\n        }\\n        set<pair<int,string>>st;  \\n        for(auto &[s, n]: mp) st.insert({n,s});\\n        for(auto &it: st) ans.push_back(it.second);\\n      }\\n                    \\n      int n = q.size();\\n      while(n--){\\n        int t = q.front(); q.pop();\\n        if(vis[t])continue;\\n        vis[t] = 1;\\n        \\n        for(auto &x: graph[t])\\n          if(!vis[x]) q.push(x);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n    vector<vector<int>>graph(watchedVideos.size());\\n    \\n    for(int i = 0;i != friends.size(); i++)\\n      for(auto &f: friends[i])\\n        graph[f].push_back(i), graph[i].push_back(f);\\n    \\n    int tmp_level = 0;\\n    vector<int>vis(watchedVideos.size(),0);\\n    vector<string>ans;\\n    \\n    queue<int>q;\\n    q.push(id);\\n    while(!q.empty()){\\n      if(tmp_level++ == level){\\n        unordered_map<string,int>mp;\\n        while(!q.empty()){\\n          int t = q.front(); q.pop();\\n          if(vis[t])continue;\\n          vis[t] = 1;\\n          for(auto &v: watchedVideos[t]) mp[v]++;\\n        }\\n        set<pair<int,string>>st;  \\n        for(auto &[s, n]: mp) st.insert({n,s});\\n        for(auto &it: st) ans.push_back(it.second);\\n      }\\n                    \\n      int n = q.size();\\n      while(n--){\\n        int t = q.front(); q.pop();\\n        if(vis[t])continue;\\n        vis[t] = 1;\\n        \\n        for(auto &x: graph[t])\\n          if(!vis[x]) q.push(x);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452785,
                "title": "java-solution-bfs-priorityqueue-map",
                "content": "\\tclass Solution {\\n    class VideoCount\\n    {\\n        String v;\\n        int count;\\n        \\n        VideoCount(String v, int count)\\n        {\\n            this.v = v;\\n            this.count = count;\\n        }\\n        \\n        @Override\\n        public String toString()\\n        {\\n            return this.v+\" \"+this.count;\\n        }\\n    }\\n    public List<String> watchedVideosByFriends(List<List<String>> watchedVideos, int[][] friends, int id, int level) {\\n        boolean[] visited = new boolean[watchedVideos.size()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(id);\\n        visited[id] = true;\\n        int currLevel = 0;\\n        \\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            while(size-- > 0)\\n            {\\n                int node = queue.poll();\\n                int[] nei = friends[node];\\n                for(int i : nei)\\n                {\\n                    if(!visited[i])\\n                    {\\n                        queue.add(i);\\n                        visited[i] = true;\\n                    }\\n                }\\n            }\\n            \\n            currLevel++;\\n            \\n            if(currLevel == level)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        Map<String,VideoCount> map = new HashMap<>();\\n        while(!queue.isEmpty())\\n        {\\n            Integer f = queue.poll();\\n            List<String> watchedVideo = watchedVideos.get(f);\\n            for(String video : watchedVideo)\\n            {\\n                map.putIfAbsent(video, new VideoCount(video,0));\\n                map.get(video).count++;\\n            }\\n        }\\n        \\n        PriorityQueue<VideoCount> pq = new PriorityQueue<>((v1,v2) -> (v1.count == v2.count) ? \\n                                                           v1.v.compareTo(v2.v) :\\n                                                           v1.count-v2.count);\\n        for(String key : map.keySet())\\n        {\\n            pq.add(map.get(key));\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n        while(!pq.isEmpty())\\n        {\\n            res.add(pq.poll().v);\\n        }\\n        \\n        return res;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    class VideoCount\\n    {\\n        String v;\\n        int count;\\n        \\n        VideoCount(String v, int count)\\n        {\\n            this.v = v;\\n            this.count = count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1356902,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<string,int> a,pair<string,int> b)\\n    {\\n        if(a.second==b.second)\\n            return a.first<b.first;\\n        return a.second<b.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& fr, int id, int lev) {\\n        vector<string> ans;\\n        queue<int> q;\\n        unordered_map<int,int> mp;\\n        mp[id]=1;\\n        q.push(id);\\n        \\n        while(lev--)\\n        {\\n           int sz=q.size();\\n            while(sz--)\\n            {\\n                int d=q.front();\\n                q.pop();\\n                vector<int> v=fr[d];\\n                for(auto n:v)\\n                {\\n                    if(!mp.count(n))\\n                    {\\n                        mp[n]=1;\\n                        q.push(n);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        unordered_map<string,int> m1;\\n        while(!q.empty())\\n        {\\n            vector<string> vs=wv[q.front()];\\n            q.pop();\\n            for(auto s:vs)\\n                m1[s]++;\\n        }\\n        vector<pair<string,int>> vp;\\n        for(auto it:m1)\\n            vp.push_back({it.first,it.second});\\n        sort(vp.begin(),vp.end(),cmp);\\n        for(auto pp:vp)\\n            ans.push_back(pp.first);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<string,int> a,pair<string,int> b)\\n    {\\n        if(a.second==b.second)\\n            return a.first<b.first;\\n        return a.second<b.second;\\n    }\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& fr, int id, int lev) {\\n        vector<string> ans;\\n        queue<int> q;\\n        unordered_map<int,int> mp;\\n        mp[id]=1;\\n        q.push(id);\\n        \\n        while(lev--)\\n        {\\n           int sz=q.size();\\n            while(sz--)\\n            {\\n                int d=q.front();\\n                q.pop();\\n                vector<int> v=fr[d];\\n                for(auto n:v)\\n                {\\n                    if(!mp.count(n))\\n                    {\\n                        mp[n]=1;\\n                        q.push(n);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        unordered_map<string,int> m1;\\n        while(!q.empty())\\n        {\\n            vector<string> vs=wv[q.front()];\\n            q.pop();\\n            for(auto s:vs)\\n                m1[s]++;\\n        }\\n        vector<pair<string,int>> vp;\\n        for(auto it:m1)\\n            vp.push_back({it.first,it.second});\\n        sort(vp.begin(),vp.end(),cmp);\\n        for(auto pp:vp)\\n            ans.push_back(pp.first);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306258,
                "title": "c-dfs",
                "content": "Most of the solutions are based on BFS, there is only 1 dfs solution, so I will post my dfs solution here.\\n\\nBasically same idea with BFS, the trick in this problem is understand the problem properly:\\n1. hashtable\\n2. sort\\n3. depth-first search\\n\\n```\\n\\nclass Solution {\\npublic:\\nset<int> v;\\nvoid dfs( unordered_map<string, int>& dict, vector<vector<string>> videos, vector<vector<int>> g, int& d, int level, int id){\\n     \\n     if( d == level ){\\n         \\n         for( auto& n: g[id]){\\n            if( v.count(n) != 0 ) continue;\\n            v.insert(n);\\n            for( auto& s: videos[n]){\\n                dict[s]++;\\n            }\\n         }\\n         return;\\n     }\\n    \\n     if( d < level ){\\n         d++;\\n         for( auto& n: g[id]){\\n            v.insert(n);\\n         }\\n         \\n         for( auto& n: g[id]){\\n            dfs( dict, videos, g, d,level, n);\\n         }\\n     } \\n}\\n    \\nstatic bool comp(pair<string,int>& a, pair<string,int>& b){\\n\\n    return a.second == b.second? a.first < b.first : a.second < b.second  ;\\n}\\n    \\nvoid sortfunction(unordered_map<string, int>& M, vector<string>& out)\\n{\\n\\n    vector<pair<string, int> > A;\\n\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n\\n    sort(A.begin(), A.end(), comp);\\n    \\n    for( auto& a: A){\\n        out.push_back(a.first);\\n    }\\n}\\n    \\nvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n    int n = friends.size();\\n\\n    v.insert(id);\\n    vector<string> out;\\n    unordered_map<string, int> dict;\\n    int depth = 1;\\n\\n    dfs(dict, watchedVideos, friends, depth, level, id);\\n\\n    sortfunction(dict, out);\\n\\n    return out;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\nset<int> v;\\nvoid dfs( unordered_map<string, int>& dict, vector<vector<string>> videos, vector<vector<int>> g, int& d, int level, int id){\\n     \\n     if( d == level ){\\n         \\n         for( auto& n: g[id]){\\n            if( v.count(n) != 0 ) continue;\\n            v.insert(n);\\n            for( auto& s: videos[n]){\\n                dict[s]++;\\n            }\\n         }\\n         return;\\n     }\\n    \\n     if( d < level ){\\n         d++;\\n         for( auto& n: g[id]){\\n            v.insert(n);\\n         }\\n         \\n         for( auto& n: g[id]){\\n            dfs( dict, videos, g, d,level, n);\\n         }\\n     } \\n}\\n    \\nstatic bool comp(pair<string,int>& a, pair<string,int>& b){\\n\\n    return a.second == b.second? a.first < b.first : a.second < b.second  ;\\n}\\n    \\nvoid sortfunction(unordered_map<string, int>& M, vector<string>& out)\\n{\\n\\n    vector<pair<string, int> > A;\\n\\n    for (auto& it : M) {\\n        A.push_back(it);\\n    }\\n\\n    sort(A.begin(), A.end(), comp);\\n    \\n    for( auto& a: A){\\n        out.push_back(a.first);\\n    }\\n}\\n    \\nvector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n    int n = friends.size();\\n\\n    v.insert(id);\\n    vector<string> out;\\n    unordered_map<string, int> dict;\\n    int depth = 1;\\n\\n    dfs(dict, watchedVideos, friends, depth, level, id);\\n\\n    sortfunction(dict, out);\\n\\n    return out;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285911,
                "title": "c-bfs-graph-unordered-map-pair-sort",
                "content": "class Graph{\\npublic:\\n\\n    unordered_map<int,list<int>> l;\\n    void add_edge(int u,int v){\\n        l[u].push_back(v);\\n    }\\n};\\n\\nbool compare(pair<int,string> p1,pair<int,string> p2){\\n\\n    if(p1.first==p2.first){\\n        return p1.second<p2.second;\\n    }\\n    return p1.first<p2.first;\\n}\\n\\n\\nclass Solution{\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level){\\n        Graph g;\\n        for(int i=0;i<friends.size();i++){\\n            for(int j=0;j<friends[i].size();j++){\\n                g.add_edge(i,friends[i][j]);\\n            }\\n        }\\n        unordered_map<int,bool> visited;\\n        unordered_map<string,int> mapping;\\n        int start=id;\\n        queue<pair<int,int>> q;\\n        q.push({start,0});\\n        while(!q.empty()){\\n            pair<int,int> temp=q.front();\\n            q.pop();\\n            if(temp.second>level){\\n                continue;\\n            }\\n            if(visited[temp.first]){\\n                continue;\\n            }\\n            visited[temp.first]=true;\\n           \\n            if(temp.second==level){\\n                for(auto&it:watchedVideos[temp.first]){\\n                    mapping[it]++;\\n                }\\n                continue;\\n            }\\n            for(auto&it:g.l[temp.first]){\\n                if(!visited[it]){\\n                    q.push({it,temp.second+1});\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        vector<pair<int,string>> arr;\\n        for(auto&it:mapping){\\n            arr.push_back({it.second,it.first});\\n        }\\n        sort(arr.begin(),arr.end(),compare);\\n        for(auto&it:arr){\\n            ans.push_back(it.second);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution{\\npublic:\\n\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level){\\n        Graph g;\\n        for(int i=0;i<friends.size();i++){\\n            for(int j=0;j<friends[i].size();j++){\\n                g.add_edge(i,friends[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1252789,
                "title": "c-easy-bfs-using-dictionary-hashset-and-sorting",
                "content": "```\\npublic class Solution {\\n    public IList<string> WatchedVideosByFriends(IList<IList<string>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        var n = friends.Length;\\n        \\n        var set = new HashSet<int>();\\n        set.Add(id);\\n        var visited = new bool[n];\\n        visited[id] = true;\\n        \\n        while(level-- > 0)\\n        {\\n            var newSet = new HashSet<int>();\\n            foreach(var item in set)\\n            {               \\n                foreach(var i in friends[item])\\n                {\\n                    if(!visited[i])\\n                    {\\n                        newSet.Add(i);\\n                        visited[i] = true;\\n                    }                        \\n                }                \\n            }\\n            set = newSet;\\n        }        \\n        \\n        var map = new Dictionary<string, int>();\\n        var output = new List<string>();\\n        foreach(var item in set)\\n        {\\n            foreach(var video in watchedVideos[item])\\n            {\\n                if(!map.ContainsKey(video))\\n                {\\n                    map.Add(video, 0);\\n                    output.Add(video);\\n                }                \\n                map[video]++;\\n            }            \\n        }\\n        output.Sort((a,b) => {\\n            if(map[b] == map[a])\\n                return a.CompareTo(b);\\n            else\\n                return map[a] - map[b];\\n        });\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> WatchedVideosByFriends(IList<IList<string>> watchedVideos, int[][] friends, int id, int level) {\\n        \\n        var n = friends.Length;\\n        \\n        var set = new HashSet<int>();\\n        set.Add(id);\\n        var visited = new bool[n];\\n        visited[id] = true;\\n        \\n        while(level-- > 0)\\n        {\\n            var newSet = new HashSet<int>();\\n            foreach(var item in set)\\n            {               \\n                foreach(var i in friends[item])\\n                {\\n                    if(!visited[i])\\n                    {\\n                        newSet.Add(i);\\n                        visited[i] = true;\\n                    }                        \\n                }                \\n            }\\n            set = newSet;\\n        }        \\n        \\n        var map = new Dictionary<string, int>();\\n        var output = new List<string>();\\n        foreach(var item in set)\\n        {\\n            foreach(var video in watchedVideos[item])\\n            {\\n                if(!map.ContainsKey(video))\\n                {\\n                    map.Add(video, 0);\\n                    output.Add(video);\\n                }                \\n                map[video]++;\\n            }            \\n        }\\n        output.Sort((a,b) => {\\n            if(map[b] == map[a])\\n                return a.CompareTo(b);\\n            else\\n                return map[a] - map[b];\\n        });\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226644,
                "title": "kotlin-bfs",
                "content": "The Plan: \\n1. Find friends with shortest path distance of `level` using BFS (we can use BFS for shortest path because it\\'s undirected unweighted graph)\\n2. Get all watched videos by the friends at `level` and sort\\n\\n```\\nfun watchedVideosByFriends(\\n        watchedVideos: List<List<String>>,\\n        friends: Array<IntArray>,\\n        id: Int,\\n\\t\\tlevel: Int\\n    ): List<String> {\\n        if (id + level > friends.size) {\\n            return emptyList()\\n        }\\n\\n        val visited = mutableSetOf(id)\\n        val queue = ArrayDeque<Int>()\\n\\n        queue.offer(id)\\n        var currentLevel = 0\\n\\n        while(queue.isNotEmpty() && currentLevel  < level) {\\n            val levelSize = queue.size\\n\\n            for (i in 1..levelSize) {\\n                val friend = queue.poll()\\n\\n                for (adj in friends[friend]) {\\n                    if (!visited.contains(adj)) {\\n                        queue.offer(adj)\\n                        visited.add(adj)\\n                    }\\n                }\\n            }\\n\\n            currentLevel++\\n        }\\n\\n        return queue\\n            .asSequence()\\n            .flatMap {\\n                watchedVideos[it].asSequence()\\n            }\\n            .groupBy { it }\\n            .map {\\n                it.key to it.value.size\\n            }\\n            .sortedWith(\\n                compareBy(\\n                    { it.second },\\n                    { it.first }\\n                )\\n            )\\n            .map {\\n                it.first\\n            }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun watchedVideosByFriends(\\n        watchedVideos: List<List<String>>,\\n        friends: Array<IntArray>,\\n        id: Int,\\n\\t\\tlevel: Int\\n    ): List<String> {\\n        if (id + level > friends.size) {\\n            return emptyList()\\n        }\\n\\n        val visited = mutableSetOf(id)\\n        val queue = ArrayDeque<Int>()\\n\\n        queue.offer(id)\\n        var currentLevel = 0\\n\\n        while(queue.isNotEmpty() && currentLevel  < level) {\\n            val levelSize = queue.size\\n\\n            for (i in 1..levelSize) {\\n                val friend = queue.poll()\\n\\n                for (adj in friends[friend]) {\\n                    if (!visited.contains(adj)) {\\n                        queue.offer(adj)\\n                        visited.add(adj)\\n                    }\\n                }\\n            }\\n\\n            currentLevel++\\n        }\\n\\n        return queue\\n            .asSequence()\\n            .flatMap {\\n                watchedVideos[it].asSequence()\\n            }\\n            .groupBy { it }\\n            .map {\\n                it.key to it.value.size\\n            }\\n            .sortedWith(\\n                compareBy(\\n                    { it.second },\\n                    { it.first }\\n                )\\n            )\\n            .map {\\n                it.first\\n            }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206305,
                "title": "python-bfs-dictionary",
                "content": "```\\nfrom collections import deque,defaultdict\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos, friends, id: int, level: int) :\\n        ans=[]\\n        d=defaultdict(int)\\n        if level==0:\\n            return watchedVideos[id]\\n        q=deque()\\n        visit=[id]\\n        for f in friends[id]:\\n            q.append((f,1))\\n            visit.append(f)\\n        \\n        while q:\\n            i,l=q.popleft()\\n            if l==level:\\n                for w in watchedVideos[i]:\\n                    d[w]+=1\\n            else:\\n                for f in friends[i]:\\n                    if f not in visit:\\n                        visit.append(f)\\n                        q.append((f,l+1))\\n        return [k for k,v in sorted(d.items(),key=lambda item:(item[1],item[0]))]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque,defaultdict\\nclass Solution:\\n    def watchedVideosByFriends(self, watchedVideos, friends, id: int, level: int) :\\n        ans=[]\\n        d=defaultdict(int)\\n        if level==0:\\n            return watchedVideos[id]\\n        q=deque()\\n        visit=[id]\\n        for f in friends[id]:\\n            q.append((f,1))\\n            visit.append(f)\\n        \\n        while q:\\n            i,l=q.popleft()\\n            if l==level:\\n                for w in watchedVideos[i]:\\n                    d[w]+=1\\n            else:\\n                for f in friends[i]:\\n                    if f not in visit:\\n                        visit.append(f)\\n                        q.append((f,l+1))\\n        return [k for k,v in sorted(d.items(),key=lambda item:(item[1],item[0]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192962,
                "title": "swift-bfs-hashmap-sort",
                "content": "```\\nclass Solution {\\n    func watchedVideosByFriends(\\n        _ watchedVideos: [[String]], \\n        _ friends: [[Int]], \\n        _ id: Int, \\n        _ level: Int\\n    ) -> [String] {\\n        \\n        /*\\n         BFS to find IDs of all users at the given relation level\\n        */\\n        var queue = [Int]()        \\n        var visited = Set<Int>() \\n        \\n        queue.append(id)\\n        visited.insert(id)\\n        \\n        var users = [Int]()\\n        var currentLevel: Int = 1\\n        \\n        while !queue.isEmpty {\\n            for _ in 0..<queue.count {\\n                let userID = queue.removeFirst()       \\n                let userFriends = friends[userID]      \\n                for friend in userFriends {     \\n                    if !visited.contains(friend) {\\n                        queue.append(friend)\\n                        visited.insert(friend)\\n                    }\\n                }\\n            }\\n            if currentLevel == level {\\n                users = queue\\n                break\\n            }\\n            currentLevel += 1\\n        }\\n        \\n        /*\\n         Get all watched videos and determine their frequency\\n        */\\n        var videoNames = [String]()\\n        var videoFreqs = [String: Int]()\\n        for user in users {\\n            let vids = watchedVideos[user]\\n            for vid in vids {\\n                if videoFreqs[vid] != nil {\\n                    videoFreqs[vid]! += 1\\n                } else {\\n                    videoFreqs[vid] = 1\\n                    videoNames.append(vid)\\n                }\\n            }\\n        }\\n        \\n        /* \\n         Return list of watched videos sorted alphabetically and by frequency\\n        */\\n        videoNames.sort(by: <)\\n        videoNames.sort(by: { videoFreqs[$0]! < videoFreqs[$1]! })\\n        return videoNames\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func watchedVideosByFriends(\\n        _ watchedVideos: [[String]], \\n        _ friends: [[Int]], \\n        _ id: Int, \\n        _ level: Int\\n    ) -> [String] {\\n        \\n        /*\\n         BFS to find IDs of all users at the given relation level\\n        */\\n        var queue = [Int]()        \\n        var visited = Set<Int>() \\n        \\n        queue.append(id)\\n        visited.insert(id)\\n        \\n        var users = [Int]()\\n        var currentLevel: Int = 1\\n        \\n        while !queue.isEmpty {\\n            for _ in 0..<queue.count {\\n                let userID = queue.removeFirst()       \\n                let userFriends = friends[userID]      \\n                for friend in userFriends {     \\n                    if !visited.contains(friend) {\\n                        queue.append(friend)\\n                        visited.insert(friend)\\n                    }\\n                }\\n            }\\n            if currentLevel == level {\\n                users = queue\\n                break\\n            }\\n            currentLevel += 1\\n        }\\n        \\n        /*\\n         Get all watched videos and determine their frequency\\n        */\\n        var videoNames = [String]()\\n        var videoFreqs = [String: Int]()\\n        for user in users {\\n            let vids = watchedVideos[user]\\n            for vid in vids {\\n                if videoFreqs[vid] != nil {\\n                    videoFreqs[vid]! += 1\\n                } else {\\n                    videoFreqs[vid] = 1\\n                    videoNames.append(vid)\\n                }\\n            }\\n        }\\n        \\n        /* \\n         Return list of watched videos sorted alphabetically and by frequency\\n        */\\n        videoNames.sort(by: <)\\n        videoNames.sort(by: { videoFreqs[$0]! < videoFreqs[$1]! })\\n        return videoNames\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190088,
                "title": "c-dijkstra-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        vector<string> res;\\n        vector<int> dists(friends.size(), INT_MAX);\\n        unordered_map<string, int> freqs;\\n        auto comp = [&](int p1, int p2){ return dists[p1] > dists[p2]; };\\n        \\n        dists[id] = 0;\\n        priority_queue<int, vector<int>, decltype(comp)> heap(comp);\\n        heap.push(id);\\n        \\n        while (!heap.empty())\\n        {\\n            int top = heap.top();\\n            heap.pop();\\n            for (int f : friends[top])\\n            {\\n                if (dists[f] > dists[top] + 1)\\n                {\\n                    dists[f] = dists[top] + 1;\\n                    heap.push(f);\\n                    if (dists[f] == level)\\n                    {\\n                        for (const auto& video : watchedVideos[f])\\n                        {\\n                            ++freqs[video];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (const auto& pair : freqs)\\n        {\\n            res.push_back(pair.first);\\n        }\\n        \\n        sort(res.begin(), res.end(),\\n            [&](const auto& s1, const auto& s2)\\n             {\\n                 return freqs[s1] < freqs[s2] || (freqs[s1] == freqs[s2] && s1 < s2);\\n             });\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        vector<string> res;\\n        vector<int> dists(friends.size(), INT_MAX);\\n        unordered_map<string, int> freqs;\\n        auto comp = [&](int p1, int p2){ return dists[p1] > dists[p2]; };\\n        \\n        dists[id] = 0;\\n        priority_queue<int, vector<int>, decltype(comp)> heap(comp);\\n        heap.push(id);\\n        \\n        while (!heap.empty())\\n        {\\n            int top = heap.top();\\n            heap.pop();\\n            for (int f : friends[top])\\n            {\\n                if (dists[f] > dists[top] + 1)\\n                {\\n                    dists[f] = dists[top] + 1;\\n                    heap.push(f);\\n                    if (dists[f] == level)\\n                    {\\n                        for (const auto& video : watchedVideos[f])\\n                        {\\n                            ++freqs[video];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (const auto& pair : freqs)\\n        {\\n            res.push_back(pair.first);\\n        }\\n        \\n        sort(res.begin(), res.end(),\\n            [&](const auto& s1, const auto& s2)\\n             {\\n                 return freqs[s1] < freqs[s2] || (freqs[s1] == freqs[s2] && s1 < s2);\\n             });\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180565,
                "title": "javascript-queue",
                "content": "```\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    function Node(val) {\\n        this.val = val\\n        this.neighs = new Set()\\n        this.visited = false\\n        this.videos = []\\n        Node.map.set(val, this)\\n    }\\n    Node.map = new Map()\\n    Node.get = val => Node.map.get(val)\\n    \\n    const len = watchedVideos.length\\n    for (let i = 0; i < len; i++) {\\n        const node = new Node(i)\\n        const videoList = watchedVideos[i]\\n        node.videos = videoList\\n    }\\n    \\n    for (const [i, friendList] of friends.entries()) {\\n        const fromNode = Node.get(i)\\n        for (const friend of friendList.values()) {\\n            const toNode = Node.get(friend)\\n            fromNode.neighs.add(toNode)\\n            toNode.neighs.add(fromNode)\\n        }\\n    }\\n    \\n    \\n    const me = Node.get(id)\\n    me.visited = true\\n    let depth = 0\\n    let queue = [me, null]\\n    \\n    // video id => freq of video id\\n    const map = new Map()\\n    while (queue.length) {\\n        const head = queue.shift()\\n        if (head) {\\n            for (const neigh of head.neighs) {\\n                if (!neigh.visited) {\\n                    neigh.visited = true\\n                    queue.push(neigh)\\n                }\\n            }\\n            if (depth === level) {\\n                const videos = head.videos\\n                for (const video of videos.values()) {\\n                    map.set(video, 1 + (map.get(video) || 0))\\n                }\\n            } else if (depth > level) {\\n                break\\n            }\\n        } else {\\n            if (queue.length)   queue.push(null)\\n            depth++\\n        }\\n    }\\n    \\n    \\n    let result = []\\n    for (const [video, freq] of map.entries()) {\\n        result.push({ video, freq })\\n    }\\n    result.sort((A, B) => (A.freq - B.freq) || A.video.localeCompare(B.video))\\n    result = result.map(A => A.video)\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[][]} watchedVideos\\n * @param {number[][]} friends\\n * @param {number} id\\n * @param {number} level\\n * @return {string[]}\\n */\\nvar watchedVideosByFriends = function(watchedVideos, friends, id, level) {\\n    function Node(val) {\\n        this.val = val\\n        this.neighs = new Set()\\n        this.visited = false\\n        this.videos = []\\n        Node.map.set(val, this)\\n    }\\n    Node.map = new Map()\\n    Node.get = val => Node.map.get(val)\\n    \\n    const len = watchedVideos.length\\n    for (let i = 0; i < len; i++) {\\n        const node = new Node(i)\\n        const videoList = watchedVideos[i]\\n        node.videos = videoList\\n    }\\n    \\n    for (const [i, friendList] of friends.entries()) {\\n        const fromNode = Node.get(i)\\n        for (const friend of friendList.values()) {\\n            const toNode = Node.get(friend)\\n            fromNode.neighs.add(toNode)\\n            toNode.neighs.add(fromNode)\\n        }\\n    }\\n    \\n    \\n    const me = Node.get(id)\\n    me.visited = true\\n    let depth = 0\\n    let queue = [me, null]\\n    \\n    // video id => freq of video id\\n    const map = new Map()\\n    while (queue.length) {\\n        const head = queue.shift()\\n        if (head) {\\n            for (const neigh of head.neighs) {\\n                if (!neigh.visited) {\\n                    neigh.visited = true\\n                    queue.push(neigh)\\n                }\\n            }\\n            if (depth === level) {\\n                const videos = head.videos\\n                for (const video of videos.values()) {\\n                    map.set(video, 1 + (map.get(video) || 0))\\n                }\\n            } else if (depth > level) {\\n                break\\n            }\\n        } else {\\n            if (queue.length)   queue.push(null)\\n            depth++\\n        }\\n    }\\n    \\n    \\n    let result = []\\n    for (const [video, freq] of map.entries()) {\\n        result.push({ video, freq })\\n    }\\n    result.sort((A, B) => (A.freq - B.freq) || A.video.localeCompare(B.video))\\n    result = result.map(A => A.video)\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165704,
                "title": "easy-bfs-soln",
                "content": "```\\nclass Solution {\\npublic:\\n        //using bfs will be a better choice to select short path \\n    //as dfs will reach a node earlier with some great level which could have been visited later on with some lower level \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& f, int id, int level) {\\n        unordered_map<string,int> mp;\\n        int l=-1;int n=f.size();\\n        vector<int> vis(n,0);\\n        queue<int> que;\\n        que.push(id);\\n        vis[id]=1;\\n        while(!que.empty()){\\n            l++;\\n            int k=que.size();\\n            while(k){\\n                k--;\\n                int u=que.front();\\n                que.pop();\\n                if(l==level){\\n                    for(auto &x:wv[u])mp[x]++;\\n                }\\n                for(int &v:f[u]){\\n                    if(!vis[v]){\\n                        que.push(v);\\n                        vis[v]=1;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        set<pair<int,string>> st;\\n        for(auto &x:mp){\\n            st.insert({x.second,x.first});\\n            //cout<<x.first<<\" \"<<x.second<<\"\\\\n\";\\n        }\\n        vector<string> ans;\\n        for(auto &x:st){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        //using bfs will be a better choice to select short path \\n    //as dfs will reach a node earlier with some great level which could have been visited later on with some lower level \\n    vector<string> watchedVideosByFriends(vector<vector<string>>& wv, vector<vector<int>>& f, int id, int level) {\\n        unordered_map<string,int> mp;\\n        int l=-1;int n=f.size();\\n        vector<int> vis(n,0);\\n        queue<int> que;\\n        que.push(id);\\n        vis[id]=1;\\n        while(!que.empty()){\\n            l++;\\n            int k=que.size();\\n            while(k){\\n                k--;\\n                int u=que.front();\\n                que.pop();\\n                if(l==level){\\n                    for(auto &x:wv[u])mp[x]++;\\n                }\\n                for(int &v:f[u]){\\n                    if(!vis[v]){\\n                        que.push(v);\\n                        vis[v]=1;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        set<pair<int,string>> st;\\n        for(auto &x:mp){\\n            st.insert({x.second,x.first});\\n            //cout<<x.first<<\" \"<<x.second<<\"\\\\n\";\\n        }\\n        vector<string> ans;\\n        for(auto &x:st){\\n            ans.push_back(x.second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1165697,
                "title": "javascript-bfs-sort-228ms",
                "content": "```\\nconst watchedVideosByFriends = function (watchedVideos, friends, id, level) {\\n    let n = friends.length;\\n    let visit = Array(n).fill(0);\\n    visit[id] = 1;\\n    let q = [id]; // level friend queue\\n    for (let i = 1; i <= level; i++) {\\n        let tmp = []; // save each level new friend id\\n        for (const e of q) {\\n            for (const fid of friends[e]) {\\n                if (visit[fid]) continue;\\n                visit[fid] = 1;\\n                tmp.push(fid);\\n            }\\n        }\\n        q = tmp; // update queue with new friend\\n    }\\n    let m = new Map(); // freq map\\n    for (const fid of q) {\\n        for (const video of watchedVideos[fid]) {\\n            m.set(video, m.get(video) + 1 || 1);\\n        }\\n    }\\n    let res = Array.from(m.keys());\\n    res.sort((x, y) => {\\n        let cx = m.get(x);\\n        let cy = m.get(y);\\n        if (cx == cy) {\\n            return x.localeCompare(y); // order alphabetically when same freq\\n        }\\n        return cx - cy;\\n    });\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst watchedVideosByFriends = function (watchedVideos, friends, id, level) {\\n    let n = friends.length;\\n    let visit = Array(n).fill(0);\\n    visit[id] = 1;\\n    let q = [id]; // level friend queue\\n    for (let i = 1; i <= level; i++) {\\n        let tmp = []; // save each level new friend id\\n        for (const e of q) {\\n            for (const fid of friends[e]) {\\n                if (visit[fid]) continue;\\n                visit[fid] = 1;\\n                tmp.push(fid);\\n            }\\n        }\\n        q = tmp; // update queue with new friend\\n    }\\n    let m = new Map(); // freq map\\n    for (const fid of q) {\\n        for (const video of watchedVideos[fid]) {\\n            m.set(video, m.get(video) + 1 || 1);\\n        }\\n    }\\n    let res = Array.from(m.keys());\\n    res.sort((x, y) => {\\n        let cx = m.get(x);\\n        let cy = m.get(y);\\n        if (cx == cy) {\\n            return x.localeCompare(y); // order alphabetically when same freq\\n        }\\n        return cx - cy;\\n    });\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155480,
                "title": "c-bfs-with-counting-level-beats-98-69",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        vector<vector<int>> G(friends.size(),vector<int>());\\n        vector<int> seq;\\n        vector<int> visit(friends.size(),0);\\n        queue<int> q;\\n        for(int i=0;i<friends.size();++i){\\n            for(auto &f:friends[i])\\n                G[i].push_back(f);\\n        }\\n        q.push(id);\\n        q.push(-1);\\n        visit[id]=1;\\n        unordered_map<string,int> cnt;\\n        while(q.size() && level){\\n            int n=q.front();\\n            q.pop();\\n\\n            if(n==-1){\\n                --level;\\n                if(level)\\n                    q.push(-1);\\n                continue;\\n            }\\n            for(auto &f:G[n]){\\n                if(visit[f]) \\n                    continue;\\n                if(level==1)//the next layer is the target\\n                    for(auto &v:watchedVideos[f]){\\n                        ++cnt[v];\\n                }\\n                visit[f]=1;\\n                q.push(f);\\n            }\\n        }\\n        vector<pair<string,int>> tmp;\\n        for(auto &r:cnt){\\n            tmp.push_back(r);\\n        }\\n        sort(tmp.begin(),tmp.end(),[](auto& a,auto &b){\\n            if(a.second==b.second)\\n                return a.first<b.first;\\n            else\\n                return a.second<b.second;\\n        });\\n        vector<string> ans;\\n        for(auto &r:tmp){\\n            ans.push_back(r.first);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {\\n        vector<vector<int>> G(friends.size(),vector<int>());\\n        vector<int> seq;\\n        vector<int> visit(friends.size(),0);\\n        queue<int> q;\\n        for(int i=0;i<friends.size();++i){\\n            for(auto &f:friends[i])\\n                G[i].push_back(f);\\n        }\\n        q.push(id);\\n        q.push(-1);\\n        visit[id]=1;\\n        unordered_map<string,int> cnt;\\n        while(q.size() && level){\\n            int n=q.front();\\n            q.pop();\\n\\n            if(n==-1){\\n                --level;\\n                if(level)\\n                    q.push(-1);\\n                continue;\\n            }\\n            for(auto &f:G[n]){\\n                if(visit[f]) \\n                    continue;\\n                if(level==1)//the next layer is the target\\n                    for(auto &v:watchedVideos[f]){\\n                        ++cnt[v];\\n                }\\n                visit[f]=1;\\n                q.push(f);\\n            }\\n        }\\n        vector<pair<string,int>> tmp;\\n        for(auto &r:cnt){\\n            tmp.push_back(r);\\n        }\\n        sort(tmp.begin(),tmp.end(),[](auto& a,auto &b){\\n            if(a.second==b.second)\\n                return a.first<b.first;\\n            else\\n                return a.second<b.second;\\n        });\\n        vector<string> ans;\\n        for(auto &r:tmp){\\n            ans.push_back(r.first);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564849,
                "content": [
                    {
                        "username": "Taranovski",
                        "content": "I didn\\'t find any \"feedback\" button, so I\\'ll post here. \\nThe problem itself is good, I liked it.\\n\\nBUT\\n\\nPLEASE CLARIFY DESCRIPTION AND ADD APPROPRIATE UNIT TEST WITH A SMALL GRAPH!!!!\\n\\nso that people can grasp the essence more clearly.\\nI can propose a small change - in addition to existing part of the description:\\n\\n\"In general, the level k of videos are all watched videos by people with the shortest path equal to k with you.\"\\n\\nyou can add a small example/clarification like:\\n\\n\"we want to find ONLY friends at the given level\\nthat is: \\ngiven level 1 - effectively means any people who are not the initial person\\nlevel 2 means that we are interested only in the friend\\'s friends, EXCLUDING friends of level 1 and the initial person\\nlevel 3 means that we are interested only in the friend\\'s friends\\'s friends, EXCLUDING the initial person, friends of level 1 AND friends of level 2\\nand so on...\"\\n\\nI could not submit the successful solution before contest have ended.\\nI copied you big input for the unit test.\\nIt is not super not fun to debug your large input to finaly get after half an hour that the problem lies in the very first step of how we find friends at the level."
                    },
                    {
                        "username": "rick_014",
                        "content": "The question's description is incomplete.\nSuppose in a level we have interconnecting edges then in which level should we consider the common node.\n\nThe answer is we will consider the common in node in the level which occurs first.\n\n\nEx : [1,2,3] are friends of 0 and 3 is also the friend of [1,2] so in such cases we will consider the common node (which is 3 in this case) in the level which occurs first (which is 1 in this case)."
                    },
                    {
                        "username": "adi_2000",
                        "content": "WHAT IZ DIS QUESTION!!!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach: \n   * Use BFS for traversal and tracking levels.(start traversal from node id(level 0))\n   * For level==given level, store frequency of each string(video) in map.\n   * Return the list of Videos(String) sorted in increasing order of frequencies(For this we can use another map which map frequency to list of videos(String)).\n   * If two videos in list has same frequency, then they must be sorted lexicographically."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This should be a ***hard*** problem."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple BFS approach worked for me!!!"
                    }
                ]
            },
            {
                "id": 1723175,
                "content": [
                    {
                        "username": "Taranovski",
                        "content": "I didn\\'t find any \"feedback\" button, so I\\'ll post here. \\nThe problem itself is good, I liked it.\\n\\nBUT\\n\\nPLEASE CLARIFY DESCRIPTION AND ADD APPROPRIATE UNIT TEST WITH A SMALL GRAPH!!!!\\n\\nso that people can grasp the essence more clearly.\\nI can propose a small change - in addition to existing part of the description:\\n\\n\"In general, the level k of videos are all watched videos by people with the shortest path equal to k with you.\"\\n\\nyou can add a small example/clarification like:\\n\\n\"we want to find ONLY friends at the given level\\nthat is: \\ngiven level 1 - effectively means any people who are not the initial person\\nlevel 2 means that we are interested only in the friend\\'s friends, EXCLUDING friends of level 1 and the initial person\\nlevel 3 means that we are interested only in the friend\\'s friends\\'s friends, EXCLUDING the initial person, friends of level 1 AND friends of level 2\\nand so on...\"\\n\\nI could not submit the successful solution before contest have ended.\\nI copied you big input for the unit test.\\nIt is not super not fun to debug your large input to finaly get after half an hour that the problem lies in the very first step of how we find friends at the level."
                    },
                    {
                        "username": "rick_014",
                        "content": "The question's description is incomplete.\nSuppose in a level we have interconnecting edges then in which level should we consider the common node.\n\nThe answer is we will consider the common in node in the level which occurs first.\n\n\nEx : [1,2,3] are friends of 0 and 3 is also the friend of [1,2] so in such cases we will consider the common node (which is 3 in this case) in the level which occurs first (which is 1 in this case)."
                    },
                    {
                        "username": "adi_2000",
                        "content": "WHAT IZ DIS QUESTION!!!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach: \n   * Use BFS for traversal and tracking levels.(start traversal from node id(level 0))\n   * For level==given level, store frequency of each string(video) in map.\n   * Return the list of Videos(String) sorted in increasing order of frequencies(For this we can use another map which map frequency to list of videos(String)).\n   * If two videos in list has same frequency, then they must be sorted lexicographically."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This should be a ***hard*** problem."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple BFS approach worked for me!!!"
                    }
                ]
            },
            {
                "id": 1964062,
                "content": [
                    {
                        "username": "Taranovski",
                        "content": "I didn\\'t find any \"feedback\" button, so I\\'ll post here. \\nThe problem itself is good, I liked it.\\n\\nBUT\\n\\nPLEASE CLARIFY DESCRIPTION AND ADD APPROPRIATE UNIT TEST WITH A SMALL GRAPH!!!!\\n\\nso that people can grasp the essence more clearly.\\nI can propose a small change - in addition to existing part of the description:\\n\\n\"In general, the level k of videos are all watched videos by people with the shortest path equal to k with you.\"\\n\\nyou can add a small example/clarification like:\\n\\n\"we want to find ONLY friends at the given level\\nthat is: \\ngiven level 1 - effectively means any people who are not the initial person\\nlevel 2 means that we are interested only in the friend\\'s friends, EXCLUDING friends of level 1 and the initial person\\nlevel 3 means that we are interested only in the friend\\'s friends\\'s friends, EXCLUDING the initial person, friends of level 1 AND friends of level 2\\nand so on...\"\\n\\nI could not submit the successful solution before contest have ended.\\nI copied you big input for the unit test.\\nIt is not super not fun to debug your large input to finaly get after half an hour that the problem lies in the very first step of how we find friends at the level."
                    },
                    {
                        "username": "rick_014",
                        "content": "The question's description is incomplete.\nSuppose in a level we have interconnecting edges then in which level should we consider the common node.\n\nThe answer is we will consider the common in node in the level which occurs first.\n\n\nEx : [1,2,3] are friends of 0 and 3 is also the friend of [1,2] so in such cases we will consider the common node (which is 3 in this case) in the level which occurs first (which is 1 in this case)."
                    },
                    {
                        "username": "adi_2000",
                        "content": "WHAT IZ DIS QUESTION!!!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach: \n   * Use BFS for traversal and tracking levels.(start traversal from node id(level 0))\n   * For level==given level, store frequency of each string(video) in map.\n   * Return the list of Videos(String) sorted in increasing order of frequencies(For this we can use another map which map frequency to list of videos(String)).\n   * If two videos in list has same frequency, then they must be sorted lexicographically."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This should be a ***hard*** problem."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple BFS approach worked for me!!!"
                    }
                ]
            },
            {
                "id": 1734026,
                "content": [
                    {
                        "username": "Taranovski",
                        "content": "I didn\\'t find any \"feedback\" button, so I\\'ll post here. \\nThe problem itself is good, I liked it.\\n\\nBUT\\n\\nPLEASE CLARIFY DESCRIPTION AND ADD APPROPRIATE UNIT TEST WITH A SMALL GRAPH!!!!\\n\\nso that people can grasp the essence more clearly.\\nI can propose a small change - in addition to existing part of the description:\\n\\n\"In general, the level k of videos are all watched videos by people with the shortest path equal to k with you.\"\\n\\nyou can add a small example/clarification like:\\n\\n\"we want to find ONLY friends at the given level\\nthat is: \\ngiven level 1 - effectively means any people who are not the initial person\\nlevel 2 means that we are interested only in the friend\\'s friends, EXCLUDING friends of level 1 and the initial person\\nlevel 3 means that we are interested only in the friend\\'s friends\\'s friends, EXCLUDING the initial person, friends of level 1 AND friends of level 2\\nand so on...\"\\n\\nI could not submit the successful solution before contest have ended.\\nI copied you big input for the unit test.\\nIt is not super not fun to debug your large input to finaly get after half an hour that the problem lies in the very first step of how we find friends at the level."
                    },
                    {
                        "username": "rick_014",
                        "content": "The question's description is incomplete.\nSuppose in a level we have interconnecting edges then in which level should we consider the common node.\n\nThe answer is we will consider the common in node in the level which occurs first.\n\n\nEx : [1,2,3] are friends of 0 and 3 is also the friend of [1,2] so in such cases we will consider the common node (which is 3 in this case) in the level which occurs first (which is 1 in this case)."
                    },
                    {
                        "username": "adi_2000",
                        "content": "WHAT IZ DIS QUESTION!!!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach: \n   * Use BFS for traversal and tracking levels.(start traversal from node id(level 0))\n   * For level==given level, store frequency of each string(video) in map.\n   * Return the list of Videos(String) sorted in increasing order of frequencies(For this we can use another map which map frequency to list of videos(String)).\n   * If two videos in list has same frequency, then they must be sorted lexicographically."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This should be a ***hard*** problem."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple BFS approach worked for me!!!"
                    }
                ]
            },
            {
                "id": 1691485,
                "content": [
                    {
                        "username": "Taranovski",
                        "content": "I didn\\'t find any \"feedback\" button, so I\\'ll post here. \\nThe problem itself is good, I liked it.\\n\\nBUT\\n\\nPLEASE CLARIFY DESCRIPTION AND ADD APPROPRIATE UNIT TEST WITH A SMALL GRAPH!!!!\\n\\nso that people can grasp the essence more clearly.\\nI can propose a small change - in addition to existing part of the description:\\n\\n\"In general, the level k of videos are all watched videos by people with the shortest path equal to k with you.\"\\n\\nyou can add a small example/clarification like:\\n\\n\"we want to find ONLY friends at the given level\\nthat is: \\ngiven level 1 - effectively means any people who are not the initial person\\nlevel 2 means that we are interested only in the friend\\'s friends, EXCLUDING friends of level 1 and the initial person\\nlevel 3 means that we are interested only in the friend\\'s friends\\'s friends, EXCLUDING the initial person, friends of level 1 AND friends of level 2\\nand so on...\"\\n\\nI could not submit the successful solution before contest have ended.\\nI copied you big input for the unit test.\\nIt is not super not fun to debug your large input to finaly get after half an hour that the problem lies in the very first step of how we find friends at the level."
                    },
                    {
                        "username": "rick_014",
                        "content": "The question's description is incomplete.\nSuppose in a level we have interconnecting edges then in which level should we consider the common node.\n\nThe answer is we will consider the common in node in the level which occurs first.\n\n\nEx : [1,2,3] are friends of 0 and 3 is also the friend of [1,2] so in such cases we will consider the common node (which is 3 in this case) in the level which occurs first (which is 1 in this case)."
                    },
                    {
                        "username": "adi_2000",
                        "content": "WHAT IZ DIS QUESTION!!!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach: \n   * Use BFS for traversal and tracking levels.(start traversal from node id(level 0))\n   * For level==given level, store frequency of each string(video) in map.\n   * Return the list of Videos(String) sorted in increasing order of frequencies(For this we can use another map which map frequency to list of videos(String)).\n   * If two videos in list has same frequency, then they must be sorted lexicographically."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This should be a ***hard*** problem."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple BFS approach worked for me!!!"
                    }
                ]
            },
            {
                "id": 2056331,
                "content": [
                    {
                        "username": "Taranovski",
                        "content": "I didn\\'t find any \"feedback\" button, so I\\'ll post here. \\nThe problem itself is good, I liked it.\\n\\nBUT\\n\\nPLEASE CLARIFY DESCRIPTION AND ADD APPROPRIATE UNIT TEST WITH A SMALL GRAPH!!!!\\n\\nso that people can grasp the essence more clearly.\\nI can propose a small change - in addition to existing part of the description:\\n\\n\"In general, the level k of videos are all watched videos by people with the shortest path equal to k with you.\"\\n\\nyou can add a small example/clarification like:\\n\\n\"we want to find ONLY friends at the given level\\nthat is: \\ngiven level 1 - effectively means any people who are not the initial person\\nlevel 2 means that we are interested only in the friend\\'s friends, EXCLUDING friends of level 1 and the initial person\\nlevel 3 means that we are interested only in the friend\\'s friends\\'s friends, EXCLUDING the initial person, friends of level 1 AND friends of level 2\\nand so on...\"\\n\\nI could not submit the successful solution before contest have ended.\\nI copied you big input for the unit test.\\nIt is not super not fun to debug your large input to finaly get after half an hour that the problem lies in the very first step of how we find friends at the level."
                    },
                    {
                        "username": "rick_014",
                        "content": "The question's description is incomplete.\nSuppose in a level we have interconnecting edges then in which level should we consider the common node.\n\nThe answer is we will consider the common in node in the level which occurs first.\n\n\nEx : [1,2,3] are friends of 0 and 3 is also the friend of [1,2] so in such cases we will consider the common node (which is 3 in this case) in the level which occurs first (which is 1 in this case)."
                    },
                    {
                        "username": "adi_2000",
                        "content": "WHAT IZ DIS QUESTION!!!"
                    },
                    {
                        "username": "nishant7372",
                        "content": "### Approach: \n   * Use BFS for traversal and tracking levels.(start traversal from node id(level 0))\n   * For level==given level, store frequency of each string(video) in map.\n   * Return the list of Videos(String) sorted in increasing order of frequencies(For this we can use another map which map frequency to list of videos(String)).\n   * If two videos in list has same frequency, then they must be sorted lexicographically."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This should be a ***hard*** problem."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple BFS approach worked for me!!!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Construct the Lexicographically Largest Valid Sequence",
        "question_content": "<p>Given an integer <code>n</code>, find a sequence that satisfies all of the following:</p>\n\n<ul>\n\t<li>The integer <code>1</code> occurs once in the sequence.</li>\n\t<li>Each integer between <code>2</code> and <code>n</code> occurs twice in the sequence.</li>\n\t<li>For every integer <code>i</code> between <code>2</code> and <code>n</code>, the <strong>distance</strong> between the two occurrences of <code>i</code> is exactly <code>i</code>.</li>\n</ul>\n\n<p>The <strong>distance</strong> between two numbers on the sequence, <code>a[i]</code> and <code>a[j]</code>, is the absolute difference of their indices, <code>|j - i|</code>.</p>\n\n<p>Return <em>the <strong>lexicographically largest</strong> sequence</em><em>. It is guaranteed that under the given constraints, there is always a solution. </em></p>\n\n<p>A sequence <code>a</code> is lexicographically larger than a sequence <code>b</code> (of the same length) if in the first position where <code>a</code> and <code>b</code> differ, sequence <code>a</code> has a number greater than the corresponding number in <code>b</code>. For example, <code>[0,1,9,0]</code> is lexicographically larger than <code>[0,1,5,6]</code> because the first position they differ is at the third number, and <code>9</code> is greater than <code>5</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [3,1,2,3,2]\n<strong>Explanation:</strong> [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> [5,3,1,4,3,5,2,4,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1008864,
                "title": "java-c-detailed-explanation-backtracking-100-faster",
                "content": "\\n\\nSince \\'n\\' ranges between 1 to 20 , we can afford a solution of exponential time complexity.\\n\\n1. We try to construct our result array by taking the largest number possible at each point.\\n2. Except  1 (since its count is 1) whenever we place an integer in a particular position, we also place the second occurence of that integer in our temporary array. This is because in the question it is mentioned that  : *For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.*\\n3. As soon as we reach a valid solution that follows all the constraints we return \\'true\\'. This indicates we do not need to continue our search. (This is an important step as otherwise we will get TLE).\\n4. Since we start from largest possible number at each step once we reach a valid solution that is our answer.\\n\\n**Time Complexity** : Ideally it should be (n!) since we are using backtracking and trying to find out all possible solutions.\\nBut because of this constraint : **For every integer i between 2 and n, the distance between the two occurrences of i is exactly i**, the number of permutations under consideration is reducing greatly.\\nAlso since we are trying to find out the **lexicographically largest sequence** we stop as soon as we find a valid solution (early stop).  \\n\\n**Java Code**\\n\\n```\\nclass Solution {\\n\\n        public int[] constructDistancedSequence(int n) {\\n            int[] ans = new int[n * 2 - 1];\\n            boolean[] visited = new boolean[n + 1];\\n            calc(0, ans, visited, n);\\n            return ans;\\n        }\\n\\n        private boolean calc(int index, int[] ans, boolean[] visited, int n) {\\n            if (index == ans.length) {\\n                return true;\\n            }\\n            if (ans[index] != 0) return calc(index + 1, ans, visited, n); // value already assigned in this position. So go ahead with the next index.\\n            else {\\n\\t\\t\\t\\t// we start from n to 1 since we need to find out the lexicographically largest sequence.\\n                for (int i = n; i >= 1; i--) {\\n                    if (visited[i]) continue;\\n                    visited[i] = true;\\n                    ans[index] = i;\\n                    if (i == 1) {\\n                        if (calc(index + 1, ans, visited, n)) return true;\\n                    } else if (index + i < ans.length && ans[index + i] == 0) {\\n                        ans[i + index] = i; // assigning the second occurence of i in the desired position i.e, (current index + i )\\n                        if (calc(index + 1, ans, visited, n)) return true; // largest possible sequence satisfying the given conditions found.\\n                        ans[index + i] = 0;\\n                    }\\n                    ans[index] = 0;\\n                    visited[i] = false;\\n                }\\n\\n            }\\n            return false;\\n        }\\n    }\\n\\t\\n```\\n\\t\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> ans(n * 2 - 1, 0);\\n\\n        vector<bool> visited(n + 1, false);\\n        calc(0, ans, visited, n);\\n        return ans;\\n    }\\n\\nprivate :\\n    bool calc(int index, vector<int> &ans, vector<bool> &visited, int n) {\\n        if (index == ans.size()) {\\n            return true;\\n        }\\n        if (ans[index] != 0)\\n            return calc(index + 1, ans, visited,\\n                        n); // value already assigned in this position. So go ahead with the next index.\\n        else {\\n            // we start from n to 1 since we need to find out the lexicographically largest sequence.\\n            for (int i = n; i >= 1; i--) {\\n                if (visited[i]) continue;\\n                visited[i] = true;\\n                ans[index] = i;\\n                if (i == 1) {\\n                    if (calc(index + 1, ans, visited, n)) return true;\\n                } else if (index + i < ans.size() && ans[index + i] == 0) {\\n                    ans[i +\\n                        index] = i; // assigning the second occurence of i in the desired position i.e, (current index + i )\\n                    if (calc(index + 1, ans, visited, n))\\n                        return true; // largest possible sequence satisfying the given conditions found.\\n                    ans[index + i] = 0;\\n                }\\n                ans[index] = 0;\\n                visited[i] = false;\\n            }\\n\\n        }\\n        return false;\\n    }\\n\\n\\n};\\n```\\n\\t",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n        public int[] constructDistancedSequence(int n) {\\n            int[] ans = new int[n * 2 - 1];\\n            boolean[] visited = new boolean[n + 1];\\n            calc(0, ans, visited, n);\\n            return ans;\\n        }\\n\\n        private boolean calc(int index, int[] ans, boolean[] visited, int n) {\\n            if (index == ans.length) {\\n                return true;\\n            }\\n            if (ans[index] != 0) return calc(index + 1, ans, visited, n); // value already assigned in this position. So go ahead with the next index.\\n            else {\\n\\t\\t\\t\\t// we start from n to 1 since we need to find out the lexicographically largest sequence.\\n                for (int i = n; i >= 1; i--) {\\n                    if (visited[i]) continue;\\n                    visited[i] = true;\\n                    ans[index] = i;\\n                    if (i == 1) {\\n                        if (calc(index + 1, ans, visited, n)) return true;\\n                    } else if (index + i < ans.length && ans[index + i] == 0) {\\n                        ans[i + index] = i; // assigning the second occurence of i in the desired position i.e, (current index + i )\\n                        if (calc(index + 1, ans, visited, n)) return true; // largest possible sequence satisfying the given conditions found.\\n                        ans[index + i] = 0;\\n                    }\\n                    ans[index] = 0;\\n                    visited[i] = false;\\n                }\\n\\n            }\\n            return false;\\n        }\\n    }\\n\\t\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> ans(n * 2 - 1, 0);\\n\\n        vector<bool> visited(n + 1, false);\\n        calc(0, ans, visited, n);\\n        return ans;\\n    }\\n\\nprivate :\\n    bool calc(int index, vector<int> &ans, vector<bool> &visited, int n) {\\n        if (index == ans.size()) {\\n            return true;\\n        }\\n        if (ans[index] != 0)\\n            return calc(index + 1, ans, visited,\\n                        n); // value already assigned in this position. So go ahead with the next index.\\n        else {\\n            // we start from n to 1 since we need to find out the lexicographically largest sequence.\\n            for (int i = n; i >= 1; i--) {\\n                if (visited[i]) continue;\\n                visited[i] = true;\\n                ans[index] = i;\\n                if (i == 1) {\\n                    if (calc(index + 1, ans, visited, n)) return true;\\n                } else if (index + i < ans.size() && ans[index + i] == 0) {\\n                    ans[i +\\n                        index] = i; // assigning the second occurence of i in the desired position i.e, (current index + i )\\n                    if (calc(index + 1, ans, visited, n))\\n                        return true; // largest possible sequence satisfying the given conditions found.\\n                    ans[index + i] = 0;\\n                }\\n                ans[index] = 0;\\n                visited[i] = false;\\n            }\\n\\n        }\\n        return false;\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008913,
                "title": "c-backtracking",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Backtracking\\n\\nAt first I thought it\\'s a greedy / pattern-finding problem. But the pattern I found failed at `n = 7`. So I had to try DFS + Backtracking.\\n\\n~~`ans[0] = ans[n] = n` is obvious~~. (I can\\'t prove this yet, so updated solution to fill from index `0`)\\n\\nFor indexes `0 <= i < ans.size()`, we try the numbers available in descending order. Once we successfully fill all the indexes, we return `ans`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/\\n// Author: github.com/lzl124631x\\n// Time: O(N!)\\n// Space: O(N)\\nclass Solution {\\n    vector<int> used;\\n    bool dfs(vector<int> &ans, int i) {\\n        if (i == ans.size()) return true; // filled all the numbers, found the answer\\n        if (ans[i]) return dfs(ans, i + 1); // this index is already filled, continue to fill the next index.\\n        for (int j = used.size() - 1; j > 0; --j) { // try each number in decending order from n to 1.\\n            if (used[j]) continue; // j is already used, skip\\n            if (j != 1 && (i + j >= ans.size() || ans[i + j])) continue; // we can\\'t fill `ans[i + j]` either because `i + j` is out of bound or `ans[i + j]` is already filled. Skip.\\n            used[j] = 1; // mark number `j` as used.\\n            ans[i] = j; // fill `ans[j]` and `ans[i + j]` (if needed) with `j`.\\n            if (j != 1) ans[i + j] = j;\\n            if (dfs(ans, i + 1)) return true;\\n            ans[i] = 0; // this filling is invalid, backtrack and try the next number.\\n            if (j != 1) ans[i + j] = 0;\\n            used[j] = 0;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> ans(2 * n - 1);\\n        used.assign(n + 1, 0); // numbers 1 ~ n are unused initially\\n        dfs(ans, 0); // try filling numbers from index 0.\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/\\n// Author: github.com/lzl124631x\\n// Time: O(N!)\\n// Space: O(N)\\nclass Solution {\\n    vector<int> used;\\n    bool dfs(vector<int> &ans, int i) {\\n        if (i == ans.size()) return true; // filled all the numbers, found the answer\\n        if (ans[i]) return dfs(ans, i + 1); // this index is already filled, continue to fill the next index.\\n        for (int j = used.size() - 1; j > 0; --j) { // try each number in decending order from n to 1.\\n            if (used[j]) continue; // j is already used, skip\\n            if (j != 1 && (i + j >= ans.size() || ans[i + j])) continue; // we can\\'t fill `ans[i + j]` either because `i + j` is out of bound or `ans[i + j]` is already filled. Skip.\\n            used[j] = 1; // mark number `j` as used.\\n            ans[i] = j; // fill `ans[j]` and `ans[i + j]` (if needed) with `j`.\\n            if (j != 1) ans[i + j] = j;\\n            if (dfs(ans, i + 1)) return true;\\n            ans[i] = 0; // this filling is invalid, backtrack and try the next number.\\n            if (j != 1) ans[i + j] = 0;\\n            used[j] = 0;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> ans(2 * n - 1);\\n        used.assign(n + 1, 0); // numbers 1 ~ n are unused initially\\n        dfs(ans, 0); // try filling numbers from index 0.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009498,
                "title": "c-greedy-search",
                "content": "First, I looked at the constraints. With `n` being so small, I realized that there isn\\'t some clever arrangement algorithm. and this is a search problem.\\n\\nAt first, I did a search that fits numbers largest to smallest, and got TLE.\\n\\nThen, I realized that I need to fit positions left-to-right with the maximum number still available in `nums`. This way, the first valid combination we find would also be the largest one.\\n\\n```cpp\\nvector<int> dfs(vector<int> &nums, vector<int> &arr, int p) {    \\n    if (p == arr.size())\\n        return arr;\\n    if (arr[p] != 0)\\n        return dfs(nums, arr, p + 1);\\n    for (int i = nums.size() - 1; i >= 1; --i) {\\n        int dist = i == 1 ? 0 : i;\\n        if (nums[i] != 0 && dist + p < arr.size() && arr[dist + p] == 0) {\\n            arr[p] = arr[p + dist] = i;\\n            nums[i] = 0;\\n            auto res = dfs(nums, arr, p + 1);\\n            if (!res.empty())\\n                return res;\\n            nums[i] = 1;\\n            arr[p] = arr[p + dist] = 0;\\n        }\\n    }\\n    return {};\\n}\\nvector<int> constructDistancedSequence(int n) {\\n    vector<int> arr((n - 1) * 2 + 1), nums(n + 1, 1);\\n    return dfs(nums, arr, 0);     \\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> dfs(vector<int> &nums, vector<int> &arr, int p) {    \\n    if (p == arr.size())\\n        return arr;\\n    if (arr[p] != 0)\\n        return dfs(nums, arr, p + 1);\\n    for (int i = nums.size() - 1; i >= 1; --i) {\\n        int dist = i == 1 ? 0 : i;\\n        if (nums[i] != 0 && dist + p < arr.size() && arr[dist + p] == 0) {\\n            arr[p] = arr[p + dist] = i;\\n            nums[i] = 0;\\n            auto res = dfs(nums, arr, p + 1);\\n            if (!res.empty())\\n                return res;\\n            nums[i] = 1;\\n            arr[p] = arr[p + dist] = 0;\\n        }\\n    }\\n    return {};\\n}\\nvector<int> constructDistancedSequence(int n) {\\n    vector<int> arr((n - 1) * 2 + 1), nums(n + 1, 1);\\n    return dfs(nums, arr, 0);     \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008948,
                "title": "python-greedy-backtracking-well-explained-comments",
                "content": "The array contains `2*n-1` elements since `1` occurs once and others twice.\\n\\nThe basic idea is, we try to put numbers into the array in a greedy way, since it requires **the only \"Lexicographically Largest\"** one.\\nWe try numbers from `n` to `1` from beginning of the array.\\nEach time we put `x` into the array at index `i`. If `x > 2`, we put another `x` at index `i+x`.\\nNote that we must ensure the availability of indecies `i` and `i+x` for any `x`, `x>2`\\nWe stop when the array is successfully filled.\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        \\n        arr = [0]*(2*n-1)     # the array we want to put numbers. 0 means no number has been put here\\n        i = 0                 # current index to put a number                \\n        vi = [False] * (n+1)  # check if we have used that number\\n        \\n\\t\\t# backtracking\\n        def dfs(arr, i, vi):\\n\\t\\t    # if we already fill the array successfully, return True\\n            if i >= (2*n-1):\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t\\t# try each number from n to 1\\n            for x in range(n, 0, -1):\\n\\t\\t\\t    # two cases:\\n\\t\\t\\t    # x > 1, we check two places. Mind index out of bound here.\\n\\t\\t\\t    # x = 1, we only check one place\\n\\t\\t\\t\\t# arr[i] == 0 means index i is not occupied\\n                if (x > 1 and ((not (arr[i] == 0 and (i+x < 2*n-1) and arr[i+x] == 0)) or vi[x]))  \\\\\\n\\t\\t\\t\\t\\tor (x == 1 and (arr[i] != 0 or vi[x])):\\n                    continue\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if it can be placed, then place it\\n                if x > 1:\\n                    arr[i] = x\\n                    arr[i+x] = x\\n                else:\\n                    arr[i] = x\\n                vi[x] = True\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# find the next available place\\n                nexti = i+1\\n                while nexti < 2*n-1 and arr[nexti]:\\n                    nexti += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# place the next one\\n                if dfs(arr, nexti, vi):\\n\\t\\t\\t\\t\\t# if it success, it is already the lexicographically largest one, we don\\'t search anymore\\n                    return True\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# backtracking... restore the state\\n                if x > 1:\\n                    arr[i] = 0\\n                    arr[i+x] = 0\\n                else:\\n                    arr[i] = 0\\n                vi[x] = False\\n\\t\\t\\t\\n\\t\\t\\t# we could not find a solution, return False\\n            return False\\n\\t\\t\\n        dfs(arr, i, vi)\\n        return arr\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        \\n        arr = [0]*(2*n-1)     # the array we want to put numbers. 0 means no number has been put here\\n        i = 0                 # current index to put a number                \\n        vi = [False] * (n+1)  # check if we have used that number\\n        \\n\\t\\t# backtracking\\n        def dfs(arr, i, vi):\\n\\t\\t    # if we already fill the array successfully, return True\\n            if i >= (2*n-1):\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t\\t# try each number from n to 1\\n            for x in range(n, 0, -1):\\n\\t\\t\\t    # two cases:\\n\\t\\t\\t    # x > 1, we check two places. Mind index out of bound here.\\n\\t\\t\\t    # x = 1, we only check one place\\n\\t\\t\\t\\t# arr[i] == 0 means index i is not occupied\\n                if (x > 1 and ((not (arr[i] == 0 and (i+x < 2*n-1) and arr[i+x] == 0)) or vi[x]))  \\\\\\n\\t\\t\\t\\t\\tor (x == 1 and (arr[i] != 0 or vi[x])):\\n                    continue\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if it can be placed, then place it\\n                if x > 1:\\n                    arr[i] = x\\n                    arr[i+x] = x\\n                else:\\n                    arr[i] = x\\n                vi[x] = True\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# find the next available place\\n                nexti = i+1\\n                while nexti < 2*n-1 and arr[nexti]:\\n                    nexti += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# place the next one\\n                if dfs(arr, nexti, vi):\\n\\t\\t\\t\\t\\t# if it success, it is already the lexicographically largest one, we don\\'t search anymore\\n                    return True\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# backtracking... restore the state\\n                if x > 1:\\n                    arr[i] = 0\\n                    arr[i+x] = 0\\n                else:\\n                    arr[i] = 0\\n                vi[x] = False\\n\\t\\t\\t\\n\\t\\t\\t# we could not find a solution, return False\\n            return False\\n\\t\\t\\n        dfs(arr, i, vi)\\n        return arr\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009406,
                "title": "python-concise-backtracking",
                "content": "The idea is straighforward, try to place the \"large\" number as front as possible.\\n```\\ndef constructDistancedSequence(n):\\n\\tm = 2*n-1\\n\\tA, V = [0] * m, [False] * (n+1)\\n\\tdef dfs(i):\\n\\t\\tif i == m:\\n\\t\\t\\treturn all(A)\\n\\t\\tif A[i]:\\n\\t\\t\\treturn dfs(i+1)\\n\\t\\tfor x in range(n, 0, -1):\\n\\t\\t    j = i if x == 1 else i+x    # This is only to combine some lines of code.\\n\\t\\t\\tif not V[x] and j < m and not A[j]:\\n\\t\\t\\t\\tA[i], A[j], V[x] = x, x, True\\n\\t\\t\\t\\tif dfs(i+1):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tA[i], A[j], V[x] = 0, 0, False\\n\\t\\treturn False\\n\\tdfs(0)\\n\\treturn A\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef constructDistancedSequence(n):\\n\\tm = 2*n-1\\n\\tA, V = [0] * m, [False] * (n+1)\\n\\tdef dfs(i):\\n\\t\\tif i == m:\\n\\t\\t\\treturn all(A)\\n\\t\\tif A[i]:\\n\\t\\t\\treturn dfs(i+1)\\n\\t\\tfor x in range(n, 0, -1):\\n\\t\\t    j = i if x == 1 else i+x    # This is only to combine some lines of code.\\n\\t\\t\\tif not V[x] and j < m and not A[j]:\\n\\t\\t\\t\\tA[i], A[j], V[x] = x, x, True\\n\\t\\t\\t\\tif dfs(i+1):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tA[i], A[j], V[x] = 0, 0, False\\n\\t\\treturn False\\n\\tdfs(0)\\n\\treturn A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1008860,
                "title": "concise-dfs-with-comments-in-java",
                "content": "We just use dfs to try every number for every position. If the number in the current position is not legal or not working, just return and try another number. \\nThe time complexity should be O(n* n!), correct me if I am wrong. The time comlexity is very high, but it can pass, the reason is that we have a very strong pruning. if(flag == true) return; this strong pruning means once we find the answer, we skip other possible results.\\n```\\n\\tboolean flag = false;  // whether we have inserted all numbers 1 to n to the results array.\\n    int[] res;  // To store the final results\\n    public int[] constructDistancedSequence(int n) { \\n        \\n        if(n == 1) return new int[]{1};\\n        int[] A  = new int[n*2 - 1];\\n        \\n        HashSet<Integer> set = new HashSet<>(); // store the number that was used. \\n        boolean[] v = new boolean[A.length]; //v = visited \\n        \\n        dfs(A, 0, v, set, n);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int[] A, int start, boolean[] v, HashSet<Integer> set, int n){\\n        if(flag == true) return; // we already inserted all numbers to the result array, just return\\n        \\n        if(set.size() == n){ // we have inserted all numbers to the result array, so we store the result and return.\\n            res = Arrays.copyOf(A, A.length);\\n            flag = true;\\n            return;\\n        }\\n        if(start >= A.length){\\n            return;\\n        }\\n        \\n        for(int i = start; i < A.length; i++){\\n            if(v[i]) continue; // if we have visited the position i, we skip it.\\n           \\n            for(int j = n; j >= 1; j--){ // we prefer larger number, so the traverse is reverse\\n                if(set.contains(j)) continue; // if we have used the number j, we skip it.\\n                \\n                // if the number to be inserted is NOT 1, we insert the number j into position i and i + j\\n                if(j != 1 && !v[i] && i + j < A.length && !v[i + j]){\\n                    \\n                    A[i] = j;\\n                    A[i + j] = j;\\n                    v[i] = true;\\n                    v[i + j] = true;\\n                    set.add(j);\\n                    \\n                    dfs(A, i + 1, v, set, n);\\n                    \\n                    A[i] = 0;\\n                    A[i + j] = 0;\\n                    v[i] = false;\\n                    v[i + j] = false;\\n                    set.remove(j);\\n                }\\n                \\n                 // if the number to be inserted IS 1,we insert the number 1 into position i.\\n                else if(j == 1){\\n                    A[i] = 1;\\n                    v[i] = true;\\n                    set.add(j);\\n\\n                    dfs(A, i + 1, v, set, n);\\n                    \\n                    A[i] = 0;\\n                    v[i] = false;\\n                    set.remove(j);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "We just use dfs to try every number for every position. If the number in the current position is not legal or not working, just return and try another number. \\nThe time complexity should be O(n* n!), correct me if I am wrong. The time comlexity is very high, but it can pass, the reason is that we have a very strong pruning. if(flag == true) return; this strong pruning means once we find the answer, we skip other possible results.\\n```\\n\\tboolean flag = false;  // whether we have inserted all numbers 1 to n to the results array.\\n    int[] res;  // To store the final results\\n    public int[] constructDistancedSequence(int n) { \\n        \\n        if(n == 1) return new int[]{1};\\n        int[] A  = new int[n*2 - 1];\\n        \\n        HashSet<Integer> set = new HashSet<>(); // store the number that was used. \\n        boolean[] v = new boolean[A.length]; //v = visited \\n        \\n        dfs(A, 0, v, set, n);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int[] A, int start, boolean[] v, HashSet<Integer> set, int n){\\n        if(flag == true) return; // we already inserted all numbers to the result array, just return\\n        \\n        if(set.size() == n){ // we have inserted all numbers to the result array, so we store the result and return.\\n            res = Arrays.copyOf(A, A.length);\\n            flag = true;\\n            return;\\n        }\\n        if(start >= A.length){\\n            return;\\n        }\\n        \\n        for(int i = start; i < A.length; i++){\\n            if(v[i]) continue; // if we have visited the position i, we skip it.\\n           \\n            for(int j = n; j >= 1; j--){ // we prefer larger number, so the traverse is reverse\\n                if(set.contains(j)) continue; // if we have used the number j, we skip it.\\n                \\n                // if the number to be inserted is NOT 1, we insert the number j into position i and i + j\\n                if(j != 1 && !v[i] && i + j < A.length && !v[i + j]){\\n                    \\n                    A[i] = j;\\n                    A[i + j] = j;\\n                    v[i] = true;\\n                    v[i + j] = true;\\n                    set.add(j);\\n                    \\n                    dfs(A, i + 1, v, set, n);\\n                    \\n                    A[i] = 0;\\n                    A[i + j] = 0;\\n                    v[i] = false;\\n                    v[i + j] = false;\\n                    set.remove(j);\\n                }\\n                \\n                 // if the number to be inserted IS 1,we insert the number 1 into position i.\\n                else if(j == 1){\\n                    A[i] = 1;\\n                    v[i] = true;\\n                    set.add(j);\\n\\n                    dfs(A, i + 1, v, set, n);\\n                    \\n                    A[i] = 0;\\n                    v[i] = false;\\n                    set.remove(j);\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1254678,
                "title": "java-backtracking-solution-super-easy",
                "content": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int []sol = new int[(2*n)-1];\\n        boolean[] visited = new boolean[n+1];\\n        helper(0,sol,visited,n);\\n        return sol;\\n    }\\n    \\n    private boolean helper(int i, int[]sol, boolean[] visited, int n){\\n        if(i == sol.length) return true;\\n        \\n        if(sol[i] != 0){\\n            return helper(i+1, sol, visited,n);\\n        }\\n        \\n        for(int j = n; j > 0; j--){\\n            if(!visited[j] && (j == 1 || i+j < sol.length && sol[i+j] == 0)){\\n                sol[i] = j;\\n                if(j != 1) sol[i+j] = j;\\n                visited[j] = true;\\n                \\n                if(helper(i+1,sol,visited,n)) return true;\\n                \\n                sol[i] = 0;\\n                if(j != 1) sol[i+j] = 0;\\n                visited[j] = false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int []sol = new int[(2*n)-1];\\n        boolean[] visited = new boolean[n+1];\\n        helper(0,sol,visited,n);\\n        return sol;\\n    }\\n    \\n    private boolean helper(int i, int[]sol, boolean[] visited, int n){\\n        if(i == sol.length) return true;\\n        \\n        if(sol[i] != 0){\\n            return helper(i+1, sol, visited,n);\\n        }\\n        \\n        for(int j = n; j > 0; j--){\\n            if(!visited[j] && (j == 1 || i+j < sol.length && sol[i+j] == 0)){\\n                sol[i] = j;\\n                if(j != 1) sol[i+j] = j;\\n                visited[j] = true;\\n                \\n                if(helper(i+1,sol,visited,n)) return true;\\n                \\n                sol[i] = 0;\\n                if(j != 1) sol[i+j] = 0;\\n                visited[j] = false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108142,
                "title": "c-backtracking-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> res(1 + (n - 1) * 2, -1); \\n        \\n        unordered_set<int> nums; \\n        \\n        for (int i = 1; i <= n; i++) nums.insert(i); \\n  \\n        dfs(0, n, res, nums);\\n        \\n        return res;\\n    }\\n    \\n    bool dfs(int i, int n, vector<int>& res, unordered_set<int>& nums) {\\n        if (nums.size() == 0) return true; \\n        \\n        if (res[i] != -1) return dfs(i + 1, n, res, nums); \\n\\n        for (int j = n; j >= 1; j--) {\\n            int dist = j == 1 ? 0 : j;\\n            \\n            if (nums.count(j) && (i + dist < res.size() && res[i + dist] == -1)) {\\n                res[i] = res[i + dist] = j; \\n                \\n                nums.erase(j); \\n\\n                if (dfs(i + 1, n, res, nums)) return true; \\n                \\n                res[i] = res[i + dist] = -1;\\n                \\n                nums.insert(j);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> res(1 + (n - 1) * 2, -1); \\n        \\n        unordered_set<int> nums; \\n        \\n        for (int i = 1; i <= n; i++) nums.insert(i); \\n  \\n        dfs(0, n, res, nums);\\n        \\n        return res;\\n    }\\n    \\n    bool dfs(int i, int n, vector<int>& res, unordered_set<int>& nums) {\\n        if (nums.size() == 0) return true; \\n        \\n        if (res[i] != -1) return dfs(i + 1, n, res, nums); \\n\\n        for (int j = n; j >= 1; j--) {\\n            int dist = j == 1 ? 0 : j;\\n            \\n            if (nums.count(j) && (i + dist < res.size() && res[i + dist] == -1)) {\\n                res[i] = res[i + dist] = j; \\n                \\n                nums.erase(j); \\n\\n                if (dfs(i + 1, n, res, nums)) return true; \\n                \\n                res[i] = res[i + dist] = -1;\\n                \\n                nums.insert(j);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009252,
                "title": "clean-c-dfs-with-explanation",
                "content": "Since we want to get the lexicographically greatest sequence, for every index we try to find the largest number which can be put there, and then call dfs on the next index. If dfs returns false, we try to put the next smaller number on given index. When ```i == n```, every index holds the highest possible number and sequence will be lexicographically greatest.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int SIZE, N;\\n\\n    bool fillIndex(vector<int> &a, vector<bool> &used, int idx) {\\n        if(idx == SIZE) return true; \\n        if(a[idx]) return fillIndex(a,used,idx+1);\\n        \\n        for(int num = N-1 ; num >= 1 ; num--) {\\n            if(used[num]) continue;\\n            if(num != 1 and (idx + num >= SIZE or a[idx + num] != 0)) continue;\\n            a[idx] = num;\\n            if(num != 1) a[idx+num] = num;\\n            used[num] = true;\\n            if(fillIndex(a,used,idx+1)) return true;\\n            a[idx] = 0 ;\\n            if(num != 1) a[idx + num] = 0;\\n            used[num] = false;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        SIZE = 1 + (n-1)*2, N = n;\\n        vector<int> a(SIZE,0);\\n        vector<bool> used(n,false);\\n        \\n        if(n==1) {\\n            a[0] = 1;\\n        } else {\\n            a[0] = a[n] = n;\\n            used[n] = true;\\n            fillIndex(a,used,1);\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```i == n```\n```\\nclass Solution {\\npublic:\\n    \\n    int SIZE, N;\\n\\n    bool fillIndex(vector<int> &a, vector<bool> &used, int idx) {\\n        if(idx == SIZE) return true; \\n        if(a[idx]) return fillIndex(a,used,idx+1);\\n        \\n        for(int num = N-1 ; num >= 1 ; num--) {\\n            if(used[num]) continue;\\n            if(num != 1 and (idx + num >= SIZE or a[idx + num] != 0)) continue;\\n            a[idx] = num;\\n            if(num != 1) a[idx+num] = num;\\n            used[num] = true;\\n            if(fillIndex(a,used,idx+1)) return true;\\n            a[idx] = 0 ;\\n            if(num != 1) a[idx + num] = 0;\\n            used[num] = false;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        SIZE = 1 + (n-1)*2, N = n;\\n        vector<int> a(SIZE,0);\\n        vector<bool> used(n,false);\\n        \\n        if(n==1) {\\n            a[0] = 1;\\n        } else {\\n            a[0] = a[n] = n;\\n            used[n] = true;\\n            fillIndex(a,used,1);\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235508,
                "title": "c-simplest-backtracking-solution-with-proper-explanation-of-each-line-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>seen;\\n    bool dfs(vector<int>&ans, int idx)\\n    {\\n        //Built the answer\\n        if(idx == ans.size()) return true;\\n\\t\\t\\n        //If already placed a num at the idx location\\n        if(ans[idx] > 0) return dfs(ans, idx + 1);\\n\\t\\t\\n\\t\\n        //Greedily trying to place nums from n to 1 so as to form lexographically largest ans\\n        for(int i = seen.size() - 1; i >= 1; i--)\\n        {\\n            if(seen[i]) continue;   //Already placed this integer in the answer\\n\\t\\t\\t\\n            //Double number can\\'t be placed then continue\\n            if(i != 1 && (i + idx >= ans.size() || ans[i + idx] )) continue; \\n\\t\\t\\t\\n            seen[i] = 1;   // Mark seen\\n            ans[idx] = i;  //Place integer to ans position idx\\n            if(i != 1) ans[idx + i] = i;  //Place the other one\\n\\t\\t\\t\\n            if(dfs(ans, idx + 1)) return true;  // Check if we can have correct sol if we place integer i at idx location\\n            \\n\\t\\t\\tseen[i] = 0;  // Backtrack\\n            ans[idx] = 0; // Backtrack\\n            if(i != 1) ans[idx + i] = 0; //Backtrack\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n         seen.resize(n + 1, 0);\\n         vector<int> ans (2 * n - 1, 0);\\n         dfs(ans, 0);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>seen;\\n    bool dfs(vector<int>&ans, int idx)\\n    {\\n        //Built the answer\\n        if(idx == ans.size()) return true;\\n\\t\\t\\n        //If already placed a num at the idx location\\n        if(ans[idx] > 0) return dfs(ans, idx + 1);\\n\\t\\t\\n\\t\\n        //Greedily trying to place nums from n to 1 so as to form lexographically largest ans\\n        for(int i = seen.size() - 1; i >= 1; i--)\\n        {\\n            if(seen[i]) continue;   //Already placed this integer in the answer\\n\\t\\t\\t\\n            //Double number can\\'t be placed then continue\\n            if(i != 1 && (i + idx >= ans.size() || ans[i + idx] )) continue; \\n\\t\\t\\t\\n            seen[i] = 1;   // Mark seen\\n            ans[idx] = i;  //Place integer to ans position idx\\n            if(i != 1) ans[idx + i] = i;  //Place the other one\\n\\t\\t\\t\\n            if(dfs(ans, idx + 1)) return true;  // Check if we can have correct sol if we place integer i at idx location\\n            \\n\\t\\t\\tseen[i] = 0;  // Backtrack\\n            ans[idx] = 0; // Backtrack\\n            if(i != 1) ans[idx + i] = 0; //Backtrack\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n         seen.resize(n + 1, 0);\\n         vector<int> ans (2 * n - 1, 0);\\n         dfs(ans, 0);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151119,
                "title": "java-greedy-simple-backtrack-faster-than-100-beginner-friendly-explained",
                "content": "```\\n/*\\ngreedily take the largest possible value for the curr Index as we build the array from left to right because \\nit is always beneficial to choose a larger number in the most signifant pos to create lexicigraphically larger array \\nand check if we can create the valid array by backtracking with given constraints . \\nkeep a boolean flag to check if we have already created an  array so we can terminate all the rest of recursive \\ncalls once we get our largest ans . \\n*/\\n\\nclass Solution {\\n    private static boolean done ; // flag for checking if we already have our ans or not \\n    private static void backtrack(boolean placed[] ,int l , int n , int temp[] ,int [] ans){\\n        if(done == true)\\n            return ;\\n        if(l == temp.length){\\n            done = true ;\\n            System.arraycopy(temp , 0 , ans , 0 , temp.length);\\n            return ;\\n        }\\n        // if currIndex is already set move to next Index\\n        if(temp[l] != 0)\\n            backtrack(placed , l + 1 , n , temp ,ans);\\n        else{\\n            for(int i = n ; i > 0 ; i--){\\n                if(placed[i] == false && i > 1 && l + i < temp.length && temp[l + i] == 0){\\n                    setValue(temp , l , l + i , i , placed , i , true);\\n                    backtrack(placed , l + 1 , n , temp , ans);\\n                    setValue(temp , l , l + i , 0 , placed , i , false);\\n                }\\n                else if(placed[i] == false && i == 1){\\n                    setValue(temp , l , l , i , placed , i , true);\\n                    backtrack(placed , l + 1 , n , temp , ans);\\n                    setValue(temp , l , l , 0 , placed , i , false);\\n                }\\n            } \\n        }\\n    }\\n    public int[] constructDistancedSequence(int n) {\\n        int temp[] = new int[2*n - 1] , ans[] = new int[2*n - 1];;\\n        boolean placed[] = new boolean[n + 1];\\n        done = false;\\n        backtrack(placed , 0 , n , temp , ans);\\n        return ans ;\\n    }\\n    private static void setValue(int nums[],int i ,int j , int val , boolean p[] ,int idx, boolean state){\\n        nums[i] = val ;\\n        nums[j] = val;\\n        p[idx] = state;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\ngreedily take the largest possible value for the curr Index as we build the array from left to right because \\nit is always beneficial to choose a larger number in the most signifant pos to create lexicigraphically larger array \\nand check if we can create the valid array by backtracking with given constraints . \\nkeep a boolean flag to check if we have already created an  array so we can terminate all the rest of recursive \\ncalls once we get our largest ans . \\n*/\\n\\nclass Solution {\\n    private static boolean done ; // flag for checking if we already have our ans or not \\n    private static void backtrack(boolean placed[] ,int l , int n , int temp[] ,int [] ans){\\n        if(done == true)\\n            return ;\\n        if(l == temp.length){\\n            done = true ;\\n            System.arraycopy(temp , 0 , ans , 0 , temp.length);\\n            return ;\\n        }\\n        // if currIndex is already set move to next Index\\n        if(temp[l] != 0)\\n            backtrack(placed , l + 1 , n , temp ,ans);\\n        else{\\n            for(int i = n ; i > 0 ; i--){\\n                if(placed[i] == false && i > 1 && l + i < temp.length && temp[l + i] == 0){\\n                    setValue(temp , l , l + i , i , placed , i , true);\\n                    backtrack(placed , l + 1 , n , temp , ans);\\n                    setValue(temp , l , l + i , 0 , placed , i , false);\\n                }\\n                else if(placed[i] == false && i == 1){\\n                    setValue(temp , l , l , i , placed , i , true);\\n                    backtrack(placed , l + 1 , n , temp , ans);\\n                    setValue(temp , l , l , 0 , placed , i , false);\\n                }\\n            } \\n        }\\n    }\\n    public int[] constructDistancedSequence(int n) {\\n        int temp[] = new int[2*n - 1] , ans[] = new int[2*n - 1];;\\n        boolean placed[] = new boolean[n + 1];\\n        done = false;\\n        backtrack(placed , 0 , n , temp , ans);\\n        return ans ;\\n    }\\n    private static void setValue(int nums[],int i ,int j , int val , boolean p[] ,int idx, boolean state){\\n        nums[i] = val ;\\n        nums[j] = val;\\n        p[idx] = state;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009048,
                "title": "java-beginner-level-backtracking-greedysolution",
                "content": "```java\\nclass Solution {\\n    int[] ans;\\n    public int[] constructDistancedSequence(int n) {\\n        TreeSet<Integer> st = new TreeSet<>();    //  using treeset to iterate optional in sorted(decreasing order)\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\tst.add(-i);    //  adding options(values to add) with -ve sign to achieve decreasing ordered TreeSet\\n\\t\\t}\\n        solve(new int[(2 * n) - 1], 0, st);\\n        return ans;\\n    }\\n    void solve(int[] arr, int idx, TreeSet<Integer> st) {\\n        if (idx == arr.length || this.ans != null) {    //  base case\\n            if (this.ans != null) {    //  ans != null(in case we already have an answer)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n            this.ans = new int[arr.length];    //  we have an answer, just deep copy arr to this.ans and return it as solution\\n            for (int i = 0, sz = arr.length; i < sz; i++) {\\n                this.ans[i] = arr[i];\\n                arr[i] = 0;\\n            }\\n            return;\\n        }\\n        if (arr[idx] != 0) {    //  if our current position is occupied, we will do work for next position\\n            solve(arr, idx + 1, st);\\n            return;\\n        }\\n\\t\\t //  iterate our current options(used a deep copy of set to prevent reshashing while iteration)\\n\\t\\t //  later in loop we will delete values while placing them in array as they are no longer needed\\n        for (int num : new TreeSet<>(st)) {\\n            num = -num;    //  converting to +ve again\\n            if (num == 1) {    //  if num == 1 then only 1 occurence is desired\\n                arr[idx] = 1;\\n                st.remove(-1);\\n                solve(arr, idx + 1, st);\\n                st.add(-1);\\n                arr[idx] = 0;\\n                return;\\n            } else {\\n                if (idx + num >= arr.length || arr[idx + num] != 0) {    //  if idx + num > size or arr[idx + num] != 0 then our num is not suitable\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n                arr[idx] = arr[idx + num] = num;    //  incase suitable then place\\n                st.remove(-num);    //  remove what is used\\n                solve(arr, idx + 1, st);    //  using power of recursion XD\\n                st.add(-num);    //  incase of backtrack, add removed option again\\n                arr[idx] = arr[idx + num] = 0;    //  backtrack\\n                if (ans != null) {    //  if ans != null we already have an answer, return \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n            }\\n        }\\n    }\\n}\\n```\\n\\nHope this helps, suggestions and improvements are appreciated :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    int[] ans;\\n    public int[] constructDistancedSequence(int n) {\\n        TreeSet<Integer> st = new TreeSet<>();    //  using treeset to iterate optional in sorted(decreasing order)\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\tst.add(-i);    //  adding options(values to add) with -ve sign to achieve decreasing ordered TreeSet\\n\\t\\t}\\n        solve(new int[(2 * n) - 1], 0, st);\\n        return ans;\\n    }\\n    void solve(int[] arr, int idx, TreeSet<Integer> st) {\\n        if (idx == arr.length || this.ans != null) {    //  base case\\n            if (this.ans != null) {    //  ans != null(in case we already have an answer)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n            this.ans = new int[arr.length];    //  we have an answer, just deep copy arr to this.ans and return it as solution\\n            for (int i = 0, sz = arr.length; i < sz; i++) {\\n                this.ans[i] = arr[i];\\n                arr[i] = 0;\\n            }\\n            return;\\n        }\\n        if (arr[idx] != 0) {    //  if our current position is occupied, we will do work for next position\\n            solve(arr, idx + 1, st);\\n            return;\\n        }\\n\\t\\t //  iterate our current options(used a deep copy of set to prevent reshashing while iteration)\\n\\t\\t //  later in loop we will delete values while placing them in array as they are no longer needed\\n        for (int num : new TreeSet<>(st)) {\\n            num = -num;    //  converting to +ve again\\n            if (num == 1) {    //  if num == 1 then only 1 occurence is desired\\n                arr[idx] = 1;\\n                st.remove(-1);\\n                solve(arr, idx + 1, st);\\n                st.add(-1);\\n                arr[idx] = 0;\\n                return;\\n            } else {\\n                if (idx + num >= arr.length || arr[idx + num] != 0) {    //  if idx + num > size or arr[idx + num] != 0 then our num is not suitable\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n                arr[idx] = arr[idx + num] = num;    //  incase suitable then place\\n                st.remove(-num);    //  remove what is used\\n                solve(arr, idx + 1, st);    //  using power of recursion XD\\n                st.add(-num);    //  incase of backtrack, add removed option again\\n                arr[idx] = arr[idx + num] = 0;    //  backtrack\\n                if (ans != null) {    //  if ans != null we already have an answer, return \\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446102,
                "title": "c-simple-c-code-80-time",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int m;\\n    bool dfs(int idx, int n, int bitmap, vector<int> &ans)\\n    {\\n        if(idx == m)\\n            return true;\\n        if(ans[idx] != 0)\\n            return dfs(idx+1, n, bitmap, ans);\\n        for(int i = n; i > 0; i--)\\n        {\\n            if(bitmap & (1 << i)) continue;\\n            ans[idx] = i;\\n            if(i == 1)\\n            {\\n                if(dfs(idx+1, n, bitmap | (1 << i), ans))\\n                    return true;\\n            }       \\n            else if(idx+i < m && ans[idx+i] == 0)\\n            {\\n                ans[idx+i] = i;\\n                if(dfs(idx+1, n, bitmap | (1 << i), ans))\\n                    return true;\\n                ans[idx+i] = 0;\\n            }\\n            ans[idx] = 0;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        m = 2*n-1;\\n        vector<int> ans(m, 0);\\n        dfs(0,n,0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    bool dfs(int idx, int n, int bitmap, vector<int> &ans)\\n    {\\n        if(idx == m)\\n            return true;\\n        if(ans[idx] != 0)\\n            return dfs(idx+1, n, bitmap, ans);\\n        for(int i = n; i > 0; i--)\\n        {\\n            if(bitmap & (1 << i)) continue;\\n            ans[idx] = i;\\n            if(i == 1)\\n            {\\n                if(dfs(idx+1, n, bitmap | (1 << i), ans))\\n                    return true;\\n            }       \\n            else if(idx+i < m && ans[idx+i] == 0)\\n            {\\n                ans[idx+i] = i;\\n                if(dfs(idx+1, n, bitmap | (1 << i), ans))\\n                    return true;\\n                ans[idx+i] = 0;\\n            }\\n            ans[idx] = 0;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        m = 2*n-1;\\n        vector<int> ans(m, 0);\\n        dfs(0,n,0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009010,
                "title": "python-dfs-backtracking-and-be-greedy",
                "content": "Intuition: I tried to construct the answer like the problem\\'s title, but failed once, so later tried a `brute force` way, but then realized it\\'s not that brute force, as we always try to fill the largest number, if it turned out not working at the end, we step back and try the next largest number. This way, the first path we ever find will be the answer, and we can stop right here.\\n\\nTime: Not sure TBH. I noticed that the answer will always start with `n`, and I counted the steps of dfs(), for `n=20` the `steps=2600`, so the time complexity is fairly small, due to the greedy strategy.\\nSpace: O(n) as we always fill at least one position each time, so the stack height is at most O(n), the answer also takes O(n) space.\\n\\n```python\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.ans = None\\n        def dfs(path, used, i):\\n            self.steps += 1\\n            if i == len(path):\\n                self.ans = path[:]\\n                return True\\n            if path[i] != 0:\\n                return dfs(path, used, i + 1)\\n            my_ans = [0]\\n            for x in range(n, 0, -1):\\n                if x in used:\\n                    continue\\n                if x == 1:\\n                    path[i] = x\\n                    used.add(1)\\n                    \\n                    if dfs(path, used, i + 1):\\n                        return True\\n                    \\n                    path[i] = 0\\n                    used.remove(1)\\n                if i + x < len(path) and path[i + x] == 0:\\n                    path[i + x] = path[i] = x\\n                    used.add(x)\\n                    \\n                    if dfs(path, used, i + 1):\\n                        return True\\n                    \\n                    path[i + x] = path[i] = 0\\n                    used.remove(x)\\n\\n            return False\\n\\n        dfs([0] * (1 + 2 * (n - 1)), set(), 0)\\n        \\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.ans = None\\n        def dfs(path, used, i):\\n            self.steps += 1\\n            if i == len(path):\\n                self.ans = path[:]\\n                return True\\n            if path[i] != 0:\\n                return dfs(path, used, i + 1)\\n            my_ans = [0]\\n            for x in range(n, 0, -1):\\n                if x in used:\\n                    continue\\n                if x == 1:\\n                    path[i] = x\\n                    used.add(1)\\n                    \\n                    if dfs(path, used, i + 1):\\n                        return True\\n                    \\n                    path[i] = 0\\n                    used.remove(1)\\n                if i + x < len(path) and path[i + x] == 0:\\n                    path[i + x] = path[i] = x\\n                    used.add(x)\\n                    \\n                    if dfs(path, used, i + 1):\\n                        return True\\n                    \\n                    path[i + x] = path[i] = 0\\n                    used.remove(x)\\n\\n            return False\\n\\n        dfs([0] * (1 + 2 * (n - 1)), set(), 0)\\n        \\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442114,
                "title": "python-3-15-lines-backtrack-t-m-77-78",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        def backtrack(idx1 = 0): \\n\\n            if not unseen: return True\\n\\n            if ans[idx1]: return backtrack(idx1+1)\\n\\n            for num in reversed(range(1,n+1)):\\n\\n                idx2 = idx1 + num if num != 1 else idx1\\n\\n                if num in unseen and idx2 < n+n-1 and not ans[idx2]:\\n                    ans[idx1] = ans[idx2] = num\\n                    unseen.remove(num)\\n\\n                    if backtrack(idx1+1): return True\\n                    ans[idx1] = ans[idx2] = 0\\n                    unseen.add(num)\\n\\n            return False\\n\\n        ans, unseen = [0]*(n+n-1), set(range(1,n+1))\\n\\n        backtrack()\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/submissions/937592483/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N!*) (worst-case) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        def backtrack(idx1 = 0): \\n\\n            if not unseen: return True\\n\\n            if ans[idx1]: return backtrack(idx1+1)\\n\\n            for num in reversed(range(1,n+1)):\\n\\n                idx2 = idx1 + num if num != 1 else idx1\\n\\n                if num in unseen and idx2 < n+n-1 and not ans[idx2]:\\n                    ans[idx1] = ans[idx2] = num\\n                    unseen.remove(num)\\n\\n                    if backtrack(idx1+1): return True\\n                    ans[idx1] = ans[idx2] = 0\\n                    unseen.add(num)\\n\\n            return False\\n\\n        ans, unseen = [0]*(n+n-1), set(range(1,n+1))\\n\\n        backtrack()\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247869,
                "title": "c-0ms-100-faster-easy-explanation",
                "content": "The main idea is to check which maximum value we can put at the current index, we put it and then call recursion for the next index. If it returns true then we have got the answer. Else we will backtrack and set other large value on current index and do the same thing.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool recurse(int index, vector<bool> &visited, vector<int> &arr, int &n, int left)\\n    {\\n        if(left == 0)\\n            return true;\\n        if(arr[index] != -1)\\n            return recurse(index + 1, visited, arr, n, left);\\n        for(int i=n;i>=1;i--)\\n        {\\n            if(visited[i])\\n                continue;\\n            if(i == 1)\\n            {\\n                arr[index] = 1;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-1))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                visited[i] = false;\\n            }\\n            else\\n            {\\n                if(index + i >= arr.size() || arr[index+i] != -1)\\n                    continue;\\n                arr[index] = i;\\n                arr[index+i] = i;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-2))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                arr[index+i] = -1;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        vector<int> arr(2*n-1, -1);        \\n        vector<bool> visited(n+1, false);\\n        visited[0] = true;\\n        recurse(0, visited, arr, n, 2*n-1);\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool recurse(int index, vector<bool> &visited, vector<int> &arr, int &n, int left)\\n    {\\n        if(left == 0)\\n            return true;\\n        if(arr[index] != -1)\\n            return recurse(index + 1, visited, arr, n, left);\\n        for(int i=n;i>=1;i--)\\n        {\\n            if(visited[i])\\n                continue;\\n            if(i == 1)\\n            {\\n                arr[index] = 1;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-1))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                visited[i] = false;\\n            }\\n            else\\n            {\\n                if(index + i >= arr.size() || arr[index+i] != -1)\\n                    continue;\\n                arr[index] = i;\\n                arr[index+i] = i;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-2))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                arr[index+i] = -1;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        vector<int> arr(2*n-1, -1);        \\n        vector<bool> visited(n+1, false);\\n        visited[0] = true;\\n        recurse(0, visited, arr, n, 2*n-1);\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713862,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> res;\\n    bool fun(vector<int> &arr, vector<bool> &used, int pos, int count, int N)\\n    {\\n        if(count==arr.size()) //count variable stores the number of elements added till now\\n        {\\n            res=arr;\\n            return true;\\n        }\\n        if(arr[pos]!=-1)\\n            return fun(arr,used,pos+1,count,N);\\n        for(int j=N;j>=1;j--) //go backwards in order to find largest sequence first\\n        {\\n            if(used[j]) \\n                continue;\\n            if(j==1) //if the integer is 1, store only once as per question\\n            {\\n                arr[pos]=j;\\n                used[j]=true;\\n                if(fun(arr,used,pos+1,count+1,N))\\n                    return true;\\n                arr[pos]=-1;\\n                used[j]=false;\\n            }\\n            else //in case of other integers, store twice\\n            {\\n                if(j+pos>=arr.size() || arr[j+pos]!=-1)\\n                    continue;\\n                arr[pos]=j;\\n                arr[pos+j]=j;\\n                used[j]=true;\\n                if(fun(arr,used,pos+1,count+2,N)) //our first sequence will be lexicographically largest so we don\\'t want to find more sequences \\n                    return true;\\n                arr[pos]=-1;\\n                arr[pos+j]=-1;\\n                used[j]=false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        res.clear();\\n        vector<bool> used(n+1,false);\\n        vector<int> arr(2*n-1,-1); //the sequence is supposed to have 2*n-1 elements\\n        fun(arr,used,0,0,n);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> res;\\n    bool fun(vector<int> &arr, vector<bool> &used, int pos, int count, int N)\\n    {\\n        if(count==arr.size()) //count variable stores the number of elements added till now\\n        {\\n            res=arr;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1062480,
                "title": "python3-backtracking",
                "content": "**Algo**\\nThis a typical backtracking problem. Essentially, we have an array of `2*n-1` positions for which we progressively fill in numbers of `1, ..., n` of which `1` has multiplicity 1 and the others have 2. \\n\\nHere the strategy is that we aggresively fill in large numbers in high position if possible. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        ans = [0]*(2*n-1)\\n        \\n        def fn(i): \\n            \"\"\"Return largest sequence after filling in ith position.\"\"\"\\n            if i == 2*n-1 or ans[i] and fn(i+1): return True \\n            for x in reversed(range(1, n+1)): \\n                if x not in ans: \\n                    ii = x if x > 1 else 0 \\n                    if i+ii < 2*n-1 and ans[i] == ans[i+ii] == 0: \\n                        ans[i] = ans[i+ii] = x\\n                        if fn(i+1): return True \\n                        ans[i] = ans[i+ii] = 0 \\n        \\n        fn(0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        ans = [0]*(2*n-1)\\n        \\n        def fn(i): \\n            \"\"\"Return largest sequence after filling in ith position.\"\"\"\\n            if i == 2*n-1 or ans[i] and fn(i+1): return True \\n            for x in reversed(range(1, n+1)): \\n                if x not in ans: \\n                    ii = x if x > 1 else 0 \\n                    if i+ii < 2*n-1 and ans[i] == ans[i+ii] == 0: \\n                        ans[i] = ans[i+ii] = x\\n                        if fn(i+1): return True \\n                        ans[i] = ans[i+ii] = 0 \\n        \\n        fn(0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010771,
                "title": "javascript-greedily-backtracking",
                "content": "```\\n/**\\n * 1718-construct-the-lexicographically-largest-valid-sequence.js\\n *\\n * Input: n = 3\\n * Output: [3,1,2,3,2]\\n *\\n * Input: n = 5\\n * Output: [5,3,1,4,3,5,2,4,2]\\n *\\n * Constrcut from large to small, the first returned answer is the final answer\\n */\\nvar constructDistancedSequence = function (n) {\\n  if (n === 1) return [1];\\n  const res = Array(2 * n - 1).fill(0);\\n  const seen = new Set();\\n  const dfs = (idx = 0) => {\\n    if (idx === 2 * n - 1) return true;\\n    if (res[idx]) return dfs(idx + 1); // If already filled, go to next\\n    for (let i = n; i >= 1; i--) {\\n      if (seen.has(i)) continue;\\n      if (i === 1 || (idx + i < res.length && !res[idx + i])) {\\n        res[idx] = i;\\n        seen.add(i);\\n        if (i > 1) res[idx + i] = i;\\n        if (dfs(idx + 1)) return true;\\n        res[idx] = 0;\\n        seen.delete(i);\\n        if (i > 1) res[idx + i] = 0;\\n      }\\n    }\\n  };\\n  dfs();\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * 1718-construct-the-lexicographically-largest-valid-sequence.js\\n *\\n * Input: n = 3\\n * Output: [3,1,2,3,2]\\n *\\n * Input: n = 5\\n * Output: [5,3,1,4,3,5,2,4,2]\\n *\\n * Constrcut from large to small, the first returned answer is the final answer\\n */\\nvar constructDistancedSequence = function (n) {\\n  if (n === 1) return [1];\\n  const res = Array(2 * n - 1).fill(0);\\n  const seen = new Set();\\n  const dfs = (idx = 0) => {\\n    if (idx === 2 * n - 1) return true;\\n    if (res[idx]) return dfs(idx + 1); // If already filled, go to next\\n    for (let i = n; i >= 1; i--) {\\n      if (seen.has(i)) continue;\\n      if (i === 1 || (idx + i < res.length && !res[idx + i])) {\\n        res[idx] = i;\\n        seen.add(i);\\n        if (i > 1) res[idx + i] = i;\\n        if (dfs(idx + 1)) return true;\\n        res[idx] = 0;\\n        seen.delete(i);\\n        if (i > 1) res[idx + i] = 0;\\n      }\\n    }\\n  };\\n  dfs();\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009503,
                "title": "python-c-backtracking-faster-than-100",
                "content": "Python\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        def backtrack(i):\\n            if i == N: return True\\n            if ans[i]: return backtrack(i + 1)\\n            for j in reversed(range(1, n + 1)):         # for the lexicographically largest \\n                if v[j]: continue                       # if visited\\n                if j == 1:                              # 1 occurs once\\n                    v[j], ans[i] = 1, j\\n                    if backtrack(i + 1): return True\\n                    v[j], ans[i] = 0, 0\\n                elif i + j < N and ans[i + j] == 0:     # other numbers occur twice \\n                    v[j], ans[i], ans[i + j] = 1, j, j\\n                    if backtrack(i + 1): return True\\n                    v[j], ans[i], ans[i + j] = 0, 0, 0\\n            return False\\n\\n        N = 2 * n - 1 \\n        v, ans = [0] * (n + 1), [0] * N\\n        backtrack(0)\\n        return ans\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> v(n + 1);\\n        vector<int> ans(2 * n - 1);\\n        backtrack(ans, v, n, 0);\\n        return ans;\\n    }\\nprivate:\\n    bool backtrack(vector<int> &ans, vector<int> &v, int n, int i){\\n        if (i == ans.size()) return true;\\n        if (ans[i] != 0)\\n            return backtrack(ans, v, n, i + 1);\\n        for(int j = n; j > 0; --j){\\n            if (v[j] == 1) continue;\\n            if (j == 1){\\n                v[j] = 1; ans[i] = j;\\n                if (backtrack(ans, v, n, i + 1)) return true;\\n                v[j] = 0; ans[i] = 0;\\n            }else if(i + j < ans.size() && ans[i + j] == 0){\\n                v[j] = 1; ans[i] = j; ans[i + j] = j;\\n                if (backtrack(ans, v, n, i + 1)) return true;\\n                v[j] = 0; ans[i] = 0; ans[i + j] = 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        def backtrack(i):\\n            if i == N: return True\\n            if ans[i]: return backtrack(i + 1)\\n            for j in reversed(range(1, n + 1)):         # for the lexicographically largest \\n                if v[j]: continue                       # if visited\\n                if j == 1:                              # 1 occurs once\\n                    v[j], ans[i] = 1, j\\n                    if backtrack(i + 1): return True\\n                    v[j], ans[i] = 0, 0\\n                elif i + j < N and ans[i + j] == 0:     # other numbers occur twice \\n                    v[j], ans[i], ans[i + j] = 1, j, j\\n                    if backtrack(i + 1): return True\\n                    v[j], ans[i], ans[i + j] = 0, 0, 0\\n            return False\\n\\n        N = 2 * n - 1 \\n        v, ans = [0] * (n + 1), [0] * N\\n        backtrack(0)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> v(n + 1);\\n        vector<int> ans(2 * n - 1);\\n        backtrack(ans, v, n, 0);\\n        return ans;\\n    }\\nprivate:\\n    bool backtrack(vector<int> &ans, vector<int> &v, int n, int i){\\n        if (i == ans.size()) return true;\\n        if (ans[i] != 0)\\n            return backtrack(ans, v, n, i + 1);\\n        for(int j = n; j > 0; --j){\\n            if (v[j] == 1) continue;\\n            if (j == 1){\\n                v[j] = 1; ans[i] = j;\\n                if (backtrack(ans, v, n, i + 1)) return true;\\n                v[j] = 0; ans[i] = 0;\\n            }else if(i + j < ans.size() && ans[i + j] == 0){\\n                v[j] = 1; ans[i] = j; ans[i + j] = j;\\n                if (backtrack(ans, v, n, i + 1)) return true;\\n                v[j] = 0; ans[i] = 0; ans[i + j] = 0;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008974,
                "title": "java-solution-with-explanation-help-with-time-complexity",
                "content": "The idea is following:\\n* \\tYou need the largest subsequence, so try to fill the lowest index with maximum value.\\n* \\tStart with index 0, try to fill n in this.\\n* \\tThen for index 1, try to fill (n-1) in the index.\\n* \\tIf you any index and value combination, the valid subsequence can\\'t be formed.\\n* \\tTry for index+1 in the value.\\n\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2*n - 1];\\n        \\n        canConstruct(res,0, n, new HashSet<>());\\n        \\n        for(int i=0;i<res.length;i++) {\\n            if(res[i] == 0) {\\n                res[i] = 1;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean canConstruct(int[] res, int start, int n, Set<Integer> valuesUsed) {\\n        \\n        if(valuesUsed.size() == (n-1)) {\\n            return true;\\n        }\\n        \\n        for(int i=start;i<res.length;i++) {\\n            \\n            if(res[i] != 0) {\\n                continue;\\n            }\\n            \\n            for(int j=n;j>1;j--) {\\n                if(valuesUsed.contains(j) || (i+j) >= res.length || res[i+j] != 0) {\\n                    continue;\\n                }\\n                res[i] = j;\\n                res[i+j] = j;\\n                valuesUsed.add(j);\\n                if(canConstruct(res, i+1, n, valuesUsed)) {\\n                    return true;\\n                }else {\\n                    res[i] = 0;\\n                    res[i+j] = 0;\\n                    valuesUsed.remove(j);\\n                }\\n            }\\n        }\\n            \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2*n - 1];\\n        \\n        canConstruct(res,0, n, new HashSet<>());\\n        \\n        for(int i=0;i<res.length;i++) {\\n            if(res[i] == 0) {\\n                res[i] = 1;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private boolean canConstruct(int[] res, int start, int n, Set<Integer> valuesUsed) {\\n        \\n        if(valuesUsed.size() == (n-1)) {\\n            return true;\\n        }\\n        \\n        for(int i=start;i<res.length;i++) {\\n            \\n            if(res[i] != 0) {\\n                continue;\\n            }\\n            \\n            for(int j=n;j>1;j--) {\\n                if(valuesUsed.contains(j) || (i+j) >= res.length || res[i+j] != 0) {\\n                    continue;\\n                }\\n                res[i] = j;\\n                res[i+j] = j;\\n                valuesUsed.add(j);\\n                if(canConstruct(res, i+1, n, valuesUsed)) {\\n                    return true;\\n                }else {\\n                    res[i] = 0;\\n                    res[i+j] = 0;\\n                    valuesUsed.remove(j);\\n                }\\n            }\\n        }\\n            \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701869,
                "title": "java-backtracking-with-a-lot-comment",
                "content": "```\\n/*\\n// observation\\n// 1 total result length should be n * 2 - 1\\n// 2 track the times of usage of each number\\n    each number i can be only use twice with i difference. So we do not need to track the times of usage anymore\\n    each time we use i at index, then we use i at index + i as well. Then each time we consume number i twice, then no need to track anymore\\n// 3 track the index usage of each time\\n    we can give a inital value such as -1 to indicate the index has not been used yet\\n// 4 track if the number already used\\n    either use an array or a set to check- I use Set here\\n// 5 try all the scenarios\\n// 6 how to keep the lexicographically? - try large number first\\n*/\\nclass Solution {\\n    Set<Integer> used; // track if the number already used\\n    int[] arr; // contains the number we used at the index. e.g arr[5] means at index 0 we use 5\\n    boolean flag; // stop flag, once there is a solution we return, since it is the best solution if we try each number as dcsending order\\n    int[] res;\\n    public int[] constructDistancedSequence(int n) {\\n        int len = n * 2 - 1; // result length\\n        used = new HashSet<>();\\n        res = new int[len];\\n        arr = new int[len];\\n        Arrays.fill(arr, -1); // initial value, -1 means current index is not used\\n        backtracking(n, len, 0);\\n        if (flag) return res;\\n        \\n        return res;\\n    }\\n    \\n    private void backtracking(int n, int len, int index) {\\n        if (flag) return;  // stop flag, once there is a solution we return, since it is the best solution if we try each number as dcsending order\\n        \\n        if (len == index) {  // reach to the end, get result, set flag and return\\n            flag = true;\\n            System.arraycopy(arr, 0, res, 0, 2 * n - 1);\\n            return;\\n        }\\n        \\n        // if current index is already used, then we need to process next index\\n        // it guarateens the index have been used all follow the rule, so no need to do anything else, just move forward\\n        if (arr[index] != -1) { \\n            backtracking(n, len, index + 1);\\n            return;\\n        }\\n        \\n        for (int i = n; i >= 1; i--) { // try large number first to get the lexicographically order\\n            if (used.contains(i)) continue;\\n            \\n            if (i == 1) { // if is 1, it is only used once, no need to consider about i + index position\\n                arr[index] = i;\\n                used.add(i); // mark this number i has been used\\n                backtracking(n, len, index + 1);\\n                used.remove(i);\\n                arr[index] = -1;\\n                \\n            } else {\\n                // if not 1, then we need to make sure index + i position is availabe to be used\\n                // otherwise there is confliction with others, then need to continue the loop to try other(smaller) number/i\\n                if (index + i < len && arr[index + i] == -1) {                       \\n                    arr[index] = i; // here each time process and backtrack two position/value, i and i + index\\n                    arr[index + i] = i;\\n                    used.add(i); // mark this number i has been used\\n                    backtracking(n, len, index + 1);\\n                    used.remove(i);\\n                    arr[index] = -1;\\n                    arr[index + i] = -1;\\n                }\\n            }\\n        }\\n    }\\n}``\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n// observation\\n// 1 total result length should be n * 2 - 1\\n// 2 track the times of usage of each number\\n    each number i can be only use twice with i difference. So we do not need to track the times of usage anymore\\n    each time we use i at index, then we use i at index + i as well. Then each time we consume number i twice, then no need to track anymore\\n// 3 track the index usage of each time\\n    we can give a inital value such as -1 to indicate the index has not been used yet\\n// 4 track if the number already used\\n    either use an array or a set to check- I use Set here\\n// 5 try all the scenarios\\n// 6 how to keep the lexicographically? - try large number first\\n*/\\nclass Solution {\\n    Set<Integer> used; // track if the number already used\\n    int[] arr; // contains the number we used at the index. e.g arr[5] means at index 0 we use 5\\n    boolean flag; // stop flag, once there is a solution we return, since it is the best solution if we try each number as dcsending order\\n    int[] res;\\n    public int[] constructDistancedSequence(int n) {\\n        int len = n * 2 - 1; // result length\\n        used = new HashSet<>();\\n        res = new int[len];\\n        arr = new int[len];\\n        Arrays.fill(arr, -1); // initial value, -1 means current index is not used\\n        backtracking(n, len, 0);\\n        if (flag) return res;\\n        \\n        return res;\\n    }\\n    \\n    private void backtracking(int n, int len, int index) {\\n        if (flag) return;  // stop flag, once there is a solution we return, since it is the best solution if we try each number as dcsending order\\n        \\n        if (len == index) {  // reach to the end, get result, set flag and return\\n            flag = true;\\n            System.arraycopy(arr, 0, res, 0, 2 * n - 1);\\n            return;\\n        }\\n        \\n        // if current index is already used, then we need to process next index\\n        // it guarateens the index have been used all follow the rule, so no need to do anything else, just move forward\\n        if (arr[index] != -1) { \\n            backtracking(n, len, index + 1);\\n            return;\\n        }\\n        \\n        for (int i = n; i >= 1; i--) { // try large number first to get the lexicographically order\\n            if (used.contains(i)) continue;\\n            \\n            if (i == 1) { // if is 1, it is only used once, no need to consider about i + index position\\n                arr[index] = i;\\n                used.add(i); // mark this number i has been used\\n                backtracking(n, len, index + 1);\\n                used.remove(i);\\n                arr[index] = -1;\\n                \\n            } else {\\n                // if not 1, then we need to make sure index + i position is availabe to be used\\n                // otherwise there is confliction with others, then need to continue the loop to try other(smaller) number/i\\n                if (index + i < len && arr[index + i] == -1) {                       \\n                    arr[index] = i; // here each time process and backtrack two position/value, i and i + index\\n                    arr[index + i] = i;\\n                    used.add(i); // mark this number i has been used\\n                    backtracking(n, len, index + 1);\\n                    used.remove(i);\\n                    arr[index] = -1;\\n                    arr[index + i] = -1;\\n                }\\n            }\\n        }\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235612,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int n ;\\n    vector<int>ret ;\\n    vector<bool>used ;\\n    \\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        this->n = n ;\\n        ret.resize(2*n-1) ;\\n        used.resize(n+1, false) ;\\n        dfs(0) ;\\n        return ret ;\\n    }\\n    \\n    bool dfs(int pos){\\n        if(pos == 2*n-1)\\n            return true ;\\n        if(ret[pos] > 0)\\n            return dfs(pos+1) ;\\n        for(int i = n; i >= 1; i--)\\n        {\\n            if(used[i])\\n                continue ;\\n            if(i > 1)\\n            {\\n                if(pos+i >= 2*n-1 || ret[pos+i] > 0)\\n                    continue ;\\n            } \\n            used[i] = true ;\\n            ret[pos] = i ;\\n            if(i > 1)\\n                ret[pos+i] = i ;\\n            if(dfs(pos+1))\\n                return true ;\\n            used[i] = false ;\\n            ret[pos] = 0 ;\\n            if(i > 1)\\n                ret[pos+i] = 0 ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n ;\\n    vector<int>ret ;\\n    vector<bool>used ;\\n    \\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        this->n = n ;\\n        ret.resize(2*n-1) ;\\n        used.resize(n+1, false) ;\\n        dfs(0) ;\\n        return ret ;\\n    }\\n    \\n    bool dfs(int pos){\\n        if(pos == 2*n-1)\\n            return true ;\\n        if(ret[pos] > 0)\\n            return dfs(pos+1) ;\\n        for(int i = n; i >= 1; i--)\\n        {\\n            if(used[i])\\n                continue ;\\n            if(i > 1)\\n            {\\n                if(pos+i >= 2*n-1 || ret[pos+i] > 0)\\n                    continue ;\\n            } \\n            used[i] = true ;\\n            ret[pos] = i ;\\n            if(i > 1)\\n                ret[pos+i] = i ;\\n            if(dfs(pos+1))\\n                return true ;\\n            used[i] = false ;\\n            ret[pos] = 0 ;\\n            if(i > 1)\\n                ret[pos+i] = 0 ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910638,
                "title": "tldr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {\\n        match n {\\n            1 => vec![1],\\n            2 => vec![2,1,2],\\n            3 => vec![3,1,2,3,2],\\n            4 => vec![4,2,3,2,4,3,1],\\n            5 => vec![5,3,1,4,3,5,2,4,2],\\n            6 => vec![6,4,2,5,2,4,6,3,5,1,3],\\n            7 => vec![7,5,3,6,4,3,5,7,4,6,2,1,2],\\n            8 => vec![8,6,4,2,7,2,4,6,8,5,3,7,1,3,5],\\n            9 => vec![9,7,5,3,8,6,3,5,7,9,4,6,8,2,4,2,1],\\n            10 => vec![10,8,6,9,3,1,7,3,6,8,10,5,9,7,4,2,5,2,4],\\n            11 => vec![11,9,10,6,4,1,7,8,4,6,9,11,10,7,5,8,2,3,2,5,3],\\n            12 => vec![12,10,11,7,5,3,8,9,3,5,7,10,12,11,8,6,9,2,4,2,1,6,4],\\n            13 => vec![13,11,12,8,6,4,9,10,1,4,6,8,11,13,12,9,7,10,3,5,2,3,2,7,5],\\n            14 => vec![14,12,13,9,7,11,4,1,10,8,4,7,9,12,14,13,11,8,10,6,3,5,2,3,2,6,5],\\n            15 => vec![15,13,14,10,8,12,5,3,11,9,3,5,8,10,13,15,14,12,9,11,7,4,6,1,2,4,2,7,6],\\n            16 => vec![16,14,15,11,9,13,6,4,12,10,1,4,6,9,11,14,16,15,13,10,12,8,5,7,2,3,2,5,3,8,7],\\n            17 => vec![17,15,16,12,10,14,7,5,3,13,11,3,5,7,10,12,15,17,16,14,9,11,13,8,6,2,1,2,4,9,6,8,4],\\n            18 => vec![18,16,17,13,11,15,8,14,4,2,12,2,4,10,8,11,13,16,18,17,15,14,12,10,9,7,5,3,6,1,3,5,7,9,6],\\n            19 => vec![19,17,18,14,12,16,9,15,6,3,13,1,3,11,6,9,12,14,17,19,18,16,15,13,11,10,8,4,5,7,2,4,2,5,8,10,7],\\n            20 => vec![20,18,19,15,13,17,10,16,7,5,3,14,12,3,5,7,10,13,15,18,20,19,17,16,12,14,11,9,4,6,8,2,4,2,1,6,9,11,8],\\n            _ => vec![],\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {\\n        match n {\\n            1 => vec![1],\\n            2 => vec![2,1,2],\\n            3 => vec![3,1,2,3,2],\\n            4 => vec![4,2,3,2,4,3,1],\\n            5 => vec![5,3,1,4,3,5,2,4,2],\\n            6 => vec![6,4,2,5,2,4,6,3,5,1,3],\\n            7 => vec![7,5,3,6,4,3,5,7,4,6,2,1,2],\\n            8 => vec![8,6,4,2,7,2,4,6,8,5,3,7,1,3,5],\\n            9 => vec![9,7,5,3,8,6,3,5,7,9,4,6,8,2,4,2,1],\\n            10 => vec![10,8,6,9,3,1,7,3,6,8,10,5,9,7,4,2,5,2,4],\\n            11 => vec![11,9,10,6,4,1,7,8,4,6,9,11,10,7,5,8,2,3,2,5,3],\\n            12 => vec![12,10,11,7,5,3,8,9,3,5,7,10,12,11,8,6,9,2,4,2,1,6,4],\\n            13 => vec![13,11,12,8,6,4,9,10,1,4,6,8,11,13,12,9,7,10,3,5,2,3,2,7,5],\\n            14 => vec![14,12,13,9,7,11,4,1,10,8,4,7,9,12,14,13,11,8,10,6,3,5,2,3,2,6,5],\\n            15 => vec![15,13,14,10,8,12,5,3,11,9,3,5,8,10,13,15,14,12,9,11,7,4,6,1,2,4,2,7,6],\\n            16 => vec![16,14,15,11,9,13,6,4,12,10,1,4,6,9,11,14,16,15,13,10,12,8,5,7,2,3,2,5,3,8,7],\\n            17 => vec![17,15,16,12,10,14,7,5,3,13,11,3,5,7,10,12,15,17,16,14,9,11,13,8,6,2,1,2,4,9,6,8,4],\\n            18 => vec![18,16,17,13,11,15,8,14,4,2,12,2,4,10,8,11,13,16,18,17,15,14,12,10,9,7,5,3,6,1,3,5,7,9,6],\\n            19 => vec![19,17,18,14,12,16,9,15,6,3,13,1,3,11,6,9,12,14,17,19,18,16,15,13,11,10,8,4,5,7,2,4,2,5,8,10,7],\\n            20 => vec![20,18,19,15,13,17,10,16,7,5,3,14,12,3,5,7,10,13,15,18,20,19,17,16,12,14,11,9,4,6,8,2,4,2,1,6,9,11,8],\\n            _ => vec![],\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078618,
                "title": "golang-0-ms-100-time-and-100-memory",
                "content": "```\\nfunc constructDistancedSequence(n int) []int {\\n\\ts := make([]bool, n+1)\\n\\tll := (n * 2) - 2\\n\\tpi := make([]int, ll+1)\\n\\tvar bt func(int) bool\\n\\tbt = func(c int) bool {\\n\\t\\tif c > ll { return true }\\n\\t\\ti := 0\\n\\t\\tfor j := range pi { if pi[j] == 0 { i = j; break } }\\n\\t\\tfor nx := n; nx > 0; nx-- {\\n\\t\\t\\tif nx != 1 {\\n\\t\\t\\t\\tif (i+nx) > ll || pi[i] != 0 || pi[i+nx] != 0 || s[nx] { continue }\\n\\t\\t\\t\\tpi[i] = nx\\n\\t\\t\\t\\tpi[i+nx] = nx\\n\\t\\t\\t\\ts[nx] = true\\n\\t\\t\\t\\tif bt(c + 2) { return true }\\n\\t\\t\\t\\tpi[i] = 0\\n\\t\\t\\t\\tpi[i+nx] = 0\\n\\t\\t\\t\\ts[nx] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif pi[i] != 0 || s[nx] { continue }\\n\\t\\t\\t\\tpi[i] = nx\\n\\t\\t\\t\\ts[nx] = true\\n\\t\\t\\t\\tif bt(c + 1) { return true }\\n\\t\\t\\t\\tpi[i] = 0\\n\\t\\t\\t\\ts[nx] = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\tbt(0)\\n\\treturn pi\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc constructDistancedSequence(n int) []int {\\n\\ts := make([]bool, n+1)\\n\\tll := (n * 2) - 2\\n\\tpi := make([]int, ll+1)\\n\\tvar bt func(int) bool\\n\\tbt = func(c int) bool {\\n\\t\\tif c > ll { return true }\\n\\t\\ti := 0\\n\\t\\tfor j := range pi { if pi[j] == 0 { i = j; break } }\\n\\t\\tfor nx := n; nx > 0; nx-- {\\n\\t\\t\\tif nx != 1 {\\n\\t\\t\\t\\tif (i+nx) > ll || pi[i] != 0 || pi[i+nx] != 0 || s[nx] { continue }\\n\\t\\t\\t\\tpi[i] = nx\\n\\t\\t\\t\\tpi[i+nx] = nx\\n\\t\\t\\t\\ts[nx] = true\\n\\t\\t\\t\\tif bt(c + 2) { return true }\\n\\t\\t\\t\\tpi[i] = 0\\n\\t\\t\\t\\tpi[i+nx] = 0\\n\\t\\t\\t\\ts[nx] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif pi[i] != 0 || s[nx] { continue }\\n\\t\\t\\t\\tpi[i] = nx\\n\\t\\t\\t\\ts[nx] = true\\n\\t\\t\\t\\tif bt(c + 1) { return true }\\n\\t\\t\\t\\tpi[i] = 0\\n\\t\\t\\t\\ts[nx] = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\tbt(0)\\n\\treturn pi\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519814,
                "title": "recursion-backtracking-with-thought-process-greedy-recur",
                "content": "while fixing values we understand it cant be  4###4 then 43##4 clashes with exisitng 4\\nSo fix values accordingly 421243##3###\\nbut for larger values n=7 this wont work  So greedy Fails\\n Then Apply Recursion , check ans , backtrack if false\\n \\n created a Res vect to store Res\\n incl vect to check value included or not\\n Traverse from larger values to smaller so we get larger number\\n```\\n int helper(int i, vector<int>&res , vector<int>&incl , int n){\\n        int size=2*(n-1)+1;\\n        if(i==size) return 1;\\n        if(res[i]!=-1) return helper(i+1,res,incl,n);\\n        int j;\\n            for(j=n;j>=1;j--){\\n                if(incl[j]==0&&(j==1||((j+i<size)&&res[j+i]==-1))) {    // means j not included and j==1 OR\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//  i+j is in range and i+j pos vacant - fix at ith and (i+j)th pos\\n                // assuming and fixing\\n                 incl[j]=1;\\n                 res[i]=j;\\n                if(j>1)  res[i+j]=j;\\n                \\n                // recursion\\n                 int ret=helper(i+1,res,incl,n);\\n                 if(ret==1) return 1;\\n                    \\n                 // backtracking\\n                 incl[j]=0;\\n                 res[i]=-1;\\n                 if(j>1) res[i+j]=-1;\\n                 }\\n            }\\n       \\n        return -1;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        int size=2*(n-1)+1;\\n        vector<int>res(size,-1);\\n        vector<int>incl(n+1,0);\\n        helper(0,res,incl,n);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int helper(int i, vector<int>&res , vector<int>&incl , int n){\\n        int size=2*(n-1)+1;\\n        if(i==size) return 1;\\n        if(res[i]!=-1) return helper(i+1,res,incl,n);\\n        int j;\\n            for(j=n;j>=1;j--){\\n                if(incl[j]==0&&(j==1||((j+i<size)&&res[j+i]==-1))) {    // means j not included and j==1 OR\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//  i+j is in range and i+j pos vacant - fix at ith and (i+j)th pos\\n                // assuming and fixing\\n                 incl[j]=1;\\n                 res[i]=j;\\n                if(j>1)  res[i+j]=j;\\n                \\n                // recursion\\n                 int ret=helper(i+1,res,incl,n);\\n                 if(ret==1) return 1;\\n                    \\n                 // backtracking\\n                 incl[j]=0;\\n                 res[i]=-1;\\n                 if(j>1) res[i+j]=-1;\\n                 }\\n            }\\n       \\n        return -1;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        int size=2*(n-1)+1;\\n        vector<int>res(size,-1);\\n        vector<int>incl(n+1,0);\\n        helper(0,res,incl,n);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490390,
                "title": "java-100-faster-backtracking",
                "content": "```\\npublic int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2*n - 1];\\n        boolean[] visited = new boolean[n + 1];\\n        backtrack(res, visited, n, 0);\\n        return res;\\n    }\\n    \\n    boolean backtrack(int[] res, boolean[] visited, int n, int pos) {\\n        if(pos == res.length) return true;\\n        if(res[pos] != 0) {\\n            return backtrack(res, visited, n, pos+1);\\n        } \\n        \\n        for(int i = n; i >=1; i--) {\\n            if(i == 1) {\\n                if(!visited[i]) {\\n                    res[pos] = i;\\n                    visited[i] = true;\\n                    if(backtrack(res, visited, n, pos+1)) {\\n                        return true;\\n                    }\\n                    res[pos] = 0;\\n                    visited[i] = false;\\n                }\\n            } else {\\n                if(!visited[i] && pos+i < res.length && res[pos+i] == 0) {\\n                    res[pos] = res[pos+i] = i;\\n                    visited[i] = true;\\n                    if(backtrack(res, visited, n, pos+1)) {\\n                        return true;\\n                    }\\n                    res[pos] = res[pos+i] = 0;\\n                    visited[i] = false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2*n - 1];\\n        boolean[] visited = new boolean[n + 1];\\n        backtrack(res, visited, n, 0);\\n        return res;\\n    }\\n    \\n    boolean backtrack(int[] res, boolean[] visited, int n, int pos) {\\n        if(pos == res.length) return true;\\n        if(res[pos] != 0) {\\n            return backtrack(res, visited, n, pos+1);\\n        } \\n        \\n        for(int i = n; i >=1; i--) {\\n            if(i == 1) {\\n                if(!visited[i]) {\\n                    res[pos] = i;\\n                    visited[i] = true;\\n                    if(backtrack(res, visited, n, pos+1)) {\\n                        return true;\\n                    }\\n                    res[pos] = 0;\\n                    visited[i] = false;\\n                }\\n            } else {\\n                if(!visited[i] && pos+i < res.length && res[pos+i] == 0) {\\n                    res[pos] = res[pos+i] = i;\\n                    visited[i] = true;\\n                    if(backtrack(res, visited, n, pos+1)) {\\n                        return true;\\n                    }\\n                    res[pos] = res[pos+i] = 0;\\n                    visited[i] = false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1451841,
                "title": "python-dfs-backtracking",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        arr=[0]*((n*2)-1)\\n        self.ans=None\\n        def dfs(arr,i):\\n            for num in range(n,0,-1):#Traverse Reverse as we need highest lexicographic number\\n                if num not in arr:\\n                    if num==1:\\n                        if arr[i]!=0:#place is occupied\\n                            continue\\n                        else:#Occupy the one place\\n                            arr[i]=1\\n                    else:\\n                        if arr[i]!=0 or (i+num)>=len(arr) or arr[i+num]!=0:#place is occupied or invalid\\n                            continue\\n                        else:#Occupy the two place\\n                            arr[i]=num\\n                            arr[i+num]=num\\n                    if 0 in arr:#means few places are still vacant\\n                        if dfs(arr,arr.index(0)):\\n                            return True\\n                        if arr[i]==1:#Backtracking vacate the one place\\n                            arr[i]=0\\n                        else:#Backtracking vacate both the two occupied place\\n                            arr[i]=0\\n                            arr[i+num]=0\\n                    else:#Yay no place is vacant \\n                        self.ans=arr\\n                        return True\\n                    \\n        dfs(arr,0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        arr=[0]*((n*2)-1)\\n        self.ans=None\\n        def dfs(arr,i):\\n            for num in range(n,0,-1):#Traverse Reverse as we need highest lexicographic number\\n                if num not in arr:\\n                    if num==1:\\n                        if arr[i]!=0:#place is occupied\\n                            continue\\n                        else:#Occupy the one place\\n                            arr[i]=1\\n                    else:\\n                        if arr[i]!=0 or (i+num)>=len(arr) or arr[i+num]!=0:#place is occupied or invalid\\n                            continue\\n                        else:#Occupy the two place\\n                            arr[i]=num\\n                            arr[i+num]=num\\n                    if 0 in arr:#means few places are still vacant\\n                        if dfs(arr,arr.index(0)):\\n                            return True\\n                        if arr[i]==1:#Backtracking vacate the one place\\n                            arr[i]=0\\n                        else:#Backtracking vacate both the two occupied place\\n                            arr[i]=0\\n                            arr[i+num]=0\\n                    else:#Yay no place is vacant \\n                        self.ans=arr\\n                        return True\\n                    \\n        dfs(arr,0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176681,
                "title": "java-0ms-clean-code-backtracking",
                "content": "Fill output array from left to right and backtrack when cannot. The first result is the largest.\\n\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] ans = new int[2 * n - 1];\\n        backtrack(0, ans, new boolean[n + 1]);\\n        return ans;\\n    }\\n    \\n    private boolean backtrack(int p, int[] ans, boolean[] used) {\\n        if (p == ans.length) return true;\\n        if (ans[p] != 0) return backtrack(p + 1, ans, used);\\n        \\n        for (int i = (ans.length + 1) / 2; i >= 1; i--) {\\n            if (used[i]) continue;\\n            if (i > 1) {\\n                if (p + i >= ans.length || ans[p + i] != 0) continue;\\n                ans[p] = i;\\n                ans[p + i] = i;\\n                used[i] = true;\\n                if (backtrack(p + 1, ans, used)) return true;\\n                ans[p] = 0;\\n                ans[p + i] = 0;\\n                used[i] = false;\\n            } else {\\n                ans[p] = i;\\n                used[i] = true;\\n                if (backtrack(p + 1, ans, used)) return true;\\n                ans[p] = 0;\\n                used[i] = false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nBelow won\\'t work see comment inline.\\n```\\n    // NG: this returns non-optimal answer as it settles max number first instead of lower position.\\n    private boolean backtrackNotLargest(int i, int[] ans) {\\n        if (i == 1) {\\n            for (int j = 0; j < ans.length; j++) {\\n                if (ans[j] == 0) {\\n                    ans[j] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < ans.length - i; j++) {\\n            if (ans[j] != 0 || ans[j + i] != 0) continue;\\n            ans[j] = i;\\n            ans[j + i] = i;\\n            if (backtrackNotLargest(i - 1, ans)) return true;\\n            ans[j] = 0;\\n            ans[j + i] = 0;\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] ans = new int[2 * n - 1];\\n        backtrack(0, ans, new boolean[n + 1]);\\n        return ans;\\n    }\\n    \\n    private boolean backtrack(int p, int[] ans, boolean[] used) {\\n        if (p == ans.length) return true;\\n        if (ans[p] != 0) return backtrack(p + 1, ans, used);\\n        \\n        for (int i = (ans.length + 1) / 2; i >= 1; i--) {\\n            if (used[i]) continue;\\n            if (i > 1) {\\n                if (p + i >= ans.length || ans[p + i] != 0) continue;\\n                ans[p] = i;\\n                ans[p + i] = i;\\n                used[i] = true;\\n                if (backtrack(p + 1, ans, used)) return true;\\n                ans[p] = 0;\\n                ans[p + i] = 0;\\n                used[i] = false;\\n            } else {\\n                ans[p] = i;\\n                used[i] = true;\\n                if (backtrack(p + 1, ans, used)) return true;\\n                ans[p] = 0;\\n                used[i] = false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\n    // NG: this returns non-optimal answer as it settles max number first instead of lower position.\\n    private boolean backtrackNotLargest(int i, int[] ans) {\\n        if (i == 1) {\\n            for (int j = 0; j < ans.length; j++) {\\n                if (ans[j] == 0) {\\n                    ans[j] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < ans.length - i; j++) {\\n            if (ans[j] != 0 || ans[j + i] != 0) continue;\\n            ans[j] = i;\\n            ans[j + i] = i;\\n            if (backtrackNotLargest(i - 1, ans)) return true;\\n            ans[j] = 0;\\n            ans[j + i] = 0;\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089785,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func constructDistancedSequence(_ n: Int) -> [Int] {\\n        let rc = (n - 1) * 2 + 1\\n        var free = [Bool](repeating: true, count: n), result = [Int](repeating: 0, count: rc)\\n        func helper(_ skip: Int) -> Bool {\\n            guard skip < n else { return true } // all nums are in result, it\\'s finish!\\n            for i in 0..<rc where result[i] == 0 { // find first free cell in result\\n                for num in stride(from: n, through: 1, by: -1) where free[num - 1] { // try all unused nums\\n                    let i2 = i + num\\n                    if num > 1 && (i2 >= rc || result[i2] != 0) { continue } // num > 1 & second cell in result is unavailable\\n                    free[num - 1] = false // mark num as used\\n                    result[i] = num // put num into result\\n                    if num > 1 { result[i2] = num } // put twice if num > 1\\n                    if helper(skip + 1) { return true } // try to put one more num into result. finish if it\\'s possible\\n                    free[num - 1] = true // mark num as unused\\n                    result[i] = 0 // pop num from result\\n                    if num > 1 { result[i2] = 0 } // pop twice if num > 1\\n                }\\n                break\\n            }\\n            return false\\n        }\\n        helper(0)\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func constructDistancedSequence(_ n: Int) -> [Int] {\\n        let rc = (n - 1) * 2 + 1\\n        var free = [Bool](repeating: true, count: n), result = [Int](repeating: 0, count: rc)\\n        func helper(_ skip: Int) -> Bool {\\n            guard skip < n else { return true } // all nums are in result, it\\'s finish!\\n            for i in 0..<rc where result[i] == 0 { // find first free cell in result\\n                for num in stride(from: n, through: 1, by: -1) where free[num - 1] { // try all unused nums\\n                    let i2 = i + num\\n                    if num > 1 && (i2 >= rc || result[i2] != 0) { continue } // num > 1 & second cell in result is unavailable\\n                    free[num - 1] = false // mark num as used\\n                    result[i] = num // put num into result\\n                    if num > 1 { result[i2] = num } // put twice if num > 1\\n                    if helper(skip + 1) { return true } // try to put one more num into result. finish if it\\'s possible\\n                    free[num - 1] = true // mark num as unused\\n                    result[i] = 0 // pop num from result\\n                    if num > 1 { result[i2] = 0 } // pop twice if num > 1\\n                }\\n                break\\n            }\\n            return false\\n        }\\n        helper(0)\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043220,
                "title": "c-0ms-greedy-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> v(n*2-1, 0);\\n        visited = vector<bool>(n+1, false);\\n        dfs(v, 0, n);\\n        return v;\\n    }\\n    \\n    bool dfs(vector<int>& v, int i, int n){\\n        if(i == v.size()){\\n            return true;    \\n        }\\n        if(v[i] > 0) return dfs(v, i+1, n);\\n        for(int j=n;j>0;j--){\\n            if(visited[j]) continue;\\n            if(j>1) if(j+i >= v.size() || v[j+i] > 0) continue;\\n            visited[j] = true;\\n            v[i] = j;\\n            if(j>1) v[j+i] = j;\\n            if(dfs(v, i+1, n)) return true;\\n            v[i] = 0;\\n            if(j>1) v[j+i] = 0;\\n            visited[j] = false;\\n        }\\n        return false;\\n    }\\n    \\n    vector<bool> visited;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> v(n*2-1, 0);\\n        visited = vector<bool>(n+1, false);\\n        dfs(v, 0, n);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1027340,
                "title": "javascript-bitmask-backtracking-w-detailed-explanation-beats-100-100",
                "content": "***Idea:***\\n\\nWith a constraint of **1 <= N <= 20**, we can try each possibility **recursively** and also use a **bitmask** to keep track of the list of available characters (**avail**) in one integer. \\n\\n(*Note: If you\\'re familiar with the principles involved in bitmasking, you can skip down to the last few paragraphs of the Idea section.*)\\n\\nBitmasking allows an integer to be used as **boolean** data storage by taking advantage of the fact that an integer is actually storing **32 bits** worth of data in a small memory allocation.\\n```\\n\\t\\tBitwise Boolean Data Storage example:\\n\\t\\t\\n                    bit positions:   5 4 3 2 1 0\\n\\t\\t\\t\\t\\t\\t             v v v v v v\\n     (base 10):  63       (base 2):  1 1 1 1 1 1        // A 1 in each bit means all bits are \"true\"\\n     (base 10):  36       (base 2):  1 0 0 1 0 0        // Bits 2 and 5 are \"true\", the rest \"false\"\\n```\\nIn order to perform the necessary bit manipulation, we\\'ll have to use **bitmask shift (<<, >>)**, **bitmask AND (&)**, and **bitmask XOR (^)** operators.\\n\\nA bitwise shift does what its name implies and shifts all bits to the left or right. Bits shifted right past the **0** bit position are dropped and the space created by shifting bits to the left is filled with **0**s.\\n```\\n\\t\\tBitwise shift left or right ( << or >> ) example;\\n\\n\\t\\t\\t(base 10):      229 << 3 = 1832\\n\\t\\t\\t(base 2):  11100101 << 3 = 11100101000\\n\\n\\t\\t\\t\\t\\t  1 1 1 0 0 1 0 1            // 229\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 < < <            // shifted left three bits\\n\\t\\t\\t ---v-v-v-v-v-v-v-v-X-X-X---\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 0 0 0            // becomes 1832\\n\\n\\n\\t\\t\\t(base 10):      229 >> 3 = 28\\n\\t\\t\\t(base 2):  11100101 >> 3 = 11100\\n\\n\\t\\t\\t\\t      1 1 1 0 0 1 0 1            // 229\\n\\t\\t\\t\\t      > > > 1 1 1 0 0|X X X      // shifted right three bits\\n\\t\\t\\t       ---------v-v-v-v-v---------\\n\\t\\t\\t\\t\\t\\t    1 1 1 0 0            // becomes 28\\n```\\nA bitwise AND operator compares two numbers bit-by-bit; each bit of the returned number is a **1** if and only if both compared numbers have a **1** in the corresponding bit position, otherwise it is a **0**. \\n```\\n\\t\\tBitwise AND ( & ) example;\\n\\n\\t\\t\\t(base 10):      229 & 51     = 33\\n\\t\\t\\t(base 2):  11100101 & 110011 = 100001\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // if the compared bits\\n\\t\\t\\t\\t\\t&   0 0 1 1 0 0 1 1          // are both 1s\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-v----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 1          // return a 1, otherwise a 0\\n```\\nSimilarly, a bitwise XOR operator also compares two numbers bit-by-bit; each bit of the returned number is a **1** if and only if one *but not both* of the compared numbers have a **1** in the corresponding bit position, otherwise it is a **0**. \\n```\\n\\t\\tBitwise XOR ( ^ ) example;\\n\\n\\t\\t\\t(base 10):      229 ^ 51     = 214\\n\\t\\t\\t(base 2):  11100101 ^ 110011 = 11010110\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // if the compared bits\\n\\t\\t\\t\\t\\t^   0 0 1 1 0 0 1 1          // are opposite of each other\\n\\t\\t\\t\\t\\t----v-v-X-v-X-v-v-X----\\n\\t\\t\\t\\t\\t    1 1 0 1 0 1 1 0          // return a 1, otherwise a 0\\n```\\nBitmasking is the practice of using a binary \"mask\" to isolate certain bits of a number. A bitmask can be used with a bitwise AND to isolate or \"read\" certain bits, while a bitwise NOR can be used to toggle or \"write\" certain bits. A common usage is to create a simple bitmask by shifting a 1 to the left to match the bit you want to read or write.\\n```\\n\\t\\tBitwise AND ( & ) combined w/ a Bitmask ( 1 << n ) examples;\\n\\t\\t\\n\\t\\t\\t(base 10):      229 & 1 << 5 = 32\\n\\t\\t\\t(base 2):  11100101 & 100000 = 100000\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 1 0 0 0 0 0          // using a bitmask for bit 5 (1 << 5)\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 0          // returns the isolated bit 5 only\\n\\n\\n\\t\\t\\t(base 10):      229 & 1 << 4 = 0\\n\\t\\t\\t(base 2):  11100101 &  10000 = 0\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 0 1 0 0 0 0          // using a bitmask for bit 4 (1 << 4)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 0 0 0 0 0 0          // returns the isolated bit 4 only\\n\\t\\t\\t\\t\\t\\t\\n\\n\\t\\tCommon usage:\\n\\t\\t\\n\\t\\t    bitmasked = num & 1 << n             // Isolates bit n of num\\n\\t\\t    if (bitmasked) A                     // Any nonzero result is truthy and triggers A\\n\\t\\t    else B                               // Whereas a zero is falsy and triggers B\\n```\\n```\\n\\t\\tBitwise XOR ( ^ ) combined w/ a Bitmask ( 1 << n ) example;\\n\\t\\t\\n\\t\\t\\t(base 10):      229 ^ 1 << 5 = 197\\n\\t\\t\\t(base 2):  11100101 ^ 100000 = 11000101\\n\\t\\t\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise XOR\\n\\t\\t\\t\\t\\t^   0 0 1 0 0 0 0 0          // using a bitmask for bit 5 (1 << 5)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    1 1 0 0 0 1 0 1          // returns the number with bit 5 toggled\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\n\\t\\t\\t(base 10):      229 ^ 1 << 4 = 245\\n\\t\\t\\t(base 2):  11100101 ^ 10000  = 11000101\\n\\t\\t\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise XOR\\n\\t\\t\\t\\t\\t^   0 0 0 1 0 0 0 0          // using a bitmask for bit 4 (1 << 4)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    1 1 1 1 0 1 0 1          // returns the number with bit 4 toggled\\n\\n\\n\\t\\tCommon usage:\\n\\t\\t\\n\\t\\t    num ^= 1 << n                        // Toggles bit n of num, 0->1 or 1->0\\n```\\nIn this situation, we need to store **N** bits\\' worth of data in **avail**. Since **N** is **1**-indexed, but bit positions are **0**-indexed, we\\'ll use up to to the first **21** bits of **avail** to store the necessary information. This will prevent unnecessary +1s and -1s throughout our bit maniupation.\\n\\nNormally, to achieve **N** number of **1**s, we use **(1 << N) - 1**, but as we\\'re going to ignore bit **0**, we\\'ll instead use **(1 << N + 1) - 2**, which will gives us **N** number of **1**s followed by a dummy **0**.\\n\\nIn order to avoid having to make and pass copies of our answer array (**ans**) down through each recursion, we can make ans global, use the recursive function to directly alter it, and then use backtracking if necessary. Since **ans** is limited to values of **N** up to **20**, we should use a more efficient **Uint8Array**.\\n\\nTo make the lexicographically largest sequence, we\\'ll always try the highest remaining available number first before working down from there. Whenever we find a location that cannot be filled, we backtrack, undoing the changes made. And when we have used all available numbers, then we know we\\'ve successfully found the correct **ans**.\\n\\nThe best result for the code below is **72ms / 38.3MB**.\\n\\n` `\\n***Implementation:***\\n\\nAfter creating our appropriately sized **ans** and **avail**, the bulk of the work is done with the recursive function **rc**. For a given index (**i**), **rc** will find the best possible fit for **ans[i]**.\\n\\nIf we find that **avail** has no more numbers marked as available (**avail = 0**), then we\\'ve found our answer and should return **true** back up the recursive chain. Otherwise, we should move **i** forward to the next unfilled spot in **ans**, then iterate through our remaining numbers, looking for one that fits.\\n\\nWe can define **j** to be the second spot filled in **ans**. If **val = 1**, however, then **j = i**, as **1** doesn\\'t fill a second spot. Then we can check to see if **val** is available and if **ans[j]** is still open. If so, we can update **ans** and **avail** and call **rc** on the next position. If that function call returns **true** then **return true** back up the chain. If nothing is returned, then undo the changes made to **ans** and **avail** and allow the **for** loop to continue.\\n\\nIf the **for** loop ends without the answer being found, then **rc** will **return** nothing, triggering the preceeding version of **rc** to continue *its* **for** loop.\\n\\nAt the very end, once **true** has bubbled back up to the main function, **return ans**.\\n\\n` `\\n***Code:***\\n```\\nvar constructDistancedSequence = function(n) {\\n    let ans = new Uint8Array(n * 2 - 1),\\n        avail = (1 << n + 1) - 2\\n    const rc = i => {\\n        if (!avail) return true\\n        while (ans[i]) i++\\n        for (let val = n; val; val--) {\\n            let j = val > 1 ? i + val : i\\n            if (avail & 1 << val && ans[j] === 0) {\\n                ans[i] = ans[j] = val, avail ^= 1 << val\\n                if (rc(i+1)) return true\\n                else ans[i] = ans[j] = 0, avail ^= 1 << val\\n            }\\n        }\\n    }\\n    rc(0)\\n\\treturn ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\t\\tBitwise Boolean Data Storage example:\\n\\t\\t\\n                    bit positions:   5 4 3 2 1 0\\n\\t\\t\\t\\t\\t\\t             v v v v v v\\n     (base 10):  63       (base 2):  1 1 1 1 1 1        // A 1 in each bit means all bits are \"true\"\\n     (base 10):  36       (base 2):  1 0 0 1 0 0        // Bits 2 and 5 are \"true\", the rest \"false\"\\n```\n```\\n\\t\\tBitwise shift left or right ( << or >> ) example;\\n\\n\\t\\t\\t(base 10):      229 << 3 = 1832\\n\\t\\t\\t(base 2):  11100101 << 3 = 11100101000\\n\\n\\t\\t\\t\\t\\t  1 1 1 0 0 1 0 1            // 229\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 < < <            // shifted left three bits\\n\\t\\t\\t ---v-v-v-v-v-v-v-v-X-X-X---\\n\\t\\t\\t\\t1 1 1 0 0 1 0 1 0 0 0            // becomes 1832\\n\\n\\n\\t\\t\\t(base 10):      229 >> 3 = 28\\n\\t\\t\\t(base 2):  11100101 >> 3 = 11100\\n\\n\\t\\t\\t\\t      1 1 1 0 0 1 0 1            // 229\\n\\t\\t\\t\\t      > > > 1 1 1 0 0|X X X      // shifted right three bits\\n\\t\\t\\t       ---------v-v-v-v-v---------\\n\\t\\t\\t\\t\\t\\t    1 1 1 0 0            // becomes 28\\n```\n```\\n\\t\\tBitwise AND ( & ) example;\\n\\n\\t\\t\\t(base 10):      229 & 51     = 33\\n\\t\\t\\t(base 2):  11100101 & 110011 = 100001\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // if the compared bits\\n\\t\\t\\t\\t\\t&   0 0 1 1 0 0 1 1          // are both 1s\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-v----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 1          // return a 1, otherwise a 0\\n```\n```\\n\\t\\tBitwise XOR ( ^ ) example;\\n\\n\\t\\t\\t(base 10):      229 ^ 51     = 214\\n\\t\\t\\t(base 2):  11100101 ^ 110011 = 11010110\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // if the compared bits\\n\\t\\t\\t\\t\\t^   0 0 1 1 0 0 1 1          // are opposite of each other\\n\\t\\t\\t\\t\\t----v-v-X-v-X-v-v-X----\\n\\t\\t\\t\\t\\t    1 1 0 1 0 1 1 0          // return a 1, otherwise a 0\\n```\n```\\n\\t\\tBitwise AND ( & ) combined w/ a Bitmask ( 1 << n ) examples;\\n\\t\\t\\n\\t\\t\\t(base 10):      229 & 1 << 5 = 32\\n\\t\\t\\t(base 2):  11100101 & 100000 = 100000\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 1 0 0 0 0 0          // using a bitmask for bit 5 (1 << 5)\\n\\t\\t\\t\\t\\t----X-X-v-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 1 0 0 0 0 0          // returns the isolated bit 5 only\\n\\n\\n\\t\\t\\t(base 10):      229 & 1 << 4 = 0\\n\\t\\t\\t(base 2):  11100101 &  10000 = 0\\n\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise AND\\n\\t\\t\\t\\t\\t&   0 0 0 1 0 0 0 0          // using a bitmask for bit 4 (1 << 4)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    0 0 0 0 0 0 0 0          // returns the isolated bit 4 only\\n\\t\\t\\t\\t\\t\\t\\n\\n\\t\\tCommon usage:\\n\\t\\t\\n\\t\\t    bitmasked = num & 1 << n             // Isolates bit n of num\\n\\t\\t    if (bitmasked) A                     // Any nonzero result is truthy and triggers A\\n\\t\\t    else B                               // Whereas a zero is falsy and triggers B\\n```\n```\\n\\t\\tBitwise XOR ( ^ ) combined w/ a Bitmask ( 1 << n ) example;\\n\\t\\t\\n\\t\\t\\t(base 10):      229 ^ 1 << 5 = 197\\n\\t\\t\\t(base 2):  11100101 ^ 100000 = 11000101\\n\\t\\t\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise XOR\\n\\t\\t\\t\\t\\t^   0 0 1 0 0 0 0 0          // using a bitmask for bit 5 (1 << 5)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    1 1 0 0 0 1 0 1          // returns the number with bit 5 toggled\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\n\\t\\t\\t(base 10):      229 ^ 1 << 4 = 245\\n\\t\\t\\t(base 2):  11100101 ^ 10000  = 11000101\\n\\t\\t\\n\\t\\t\\t\\t\\t    1 1 1 0 0 1 0 1          // performing a bitwise XOR\\n\\t\\t\\t\\t\\t^   0 0 0 1 0 0 0 0          // using a bitmask for bit 4 (1 << 4)\\n\\t\\t\\t\\t\\t----X-X-X-X-X-X-X-X----\\n\\t\\t\\t\\t\\t    1 1 1 1 0 1 0 1          // returns the number with bit 4 toggled\\n\\n\\n\\t\\tCommon usage:\\n\\t\\t\\n\\t\\t    num ^= 1 << n                        // Toggles bit n of num, 0->1 or 1->0\\n```\n```\\nvar constructDistancedSequence = function(n) {\\n    let ans = new Uint8Array(n * 2 - 1),\\n        avail = (1 << n + 1) - 2\\n    const rc = i => {\\n        if (!avail) return true\\n        while (ans[i]) i++\\n        for (let val = n; val; val--) {\\n            let j = val > 1 ? i + val : i\\n            if (avail & 1 << val && ans[j] === 0) {\\n                ans[i] = ans[j] = val, avail ^= 1 << val\\n                if (rc(i+1)) return true\\n                else ans[i] = ans[j] = 0, avail ^= 1 << val\\n            }\\n        }\\n    }\\n    rc(0)\\n\\treturn ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020378,
                "title": "python-solution",
                "content": "Backtracking:\\n\\nWe first initialize a list `res` of `0`s of length `2n - 1` to be the result, and a set `se` consisting of elements from `1` to `n` indicating the available elements that hasn\\'t been used. We define a recursive function `dfs(i)`, which populates `res` starting from index `i`, and returns `True`/`False` if a solution exists/does not exist.\\n\\nThe base case of dfs(i) is when `i >= 2n - 1`, we know that `res` is a valid sequence for the solution, hence we return `True`. For the recursive step, if `res[i] != 0`, it means that we already populated the `i`th index of `res`, so we simply try populating the next index by returning `dfs(i + 1)`; Otherwise, we enumerate an integer `j` from `n` to `1`, and check if `j` is in `se`, i.e., if it has been used or not. We want to enumerate the integers from large to small because we want to construct the lexicographically largest sequence. If `j == 1`, we assign `res[i] = j`, and remove `j` from `se` to indicate that `j` has been used, then we run the recursive step `dfs(i + 1)`, if it returns `True`, it means that we already find the lexicographically largest sequence, and we return `True`; Otherwise, it means that there is no solution with the initial sequence being `res[:i]`, and let `res[i] = 0`, and add `i` back to `se`, and return `False`. The way to handle the `j != 1` case is identical, except that we need to populate both `res[i]` and `res[i + j]` with the number `j`, so that the condition \"**For every integer `i` between `2` and `n`, the distance between the two occurrences of `i` is exactly `i`**\" is satisied.\\n\\nTime complexity: O(n!), space complexity: O(n).\\n\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        res = [0] * (2 * n - 1)\\n        se = set([i for i in range(1, n + 1)])\\n        \\n        def dfs(i):\\n            if i >= 2 * n - 1:\\n                return True\\n            if res[i] != 0:\\n                return dfs(i + 1)\\n            for j in range(n, 0, -1):\\n                if j in se:\\n                    if j == 1:\\n                        se.remove(j)\\n                        res[i] = j\\n                        if (dfs(i + 1)):\\n                            return True\\n                        else:\\n                            se.add(j)\\n                            res[i] = 0\\n                    elif i + j < 2 * n - 1 and res[i + j] == 0:\\n                        se.remove(j)\\n                        res[i] = j\\n                        res[i + j] = j\\n                        if (dfs(i + 1)):\\n                            return True\\n                        else:\\n                            se.add(j)\\n                            res[i] = 0\\n                            res[i + j] = 0\\n            \\n            return False\\n            \\n        dfs(0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        res = [0] * (2 * n - 1)\\n        se = set([i for i in range(1, n + 1)])\\n        \\n        def dfs(i):\\n            if i >= 2 * n - 1:\\n                return True\\n            if res[i] != 0:\\n                return dfs(i + 1)\\n            for j in range(n, 0, -1):\\n                if j in se:\\n                    if j == 1:\\n                        se.remove(j)\\n                        res[i] = j\\n                        if (dfs(i + 1)):\\n                            return True\\n                        else:\\n                            se.add(j)\\n                            res[i] = 0\\n                    elif i + j < 2 * n - 1 and res[i + j] == 0:\\n                        se.remove(j)\\n                        res[i] = j\\n                        res[i + j] = j\\n                        if (dfs(i + 1)):\\n                            return True\\n                        else:\\n                            se.add(j)\\n                            res[i] = 0\\n                            res[i + j] = 0\\n            \\n            return False\\n            \\n        dfs(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018982,
                "title": "java-dfs-backtracking-0-ms",
                "content": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        var picked=new boolean[n+1];\\n        var dest=new int[n*2-1];\\n        dfs(dest,0,picked);\\n        return dest;\\n    }\\n    \\n    boolean dfs(int[] dest,int idx,boolean[] picked) {\\n        if(idx==dest.length) return true;\\n        if(dest[idx]!=0) return dfs(dest,idx+1,picked);\\n        for(int k=picked.length-1;k>=1;k--) {\\n            if(picked[k]) continue;\\n            if(k==1||(idx+k<dest.length&&dest[idx+k]==0)) {\\n                dest[idx]=k;\\n                if(k>1) dest[idx+k]=k;\\n                picked[k]=true;\\n                if(dfs(dest,idx+1,picked)) return true;\\n                dest[idx]=0;\\n                if(k!=1) dest[idx+k]=0;\\n                picked[k]=false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        var picked=new boolean[n+1];\\n        var dest=new int[n*2-1];\\n        dfs(dest,0,picked);\\n        return dest;\\n    }\\n    \\n    boolean dfs(int[] dest,int idx,boolean[] picked) {\\n        if(idx==dest.length) return true;\\n        if(dest[idx]!=0) return dfs(dest,idx+1,picked);\\n        for(int k=picked.length-1;k>=1;k--) {\\n            if(picked[k]) continue;\\n            if(k==1||(idx+k<dest.length&&dest[idx+k]==0)) {\\n                dest[idx]=k;\\n                if(k>1) dest[idx+k]=k;\\n                picked[k]=true;\\n                if(dfs(dest,idx+1,picked)) return true;\\n                dest[idx]=0;\\n                if(k!=1) dest[idx+k]=0;\\n                picked[k]=false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011902,
                "title": "c-backtracking-brute-force-easy-to-understand",
                "content": "We start from n and break the recusion as soon as we meet the solution to get lexigrapgically largest answer\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,int> h;\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> v((2*n)-1,0);\\n        int i;\\n        backtrack(v,0,n);\\n        return v;\\n    }\\n    \\n    bool backtrack(vector<int> &v,int p,int n)\\n    {\\n        if(p==v.size())\\n        return true;\\n            \\n        else if(v[p]!=0)\\n        return backtrack(v,p+1,n);\\n        \\n        else\\n        {       \\n            for(int i=n;i>=1;i--)\\n            {\\n                if(h[i]>0)\\n                continue;\\n\\n                if(i==1)\\n                {\\n                v[p]=1;\\n                h[1]++;\\n                if(backtrack(v,p+1,n))\\n                return true;\\n                v[p]=0;\\n                h[1]--;\\n                }\\n\\n                else if(p+i<v.size() && v[p]==0 && v[p+i]==0 )\\n                {\\n                v[p]=i;\\n                v[p+i]=i;\\n                h[i]++;\\n                if(backtrack(v,p+1,n))\\n                return true;\\n                h[i]--;\\n                v[p]=0;\\n                v[p+i]=0;\\n                }\\n            }  \\n        }  \\n        return false;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int,int> h;\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> v((2*n)-1,0);\\n        int i;\\n        backtrack(v,0,n);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1011274,
                "title": "c-o-n-greedy-backtracking-start-by-filling-largest-values",
                "content": "```csharp\\npublic int[] ConstructDistancedSequence(int n)\\n{\\n\\tint[] result = new int[2 * n - 1];\\n\\tbool[] visited = new bool[n + 1];\\n\\thelper(0, result, visited, n);\\n\\treturn result;\\n}\\n\\nprivate bool helper(int currentIndex, int[] result, bool[] visited, int n)\\n{\\n\\tif (currentIndex == result.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (result[currentIndex] != 0)\\n\\t{\\n\\t\\treturn helper(currentIndex + 1, result, visited, n);\\n\\t}\\n\\n\\tfor (int nextValue = n; nextValue > 0; nextValue--)\\n\\t{\\n\\t\\tif (visited[nextValue])\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tvisited[nextValue] = true;\\n\\t\\tresult[currentIndex] = nextValue;\\n\\n\\t\\tif (nextValue == 1)\\n\\t\\t{\\n\\t\\t\\tif (helper(currentIndex + 1, result, visited, n))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if (currentIndex + nextValue < result.Length && result[currentIndex + nextValue] == 0)\\n\\t\\t{\\n\\t\\t\\tresult[currentIndex + nextValue] = nextValue;\\n\\n\\t\\t\\tif (helper(currentIndex + 1, result, visited, n))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult[currentIndex + nextValue] = 0;\\n\\t\\t}\\n\\n\\t\\tvisited[nextValue] = false;\\n\\t\\tresult[currentIndex] = 0;\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] ConstructDistancedSequence(int n)\\n{\\n\\tint[] result = new int[2 * n - 1];\\n\\tbool[] visited = new bool[n + 1];\\n\\thelper(0, result, visited, n);\\n\\treturn result;\\n}\\n\\nprivate bool helper(int currentIndex, int[] result, bool[] visited, int n)\\n{\\n\\tif (currentIndex == result.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif (result[currentIndex] != 0)\\n\\t{\\n\\t\\treturn helper(currentIndex + 1, result, visited, n);\\n\\t}\\n\\n\\tfor (int nextValue = n; nextValue > 0; nextValue--)\\n\\t{\\n\\t\\tif (visited[nextValue])\\n\\t\\t{\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tvisited[nextValue] = true;\\n\\t\\tresult[currentIndex] = nextValue;\\n\\n\\t\\tif (nextValue == 1)\\n\\t\\t{\\n\\t\\t\\tif (helper(currentIndex + 1, result, visited, n))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\telse if (currentIndex + nextValue < result.Length && result[currentIndex + nextValue] == 0)\\n\\t\\t{\\n\\t\\t\\tresult[currentIndex + nextValue] = nextValue;\\n\\n\\t\\t\\tif (helper(currentIndex + 1, result, visited, n))\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult[currentIndex + nextValue] = 0;\\n\\t\\t}\\n\\n\\t\\tvisited[nextValue] = false;\\n\\t\\tresult[currentIndex] = 0;\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009568,
                "title": "concise-backtracking-solution",
                "content": "```\\nclass Solution {\\n  bool construct_seq(size_t pos, vector<int> &seq, vector<bool> &used) {\\n    if (pos == seq.size()) return 1;\\n    if (seq[pos]) return construct_seq(pos+1, seq, used);\\n\\n    for (int i = used.size()-1; i > 0; i--) {\\n      if (used[i]) continue;\\n      if (i == 1 || (seq.size() > pos + i && seq[pos + i] == 0)) {\\n        used[i] = seq[pos] = seq[pos + (i > 1? i : 0)] = i;\\n        if (construct_seq(pos + 1, seq, used)) return 1;\\n        else used[i] = seq[pos] = seq[pos + (i > 1? i : 0)] = 0;\\n      }\\n    }\\n    return 0;\\n  }\\n  \\npublic:\\n  // Complexity: O(n!) in the worst case\\n  vector<int> constructDistancedSequence(int n) {\\n    vector<bool> used(n+1);\\n    vector<int> seq((n-1)*2 + 1);\\n    construct_seq(0, seq, used);\\n    return seq;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  bool construct_seq(size_t pos, vector<int> &seq, vector<bool> &used) {\\n    if (pos == seq.size()) return 1;\\n    if (seq[pos]) return construct_seq(pos+1, seq, used);\\n\\n    for (int i = used.size()-1; i > 0; i--) {\\n      if (used[i]) continue;\\n      if (i == 1 || (seq.size() > pos + i && seq[pos + i] == 0)) {\\n        used[i] = seq[pos] = seq[pos + (i > 1? i : 0)] = i;\\n        if (construct_seq(pos + 1, seq, used)) return 1;\\n        else used[i] = seq[pos] = seq[pos + (i > 1? i : 0)] = 0;\\n      }\\n    }\\n    return 0;\\n  }\\n  \\npublic:\\n  // Complexity: O(n!) in the worst case\\n  vector<int> constructDistancedSequence(int n) {\\n    vector<bool> used(n+1);\\n    vector<int> seq((n-1)*2 + 1);\\n    construct_seq(0, seq, used);\\n    return seq;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009272,
                "title": "c-dfs-with-greedy-pruning-24ms",
                "content": "time O(N!) ?\\n\\n    vector<int> constructDistancedSequence(int n) {\\n        int total = 1 + (n - 1) * 2;        \\n        vector<int> res;\\n        vector<int> path(total, 0);        \\n        set<int> used;\\n        dfs(n, 0, path, res, total, used);        \\n        return res;        \\n    }\\n    \\n    void dfs(int n, int index, vector<int>& path, vector<int>& res, int total, set<int>& used) {        \\n        if (res.size() == total) return;\\n        if (used.size() == n) {\\n            res = path;           \\n            return;\\n        }\\n        \\n        if (path[index] > 0) {\\n            if (index < total) {\\n                dfs(n, index + 1, path, res, total, used);\\n            }\\n            return;\\n        }\\n        \\n        \\n        for(int i = n; i > 0; --i) {\\n            if (used.count(i) > 0) continue;\\n            \\n            if (i == 1) {\\n                if (path[index] == 0) {\\n                    path[index] = 1;\\n                    used.insert(1);\\n                    dfs(n, index + 1, path, res, total, used);\\n                    used.erase(1);\\n                    path[index] = 0;\\n                }\\n            } else {\\n                if (index + i < total && path[index] == 0 && path[i + index] == 0) {\\n                    path[index] = i;\\n                    path[i + index] = i;\\n                    used.insert(i);\\n                    dfs(n, index + 1, path, res, total, used);                \\n                    used.erase(i);\\n                    path[index] = 0;\\n                    path[i + index] = 0;                \\n                }\\n            }\\n        }        \\n    }",
                "solutionTags": [],
                "code": "time O(N!) ?\\n\\n    vector<int> constructDistancedSequence(int n) {\\n        int total = 1 + (n - 1) * 2;        \\n        vector<int> res;\\n        vector<int> path(total, 0);        \\n        set<int> used;\\n        dfs(n, 0, path, res, total, used);        \\n        return res;        \\n    }\\n    \\n    void dfs(int n, int index, vector<int>& path, vector<int>& res, int total, set<int>& used) {        \\n        if (res.size() == total) return;\\n        if (used.size() == n) {\\n            res = path;           \\n            return;\\n        }\\n        \\n        if (path[index] > 0) {\\n            if (index < total) {\\n                dfs(n, index + 1, path, res, total, used);\\n            }\\n            return;\\n        }\\n        \\n        \\n        for(int i = n; i > 0; --i) {\\n            if (used.count(i) > 0) continue;\\n            \\n            if (i == 1) {\\n                if (path[index] == 0) {\\n                    path[index] = 1;\\n                    used.insert(1);\\n                    dfs(n, index + 1, path, res, total, used);\\n                    used.erase(1);\\n                    path[index] = 0;\\n                }\\n            } else {\\n                if (index + i < total && path[index] == 0 && path[i + index] == 0) {\\n                    path[index] = i;\\n                    path[i + index] = i;\\n                    used.insert(i);\\n                    dfs(n, index + 1, path, res, total, used);                \\n                    used.erase(i);\\n                    path[index] = 0;\\n                    path[i + index] = 0;                \\n                }\\n            }\\n        }        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1009205,
                "title": "c-backtracking-with-comments",
                "content": "class Solution\\n{\\n\\n    vector<bool> visited;\\npublic:\\n    \\n    bool backtrack(int idx,int n,vector<int> &a)\\n    {\\n         // if we reached end ,it means we have found the solution\\n         if(idx == a.size())\\n         return true;\\n        \\n        // if current index is already filled, then just move on\\n        if(a[idx] != 0)\\n        return  backtrack(idx + 1, n, a);\\n        \\n        //now try to fill curr position greedily\\n        //ie. starting from highest no to lowest\\n        for(int i = n; i >= 1; i--)\\n        {\\n            //checking if it is already used\\n            if(visited[i])\\n                continue;\\n            \\n            if(i == 1)\\n            {\\n                a[idx] = 1;\\n                visited[1] = true;\\n                \\n                if(backtrack(idx+1,n,a)) return true;\\n                \\n                a[idx] = 0;\\n                visited[1] = false;\\n                    \\n            }\\n            \\n            else if(a[idx] == 0 and i + idx < a.size() and a[i + idx] == 0)\\n            {\\n                // temporaily filling the values\\n                a[idx] = i;\\n                a[i+idx] = i;\\n                visited[i] = true;\\n                \\n                if(backtrack(idx+1,n,a)) return true;\\n\\n                // resetting the values\\n                visited[i] = false;\\n                a[idx] = 0;\\n                a[i + idx] = 0;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n)\\n    {\\n        // base case\\n        if(n == 1)\\n            return {1};\\n        \\n        vector<int> a(2*n - 1);\\n        visited = vector<bool>(n);\\n\\n        // trivial case\\n        a[0] = a[n] = n;\\n        \\n        if(!backtrack(1,n-1,a))\\n            return {0};\\n        \\n        return a;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\n\\n    vector<bool> visited;\\npublic:\\n    \\n    bool backtrack(int idx,int n,vector<int> &a)\\n    {\\n         // if we reached end ,it means we have found the solution\\n         if(idx == a.size())\\n         return true;\\n        \\n        // if current index is already filled, then just move on\\n        if(a[idx] != 0)\\n        return  backtrack(idx + 1, n, a);\\n        \\n        //now try to fill curr position greedily\\n        //ie. starting from highest no to lowest\\n        for(int i = n; i >= 1; i--)\\n        {\\n            //checking if it is already used\\n            if(visited[i])\\n                continue;\\n            \\n            if(i == 1)\\n            {\\n                a[idx] = 1;\\n                visited[1] = true;\\n                \\n                if(backtrack(idx+1,n,a)) return true;\\n                \\n                a[idx] = 0;\\n                visited[1] = false;\\n                    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1009168,
                "title": "my-c-backtracking-solution",
                "content": "Greedy approach:\\nfrom the left to right, on each index try from the largest number to 1.\\nusing visited array to record which number is used.\\nI first tried to use the approach by arrange largest number first and then second number...,, which does not work since smaller number may take the slots in the front which are unfilled.\\n\\n```\\n    vector<int> constructDistancedSequence(int n) {\\n        //try to fill one by one (index)\\n        vector<int> ans,t(2*n-1);\\n        vector<bool> v(n+1);\\n        backtrack(0,v,t,ans);\\n        return ans;\\n    }\\n    \\n    //backtrack using number on this index will be OK\\n    bool backtrack(int ind,vector<bool>& v,vector<int>& t,vector<int>& ans){\\n        int used=accumulate(begin(v),end(v),0);\\n        int n=v.size()-1;\\n        //for(int i: t) cout<<i<<\" \";cout<<endl<<used<<endl;\\n        if(used==n){\\n            ans=max(ans,t);\\n            return 1;\\n        }\\n        if(ind>=t.size()){\\n            return 0;\\n        }\\n        if(t[ind]) return backtrack(ind+1,v,t,ans);\\n        \\n        for(int i=n;i>=1;i--){\\n            int add=i>1?i:0;\\n            if(v[i] || ind+add>=2*n-1 || t[ind+add]) continue;\\n            v[i]=1;\\n            t[ind]=t[ind+add]=i;\\n            if(backtrack(ind+1,v,t,ans)) return 1;\\n            t[ind]=t[ind+add]=0; //restore\\n            v[i]=0;\\n        }\\n        return 0;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n    vector<int> constructDistancedSequence(int n) {\\n        //try to fill one by one (index)\\n        vector<int> ans,t(2*n-1);\\n        vector<bool> v(n+1);\\n        backtrack(0,v,t,ans);\\n        return ans;\\n    }\\n    \\n    //backtrack using number on this index will be OK\\n    bool backtrack(int ind,vector<bool>& v,vector<int>& t,vector<int>& ans){\\n        int used=accumulate(begin(v),end(v),0);\\n        int n=v.size()-1;\\n        //for(int i: t) cout<<i<<\" \";cout<<endl<<used<<endl;\\n        if(used==n){\\n            ans=max(ans,t);\\n            return 1;\\n        }\\n        if(ind>=t.size()){\\n            return 0;\\n        }\\n        if(t[ind]) return backtrack(ind+1,v,t,ans);\\n        \\n        for(int i=n;i>=1;i--){\\n            int add=i>1?i:0;\\n            if(v[i] || ind+add>=2*n-1 || t[ind+add]) continue;\\n            v[i]=1;\\n            t[ind]=t[ind+add]=i;\\n            if(backtrack(ind+1,v,t,ans)) return 1;\\n            t[ind]=t[ind+add]=0; //restore\\n            v[i]=0;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1009123,
                "title": "brute-force-java-backtracking-solution-with-early-stop",
                "content": "I was thinking about whether there is any greedy strategy to directly solve this rather than searching. But I decided to use a brute-force backtracking as the size is limited with in 20... \\nOnce we find the valid solution, stop the backtracking and restore of the array to get the desired solution. This may help to improve the speed. I think the complexity should be O(n!). Please correct me if I\\'m wrong.\\n\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2 * n - 1];\\n        boolean[] used = new boolean[n+1];\\n        dfs(0, res, used);\\n        return res;\\n    }\\n    \\n    public boolean dfs(int idx, int[] res, boolean[] used) {\\n        if (idx == res.length) { // we have get the valid solution, yeah!\\n            return true;\\n        }\\n        \\n        if (res[idx] != 0) { // current position has been used, check the next one\\n            return dfs(idx+1, res, used);\\n        }\\n        \\n        // backtracking logic\\n        for (int n = used.length - 1; n > 0; n--) {\\n            // checking logic here:\\n            // 1. n is not used\\n            // 2. (idx + n) the index of the duplication must be valid\\n            // 3. res[idx + n] has NOT be used\\n            if (!used[n] && (n == 1 || idx+n < res.length && res[idx+n] == 0)) {\\n                res[idx] = n;\\n                if (n != 1) res[idx+n] = n;\\n                used[n] = true;\\n                if (dfs(idx+1, res, used)) return true;\\n                res[idx] = 0;\\n                if (n != 1)  res[idx+n] = 0;\\n                used[n] = false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2 * n - 1];\\n        boolean[] used = new boolean[n+1];\\n        dfs(0, res, used);\\n        return res;\\n    }\\n    \\n    public boolean dfs(int idx, int[] res, boolean[] used) {\\n        if (idx == res.length) { // we have get the valid solution, yeah!\\n            return true;\\n        }\\n        \\n        if (res[idx] != 0) { // current position has been used, check the next one\\n            return dfs(idx+1, res, used);\\n        }\\n        \\n        // backtracking logic\\n        for (int n = used.length - 1; n > 0; n--) {\\n            // checking logic here:\\n            // 1. n is not used\\n            // 2. (idx + n) the index of the duplication must be valid\\n            // 3. res[idx + n] has NOT be used\\n            if (!used[n] && (n == 1 || idx+n < res.length && res[idx+n] == 0)) {\\n                res[idx] = n;\\n                if (n != 1) res[idx+n] = n;\\n                used[n] = true;\\n                if (dfs(idx+1, res, used)) return true;\\n                res[idx] = 0;\\n                if (n != 1)  res[idx+n] = 0;\\n                used[n] = false;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008989,
                "title": "java-dfs-solution",
                "content": "We can use a DFS Solution to try each num, if there is a conflict, we return a array with length 0.\\n```\\n\\t\\tpublic int[] constructDistancedSequence(int n) {\\n\\t\\t\\tint[] res = new int[2*n-1];\\n\\t\\t\\treturn dfs(0, (1<<n+1)-2, res);\\n\\t\\t}\\n\\n\\t\\tint[] dfs(int cur, int rem, int[] temp)\\n\\t\\t{\\n\\t\\t\\tif(cur == temp.length){\\n\\t\\t\\t\\treturn Arrays.copyOf(temp, temp.length);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp[cur] > 0){\\n\\t\\t\\t\\treturn dfs(cur+1, rem, temp);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 20;i >= 1;i--){\\n\\t\\t\\t\\tif(rem <<~i <0){\\n\\t\\t\\t\\t\\tif(i > 1 && cur+i < temp.length && temp[cur+i] == 0) {\\n\\t\\t\\t\\t\\t\\ttemp[cur] = temp[cur + i] = i;\\n\\t\\t\\t\\t\\t\\tint[] res = dfs(cur+1, rem^1<<i, temp);\\n\\t\\t\\t\\t\\t\\tif(res.length != 0){\\n\\t\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttemp[cur] = temp[cur + i] = 0;\\n\\t\\t\\t\\t\\t}else if(i == 1){\\n\\t\\t\\t\\t\\t\\ttemp[cur] = 1;\\n\\t\\t\\t\\t\\t\\tint[] res = dfs(cur+1, rem^1<<1, temp);\\n\\t\\t\\t\\t\\t\\tif(res.length != 0){\\n\\t\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttemp[cur] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new int[0];\\n\\t\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic int[] constructDistancedSequence(int n) {\\n\\t\\t\\tint[] res = new int[2*n-1];\\n\\t\\t\\treturn dfs(0, (1<<n+1)-2, res);\\n\\t\\t}\\n\\n\\t\\tint[] dfs(int cur, int rem, int[] temp)\\n\\t\\t{\\n\\t\\t\\tif(cur == temp.length){\\n\\t\\t\\t\\treturn Arrays.copyOf(temp, temp.length);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp[cur] > 0){\\n\\t\\t\\t\\treturn dfs(cur+1, rem, temp);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 20;i >= 1;i--){\\n\\t\\t\\t\\tif(rem <<~i <0){\\n\\t\\t\\t\\t\\tif(i > 1 && cur+i < temp.length && temp[cur+i] == 0) {\\n\\t\\t\\t\\t\\t\\ttemp[cur] = temp[cur + i] = i;\\n\\t\\t\\t\\t\\t\\tint[] res = dfs(cur+1, rem^1<<i, temp);\\n\\t\\t\\t\\t\\t\\tif(res.length != 0){\\n\\t\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttemp[cur] = temp[cur + i] = 0;\\n\\t\\t\\t\\t\\t}else if(i == 1){\\n\\t\\t\\t\\t\\t\\ttemp[cur] = 1;\\n\\t\\t\\t\\t\\t\\tint[] res = dfs(cur+1, rem^1<<1, temp);\\n\\t\\t\\t\\t\\t\\tif(res.length != 0){\\n\\t\\t\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttemp[cur] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new int[0];\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008942,
                "title": "c-easy-backtrack",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int sz;\\n    unordered_set<int> vis;\\n\\n    bool solve(int id,vector<int> &arr,int n){\\n        \\n        if(id==sz){\\n            if(vis.size()!=n) return 0;\\n            return 1;\\n        }\\n\\n        if(arr[id]!=0) \\n            return solve(id+1,arr,n);\\n\\n        for(int i=n;i>=1;i--){\\n\\n            if(vis.count(i)) continue;\\n\\n            if(i!=1 && id+i<sz && arr[id+i]==0){\\n                arr[id] = arr[id+i] = i;\\n                vis.insert(i);\\n                if(solve(id+1,arr,n)) return 1;\\n                arr[id] = arr[id+i] = 0;\\n                vis.erase(i);\\n            }\\n            else if(i==1){\\n                arr[id] = 1;\\n                vis.insert(1);\\n                if(solve(id+1,arr,n)) return 1;\\n                arr[id] = 0;\\n                vis.erase(1);\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n\\n        sz = 2*n-1;\\n        vector<int> arr(sz,0);\\n        solve(0,arr,n);\\n        return arr;\\n    }\\n\\n};\\n```\\nPlease ask if something is unclear, Thanks !!",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    int sz;\\n    unordered_set<int> vis;\\n\\n    bool solve(int id,vector<int> &arr,int n){\\n        \\n        if(id==sz){\\n            if(vis.size()!=n) return 0;\\n            return 1;\\n        }\\n\\n        if(arr[id]!=0) \\n            return solve(id+1,arr,n);\\n\\n        for(int i=n;i>=1;i--){\\n\\n            if(vis.count(i)) continue;\\n\\n            if(i!=1 && id+i<sz && arr[id+i]==0){\\n                arr[id] = arr[id+i] = i;\\n                vis.insert(i);\\n                if(solve(id+1,arr,n)) return 1;\\n                arr[id] = arr[id+i] = 0;\\n                vis.erase(i);\\n            }\\n            else if(i==1){\\n                arr[id] = 1;\\n                vis.insert(1);\\n                if(solve(id+1,arr,n)) return 1;\\n                arr[id] = 0;\\n                vis.erase(1);\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n\\n        sz = 2*n-1;\\n        vector<int> arr(sz,0);\\n        solve(0,arr,n);\\n        return arr;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008937,
                "title": "c-dfs",
                "content": "From position 0 to position 2 * n - 2, try to put every number from N to 1, using DFS to judges whether it can be a legal sequence. The first found sequence is the answer.\\n```\\nclass Solution {\\npublic:\\n    vector<int> rec;\\n    vector<vector<int>> all;\\n    bool visit[21];\\n    vector<int> constructDistancedSequence(int n) {\\n        rec.resize(2 * n - 1, 0);\\n        memset(visit, false, sizeof visit);\\n        dfs(n, 0);\\n        return rec;\\n    }\\n    bool dfs(int n, int i) {\\n        while (i < 2 * n - 1 && rec[i] != 0) i++;\\n        if (i == 2 * n - 1) return true;\\n        for (int j = n; j > 1; j--) {\\n            if (!visit[j] && i + j < 2 * n - 1 && rec[i + j] == 0) {\\n                visit[j] = true;\\n                rec[i] = rec[i + j] = j;\\n                if (dfs(n, i + 1)) return true;\\n                rec[i] = rec[i + j] = 0;\\n                visit[j] = false;\\n            }\\n        }\\n        if (!visit[1]) {\\n            visit[1] = true;\\n            rec[i] = 1;\\n            if (dfs(n, i + 1)) return true;\\n            rec[i] = 0;\\n            visit[1] = false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rec;\\n    vector<vector<int>> all;\\n    bool visit[21];\\n    vector<int> constructDistancedSequence(int n) {\\n        rec.resize(2 * n - 1, 0);\\n        memset(visit, false, sizeof visit);\\n        dfs(n, 0);\\n        return rec;\\n    }\\n    bool dfs(int n, int i) {\\n        while (i < 2 * n - 1 && rec[i] != 0) i++;\\n        if (i == 2 * n - 1) return true;\\n        for (int j = n; j > 1; j--) {\\n            if (!visit[j] && i + j < 2 * n - 1 && rec[i + j] == 0) {\\n                visit[j] = true;\\n                rec[i] = rec[i + j] = j;\\n                if (dfs(n, i + 1)) return true;\\n                rec[i] = rec[i + j] = 0;\\n                visit[j] = false;\\n            }\\n        }\\n        if (!visit[1]) {\\n            visit[1] = true;\\n            rec[i] = 1;\\n            if (dfs(n, i + 1)) return true;\\n            rec[i] = 0;\\n            visit[1] = false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908275,
                "title": "c-solution-easy-solution-using-backtracking-bitmask",
                "content": "```\\npublic class Solution {\\n    public int[] ConstructDistancedSequence(int n) {\\n        int size = n * 2 - 1;\\n        int[] res = new int[size];\\n        int visit = 0;       \\n        bool solve(int idx){\\n            if(idx >= size) return true;\\n            if(res[idx] != 0) return solve(idx + 1);\\n            for(int i = n; i > 0;i--){\\n                if((visit & (1<<i)) > 0) continue;\\n                if(i != 1 && (idx + i >= size || res[idx] != res[i + idx])) continue;\\n                if(i != 1)res[idx] = res[i + idx] =  i;\\n                else res[idx] = 1;\\n                visit|= (1<<i);\\n                bool check = solve(idx + 1);\\n                if(check) return true;\\n                visit ^= (1<<i);;\\n                if(i != 1) res[idx] = res[i + idx] = 0;\\n                else res[idx] = 0;\\n            }\\n            return false;\\n        }\\n        solve(0);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ConstructDistancedSequence(int n) {\\n        int size = n * 2 - 1;\\n        int[] res = new int[size];\\n        int visit = 0;       \\n        bool solve(int idx){\\n            if(idx >= size) return true;\\n            if(res[idx] != 0) return solve(idx + 1);\\n            for(int i = n; i > 0;i--){\\n                if((visit & (1<<i)) > 0) continue;\\n                if(i != 1 && (idx + i >= size || res[idx] != res[i + idx])) continue;\\n                if(i != 1)res[idx] = res[i + idx] =  i;\\n                else res[idx] = 1;\\n                visit|= (1<<i);\\n                bool check = solve(idx + 1);\\n                if(check) return true;\\n                visit ^= (1<<i);;\\n                if(i != 1) res[idx] = res[i + idx] = 0;\\n                else res[idx] = 0;\\n            }\\n            return false;\\n        }\\n        solve(0);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715330,
                "title": "easily-readable-c-backtracking-solution-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to always consider the next biggest number we can use and perfectly place each and every number around it satisfying the conditions given in the problem. We could understand it as Greedy BackTracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we need to try out different combinations, the natural solution is recursion and backtracking so as to keep trying different combinations and use the appropriate one.\\nThe base case is the usual whenever we are trying all the combinations , we make the combination and when we are through with it we check if it fits our conditions, so as we did not need any unfilled element we counted if there were any 0\\'s present.\\n\\nWe also iterate everytime from n to 1 while keeping a check on those elements which we haven\\'t visited so as to not fill them again and if we do not find a matching combination we back track and fill some other element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nExponential although not Factorial due to our constraints of |i - j| \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ due to the visited vector + Recursive Stack Space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool backTrack(vector<int>& vec, int p, int n, vector<bool>& vis, int sz)\\n    {\\n        if(p == sz)\\n        {\\n            if(count(vec.begin(), vec.end(), 0) == 0)\\n                return true;\\n            return false;\\n        }\\n        for(int i = n; i >= 1; i--)\\n        {\\n            if(i == 1 && vec[p] == 0 && vis[i] == false)\\n            {\\n                vis[i] = true;\\n                vec[p] = i;\\n                if(backTrack(vec, p + 1, n, vis, sz))\\n                    return true;\\n                vis[i] = false;\\n                vec[p] = 0;\\n            }\\n            else if(p + i < sz && vec[p] == 0 && vec[p + i] == 0 && vis[i] == false)\\n            {\\n                vis[i] = true;\\n                vec[p] = vec[p + i] = i;\\n                if(backTrack(vec, p + 1, n, vis, sz))\\n                    return true;\\n                vis[i] = false;\\n                vec[p] = vec[p + i] = 0;\\n            }\\n        }\\n        if(count(vec.begin(), vec.end(), 0) == 0)\\n            return true;\\n        return backTrack(vec, p + 1, n, vis, sz);\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        int size = 2 * n - 1;\\n        vector<int> vec(size, 0);\\n        vector<bool> vis(n + 1, false);\\n        bool what = backTrack(vec, 0, n, vis, size);\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool backTrack(vector<int>& vec, int p, int n, vector<bool>& vis, int sz)\\n    {\\n        if(p == sz)\\n        {\\n            if(count(vec.begin(), vec.end(), 0) == 0)\\n                return true;\\n            return false;\\n        }\\n        for(int i = n; i >= 1; i--)\\n        {\\n            if(i == 1 && vec[p] == 0 && vis[i] == false)\\n            {\\n                vis[i] = true;\\n                vec[p] = i;\\n                if(backTrack(vec, p + 1, n, vis, sz))\\n                    return true;\\n                vis[i] = false;\\n                vec[p] = 0;\\n            }\\n            else if(p + i < sz && vec[p] == 0 && vec[p + i] == 0 && vis[i] == false)\\n            {\\n                vis[i] = true;\\n                vec[p] = vec[p + i] = i;\\n                if(backTrack(vec, p + 1, n, vis, sz))\\n                    return true;\\n                vis[i] = false;\\n                vec[p] = vec[p + i] = 0;\\n            }\\n        }\\n        if(count(vec.begin(), vec.end(), 0) == 0)\\n            return true;\\n        return backTrack(vec, p + 1, n, vis, sz);\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        int size = 2 * n - 1;\\n        vector<int> vec(size, 0);\\n        vector<bool> vis(n + 1, false);\\n        bool what = backTrack(vec, 0, n, vis, size);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556725,
                "title": "rust-python-dfs-with-explanation",
                "content": "# Intuition\\n\\nLooking at the time constrains, one can see that we can generate some sort of bruteforce solution, which will smartly assign the numbers to positions.\\n\\nMy first thought was something like **Python_wrong** which resulted in the right sequences, but not the biggest. I thought that I can quickly fix it by generating all and find biggest, but the number of sequences grows too fast, so had to abandon this idea. \\n\\nSecond approach was to pick the biggest number as close to the start of the array as possible. Similar to a previous approach, I need to check whether the positions where not already used for other numbers. Here I also need to check if the number is 1 as you need to insert it only in one position.\\n\\n# Complexity\\n\\nI tried various approaches to analyze the complexity, but it is hard as sometimes the result for the next value takes way longer time than previous. For example `T(32) = 11s, T(38) < 0.01`. This is because the recusion for can iterate over less number of positions.\\n\\nUsing counter to find the number of `dfs` calls, the value seems to be below $O(2^n)$ \\n\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n\\n  fn dfs(arr: &mut Vec<i32>, p: usize) -> Vec<i32> {\\n    if p == arr.len() {\\n      return arr.to_vec();\\n    }\\n    if arr[p] != 0 {\\n      return Self::dfs(arr, p + 1);\\n    }\\n\\n    for num in (1 .. arr.len() / 2 + 2).rev() {\\n      if arr.contains(&(num as i32)) { \\n        continue;\\n      }\\n\\n      if num == 1 {\\n        arr[p] = 1;\\n        let res = Self::dfs(arr, p + 1);\\n        if !res.is_empty() {\\n          return res;\\n        }\\n        arr[p] = 0;\\n      } else if p + num < arr.len() && arr[p + num] == 0 {\\n        arr[p] = num as i32;\\n        arr[p + num] = num as i32;\\n        let res = Self::dfs(arr, p + 1);\\n        if !res.is_empty() {\\n          return res;\\n        }\\n        arr[p] = 0 as i32;\\n        arr[p + num] = 0 as i32;\\n      }\\n    }\\n\\n    return Vec::new();\\n  }\\n\\n  pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {\\n    let mut arr = vec![0; (2 * n - 1) as usize];\\n    return Self::dfs(&mut arr, 0);\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n\\n  def dfs(self, arr, p):\\n    if p == len(arr):\\n      return arr\\n\\n    if arr[p] != 0:\\n      return self.dfs(arr, p + 1)\\n\\n    for num in range(len(arr) // 2 + 1, 0, -1):\\n      if num in arr:\\n        continue\\n\\n      if num == 1:\\n        arr[p] = 1\\n        res = self.dfs(arr, p + 1)\\n        if res:\\n          return res\\n        arr[p] = 0\\n      else:\\n        if p + num < len(arr) and arr[p + num] == 0:\\n          arr[p], arr[p + num] = num, num\\n          res = self.dfs(arr, p + 1)\\n          if res:\\n            return res\\n          arr[p], arr[p + num] = 0, 0\\n\\n    return []\\n\\n  def constructDistancedSequence(self, n: int) -> List[int]:\\n    return self.dfs([0] * (2 * n - 1), 0)\\n```\\n```Python_wrong []\\nclass Solution_1:\\n\\n  def __init__(self):\\n    self.data = []\\n\\n  def dfs(self, n):\\n    if n == 1:\\n      return True\\n\\n    for i in range(len(self.data) - n):\\n      if self.data[i] == 1 and self.data[i + n] == 1:\\n        self.data[i], self.data[i + n] = n, n\\n        if self.dfs(n - 1):\\n          return True\\n        self.data[i], self.data[i + n] = 1, 1\\n\\n    return False\\n\\n  def constructDistancedSequence(self, n: int) -> List[int]:\\n    self.data = [1] * (2 * n - 1)\\n    self.dfs(n)\\n    return self.data\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n\\n  fn dfs(arr: &mut Vec<i32>, p: usize) -> Vec<i32> {\\n    if p == arr.len() {\\n      return arr.to_vec();\\n    }\\n    if arr[p] != 0 {\\n      return Self::dfs(arr, p + 1);\\n    }\\n\\n    for num in (1 .. arr.len() / 2 + 2).rev() {\\n      if arr.contains(&(num as i32)) { \\n        continue;\\n      }\\n\\n      if num == 1 {\\n        arr[p] = 1;\\n        let res = Self::dfs(arr, p + 1);\\n        if !res.is_empty() {\\n          return res;\\n        }\\n        arr[p] = 0;\\n      } else if p + num < arr.len() && arr[p + num] == 0 {\\n        arr[p] = num as i32;\\n        arr[p + num] = num as i32;\\n        let res = Self::dfs(arr, p + 1);\\n        if !res.is_empty() {\\n          return res;\\n        }\\n        arr[p] = 0 as i32;\\n        arr[p + num] = 0 as i32;\\n      }\\n    }\\n\\n    return Vec::new();\\n  }\\n\\n  pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {\\n    let mut arr = vec![0; (2 * n - 1) as usize];\\n    return Self::dfs(&mut arr, 0);\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n\\n  def dfs(self, arr, p):\\n    if p == len(arr):\\n      return arr\\n\\n    if arr[p] != 0:\\n      return self.dfs(arr, p + 1)\\n\\n    for num in range(len(arr) // 2 + 1, 0, -1):\\n      if num in arr:\\n        continue\\n\\n      if num == 1:\\n        arr[p] = 1\\n        res = self.dfs(arr, p + 1)\\n        if res:\\n          return res\\n        arr[p] = 0\\n      else:\\n        if p + num < len(arr) and arr[p + num] == 0:\\n          arr[p], arr[p + num] = num, num\\n          res = self.dfs(arr, p + 1)\\n          if res:\\n            return res\\n          arr[p], arr[p + num] = 0, 0\\n\\n    return []\\n\\n  def constructDistancedSequence(self, n: int) -> List[int]:\\n    return self.dfs([0] * (2 * n - 1), 0)\\n```\n```Python_wrong []\\nclass Solution_1:\\n\\n  def __init__(self):\\n    self.data = []\\n\\n  def dfs(self, n):\\n    if n == 1:\\n      return True\\n\\n    for i in range(len(self.data) - n):\\n      if self.data[i] == 1 and self.data[i + n] == 1:\\n        self.data[i], self.data[i + n] = n, n\\n        if self.dfs(n - 1):\\n          return True\\n        self.data[i], self.data[i + n] = 1, 1\\n\\n    return False\\n\\n  def constructDistancedSequence(self, n: int) -> List[int]:\\n    self.data = [1] * (2 * n - 1)\\n    self.dfs(n)\\n    return self.data\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533462,
                "title": "python3-solution-ternary-operators",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPut the integers in from left to right, and from large to small. Whenver we can fill the array, we have the answer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStandard backtracking. The answer is found whenever we reach the end\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI tried larger $n$, and found that when $n$ is $39$, the calculation suddenly takes very long, probably because this is the first number in which the question setup breaks down.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n#\\n# @lc app=leetcode id=1718 lang=python3\\n#\\n# [1718] Construct the Lexicographically Largest Valid Sequence\\n#\\n\\n# @lc code=start\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    Put the integers in from left to right, and from large to small. Whenver we can fill the array, we have the answer\\n    \\'\\'\\'                \\n\\n    def backtrack(self, i):\\n        if i == 2*self.n - 1:\\n            self.ans = [num for num in self.arr]\\n            return True\\n        elif self.arr[i] > 0:\\n            return self.backtrack(i + 1)\\n        else:\\n            for j in range(self.n, 0, -1):\\n                if j not in self.used and (i + j < 2*self.n - 1 if j > 1 else True) and self.arr[i] == 0 and (True if j == 1 else self.arr[i + j] == 0):\\n                    self.used.add(j)\\n                    self.arr[i] = j\\n                    if j > 1:\\n                        self.arr[i + j] = j\\n                    if self.backtrack(i + 1):\\n                        return True\\n                    self.arr[i] = 0\\n                    if j > 1:\\n                        self.arr[i + j] = 0\\n                    self.used.remove(j)\\n            return False\\n\\n\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.arr = [0 for i in range(2*n - 1)]\\n        self.used = set()\\n        self.n = n\\n        self.ans = []\\n        found = self.backtrack(0)\\n        return self.ans\\n        \\n\\n            \\n# @lc code=end\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#\\n# @lc app=leetcode id=1718 lang=python3\\n#\\n# [1718] Construct the Lexicographically Largest Valid Sequence\\n#\\n\\n# @lc code=start\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    Put the integers in from left to right, and from large to small. Whenver we can fill the array, we have the answer\\n    \\'\\'\\'                \\n\\n    def backtrack(self, i):\\n        if i == 2*self.n - 1:\\n            self.ans = [num for num in self.arr]\\n            return True\\n        elif self.arr[i] > 0:\\n            return self.backtrack(i + 1)\\n        else:\\n            for j in range(self.n, 0, -1):\\n                if j not in self.used and (i + j < 2*self.n - 1 if j > 1 else True) and self.arr[i] == 0 and (True if j == 1 else self.arr[i + j] == 0):\\n                    self.used.add(j)\\n                    self.arr[i] = j\\n                    if j > 1:\\n                        self.arr[i + j] = j\\n                    if self.backtrack(i + 1):\\n                        return True\\n                    self.arr[i] = 0\\n                    if j > 1:\\n                        self.arr[i + j] = 0\\n                    self.used.remove(j)\\n            return False\\n\\n\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.arr = [0 for i in range(2*n - 1)]\\n        self.used = set()\\n        self.n = n\\n        self.ans = []\\n        found = self.backtrack(0)\\n        return self.ans\\n        \\n\\n            \\n# @lc code=end\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385956,
                "title": "c-soluiton",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool rec(int ind,int n,vector<int>&cur,int pick,int& sz,vector<int>&ans,int& val)\\n    {\\n       if (pick==val)\\n       {\\n           ans=cur;\\n           return true;\\n       }\\n        if (ind>=sz) return false;\\n       if (cur[ind]!=-1) \\n       {\\n           if (rec(ind+1,n,cur,pick,sz,ans,val)) return true;\\n           return false;\\n       }\\n       for (int i=n;i>=1;i--)\\n       {\\n           if (i==1)\\n           {\\n               cur[ind]=1;\\n               int temp=pick;\\n               pick=(pick|1);\\n               if (rec(ind+1,n,cur,pick,sz,ans,val)) return true;\\n               pick=temp;\\n               cur[ind]=-1;\\n           }\\n           else {\\n               if((pick&(1<<(i-1)))==0 && ind+i<sz && cur[ind+i]==-1)\\n           {\\n               cur[ind]=i;\\n               cur[ind+i]=i;\\n               int temp=pick;\\n               pick=pick|(1<<(i-1));\\n               if (rec(ind+1,n,cur,pick,sz,ans,val)) return true;\\n               cur[ind]=-1;\\n               pick=temp;\\n               cur[ind+i]=-1;\\n           }}\\n       }\\n       return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        int val=(1<<n);\\n        val-=1;\\n        int sz=(n-1)*2+1;\\n        vector<int>ans(sz,-1);\\n        vector<int>cur(sz,-1);\\n        rec(0,n,cur,0,sz,ans,val);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(int ind,int n,vector<int>&cur,int pick,int& sz,vector<int>&ans,int& val)\\n    {\\n       if (pick==val)\\n       {\\n           ans=cur;\\n           return true;\\n       }\\n        if (ind>=sz) return false;\\n       if (cur[ind]!=-1) \\n       {\\n           if (rec(ind+1,n,cur,pick,sz,ans,val)) return true;\\n           return false;\\n       }\\n       for (int i=n;i>=1;i--)\\n       {\\n           if (i==1)\\n           {\\n               cur[ind]=1;\\n               int temp=pick;\\n               pick=(pick|1);\\n               if (rec(ind+1,n,cur,pick,sz,ans,val)) return true;\\n               pick=temp;\\n               cur[ind]=-1;\\n           }\\n           else {\\n               if((pick&(1<<(i-1)))==0 && ind+i<sz && cur[ind+i]==-1)\\n           {\\n               cur[ind]=i;\\n               cur[ind+i]=i;\\n               int temp=pick;\\n               pick=pick|(1<<(i-1));\\n               if (rec(ind+1,n,cur,pick,sz,ans,val)) return true;\\n               cur[ind]=-1;\\n               pick=temp;\\n               cur[ind+i]=-1;\\n           }}\\n       }\\n       return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        int val=(1<<n);\\n        val-=1;\\n        int sz=(n-1)*2+1;\\n        vector<int>ans(sz,-1);\\n        vector<int>cur(sz,-1);\\n        rec(0,n,cur,0,sz,ans,val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377247,
                "title": "easy-to-understand-java-backtracking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] result;\\n    private Set<Integer> valuesSeen;\\n    private int n;\\n\\n    private boolean isValid(int value, int index) {\\n        if (result[index] != 0) {\\n            return false;\\n        }\\n\\n        if (value != 1) {\\n            if (value + index >= result.length || result[index + value] != 0) {\\n                return false;\\n            }\\n        } \\n\\n        return !valuesSeen.contains(value);\\n    }\\n\\n    private boolean isFinalResult() {\\n        for (int val: result) {\\n            if (val == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int findNextIndex() {\\n        for (int i = 0; i < result.length; i++) {\\n            if (result[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public boolean backtrack(int index) {\\n        if (isFinalResult()) {\\n            return true;\\n        }\\n\\n        boolean solutionFound = false;\\n        for (int value = n; value > 0; value--) {\\n            if (isValid(value, index)){\\n                result[index] = value;\\n                valuesSeen.add(value);\\n\\n                if (value != 1) {\\n                    result[index + value] = value;\\n                }\\n\\n                solutionFound = backtrack(findNextIndex());\\n\\n                if (!solutionFound) {\\n                    result[index] = 0;\\n                    valuesSeen.remove(value);\\n\\n                    if (value != 1) {\\n                        result[index + value] = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return solutionFound;\\n    }\\n    \\n    public int[] constructDistancedSequence(int n) {\\n        this.n = n;\\n        result = new int[2 * n - 1];\\n        valuesSeen = new HashSet<>();\\n\\n        backtrack(0);\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] result;\\n    private Set<Integer> valuesSeen;\\n    private int n;\\n\\n    private boolean isValid(int value, int index) {\\n        if (result[index] != 0) {\\n            return false;\\n        }\\n\\n        if (value != 1) {\\n            if (value + index >= result.length || result[index + value] != 0) {\\n                return false;\\n            }\\n        } \\n\\n        return !valuesSeen.contains(value);\\n    }\\n\\n    private boolean isFinalResult() {\\n        for (int val: result) {\\n            if (val == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int findNextIndex() {\\n        for (int i = 0; i < result.length; i++) {\\n            if (result[i] == 0){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public boolean backtrack(int index) {\\n        if (isFinalResult()) {\\n            return true;\\n        }\\n\\n        boolean solutionFound = false;\\n        for (int value = n; value > 0; value--) {\\n            if (isValid(value, index)){\\n                result[index] = value;\\n                valuesSeen.add(value);\\n\\n                if (value != 1) {\\n                    result[index + value] = value;\\n                }\\n\\n                solutionFound = backtrack(findNextIndex());\\n\\n                if (!solutionFound) {\\n                    result[index] = 0;\\n                    valuesSeen.remove(value);\\n\\n                    if (value != 1) {\\n                        result[index + value] = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return solutionFound;\\n    }\\n    \\n    public int[] constructDistancedSequence(int n) {\\n        this.n = n;\\n        result = new int[2 * n - 1];\\n        valuesSeen = new HashSet<>();\\n\\n        backtrack(0);\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328616,
                "title": "java-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        //length is like every num has to be place twise so 2*n but not 1, that will be placed only once\\n        int[] res = new int[2 * n - 1];\\n        \\n        // if num is used it wont be used again\\n        boolean[] used = new boolean[n + 1];\\n        \\n        backtrack(res, used, n, 0);\\n        return res;\\n    }\\n\\n    private boolean backtrack(int[] res, boolean[] used, int n, int index) {\\n        // If res array is already filled\\n        if (index == res.length) {\\n            return true;\\n        }\\n        \\n        // If number is already filled then go ahead to place another number on index + 1\\n        if (res[index] != 0) return backtrack(res, used, n, index + 1);\\n        \\n        \\n        for (int i = n; i >= 1; i--) {\\n            // if the number \\'i\\' is already used then go ahead\\n            if (used[i]) continue;\\n            \\n            // next index a/c to the condition#3 to place the same number means twice\\n            int nextIndex = index + i; \\n            \\n            // if the number is not 1 then check if its possible to place same num on the nextIndex\\n            // and also check if on the nextIndex if the same number is already filled or not\\n            if (i != 1 && (nextIndex >= res.length || res[nextIndex] != 0)) continue;\\n            \\n            // place numnber on index\\n            res[index] = i;\\n            \\n            // means the number \\'i\\' is used or filled\\n            used[i] = true;\\n            \\n            //if this number is not 1 so this num is must be place twise on nextIndex\\n            if (i != 1) res[nextIndex] = i;\\n            \\n            // now time to backtrack\\n            if (backtrack(res, used, n, index + 1)) return true;\\n            \\n            // backtrack to same position\\n            res[index] = 0;\\n            \\n            // make it available again to use again\\n            used[i] = false;\\n            \\n            // if num was not 1 then make its nextIndex availabe also to place another number\\n            if (i != 1) res[nextIndex] = 0;\\n            \\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        //length is like every num has to be place twise so 2*n but not 1, that will be placed only once\\n        int[] res = new int[2 * n - 1];\\n        \\n        // if num is used it wont be used again\\n        boolean[] used = new boolean[n + 1];\\n        \\n        backtrack(res, used, n, 0);\\n        return res;\\n    }\\n\\n    private boolean backtrack(int[] res, boolean[] used, int n, int index) {\\n        // If res array is already filled\\n        if (index == res.length) {\\n            return true;\\n        }\\n        \\n        // If number is already filled then go ahead to place another number on index + 1\\n        if (res[index] != 0) return backtrack(res, used, n, index + 1);\\n        \\n        \\n        for (int i = n; i >= 1; i--) {\\n            // if the number \\'i\\' is already used then go ahead\\n            if (used[i]) continue;\\n            \\n            // next index a/c to the condition#3 to place the same number means twice\\n            int nextIndex = index + i; \\n            \\n            // if the number is not 1 then check if its possible to place same num on the nextIndex\\n            // and also check if on the nextIndex if the same number is already filled or not\\n            if (i != 1 && (nextIndex >= res.length || res[nextIndex] != 0)) continue;\\n            \\n            // place numnber on index\\n            res[index] = i;\\n            \\n            // means the number \\'i\\' is used or filled\\n            used[i] = true;\\n            \\n            //if this number is not 1 so this num is must be place twise on nextIndex\\n            if (i != 1) res[nextIndex] = i;\\n            \\n            // now time to backtrack\\n            if (backtrack(res, used, n, index + 1)) return true;\\n            \\n            // backtrack to same position\\n            res[index] = 0;\\n            \\n            // make it available again to use again\\n            used[i] = false;\\n            \\n            // if num was not 1 then make its nextIndex availabe also to place another number\\n            if (i != 1) res[nextIndex] = 0;\\n            \\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276146,
                "title": "backtracking-c-easy-solution",
                "content": "# Intuition\\nWe will get lexicographically largest sequence when we pick the largest possible number for each position, starting from the first position.\\n\\n# Approach\\n1. We will create a $$res$$ vector of size $$2*n+1$$.\\n2. A $$used$$ vector of size $$n+1$$, that will indicate which numbers from $$1$$ to $$n$$ have been used.\\n3. Now we will use a helper function that will give us are sequence.\\n4. In this function, if $$res[index]$$ is occupied, we will got $$index+1$$.\\n5. if not, we will do a loop to select number from $$1$$ to $$n$$.\\n6. if a $$number$$ is used, go to next iteration.\\n7. if $$number$$ = 1, then $$res[index] = number$$, mark it as used, call function again, if got an answer retur otherwise backtrack.\\n8. if $$number$$ is from $$2$$ to $$n$$ and $$index+number$$ is valid and unoccupied, then $$res[index] = res[index+number] = number$$, mark it as used, call function again, if got an answer retur otherwise backtrack.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> solve(vector<int>& res, vector<int>& used, int index){\\n        if(index == res.size()){\\n            return res;\\n        }\\n        // position used, go to next index\\n        if(res[index] != 0){\\n            return solve(res, used, index+1);\\n        }\\n        // from n to 1\\n        for(int i=used.size()-1; i>=1; i--){\\n            // number used\\n            if(used[i] == 0){\\n                continue;\\n            }\\n            int dist = (i == 1) ? 0 : i;\\n            if(index + dist < res.size() && res[index + dist] == 0){\\n                res[index] = res[index + dist] = i;\\n                used[i] = 0;\\n                vector<int> temp = solve(res, used, index+1);\\n                if(!temp.empty()){\\n                    return temp;\\n                }\\n                used[i] = 1;\\n                res[index] = res[index + dist] = 0;\\n            }\\n        }\\n        return {};\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> res(2*n-1, 0), used(n+1, 1);\\n        return solve(res, used, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> solve(vector<int>& res, vector<int>& used, int index){\\n        if(index == res.size()){\\n            return res;\\n        }\\n        // position used, go to next index\\n        if(res[index] != 0){\\n            return solve(res, used, index+1);\\n        }\\n        // from n to 1\\n        for(int i=used.size()-1; i>=1; i--){\\n            // number used\\n            if(used[i] == 0){\\n                continue;\\n            }\\n            int dist = (i == 1) ? 0 : i;\\n            if(index + dist < res.size() && res[index + dist] == 0){\\n                res[index] = res[index + dist] = i;\\n                used[i] = 0;\\n                vector<int> temp = solve(res, used, index+1);\\n                if(!temp.empty()){\\n                    return temp;\\n                }\\n                used[i] = 1;\\n                res[index] = res[index + dist] = 0;\\n            }\\n        }\\n        return {};\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> res(2*n-1, 0), used(n+1, 1);\\n        return solve(res, used, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239902,
                "title": "easy-python-solution-using-recursion",
                "content": "# Code\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        arr=[-1 for _ in range(2*n-1)]\\n        status=self.get(arr,0,0,n)\\n        return arr\\n    def get(self,arr,i,bit,n):\\n        if(i>=len(arr)):\\n            return True\\n        elif(arr[i]!=-1):\\n            return self.get(arr,i+1,bit,n)\\n        else:\\n            for j in range(n,0,-1):\\n                if((bit>>j)&1!=0 or (j!=1 and ((j+i)>=len(arr) or arr[j+i]!=-1))):continue\\n                arr[i]=j\\n                if(j!=1):\\n                    arr[i+j]=j\\n                status=self.get(arr,i+1,bit|(1<<j),n)\\n                if(status):return True\\n                arr[i]=-1\\n                if(j!=1):\\n                    arr[i+j]=-1\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        arr=[-1 for _ in range(2*n-1)]\\n        status=self.get(arr,0,0,n)\\n        return arr\\n    def get(self,arr,i,bit,n):\\n        if(i>=len(arr)):\\n            return True\\n        elif(arr[i]!=-1):\\n            return self.get(arr,i+1,bit,n)\\n        else:\\n            for j in range(n,0,-1):\\n                if((bit>>j)&1!=0 or (j!=1 and ((j+i)>=len(arr) or arr[j+i]!=-1))):continue\\n                arr[i]=j\\n                if(j!=1):\\n                    arr[i+j]=j\\n                status=self.get(arr,i+1,bit|(1<<j),n)\\n                if(status):return True\\n                arr[i]=-1\\n                if(j!=1):\\n                    arr[i+j]=-1\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200092,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {\\n        fn dfs(pos: usize, ans: &mut Vec<i32>, used: &mut Vec<bool>) -> bool {\\n            if pos == ans.len() {\\n                return true;\\n            }\\n            if ans[pos] != 0 {\\n                return dfs(pos + 1, ans, used);\\n            }\\n            for i in (1..used.len()).rev() {\\n                if used[i] {\\n                    continue;\\n                }\\n                if i != 1 && (pos + i >= ans.len() || ans[pos + i] != 0) {\\n                    continue;\\n                }\\n                ans[pos] = i as i32;\\n                if i != 1 {\\n                    ans[pos + i] = i as i32;\\n                }\\n                used[i] = true;\\n                if dfs(pos + 1, ans, used) {\\n                    return true;\\n                }\\n                ans[pos] = 0;\\n                if i != 1 {\\n                    ans[pos + i] = 0;\\n                }\\n                used[i] = false;\\n            }\\n            false\\n        }\\n\\n        let n = n as usize;\\n        let mut ans = vec![0; 2 * n - 1];\\n        let mut used = vec![false; n + 1];\\n        dfs(0, &mut ans, &mut used);\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {\\n        fn dfs(pos: usize, ans: &mut Vec<i32>, used: &mut Vec<bool>) -> bool {\\n            if pos == ans.len() {\\n                return true;\\n            }\\n            if ans[pos] != 0 {\\n                return dfs(pos + 1, ans, used);\\n            }\\n            for i in (1..used.len()).rev() {\\n                if used[i] {\\n                    continue;\\n                }\\n                if i != 1 && (pos + i >= ans.len() || ans[pos + i] != 0) {\\n                    continue;\\n                }\\n                ans[pos] = i as i32;\\n                if i != 1 {\\n                    ans[pos + i] = i as i32;\\n                }\\n                used[i] = true;\\n                if dfs(pos + 1, ans, used) {\\n                    return true;\\n                }\\n                ans[pos] = 0;\\n                if i != 1 {\\n                    ans[pos + i] = 0;\\n                }\\n                used[i] = false;\\n            }\\n            false\\n        }\\n\\n        let n = n as usize;\\n        let mut ans = vec![0; 2 * n - 1];\\n        let mut used = vec![false; n + 1];\\n        dfs(0, &mut ans, &mut used);\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2995033,
                "title": "scala",
                "content": "```Scala\\nimport scala.collection.immutable.TreeSet\\nobject Solution {\\n    def constructDistancedSequence(n: Int): Array[Int] = {\\n        def go(cur: Vector[Int], i: Int, left: TreeSet[Int]): Option[Vector[Int]] = {\\n            if (i == (2 * n - 1))\\n                Some(cur)\\n            else if (cur(i) != 0)\\n                go(cur, i + 1, left)\\n            else\\n                left.iterator.map {\\n                    case 1 =>\\n                        go(cur.updated(i, 1), i + 1, left - 1)\\n                    case x if (cur.lift(i + x).getOrElse(1) == 0) =>\\n                        go(cur.updated(i, x).updated(i + x, x), i + 1, left - x)\\n                    case _ => None\\n                }.find(_.isDefined).getOrElse(None)\\n        }\\n                \\n        go(Vector.fill(2 * n - 1)(0), 0, TreeSet[Int]()(Ordering.by(-_)) ++ (1 to n)).get.toArray\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nimport scala.collection.immutable.TreeSet\\nobject Solution {\\n    def constructDistancedSequence(n: Int): Array[Int] = {\\n        def go(cur: Vector[Int], i: Int, left: TreeSet[Int]): Option[Vector[Int]] = {\\n            if (i == (2 * n - 1))\\n                Some(cur)\\n            else if (cur(i) != 0)\\n                go(cur, i + 1, left)\\n            else\\n                left.iterator.map {\\n                    case 1 =>\\n                        go(cur.updated(i, 1), i + 1, left - 1)\\n                    case x if (cur.lift(i + x).getOrElse(1) == 0) =>\\n                        go(cur.updated(i, x).updated(i + x, x), i + 1, left - x)\\n                    case _ => None\\n                }.find(_.isDefined).getOrElse(None)\\n        }\\n                \\n        go(Vector.fill(2 * n - 1)(0), 0, TreeSet[Int]()(Ordering.by(-_)) ++ (1 to n)).get.toArray\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2988372,
                "title": "c-easy-backtracking-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;  \\n    vector<int> constructDistancedSequence(int n) {\\n        this->n = n;\\n        vector<int> res(1+(n-1)*2,-1);\\n        unordered_set<int> nums;\\n        for(int i = 1; i <= n; i++) nums.insert(i);\\n        dfs(0, res, nums);\\n        return res;\\n    }\\n\\n    bool dfs(int i, vector<int> &res, unordered_set<int> &nums){\\n        if(nums.size() == 0) return true;\\n        if(res[i]!=-1) return dfs(i+1,res,nums);\\n        for(int j=n; j>=1; j--){\\n            int dist = j==1 ? 0 : j;\\n\\n            if(nums.count(j) and (i+dist<res.size() and res[i+dist] == -1)){\\n                res[i] = res[i+dist] = j;\\n                nums.erase(j);\\n                if(dfs(i+1, res, nums)) return true;\\n                res[i] = res[i+dist] = -1;\\n                nums.insert(j);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;  \\n    vector<int> constructDistancedSequence(int n) {\\n        this->n = n;\\n        vector<int> res(1+(n-1)*2,-1);\\n        unordered_set<int> nums;\\n        for(int i = 1; i <= n; i++) nums.insert(i);\\n        dfs(0, res, nums);\\n        return res;\\n    }\\n\\n    bool dfs(int i, vector<int> &res, unordered_set<int> &nums){\\n        if(nums.size() == 0) return true;\\n        if(res[i]!=-1) return dfs(i+1,res,nums);\\n        for(int j=n; j>=1; j--){\\n            int dist = j==1 ? 0 : j;\\n\\n            if(nums.count(j) and (i+dist<res.size() and res[i+dist] == -1)){\\n                res[i] = res[i+dist] = j;\\n                nums.erase(j);\\n                if(dfs(i+1, res, nums)) return true;\\n                res[i] = res[i+dist] = -1;\\n                nums.insert(j);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932543,
                "title": "python-backtracking-clean-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        m = 2*n - 1\\n        A = [0]*m\\n        path = set()\\n        def dfs(i):\\n            if i == m:\\n                return all(A)\\n            if A[i]:\\n                return dfs(i+1)\\n            for v in range(n, 0, -1):\\n                j = i if v == 1 else i + v\\n                if v not in path and j < m and not A[j]:\\n                    A[i], A[j] = v, v\\n                    path.add(v)\\n                    if dfs(i+1): return True\\n                    A[i], A[j] = 0, 0\\n                    path.remove(v)\\n            return False\\n        if dfs(0): return A\\n        return []\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        m = 2*n - 1\\n        A = [0]*m\\n        path = set()\\n        def dfs(i):\\n            if i == m:\\n                return all(A)\\n            if A[i]:\\n                return dfs(i+1)\\n            for v in range(n, 0, -1):\\n                j = i if v == 1 else i + v\\n                if v not in path and j < m and not A[j]:\\n                    A[i], A[j] = v, v\\n                    path.add(v)\\n                    if dfs(i+1): return True\\n                    A[i], A[j] = 0, 0\\n                    path.remove(v)\\n            return False\\n        if dfs(0): return A\\n        return []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912625,
                "title": "python3-dfs-w-backtracking",
                "content": "# Intuition\\nWe start with an array of all 0s of length $$2n - 1$$. Using depth first search we place the higher number possible in the first cell in the array that is a 0. We repeat this process until we\\'ve either found a solution or there are no more possible placements, in which case we backtrack to the next possible previous move.\\n\\nThe first solution we find will have the highest possible lexicographical order as we are always inserting the highest possible number into the next available 0 slot.\\n\\n\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        def dfs(sequence):\\n            if 0 not in sequence:\\n                return sequence\\n            idx = sequence.index(0)\\n\\n            for nextNum in range(n, 0, -1):\\n                nextIdx = idx + nextNum\\n                if nextNum == 1:\\n                    nextIdx -= 1\\n                if nextNum in sequence or nextIdx >= len(sequence) or sequence[nextIdx] != 0:\\n                    continue\\n\\n                sequence[idx], sequence[nextIdx] = nextNum, nextNum\\n                res = dfs(sequence)\\n                if res != -1:\\n                    return res\\n                sequence[idx], sequence[nextIdx] = 0, 0\\n\\n            return -1\\n\\n        return dfs([0] * (2 * n - 1))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        def dfs(sequence):\\n            if 0 not in sequence:\\n                return sequence\\n            idx = sequence.index(0)\\n\\n            for nextNum in range(n, 0, -1):\\n                nextIdx = idx + nextNum\\n                if nextNum == 1:\\n                    nextIdx -= 1\\n                if nextNum in sequence or nextIdx >= len(sequence) or sequence[nextIdx] != 0:\\n                    continue\\n\\n                sequence[idx], sequence[nextIdx] = nextNum, nextNum\\n                res = dfs(sequence)\\n                if res != -1:\\n                    return res\\n                sequence[idx], sequence[nextIdx] = 0, 0\\n\\n            return -1\\n\\n        return dfs([0] * (2 * n - 1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740277,
                "title": "c-backtracking-with-bitmask-with-explanation",
                "content": "# First Thought:\\nInsert the greatest number at the best index in ```ans``` (*resultant vector in the code*). Thus the path reaching the end of recursion/bactrack will be my answer. However this will give wrong answer for **n = 5**.\\n**Here, emphasis is on the element.**\\n\\n# Improvised:\\nInsert the best possible greatest number at an index in ```ans``` (*resultant vector in the code*). This will be done in decending order so that best possible greatest number acquires the earliest index in ```ans```.\\n**Here, emphasis is on the index.**\\n\\nBitmasking is to keep track to the elements that have been previously used.\\n\\n```\\n#define vi vector<int> \\n\\nclass Solution {\\npublic:\\n    bool helper (int& mask, int &n, vi &ans, int i){\\n        if (i == ans.size()) return 1;   // ans is completely filled and solution has been found\\n        \\n        if (ans[i]) return helper (mask, n, ans, i+1);   // ith index is already acquired\\n        \\n        for (int j = n; j > 0; j--){\\n            int val = (mask & (1 << j));   // checking whether we can take j number or not.\\n            if (val) continue;\\n            if (j != 1 && (j+i >= ans.size() || ans[j+i])) continue;\\n            \\n            mask = (mask | (1 << j));\\n            ans[i] = j;            \\n            if (j != 1) ans[i+j] = j;\\n            \\n            if (helper (mask,n,ans,i+1)) return 1;            \\n\\t\\t\\t\\n\\t\\t\\t// backtrack\\t\\t\\t\\n            ans[i] = 0;            \\n            if (j != 1) ans[i+j] = 0;            \\n            mask = (mask ^ (1<<j));\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vi ans (2*n-1,0);\\n        int mask = 0;\\n        helper (mask, n, ans, 0);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```ans```\n```ans```\n```ans```\n```\\n#define vi vector<int> \\n\\nclass Solution {\\npublic:\\n    bool helper (int& mask, int &n, vi &ans, int i){\\n        if (i == ans.size()) return 1;   // ans is completely filled and solution has been found\\n        \\n        if (ans[i]) return helper (mask, n, ans, i+1);   // ith index is already acquired\\n        \\n        for (int j = n; j > 0; j--){\\n            int val = (mask & (1 << j));   // checking whether we can take j number or not.\\n            if (val) continue;\\n            if (j != 1 && (j+i >= ans.size() || ans[j+i])) continue;\\n            \\n            mask = (mask | (1 << j));\\n            ans[i] = j;            \\n            if (j != 1) ans[i+j] = j;\\n            \\n            if (helper (mask,n,ans,i+1)) return 1;            \\n\\t\\t\\t\\n\\t\\t\\t// backtrack\\t\\t\\t\\n            ans[i] = 0;            \\n            if (j != 1) ans[i+j] = 0;            \\n            mask = (mask ^ (1<<j));\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vi ans (2*n-1,0);\\n        int mask = 0;\\n        helper (mask, n, ans, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717913,
                "title": "python-backtracking-solution-faster-than-91",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        ans, visited = [0] * (2 * n - 1), [False] * (n + 1)\\n        \\n        def backtrack(idx: int) -> bool:\\n            nonlocal ans, visited, n\\n            if idx == len(ans):\\n                return True\\n            if ans[idx] != 0:\\n                return backtrack(idx + 1)\\n            else:\\n                for num in range(n, 0, -1):\\n                    if visited[num]:\\n                        continue\\n                    visited[num], ans[idx] = True, num\\n                    if num == 1:\\n                        if backtrack(idx + 1):\\n                            return True\\n                    elif idx + num < len(ans) and ans[idx + num] == 0:\\n                        ans[num + idx] = num\\n                        if backtrack(idx + 1): \\n                            return True\\n                        ans[idx + num] = 0\\n                    ans[idx], visited[num] = 0, False\\n            return False\\n        \\n        backtrack(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        ans, visited = [0] * (2 * n - 1), [False] * (n + 1)\\n        \\n        def backtrack(idx: int) -> bool:\\n            nonlocal ans, visited, n\\n            if idx == len(ans):\\n                return True\\n            if ans[idx] != 0:\\n                return backtrack(idx + 1)\\n            else:\\n                for num in range(n, 0, -1):\\n                    if visited[num]:\\n                        continue\\n                    visited[num], ans[idx] = True, num\\n                    if num == 1:\\n                        if backtrack(idx + 1):\\n                            return True\\n                    elif idx + num < len(ans) and ans[idx + num] == 0:\\n                        ans[num + idx] = num\\n                        if backtrack(idx + 1): \\n                            return True\\n                        ans[idx + num] = 0\\n                    ans[idx], visited[num] = 0, False\\n            return False\\n        \\n        backtrack(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675062,
                "title": "c-original-code-faster-than-100-submissions",
                "content": "There are three possible ways:\\n\\n1. For each value, check for possible placement in resultant array. (This will cause time limit exceeded)\\n2. For each position, check for possible values. (accepted)\\n3. Greedy, array approach. (Can\\'t think of such logic yet, although it seems possible)\\n\\nFor approach one, why it will cause TLE:\\n* For each value V in the range [2, n], the result array\\'s length is 2 * n - 1, so no. of V\\'s possible placement in array is (len - V). The number of recursive level grows exponentially.\\n* Even if you apply a hash map to preserve previously travelled state, it is still too time-consuming.\\n\\nFor approach two, there is a greedy optimization there : Try out the maximum possible value at position i first. \\n* When you can assign all numbers into the array for the first time,\\n```cpp\\nif (i >= len) {\\n    // check whether all the numbers have been assigned.\\n    return avis();\\n}\\n```\\n* it is already the final answer. Because at every position i, you always select max valid value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> cur;\\n    bool vis[21];\\n    int len;\\n    int N;\\n    \\n    bool avis() {\\n        for (int v = 1; v <= N; v++) {\\n            if (!vis[v])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool opt(int i) {\\n        if (i >= len) {\\n            return avis();\\n        }\\n        if (i == len - 1) {\\n            // well, only 1 is possible here\\n            if (avis())\\n                return true;\\n            if (vis[1])\\n                return false;\\n            cur[i] = 1;\\n            vis[1] = true;\\n            if (avis()) {\\n                return true;\\n            }\\n            cur[i] = 0;\\n            vis[1] = false;\\n            return false;\\n        }\\n        if (cur[i] != 0)\\n            return opt(i + 1);\\n        for (int v = min(N, len - i - 1); v >= 2; v--) {\\n            if (!vis[v] && cur[i + v] == 0) {\\n                vis[v] = true;\\n                cur[i] = v;\\n                cur[i + v] = v;\\n                if (opt(i + 1))\\n                    return true;\\n                vis[v] = false;\\n                cur[i] = 0;\\n                cur[i + v] = 0;\\n            }\\n        }\\n        if (!vis[1]) {\\n            vis[1] = true;\\n            cur[i] = 1;\\n            if (opt(i + 1))\\n                return true;\\n            vis[1] = false;\\n            cur[i] = 0;\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        len = 2 * n - 1;\\n        cur = vector<int>(len, 0);\\n        N = n;\\n        opt(0);\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nif (i >= len) {\\n    // check whether all the numbers have been assigned.\\n    return avis();\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> cur;\\n    bool vis[21];\\n    int len;\\n    int N;\\n    \\n    bool avis() {\\n        for (int v = 1; v <= N; v++) {\\n            if (!vis[v])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool opt(int i) {\\n        if (i >= len) {\\n            return avis();\\n        }\\n        if (i == len - 1) {\\n            // well, only 1 is possible here\\n            if (avis())\\n                return true;\\n            if (vis[1])\\n                return false;\\n            cur[i] = 1;\\n            vis[1] = true;\\n            if (avis()) {\\n                return true;\\n            }\\n            cur[i] = 0;\\n            vis[1] = false;\\n            return false;\\n        }\\n        if (cur[i] != 0)\\n            return opt(i + 1);\\n        for (int v = min(N, len - i - 1); v >= 2; v--) {\\n            if (!vis[v] && cur[i + v] == 0) {\\n                vis[v] = true;\\n                cur[i] = v;\\n                cur[i + v] = v;\\n                if (opt(i + 1))\\n                    return true;\\n                vis[v] = false;\\n                cur[i] = 0;\\n                cur[i + v] = 0;\\n            }\\n        }\\n        if (!vis[1]) {\\n            vis[1] = true;\\n            cur[i] = 1;\\n            if (opt(i + 1))\\n                return true;\\n            vis[1] = false;\\n            cur[i] = 0;\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        len = 2 * n - 1;\\n        cur = vector<int>(len, 0);\\n        N = n;\\n        opt(0);\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608336,
                "title": "python-dfs-backtracking",
                "content": "\\n```\\ndef constructDistancedSequence(self, n: int) -> List[int]:\\n        sz=2*n-1\\n        res=[0 for i in range(sz)]\\n        used=[0 for i in range(sz+1)]\\n        def dfs(pos):\\n            nonlocal sz, res, used\\n            if pos==sz:\\n                return True\\n            if res[pos]>0:\\n                return dfs(pos+1)\\n            for d in range(n,0,-1):\\n                if used[d]:\\n                    continue\\n                if d>1 and (pos+d>=sz or res[pos+d]):\\n                    continue\\n                used[d]=1\\n                res[pos]=d\\n                if d>1:\\n                    res[pos+d]=d\\n                if dfs(pos+1):\\n                    return True\\n                used[d]=0\\n                res[pos]=0\\n                if d>1:\\n                    res[pos+d]=0\\n            return False\\n        dfs(0)\\n        return res",
                "solutionTags": [],
                "code": "\\n```\\ndef constructDistancedSequence(self, n: int) -> List[int]:\\n        sz=2*n-1\\n        res=[0 for i in range(sz)]\\n        used=[0 for i in range(sz+1)]\\n        def dfs(pos):\\n            nonlocal sz, res, used\\n            if pos==sz:\\n                return True\\n            if res[pos]>0:\\n                return dfs(pos+1)\\n            for d in range(n,0,-1):\\n                if used[d]:\\n                    continue\\n                if d>1 and (pos+d>=sz or res[pos+d]):\\n                    continue\\n                used[d]=1\\n                res[pos]=d\\n                if d>1:\\n                    res[pos+d]=d\\n                if dfs(pos+1):\\n                    return True\\n                used[d]=0\\n                res[pos]=0\\n                if d>1:\\n                    res[pos+d]=0\\n            return False\\n        dfs(0)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2524093,
                "title": "c-backtracking-visited-array-clean-code",
                "content": "\\n```\\n   vector<bool> visited;\\n    bool func(vector<int> &nums  , int i )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return true;\\n        }\\n        \\n        // visited is of size of n , checking the \\n        \\n        if(nums[i]>0)\\n        {\\n            return func(nums , i+1 );\\n        }\\n        \\n            for(int j=visited.size()-1;j>=1;j--)\\n            {\\n                if(visited[j]==true)\\n                {\\n                    continue;\\n                }\\n                \\n                if(j!=1 && ((i+j)>=nums.size() || nums[i+j] ) )\\n                {\\n                    continue;\\n                }\\n                \\n                nums[i]=j;\\n                \\n                visited[j]=true;\\n                \\n                if(j!=1)\\n                {\\n                    nums[i+j]=j;\\n                }\\n                \\n                if(func(nums  , i+1))\\n                {\\n                    return true;\\n                }\\n                \\n                visited[j]=false;\\n                \\n                nums[i]=0;\\n                \\n                if(j!=1)\\n                {\\n                    nums[i+j]=0;\\n                }\\n            }\\n        \\n        \\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        \\n        visited.resize(n+1 , false);\\n        \\n        vector<int> nums(2*n-1 , 0);\\n        \\n        int m=2*n-1;\\n        \\n        func(nums , 0 );\\n        \\n        return nums;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n   vector<bool> visited;\\n    bool func(vector<int> &nums  , int i )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return true;\\n        }\\n        \\n        // visited is of size of n , checking the \\n        \\n        if(nums[i]>0)\\n        {\\n            return func(nums , i+1 );\\n        }\\n        \\n            for(int j=visited.size()-1;j>=1;j--)\\n            {\\n                if(visited[j]==true)\\n                {\\n                    continue;\\n                }\\n                \\n                if(j!=1 && ((i+j)>=nums.size() || nums[i+j] ) )\\n                {\\n                    continue;\\n                }\\n                \\n                nums[i]=j;\\n                \\n                visited[j]=true;\\n                \\n                if(j!=1)\\n                {\\n                    nums[i+j]=j;\\n                }\\n                \\n                if(func(nums  , i+1))\\n                {\\n                    return true;\\n                }\\n                \\n                visited[j]=false;\\n                \\n                nums[i]=0;\\n                \\n                if(j!=1)\\n                {\\n                    nums[i+j]=0;\\n                }\\n            }\\n        \\n        \\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        \\n        visited.resize(n+1 , false);\\n        \\n        vector<int> nums(2*n-1 , 0);\\n        \\n        int m=2*n-1;\\n        \\n        func(nums , 0 );\\n        \\n        return nums;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2370263,
                "title": "c-backtracking-hash-map",
                "content": "```\\nunordered_set<int> s;\\nvector<int> res;\\nint sz;\\nint n;\\nbool sol(int i=0) {\\n\\tif(i>=sz) return true;\\n\\tif(res[i]) return sol(i+1);\\n\\tfor(int j=n; j>=1; j--) {\\n\\t\\tif(s.find(j) != s.end()) continue;\\n\\t\\tif(j==1) {\\n\\t\\t\\tres[i] = j;\\n\\t\\t\\ts.insert(j);\\n\\t\\t\\tif(sol(i+1)) return true;\\n\\t\\t\\tres[i] = 0;\\n\\t\\t\\ts.erase(j);\\n\\t\\t} else if(i+j < sz && !res[i+j]){\\n\\t\\t\\tres[i] = j;\\n\\t\\t\\tres[i+j] = j;\\n\\t\\t\\ts.insert(j);\\n\\t\\t\\tif(sol(i+1)) return true;\\n\\t\\t\\tres[i] = 0;\\n\\t\\t\\tres[i+j] = 0;\\n\\t\\t\\ts.erase(j);\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\nvector<int> constructDistancedSequence(int m) {\\n\\tn = m;\\n\\tsz = 2*n - 1;\\n\\tres.resize(sz, 0);\\n\\tsol();\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nunordered_set<int> s;\\nvector<int> res;\\nint sz;\\nint n;\\nbool sol(int i=0) {\\n\\tif(i>=sz) return true;\\n\\tif(res[i]) return sol(i+1);\\n\\tfor(int j=n; j>=1; j--) {\\n\\t\\tif(s.find(j) != s.end()) continue;\\n\\t\\tif(j==1) {\\n\\t\\t\\tres[i] = j;\\n\\t\\t\\ts.insert(j);\\n\\t\\t\\tif(sol(i+1)) return true;\\n\\t\\t\\tres[i] = 0;\\n\\t\\t\\ts.erase(j);\\n\\t\\t} else if(i+j < sz && !res[i+j]){\\n\\t\\t\\tres[i] = j;\\n\\t\\t\\tres[i+j] = j;\\n\\t\\t\\ts.insert(j);\\n\\t\\t\\tif(sol(i+1)) return true;\\n\\t\\t\\tres[i] = 0;\\n\\t\\t\\tres[i+j] = 0;\\n\\t\\t\\ts.erase(j);\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\nvector<int> constructDistancedSequence(int m) {\\n\\tn = m;\\n\\tsz = 2*n - 1;\\n\\tres.resize(sz, 0);\\n\\tsol();\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314892,
                "title": "c-backtracking-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> seen;\\n    bool dfs(vector<int>& res,int idx)\\n    {\\n        if(idx>=res.size())\\n            return true;\\n        if(res[idx]>0)\\n            return dfs(res,idx+1);\\n        for(int i=seen.size()-1;i>=1;i--)\\n        {\\n            if(seen[i])\\n                continue;\\n            if(i!=1&&(i+idx>=res.size()||res[i+idx]))\\n                continue;\\n            seen[i]=1;\\n            res[idx]=i;\\n            if(i!=1)\\n                res[i+idx]=i;\\n            if(dfs(res,idx+1))\\n                return true;\\n\\t\\t\\tseen[i]=0;           //backtrack\\n            res[idx]=0;\\n            if(i!=1)\\n                res[i+idx]=0;\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n)\\n    {\\n        seen.resize(n+1,0);\\n        vector<int> res(2*n-1,0);\\n        dfs(res,0);\\n        return res;\\n        \\n    }\\n};\\n//if you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> seen;\\n    bool dfs(vector<int>& res,int idx)\\n    {\\n        if(idx>=res.size())\\n            return true;\\n        if(res[idx]>0)\\n            return dfs(res,idx+1);\\n        for(int i=seen.size()-1;i>=1;i--)\\n        {\\n            if(seen[i])\\n                continue;\\n            if(i!=1&&(i+idx>=res.size()||res[i+idx]))\\n                continue;\\n            seen[i]=1;\\n            res[idx]=i;\\n            if(i!=1)\\n                res[i+idx]=i;\\n            if(dfs(res,idx+1))\\n                return true;\\n\\t\\t\\tseen[i]=0;           //backtrack\\n            res[idx]=0;\\n            if(i!=1)\\n                res[i+idx]=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2177923,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool helper(vector<int> &res,unordered_set<int> &s,int i,int n){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        if(res[i]!=-1){\\n            return helper(res,s,i+1,n);\\n        }\\n        for(int j = n; j >= 1; j-- ){\\n            int distance;\\n            if(j > 1){\\n                distance = j;\\n            }\\n            else{\\n                distance = 0;   // if j == 1 distance is 0 as one is to be inserted only once\\n            }\\n            if((i+distance < res.size() and res[i+distance] == -1) and s.count(j)){\\n                res[i] = j;\\n                res[i+distance] = j;\\n                s.erase(j);\\n                if(helper(res,s,i+1,n)){\\n                    return true;\\n                }\\n                res[i] = -1;\\n                res[i+distance] = -1;\\n                s.insert(j);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        int len = 2*(n-1)+1;\\n        vector<int> res(len,-1);\\n        unordered_set<int> s;\\n        for(int i = 1;i <= n;i++){\\n            s.insert(i);\\n        }\\n        helper(res,s,0,n);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n   \\n    bool helper(vector<int> &res,unordered_set<int> &s,int i,int n){\\n        if(s.size()==0){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2115674,
                "title": "python-greedy-backtracking-approach",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        m = 1+ 2*(n-1)\\n        ans=[\\'*\\']*m\\n        left_nodes = set([i for i in range(1, n + 1)])\\n        def func(index):\\n            if(index>=m):\\n                return True\\n            if(ans[index]!=\\'*\\'):\\n                return func(index+1)\\n            for _ in range(n,0,-1):\\n                if(_ in left_nodes):\\n                    if(_ == 1 ):\\n                        ans[index] = _\\n                        left_nodes.remove(_)\\n                        if(func(index+1)):\\n                            return True\\n                        else:\\n                            left_nodes.add(_)\\n                            ans[index]=\\'*\\'\\n                    else:\\n                        next_index = index + _\\n                        if(next_index<m and ans[next_index] == \\'*\\'):\\n                            ans[index] = _\\n                            ans[next_index]= _\\n                            left_nodes.remove(_)\\n                            if(func(index+1)):\\n                                return True\\n                            else:\\n                                left_nodes.add(_)\\n                                ans[index] = \\'*\\'\\n                                ans[next_index]= \\'*\\'\\n            return False\\n                        \\n        func(0)\\n        return ans\\n    \\n    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        m = 1+ 2*(n-1)\\n        ans=[\\'*\\']*m\\n        left_nodes = set([i for i in range(1, n + 1)])\\n        def func(index):\\n            if(index>=m):\\n                return True\\n            if(ans[index]!=\\'*\\'):\\n                return func(index+1)\\n            for _ in range(n,0,-1):\\n                if(_ in left_nodes):\\n                    if(_ == 1 ):\\n                        ans[index] = _\\n                        left_nodes.remove(_)\\n                        if(func(index+1)):\\n                            return True\\n                        else:\\n                            left_nodes.add(_)\\n                            ans[index]=\\'*\\'\\n                    else:\\n                        next_index = index + _\\n                        if(next_index<m and ans[next_index] == \\'*\\'):\\n                            ans[index] = _\\n                            ans[next_index]= _\\n                            left_nodes.remove(_)\\n                            if(func(index+1)):\\n                                return True\\n                            else:\\n                                left_nodes.add(_)\\n                                ans[index] = \\'*\\'\\n                                ans[next_index]= \\'*\\'\\n            return False\\n                        \\n        func(0)\\n        return ans\\n    \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114162,
                "title": "c-backtracking-greedy-filling-of-numbers",
                "content": "**Solution -1 (Brute Force - TLE)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans ;\\n    int sz ;\\n    \\n    void solve(int pos , int n , vector<int>&temp){\\n        if(pos > n){\\n            if(ans < temp) ans = temp ; // takes O(N) \\n            return ;\\n        }\\n        \\n        for(int i = 0 ; i < sz ; ++i ){\\n            if(temp[i]) continue ;\\n            if(pos == 1){\\n                temp[i] = pos ;\\n                solve(pos+1,n,temp);\\n                temp[i] = 0 ;\\n            } else {\\n                if(i + pos < sz and !temp[i + pos]){\\n                    temp[i] = pos ;\\n                    temp[i+pos] = pos ;\\n                    solve(pos + 1,n,temp) ;\\n                    temp[i] = 0 ;\\n                    temp[i+pos] = 0 ;\\n                }\\n            }\\n        }\\n        return ;\\n        \\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        sz = 2*n - 1 ;\\n        ans.resize(sz,0);\\n        vector<int>temp(sz,0) ;\\n        solve(1,n,temp) ;\\n        return ans ;\\n    }\\n};\\n```\\n\\n**Solution-2 (Greedily Fill Numbers From Largest To Smallest - AC)**\\nReference- [This Post](https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/discuss/1008913/C%2B%2B-Backtracking)\\n```\\nclass Solution {\\npublic:\\n    int sz ;\\n    vector<int> ans , numberTaken ;\\n    \\n    bool solve(int pos , int n){\\n        if(pos >= sz) return true ; //if all positions are filled the formed array is valid \\n        if(ans[pos]) return solve(pos + 1 , n) ; //if current space is occupied move to next position \\n        \\n        //Greedy nature , start filling from largest number first \\n        for(int number =  n ; number >= 1 ; --number ){\\n            if(numberTaken[number]) continue ;\\n            ans[pos] = number ;\\n            numberTaken[number] = 1 ;\\n            if(number == 1){\\n                if(solve(pos + 1, n)) return true ;\\n            } else {\\n                if(pos + number < sz and !ans[pos + number]){\\n                    ans[pos + number] = number ;\\n                    if(solve(pos + 1 ,n)) return true ;\\n                    ans[pos + number] = 0 ;\\n                }\\n            }\\n            ans[pos] = 0 ;\\n            numberTaken[number] = 0 ;\\n        }\\n        return false ;\\n        \\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        sz = 2*n - 1 ;\\n        ans.resize(sz,0) , numberTaken.resize(n + 1,0) ;\\n        solve(0,n) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans ;\\n    int sz ;\\n    \\n    void solve(int pos , int n , vector<int>&temp){\\n        if(pos > n){\\n            if(ans < temp) ans = temp ; // takes O(N) \\n            return ;\\n        }\\n        \\n        for(int i = 0 ; i < sz ; ++i ){\\n            if(temp[i]) continue ;\\n            if(pos == 1){\\n                temp[i] = pos ;\\n                solve(pos+1,n,temp);\\n                temp[i] = 0 ;\\n            } else {\\n                if(i + pos < sz and !temp[i + pos]){\\n                    temp[i] = pos ;\\n                    temp[i+pos] = pos ;\\n                    solve(pos + 1,n,temp) ;\\n                    temp[i] = 0 ;\\n                    temp[i+pos] = 0 ;\\n                }\\n            }\\n        }\\n        return ;\\n        \\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        sz = 2*n - 1 ;\\n        ans.resize(sz,0);\\n        vector<int>temp(sz,0) ;\\n        solve(1,n,temp) ;\\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sz ;\\n    vector<int> ans , numberTaken ;\\n    \\n    bool solve(int pos , int n){\\n        if(pos >= sz) return true ; //if all positions are filled the formed array is valid \\n        if(ans[pos]) return solve(pos + 1 , n) ; //if current space is occupied move to next position \\n        \\n        //Greedy nature , start filling from largest number first \\n        for(int number =  n ; number >= 1 ; --number ){\\n            if(numberTaken[number]) continue ;\\n            ans[pos] = number ;\\n            numberTaken[number] = 1 ;\\n            if(number == 1){\\n                if(solve(pos + 1, n)) return true ;\\n            } else {\\n                if(pos + number < sz and !ans[pos + number]){\\n                    ans[pos + number] = number ;\\n                    if(solve(pos + 1 ,n)) return true ;\\n                    ans[pos + number] = 0 ;\\n                }\\n            }\\n            ans[pos] = 0 ;\\n            numberTaken[number] = 0 ;\\n        }\\n        return false ;\\n        \\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        sz = 2*n - 1 ;\\n        ans.resize(sz,0) , numberTaken.resize(n + 1,0) ;\\n        solve(0,n) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867556,
                "title": "easy-backtracking-intution",
                "content": "class Solution {\\npublic:\\n    \\n    map<int,int> visit;\\n    \\n  \\n    \\n    int got = 0;\\n    \\n    vector<int> fun(vector<int> v,int n,int i,int ind,int placed)\\n    {\\n        //cout<<placed<<endl;\\n        \\n       /* for(int i =0;i<v.size();i++)\\n        {\\n            cout<<v[i]<<\" \";\\n        }*/\\n        \\n        \\n        \\n        if(placed == n)\\n        {\\n            got = 1; // finding the answer this variable tells if answer is found or not\\n            return v;\\n        }\\n        \\n        \\n        while(v[ind] > 0)\\n        {\\n            ind++;\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(int j = n; j >= 1;j--)\\n        {\\n            //cout<<j<<endl;\\n            if(j == 1)\\n            {\\n                if(visit[j] == 0 and v[ind] == -1)\\n                {\\n                    v[ind] = j;\\n                    \\n                    visit[j] = 1;\\n                    \\n                    ans = fun(v,n,i,ind+1,placed+1);\\n                    \\n                    if(got == 1)\\n                    {\\n                        return ans;\\n                    }\\n                    \\n                    v[ind] = -1;\\n                    \\n                    visit[j] = 0;\\n                }\\n            }\\n            else\\n            {\\n                if(visit[j] == 0 and (ind + j < 2*n - 1) and (v[ind] == -1) and (v[ind+j] == -1))\\n                {\\n                    v[ind] = j;\\n\\n                    v[ind+j] = j;\\n\\n                    visit[j] = 1;\\n\\n                    ans = fun(v,n,i,ind+1,placed+1);\\n                    \\n                    if(got)\\n                    {\\n                        return ans;\\n                    }\\n                    \\n                    // backtracking reseting all the parametres\\n                    \\n                    visit[j] = 0;\\n\\n                    v[ind] = -1;\\n\\n                    v[ind+j] = -1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        \\n        vector<int> v(2*n - 1);\\n        \\n        for(int i =0;i < 2*n - 1; i++)\\n        {\\n            v[i] = -1;\\n        }\\n        \\n        vector<int> answer = fun(v,n,n,0,0);\\n        \\n        return answer;\\n    }\\n};",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    map<int,int> visit;\\n    \\n  \\n    \\n    int got = 0;\\n    \\n    vector<int> fun(vector<int> v,int n,int i,int ind,int placed)\\n    {\\n        //cout<<placed<<endl;\\n        \\n       /* for(int i =0;i<v.size();i++)\\n        {\\n            cout<<v[i]<<\" \";\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1816666,
                "title": "what-s-space-and-time-complexity-of-all-the-backtracking-solutions-here",
                "content": "What\\'s space and time complexity of all the backtracking solutions here?\\nO(n!)",
                "solutionTags": [],
                "code": "What\\'s space and time complexity of all the backtracking solutions here?\\nO(n!)",
                "codeTag": "Unknown"
            },
            {
                "id": 1708951,
                "title": "c-3ms-backtracking-greedy",
                "content": "Runtime: 3 ms, faster than 43.90% of C++ online submissions for Construct the Lexicographically Largest Valid Sequence.\\nMemory Usage: 6.2 MB, less than 57.93% of C++ online submissions for Construct the Lexicographically Largest Valid Sequence.\\n```\\nclass Solution {\\npublic:\\n  vector<int>s, nums;\\n  bool flag;\\n  \\n  void dfs(int n){\\n    if(flag) return;\\n                  \\n    flag = true;\\n    for(int i = 1; i != nums.size(); i++)\\n      if(nums[i] == 0) {flag = false; break;}\\n    \\n    if(flag) return;              \\n                  \\n    int id = 1;\\n    while(s[id]) id++; \\n      \\n    for(int j = nums.size() - 2; j ;j--)\\n      if(nums[j] == 0 && (j == 1 || (id+j < s.size() && s[id+j] == 0))){\\n        if(j == 1) nums[j] = s[id] = j;\\n        else nums[j] = s[id] = s[id+j] = j;\\n        \\n        dfs(j);\\n        if(flag) return;\\n        \\n        if(j == 1) nums[j] = s[id] = 0;\\n        else nums[j] = s[id] = s[id+j] = 0;  \\n      }     \\n  }\\n  \\n  vector<int> constructDistancedSequence(int n) {\\n    if(n == 1) return {1};\\n    s.resize(n*2-1, 0), nums.resize(n+1, 0);\\n    nums.back() = 1;\\n    s[0] = s[n] = n;\\n    flag = false;\\n    dfs(n);\\n    return s;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int>s, nums;\\n  bool flag;\\n  \\n  void dfs(int n){\\n    if(flag) return;\\n                  \\n    flag = true;\\n    for(int i = 1; i != nums.size(); i++)\\n      if(nums[i] == 0) {flag = false; break;}\\n    \\n    if(flag) return;              \\n                  \\n    int id = 1;\\n    while(s[id]) id++; \\n      \\n    for(int j = nums.size() - 2; j ;j--)\\n      if(nums[j] == 0 && (j == 1 || (id+j < s.size() && s[id+j] == 0))){\\n        if(j == 1) nums[j] = s[id] = j;\\n        else nums[j] = s[id] = s[id+j] = j;\\n        \\n        dfs(j);\\n        if(flag) return;\\n        \\n        if(j == 1) nums[j] = s[id] = 0;\\n        else nums[j] = s[id] = s[id+j] = 0;  \\n      }     \\n  }\\n  \\n  vector<int> constructDistancedSequence(int n) {\\n    if(n == 1) return {1};\\n    s.resize(n*2-1, 0), nums.resize(n+1, 0);\\n    nums.back() = 1;\\n    s[0] = s[n] = n;\\n    flag = false;\\n    dfs(n);\\n    return s;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690996,
                "title": "c-backtracking-solution-beats-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool backtrack(vector<int>&curr,vector<bool>&table,int &n,int index){\\n        if(index==curr.size()){\\n            return true;\\n        } else if(curr[index]!=0){\\n            return backtrack(curr,table,n,index+1);\\n        } else {\\n            for(int i=n;i>=1;i--){\\n                if(!table[i]){\\n                    table[i]=true;\\n                    curr[index]=i;\\n                    if(i==1){\\n                        if(backtrack(curr,table,n,index+1)){\\n                            return true;\\n                        }\\n                    } else {\\n                        if(index+i<2*n-1){\\n                            if(curr[index+i]==0){\\n                                curr[index+i]=i;\\n                                if(backtrack(curr,table,n,index+1)){\\n                                    return true;\\n                                }\\n                                curr[index+i]=0;\\n                            }\\n                        }\\n                    }\\n                    curr[index]=0;\\n                    table[i]=false;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<bool>table(n+1,false);\\n        vector<int>curr(2*n-1,0);\\n        backtrack(curr,table,n,0);\\n        return curr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\nprivate:\\n    bool backtrack(vector<int>&curr,vector<bool>&table,int &n,int index){\\n        if(index==curr.size()){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1685181,
                "title": "construct-the-lexicographically-largest-valid-sequence",
                "content": "The main idea is to check which maximum value we can put at the current index, we put it and then call recursion for the next index. If it returns true then we have got the answer. Else we will backtrack and set other large value on current index and do the same thing.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool recurse(int index, vector<bool> &visited, vector<int> &arr, int &n, int left)\\n    {\\n        if(left == 0)\\n            return true;\\n        if(arr[index] != -1)\\n            return recurse(index + 1, visited, arr, n, left);\\n        for(int i=n;i>=1;i--)\\n        {\\n            if(visited[i])\\n                continue;\\n            if(i == 1)\\n            {\\n                arr[index] = 1;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-1))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                visited[i] = false;\\n            }\\n            else\\n            {\\n                if(index + i >= arr.size() || arr[index+i] != -1)\\n                    continue;\\n                arr[index] = i;\\n                arr[index+i] = i;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-2))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                arr[index+i] = -1;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        vector<int> arr(2*n-1, -1);        \\n        vector<bool> visited(n+1, false);\\n        visited[0] = true;\\n        recurse(0, visited, arr, n, 2*n-1);\\n        return arr;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool recurse(int index, vector<bool> &visited, vector<int> &arr, int &n, int left)\\n    {\\n        if(left == 0)\\n            return true;\\n        if(arr[index] != -1)\\n            return recurse(index + 1, visited, arr, n, left);\\n        for(int i=n;i>=1;i--)\\n        {\\n            if(visited[i])\\n                continue;\\n            if(i == 1)\\n            {\\n                arr[index] = 1;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-1))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                visited[i] = false;\\n            }\\n            else\\n            {\\n                if(index + i >= arr.size() || arr[index+i] != -1)\\n                    continue;\\n                arr[index] = i;\\n                arr[index+i] = i;\\n                visited[i] = true;\\n                if(recurse(index + 1, visited, arr, n, left-2))\\n                {\\n                    return true;   \\n                }\\n                arr[index] = -1;\\n                arr[index+i] = -1;\\n                visited[i] = false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        vector<int> arr(2*n-1, -1);        \\n        vector<bool> visited(n+1, false);\\n        visited[0] = true;\\n        recurse(0, visited, arr, n, 2*n-1);\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656063,
                "title": "two-simple-python-solutions",
                "content": "```\\nclass Solution(object):\\n    def constructDistancedSequence(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        self.n = n\\n        self.res = [0] * (1 + 2*(n-1)) \\n        self.len = len(self.res)\\n        self.arrange(0)\\n        return self.res\\n        \\n    def arrange(self, idx):\\n        if idx == self.len:\\n            return True\\n        \\n        if self.res[idx] > 0:\\n            return self.arrange(idx+1)\\n        \\n        for ix in range(self.n, 0, -1):\\n            if ix not in self.res:\\n                if ix == 1 or (idx+ix < self.len and self.res[idx+ix] == 0):\\n                    self.res[idx] = ix\\n                    if ix > 1:\\n                        self.res[ix+idx] = ix \\n                    if self.arrange(idx+1):\\n                        return True\\n                    self.res[idx] = 0\\n                    if ix > 1:\\n                        self.res[ix+idx] = 0\\n        return False\\n\\n//////////////////////////////////////////////////////////////////////////////////\\n\\nclass Solution(object):\\n    def constructDistancedSequence(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0] * (1 + 2*(n-1))\\n        self.lists = []\\n        self.len = len(res)\\n        self.arrange(n, res, 0)\\n        return max(self.lists)\\n        \\n    def arrange(self, n, res, idx):\\n        if n == 1:\\n            res[idx] = 1\\n            self.lists.append(copy.copy(res))\\n            res[idx] = 0\\n            return True\\n\\n        if idx >= self.len-n:\\n            return False\\n        \\n        for ix in range(idx, self.len-n):\\n            if res[ix] == 0 and res[ix+n] == 0:\\n                res[ix], res[ix+n] = n, n\\n                idxn = res.index(0)\\n                if self.arrange(n-1, res, idxn) and len(self.lists) >= self.len*self.len*14:\\n                    return True\\n                res[ix], res[ix+n] = 0, 0\\n        return False\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def constructDistancedSequence(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        self.n = n\\n        self.res = [0] * (1 + 2*(n-1)) \\n        self.len = len(self.res)\\n        self.arrange(0)\\n        return self.res\\n        \\n    def arrange(self, idx):\\n        if idx == self.len:\\n            return True\\n        \\n        if self.res[idx] > 0:\\n            return self.arrange(idx+1)\\n        \\n        for ix in range(self.n, 0, -1):\\n            if ix not in self.res:\\n                if ix == 1 or (idx+ix < self.len and self.res[idx+ix] == 0):\\n                    self.res[idx] = ix\\n                    if ix > 1:\\n                        self.res[ix+idx] = ix \\n                    if self.arrange(idx+1):\\n                        return True\\n                    self.res[idx] = 0\\n                    if ix > 1:\\n                        self.res[ix+idx] = 0\\n        return False\\n\\n//////////////////////////////////////////////////////////////////////////////////\\n\\nclass Solution(object):\\n    def constructDistancedSequence(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0] * (1 + 2*(n-1))\\n        self.lists = []\\n        self.len = len(res)\\n        self.arrange(n, res, 0)\\n        return max(self.lists)\\n        \\n    def arrange(self, n, res, idx):\\n        if n == 1:\\n            res[idx] = 1\\n            self.lists.append(copy.copy(res))\\n            res[idx] = 0\\n            return True\\n\\n        if idx >= self.len-n:\\n            return False\\n        \\n        for ix in range(idx, self.len-n):\\n            if res[ix] == 0 and res[ix+n] == 0:\\n                res[ix], res[ix+n] = n, n\\n                idxn = res.index(0)\\n                if self.arrange(n-1, res, idxn) and len(self.lists) >= self.len*self.len*14:\\n                    return True\\n                res[ix], res[ix+n] = 0, 0\\n        return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 1633386,
                "title": "python-simple-greedy-backtracking",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.size = 2*n-1 #size of the array\\n        self.arr = [-1]*self.size #construct output array\\n        \\n        def solve(i, seen):\\n            if len(seen) == n or i >= self.size: #if we have seen all n numbers or i > self.size return true\\n                return True\\n            if self.arr[i] != -1: #move to next index if current one is taken\\n                return solve(i+1, seen)\\n            \\n            for idx in range(n, 0, -1):\\n                if idx in seen: continue #continue if this number has been used\\n                if i+idx >= self.size and idx != 1: continue #continue if this number would be out of index\\n                if idx != 1 and self.arr[i+idx] != -1: continue #continue if the element that in index i+idx (this is the distance) is not available \\n                \\n                seen.add(idx)\\n                \\n\\t\\t\\t\\t#add the number to the array\\n                self.arr[i] = idx\\n                if idx != 1:\\n                    self.arr[i+idx] = idx\\n                \\n                ans = solve(i+1, seen)\\n                if ans: return True #stop once we find the first working sequence\\n                elif idx != 1: self.arr[i+idx] = -1 #if sequence did not work reset the element at index i+idx.\\n\\t\\t\\t\\t#no need to do this for index i since it will be overwritten next iteration\\n                \\n                seen.remove(idx)\\n            \\n            self.arr[i] = -1 #reset index if no numbers worked\\n            return False\\n        solve(0, set())\\n        \\n        return self.arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.size = 2*n-1 #size of the array\\n        self.arr = [-1]*self.size #construct output array\\n        \\n        def solve(i, seen):\\n            if len(seen) == n or i >= self.size: #if we have seen all n numbers or i > self.size return true\\n                return True\\n            if self.arr[i] != -1: #move to next index if current one is taken\\n                return solve(i+1, seen)\\n            \\n            for idx in range(n, 0, -1):\\n                if idx in seen: continue #continue if this number has been used\\n                if i+idx >= self.size and idx != 1: continue #continue if this number would be out of index\\n                if idx != 1 and self.arr[i+idx] != -1: continue #continue if the element that in index i+idx (this is the distance) is not available \\n                \\n                seen.add(idx)\\n                \\n\\t\\t\\t\\t#add the number to the array\\n                self.arr[i] = idx\\n                if idx != 1:\\n                    self.arr[i+idx] = idx\\n                \\n                ans = solve(i+1, seen)\\n                if ans: return True #stop once we find the first working sequence\\n                elif idx != 1: self.arr[i+idx] = -1 #if sequence did not work reset the element at index i+idx.\\n\\t\\t\\t\\t#no need to do this for index i since it will be overwritten next iteration\\n                \\n                seen.remove(idx)\\n            \\n            self.arr[i] = -1 #reset index if no numbers worked\\n            return False\\n        solve(0, set())\\n        \\n        return self.arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627872,
                "title": "golang-recursion-search-with-early-termination-0ms",
                "content": "```\\nfunc constructDistancedSequence(n int) []int {\\n    ans := make([]int, 2 * n - 1)\\n    flag := make([]bool, n + 1) \\n    \\n    find(ans, flag, 0)\\n    \\n    for i := range ans {\\n        if ans[i] == 0 {\\n            ans[i] = 1\\n            break\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc find(a []int, flag []bool, ind int) bool {\\n    if ind + 1 == len(a) {\\n        return true\\n    }\\n    \\n    if a[ind] != 0 {\\n        return find(a, flag, ind + 1)\\n    }\\n    \\n    for i := len(flag) - 1; i >= 1; i-- {\\n        if flag[i] {\\n            continue\\n        }\\n        \\n        if i == 1 {\\n            a[ind], flag[1] = 1, true\\n            if find(a, flag, ind + 1) {\\n                return true\\n            }\\n            a[ind], flag[1] = 0, false\\n        } else if ind + i < len(a) && a[ind + i] == 0 {\\n            a[ind], a[ind + i], flag[i] = i, i, true\\n            if find(a, flag, ind + 1) {\\n                return true\\n            }\\n            a[ind], a[ind + i], flag[i] = 0, 0, false\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc constructDistancedSequence(n int) []int {\\n    ans := make([]int, 2 * n - 1)\\n    flag := make([]bool, n + 1) \\n    \\n    find(ans, flag, 0)\\n    \\n    for i := range ans {\\n        if ans[i] == 0 {\\n            ans[i] = 1\\n            break\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc find(a []int, flag []bool, ind int) bool {\\n    if ind + 1 == len(a) {\\n        return true\\n    }\\n    \\n    if a[ind] != 0 {\\n        return find(a, flag, ind + 1)\\n    }\\n    \\n    for i := len(flag) - 1; i >= 1; i-- {\\n        if flag[i] {\\n            continue\\n        }\\n        \\n        if i == 1 {\\n            a[ind], flag[1] = 1, true\\n            if find(a, flag, ind + 1) {\\n                return true\\n            }\\n            a[ind], flag[1] = 0, false\\n        } else if ind + i < len(a) && a[ind + i] == 0 {\\n            a[ind], a[ind + i], flag[i] = i, i, true\\n            if find(a, flag, ind + 1) {\\n                return true\\n            }\\n            a[ind], a[ind + i], flag[i] = 0, 0, false\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1616405,
                "title": "go-search",
                "content": "```\\nfunc constructDistancedSequence(n int) []int {\\n    ints := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        ints[i] = n - i\\n    }\\n    seq := make([]int, n * 2 - 1)\\n    dfs(seq, ints)\\n    return seq\\n}\\n\\nfunc dfs(seq []int, ints []int) bool {\\n    i := 0\\n    for i < len(seq) {\\n        if seq[i] == 0 {\\n            break\\n        }\\n        i++\\n    }\\n    \\n    if i == len(seq) {\\n        return true\\n    }\\n    \\n    for j, v := range ints {\\n        if v != 0 && (v == 1 || (i + v < len(seq) && seq[i + v] == 0)) {\\n            ints[j] = 0\\n            if v != 1 {\\n                seq[i] = v\\n                seq[i + v] = v\\n            } else {\\n                seq[i] = v\\n            }\\n            \\n            if dfs(seq, ints) {\\n                return true\\n            }\\n            ints[j] = v\\n            if v != 1 {\\n                seq[i] = 0\\n                seq[i + v] = 0\\n            } else {\\n                seq[i] = 0\\n            }            \\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc constructDistancedSequence(n int) []int {\\n    ints := make([]int, n)\\n    for i := 0; i < n; i++ {\\n        ints[i] = n - i\\n    }\\n    seq := make([]int, n * 2 - 1)\\n    dfs(seq, ints)\\n    return seq\\n}\\n\\nfunc dfs(seq []int, ints []int) bool {\\n    i := 0\\n    for i < len(seq) {\\n        if seq[i] == 0 {\\n            break\\n        }\\n        i++\\n    }\\n    \\n    if i == len(seq) {\\n        return true\\n    }\\n    \\n    for j, v := range ints {\\n        if v != 0 && (v == 1 || (i + v < len(seq) && seq[i + v] == 0)) {\\n            ints[j] = 0\\n            if v != 1 {\\n                seq[i] = v\\n                seq[i + v] = v\\n            } else {\\n                seq[i] = v\\n            }\\n            \\n            if dfs(seq, ints) {\\n                return true\\n            }\\n            ints[j] = v\\n            if v != 1 {\\n                seq[i] = 0\\n                seq[i + v] = 0\\n            } else {\\n                seq[i] = 0\\n            }            \\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1610500,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[1 + 2 * (n-1)];\\n        Arrays.fill(res, -1);\\n        boolean[] usednumber = new boolean[n+1];\\n        dfs(res, 0,usednumber, n);\\n        return res;\\n    }\\n    \\n    public boolean dfs(int[] res, int pos,boolean[] used, int n)\\n    {\\n        if(pos >= n)\\n        {\\n            return true;\\n        }\\n        \\n        int respos = -1;\\n        for(int i = 0; i < res.length; i++)\\n        {\\n            if(res[i]==-1)\\n            {\\n                respos = i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = n; i >=1; i--)\\n        {\\n            if(!used[i])\\n            {\\n                if(i>1 && respos + i < res.length && res[respos+i]==-1){\\n                    res[respos] = i;\\n                    res[respos+i] = i;\\n                }\\n                else if(i==1)\\n                {\\n                    res[respos] = 1;\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n                \\n                used[i] = true;\\n                if(dfs(res, pos+1, used, n))return true;\\n                used[i] = false;\\n                \\n                if(i>1){\\n                    res[respos] = -1;\\n                    res[respos+i] = -1;\\n                }\\n                else if(i==1)\\n                {\\n                    res[respos] = -1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[1 + 2 * (n-1)];\\n        Arrays.fill(res, -1);\\n        boolean[] usednumber = new boolean[n+1];\\n        dfs(res, 0,usednumber, n);\\n        return res;\\n    }\\n    \\n    public boolean dfs(int[] res, int pos,boolean[] used, int n)\\n    {\\n        if(pos >= n)\\n        {\\n            return true;\\n        }\\n        \\n        int respos = -1;\\n        for(int i = 0; i < res.length; i++)\\n        {\\n            if(res[i]==-1)\\n            {\\n                respos = i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = n; i >=1; i--)\\n        {\\n            if(!used[i])\\n            {\\n                if(i>1 && respos + i < res.length && res[respos+i]==-1){\\n                    res[respos] = i;\\n                    res[respos+i] = i;\\n                }\\n                else if(i==1)\\n                {\\n                    res[respos] = 1;\\n                }\\n                else\\n                {\\n                    continue;\\n                }\\n                \\n                used[i] = true;\\n                if(dfs(res, pos+1, used, n))return true;\\n                used[i] = false;\\n                \\n                if(i>1){\\n                    res[respos] = -1;\\n                    res[respos+i] = -1;\\n                }\\n                else if(i==1)\\n                {\\n                    res[respos] = -1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568321,
                "title": "backtracking-lexicographic-early-termination-this-one-s-a-hard-for-sure",
                "content": "```\\n    bool f = false;\\n    vector<int> res;\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        \\n        vector<int> v(2 * (n - 1) + 1, 0);\\n        rec(v, {} ,0, n);\\n        return res;\\n    }\\n    \\n    void rec(vector<int> nums, set<int> st, int idx, int n) {\\n        \\n        if(f) return;\\n\\n        if(st.size() == n) {\\n            f = true;\\n            res = nums;\\n            return;\\n        }\\n        \\n        if(nums[idx] != 0) return rec(nums, st, idx + 1, n);\\n        \\n        for(int i = n ; i >= 1 ; i--) \\n            if(i == 1 && st.count(i) == 0 && nums[idx] == 0) {\\n                \\n                st.insert(i);\\n                nums[idx] = i;\\n                rec(nums, st, idx + 1, n);\\n                nums[idx] = 0;\\n                st.erase(i);\\n            }\\n            else if(st.count(i) == 0 && nums[idx] == 0 && idx + i < nums.size() && nums[idx + i] == 0) {\\n                \\n                st.insert(i);\\n                nums[idx] = nums[idx + i] = i;\\n                rec(nums, st, idx + 1 ,n);\\n                nums[idx] = nums[idx + i] = 0;\\n                st.erase(i);\\n            }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool f = false;\\n    vector<int> res;\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        \\n        vector<int> v(2 * (n - 1) + 1, 0);\\n        rec(v, {} ,0, n);\\n        return res;\\n    }\\n    \\n    void rec(vector<int> nums, set<int> st, int idx, int n) {\\n        \\n        if(f) return;\\n\\n        if(st.size() == n) {\\n            f = true;\\n            res = nums;\\n            return;\\n        }\\n        \\n        if(nums[idx] != 0) return rec(nums, st, idx + 1, n);\\n        \\n        for(int i = n ; i >= 1 ; i--) \\n            if(i == 1 && st.count(i) == 0 && nums[idx] == 0) {\\n                \\n                st.insert(i);\\n                nums[idx] = i;\\n                rec(nums, st, idx + 1, n);\\n                nums[idx] = 0;\\n                st.erase(i);\\n            }\\n            else if(st.count(i) == 0 && nums[idx] == 0 && idx + i < nums.size() && nums[idx + i] == 0) {\\n                \\n                st.insert(i);\\n                nums[idx] = nums[idx + i] = i;\\n                rec(nums, st, idx + 1 ,n);\\n                nums[idx] = nums[idx + i] = 0;\\n                st.erase(i);\\n            }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502900,
                "title": "c-backtracking-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>&ans, vector<int>&seq, vector<bool>&visited, int current){\\n        int i;\\n        if(current == seq.size()){\\n            ans = seq;\\n            return true;\\n        }\\n        \\n        if(seq[current] != -1){\\n            return dfs(ans, seq, visited, current + 1);\\n        }\\n        \\n        bool result = false;\\n        for(i = visited.size() - 1; i >= 2; i--){\\n            if(visited[i]){\\n                continue;\\n            }\\n            if(current + i < seq.size() && seq[current + i] == -1){\\n                seq[current] = i;\\n                seq[current + i] = i;\\n                visited[i] = true;\\n                result = dfs(ans, seq, visited, current + 1);\\n                visited[i] = false;\\n                seq[current + i] = -1;\\n                seq[current] = -1;\\n            }\\n            if(result){\\n                return true;\\n            }\\n        }\\n        if(!visited[1]){\\n            visited[1] = true;\\n            seq[current] = 1;\\n            result = dfs(ans, seq, visited, current + 1);\\n            seq[current] = -1;\\n            visited[1] = false;\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vector<bool>visited(n + 1);\\n        vector<int>seq(2 * n - 1, -1);\\n        vector<int>ans;\\n        dfs(ans, seq, visited, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>&ans, vector<int>&seq, vector<bool>&visited, int current){\\n        int i;\\n        if(current == seq.size()){\\n            ans = seq;\\n            return true;\\n        }\\n        \\n        if(seq[current] != -1){\\n            return dfs(ans, seq, visited, current + 1);\\n        }\\n        \\n        bool result = false;\\n        for(i = visited.size() - 1; i >= 2; i--){\\n            if(visited[i]){\\n                continue;\\n            }\\n            if(current + i < seq.size() && seq[current + i] == -1){\\n                seq[current] = i;\\n                seq[current + i] = i;\\n                visited[i] = true;\\n                result = dfs(ans, seq, visited, current + 1);\\n                visited[i] = false;\\n                seq[current + i] = -1;\\n                seq[current] = -1;\\n            }\\n            if(result){\\n                return true;\\n            }\\n        }\\n        if(!visited[1]){\\n            visited[1] = true;\\n            seq[current] = 1;\\n            result = dfs(ans, seq, visited, current + 1);\\n            seq[current] = -1;\\n            visited[1] = false;\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vector<bool>visited(n + 1);\\n        vector<int>seq(2 * n - 1, -1);\\n        vector<int>ans;\\n        dfs(ans, seq, visited, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482259,
                "title": "python3-simple-backtracking-with-early-stop-with-bit-seen",
                "content": "Go through the first position to last position\\nFor each position to find a number to fill it \\n\\nHow to check the number is used or not?\\n```\\n# using seen (bit) to check the number is used or not\\n# e.x. 101 -> 0, 2 are used\\nseen >> num & 1\\n```\\n\\nTricky condition is to fill two numbers, if not find the answer, filled these two nubmers with 1 (like pop them)\\n```\\n# update cur array to fill two numbers\\ncur[pos] = num\\ncur[pos+num] = num\\n```\\n\\n\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        def dfs(cur, seen, pos):\\n            nonlocal ans, n\\n            if pos == len(cur):\\n                return True\\n            if cur[pos] != -1:\\n                return dfs(cur, seen, pos + 1)\\n            \\n            for num in range(n, 0, -1):\\n                if seen >> num & 1:\\n                    continue\\n                if num == 1:\\n                    if cur[pos] != -1:\\n                        continue\\n                    cur[pos] = num\\n                    ans = cur\\n                    seen ^= 1 << num\\n                    if dfs(cur, seen, pos + 1):\\n                        return True\\n                    cur[pos] = -1\\n                    seen ^= 1 << num\\n                else:\\n                    if pos + num >= len(cur):\\n                        continue\\n                    if cur[pos] != -1 or cur[pos+num] != -1:\\n                        continue\\n                    cur[pos] = num\\n                    cur[pos+num] = num\\n                    seen ^= 1 << num\\n                    if dfs(cur, seen, pos + 1):\\n                        return True\\n                    cur[pos] = -1\\n                    cur[pos+num] = -1\\n                    seen ^= 1 << num\\n            return False\\n        \\n        \\n        ans = []\\n        seen = 0\\n        dfs([-1] * (n * 2 - 1), seen, 0)\\n        return ans\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# using seen (bit) to check the number is used or not\\n# e.x. 101 -> 0, 2 are used\\nseen >> num & 1\\n```\n```\\n# update cur array to fill two numbers\\ncur[pos] = num\\ncur[pos+num] = num\\n```\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        def dfs(cur, seen, pos):\\n            nonlocal ans, n\\n            if pos == len(cur):\\n                return True\\n            if cur[pos] != -1:\\n                return dfs(cur, seen, pos + 1)\\n            \\n            for num in range(n, 0, -1):\\n                if seen >> num & 1:\\n                    continue\\n                if num == 1:\\n                    if cur[pos] != -1:\\n                        continue\\n                    cur[pos] = num\\n                    ans = cur\\n                    seen ^= 1 << num\\n                    if dfs(cur, seen, pos + 1):\\n                        return True\\n                    cur[pos] = -1\\n                    seen ^= 1 << num\\n                else:\\n                    if pos + num >= len(cur):\\n                        continue\\n                    if cur[pos] != -1 or cur[pos+num] != -1:\\n                        continue\\n                    cur[pos] = num\\n                    cur[pos+num] = num\\n                    seen ^= 1 << num\\n                    if dfs(cur, seen, pos + 1):\\n                        return True\\n                    cur[pos] = -1\\n                    cur[pos+num] = -1\\n                    seen ^= 1 << num\\n            return False\\n        \\n        \\n        ans = []\\n        seen = 0\\n        dfs([-1] * (n * 2 - 1), seen, 0)\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454420,
                "title": "c-recursion",
                "content": "```\\n//if list toPlace is empty\\n    //we are done\\n//else\\n    //at each step take the largest available number\\n    //if > 1\\n        //place at next available idx and at idx + i\\n    //if == 1\\n        //place 1 at next available idx\\n    //if success\\n        //remove i from list to place and continue\\n    //if failure backtrack and try next largest number\\n        //add number back to list\\n        //set values back to 0\\n\\t\\t\\npublic class Solution \\n{\\n    public int[] ConstructDistancedSequence(int n) \\n    {\\n        var output = new int[((n - 1)*2) + 1];\\n        var toPlace = Enumerable.Range(1, n).ToList();\\n        \\n        PlaceNextGoodNumber(0, toPlace, output);\\n        \\n        return output;\\n    }\\n    \\n    private bool PlaceNextGoodNumber(int idx, List<int> toPlace, int[] output)\\n    {\\n        bool isConstructed = false;\\n        \\n        //backtrack\\n        if (toPlace.Count == 0)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            //get the count since the list will be modified throughout the loop\\n            var count = toPlace.Count;\\n            \\n            for (int i = count - 1; i >= 0; i--)\\n            {\\n                //get the biggest number we have not tried yet\\n                var num = toPlace[i];\\n                \\n                if (num == 1 || IsValidPlacement(num, idx, output))\\n                {\\n                    //place the number in the correct spot(s)\\n                    output[idx] = num;\\n                    \\n                    if (num != 1)\\n                    {\\n                        output[idx + num] = num;                        \\n                    }\\n                    \\n                    toPlace.RemoveAt(i);\\n                    \\n                    isConstructed = PlaceNextGoodNumber(GetNextIdx(output, idx + 1), toPlace, output);\\n                    \\n                    //reverse the changes\\n                    if (!isConstructed)\\n                    {\\n                        toPlace.Insert(i, num);\\n                        \\n                        output[idx] = 0;\\n                        \\n                        if (num != 1)\\n                        {\\n                            output[idx + num] = 0;                        \\n                        }\\n                    }\\n                    //we have constructed the largest valid sequence \\n                    //therefore do not undo the changes made, just return\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return isConstructed;\\n    }\\n    \\n    private bool IsValidPlacement(int num, int idx, int[] output)\\n    {\\n        //ensure the number can placed i spaces apart &&\\n        //that the space is within the length of the output[]\\n        if (num + idx >= output.Length || output[num + idx] != 0)\\n        {\\n            return false;    \\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int GetNextIdx(int[] output, int startIdx)\\n    {\\n        var nextIdx = -1;\\n        \\n        for (int i = startIdx; i < output.Length; i++)\\n        {\\n            if (output[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //-1 can be returned when the output[] is full\\n        //but in that case the backtracking will prevent IOOBE\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//if list toPlace is empty\\n    //we are done\\n//else\\n    //at each step take the largest available number\\n    //if > 1\\n        //place at next available idx and at idx + i\\n    //if == 1\\n        //place 1 at next available idx\\n    //if success\\n        //remove i from list to place and continue\\n    //if failure backtrack and try next largest number\\n        //add number back to list\\n        //set values back to 0\\n\\t\\t\\npublic class Solution \\n{\\n    public int[] ConstructDistancedSequence(int n) \\n    {\\n        var output = new int[((n - 1)*2) + 1];\\n        var toPlace = Enumerable.Range(1, n).ToList();\\n        \\n        PlaceNextGoodNumber(0, toPlace, output);\\n        \\n        return output;\\n    }\\n    \\n    private bool PlaceNextGoodNumber(int idx, List<int> toPlace, int[] output)\\n    {\\n        bool isConstructed = false;\\n        \\n        //backtrack\\n        if (toPlace.Count == 0)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            //get the count since the list will be modified throughout the loop\\n            var count = toPlace.Count;\\n            \\n            for (int i = count - 1; i >= 0; i--)\\n            {\\n                //get the biggest number we have not tried yet\\n                var num = toPlace[i];\\n                \\n                if (num == 1 || IsValidPlacement(num, idx, output))\\n                {\\n                    //place the number in the correct spot(s)\\n                    output[idx] = num;\\n                    \\n                    if (num != 1)\\n                    {\\n                        output[idx + num] = num;                        \\n                    }\\n                    \\n                    toPlace.RemoveAt(i);\\n                    \\n                    isConstructed = PlaceNextGoodNumber(GetNextIdx(output, idx + 1), toPlace, output);\\n                    \\n                    //reverse the changes\\n                    if (!isConstructed)\\n                    {\\n                        toPlace.Insert(i, num);\\n                        \\n                        output[idx] = 0;\\n                        \\n                        if (num != 1)\\n                        {\\n                            output[idx + num] = 0;                        \\n                        }\\n                    }\\n                    //we have constructed the largest valid sequence \\n                    //therefore do not undo the changes made, just return\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return isConstructed;\\n    }\\n    \\n    private bool IsValidPlacement(int num, int idx, int[] output)\\n    {\\n        //ensure the number can placed i spaces apart &&\\n        //that the space is within the length of the output[]\\n        if (num + idx >= output.Length || output[num + idx] != 0)\\n        {\\n            return false;    \\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int GetNextIdx(int[] output, int startIdx)\\n    {\\n        var nextIdx = -1;\\n        \\n        for (int i = startIdx; i < output.Length; i++)\\n        {\\n            if (output[i] == 0)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        //-1 can be returned when the output[] is full\\n        //but in that case the backtracking will prevent IOOBE\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439387,
                "title": "javascript-backtracking-clean-code-with-comments",
                "content": "```\\nconst constructDistancedSequence = function (number) {\\n    // declare the sequence array with length\\n    const sequence = new Array(number*2-1);\\n    \\n    const dfs = function(depth) {\\n        // base condition\\n        if(depth === sequence.length) return true; // since we are at the max depth, problem is solved\\n        \\n        if(sequence[depth]) return dfs(depth + 1); // if depth has already been evaluated move on to the next one.\\n        \\n        for(let trial=number; trial > 0; trial--) { // try for each number from max to 1 and see if they can fit into the sequence\\n            if(sequence.includes(trial)) continue; // we already have this trial in the sequence move on to the next\\n            if(trial === 1) { //special handling for the 1\\n                sequence[depth] = trial; // assaign trail to the empty space\\n                if(dfs(depth + 1)) return true; // since next depth can be evaluted do nothing\\n                sequence[depth] = 0; // since next depth is not able to evaluate redo this step\\n            }else if(depth + trial < sequence.length && !sequence[depth + trial]) {\\n                // since trial can fit, assign and hold trial in sequence array\\n                sequence[depth] = trial;\\n                sequence[depth + trial] = trial;\\n                if(dfs(depth + 1)) return true; // since next depth can be evaluated return true and do nothing.\\n                // since next depth can\\'t fit, redo the option\\n                sequence[depth] = 0;\\n                sequence[depth + trial] = 0;\\n            }\\n        }\\n    }\\n    // start with the root depth\\n    dfs(0);\\n    return sequence;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst constructDistancedSequence = function (number) {\\n    // declare the sequence array with length\\n    const sequence = new Array(number*2-1);\\n    \\n    const dfs = function(depth) {\\n        // base condition\\n        if(depth === sequence.length) return true; // since we are at the max depth, problem is solved\\n        \\n        if(sequence[depth]) return dfs(depth + 1); // if depth has already been evaluated move on to the next one.\\n        \\n        for(let trial=number; trial > 0; trial--) { // try for each number from max to 1 and see if they can fit into the sequence\\n            if(sequence.includes(trial)) continue; // we already have this trial in the sequence move on to the next\\n            if(trial === 1) { //special handling for the 1\\n                sequence[depth] = trial; // assaign trail to the empty space\\n                if(dfs(depth + 1)) return true; // since next depth can be evaluted do nothing\\n                sequence[depth] = 0; // since next depth is not able to evaluate redo this step\\n            }else if(depth + trial < sequence.length && !sequence[depth + trial]) {\\n                // since trial can fit, assign and hold trial in sequence array\\n                sequence[depth] = trial;\\n                sequence[depth + trial] = trial;\\n                if(dfs(depth + 1)) return true; // since next depth can be evaluated return true and do nothing.\\n                // since next depth can\\'t fit, redo the option\\n                sequence[depth] = 0;\\n                sequence[depth + trial] = 0;\\n            }\\n        }\\n    }\\n    // start with the root depth\\n    dfs(0);\\n    return sequence;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370676,
                "title": "simple-backtracking-c-0ms",
                "content": "Approach : For every position `pos` check which number can be filled at `pos`. If this number can be filled and we get a valid configuration, we are sure to get the lexicographically largest sequence as we start filling from highest to lowest number.\\n```\\nclass Solution {\\npublic:\\nbool help(vector<int> &ans,int pos,int mask){\\n    // mask contains info about used numbers\\n    if(pos==ans.size()) return true;\\n    if(ans[pos]!=-1) return help(ans,pos+1,mask);\\n    int n=(ans.size()+1)/2;\\n    for(int i=n;i>=1;i--){\\n        if(mask&(1<<(i-1))) continue;                                   //  since \\'i\\' has been used before\\n        if((i!=1 && pos+i>=ans.size()) || (i!=1 && ans[pos+i]!=-1)) continue;      //  since I can\\'t put \\'i\\' now \\n        if(i==1){\\n            ans[pos]=i;\\n            mask^=(1<<(i-1));\\n            if(help(ans,pos+1,mask)) return true;\\n            ans[pos]=-1;\\n            mask^=(1<<(i-1));\\n        }\\n        else{\\n            ans[pos]=i;\\n            ans[pos+i]=i;\\n            mask^=(1<<(i-1));\\n            if(help(ans,pos+1,mask)) return true;\\n            ans[pos]=-1;\\n            ans[pos+i]=-1;\\n            mask^=(1<<(i-1));\\n        }\\n    }\\n    return false;\\n}\\n\\nvector<int> constructDistancedSequence(int n){\\n    vector<int> ans(2*n-1,-1);\\n    help(ans,0,0);\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool help(vector<int> &ans,int pos,int mask){\\n    // mask contains info about used numbers\\n    if(pos==ans.size()) return true;\\n    if(ans[pos]!=-1) return help(ans,pos+1,mask);\\n    int n=(ans.size()+1)/2;\\n    for(int i=n;i>=1;i--){\\n        if(mask&(1<<(i-1))) continue;                                   //  since \\'i\\' has been used before\\n        if((i!=1 && pos+i>=ans.size()) || (i!=1 && ans[pos+i]!=-1)) continue;      //  since I can\\'t put \\'i\\' now \\n        if(i==1){\\n            ans[pos]=i;\\n            mask^=(1<<(i-1));\\n            if(help(ans,pos+1,mask)) return true;\\n            ans[pos]=-1;\\n            mask^=(1<<(i-1));\\n        }\\n        else{\\n            ans[pos]=i;\\n            ans[pos+i]=i;\\n            mask^=(1<<(i-1));\\n            if(help(ans,pos+1,mask)) return true;\\n            ans[pos]=-1;\\n            ans[pos+i]=-1;\\n            mask^=(1<<(i-1));\\n        }\\n    }\\n    return false;\\n}\\n\\nvector<int> constructDistancedSequence(int n){\\n    vector<int> ans(2*n-1,-1);\\n    help(ans,0,0);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357336,
                "title": "c-backtracking-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void bt(vector<int>& arr, int idx, int n, bitset<21>& mask){\\n        if(!ans.empty()) return;\\n        if(idx == arr.size()){\\n            ans = arr;\\n            return;\\n        }\\n        if(arr[idx] != -1){\\n            bt(arr,idx+1, n, mask);\\n            return;\\n        }\\n        for(int i=n; i>=2; i--){\\n            if(mask[i]==0 && idx+i<arr.size() && arr[idx+i] == -1){\\n                mask[i]=1;\\n                arr[idx] = i;\\n                arr[idx+i]=i;\\n                bt(arr, idx+1, n, mask);\\n                arr[idx]=-1;\\n                arr[idx+i]=-1;\\n                mask[i]=0;\\n            }\\n        }\\n        if(mask[1]==0){\\n            mask[1]=1;\\n            arr[idx]=1;\\n            bt(arr, idx+1, n, mask);\\n            mask[1]=0;\\n            arr[idx]=-1;\\n        }\\n   \\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> arr((n-1)*2+1,-1);\\n        bitset<21> mask;\\n        bt(arr, 0, n, mask);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void bt(vector<int>& arr, int idx, int n, bitset<21>& mask){\\n        if(!ans.empty()) return;\\n        if(idx == arr.size()){\\n            ans = arr;\\n            return;\\n        }\\n        if(arr[idx] != -1){\\n            bt(arr,idx+1, n, mask);\\n            return;\\n        }\\n        for(int i=n; i>=2; i--){\\n            if(mask[i]==0 && idx+i<arr.size() && arr[idx+i] == -1){\\n                mask[i]=1;\\n                arr[idx] = i;\\n                arr[idx+i]=i;\\n                bt(arr, idx+1, n, mask);\\n                arr[idx]=-1;\\n                arr[idx+i]=-1;\\n                mask[i]=0;\\n            }\\n        }\\n        if(mask[1]==0){\\n            mask[1]=1;\\n            arr[idx]=1;\\n            bt(arr, idx+1, n, mask);\\n            mask[1]=0;\\n            arr[idx]=-1;\\n        }\\n   \\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> arr((n-1)*2+1,-1);\\n        bitset<21> mask;\\n        bt(arr, 0, n, mask);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323232,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool help(vector<int> &v,int x, int k,int n,vector<bool>&visited)\\n    {\\n        \\n        if(v[k]!=0)\\n            return false;\\n        else if(( (x!=1) && (k+x<(2*n - 1)) && v[k+x]!=0)||((x!=1) &&(k+x>=(2*n - 1))))\\n            return false;\\n        visited[x]=true;\\n        v[k]=x;\\n        if(x!=1)\\n            v[k+x]=x;\\n        bool flag=true;\\n        for(int i=n;i>0;i--)\\n        {\\n            flag=flag&&visited[i];\\n        }\\n        if(flag)\\n            return true;\\n        int j=k;\\n        while(j<(2*n - 1)&&v[j]!=0)\\n                j++;\\n        for(int i=n;i>0;i--)\\n        {\\n            if(!visited[i])\\n            {\\n                if(help(v,i,j,n,visited))\\n                    return true;\\n            }\\n        }\\n        v[k]=0;\\n        if(x!=1)\\n        {\\n            v[k+x]=0;\\n        }\\n        visited[x]=false;\\n        return false;\\n    }\\n    \\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int>res(2*n -1,0);\\n        vector<bool>visited(n+1,false);\\n        visited[0]=true;\\n        help(res,n,0,n,visited);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool help(vector<int> &v,int x, int k,int n,vector<bool>&visited)\\n    {\\n        \\n        if(v[k]!=0)\\n            return false;\\n        else if(( (x!=1) && (k+x<(2*n - 1)) && v[k+x]!=0)||((x!=1) &&(k+x>=(2*n - 1))))\\n            return false;\\n        visited[x]=true;\\n        v[k]=x;\\n        if(x!=1)\\n            v[k+x]=x;\\n        bool flag=true;\\n        for(int i=n;i>0;i--)\\n        {\\n            flag=flag&&visited[i];\\n        }\\n        if(flag)\\n            return true;\\n        int j=k;\\n        while(j<(2*n - 1)&&v[j]!=0)\\n                j++;\\n        for(int i=n;i>0;i--)\\n        {\\n            if(!visited[i])\\n            {\\n                if(help(v,i,j,n,visited))\\n                    return true;\\n            }\\n        }\\n        v[k]=0;\\n        if(x!=1)\\n        {\\n            v[k+x]=0;\\n        }\\n        visited[x]=false;\\n        return false;\\n    }\\n    \\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int>res(2*n -1,0);\\n        vector<bool>visited(n+1,false);\\n        visited[0]=true;\\n        help(res,n,0,n,visited);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313408,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar constructDistancedSequence = function(n) {\\n    const table = new Array(1 + n).fill(true)\\n    table[0] = false\\n    let result = new Array(2 * n - 1).fill(0)\\n    \\n    \\n    function pairAvailable(fromIndex, tryMe) {\\n        if (tryMe === 1)    return result[fromIndex] === 0\\n        return result[fromIndex] === 0 && result[fromIndex + tryMe] === 0\\n    }\\n    \\n    let remaining = n, solved = false\\n    function solve(fromIndex) {\\n        if (fromIndex === result.length) {\\n            if (remaining === 0) {\\n                solved = true\\n            }\\n        }\\n        \\n        if (result[fromIndex]) {\\n            solve(1 + fromIndex)\\n            return\\n        }\\n    \\n        for (let tryMe = n; tryMe > 0; tryMe--) {\\n            if (!table[tryMe])  continue\\n            if (!pairAvailable(fromIndex, tryMe))    continue\\n            \\n            result[fromIndex] = tryMe\\n            if (tryMe !== 1)    result[fromIndex + tryMe] = tryMe\\n            table[tryMe] = false\\n            remaining--\\n            \\n            solve(1 + fromIndex)\\n            if (!solved) {\\n                result[fromIndex] = 0\\n                if (tryMe !== 1)    result[fromIndex + tryMe] = 0\\n                table[tryMe] = true\\n                remaining++\\n            }\\n        }\\n    }\\n    \\n    \\n    solve(0)\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar constructDistancedSequence = function(n) {\\n    const table = new Array(1 + n).fill(true)\\n    table[0] = false\\n    let result = new Array(2 * n - 1).fill(0)\\n    \\n    \\n    function pairAvailable(fromIndex, tryMe) {\\n        if (tryMe === 1)    return result[fromIndex] === 0\\n        return result[fromIndex] === 0 && result[fromIndex + tryMe] === 0\\n    }\\n    \\n    let remaining = n, solved = false\\n    function solve(fromIndex) {\\n        if (fromIndex === result.length) {\\n            if (remaining === 0) {\\n                solved = true\\n            }\\n        }\\n        \\n        if (result[fromIndex]) {\\n            solve(1 + fromIndex)\\n            return\\n        }\\n    \\n        for (let tryMe = n; tryMe > 0; tryMe--) {\\n            if (!table[tryMe])  continue\\n            if (!pairAvailable(fromIndex, tryMe))    continue\\n            \\n            result[fromIndex] = tryMe\\n            if (tryMe !== 1)    result[fromIndex + tryMe] = tryMe\\n            table[tryMe] = false\\n            remaining--\\n            \\n            solve(1 + fromIndex)\\n            if (!solved) {\\n                result[fromIndex] = 0\\n                if (tryMe !== 1)    result[fromIndex + tryMe] = 0\\n                table[tryMe] = true\\n                remaining++\\n            }\\n        }\\n    }\\n    \\n    \\n    solve(0)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283965,
                "title": "c-with-backtracking",
                "content": "```\\npublic class Solution {\\n    public int[] ConstructDistancedSequence(int n) {\\n        int size = (2 * n) - 1;\\n        int[] outAry = new int[size];\\n        HashSet<int> visited = new HashSet<int>();\\n        this.Construct(outAry, visited, 0, n, n);\\n        return outAry;\\n    }\\n    \\n    private bool Construct(int[] outAry, HashSet<int> visited, int startIdx, int startVal, int n)\\n    {\\n        if (startIdx > outAry.Length || startVal < 1)\\n        {\\n            return true;\\n        }\\n\\n        // try different values to put in the next index\\n        int i = startVal;\\n        bool isSequencePossible;\\n        while (i >= 1)\\n        {\\n            outAry[startIdx] = i;\\n            if (i == 1)\\n            {                \\n                visited.Add(i);\\n                isSequencePossible = this.Construct(outAry, visited, this.GetNextAvailableIdx(startIdx, outAry), this.GetNextHighestUnvisited(visited, n), n);\\n                if (isSequencePossible)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    visited.Remove(i);\\n                    outAry[startIdx] = 0;\\n                }\\n                \\n                break;\\n            }\\n            \\n            if ((startIdx + i) >= outAry.Length)\\n            {\\n                outAry[startIdx] = 0;\\n                return false;\\n            }\\n            \\n            if (outAry[startIdx + i] != 0)\\n            {\\n                outAry[startIdx] = 0;\\n                i = this.GetNextHighestUnvisited(visited, i - 1);\\n                continue;\\n            }\\n        \\n            outAry[startIdx + i] = i;\\n            visited.Add(i);\\n            isSequencePossible = this.Construct(outAry, visited, this.GetNextAvailableIdx(startIdx, outAry), this.GetNextHighestUnvisited(visited, n), n);\\n            if (isSequencePossible)\\n            {\\n                return true;\\n            }\\n            \\n            outAry[startIdx] = 0;\\n            outAry[startIdx + i] = 0;\\n            visited.Remove(i);\\n            i = this.GetNextHighestUnvisited(visited, i - 1);            \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int GetNextHighestUnvisited(HashSet<int> visited, int n)\\n    {\\n        int i = n;\\n        while (i >= 1 && visited.Contains(i))\\n        {\\n            i--;\\n        }\\n        \\n        return i;\\n    }\\n    \\n    private int GetNextAvailableIdx(int startIdx, int[] outAry)\\n    {\\n        int i = startIdx + 1;\\n        while (i < outAry.Length && outAry[i] != 0)\\n        {\\n            i++;\\n        }\\n        \\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] ConstructDistancedSequence(int n) {\\n        int size = (2 * n) - 1;\\n        int[] outAry = new int[size];\\n        HashSet<int> visited = new HashSet<int>();\\n        this.Construct(outAry, visited, 0, n, n);\\n        return outAry;\\n    }\\n    \\n    private bool Construct(int[] outAry, HashSet<int> visited, int startIdx, int startVal, int n)\\n    {\\n        if (startIdx > outAry.Length || startVal < 1)\\n        {\\n            return true;\\n        }\\n\\n        // try different values to put in the next index\\n        int i = startVal;\\n        bool isSequencePossible;\\n        while (i >= 1)\\n        {\\n            outAry[startIdx] = i;\\n            if (i == 1)\\n            {                \\n                visited.Add(i);\\n                isSequencePossible = this.Construct(outAry, visited, this.GetNextAvailableIdx(startIdx, outAry), this.GetNextHighestUnvisited(visited, n), n);\\n                if (isSequencePossible)\\n                {\\n                    return true;\\n                }\\n                else\\n                {\\n                    visited.Remove(i);\\n                    outAry[startIdx] = 0;\\n                }\\n                \\n                break;\\n            }\\n            \\n            if ((startIdx + i) >= outAry.Length)\\n            {\\n                outAry[startIdx] = 0;\\n                return false;\\n            }\\n            \\n            if (outAry[startIdx + i] != 0)\\n            {\\n                outAry[startIdx] = 0;\\n                i = this.GetNextHighestUnvisited(visited, i - 1);\\n                continue;\\n            }\\n        \\n            outAry[startIdx + i] = i;\\n            visited.Add(i);\\n            isSequencePossible = this.Construct(outAry, visited, this.GetNextAvailableIdx(startIdx, outAry), this.GetNextHighestUnvisited(visited, n), n);\\n            if (isSequencePossible)\\n            {\\n                return true;\\n            }\\n            \\n            outAry[startIdx] = 0;\\n            outAry[startIdx + i] = 0;\\n            visited.Remove(i);\\n            i = this.GetNextHighestUnvisited(visited, i - 1);            \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private int GetNextHighestUnvisited(HashSet<int> visited, int n)\\n    {\\n        int i = n;\\n        while (i >= 1 && visited.Contains(i))\\n        {\\n            i--;\\n        }\\n        \\n        return i;\\n    }\\n    \\n    private int GetNextAvailableIdx(int startIdx, int[] outAry)\\n    {\\n        int i = startIdx + 1;\\n        while (i < outAry.Length && outAry[i] != 0)\\n        {\\n            i++;\\n        }\\n        \\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234524,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int[] ConstructDistancedSequence(int n) \\n    {\\n        int[] arr = new int[2*(n-1)+1];\\n        bool[] taken = new bool[n];\\n        Recur(arr,taken,0);\\n        return arr;\\n    }\\n    \\n    private bool Recur(int[] arr, bool[] taken, int st)\\n    {\\n        if(st >= arr.Length)\\n        {\\n            return true;\\n        }\\n        \\n        bool isValid = false;\\n        \\n        for(int i=taken.Length-1; i>=0; i--)\\n        {\\n            if(!taken[i])\\n            {\\n                \\n                taken[i] = true;\\n                \\n                int n = i+1;\\n                \\n                int en = st;\\n                \\n                if(n!=1)\\n                    en += n;\\n                \\n                \\n                if(en<arr.Length && arr[st]==0 && arr[en]==0)\\n                {\\n                    arr[st] = n;\\n                    arr[en] = n;\\n                    \\n                    int temp = st+1;\\n                    \\n                    while(temp<arr.Length && arr[temp]!=0)\\n                    {\\n                        temp++;\\n                    }\\n                    \\n                    isValid = Recur(arr,taken,temp);\\n                    \\n                    if(isValid)\\n                        break;\\n                    \\n                    arr[st] = 0;\\n                    arr[en] = 0;\\n                }\\n                \\n                taken[i] = false;\\n            }\\n            \\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] ConstructDistancedSequence(int n) \\n    {\\n        int[] arr = new int[2*(n-1)+1];\\n        bool[] taken = new bool[n];\\n        Recur(arr,taken,0);\\n        return arr;\\n    }\\n    \\n    private bool Recur(int[] arr, bool[] taken, int st)\\n    {\\n        if(st >= arr.Length)\\n        {\\n            return true;\\n        }\\n        \\n        bool isValid = false;\\n        \\n        for(int i=taken.Length-1; i>=0; i--)\\n        {\\n            if(!taken[i])\\n            {\\n                \\n                taken[i] = true;\\n                \\n                int n = i+1;\\n                \\n                int en = st;\\n                \\n                if(n!=1)\\n                    en += n;\\n                \\n                \\n                if(en<arr.Length && arr[st]==0 && arr[en]==0)\\n                {\\n                    arr[st] = n;\\n                    arr[en] = n;\\n                    \\n                    int temp = st+1;\\n                    \\n                    while(temp<arr.Length && arr[temp]!=0)\\n                    {\\n                        temp++;\\n                    }\\n                    \\n                    isValid = Recur(arr,taken,temp);\\n                    \\n                    if(isValid)\\n                        break;\\n                    \\n                    arr[st] = 0;\\n                    arr[en] = 0;\\n                }\\n                \\n                taken[i] = false;\\n            }\\n            \\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204769,
                "title": "ruby-backtracking",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef construct_distanced_sequence(n)\\n  cur = Array.new(2*n - 1, 0)\\n  f(cur)\\nend\\n\\ndef f(cur)\\n    idx = cur.index(0)\\n    return cur.dup unless idx\\n    \\n    ((cur.size / 2 + 1).downto(1).to_a - cur).each do |d|\\n        j = d == 1 ? idx : idx + d\\n        next unless cur[j] == 0\\n        cur[idx] = d\\n        cur[j] = d\\n        t = f(cur)\\n        cur[idx] = 0\\n        cur[j] = 0\\n        return t if t\\n    end\\n    \\n    nil            \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef construct_distanced_sequence(n)\\n  cur = Array.new(2*n - 1, 0)\\n  f(cur)\\nend\\n\\ndef f(cur)\\n    idx = cur.index(0)\\n    return cur.dup unless idx\\n    \\n    ((cur.size / 2 + 1).downto(1).to_a - cur).each do |d|\\n        j = d == 1 ? idx : idx + d\\n        next unless cur[j] == 0\\n        cur[idx] = d\\n        cur[j] = d\\n        t = f(cur)\\n        cur[idx] = 0\\n        cur[j] = 0\\n        return t if t\\n    end\\n    \\n    nil            \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1183253,
                "title": "cpp-backtrack",
                "content": "```\\n// https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/\\n//\\n// Time Complexity:     O(`n`!)\\n// Space Complexity:    O(`n`)\\n//\\n// Reference:\\n//  https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/discuss/1008913/C%2B%2B-Backtracking\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> ConstructDistancedSequence(int n)\\n    {\\n        vector<int> ans(2 * n - 1);\\n        vector<int> used;\\n        used.assign(n + 1, 0);\\n\\n        Backtrack(0, used, n, ans);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    bool Backtrack(int idx, vector<int> &used, const int kN, vector<int> &res)\\n    {\\n        const int kSize = res.size();\\n        const int kUsed = used.size();\\n\\n        if (idx == kSize)\\n            return true;\\n\\n        if (res[idx])\\n            return Backtrack(idx + 1, used, kN, res);\\n\\n        for (int num = kUsed - 1; num > 0; --num)\\n        {\\n            if (used[num])\\n                continue;\\n\\n            if (num != 1 && (idx + num >= kSize || res[idx + num]))\\n                continue;\\n\\n            used[num] = 1;\\n            res[idx] = num;\\n\\n            if (num != 1)\\n                res[idx + num] = num;\\n\\n            if (Backtrack(idx + 1, used, kN, res))\\n                return true;\\n\\n            res[idx] = 0;\\n\\n            if (num != 1)\\n                res[idx + num] = 0;\\n\\n            used[num] = 0;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n// https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/\\n//\\n// Time Complexity:     O(`n`!)\\n// Space Complexity:    O(`n`)\\n//\\n// Reference:\\n//  https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/discuss/1008913/C%2B%2B-Backtracking\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> ConstructDistancedSequence(int n)\\n    {\\n        vector<int> ans(2 * n - 1);\\n        vector<int> used;\\n        used.assign(n + 1, 0);\\n\\n        Backtrack(0, used, n, ans);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    bool Backtrack(int idx, vector<int> &used, const int kN, vector<int> &res)\\n    {\\n        const int kSize = res.size();\\n        const int kUsed = used.size();\\n\\n        if (idx == kSize)\\n            return true;\\n\\n        if (res[idx])\\n            return Backtrack(idx + 1, used, kN, res);\\n\\n        for (int num = kUsed - 1; num > 0; --num)\\n        {\\n            if (used[num])\\n                continue;\\n\\n            if (num != 1 && (idx + num >= kSize || res[idx + num]))\\n                continue;\\n\\n            used[num] = 1;\\n            res[idx] = num;\\n\\n            if (num != 1)\\n                res[idx + num] = num;\\n\\n            if (Backtrack(idx + 1, used, kN, res))\\n                return true;\\n\\n            res[idx] = 0;\\n\\n            if (num != 1)\\n                res[idx + num] = 0;\\n\\n            used[num] = 0;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1182538,
                "title": "backtracking-approach-c-100",
                "content": "```\\nvector<int> validseq(vector<int> &answer,vector<int> &remaining,int index)\\n    {\\n        if(index==answer.size())\\n            return answer;\\n        if(answer[index]!=0)\\n            return validseq(answer,remaining,index+1);\\n        for(int i=remaining.size()-1;i>0;i--)\\n        {\\n            if(remaining[i]==0)\\n                continue;\\n           \\n            if(i!=1 && i+index < answer.size() && answer[index+i]==0)\\n            {\\n                answer[index]=i;\\n                answer[index+i]=i;\\n                remaining[i]=0;\\n                vector<int> tempanswer=validseq(answer,remaining,index+1);\\n                if(!tempanswer.empty())\\n                    return tempanswer;\\n                answer[index]=0;\\n                answer[index+i]=0;\\n                remaining[i]=1;\\n            }\\n             if(i==1)\\n            {\\n                answer[index]=i;\\n                remaining[i]=0;\\n                vector<int> tempanswer=validseq(answer,remaining,index+1);\\n                if(!tempanswer.empty())\\n                    return tempanswer;\\n                answer[index]=0;\\n                remaining[i]=1;\\n            }\\n        }\\n        return {};\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> validseq(vector<int> &answer,vector<int> &remaining,int index)\\n    {\\n        if(index==answer.size())\\n            return answer;\\n        if(answer[index]!=0)\\n            return validseq(answer,remaining,index+1);\\n        for(int i=remaining.size()-1;i>0;i--)\\n        {\\n            if(remaining[i]==0)\\n                continue;\\n           \\n            if(i!=1 && i+index < answer.size() && answer[index+i]==0)\\n            {\\n                answer[index]=i;\\n                answer[index+i]=i;\\n                remaining[i]=0;\\n                vector<int> tempanswer=validseq(answer,remaining,index+1);\\n                if(!tempanswer.empty())\\n                    return tempanswer;\\n                answer[index]=0;\\n                answer[index+i]=0;\\n                remaining[i]=1;\\n            }\\n             if(i==1)\\n            {\\n                answer[index]=i;\\n                remaining[i]=0;\\n                vector<int> tempanswer=validseq(answer,remaining,index+1);\\n                if(!tempanswer.empty())\\n                    return tempanswer;\\n                answer[index]=0;\\n                remaining[i]=1;\\n            }\\n        }\\n        return {};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1181894,
                "title": "c-backtracking-based-0-ms-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> s,vector<int> &v,int i)\\n    {\\n        if(i>=v.size())  //base case\\n        {\\n            return true;\\n        }\\n        if(v[i]!=-1)  // if an index is already filled just increment the index\\n        {\\n            return solve(s,v,i+1);\\n        }\\n        for(int itr=s.size()-1;itr>=1;itr--)\\n        {\\n            if(s[itr]==1) continue;\\n            int temp=itr;\\n            if(temp==1)\\n            {\\n                v[i]=temp;\\n                s[itr]=1;\\n                if(solve(s,v,i+1)) return true;\\n                v[i]=-1;\\n                s[itr]=0;\\n                continue;\\n            }\\n            if(i+temp>=v.size()) return false;            \\n            if(v[i+temp]!=-1) continue;\\n\\n                v[i]=temp;\\n                v[i+temp]=temp;\\n                s[itr]=1;\\n                if(solve(s,v,i+1))  return true;\\n                s[itr]=0;\\n                v[i]=-1;\\n                v[i+temp]=-1;\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> s(n+1,0);  // 1 indexed boolean array for the selection of the values \\n        vector<int> v((2*(n-1))+1,-1);\\n        solve(s,v,0);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> s,vector<int> &v,int i)\\n    {\\n        if(i>=v.size())  //base case\\n        {\\n            return true;\\n        }\\n        if(v[i]!=-1)  // if an index is already filled just increment the index\\n        {\\n            return solve(s,v,i+1);\\n        }\\n        for(int itr=s.size()-1;itr>=1;itr--)\\n        {\\n            if(s[itr]==1) continue;\\n            int temp=itr;\\n            if(temp==1)\\n            {\\n                v[i]=temp;\\n                s[itr]=1;\\n                if(solve(s,v,i+1)) return true;\\n                v[i]=-1;\\n                s[itr]=0;\\n                continue;\\n            }\\n            if(i+temp>=v.size()) return false;            \\n            if(v[i+temp]!=-1) continue;\\n\\n                v[i]=temp;\\n                v[i+temp]=temp;\\n                s[itr]=1;\\n                if(solve(s,v,i+1))  return true;\\n                s[itr]=0;\\n                v[i]=-1;\\n                v[i+temp]=-1;\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> s(n+1,0);  // 1 indexed boolean array for the selection of the values \\n        vector<int> v((2*(n-1))+1,-1);\\n        solve(s,v,0);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169387,
                "title": "can-someone-please-help-me-getting-tle",
                "content": "```class Solution {\\npublic:\\n    void constructUtil(int n, vector<int>& res, vector<vector<int>>& ans, unordered_map<int, pair<int, int>>& freq, int i) {\\n        if(i == (2*n-1))\\n        {\\n            // for(auto x: res) {\\n            //     cout << x << endl;\\n            // }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int j = n; j >= 1 ; j--) {\\n            auto x = freq[j];\\n            int cnt = x.first;\\n            int ind = x.second;\\n            if(j == 1 && cnt < 1) {\\n                //cout << j << \" \" << cnt << \" \"<< ind  << \" \" << i << \" \" << endl;\\n                res.push_back(j);\\n                freq[j] = make_pair(cnt+1, i);\\n                constructUtil(n, res, ans, freq, i+1);\\n                res.pop_back();\\n                freq[j] = make_pair(cnt, ind);\\n            }\\n            else if(j != 1 && ((cnt == 0) || (cnt == 1 && abs(i - ind) == j))) {\\n                //cout << j << \" \" << cnt << \" \"<< ind  << \" \" << i << \" \" << endl;\\n                res.push_back(j);\\n                freq[j] = make_pair(cnt+1, i);\\n                constructUtil(n, res, ans, freq, i+1);\\n                res.pop_back();\\n                freq[j] = make_pair(cnt, ind);\\n            }\\n        }\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<vector<int>> ans; \\n        vector<int> res;\\n        unordered_map<int, pair<int, int>> freq;\\n        for(int i = 1; i <= n; i++) {\\n            pair<int, int> a;\\n            a.first = 0;\\n            a.second = -1;\\n            freq[i] = a;\\n        }\\n        constructUtil(n, res, ans, freq, 0);\\n        if(ans.size() > 0)\\n            return ans[0];\\n        else \\n            return res;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    void constructUtil(int n, vector<int>& res, vector<vector<int>>& ans, unordered_map<int, pair<int, int>>& freq, int i) {\\n        if(i == (2*n-1))\\n        {\\n            // for(auto x: res) {\\n            //     cout << x << endl;\\n            // }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int j = n; j >= 1 ; j--) {\\n            auto x = freq[j];\\n            int cnt = x.first;\\n            int ind = x.second;\\n            if(j == 1 && cnt < 1) {\\n                //cout << j << \" \" << cnt << \" \"<< ind  << \" \" << i << \" \" << endl;\\n                res.push_back(j);\\n                freq[j] = make_pair(cnt+1, i);\\n                constructUtil(n, res, ans, freq, i+1);\\n                res.pop_back();\\n                freq[j] = make_pair(cnt, ind);\\n            }\\n            else if(j != 1 && ((cnt == 0) || (cnt == 1 && abs(i - ind) == j))) {\\n                //cout << j << \" \" << cnt << \" \"<< ind  << \" \" << i << \" \" << endl;\\n                res.push_back(j);\\n                freq[j] = make_pair(cnt+1, i);\\n                constructUtil(n, res, ans, freq, i+1);\\n                res.pop_back();\\n                freq[j] = make_pair(cnt, ind);\\n            }\\n        }\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<vector<int>> ans; \\n        vector<int> res;\\n        unordered_map<int, pair<int, int>> freq;\\n        for(int i = 1; i <= n; i++) {\\n            pair<int, int> a;\\n            a.first = 0;\\n            a.second = -1;\\n            freq[i] = a;\\n        }\\n        constructUtil(n, res, ans, freq, 0);\\n        if(ans.size() > 0)\\n            return ans[0];\\n        else \\n            return res;\\n    }\\n};```",
                "codeTag": "C++"
            },
            {
                "id": 1149469,
                "title": "python3-backtrack-with-greedy-selection",
                "content": "Fill in the array of size 2n-1 one position each time. If it is occupied, go to the next location. Always choose larger digits first. Terminate early as soon as a solution is found.\\n\\n```python\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.ans = []\\n        self.free = {i for i in range(1, n+1)}\\n\\n        def backtrack(i, cur):\\n            if i == 2*n-1:\\n                self.ans = cur[:]\\n                return True\\n            if cur[i] != 0:\\n                return backtrack(i + 1, cur)\\n            for x in range(n, 0, -1):\\n                if x not in self.free:\\n                    continue\\n                if x == 1:\\n                    cur[i] = 1\\n                    self.free.discard(1)\\n                    if backtrack(i + 1, cur):\\n                        return True\\n                    self.free.add(1)\\n                    cur[i] = 0\\n                elif i + x < 2*n-1 and cur[i + x] == 0:\\n                    cur[i] = cur[i + x] = x\\n                    self.free.discard(x)\\n                    if backtrack(i + 1, cur):\\n                        return True\\n                    self.free.add(x)\\n                    cur[i] = cur[i + x] = 0\\n            return False\\n        \\n        backtrack(0, [0] * (2*n-1))\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.ans = []\\n        self.free = {i for i in range(1, n+1)}\\n\\n        def backtrack(i, cur):\\n            if i == 2*n-1:\\n                self.ans = cur[:]\\n                return True\\n            if cur[i] != 0:\\n                return backtrack(i + 1, cur)\\n            for x in range(n, 0, -1):\\n                if x not in self.free:\\n                    continue\\n                if x == 1:\\n                    cur[i] = 1\\n                    self.free.discard(1)\\n                    if backtrack(i + 1, cur):\\n                        return True\\n                    self.free.add(1)\\n                    cur[i] = 0\\n                elif i + x < 2*n-1 and cur[i + x] == 0:\\n                    cur[i] = cur[i + x] = x\\n                    self.free.discard(x)\\n                    if backtrack(i + 1, cur):\\n                        return True\\n                    self.free.add(x)\\n                    cur[i] = cur[i + x] = 0\\n            return False\\n        \\n        backtrack(0, [0] * (2*n-1))\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129563,
                "title": "greedy-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    int N;\\n    int L;\\n    vector<int> sol;\\n    bool util(int i)\\n    {\\n        if(i==N)\\n        {\\n            return true;\\n        }\\n        if(sol[i]!=0) return util(i+1);\\n        else\\n        {\\n            for(int x=L;x>=1;x--)\\n            {\\n                if(x==1)\\n                {\\n                    if(!vis[x] and sol[i]==0)\\n                    {\\n                        vis[x]=true;\\n                        sol[i]=x;\\n                        if(util(i+1)) return true;\\n                        sol[i]=0;\\n                        vis[x]=false;\\n                    }\\n                }\\n                else\\n                {\\n                    if(!vis[x] and sol[i]==0 and (i+x)<N and sol[i+x]==0)\\n                    {\\n                        \\n                        vis[x]=true;\\n                        sol[i]=x;\\n                        sol[i+x]=x;\\n                        if(util(i+1)) return true;\\n                        sol[i]=0;\\n                        sol[i+x]=0;\\n                        vis[x]=false;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vis.resize(n+1,false);\\n        L=n;\\n        N=2*(n-1)+1;\\n        sol.resize(N,0);\\n        util(0);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    int N;\\n    int L;\\n    vector<int> sol;\\n    bool util(int i)\\n    {\\n        if(i==N)\\n        {\\n            return true;\\n        }\\n        if(sol[i]!=0) return util(i+1);\\n        else\\n        {\\n            for(int x=L;x>=1;x--)\\n            {\\n                if(x==1)\\n                {\\n                    if(!vis[x] and sol[i]==0)\\n                    {\\n                        vis[x]=true;\\n                        sol[i]=x;\\n                        if(util(i+1)) return true;\\n                        sol[i]=0;\\n                        vis[x]=false;\\n                    }\\n                }\\n                else\\n                {\\n                    if(!vis[x] and sol[i]==0 and (i+x)<N and sol[i+x]==0)\\n                    {\\n                        \\n                        vis[x]=true;\\n                        sol[i]=x;\\n                        sol[i+x]=x;\\n                        if(util(i+1)) return true;\\n                        sol[i]=0;\\n                        sol[i+x]=0;\\n                        vis[x]=false;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vis.resize(n+1,false);\\n        L=n;\\n        N=2*(n-1)+1;\\n        sol.resize(N,0);\\n        util(0);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096205,
                "title": "python-simple-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.ans=[]\\n        temp=[None]*(n*2-1)\\n        self.helper(temp, [j for j in range(n, 0, -1)])\\n        return self.ans\\n    def helper(self, arr, num):\\n        if self.ans:\\n            return\\n        if not num:\\n            self.ans=[i for i in arr]\\n            return\\n        cur=next(i for i,j in enumerate(arr) if j==None)\\n        for k,j in enumerate(num):\\n            last=cur+j\\n            if j==1 and arr[cur]==None:\\n                arr[cur]=j\\n                self.helper(arr, num[:k]+num[k+1:])\\n                arr[cur]=None\\n            elif j!=1 and last<len(arr) and arr[cur]==arr[last]==None:\\n                arr[cur]=arr[last]=j\\n                self.helper(arr, num[:k]+num[k+1:])\\n                arr[cur]=arr[last]=None\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        self.ans=[]\\n        temp=[None]*(n*2-1)\\n        self.helper(temp, [j for j in range(n, 0, -1)])\\n        return self.ans\\n    def helper(self, arr, num):\\n        if self.ans:\\n            return\\n        if not num:\\n            self.ans=[i for i in arr]\\n            return\\n        cur=next(i for i,j in enumerate(arr) if j==None)\\n        for k,j in enumerate(num):\\n            last=cur+j\\n            if j==1 and arr[cur]==None:\\n                arr[cur]=j\\n                self.helper(arr, num[:k]+num[k+1:])\\n                arr[cur]=None\\n            elif j!=1 and last<len(arr) and arr[cur]==arr[last]==None:\\n                arr[cur]=arr[last]=j\\n                self.helper(arr, num[:k]+num[k+1:])\\n                arr[cur]=arr[last]=None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090152,
                "title": "python-readable-code-easy-to-understand-backtracking-greedy",
                "content": "Suggestions are welcome\\n\\n```\\ndef backtrack(candidates, result, start = 0):\\n    if len(candidates) <= 0:\\n        return True\\n\\n    if start >= len(result):\\n        return False\\n\\n    if result[start] != -1:\\n        return backtrack(candidates, result, start + 1)\\n\\n    for i in range(len(candidates)):\\n        num = candidates[i]\\n        dist = 0 if num == 1 else num\\n\\n        if (start + dist) < len(result) and result[start + dist] == -1:\\n            result[start] = num\\n            result[start + dist] = num\\n            candidates.pop(i)\\n\\n            if not backtrack(candidates, result, start):\\n                result[start] = -1\\n                result[start + dist] = -1\\n                candidates.insert(i, num)\\n                continue\\n            else:\\n                return True\\n\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        candidates = [ i for i in range(n,0,-1)]\\n        result = [ -1 for i in range(n*2 - 1)]\\n        backtrack(candidates, result)\\n        return result\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\ndef backtrack(candidates, result, start = 0):\\n    if len(candidates) <= 0:\\n        return True\\n\\n    if start >= len(result):\\n        return False\\n\\n    if result[start] != -1:\\n        return backtrack(candidates, result, start + 1)\\n\\n    for i in range(len(candidates)):\\n        num = candidates[i]\\n        dist = 0 if num == 1 else num\\n\\n        if (start + dist) < len(result) and result[start + dist] == -1:\\n            result[start] = num\\n            result[start + dist] = num\\n            candidates.pop(i)\\n\\n            if not backtrack(candidates, result, start):\\n                result[start] = -1\\n                result[start + dist] = -1\\n                candidates.insert(i, num)\\n                continue\\n            else:\\n                return True\\n\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        candidates = [ i for i in range(n,0,-1)]\\n        result = [ -1 for i in range(n*2 - 1)]\\n        backtrack(candidates, result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082104,
                "title": "python-3-true-o-n-using-doubly-linked-list",
                "content": "```\\nfrom contextlib import suppress\\n\\nclass Node:\\n    \\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n    \\n    def delete(self):\\n        self.prev.next = self.next\\n        self.next.prev = self.prev\\n    \\n    def restore(self):\\n        self.prev.next = self\\n        self.next.prev = self\\n\\n\\nclass DLL:\\n    \\n    def __init__(self):\\n        self.head = Node(-1)\\n        self.tail = Node(-1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n    \\n    def append(self, val):\\n        u = Node(val)\\n        u.prev = self.tail.prev\\n        u.next = self.tail\\n        self.tail.prev.next = u\\n        self.tail.prev = u\\n        \\n        \\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        \\n        ret = [-1] * (2*n-1)\\n        \\n        used = DLL()\\n        \\n        for val in range(n,0,-1):\\n            used.append(val)\\n        \\n        indices = DLL()\\n        index_node = {}\\n        \\n        for i in range(2*n-1):\\n            indices.append(i)\\n            index_node[i] = indices.tail.prev\\n        \\n        def recurse():\\n            \\n            if used.head.next == used.tail:\\n                raise StopIteration\\n            \\n            valnode = used.head.next\\n            idxnode = indices.head.next\\n            idx = idxnode.val\\n            \\n            while valnode != used.tail:\\n                \\n                val = valnode.val\\n                \\n                if val == 1:\\n                    \\n                    ret[idx] = 1\\n                    valnode.delete()\\n                    idxnode.delete()\\n                    recurse()\\n                    idxnode.restore()\\n                    valnode.restore()\\n                    ret[idx] = -1\\n                    \\n                else:\\n                    \\n                    idx2 = idx + val\\n                    \\n                    if idx2 < len(ret) and ret[idx2] == -1:\\n                        \\n                        idxnode2 = index_node[idx2]\\n                        \\n                        ret[idx] = valnode.val\\n                        ret[idx2] = valnode.val\\n                        valnode.delete()\\n                        idxnode.delete()\\n                        idxnode2.delete()\\n                        recurse()\\n                        idxnode2.restore()\\n                        idxnode.restore()\\n                        valnode.restore()\\n                        ret[idx2] = -1\\n                        ret[idx] = -1\\n\\n                valnode = valnode.next\\n        \\n        \\n        with suppress(StopIteration):\\n            recurse()\\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nfrom contextlib import suppress\\n\\nclass Node:\\n    \\n    def __init__(self, val):\\n        self.val = val\\n        self.prev = None\\n        self.next = None\\n    \\n    def delete(self):\\n        self.prev.next = self.next\\n        self.next.prev = self.prev\\n    \\n    def restore(self):\\n        self.prev.next = self\\n        self.next.prev = self\\n\\n\\nclass DLL:\\n    \\n    def __init__(self):\\n        self.head = Node(-1)\\n        self.tail = Node(-1)\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n    \\n    def append(self, val):\\n        u = Node(val)\\n        u.prev = self.tail.prev\\n        u.next = self.tail\\n        self.tail.prev.next = u\\n        self.tail.prev = u\\n        \\n        \\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        \\n        ret = [-1] * (2*n-1)\\n        \\n        used = DLL()\\n        \\n        for val in range(n,0,-1):\\n            used.append(val)\\n        \\n        indices = DLL()\\n        index_node = {}\\n        \\n        for i in range(2*n-1):\\n            indices.append(i)\\n            index_node[i] = indices.tail.prev\\n        \\n        def recurse():\\n            \\n            if used.head.next == used.tail:\\n                raise StopIteration\\n            \\n            valnode = used.head.next\\n            idxnode = indices.head.next\\n            idx = idxnode.val\\n            \\n            while valnode != used.tail:\\n                \\n                val = valnode.val\\n                \\n                if val == 1:\\n                    \\n                    ret[idx] = 1\\n                    valnode.delete()\\n                    idxnode.delete()\\n                    recurse()\\n                    idxnode.restore()\\n                    valnode.restore()\\n                    ret[idx] = -1\\n                    \\n                else:\\n                    \\n                    idx2 = idx + val\\n                    \\n                    if idx2 < len(ret) and ret[idx2] == -1:\\n                        \\n                        idxnode2 = index_node[idx2]\\n                        \\n                        ret[idx] = valnode.val\\n                        ret[idx2] = valnode.val\\n                        valnode.delete()\\n                        idxnode.delete()\\n                        idxnode2.delete()\\n                        recurse()\\n                        idxnode2.restore()\\n                        idxnode.restore()\\n                        valnode.restore()\\n                        ret[idx2] = -1\\n                        ret[idx] = -1\\n\\n                valnode = valnode.next\\n        \\n        \\n        with suppress(StopIteration):\\n            recurse()\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077941,
                "title": "c-dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, bool> memo; \\n    \\n    bool dfs(vector<int>& v, int i, int n){\\n        if(i == v.size())   return true;    \\n        if(v[i] > 0) return dfs(v, i+1, n);\\n        \\n        for(int j = n; j > 0; j--) {\\n            if(memo[j]) continue;\\n            if(j > 1) { \\n                if(j + i >= v.size() || v[j + i] > 0) continue;\\n            }\\n            memo[j] = true;\\n            v[i] = j;\\n            if(j > 1) v[j + i] = j;\\n            if(dfs(v, i + 1, n)) return true;\\n            v[i] = 0;\\n            if(j > 1) v[j + i] = 0;\\n            memo[j] = false;\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> vec((2 * n) - 1, 0);\\n        dfs(vec, 0, n);\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, bool> memo; \\n    \\n    bool dfs(vector<int>& v, int i, int n){\\n        if(i == v.size())   return true;    \\n        if(v[i] > 0) return dfs(v, i+1, n);\\n        \\n        for(int j = n; j > 0; j--) {\\n            if(memo[j]) continue;\\n            if(j > 1) { \\n                if(j + i >= v.size() || v[j + i] > 0) continue;\\n            }\\n            memo[j] = true;\\n            v[i] = j;\\n            if(j > 1) v[j + i] = j;\\n            if(dfs(v, i + 1, n)) return true;\\n            v[i] = 0;\\n            if(j > 1) v[j + i] = 0;\\n            memo[j] = false;\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> vec((2 * n) - 1, 0);\\n        dfs(vec, 0, n);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067558,
                "title": "c-bitmask-state-compression-dfs-backtracking",
                "content": "```c++\\n#define V vector<int>\\n\\nclass Solution {\\nprivate:\\n\\tbool is_found { false };\\n\\tint full { 0 };\\n\\tint n { 0 };\\n\\n\\tvoid f(V *res, int set, int idx) {\\n\\n\\t\\tif (is_found)\\n\\t\\t\\treturn;\\n\\t\\tif (idx >= res->size()) {\\n\\t\\t\\tif (set == full) {\\n\\t\\t\\t\\tthis->is_found = true;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (res->at(idx) != 0) {\\n\\t\\t\\tf(res, set, idx + 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tbool is_fill = false;\\n\\t\\tfor (int i = n - 1; i >= 1; i--) {\\n\\t\\t\\tif ((set & (1 << (i - 1))) == 0) {\\n\\n\\t\\t\\t\\tif (i == 1\\n\\t\\t\\t\\t\\t\\t|| (idx + i < res->size() && res->at(idx + i) == 0)) {\\n\\t\\t\\t\\t\\tis_fill = true;\\n\\n\\t\\t\\t\\t\\tres->at(idx) = i;\\n\\t\\t\\t\\t\\tif (i != 1)\\n\\t\\t\\t\\t\\t\\tres->at(idx + i) = i;\\n\\t\\t\\t\\t\\tf(res, set | (1 << (i - 1)), idx + 1);\\n\\t\\t\\t\\t\\tif (this->is_found)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tres->at(idx) = 0;\\n\\t\\t\\t\\t\\tif (i != 1)\\n\\t\\t\\t\\t\\t\\tres->at(idx + i) = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tif (!is_fill)\\n\\t\\t\\tf(res, set, idx + 1);\\n\\n\\t}\\n\\npublic:\\n\\n\\tV constructDistancedSequence(int n) {\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn {1};\\n\\n\\t\\tV res(2 * n - 1, 0);\\n\\t\\tres[0] = n;\\n\\t\\tres[n] = n;\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfull = full | (1 << i);\\n\\n\\t\\tint set = 0 | (1 << (n - 1));\\n\\t\\tthis->n = n;\\n\\n\\t\\tf(&res, set, 1);\\n\\n\\t\\treturn res;\\n\\n\\t}\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n#define V vector<int>\\n\\nclass Solution {\\nprivate:\\n\\tbool is_found { false };\\n\\tint full { 0 };\\n\\tint n { 0 };\\n\\n\\tvoid f(V *res, int set, int idx) {\\n\\n\\t\\tif (is_found)\\n\\t\\t\\treturn;\\n\\t\\tif (idx >= res->size()) {\\n\\t\\t\\tif (set == full) {\\n\\t\\t\\t\\tthis->is_found = true;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (res->at(idx) != 0) {\\n\\t\\t\\tf(res, set, idx + 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tbool is_fill = false;\\n\\t\\tfor (int i = n - 1; i >= 1; i--) {\\n\\t\\t\\tif ((set & (1 << (i - 1))) == 0) {\\n\\n\\t\\t\\t\\tif (i == 1\\n\\t\\t\\t\\t\\t\\t|| (idx + i < res->size() && res->at(idx + i) == 0)) {\\n\\t\\t\\t\\t\\tis_fill = true;\\n\\n\\t\\t\\t\\t\\tres->at(idx) = i;\\n\\t\\t\\t\\t\\tif (i != 1)\\n\\t\\t\\t\\t\\t\\tres->at(idx + i) = i;\\n\\t\\t\\t\\t\\tf(res, set | (1 << (i - 1)), idx + 1);\\n\\t\\t\\t\\t\\tif (this->is_found)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tres->at(idx) = 0;\\n\\t\\t\\t\\t\\tif (i != 1)\\n\\t\\t\\t\\t\\t\\tres->at(idx + i) = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tif (!is_fill)\\n\\t\\t\\tf(res, set, idx + 1);\\n\\n\\t}\\n\\npublic:\\n\\n\\tV constructDistancedSequence(int n) {\\n\\t\\tif (n == 1)\\n\\t\\t\\treturn {1};\\n\\n\\t\\tV res(2 * n - 1, 0);\\n\\t\\tres[0] = n;\\n\\t\\tres[n] = n;\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfull = full | (1 << i);\\n\\n\\t\\tint set = 0 | (1 << (n - 1));\\n\\t\\tthis->n = n;\\n\\n\\t\\tf(&res, set, 1);\\n\\n\\t\\treturn res;\\n\\n\\t}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062954,
                "title": "python-greedy-backtracking-with-explanation-and-comments",
                "content": "**Intuition** :- We apply backtracking only and try to prune the backtracking by applying greedy technique. So what we do in the greedy technique is that we start from the greatest number and check which ones haven\\'t been used before and place them in that position. If we are able to reach the end using the numbers in that decreasing order, then we don\\'t check the other combinations since those combinations would obviously be lexicographically smaller.\\n\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\t\\t# to check what all numbers have been used\\n        vis = [False] * (n + 1)\\n\\t\\t\\n\\t\\t# intermediate array to build the final sequence\\n        curr_list = [-1] * (2*n - 1)\\n        li, ans_list = self.recur(vis, curr_list, 0, n, n)\\n        return ans_list\\n        \\n    def recur(self, vis, curr_list, curr_ind, n, rem):\\n\\t\\t# base conditon which is to check that we have used all the \\'n\\' numbers\\n        if rem == 0:\\n            return True, curr_list\\n\\t\\t\\n\\t\\t# check what index we have to fill in the intermediate array\\n        while(curr_list[curr_ind] != -1 and curr_ind < 2 * n - 1):\\n            curr_ind += 1\\n        ans = False\\n        ans_list = None\\n        for i in range(len(vis) - 1, 0, -1):\\n\\t\\t\\taddition = i\\n\\t\\t\\t\\n\\t\\t\\t# special handling of \\'1\\'\\n            if i == 1:\\n                addition = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# only numbers that are not already used and check for feasibility using the constraints given\\n           if not vis[i] and self.check_feasible(curr_list, curr_ind, addition, n):\\n                vis[i] = True\\n                curr_list[curr_ind] = i\\n                curr_list[curr_ind + addition] = i\\n                is_list, li = self.recur(vis, curr_list, curr_ind + 1, n, rem - 1)\\n                if is_list:\\n                    ans = True\\n                    ans_list = li\\n                    break\\n                curr_list[curr_ind] = -1\\n                curr_list[curr_ind + addition] = -1\\n                vis[i] = False\\n        return ans, ans_list\\n    \\n    def check_feasible(self, curr_list, curr_ind, addition, n):\\n        if curr_ind + addition < 2*n - 1 and curr_list[curr_ind] == -1 and curr_list[curr_ind + addition] == -1:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\t\\t# to check what all numbers have been used\\n        vis = [False] * (n + 1)\\n\\t\\t\\n\\t\\t# intermediate array to build the final sequence\\n        curr_list = [-1] * (2*n - 1)\\n        li, ans_list = self.recur(vis, curr_list, 0, n, n)\\n        return ans_list\\n        \\n    def recur(self, vis, curr_list, curr_ind, n, rem):\\n\\t\\t# base conditon which is to check that we have used all the \\'n\\' numbers\\n        if rem == 0:\\n            return True, curr_list\\n\\t\\t\\n\\t\\t# check what index we have to fill in the intermediate array\\n        while(curr_list[curr_ind] != -1 and curr_ind < 2 * n - 1):\\n            curr_ind += 1\\n        ans = False\\n        ans_list = None\\n        for i in range(len(vis) - 1, 0, -1):\\n\\t\\t\\taddition = i\\n\\t\\t\\t\\n\\t\\t\\t# special handling of \\'1\\'\\n            if i == 1:\\n                addition = 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# only numbers that are not already used and check for feasibility using the constraints given\\n           if not vis[i] and self.check_feasible(curr_list, curr_ind, addition, n):\\n                vis[i] = True\\n                curr_list[curr_ind] = i\\n                curr_list[curr_ind + addition] = i\\n                is_list, li = self.recur(vis, curr_list, curr_ind + 1, n, rem - 1)\\n                if is_list:\\n                    ans = True\\n                    ans_list = li\\n                    break\\n                curr_list[curr_ind] = -1\\n                curr_list[curr_ind + addition] = -1\\n                vis[i] = False\\n        return ans, ans_list\\n    \\n    def check_feasible(self, curr_list, curr_ind, addition, n):\\n        if curr_ind + addition < 2*n - 1 and curr_list[curr_ind] == -1 and curr_list[curr_ind + addition] == -1:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057279,
                "title": "java-clean-dfs-solution-submission-time-beats-100",
                "content": "Time O(n^2) Space O(n)\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2 * n - 1];\\n        int[] nums = new int[n];\\n        // construct candidates: nums=[n, n-1, n-2, ..., 1]\\n        int i = 0;\\n        while (n > 0) {\\n            nums[i] = n;\\n            i++;\\n            n--;\\n        }\\n        dfs(res, 0, nums);\\n        return res;\\n    }\\n    \\n    private boolean dfs(int[] res, int index, int[] nums) {\\n        if (index == res.length) return true;\\n        if (res[index] != 0) return dfs(res, index + 1, nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            int currNum = nums[i];\\n            if (currNum == 0 || (currNum != 1 && (index + currNum >= res.length || res[index + currNum] != 0))) continue;\\n            nums[i] = 0; // mark nums[i] as visited\\n            res[index] = currNum;\\n            if (currNum != 1) {\\n                res[index + currNum] = currNum;\\n            }\\n            if (dfs(res, index + 1, nums)) {\\n                return true;\\n            }\\n            \\n            // go back to previous state\\n            nums[i] = currNum;\\n            res[index] = 0;\\n            if (currNum != 1) {\\n                res[index + currNum] = 0;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nLooking for improvements. Comments are highly welcomed.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2 * n - 1];\\n        int[] nums = new int[n];\\n        // construct candidates: nums=[n, n-1, n-2, ..., 1]\\n        int i = 0;\\n        while (n > 0) {\\n            nums[i] = n;\\n            i++;\\n            n--;\\n        }\\n        dfs(res, 0, nums);\\n        return res;\\n    }\\n    \\n    private boolean dfs(int[] res, int index, int[] nums) {\\n        if (index == res.length) return true;\\n        if (res[index] != 0) return dfs(res, index + 1, nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            int currNum = nums[i];\\n            if (currNum == 0 || (currNum != 1 && (index + currNum >= res.length || res[index + currNum] != 0))) continue;\\n            nums[i] = 0; // mark nums[i] as visited\\n            res[index] = currNum;\\n            if (currNum != 1) {\\n                res[index + currNum] = currNum;\\n            }\\n            if (dfs(res, index + 1, nums)) {\\n                return true;\\n            }\\n            \\n            // go back to previous state\\n            nums[i] = currNum;\\n            res[index] = 0;\\n            if (currNum != 1) {\\n                res[index + currNum] = 0;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020019,
                "title": "python-3-backtrack-with-explanation-better-than-99",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        def f(nums_to_try, l):\\n            if not nums_to_try:\\n                return l\\n            else:\\n                # index of el which we change\\n                i = l.index(0) \\n                # try all elements\\n                for n in nums_to_try: \\n                    # 1 can appear once, while other nums multiple times\\n                    if n == 1:\\n                        # swap and remove from to try list\\n                        l[i] = 1\\n                        left_to_try = [x for x in nums_to_try if x != n]\\n                        # find the solution with currently filled list\\n                        res = f(left_to_try, l)\\n                        # if found then keep returning since we want the first one\\n                        if res:\\n                            return res\\n                        l[i] = 0\\n                    elif i+n < len(l) and l[i+n] == 0:\\n\\t\\t\\t\\t\\t    # same as above just with two numbers\\n                        l[i] = n\\n                        l[i+n] = n\\n                        left_to_try = [x for x in nums_to_try if x != n]\\n                        res = f(left_to_try, l)\\n                        if res:\\n                            return res\\n                        l[i] = 0\\n                        l[i+n] = 0\\n                        \\n\\n        return f(range(n, 0, -1), [0] * (2*(n-1)+1))\\n                        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        def f(nums_to_try, l):\\n            if not nums_to_try:\\n                return l\\n            else:\\n                # index of el which we change\\n                i = l.index(0) \\n                # try all elements\\n                for n in nums_to_try: \\n                    # 1 can appear once, while other nums multiple times\\n                    if n == 1:\\n                        # swap and remove from to try list\\n                        l[i] = 1\\n                        left_to_try = [x for x in nums_to_try if x != n]\\n                        # find the solution with currently filled list\\n                        res = f(left_to_try, l)\\n                        # if found then keep returning since we want the first one\\n                        if res:\\n                            return res\\n                        l[i] = 0\\n                    elif i+n < len(l) and l[i+n] == 0:\\n\\t\\t\\t\\t\\t    # same as above just with two numbers\\n                        l[i] = n\\n                        l[i+n] = n\\n                        left_to_try = [x for x in nums_to_try if x != n]\\n                        res = f(left_to_try, l)\\n                        if res:\\n                            return res\\n                        l[i] = 0\\n                        l[i+n] = 0\\n                        \\n\\n        return f(range(n, 0, -1), [0] * (2*(n-1)+1))\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017667,
                "title": "c-backtrack",
                "content": "```\\npublic class Solution \\n{\\n    public int[] ConstructDistancedSequence(int n) \\n    {\\n        if (n == 1) return new int[1]{1};\\n        \\n        int length = 2*(n-1)+1;\\n        int[] curr = new int[length];\\n        Construct(curr, n, n, 0, new HashSet<int>());\\n        return curr;\\n    }\\n    \\n    private bool Construct(int[] curr, int val, int nodes, int pos, HashSet<int> visited)\\n    {\\n        if (visited.Count() == nodes) return true;\\n        \\n        for (int i=val; i>0; i--)\\n        {\\n            if (visited.Contains(i)) continue;\\n            \\n            if (i != 1 && (pos+i >= curr.Length || curr[pos+i] != 0)) continue;\\n            \\n            visited.Add(i);\\n            curr[pos] = i;\\n            if (i != 1) curr[pos+i] = i;\\n            \\n            int newPos = pos+1;\\n            while (newPos < curr.Length && curr[newPos] != 0) newPos++;\\n            \\n            if (Construct(curr, val, nodes, newPos, visited)) return true;\\n            \\n            curr[pos] = 0;\\n            if (i != 1) curr[pos+i] = 0;\\n            visited.Remove(i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[] ConstructDistancedSequence(int n) \\n    {\\n        if (n == 1) return new int[1]{1};\\n        \\n        int length = 2*(n-1)+1;\\n        int[] curr = new int[length];\\n        Construct(curr, n, n, 0, new HashSet<int>());\\n        return curr;\\n    }\\n    \\n    private bool Construct(int[] curr, int val, int nodes, int pos, HashSet<int> visited)\\n    {\\n        if (visited.Count() == nodes) return true;\\n        \\n        for (int i=val; i>0; i--)\\n        {\\n            if (visited.Contains(i)) continue;\\n            \\n            if (i != 1 && (pos+i >= curr.Length || curr[pos+i] != 0)) continue;\\n            \\n            visited.Add(i);\\n            curr[pos] = i;\\n            if (i != 1) curr[pos+i] = i;\\n            \\n            int newPos = pos+1;\\n            while (newPos < curr.Length && curr[newPos] != 0) newPos++;\\n            \\n            if (Construct(curr, val, nodes, newPos, visited)) return true;\\n            \\n            curr[pos] = 0;\\n            if (i != 1) curr[pos+i] = 0;\\n            visited.Remove(i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017478,
                "title": "java-greedy-bitmask-backtracking",
                "content": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[n * 2 - 1];\\n        int mask = (1 << n) - 1;\\n        dfs(n, 0, res, 0, mask);\\n        return res;\\n    }\\n    \\n    private boolean dfs(int n, int j, int[] res, int state, int mask) {\\n        if (state == mask) {\\n            return true;\\n        }\\n        if (j == res.length) {\\n            return false;\\n        }\\n        if (res[j] != 0) {\\n            return dfs(n, j + 1, res, state, mask);\\n        }\\n        for (int k = n; k > 0; k--) {\\n            if ((state & (1 << (k - 1))) != 0) {\\n                continue;\\n            }\\n            if (k == 1) {\\n                res[j] = k;\\n                if (dfs(n, j + 1, res, state ^ (1 << (k - 1)), mask)) {\\n                    return true;\\n                }\\n                res[j] = 0;\\n            }\\n            else if (j + k < res.length && res[j + k] == 0) {\\n                res[j + k] = k;\\n                res[j] = k;\\n                if (dfs(n, j + 1, res, state ^ (1 << (k - 1)), mask)) {\\n                    return true;\\n                }\\n                res[j + k] = 0;\\n                res[j] = 0;\\n            }\\n        }\\n        return false;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[n * 2 - 1];\\n        int mask = (1 << n) - 1;\\n        dfs(n, 0, res, 0, mask);\\n        return res;\\n    }\\n    \\n    private boolean dfs(int n, int j, int[] res, int state, int mask) {\\n        if (state == mask) {\\n            return true;\\n        }\\n        if (j == res.length) {\\n            return false;\\n        }\\n        if (res[j] != 0) {\\n            return dfs(n, j + 1, res, state, mask);\\n        }\\n        for (int k = n; k > 0; k--) {\\n            if ((state & (1 << (k - 1))) != 0) {\\n                continue;\\n            }\\n            if (k == 1) {\\n                res[j] = k;\\n                if (dfs(n, j + 1, res, state ^ (1 << (k - 1)), mask)) {\\n                    return true;\\n                }\\n                res[j] = 0;\\n            }\\n            else if (j + k < res.length && res[j + k] == 0) {\\n                res[j + k] = k;\\n                res[j] = k;\\n                if (dfs(n, j + 1, res, state ^ (1 << (k - 1)), mask)) {\\n                    return true;\\n                }\\n                res[j + k] = 0;\\n                res[j] = 0;\\n            }\\n        }\\n        return false;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016626,
                "title": "easy-c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>visit;\\n    bool solve(vector<int>&ans,int i,int n){\\n        if(i==2*n-1)return true;\\n        if(ans[i])return solve(ans,i+1,n);\\n        \\n        for(int j=n;j>=1;j--){\\n            if(!visit[j]){\\n                if(j!=1 && (i+j>=(2*n-1) || ans[i+j]!=0))continue;\\n                \\n                ans[i]=j;\\n                if(j!=1)ans[i+j]=j;\\n                visit[j]=1;\\n                \\n                bool res=solve(ans,i+1,n);\\n                \\n                if(res)return true;\\n                \\n                ans[i]=0;\\n                if(j!=1)ans[i+j]=0;\\n                visit[j]=0;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        visit.resize(n+1,0);\\n        vector<int>ans(2*n-1,0);\\n        solve(ans,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>visit;\\n    bool solve(vector<int>&ans,int i,int n){\\n        if(i==2*n-1)return true;\\n        if(ans[i])return solve(ans,i+1,n);\\n        \\n        for(int j=n;j>=1;j--){\\n            if(!visit[j]){\\n                if(j!=1 && (i+j>=(2*n-1) || ans[i+j]!=0))continue;\\n                \\n                ans[i]=j;\\n                if(j!=1)ans[i+j]=j;\\n                visit[j]=1;\\n                \\n                bool res=solve(ans,i+1,n);\\n                \\n                if(res)return true;\\n                \\n                ans[i]=0;\\n                if(j!=1)ans[i+j]=0;\\n                visit[j]=0;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    vector<int> constructDistancedSequence(int n) {\\n        visit.resize(n+1,0);\\n        vector<int>ans(2*n-1,0);\\n        solve(ans,0,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015857,
                "title": "javascript-dfs-bitmask-80ms",
                "content": "```\\nconst constructDistancedSequence = (n) => {\\n    let a = Array(2 * n - 1).fill(0);\\n    return dfs(0, a, (1 << n + 1) - 2);\\n};\\n\\nconst dfs = (pos, a, rem) => {\\n    if (pos == a.length) return a;\\n    if (a[pos] > 0) return dfs(pos + 1, a, rem);\\n    for (let i = 20; i >= 1; i--) {\\n        if (rem << ~i < 0) {\\n            if (i > 1 && pos + i < a.length && a[pos + i] == 0) {\\n                a[pos] = a[pos + i] = i;\\n                let res = dfs(pos + 1, a, rem ^ 1 << i);\\n                if (res != null) return res;\\n                a[pos] = a[pos + i] = 0;\\n            } else if (i == 1) {\\n                a[pos] = 1;\\n                let res = dfs(pos + 1, a, rem ^ 1 << 1);\\n                if (res != null) return res;\\n                a[pos] = 0;\\n            }\\n        }\\n    }\\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst constructDistancedSequence = (n) => {\\n    let a = Array(2 * n - 1).fill(0);\\n    return dfs(0, a, (1 << n + 1) - 2);\\n};\\n\\nconst dfs = (pos, a, rem) => {\\n    if (pos == a.length) return a;\\n    if (a[pos] > 0) return dfs(pos + 1, a, rem);\\n    for (let i = 20; i >= 1; i--) {\\n        if (rem << ~i < 0) {\\n            if (i > 1 && pos + i < a.length && a[pos + i] == 0) {\\n                a[pos] = a[pos + i] = i;\\n                let res = dfs(pos + 1, a, rem ^ 1 << i);\\n                if (res != null) return res;\\n                a[pos] = a[pos + i] = 0;\\n            } else if (i == 1) {\\n                a[pos] = 1;\\n                let res = dfs(pos + 1, a, rem ^ 1 << 1);\\n                if (res != null) return res;\\n                a[pos] = 0;\\n            }\\n        }\\n    }\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1012424,
                "title": "c-dfs",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<int> used;\\n    int n;\\n    int m;\\n    bool dfs(int j, int r)\\n    {\\n        if (r == 0)\\n        {\\n            return true;\\n        }\\n        while (arr[j] != 0)\\n        {\\n            j++;\\n        };\\n        for (int k = n; k >= 1; k--)\\n        {\\n            if (used[k] == 1)\\n            {\\n                continue;\\n            }\\n            int d = (k == 1) ? 0 : k;\\n            if (j + d < m && arr[j + d] == 0)\\n            {\\n                used[k] = 1;\\n                arr[j] = k;\\n                arr[j + d] = k;\\n                bool res = dfs(j + 1, r - 1);\\n                if (res)\\n                {\\n                    return res;\\n                }\\n                arr[j + d] = 0;\\n                arr[j] = 0;\\n                used[k] = 0;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n1) {\\n        n = n1;\\n        arr.resize(2 * n - 1, 0);\\n        m = arr.size();\\n        used = vector<int>(n + 1, 0);\\n        dfs(0, n);\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<int> used;\\n    int n;\\n    int m;\\n    bool dfs(int j, int r)\\n    {\\n        if (r == 0)\\n        {\\n            return true;\\n        }\\n        while (arr[j] != 0)\\n        {\\n            j++;\\n        };\\n        for (int k = n; k >= 1; k--)\\n        {\\n            if (used[k] == 1)\\n            {\\n                continue;\\n            }\\n            int d = (k == 1) ? 0 : k;\\n            if (j + d < m && arr[j + d] == 0)\\n            {\\n                used[k] = 1;\\n                arr[j] = k;\\n                arr[j + d] = k;\\n                bool res = dfs(j + 1, r - 1);\\n                if (res)\\n                {\\n                    return res;\\n                }\\n                arr[j + d] = 0;\\n                arr[j] = 0;\\n                used[k] = 0;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> constructDistancedSequence(int n1) {\\n        n = n1;\\n        arr.resize(2 * n - 1, 0);\\n        m = arr.size();\\n        used = vector<int>(n + 1, 0);\\n        dfs(0, n);\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011583,
                "title": "java-solution-backtracking",
                "content": "```\\nclass Solution {\\n    \\n    boolean f(int[] arr, boolean[] chk, int i){\\n        if(i>=arr.length-1) return true;\\n        if(arr[i]!=0) return f(arr, chk, i+1);\\n        for(int j=chk.length-1; j>=1; j--){\\n            if(chk[j]) continue;\\n            int add = (j==1?0:j);\\n            if(i+add >= arr.length) continue;\\n            if(arr[i]==0 && arr[i+add]==0){\\n                chk[j]=true;\\n                arr[i]=arr[i+add]=j;\\n                if(f(arr, chk, i+1)) return true;\\n                else arr[i]=arr[i+add]=0;\\n                chk[j]=false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int[] constructDistancedSequence(int n) {\\n        int[] arr = new int[n*2-1];\\n        f(arr, new boolean[n+1], 0);\\n        for(int i=0; i<arr.length; i++)\\n            if(arr[i]==0){\\n                arr[i]=1; break;\\n            }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    boolean f(int[] arr, boolean[] chk, int i){\\n        if(i>=arr.length-1) return true;\\n        if(arr[i]!=0) return f(arr, chk, i+1);\\n        for(int j=chk.length-1; j>=1; j--){\\n            if(chk[j]) continue;\\n            int add = (j==1?0:j);\\n            if(i+add >= arr.length) continue;\\n            if(arr[i]==0 && arr[i+add]==0){\\n                chk[j]=true;\\n                arr[i]=arr[i+add]=j;\\n                if(f(arr, chk, i+1)) return true;\\n                else arr[i]=arr[i+add]=0;\\n                chk[j]=false;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int[] constructDistancedSequence(int n) {\\n        int[] arr = new int[n*2-1];\\n        f(arr, new boolean[n+1], 0);\\n        for(int i=0; i<arr.length; i++)\\n            if(arr[i]==0){\\n                arr[i]=1; break;\\n            }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011295,
                "title": "simple-c-recursive-solution-advice-appreciated",
                "content": "\\nalgo:\\nfind position of next 0 in answer array\\n--if 0 is found\\n--set flag for incompleteness\\n--test the highest remaining value at position==position+value is empty\\n----if the value fits, remove the value from remaining possible values and increment position in answer array\\nwhen 0 not found return answer array\\n\\n\\n```\\nprivate:\\n    int *ans;\\n    bool tryNext(int *arr,int lc,bool *ns,int n){\\n        bool foundN=false;\\n        while(arr[lc]!=0 && lc<2*n-1)lc++;\\n        for(int i=n;i>0;i--) {\\n            if (!ns[i - 1]) {\\n                foundN = true;\\n                if (i == 1 || (lc + i < (2 * n - 1) && arr[lc + i] == 0)) {\\n                    int *t = new int[2 * n + 1];  //I should have recursively undone my changes instead of creating all these arrays\\n                    memcpy(t, arr, (2 * n - 1) * sizeof(int));  //how do I use the copy array constructor with dynamically sized arrays\\n                    //tentatively set\\n                    t[lc] = i;\\n                    if (i != 1)t[lc + i] = i;\\n                    ns[i - 1] = 1;\\n                    //test\\n                    if (tryNext(t, lc + 1, ns, n)) return true;\\n                    ns[i - 1] = 0;//assertion failed - not worried about memory of t[] for this problem\\n                }\\n            }\\n        }\\n        ans=arr;  //how do I properly recursively return a second value in c++ without structs making it messy?\\n        return !foundN;\\n    }\\npublic:\\n    vector<int> constructDistancedSequence(int n){\\n        bool *ns = new bool[n]();//bool[] is a c++ bitset?\\n        ans = new int[2 * n - 1]();\\n\\n        tryNext(ans,0,ns,n);\\n        return *new vector<int>(ans,ans+(2*n-1));\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nprivate:\\n    int *ans;\\n    bool tryNext(int *arr,int lc,bool *ns,int n){\\n        bool foundN=false;\\n        while(arr[lc]!=0 && lc<2*n-1)lc++;\\n        for(int i=n;i>0;i--) {\\n            if (!ns[i - 1]) {\\n                foundN = true;\\n                if (i == 1 || (lc + i < (2 * n - 1) && arr[lc + i] == 0)) {\\n                    int *t = new int[2 * n + 1];  //I should have recursively undone my changes instead of creating all these arrays\\n                    memcpy(t, arr, (2 * n - 1) * sizeof(int));  //how do I use the copy array constructor with dynamically sized arrays\\n                    //tentatively set\\n                    t[lc] = i;\\n                    if (i != 1)t[lc + i] = i;\\n                    ns[i - 1] = 1;\\n                    //test\\n                    if (tryNext(t, lc + 1, ns, n)) return true;\\n                    ns[i - 1] = 0;//assertion failed - not worried about memory of t[] for this problem\\n                }\\n            }\\n        }\\n        ans=arr;  //how do I properly recursively return a second value in c++ without structs making it messy?\\n        return !foundN;\\n    }\\npublic:\\n    vector<int> constructDistancedSequence(int n){\\n        bool *ns = new bool[n]();//bool[] is a c++ bitset?\\n        ans = new int[2 * n - 1]();\\n\\n        tryNext(ans,0,ns,n);\\n        return *new vector<int>(ans,ans+(2*n-1));\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010857,
                "title": "c-backtracking-stl-8ms-easy-to-read",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint sz;\\n\\t\\tint N;\\n\\n\\t\\tbool backtrack(int i, vector<int> &ans, vector<bool> &seen)\\n\\t\\t{\\n\\t\\t\\tif(i == sz)\\n\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\tif(ans[i] != 0)\\n\\t\\t\\t\\treturn backtrack(i+1, ans, seen);\\n\\n\\t\\t\\tfor(int num=N; num>=1; num--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!seen[num])                \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans[i] = 1;\\n\\t\\t\\t\\t\\t\\tseen[1] = 1;\\n\\n\\t\\t\\t\\t\\t\\tif(backtrack(i+1, ans, seen))\\n\\t\\t\\t\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\t\\t\\t\\tans[i] = 0;\\n\\t\\t\\t\\t\\t\\tseen[1] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!seen[num] && i+num < sz && ans[i+num] == 0)                \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans[i] = ans[i+num] = num;\\n\\t\\t\\t\\t\\t\\tseen[num] = 1;\\n\\n\\t\\t\\t\\t\\t\\tif(backtrack(i+1, ans, seen))\\n\\t\\t\\t\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\t\\t\\t\\tans[i] = ans[i+num] = 0;\\n\\t\\t\\t\\t\\t\\tseen[num] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> constructDistancedSequence(int n) {\\n\\t\\t\\tsz = 1 + 2*(n-1);\\n\\t\\t\\tN = n;\\n\\n\\t\\t\\tvector<int> ans(sz, 0);\\n\\t\\t\\tvector<bool> seen(n+1, 0);\\n\\n\\t\\t\\tbacktrack(0, ans, seen);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint sz;\\n\\t\\tint N;\\n\\n\\t\\tbool backtrack(int i, vector<int> &ans, vector<bool> &seen)\\n\\t\\t{\\n\\t\\t\\tif(i == sz)\\n\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\tif(ans[i] != 0)\\n\\t\\t\\t\\treturn backtrack(i+1, ans, seen);\\n\\n\\t\\t\\tfor(int num=N; num>=1; num--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(num == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(!seen[num])                \\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans[i] = 1;\\n\\t\\t\\t\\t\\t\\tseen[1] = 1;\\n\\n\\t\\t\\t\\t\\t\\tif(backtrack(i+1, ans, seen))\\n\\t\\t\\t\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\t\\t\\t\\tans[i] = 0;\\n\\t\\t\\t\\t\\t\\tseen[1] = 0;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1010582,
                "title": "python3-explanation-runtime-and-space-analysis-recursion",
                "content": "**Explanation**\\nThe idea is to first create an array of size `2*n - 1` and then to examine each index one by one. In order to achieve this, a recursive function is called for each index. The function is defined as followed:\\n\\n1. if the index is out of range, return the built sequence since it is the largest valid one lexicographically.\\n2. If there is a number on the current position, head over to the next position.\\n3. If there is no number on the current position which marked by the value `None`, do the following:\\nLoop through all numbers from `n` down to `1` and whenever a number occurs which has not been used yet, check if `current_position + number` is a valid position or if the given number is `1`. If this is the case, set the value on both positions and head over to the next index. The number will also be marked as used.\\n\\nAs soon as the position is out of range, the largest sequence has been found since we use the greatest numbers for each position first.\\n____________________________\\n**Time Complexity**\\nNaive answer: `O((2*n - 1) + n^n)` = `O(n^n)`\\n____________________________\\n**Space Complexity**\\n`O(n)` for storing the output and due to recursion.\\n___________________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def construct_sequence(self, sequence, sequence_index, n, number_free):\\n        if sequence_index == len(sequence):\\n            return sequence\\n        elif sequence[sequence_index] is not None:\\n            return self.construct_sequence(sequence, sequence_index + 1, n, number_free)\\n        else:\\n            next_sequence_index = sequence_index + 1\\n            \\n            for i in range(n, 0, -1):\\n                if number_free[i] and (i == 1 or sequence_index + i < len(sequence) and sequence[sequence_index + i] is None):\\n                    number_free[i] = False\\n                    sequence[sequence_index] = i\\n                    \\n                    if i != 1:\\n                        sequence[sequence_index + i] = i\\n\\n                    if self.construct_sequence(sequence, next_sequence_index, n, number_free) is not None:\\n                        return sequence\\n                    else:\\n                        sequence[sequence_index] = None\\n                        \\n                        if i != 1:\\n                            sequence[sequence_index + i] = None\\n                        \\n                        number_free[i] = True\\n\\n            return None\\n        \\n        \\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        number_free = [True] * (n + 1)\\n        sequence = [None] * (2*n - 1)\\n        return self.construct_sequence(sequence, 0, n, number_free)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def construct_sequence(self, sequence, sequence_index, n, number_free):\\n        if sequence_index == len(sequence):\\n            return sequence\\n        elif sequence[sequence_index] is not None:\\n            return self.construct_sequence(sequence, sequence_index + 1, n, number_free)\\n        else:\\n            next_sequence_index = sequence_index + 1\\n            \\n            for i in range(n, 0, -1):\\n                if number_free[i] and (i == 1 or sequence_index + i < len(sequence) and sequence[sequence_index + i] is None):\\n                    number_free[i] = False\\n                    sequence[sequence_index] = i\\n                    \\n                    if i != 1:\\n                        sequence[sequence_index + i] = i\\n\\n                    if self.construct_sequence(sequence, next_sequence_index, n, number_free) is not None:\\n                        return sequence\\n                    else:\\n                        sequence[sequence_index] = None\\n                        \\n                        if i != 1:\\n                            sequence[sequence_index + i] = None\\n                        \\n                        number_free[i] = True\\n\\n            return None\\n        \\n        \\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        number_free = [True] * (n + 1)\\n        sequence = [None] * (2*n - 1)\\n        return self.construct_sequence(sequence, 0, n, number_free)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010478,
                "title": "java-100-backtracking-greedy",
                "content": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] result = new int[(n-1)*2+1];\\n        boolean[] visited = new boolean[n+1];\\n        \\n        construct(0, result, visited);\\n        \\n        return result;\\n    }\\n    \\n    private boolean construct(int index, int[] result, boolean[] visited) {\\n        if(index == result.length) {\\n            return true;\\n        }\\n        \\n        //If resultant index is empty\\n        if(result[index] == 0) {\\n            //try to insert max num first (Lexicographically Largest)\\n            for(int n = visited.length-1; n >= 1; n--) { \\n                //If n is not visited\\n                if(!visited[n]) {\\n                    if(n == 1) {\\n                        visited[n] = true;\\n                        result[index] = n;\\n                        //Go to the next index\\n                        if(construct(index+1, result, visited)) return true;\\n                    } else if(index+n < result.length && result[index+n] == 0) {\\n                        visited[n] = true;\\n                        result[index] = n;\\n                        result[index+n] = n;\\n                        //Go to the next index\\n                        if(construct(index+1, result, visited)) return true;\\n                        //Unvisit if find false\\n                        result[index+n] = 0;\\n                    }\\n                    //Unvisit if find false\\n                    visited[n] = false;\\n                    result[index] = 0;\\n                }\\n            }\\n        } else if(result[index] != 0) {\\n            return construct(index+1, result, visited);\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] result = new int[(n-1)*2+1];\\n        boolean[] visited = new boolean[n+1];\\n        \\n        construct(0, result, visited);\\n        \\n        return result;\\n    }\\n    \\n    private boolean construct(int index, int[] result, boolean[] visited) {\\n        if(index == result.length) {\\n            return true;\\n        }\\n        \\n        //If resultant index is empty\\n        if(result[index] == 0) {\\n            //try to insert max num first (Lexicographically Largest)\\n            for(int n = visited.length-1; n >= 1; n--) { \\n                //If n is not visited\\n                if(!visited[n]) {\\n                    if(n == 1) {\\n                        visited[n] = true;\\n                        result[index] = n;\\n                        //Go to the next index\\n                        if(construct(index+1, result, visited)) return true;\\n                    } else if(index+n < result.length && result[index+n] == 0) {\\n                        visited[n] = true;\\n                        result[index] = n;\\n                        result[index+n] = n;\\n                        //Go to the next index\\n                        if(construct(index+1, result, visited)) return true;\\n                        //Unvisit if find false\\n                        result[index+n] = 0;\\n                    }\\n                    //Unvisit if find false\\n                    visited[n] = false;\\n                    result[index] = 0;\\n                }\\n            }\\n        } else if(result[index] != 0) {\\n            return construct(index+1, result, visited);\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009796,
                "title": "how-time-complexity-for-this-problem-is-far-less-than-o-n",
                "content": "\\nCan anyone give the logical explanation of how time complexity for this problem is far less than O(N!) because of which TC passed. I think the constraint to store the same value at j and i+j index had made this possible. But not able to understand how?",
                "solutionTags": [],
                "code": "\\nCan anyone give the logical explanation of how time complexity for this problem is far less than O(N!) because of which TC passed. I think the constraint to store the same value at j and i+j index had made this possible. But not able to understand how?",
                "codeTag": "Unknown"
            },
            {
                "id": 1009759,
                "title": "python-clean-self-explained-greedy-backtracking",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        l = [None] * (2*n-1)\\n        filled = set()\\n        \\n        def can_fill(k, i):\\n            if k == 1:\\n                return l[i] == None\\n            return i+k < len(l) and l[i] == l[i+k] == None\\n        \\n        def _fill(k, i, m):\\n            if k == 1:\\n                l[i] = m\\n            else:\\n                l[i] = l[i+k] = m\\n        \\n        def fill(k, i):\\n            filled.add(k)\\n            _fill(k, i, k)\\n        \\n        def erase(k, i):\\n            filled.remove(k)\\n            _fill(k, i, None)\\n            \\n        \\n        def bt(i):\\n            if i == len(l):\\n                return True\\n            if l[i] is not None:\\n                return bt(i+1)\\n            \\n            for k in range(n, 0, -1):\\n                if k in filled or not can_fill(k, i):\\n                    continue\\n                    \\n                fill(k, i)\\n                if bt(i+1):\\n                    return True\\n                erase(k, i)\\n                        \\n        bt(0)\\n        return l\\n```\\n\\nOr using `twins` to generalize the case `k == 1`\\n\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        l = [None] * (2*n-1)\\n        filled = set()\\n        \\n        def twins(i, k):\\n            return i if k == 1 else i + k\\n            \\n        def can_fill(k, i):\\n            return twins(i, k) < len(l) and l[i] == l[twins(i, k)] == None\\n        \\n        def _fill(k, i, m):\\n            l[i] = l[twins(i, k)] = m\\n        \\n        def fill(k, i):\\n            filled.add(k)\\n            _fill(k, i, k)\\n        \\n        def erase(k, i):\\n            filled.remove(k)\\n            _fill(k, i, None)\\n        \\n        def bt(i):\\n            if i == len(l):\\n                return True\\n            if l[i] is not None:\\n                return bt(i+1)\\n            \\n            for k in range(n, 0, -1):\\n                if k in filled or not can_fill(k, i):\\n                    continue\\n                    \\n                fill(k, i)\\n                if bt(i+1):\\n                    return True\\n                erase(k, i)\\n                        \\n        bt(0)\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        l = [None] * (2*n-1)\\n        filled = set()\\n        \\n        def can_fill(k, i):\\n            if k == 1:\\n                return l[i] == None\\n            return i+k < len(l) and l[i] == l[i+k] == None\\n        \\n        def _fill(k, i, m):\\n            if k == 1:\\n                l[i] = m\\n            else:\\n                l[i] = l[i+k] = m\\n        \\n        def fill(k, i):\\n            filled.add(k)\\n            _fill(k, i, k)\\n        \\n        def erase(k, i):\\n            filled.remove(k)\\n            _fill(k, i, None)\\n            \\n        \\n        def bt(i):\\n            if i == len(l):\\n                return True\\n            if l[i] is not None:\\n                return bt(i+1)\\n            \\n            for k in range(n, 0, -1):\\n                if k in filled or not can_fill(k, i):\\n                    continue\\n                    \\n                fill(k, i)\\n                if bt(i+1):\\n                    return True\\n                erase(k, i)\\n                        \\n        bt(0)\\n        return l\\n```\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        l = [None] * (2*n-1)\\n        filled = set()\\n        \\n        def twins(i, k):\\n            return i if k == 1 else i + k\\n            \\n        def can_fill(k, i):\\n            return twins(i, k) < len(l) and l[i] == l[twins(i, k)] == None\\n        \\n        def _fill(k, i, m):\\n            l[i] = l[twins(i, k)] = m\\n        \\n        def fill(k, i):\\n            filled.add(k)\\n            _fill(k, i, k)\\n        \\n        def erase(k, i):\\n            filled.remove(k)\\n            _fill(k, i, None)\\n        \\n        def bt(i):\\n            if i == len(l):\\n                return True\\n            if l[i] is not None:\\n                return bt(i+1)\\n            \\n            for k in range(n, 0, -1):\\n                if k in filled or not can_fill(k, i):\\n                    continue\\n                    \\n                fill(k, i)\\n                if bt(i+1):\\n                    return True\\n                erase(k, i)\\n                        \\n        bt(0)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009687,
                "title": "c-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        if(n == 0) {\\n            return {};\\n        }\\n        \\n        int len = 2*(n - 1) + 1, cnt = 0;\\n        vector<int> ans(len, -1);\\n        vector<bool> vis(n + 1, false);\\n        bool isFind = false;\\n        dfs(ans, n, len, vis, 0, 0, isFind);\\n        return ans;\\n    }\\nprivate:\\n    void dfs(vector<int> &ans, int n, int len, vector<bool> &vis, int idx, int cnt, bool &isFind) {\\n        if(cnt >= len || idx >= len) {\\n            isFind = true;\\n            return ;\\n        }\\n        if(idx < len && ans[idx] != -1) {\\n            dfs(ans, n, len, vis, idx + 1, cnt, isFind);\\n            return ;\\n        }\\n        for(int i = n; i > 0; -- i) {\\n            if(vis[i]) {\\n                continue;\\n            }\\n            if(i == 1) {\\n                ans[idx] = 1;\\n                vis[i] = true;\\n                dfs(ans, n, len, vis, idx + 1, cnt + 1, isFind);\\n                if(isFind) {\\n                    return ;\\n                }\\n                ans[idx] = -1;\\n                vis[i] = false;\\n                continue;\\n            }\\n            if(idx + i >= len || ans[idx + i] != -1) {\\n                continue;\\n            }\\n            ans[idx] = ans[idx + i] = i;\\n            vis[i] = true;\\n            dfs(ans, n, len, vis, idx + 1, cnt + 2, isFind);\\n            if(isFind) {\\n                return ;\\n            }\\n            ans[idx] = ans[idx + i] = -1;\\n            vis[i] = false;\\n        }\\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        if(n == 0) {\\n            return {};\\n        }\\n        \\n        int len = 2*(n - 1) + 1, cnt = 0;\\n        vector<int> ans(len, -1);\\n        vector<bool> vis(n + 1, false);\\n        bool isFind = false;\\n        dfs(ans, n, len, vis, 0, 0, isFind);\\n        return ans;\\n    }\\nprivate:\\n    void dfs(vector<int> &ans, int n, int len, vector<bool> &vis, int idx, int cnt, bool &isFind) {\\n        if(cnt >= len || idx >= len) {\\n            isFind = true;\\n            return ;\\n        }\\n        if(idx < len && ans[idx] != -1) {\\n            dfs(ans, n, len, vis, idx + 1, cnt, isFind);\\n            return ;\\n        }\\n        for(int i = n; i > 0; -- i) {\\n            if(vis[i]) {\\n                continue;\\n            }\\n            if(i == 1) {\\n                ans[idx] = 1;\\n                vis[i] = true;\\n                dfs(ans, n, len, vis, idx + 1, cnt + 1, isFind);\\n                if(isFind) {\\n                    return ;\\n                }\\n                ans[idx] = -1;\\n                vis[i] = false;\\n                continue;\\n            }\\n            if(idx + i >= len || ans[idx + i] != -1) {\\n                continue;\\n            }\\n            ans[idx] = ans[idx + i] = i;\\n            vis[i] = true;\\n            dfs(ans, n, len, vis, idx + 1, cnt + 2, isFind);\\n            if(isFind) {\\n                return ;\\n            }\\n            ans[idx] = ans[idx + i] = -1;\\n            vis[i] = false;\\n        }\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009587,
                "title": "python-java-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef constructDistancedSequence(self, n: int) -> List[int]:\\n\\t\\t\\tres = [0] * (n * 2 - 1)\\n\\t\\t\\tseen = set()\\n\\t\\t\\tdef backtracking(i):\\n\\t\\t\\t\\tif i == len(res):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif res[i] != 0:\\n\\t\\t\\t\\t\\treturn backtracking(i + 1)\\n\\t\\t\\t\\tfor j in range(n, 0, -1):\\n\\t\\t\\t\\t\\tif j == 1 and j not in seen:\\n\\t\\t\\t\\t\\t\\tres[i] = j\\n\\t\\t\\t\\t\\t\\tseen.add(j)\\n\\t\\t\\t\\t\\t\\tif backtracking(i + 1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\tres[i] = 0\\n\\t\\t\\t\\t\\t\\tseen.remove(j)\\n\\t\\t\\t\\t\\telif j != 1 and i + j < len(res) and res[i + j] == 0 and j not in seen:\\n\\t\\t\\t\\t\\t\\tres[i] = j\\n\\t\\t\\t\\t\\t\\tres[i + j] = j\\n\\t\\t\\t\\t\\t\\tseen.add(j)\\n\\t\\t\\t\\t\\t\\tif backtracking(i + 1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\tres[i] = 0\\n\\t\\t\\t\\t\\t\\tres[i + j] = 0\\n\\t\\t\\t\\t\\t\\tseen.remove(j)\\n\\t\\t\\tbacktracking(0)\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int[] constructDistancedSequence(int n) {\\n\\t\\t\\tint[] res = new int[n * 2 - 1];\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\tbacktracking(n, seen, 0, res);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tprivate boolean backtracking(int n, Set<Integer> seen, int i, int[] res){\\n\\t\\t\\tif (i == res.length){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tif (res[i] != 0){\\n\\t\\t\\t\\treturn backtracking(n, seen, i + 1, res);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j = n; j > 0; j --){\\n\\t\\t\\t\\tif (j == 1 && !seen.contains(j)){\\n\\t\\t\\t\\t\\tres[i] = j;\\n\\t\\t\\t\\t\\tseen.add(j);\\n\\t\\t\\t\\t\\tif (backtracking(n, seen, i + 1, res)){\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tres[i] = 0;\\n\\t\\t\\t\\t\\tseen.remove(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (j != 1 && !seen.contains(j) && i + j < res.length && res[i + j] == 0){\\n\\t\\t\\t\\t\\tres[i] = j;\\n\\t\\t\\t\\t\\tres[i + j] = j;\\n\\t\\t\\t\\t\\tseen.add(j);\\n\\t\\t\\t\\t\\tif (backtracking(n, seen, i + 1, res)){\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tres[i] = 0;\\n\\t\\t\\t\\t\\tres[i + j] = 0;\\n\\t\\t\\t\\t\\tseen.remove(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef constructDistancedSequence(self, n: int) -> List[int]:\\n\\t\\t\\tres = [0] * (n * 2 - 1)\\n\\t\\t\\tseen = set()\\n\\t\\t\\tdef backtracking(i):\\n\\t\\t\\t\\tif i == len(res):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif res[i] != 0:\\n\\t\\t\\t\\t\\treturn backtracking(i + 1)\\n\\t\\t\\t\\tfor j in range(n, 0, -1):\\n\\t\\t\\t\\t\\tif j == 1 and j not in seen:\\n\\t\\t\\t\\t\\t\\tres[i] = j\\n\\t\\t\\t\\t\\t\\tseen.add(j)\\n\\t\\t\\t\\t\\t\\tif backtracking(i + 1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\tres[i] = 0\\n\\t\\t\\t\\t\\t\\tseen.remove(j)\\n\\t\\t\\t\\t\\telif j != 1 and i + j < len(res) and res[i + j] == 0 and j not in seen:\\n\\t\\t\\t\\t\\t\\tres[i] = j\\n\\t\\t\\t\\t\\t\\tres[i + j] = j\\n\\t\\t\\t\\t\\t\\tseen.add(j)\\n\\t\\t\\t\\t\\t\\tif backtracking(i + 1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\tres[i] = 0\\n\\t\\t\\t\\t\\t\\tres[i + j] = 0\\n\\t\\t\\t\\t\\t\\tseen.remove(j)\\n\\t\\t\\tbacktracking(0)\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int[] constructDistancedSequence(int n) {\\n\\t\\t\\tint[] res = new int[n * 2 - 1];\\n\\t\\t\\tSet<Integer> seen = new HashSet<>();\\n\\t\\t\\tbacktracking(n, seen, 0, res);\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1009520,
                "title": "golang-dfs-beats-100",
                "content": "Practicaly same as https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/discuss/1008913/C%2B%2B-Backtracking\\n\\nJust try contructing sequence with the largest possible number. If fale undo inserting the last number you\\'ve tried and try a smaller one.\\n\\n```\\nfunc constructDistancedSequence(n int) []int {\\n    res := make([]int, n*2 - 1)\\n    used := make([]bool, n+1)\\n    dfs(res, 0, used)\\n    return res\\n}\\n\\nfunc dfs(res []int, i int, used []bool) bool {\\n    if i == len(res) {\\n        return true\\n    }\\n    \\n    if res[i] != 0 {\\n        return dfs(res, i+1, used)\\n    }\\n    \\n    for k := len(used)-1; k > 1; k-- {\\n        if used[k] || len(res) <= i + k || res[i+k] != 0 {\\n            continue\\n        }\\n        \\n        res[i] = k\\n        res[i+k] = k\\n        used[k] = true\\n        \\n        if dfs(res, i+1, used) {\\n            return true\\n        }\\n        \\n        res[i] = 0\\n        res[i+k] = 0\\n        used[k] = false\\n    }\\n    \\n    if !used[1] {\\n        res[i] = 1\\n        used[1] = true\\n        \\n        if dfs(res, i+1, used) {\\n            return true\\n        }\\n        \\n        res[i] = 0\\n        used[1] = false\\n    }\\n    \\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc constructDistancedSequence(n int) []int {\\n    res := make([]int, n*2 - 1)\\n    used := make([]bool, n+1)\\n    dfs(res, 0, used)\\n    return res\\n}\\n\\nfunc dfs(res []int, i int, used []bool) bool {\\n    if i == len(res) {\\n        return true\\n    }\\n    \\n    if res[i] != 0 {\\n        return dfs(res, i+1, used)\\n    }\\n    \\n    for k := len(used)-1; k > 1; k-- {\\n        if used[k] || len(res) <= i + k || res[i+k] != 0 {\\n            continue\\n        }\\n        \\n        res[i] = k\\n        res[i+k] = k\\n        used[k] = true\\n        \\n        if dfs(res, i+1, used) {\\n            return true\\n        }\\n        \\n        res[i] = 0\\n        res[i+k] = 0\\n        used[k] = false\\n    }\\n    \\n    if !used[1] {\\n        res[i] = 1\\n        used[1] = true\\n        \\n        if dfs(res, i+1, used) {\\n            return true\\n        }\\n        \\n        res[i] = 0\\n        used[1] = false\\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009402,
                "title": "java-backtracking-with-1-recursive-call",
                "content": "In the begining of the recursive fuction call, when the current position is filled, you really don\\'t need to waste the system stack space to recursive calling itself only to find the next non-filled ones. Just use a while loop to find the next non-filled position and begin from there.\\n\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2 * n - 1];\\n        backtrack(res, new boolean[n + 1], 0);\\n        return res;\\n    }\\n    \\n    private boolean backtrack(int[] res, boolean[] used, int cur) {\\n        while (cur < res.length && res[cur] != 0)\\n            cur++;\\n        if (cur >= res.length)\\n            return true;\\n        for (int i = used.length - 1; i >= 1; i--) {\\n            if (used[i])\\n                continue;\\n            if (i != 1 && (cur + i >= res.length || res[cur + i] != 0))\\n                continue;\\n            res[cur] = i; \\n            if (i != 1)\\n                res [cur + i] = i;\\n            used[i] = true;\\n            if (backtrack(res, used, cur + 1))\\n                return true;\\n            res[cur] = 0;\\n            if (i != 1)\\n                res [cur + i] = 0;\\n            used[i] = false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2 * n - 1];\\n        backtrack(res, new boolean[n + 1], 0);\\n        return res;\\n    }\\n    \\n    private boolean backtrack(int[] res, boolean[] used, int cur) {\\n        while (cur < res.length && res[cur] != 0)\\n            cur++;\\n        if (cur >= res.length)\\n            return true;\\n        for (int i = used.length - 1; i >= 1; i--) {\\n            if (used[i])\\n                continue;\\n            if (i != 1 && (cur + i >= res.length || res[cur + i] != 0))\\n                continue;\\n            res[cur] = i; \\n            if (i != 1)\\n                res [cur + i] = i;\\n            used[i] = true;\\n            if (backtrack(res, used, cur + 1))\\n                return true;\\n            res[cur] = 0;\\n            if (i != 1)\\n                res [cur + i] = 0;\\n            used[i] = false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009378,
                "title": "c-backtrack",
                "content": "Trying to put the not taken values(from large to small) for each available space from left to right.\\n```\\nclass Solution {\\npublic:\\n    bool backtrack( vector<int>& ret, int i, int n, vector<bool>& available, set<int>& notdone) {\\n        if (notdone.empty()) return true;\\n        // this position is occupied, move to next one.\\n        if (!available[i])return backtrack(ret, i + 1, n, available, notdone);\\n        vector<int> candidates(notdone.rbegin(), notdone.rend());\\n        for (auto k : candidates) {\\n            auto m = (k == 1 ? i : i + k);\\n            if (( m < 2*n - 1) &&available[m]) {\\n                 notdone.erase(k);\\n                 available[i] = false;\\n                 available[m] = false;\\n                 ret[i] = k;\\n                 ret[m] = k;\\n                 auto done = backtrack(ret, i + 1, n, available, notdone);\\n                 if (done) return true;\\n                 available[i] = true;\\n                 available[m] = true;\\n                 ret[i] = 0;\\n                 ret[m] = 0;\\n                 notdone.insert(k); \\n            }  \\n        }\\n        return false; \\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> ret(2*n - 1, 0);\\n        set<int> notdone;\\n        vector<bool> available(2*n - 1, true);\\n        for (int i = 1; i <=n; ++i)notdone.insert(i); \\n        backtrack(ret, 0, n, available, notdone);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool backtrack( vector<int>& ret, int i, int n, vector<bool>& available, set<int>& notdone) {\\n        if (notdone.empty()) return true;\\n        // this position is occupied, move to next one.\\n        if (!available[i])return backtrack(ret, i + 1, n, available, notdone);\\n        vector<int> candidates(notdone.rbegin(), notdone.rend());\\n        for (auto k : candidates) {\\n            auto m = (k == 1 ? i : i + k);\\n            if (( m < 2*n - 1) &&available[m]) {\\n                 notdone.erase(k);\\n                 available[i] = false;\\n                 available[m] = false;\\n                 ret[i] = k;\\n                 ret[m] = k;\\n                 auto done = backtrack(ret, i + 1, n, available, notdone);\\n                 if (done) return true;\\n                 available[i] = true;\\n                 available[m] = true;\\n                 ret[i] = 0;\\n                 ret[m] = 0;\\n                 notdone.insert(k); \\n            }  \\n        }\\n        return false; \\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> ret(2*n - 1, 0);\\n        set<int> notdone;\\n        vector<bool> available(2*n - 1, true);\\n        for (int i = 1; i <=n; ++i)notdone.insert(i); \\n        backtrack(ret, 0, n, available, notdone);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009309,
                "title": "golang-backtracking-bitmask-with-comments-0-ms",
                "content": "```\\nfunc constructDistancedSequence(n int) []int {\\n\\tif n == 1 {\\n\\t\\treturn []int{1}\\n\\t}\\n\\n\\tsize := 2*n - 1\\n\\tanswer := make([]int, size)\\n\\n\\tvar dfs func(int, int) bool\\n\\tdfs = func(mask int, p int) bool {\\n\\t\\t// if all the values have been assigned we found the answer\\n\\t\\tif p == size {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// if the value is already assigned move to the next index\\n\\t\\tif answer[p] != 0 {\\n\\t\\t\\treturn dfs(mask, p+1)\\n\\t\\t}\\n\\t\\t// iterate the numbers in descending order to ensure a lexicographically largest sequence\\n\\t\\tfor i := n; i >= 1; i-- {\\n\\t\\t\\t// skip i if is already in used or its second occurrence is out of bound or cannot be filled\\n\\t\\t\\tif mask&(1<<i) != 0 || (i > 1 && (p+i >= size || answer[p+i] != 0)) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// fill i and its second occurrence (if it is possible)\\n\\t\\t\\tanswer[p] = i\\n\\t\\t\\tif i > 1 {\\n\\t\\t\\t\\tanswer[p+i] = i\\n\\t\\t\\t}\\n\\t\\t\\t// mark i in the mask and move to the next index; stop if the sequence has been found\\n\\t\\t\\tif dfs(mask|(1<<i), p+1) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t// backtrack the filling\\n\\t\\t\\tanswer[p] = 0\\n\\t\\t\\tif i > 1 {\\n\\t\\t\\t\\tanswer[p+i] = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\tdfs(0, 0)\\n\\treturn answer\\n}\\n```\\n\\nVisit https://github.com/ympons/katas for other solved challenges and hacks ;)",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nfunc constructDistancedSequence(n int) []int {\\n\\tif n == 1 {\\n\\t\\treturn []int{1}\\n\\t}\\n\\n\\tsize := 2*n - 1\\n\\tanswer := make([]int, size)\\n\\n\\tvar dfs func(int, int) bool\\n\\tdfs = func(mask int, p int) bool {\\n\\t\\t// if all the values have been assigned we found the answer\\n\\t\\tif p == size {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\t// if the value is already assigned move to the next index\\n\\t\\tif answer[p] != 0 {\\n\\t\\t\\treturn dfs(mask, p+1)\\n\\t\\t}\\n\\t\\t// iterate the numbers in descending order to ensure a lexicographically largest sequence\\n\\t\\tfor i := n; i >= 1; i-- {\\n\\t\\t\\t// skip i if is already in used or its second occurrence is out of bound or cannot be filled\\n\\t\\t\\tif mask&(1<<i) != 0 || (i > 1 && (p+i >= size || answer[p+i] != 0)) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\t// fill i and its second occurrence (if it is possible)\\n\\t\\t\\tanswer[p] = i\\n\\t\\t\\tif i > 1 {\\n\\t\\t\\t\\tanswer[p+i] = i\\n\\t\\t\\t}\\n\\t\\t\\t// mark i in the mask and move to the next index; stop if the sequence has been found\\n\\t\\t\\tif dfs(mask|(1<<i), p+1) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t// backtrack the filling\\n\\t\\t\\tanswer[p] = 0\\n\\t\\t\\tif i > 1 {\\n\\t\\t\\t\\tanswer[p+i] = 0\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\tdfs(0, 0)\\n\\treturn answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009268,
                "title": "java-back-tracking-super-simple-to-understand",
                "content": "```\\n/**\\nKey points for this to work\\n1) The key idea is to fill the empty array slots sequentially with the largest possible value\\n2) If you focus on filling the largest element instead of the first vacant slot, \\n\\tthen the answer will not always be correct (i.e. largest)\\n3) If you focus only filling empty slots sequentially, \\n\\tthen the filled slot will be backtracked only when all other options result in conflict\\n**/\\nclass Solution {\\n  public int[] constructDistancedSequence(int n) {\\n    int[] ans = new int[n*2-1];\\n    PriorityQueue<Integer> unprocessed = new PriorityQueue<>(Collections.reverseOrder());\\n    for(int i=1; i<=n; i++) unprocessed.offer(i); // all elements here need to be processed\\n    \\n    dp(ans, unprocessed, 0); // by the time this method is done, ans will be filled\\n    \\n    return ans;\\n  }\\n  \\n  private boolean dp(int[] ans, PriorityQueue<Integer> unprocessed, int idx) {\\n    if(unprocessed.isEmpty()) return true; // we have processed everything, so WE ARE DONE!\\n    List<Integer> elements = new ArrayList<>(); // hold elements we can\\'t fill here\\n    while(!unprocessed.isEmpty() && idx<ans.length) {\\n      // advance idx to first vacant slot where we can fill something, in case the current slot is already taken\\n      while(idx<ans.length && ans[idx] != 0) idx++; \\n      \\n      int next = unprocessed.poll(); // try to fill current position with the largest element\\n      if(next==1 || (idx+next<ans.length && ans[idx+next] == 0)) { // this is satisfied when we can fill without conflict\\n        // fill the unprocessed elements back, so they can be tried in the next slot\\n        for(int element : elements) unprocessed.offer(element); \\n        ans[idx] = next; \\n        if(next!= 1) ans[idx+next] = next;\\n        if(dp(ans, unprocessed, idx+1)) return true; // we already processed everything, so return true and WE ARE DONE!\\n        \\n        // else backtrack and reset the values\\n        ans[idx] = 0; \\n        if(next!=1) ans[idx+next] = 0;\\n        // remove already tried elements for backtracking\\n        for(int i=0; i<elements.size(); i++) unprocessed.poll(); \\n        elements.add(next);\\n      } else { // else we just keep the largest unprocessed elements to try fill in the next slot for ans\\n        elements.add(next);\\n      }\\n    }\\n    // we reached end of ans array without finding solution, so we need to fill back the unprocessed elements of the current step\\n    for(int element : elements) unprocessed.offer(element);\\n    return false;\\n  }\\n  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nKey points for this to work\\n1) The key idea is to fill the empty array slots sequentially with the largest possible value\\n2) If you focus on filling the largest element instead of the first vacant slot, \\n\\tthen the answer will not always be correct (i.e. largest)\\n3) If you focus only filling empty slots sequentially, \\n\\tthen the filled slot will be backtracked only when all other options result in conflict\\n**/\\nclass Solution {\\n  public int[] constructDistancedSequence(int n) {\\n    int[] ans = new int[n*2-1];\\n    PriorityQueue<Integer> unprocessed = new PriorityQueue<>(Collections.reverseOrder());\\n    for(int i=1; i<=n; i++) unprocessed.offer(i); // all elements here need to be processed\\n    \\n    dp(ans, unprocessed, 0); // by the time this method is done, ans will be filled\\n    \\n    return ans;\\n  }\\n  \\n  private boolean dp(int[] ans, PriorityQueue<Integer> unprocessed, int idx) {\\n    if(unprocessed.isEmpty()) return true; // we have processed everything, so WE ARE DONE!\\n    List<Integer> elements = new ArrayList<>(); // hold elements we can\\'t fill here\\n    while(!unprocessed.isEmpty() && idx<ans.length) {\\n      // advance idx to first vacant slot where we can fill something, in case the current slot is already taken\\n      while(idx<ans.length && ans[idx] != 0) idx++; \\n      \\n      int next = unprocessed.poll(); // try to fill current position with the largest element\\n      if(next==1 || (idx+next<ans.length && ans[idx+next] == 0)) { // this is satisfied when we can fill without conflict\\n        // fill the unprocessed elements back, so they can be tried in the next slot\\n        for(int element : elements) unprocessed.offer(element); \\n        ans[idx] = next; \\n        if(next!= 1) ans[idx+next] = next;\\n        if(dp(ans, unprocessed, idx+1)) return true; // we already processed everything, so return true and WE ARE DONE!\\n        \\n        // else backtrack and reset the values\\n        ans[idx] = 0; \\n        if(next!=1) ans[idx+next] = 0;\\n        // remove already tried elements for backtracking\\n        for(int i=0; i<elements.size(); i++) unprocessed.poll(); \\n        elements.add(next);\\n      } else { // else we just keep the largest unprocessed elements to try fill in the next slot for ans\\n        elements.add(next);\\n      }\\n    }\\n    // we reached end of ans array without finding solution, so we need to fill back the unprocessed elements of the current step\\n    for(int element : elements) unprocessed.offer(element);\\n    return false;\\n  }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009203,
                "title": "c-backtrack-solution-66-faster-than-other-solutions",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> a(5*n+1, 0),ans;\\n        set<int> d;\\n        d.clear();\\n        ans.clear();\\n        a.clear();\\n        for(int i=1;i<=n;i++)d.insert(i);\\n        solve(a,d,n,1);\\n        for(int i=1;i<=2*n-1;i++){\\n            cout<<a[i]<<\" \";\\n            ans.push_back(a[i]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool solve(vector<int> &a, set<int> &d, int n, int k){\\n        // Base condition \\n        if(d.empty()){\\n            for(int i=1;i<=2*n-1;i++){\\n                if(a[i]==0)return false;\\n            }\\n            return true;\\n        }\\n        \\n        // Recurse for all n from greater to smaller\\n        for(int i=n;i>0;i--){\\n            if(d.find(i)!=d.end()){\\n                if(i==1){\\n                    if(a[k]==0)a[k]=i;\\n                    else continue;\\n                }\\n                else{\\n                    if(a[k+i]==0 && a[k]==0){\\n                        a[k]=i;\\n                        a[k+i]=i;   \\n                    }else{\\n                        continue;\\n                    }\\n                }\\n                d.erase(i);\\n                bool x=false;\\n                int g=0;\\n                for(int i=k+1;i<=2*n-1;i++){\\n                    if(a[i]==0){\\n\\n                        x=solve(a,d,n,i);\\n                        g=1;\\n                        break;\\n                    }\\n                }\\n\\n                if(g==0)x=solve(a,d,n,n);\\n                if(x){\\n                    return true;\\n                }else{\\n                    d.insert(i);\\n                    if(i==1)a[k]=0;\\n                    else{\\n                        a[k]=0;\\n                        a[k+i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> constructDistancedSequence(int n) {\\n        vector<int> a(5*n+1, 0),ans;\\n        set<int> d;\\n        d.clear();\\n        ans.clear();\\n        a.clear();\\n        for(int i=1;i<=n;i++)d.insert(i);\\n        solve(a,d,n,1);\\n        for(int i=1;i<=2*n-1;i++){\\n            cout<<a[i]<<\" \";\\n            ans.push_back(a[i]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool solve(vector<int> &a, set<int> &d, int n, int k){\\n        // Base condition \\n        if(d.empty()){\\n            for(int i=1;i<=2*n-1;i++){\\n                if(a[i]==0)return false;\\n            }\\n            return true;\\n        }\\n        \\n        // Recurse for all n from greater to smaller\\n        for(int i=n;i>0;i--){\\n            if(d.find(i)!=d.end()){\\n                if(i==1){\\n                    if(a[k]==0)a[k]=i;\\n                    else continue;\\n                }\\n                else{\\n                    if(a[k+i]==0 && a[k]==0){\\n                        a[k]=i;\\n                        a[k+i]=i;   \\n                    }else{\\n                        continue;\\n                    }\\n                }\\n                d.erase(i);\\n                bool x=false;\\n                int g=0;\\n                for(int i=k+1;i<=2*n-1;i++){\\n                    if(a[i]==0){\\n\\n                        x=solve(a,d,n,i);\\n                        g=1;\\n                        break;\\n                    }\\n                }\\n\\n                if(g==0)x=solve(a,d,n,n);\\n                if(x){\\n                    return true;\\n                }else{\\n                    d.insert(i);\\n                    if(i==1)a[k]=0;\\n                    else{\\n                        a[k]=0;\\n                        a[k+i]=0;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1009191,
                "title": "c-backtracking-and-bit-compression-solution-beats-100",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> result;\\n    bool flag=false;\\n    void dfs(int n,int current,vector<int>& temp,int state)\\n    {\\n        if(current==2*n-1)\\n        {\\n            result=temp;\\n            flag=true;\\n            return;\\n        }\\n        if(flag)\\n        {\\n            return;\\n        }\\n        if(temp[current]!=0)\\n        {\\n            dfs(n,current+1,temp,state);\\n        }\\n        for(int i=n;i>1;i--)\\n        {\\n            if(!(state&(1<<i))&&current+i<2*n-1&&temp[current]==0&&temp[current+i]==0)\\n            {\\n                temp[current]=i;\\n                temp[current+i]=i;\\n                state^=1<<i;\\n                dfs(n,current+1,temp,state);\\n                temp[current]=0;\\n                temp[current+i]=0;\\n                state^=1<<i;\\n            }\\n        }\\n        if(!(state&1)&&temp[current]==0)\\n        {\\n            temp[current]=1;\\n            state^=1;\\n            dfs(n,current+1,temp,state);\\n            temp[current]=0;\\n            state^=1;\\n        }\\n    }\\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        vector<int> temp(2*n-1);\\n        dfs(n,0,temp,0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> result;\\n    bool flag=false;\\n    void dfs(int n,int current,vector<int>& temp,int state)\\n    {\\n        if(current==2*n-1)\\n        {\\n            result=temp;\\n            flag=true;\\n            return;\\n        }\\n        if(flag)\\n        {\\n            return;\\n        }\\n        if(temp[current]!=0)\\n        {\\n            dfs(n,current+1,temp,state);\\n        }\\n        for(int i=n;i>1;i--)\\n        {\\n            if(!(state&(1<<i))&&current+i<2*n-1&&temp[current]==0&&temp[current+i]==0)\\n            {\\n                temp[current]=i;\\n                temp[current+i]=i;\\n                state^=1<<i;\\n                dfs(n,current+1,temp,state);\\n                temp[current]=0;\\n                temp[current+i]=0;\\n                state^=1<<i;\\n            }\\n        }\\n        if(!(state&1)&&temp[current]==0)\\n        {\\n            temp[current]=1;\\n            state^=1;\\n            dfs(n,current+1,temp,state);\\n            temp[current]=0;\\n            state^=1;\\n        }\\n    }\\n    vector<int> constructDistancedSequence(int n) \\n    {\\n        vector<int> temp(2*n-1);\\n        dfs(n,0,temp,0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009116,
                "title": "java-backtracking-simple-solution-runtime-100-00-memory-usage-100-00",
                "content": "```\\nclass Solution {\\n    public int[] result;\\n    public HashSet<Integer> set;\\n    public boolean checkForStopping = false;\\n    \\n    public boolean dfs(int[] res, int start, int n) {\\n        if (set.size() == n) {\\n            result = Arrays.copyOf(res, res.length);\\n            checkForStopping = true;\\n            return false;\\n        }\\n        \\n        if (res[start] != 0) {\\n            start++;\\n        }\\n            \\n        for (int i = n; i > 0; i--) { \\n            if (checkForStoping)\\n                return false;\\n            \\n            if (set.contains(i)) {\\n                continue;\\n                \\n            } else if (res[start] != 0) {\\n                i++;\\n                start++;\\n                continue;\\n            }\\n            \\n            if (i != 1) {     \\n                if (!(start + i < 2 * n - 1)) {\\n                    return false;\\n                }\\n                if (res[start + i] == 0) {\\n                    res[start + i] = i;\\n                } else {\\n                    continue;\\n                }\\n            }\\n            \\n            res[start] = i;\\n            set.add(i);\\n            \\n            if (!dfs(res, start + 1, n)) {\\n                res[start] = 0;\\n                \\n                if (i != 1) \\n                    res[start + i] = 0;\\n                set.remove(i);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public int[] constructDistancedSequence(int n) {\\n        if (n == 1) {\\n            int[] res = new int[1];\\n            res[0] = 1;\\n            return res;\\n        }\\n\\n        int[] res = new int[2 * n - 1];\\n        max = new int[2 * n - 1];\\n        set = new HashSet<>();\\n        \\n        dfs(res, 0, n);\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] result;\\n    public HashSet<Integer> set;\\n    public boolean checkForStopping = false;\\n    \\n    public boolean dfs(int[] res, int start, int n) {\\n        if (set.size() == n) {\\n            result = Arrays.copyOf(res, res.length);\\n            checkForStopping = true;\\n            return false;\\n        }\\n        \\n        if (res[start] != 0) {\\n            start++;\\n        }\\n            \\n        for (int i = n; i > 0; i--) { \\n            if (checkForStoping)\\n                return false;\\n            \\n            if (set.contains(i)) {\\n                continue;\\n                \\n            } else if (res[start] != 0) {\\n                i++;\\n                start++;\\n                continue;\\n            }\\n            \\n            if (i != 1) {     \\n                if (!(start + i < 2 * n - 1)) {\\n                    return false;\\n                }\\n                if (res[start + i] == 0) {\\n                    res[start + i] = i;\\n                } else {\\n                    continue;\\n                }\\n            }\\n            \\n            res[start] = i;\\n            set.add(i);\\n            \\n            if (!dfs(res, start + 1, n)) {\\n                res[start] = 0;\\n                \\n                if (i != 1) \\n                    res[start + i] = 0;\\n                set.remove(i);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public int[] constructDistancedSequence(int n) {\\n        if (n == 1) {\\n            int[] res = new int[1];\\n            res[0] = 1;\\n            return res;\\n        }\\n\\n        int[] res = new int[2 * n - 1];\\n        max = new int[2 * n - 1];\\n        set = new HashSet<>();\\n        \\n        dfs(res, 0, n);\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009101,
                "title": "java-0-ms-v3",
                "content": "v3\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int len = 2 * n - 1;\\n        int[] a = new int[len];\\n        int[] f = new int[n]; // used nums\\n\\n        rec(a, 0, len, f);\\n\\n        return a;\\n    }\\n\\n    private boolean rec(int[] a, int i, int len, int[] f) {\\n        while(i < len && a[i] != 0)\\n            i++;\\n        if(i == len)\\n            return true;\\n\\n        for (int i1 = f.length - 1; i1 >= 0; i1--) {\\n            if(f[i1] > 0)\\n                continue;\\n            int num = i1 + 1;\\n            if(num == 1 || (i + num < len && a[i + num] == 0)) {\\n                a[i] = num;\\n                if(num > 1) a[i + num] = num;\\n                f[i1] = 1;\\n\\n                if(rec(a, i + 1, len, f))\\n                    return true;\\n\\n                a[i] = 0;\\n                if(num > 1) a[i + num] = 0;\\n                f[i1] = 0;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n}\\n```\\n\\nv2\\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int len = 2 * n - 1;\\n        int[] a = new int[len];\\n        int[] f = new int[n]; // used nums\\n        best = new int[len]; // saved combination\\n        bc = 0;\\n\\n        rec(a, 0, len, f);\\n\\n        //System.out.println(bc);\\n        return best;\\n    }\\n\\n    private int[] best;\\n    private int bc;\\n    private void rec(int[] a, int i, int len, int[] f) {\\n        while(i < len && a[i] != 0)\\n            i++;\\n        if(i == len) {\\n            //if (check(a, len))\\n                save(a, len);\\n            bc++;\\n            return;\\n        }\\n\\n\\n\\n        for (int i1 = f.length - 1; i1 >= 0; i1--) {\\n            if(f[i1] > 0)\\n                continue;\\n            int num = i1 + 1;\\n            if(num == 1) {\\n                a[i] = num;\\n                f[i1] = 1;\\n\\n                //if(preCheck(a, len))\\n                    rec(a, i + 1, len, f);\\n\\n                a[i] = 0;\\n                f[i1] = 0;\\n            }\\n            else if(i + num < len && a[i + num] == 0) {\\n                a[i] = num; a[i + num] = num;\\n                f[i1] = 1;\\n\\n                //if(preCheck(a, len))\\n                    rec(a, i + 1, len, f);\\n\\n                a[i] = 0; a[i + num] = 0;\\n                f[i1] = 0;\\n            }\\n            if(bc == 1)\\n                return;\\n        }\\n\\n\\n    }\\n\\n    private void save(int[] a, int len) {\\n        for (int i = 0; i < len; i++)\\n            best[i] = a[i];\\n    }\\n\\n    /*private boolean check(int[] a, int len) {\\n        for (int i = 0; i < len; i++)\\n            if(best[i] > a[i])\\n                return false;\\n        return true;\\n    }*/\\n\\n    /*private boolean preCheck(int[] a, int len) {\\n        for (int i = 0; i < len; i++) {\\n            if(a[i] == 0)\\n                break;\\n            if(best[i] > a[i])\\n                return false;\\n        }\\n        return true;\\n    }*/\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int len = 2 * n - 1;\\n        int[] a = new int[len];\\n        int[] f = new int[n]; // used nums\\n\\n        rec(a, 0, len, f);\\n\\n        return a;\\n    }\\n\\n    private boolean rec(int[] a, int i, int len, int[] f) {\\n        while(i < len && a[i] != 0)\\n            i++;\\n        if(i == len)\\n            return true;\\n\\n        for (int i1 = f.length - 1; i1 >= 0; i1--) {\\n            if(f[i1] > 0)\\n                continue;\\n            int num = i1 + 1;\\n            if(num == 1 || (i + num < len && a[i + num] == 0)) {\\n                a[i] = num;\\n                if(num > 1) a[i + num] = num;\\n                f[i1] = 1;\\n\\n                if(rec(a, i + 1, len, f))\\n                    return true;\\n\\n                a[i] = 0;\\n                if(num > 1) a[i + num] = 0;\\n                f[i1] = 0;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int len = 2 * n - 1;\\n        int[] a = new int[len];\\n        int[] f = new int[n]; // used nums\\n        best = new int[len]; // saved combination\\n        bc = 0;\\n\\n        rec(a, 0, len, f);\\n\\n        //System.out.println(bc);\\n        return best;\\n    }\\n\\n    private int[] best;\\n    private int bc;\\n    private void rec(int[] a, int i, int len, int[] f) {\\n        while(i < len && a[i] != 0)\\n            i++;\\n        if(i == len) {\\n            //if (check(a, len))\\n                save(a, len);\\n            bc++;\\n            return;\\n        }\\n\\n\\n\\n        for (int i1 = f.length - 1; i1 >= 0; i1--) {\\n            if(f[i1] > 0)\\n                continue;\\n            int num = i1 + 1;\\n            if(num == 1) {\\n                a[i] = num;\\n                f[i1] = 1;\\n\\n                //if(preCheck(a, len))\\n                    rec(a, i + 1, len, f);\\n\\n                a[i] = 0;\\n                f[i1] = 0;\\n            }\\n            else if(i + num < len && a[i + num] == 0) {\\n                a[i] = num; a[i + num] = num;\\n                f[i1] = 1;\\n\\n                //if(preCheck(a, len))\\n                    rec(a, i + 1, len, f);\\n\\n                a[i] = 0; a[i + num] = 0;\\n                f[i1] = 0;\\n            }\\n            if(bc == 1)\\n                return;\\n        }\\n\\n\\n    }\\n\\n    private void save(int[] a, int len) {\\n        for (int i = 0; i < len; i++)\\n            best[i] = a[i];\\n    }\\n\\n    /*private boolean check(int[] a, int len) {\\n        for (int i = 0; i < len; i++)\\n            if(best[i] > a[i])\\n                return false;\\n        return true;\\n    }*/\\n\\n    /*private boolean preCheck(int[] a, int len) {\\n        for (int i = 0; i < len; i++) {\\n            if(a[i] == 0)\\n                break;\\n            if(best[i] > a[i])\\n                return false;\\n        }\\n        return true;\\n    }*/\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009098,
                "title": "c-backtracking-with-explanation",
                "content": "```vector<int> ans(n * 2 - 1)``` is the result to return i.e. the sequence we are supposed to construct. We initialize it with ```-1```\\n\\nBecause we want to find the lexicographically largest ```ans```, we start to search ```ans[idx]``` from ```idx = 0``` to ```2 * n - 1``` in ascending order. If ```ans[idx] != -1```, it means we already assign it with another value earlier, so we don\\'t modify it now. Otherwise, we try to assign ```ans[idx] ``` and ```and[idx + i]``` with the value ```i```  in decreasing order from ```i = n``` to ```i = 1```. \\n\\nIn this order, the largest possible value will be attempted first. Once we find a possible result, it\\'d be the  lexicographically largest one, so we set ```flag=1```, and all the other functions running will end without modifying any value in ```ans[i]``` to maintain the correcteness of the answer. That\\'s why everytime after I call the function ```rec```, I need to check immediately if the value of ```flag``` is modified. If it\\'s not, that\\'s also important to change ```ans[idx + i]``` back to ```-1```.\\n\\nThe ```vector<int> used(n)``` is to record if the value is already in ```ans``` or not. In other words, ```used[i] = 1``` means for some ```x``` in range ```[1,n]```, ```ans[x] = i```.\\n\\nIn the function ```rec```(which means recursive), I set the argument ```ub``` and ```bound```which means ```n```(upper bound of value that is possible to be assigned) and ```2 * n - 1``` respectively, they are unnecessarry to be declared as arguments because they are invariant during the whole backtracking process, using only ```n``` might be easier to code. \\n\\nIn short, think ```rec(idx)``` as a function to assign the possible values in ```ans[idx]```, so everytime we find a possible value ```i``` to put in ```ans[idx]``` and ```ans[idx + i]```, we assign this value and call ```rec(idx + 1)``` to see if it\\'s possile to assign the value for the next ```idx```. If it\\'s possible till the end ```idx == 2 * n - 1 ```, then we find the answer.\\n\\nLeave comments if there is anything not explained clearly :) . Thanks for reading this sorry if I don\\'t talk clearly in English (it\\'s my third language) if you like it leave an upvote ! I\\'d appreciate it\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> used;\\n    int flag;\\n    void rec(int idx, int ub, int bound){\\n        if (flag) return ;\\n        if (idx == bound){\\n            flag=  1;\\n            return ;\\n        }\\n        if (ans[idx] != -1){\\n            rec(idx + 1, ub, bound);\\n            return ;\\n        }\\n        for(int i = ub ; i > 0 ; i--){\\n            if (used[i]) continue ;\\n            if (i != 1 && i + idx >= bound) continue ;\\n            if (i != 1 && ans[i + idx] != -1 ) continue ;\\n            if (i == 1){\\n                ans[idx] = 1;\\n                used[1] = 1;\\n                rec(idx + 1, ub, bound);\\n                if (flag) return ;\\n                used[1] = 0;\\n                ans[idx] = -1;\\n                continue ;\\n            }\\n            \\n            ans[idx] = i;\\n            ans[idx + i] = i;\\n            used[i] = 1;\\n            rec(idx + 1, ub, bound);\\n            if (flag) return ;\\n            ans[idx] = -1;\\n            ans[idx + i] = -1;\\n            used[i] = 0;\\n        }\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        flag = 0;\\n        used = vector<int>(n + 1,0);\\n        ans = vector<int>(n * 2 - 1, -1);\\n        rec(0,n,2 * n - 1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```vector<int> ans(n * 2 - 1)```\n```-1```\n```ans```\n```ans[idx]```\n```idx = 0```\n```2 * n - 1```\n```ans[idx] != -1```\n```ans[idx] ```\n```and[idx + i]```\n```i```\n```i = n```\n```i = 1```\n```flag=1```\n```ans[i]```\n```rec```\n```flag```\n```ans[idx + i]```\n```-1```\n```vector<int> used(n)```\n```ans```\n```used[i] = 1```\n```x```\n```[1,n]```\n```ans[x] = i```\n```rec```\n```ub```\n```bound```\n```n```\n```2 * n - 1```\n```n```\n```rec(idx)```\n```ans[idx]```\n```i```\n```ans[idx]```\n```ans[idx + i]```\n```rec(idx + 1)```\n```idx```\n```idx == 2 * n - 1 ```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> used;\\n    int flag;\\n    void rec(int idx, int ub, int bound){\\n        if (flag) return ;\\n        if (idx == bound){\\n            flag=  1;\\n            return ;\\n        }\\n        if (ans[idx] != -1){\\n            rec(idx + 1, ub, bound);\\n            return ;\\n        }\\n        for(int i = ub ; i > 0 ; i--){\\n            if (used[i]) continue ;\\n            if (i != 1 && i + idx >= bound) continue ;\\n            if (i != 1 && ans[i + idx] != -1 ) continue ;\\n            if (i == 1){\\n                ans[idx] = 1;\\n                used[1] = 1;\\n                rec(idx + 1, ub, bound);\\n                if (flag) return ;\\n                used[1] = 0;\\n                ans[idx] = -1;\\n                continue ;\\n            }\\n            \\n            ans[idx] = i;\\n            ans[idx + i] = i;\\n            used[i] = 1;\\n            rec(idx + 1, ub, bound);\\n            if (flag) return ;\\n            ans[idx] = -1;\\n            ans[idx + i] = -1;\\n            used[i] = 0;\\n        }\\n    }\\n    vector<int> constructDistancedSequence(int n) {\\n        flag = 0;\\n        used = vector<int>(n + 1,0);\\n        ans = vector<int>(n * 2 - 1, -1);\\n        rec(0,n,2 * n - 1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009078,
                "title": "simple-java-solution-dfs-pruning",
                "content": "```\\nclass Solution {\\n    private int[] result;\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2*n-1];\\n        result = Arrays.copyOf(res, res.length);\\n        helper(n, res);\\n        return result;\\n    }\\n    \\n    private void helper(int n, int[] acc) {\\n        if (n == 1) {\\n            int idx = -1;\\n            for (int i = 0; i < acc.length; i++) {\\n                if (acc[i] == 0) {\\n                    idx = i;\\n                    break;\\n                }\\n            }\\n            acc[idx] = 1;\\n            result = Arrays.copyOf(acc, acc.length);\\n            acc[idx] = 0;\\n            return;\\n        }\\n        \\n        for (int idx = 0; idx < acc.length - n; idx++) {\\n            if (acc[idx] == 0 && acc[idx+n] == 0) {\\n                acc[idx] = n;\\n                acc[idx+n] = n;\\n                if (isLarger(acc, result, n)) helper(n-1, acc);\\n                acc[idx] = 0;\\n                acc[idx+n] = 0;\\n            }\\n        }\\n    }\\n    \\n    private boolean isLarger(int[] a, int[] b, int n) {\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] > b[i] || (a[i] == 0 && b[i] < n-1)) return true;\\n            else if ((a[i] != 0 && b[i] > a[i]) || (a[i] == 0 && b[i] > n-1)) return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] result;\\n    public int[] constructDistancedSequence(int n) {\\n        int[] res = new int[2*n-1];\\n        result = Arrays.copyOf(res, res.length);\\n        helper(n, res);\\n        return result;\\n    }\\n    \\n    private void helper(int n, int[] acc) {\\n        if (n == 1) {\\n            int idx = -1;\\n            for (int i = 0; i < acc.length; i++) {\\n                if (acc[i] == 0) {\\n                    idx = i;\\n                    break;\\n                }\\n            }\\n            acc[idx] = 1;\\n            result = Arrays.copyOf(acc, acc.length);\\n            acc[idx] = 0;\\n            return;\\n        }\\n        \\n        for (int idx = 0; idx < acc.length - n; idx++) {\\n            if (acc[idx] == 0 && acc[idx+n] == 0) {\\n                acc[idx] = n;\\n                acc[idx+n] = n;\\n                if (isLarger(acc, result, n)) helper(n-1, acc);\\n                acc[idx] = 0;\\n                acc[idx+n] = 0;\\n            }\\n        }\\n    }\\n    \\n    private boolean isLarger(int[] a, int[] b, int n) {\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] > b[i] || (a[i] == 0 && b[i] < n-1)) return true;\\n            else if ((a[i] != 0 && b[i] > a[i]) || (a[i] == 0 && b[i] > n-1)) return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009044,
                "title": "modular-easy-to-read-code-greedy-with-backtracking",
                "content": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] result = new int[2 * n - 1];\\n        // result init to zero.\\n        Set<Integer> candidatesUsed = new HashSet<Integer>();\\n        helper(result,0,candidatesUsed,n);\\n        return result;\\n    }\\n    \\n    boolean valid(int[] result, int currentIndex, int candidate) {\\n        if(candidate == 1) return result[currentIndex] == 0;\\n        int N = result.length;\\n        int nextIndex = currentIndex + candidate;\\n        return nextIndex < N && result[nextIndex] == 0 && result[currentIndex] == 0;\\n    }\\n    \\n    void fill(int[] result, int currentIndex, int candidate) {\\n        if(candidate == 1) {\\n            result[currentIndex] = candidate;  \\n            return;\\n        }\\n        int N = result.length;\\n        int nextIndex = currentIndex + candidate;\\n        result[currentIndex] = candidate;\\n        result[nextIndex] = candidate;\\n    }\\n    \\n    void unfill(int[] result, int currentIndex, int candidate) {\\n        if(candidate == 1) {\\n            result[currentIndex] = 0;\\n            return;\\n        }\\n        int N = result.length;\\n        int nextIndex = currentIndex + candidate;\\n        result[currentIndex]= 0;\\n        result[nextIndex] = 0;\\n    }\\n    \\n    \\n    public boolean helper(int[] result, int index, Set<Integer> candidatesUsed,int n) {\\n        // greedily fill the leftmost number with a digit.\\n        int N = result.length;\\n        if(index == N) return true;\\n        // currentIndex will be less than N\\n        // currentIndex is filled with 0.\\n        for(int candidate=n;candidate>=0;candidate--) {\\n            if(candidatesUsed.contains(candidate)) continue;\\n            if(!valid(result,index,candidate)) continue;\\n            fill(result,index,candidate);\\n            //System.out.println(Arrays.toString(result));\\n            candidatesUsed.add(candidate);\\n            int recursionIndex = index+1;\\n            while(recursionIndex < N && result[recursionIndex]!=0) recursionIndex++;\\n            if(helper(result,recursionIndex,candidatesUsed,n)) return true;\\n            candidatesUsed.remove(candidate);\\n            unfill(result,index,candidate);\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] constructDistancedSequence(int n) {\\n        int[] result = new int[2 * n - 1];\\n        // result init to zero.\\n        Set<Integer> candidatesUsed = new HashSet<Integer>();\\n        helper(result,0,candidatesUsed,n);\\n        return result;\\n    }\\n    \\n    boolean valid(int[] result, int currentIndex, int candidate) {\\n        if(candidate == 1) return result[currentIndex] == 0;\\n        int N = result.length;\\n        int nextIndex = currentIndex + candidate;\\n        return nextIndex < N && result[nextIndex] == 0 && result[currentIndex] == 0;\\n    }\\n    \\n    void fill(int[] result, int currentIndex, int candidate) {\\n        if(candidate == 1) {\\n            result[currentIndex] = candidate;  \\n            return;\\n        }\\n        int N = result.length;\\n        int nextIndex = currentIndex + candidate;\\n        result[currentIndex] = candidate;\\n        result[nextIndex] = candidate;\\n    }\\n    \\n    void unfill(int[] result, int currentIndex, int candidate) {\\n        if(candidate == 1) {\\n            result[currentIndex] = 0;\\n            return;\\n        }\\n        int N = result.length;\\n        int nextIndex = currentIndex + candidate;\\n        result[currentIndex]= 0;\\n        result[nextIndex] = 0;\\n    }\\n    \\n    \\n    public boolean helper(int[] result, int index, Set<Integer> candidatesUsed,int n) {\\n        // greedily fill the leftmost number with a digit.\\n        int N = result.length;\\n        if(index == N) return true;\\n        // currentIndex will be less than N\\n        // currentIndex is filled with 0.\\n        for(int candidate=n;candidate>=0;candidate--) {\\n            if(candidatesUsed.contains(candidate)) continue;\\n            if(!valid(result,index,candidate)) continue;\\n            fill(result,index,candidate);\\n            //System.out.println(Arrays.toString(result));\\n            candidatesUsed.add(candidate);\\n            int recursionIndex = index+1;\\n            while(recursionIndex < N && result[recursionIndex]!=0) recursionIndex++;\\n            if(helper(result,recursionIndex,candidatesUsed,n)) return true;\\n            candidatesUsed.remove(candidate);\\n            unfill(result,index,candidate);\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009038,
                "title": "python-dfs-with-pruning",
                "content": "Do DFS to get all working permuations.  We can save a lot of work if we prune branches that cannot possibly beat the already saved optima:\\n\\nUpdate: My scan is (number, location). However, after seeing other solutions, I see that scanning with (location, number) naturally applies pruning! So as soon as you find an answer doing other version, you can return! whoops xD\\n\\n```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        res = [float(\"inf\")] * (2*n - 1) # active subgraph\\n        best = [-1] * (2*n - 1) # current optima\\n        \\n        def lessThan(start):\\n            # returns True if current branch cannot possible beat best\\n            for i in range(2*n - 1):\\n                if best[i] == -1:\\n                    return False # best not assigned yet\\n                elif res[i] == float(\\'inf\\'):\\n                    if best[i] > start:\\n                        # it is impossible to create a better result\\n                        return True\\n                    else:\\n                        return False\\n                elif res[i] > best[i]:\\n                    return False # definitely will be better if it works\\n            return False\\n        \\n        \\n        def dfs(start):\\n            nonlocal best\\n\\n            # if this subgraph is not useful, prune it\\n            if lessThan(start):\\n                return\\n            \\n            if start == 1:\\n                pos = None\\n                for loc in range(2*n - 1):\\n                    if res[loc] == float(\"inf\"):\\n                        pos = loc\\n                        break\\n\\n                res[pos] = 1\\n                if best < res:\\n                    best = deepcopy(res)\\n                res[pos] = float(\"inf\")\\n                return \\n            \\n            i = start\\n            for loc in range(2*n - 1):\\n                if loc + i >= 2*n - 1:\\n                    break\\n                if res[loc] != float(\\'inf\\') or res[loc+i] != float(\\'inf\\'):\\n                    continue\\n                \\n                # try this location:\\n                res[loc] = i\\n                res[loc+i] = i\\n                dfs(start-1)\\n                res[loc] = float(\\'inf\\')\\n                res[loc+i] = float(\\'inf\\')\\n                 \\n            return \\n        \\n        dfs(n)   \\n                \\n        return best\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        res = [float(\"inf\")] * (2*n - 1) # active subgraph\\n        best = [-1] * (2*n - 1) # current optima\\n        \\n        def lessThan(start):\\n            # returns True if current branch cannot possible beat best\\n            for i in range(2*n - 1):\\n                if best[i] == -1:\\n                    return False # best not assigned yet\\n                elif res[i] == float(\\'inf\\'):\\n                    if best[i] > start:\\n                        # it is impossible to create a better result\\n                        return True\\n                    else:\\n                        return False\\n                elif res[i] > best[i]:\\n                    return False # definitely will be better if it works\\n            return False\\n        \\n        \\n        def dfs(start):\\n            nonlocal best\\n\\n            # if this subgraph is not useful, prune it\\n            if lessThan(start):\\n                return\\n            \\n            if start == 1:\\n                pos = None\\n                for loc in range(2*n - 1):\\n                    if res[loc] == float(\"inf\"):\\n                        pos = loc\\n                        break\\n\\n                res[pos] = 1\\n                if best < res:\\n                    best = deepcopy(res)\\n                res[pos] = float(\"inf\")\\n                return \\n            \\n            i = start\\n            for loc in range(2*n - 1):\\n                if loc + i >= 2*n - 1:\\n                    break\\n                if res[loc] != float(\\'inf\\') or res[loc+i] != float(\\'inf\\'):\\n                    continue\\n                \\n                # try this location:\\n                res[loc] = i\\n                res[loc+i] = i\\n                dfs(start-1)\\n                res[loc] = float(\\'inf\\')\\n                res[loc+i] = float(\\'inf\\')\\n                 \\n            return \\n        \\n        dfs(n)   \\n                \\n        return best\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009009,
                "title": "greedy-backtracking",
                "content": "mems is the sorted array left\\nplace is the remain index to put element\\nret[i] == 0 means the i-th index has no element yet\\nThen simple backtracking\\n```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        mems = list(range(1, n + 1))\\n        mems.sort(reverse=True)\\n        place = list(range(2 * n - 1))\\n        ret = [0] * (2 * n - 1)\\n\\n        def helper(ms, pl):\\n            print(ms, pl, ret)\\n            if not ms:\\n                return True\\n            if not pl:\\n                return False\\n            next_pos = pl[0]\\n            if ret[next_pos] > 0:\\n                return helper(ms, pl[1:])\\n            for i, m in enumerate(ms):\\n                if m > 1 and next_pos + m < 2 * n - 1 and ret[next_pos + m] == 0:\\n                    ret[next_pos] = m\\n                    ret[next_pos + m] = m\\n                    if helper(ms[:i] + ms[i + 1:], pl[1:]):\\n                        return True\\n                    ret[next_pos] = 0\\n                    ret[next_pos + m] = 0\\n                else:\\n                    if m == 1:\\n                        ret[next_pos] = 1\\n                        if helper(ms[:i] + ms[i + 1:], pl[1:]):\\n                            return True\\n                        ret[next_pos] = 0\\n            return False\\n\\n        helper(mems, place)\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        mems = list(range(1, n + 1))\\n        mems.sort(reverse=True)\\n        place = list(range(2 * n - 1))\\n        ret = [0] * (2 * n - 1)\\n\\n        def helper(ms, pl):\\n            print(ms, pl, ret)\\n            if not ms:\\n                return True\\n            if not pl:\\n                return False\\n            next_pos = pl[0]\\n            if ret[next_pos] > 0:\\n                return helper(ms, pl[1:])\\n            for i, m in enumerate(ms):\\n                if m > 1 and next_pos + m < 2 * n - 1 and ret[next_pos + m] == 0:\\n                    ret[next_pos] = m\\n                    ret[next_pos + m] = m\\n                    if helper(ms[:i] + ms[i + 1:], pl[1:]):\\n                        return True\\n                    ret[next_pos] = 0\\n                    ret[next_pos + m] = 0\\n                else:\\n                    if m == 1:\\n                        ret[next_pos] = 1\\n                        if helper(ms[:i] + ms[i + 1:], pl[1:]):\\n                            return True\\n                        ret[next_pos] = 0\\n            return False\\n\\n        helper(mems, place)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009002,
                "title": "python-backtracking-with-explanation",
                "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        N = (n * 2) - 1 # final length of solution\\n        def isValid(sln, curIdx, val):\\n            # check if we can place val at curIdx (and curIdx + val, if needed)\\n            if val == 1:\\n                return sln[curIdx] is None\\n            else:\\n                return (curIdx + val) < len(sln) and sln[curIdx] is None and sln[curIdx + val] is None\\n        def backtrack(sln, used):\\n            # find an open spot to place our value\\n            for tIdx in range(N):\\n                if sln[tIdx] is None:\\n                    break\\n            if tIdx == N - 1 and sln[-1] is not None: return sln[:] # all spots taken, we found a solution\\n            \\n            for i in range(n)[::-1]: # iterate in reverse for lexicographically largest sequence\\n                val = i + 1\\n                if val not in used and isValid(sln, tIdx, val):\\n                    # place val\\n                    used.add(val)\\n                    sln[tIdx] = val\\n                    if val != 1:\\n                        sln[tIdx+val] = val\\n\\n                    v = backtrack(sln, used)\\n                    if v: return v\\n\\n                    # backtrack: undo placement\\n                    sln[tIdx] = None\\n                    if val != 1:\\n                        sln[tIdx+val] = None\\n                    used.remove(val)\\n        return backtrack([None for _ in range(N)], set())\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        N = (n * 2) - 1 # final length of solution\\n        def isValid(sln, curIdx, val):\\n            # check if we can place val at curIdx (and curIdx + val, if needed)\\n            if val == 1:\\n                return sln[curIdx] is None\\n            else:\\n                return (curIdx + val) < len(sln) and sln[curIdx] is None and sln[curIdx + val] is None\\n        def backtrack(sln, used):\\n            # find an open spot to place our value\\n            for tIdx in range(N):\\n                if sln[tIdx] is None:\\n                    break\\n            if tIdx == N - 1 and sln[-1] is not None: return sln[:] # all spots taken, we found a solution\\n            \\n            for i in range(n)[::-1]: # iterate in reverse for lexicographically largest sequence\\n                val = i + 1\\n                if val not in used and isValid(sln, tIdx, val):\\n                    # place val\\n                    used.add(val)\\n                    sln[tIdx] = val\\n                    if val != 1:\\n                        sln[tIdx+val] = val\\n\\n                    v = backtrack(sln, used)\\n                    if v: return v\\n\\n                    # backtrack: undo placement\\n                    sln[tIdx] = None\\n                    if val != 1:\\n                        sln[tIdx+val] = None\\n                    used.remove(val)\\n        return backtrack([None for _ in range(N)], set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008990,
                "title": "python-40ms-easy-understanding-simple",
                "content": "```\\n\\n\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        \\n        if n==1:\\n            return [1]\\n        \\n        cand_l = []\\n        for i in range(n,0,-1):\\n            cand_l.append(i)\\n                        \\n        res_l=[0] * ((n-1)*2+1)\\n        \\n        def backtrack(i):\\n            if i == len(res_l):\\n                self.end=True\\n                return\\n            \\n            if res_l[i]!=0:\\n                backtrack(i+1)\\n                return\\n            \\n            for j in range(0, len(cand_l), 1):                    \\n                top = cand_l[j]\\n                if top==0:\\n                    continue\\n                    \\n                if top==1:\\n                    res_l[i]=top\\n                    \\n                    tmp = cand_l[j]\\n                    cand_l[j]=0\\n                    \\n                    backtrack(i+1)\\n                    if(self.end): return\\n                    \\n                    res_l[i]=0\\n                    cand_l[j]=tmp\\n                    continue\\n                    \\n                if i+top<len(res_l) and res_l[i+top]==0:   \\n                    res_l[i]=top\\n                    res_l[i+top]=top\\n                    \\n                    tmp = cand_l[j]\\n                    cand_l[j]=0\\n                    \\n                    backtrack(i+1)\\n                    if(self.end): return\\n                    \\n                    res_l[i]=0\\n                    res_l[i+top]=0\\n                    cand_l[j]=tmp\\n            \\n            \\n        self.end = False\\n        backtrack(0)\\n        \\n        return res_l\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n        \\n        if n==1:\\n            return [1]\\n        \\n        cand_l = []\\n        for i in range(n,0,-1):\\n            cand_l.append(i)\\n                        \\n        res_l=[0] * ((n-1)*2+1)\\n        \\n        def backtrack(i):\\n            if i == len(res_l):\\n                self.end=True\\n                return\\n            \\n            if res_l[i]!=0:\\n                backtrack(i+1)\\n                return\\n            \\n            for j in range(0, len(cand_l), 1):                    \\n                top = cand_l[j]\\n                if top==0:\\n                    continue\\n                    \\n                if top==1:\\n                    res_l[i]=top\\n                    \\n                    tmp = cand_l[j]\\n                    cand_l[j]=0\\n                    \\n                    backtrack(i+1)\\n                    if(self.end): return\\n                    \\n                    res_l[i]=0\\n                    cand_l[j]=tmp\\n                    continue\\n                    \\n                if i+top<len(res_l) and res_l[i+top]==0:   \\n                    res_l[i]=top\\n                    res_l[i+top]=top\\n                    \\n                    tmp = cand_l[j]\\n                    cand_l[j]=0\\n                    \\n                    backtrack(i+1)\\n                    if(self.end): return\\n                    \\n                    res_l[i]=0\\n                    res_l[i+top]=0\\n                    cand_l[j]=tmp\\n            \\n            \\n        self.end = False\\n        backtrack(0)\\n        \\n        return res_l\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1008961,
                "title": "c-backtracking",
                "content": "```\\nvector<int> res;   \\nvoid find(vector<int> curr, int n, int pos, vector<bool> &vis)\\n{\\n\\tif(res.size()>0) return;\\n\\tif(pos==curr.size())\\n\\t{\\n\\t\\tres = curr;\\n\\t\\treturn;\\n\\t}\\n\\tif(curr[pos]!=-1) return find(curr,n,pos+1,vis);\\n\\tfor(int i=n;i>=1;i--)\\n\\t{\\n\\t\\tif(res.size()>0) return;\\n\\t\\tif(!vis[i])\\n\\t\\t{\\n\\t\\t\\tvis[i] = true;\\n\\t\\t\\tif(i==1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurr[pos] = i;\\n\\t\\t\\t\\tfind(curr,n,pos+1,vis);\\n\\t\\t\\t\\tcurr[pos] = -1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(pos+i<curr.size() && curr[pos+i]==-1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurr[pos] = i;\\n\\t\\t\\t\\t\\tcurr[pos+i] = i;\\n\\t\\t\\t\\t\\tfind(curr,n,pos+1,vis);\\n\\t\\t\\t\\t\\tcurr[pos] = -1;\\n\\t\\t\\t\\t\\tcurr[pos+i] = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvis[i] = false;\\n\\t\\t}\\n\\t}\\n}\\n\\nvector<int> constructDistancedSequence(int n) {\\n\\tvector<int> curr((2*n)-1,-1);\\n\\tvector<bool> vis(n+1,false);\\n\\tfind(curr,n,0,vis);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> res;   \\nvoid find(vector<int> curr, int n, int pos, vector<bool> &vis)\\n{\\n\\tif(res.size()>0) return;\\n\\tif(pos==curr.size())\\n\\t{\\n\\t\\tres = curr;\\n\\t\\treturn;\\n\\t}\\n\\tif(curr[pos]!=-1) return find(curr,n,pos+1,vis);\\n\\tfor(int i=n;i>=1;i--)\\n\\t{\\n\\t\\tif(res.size()>0) return;\\n\\t\\tif(!vis[i])\\n\\t\\t{\\n\\t\\t\\tvis[i] = true;\\n\\t\\t\\tif(i==1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurr[pos] = i;\\n\\t\\t\\t\\tfind(curr,n,pos+1,vis);\\n\\t\\t\\t\\tcurr[pos] = -1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(pos+i<curr.size() && curr[pos+i]==-1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurr[pos] = i;\\n\\t\\t\\t\\t\\tcurr[pos+i] = i;\\n\\t\\t\\t\\t\\tfind(curr,n,pos+1,vis);\\n\\t\\t\\t\\t\\tcurr[pos] = -1;\\n\\t\\t\\t\\t\\tcurr[pos+i] = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvis[i] = false;\\n\\t\\t}\\n\\t}\\n}\\n\\nvector<int> constructDistancedSequence(int n) {\\n\\tvector<int> curr((2*n)-1,-1);\\n\\tvector<bool> vis(n+1,false);\\n\\tfind(curr,n,0,vis);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": []
    }
]