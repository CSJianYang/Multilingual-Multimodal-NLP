[
    {
        "title": "Palindrome Number",
        "question_content": "Given an integer x, return true if x is a palindrome, and false otherwise.\n&nbsp;\nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n&nbsp;\nConstraints:\n\n\t-231&nbsp;<= x <= 231&nbsp;- 1\n\n&nbsp;\nFollow up: Could you solve it without converting the integer to a string?",
        "solutions": [
            {
                "id": 5127,
                "title": "9-line-accepted-java-code-without-the-need-of-handling-overflow",
                "content": "compare half of the digits in x, so don't need to deal with overflow.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n        \\trev = rev*10 + x%10;\\n        \\tx = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }",
                "solutionTags": [],
                "code": "compare half of the digits in x, so don't need to deal with overflow.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n        \\trev = rev*10 + x%10;\\n        \\tx = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 785314,
                "title": "python-3-1-solution-is-89-20-faster-2nd-is-99-14-faster-explanation-added",
                "content": "**Suggestions to make them better are always welcomed.**\\n\\n**Solution 1: 89.20% faster**\\nThis is the easiest way to check if integer is palindrome. \\n\\nConvert the number to string and compare it with the reversed string.\\n\\nI wrote this working solution first and then found in the description that we need to solve this problem without converting the input to string. Then I wrote solution 2.\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```\\n\\nIf we don\\'t want to convert the number to string, then recreate a new number in reverse order.\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x<0:\\n\\t\\treturn False\\n\\n\\tinputNum = x\\n\\tnewNum = 0\\n\\twhile x>0:\\n\\t\\tnewNum = newNum * 10 + x%10\\n\\t\\tx = x//10\\n\\treturn newNum == inputNum\\n```\\n\\n**Solution 2: 99.14% faster.**\\nI\\'d recommend you to solve leetcode question 7 (reverse integer) to understand the logic behind this solution.\\n\\nPython3 int type has no lower or upper bounds. But if there are constraints given then we have to make sure that while reversing the integer we don\\'t cross those constraints.\\n\\nSo, instead of reversing the whole integer, let\\'s convert half of the integer and then check if it\\'s palindrome.\\nBut we don\\'t know when is that half going to come. \\n\\nExample, if x = 15951, then let\\'s create reverse of x in loop. Initially, x = 15951, revX = 0\\n1. x = 1595, revX = 1\\n2. x = 159, revX = 15\\n3. x = 15, revX = 159\\n\\nWe see that revX > x after  3 loops and we crossed the half way in the integer bcoz it\\'s an odd length integer.\\nIf it\\'s an even length integer, our loop stops exactly in the middle.\\n\\nNow we can compare x and revX, if even length, or x and revX//10 if odd length and return True if they match.\\n\\nThere\\'s a difference between / and // division in Python3. Read it here on [stackoverflow](https://stackoverflow.com/questions/183853/what-is-the-difference-between-and-when-used-for-division).\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\\n\\t\\treturn False\\n\\t\\n\\tresult = 0\\n\\twhile x > result:\\n\\t\\tresult = result * 10 + x % 10\\n\\t\\tx = x // 10\\n\\t\\t\\n\\treturn True if (x == result or x == result // 10) else False\\n```\\n\\n **If you like the solutions, please upvote it for better reach to other people.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n\\t\\treturn False\\n\\t\\n\\treturn str(x) == str(x)[::-1]\\n```\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x<0:\\n\\t\\treturn False\\n\\n\\tinputNum = x\\n\\tnewNum = 0\\n\\twhile x>0:\\n\\t\\tnewNum = newNum * 10 + x%10\\n\\t\\tx = x//10\\n\\treturn newNum == inputNum\\n```\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\\n\\t\\treturn False\\n\\t\\n\\tresult = 0\\n\\twhile x > result:\\n\\t\\tresult = result * 10 + x % 10\\n\\t\\tx = x // 10\\n\\t\\t\\n\\treturn True if (x == result or x == result // 10) else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3213890,
                "title": "fastest-java-solution",
                "content": "## For better Visualization:\\n\\n[https://www.youtube.com/watch?v=9xUcC6iIq7I]()\\n\\n## Idea\\nWe\\'re going to convert our **int** to **String** and then compare the first element to the very last element, second element to second last element and so on *[elements at the same distance from the beginning and from the end]*.. If they don\\'t match we return a False\\n\\n## JAVA Code\\n``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = String.valueOf(x); // Convert to String\\n        int n = s.length(); // Store the String length to int n\\n\\n        for (int i=0; i<n/2; i++) {\\n            // We check whether the elements at the same distance from\\n            // beginning and from ending are same, if not we return false\\n            if (s.charAt(i) != s.charAt(n-i-1)) return false;\\n        }\\n\\n        // if no flaws are found we return true\\n        return true;\\n    }\\n}\\n```\\n\\nThere is another approach to this problem:\\n\\nWe can store one half of the integer in a another variable in reversed order. Then we compare it to the other unaltered half of the number and see if they are equal or not [which should be in case of palindromes]\\n\\n``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/d141c86e-a7ed-4750-baa3-2ae88d11bf05_1676971396.8824553.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = String.valueOf(x); // Convert to String\\n        int n = s.length(); // Store the String length to int n\\n\\n        for (int i=0; i<n/2; i++) {\\n            // We check whether the elements at the same distance from\\n            // beginning and from ending are same, if not we return false\\n            if (s.charAt(i) != s.charAt(n-i-1)) return false;\\n        }\\n\\n        // if no flaws are found we return true\\n        return true;\\n    }\\n}\\n```\n``` JAVA []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x<0 || (x!=0 && x%10==0)) return false;\\n        int rev = 0;\\n        while (x>rev){\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        return (x==rev || x==rev/10);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5165,
                "title": "an-easy-c-8-lines-code-only-reversing-till-half-and-then-compare",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x<0|| (x!=0 &&x%10==0)) return false;\\n            int sum=0;\\n            while(x>sum)\\n            {\\n                sum = sum*10+x%10;\\n                x = x/10;\\n            }\\n            return (x==sum)||(x==sum/10);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x<0|| (x!=0 &&x%10==0)) return false;\\n            int sum=0;\\n            while(x>sum)\\n            {\\n                sum = sum*10+x%10;\\n                x = x/10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3651712,
                "title": "2-method-s-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nThe intuition behind this code is to reverse the entire input number and check if the reversed number is equal to the original number. If they are the same, then the number is a palindrome.\\n\\n# Approach 1: Reversing the Entire Number\\n# Explanation:\\n1. We begin by performing an initial check. If the input number `x` is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return `false`.\\n\\n2. We initialize two variables:\\n   - `reversed`: This variable will store the reversed value of the number `x`.\\n   - `temp`: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\\n\\n3. We enter a loop that continues until `temp` becomes zero:\\n   - Inside the loop, we extract the last digit of `temp` using the modulo operator `%` and store it in the `digit` variable.\\n   - To reverse the number, we multiply the current value of `reversed` by 10 and add the extracted `digit`.\\n   - We then divide `temp` by 10 to remove the last digit and move on to the next iteration.\\n\\n4. Once the loop is completed, we have reversed the entire number. Now, we compare the reversed value `reversed` with the original input value `x`.\\n   - If they are equal, it means the number is a palindrome, so we return `true`.\\n   - If they are not equal, it means the number is not a palindrome, so we return `false`.\\n\\nThe code uses a `long long` data type for the `reversed` variable to handle potential overflow in case of large input numbers.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long long reversed = 0;\\n        long long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = temp % 10;\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n};\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long reversed = 0;\\n        long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = (int) (temp % 10);\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n\\n        reversed_num = 0\\n        temp = x\\n\\n        while temp != 0:\\n            digit = temp % 10\\n            reversed_num = reversed_num * 10 + digit\\n            temp //= 10\\n\\n        return reversed_num == x\\n\\n```\\n\\n# Approach 2: Reversing Half of the Number\\nInstead of reversing the entire number, we can reverse only the last half of the number. This approach is tricky because when we reverse the last half of the number, we don\\'t want the middle digit to be reversed back to its original value. This can happen if the number has an odd number of digits. To resolve this, we can compare the first half of the number with the reversed second half of the number.\\n# Explanation:\\n1. We begin with an initial check to handle special cases:\\n   - If the input number `x` is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return `false`.\\n   - If `x` is non-zero and ends with a zero, it cannot be a palindrome because leading zeros are not allowed in palindromes. We return `false` for such cases.\\n\\n2. We initialize two variables:\\n   - `reversed`: This variable will store the reversed second half of the digits of the number.\\n   - `temp`: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\\n\\n3. We enter a loop that continues until the first half of the digits (`x`) becomes less than or equal to the reversed second half (`reversed`):\\n   - Inside the loop, we extract the last digit of `x` using the modulo operator `%` and add it to the `reversed` variable after multiplying it by 10 (shifting the existing digits to the left).\\n   - We then divide `x` by 10 to remove the last digit and move towards the center of the number.\\n\\n4. Once the loop is completed, we have reversed the second half of the digits. Now, we compare the first half of the digits (`x`) with the reversed second half (`reversed`) to determine if the number is a palindrome:\\n   - For an even number of digits, if `x` is equal to `reversed`, then the number is a palindrome. We return `true`.\\n   - For an odd number of digits, if `x` is equal to `reversed / 10` (ignoring the middle digit), then the number is a palindrome. We return `true`.\\n   - If none of the above conditions are met, it means the number is not a palindrome, so we return `false`.\\n\\nThe code avoids the need for reversing the entire number by comparing only the necessary parts. This approach reduces both time complexity and memory usage, resulting in a more efficient solution.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        int original = x;\\n\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        reversed_num = 0\\n        original = x\\n\\n        while x > reversed_num:\\n            reversed_num = reversed_num * 10 + x % 10\\n            x //= 10\\n\\n        return x == reversed_num or x == reversed_num // 10\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/bc4560f0-64e2-4083-8f14-c5e8220c2e7f_1687078450.4746537.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long long reversed = 0;\\n        long long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = temp % 10;\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n\\n        long reversed = 0;\\n        long temp = x;\\n\\n        while (temp != 0) {\\n            int digit = (int) (temp % 10);\\n            reversed = reversed * 10 + digit;\\n            temp /= 10;\\n        }\\n\\n        return (reversed == x);\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n\\n        reversed_num = 0\\n        temp = x\\n\\n        while temp != 0:\\n            digit = temp % 10\\n            reversed_num = reversed_num * 10 + digit\\n            temp //= 10\\n\\n        return reversed_num == x\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n\\n        int reversed = 0;\\n        int original = x;\\n\\n        while (x > reversed) {\\n            reversed = reversed * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n        return (x == reversed) || (x == reversed / 10);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        reversed_num = 0\\n        original = x\\n\\n        while x > reversed_num:\\n            reversed_num = reversed_num * 10 + x % 10\\n            x //= 10\\n\\n        return x == reversed_num or x == reversed_num // 10\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283534,
                "title": "accepted-java-c-code-beats-98",
                "content": "**Note:**\\n\\n**`Check only half of the digits of given number to prevent OVERFLOW`**\\n\\n# Complexity\\n- Time complexity: $$O(n/2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JAVA :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **9** *ms* | *Beats* **98%**\\n**Memory** | **40** *MB* | *Beats* **67%**\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0 || x!=0 && x%10 ==0 ) return false;\\n        int check=0;\\n        while(x>check){\\n            check = check*10 + x%10;\\n            x/=10;\\n        }\\n        return (x==check || x==check/10);\\n    }\\n}\\n````\\n# C :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **15** *ms* | *Beats* **80%**\\n**Memory** | **6** *MB* | *Beats* **93%**\\n```\\nbool isPalindrome(int x){\\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\\n    int check=0;\\n    while(x>check){\\n        check = check*10 + x%10;\\n        x/=10;\\n    }\\n    return (x==check || x==check/10);\\n}\\n```\\n```\\n **   Use similar Math in PYTHON / C++   **\\n```\\n## UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0 || x!=0 && x%10 ==0 ) return false;\\n        int check=0;\\n        while(x>check){\\n            check = check*10 + x%10;\\n            x/=10;\\n        }\\n        return (x==check || x==check/10);\\n    }\\n}\\n```\n```\\nbool isPalindrome(int x){\\n    if(x<0 || x!=0 && x%10 ==0 ) return false;\\n    int check=0;\\n    while(x>check){\\n        check = check*10 + x%10;\\n        x/=10;\\n    }\\n    return (x==check || x==check/10);\\n}\\n```\n```\\n **   Use similar Math in PYTHON / C++   **\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499161,
                "title": "99-22-javascript-dart-without-converting-the-integer-to-a-string",
                "content": "#### How to reverse the number\\n```\\noriginal number: 543\\nreverse number: 0\\n\\n//Get the last digit of the original number\\noriginal % 10 = 543 % 10 = 3\\n//Put this digit as the last one in the reverse number\\nreverse * 10 + digit = 0 * 10 + 3 = 0 + 3 = 3\\nreverse: 3\\n//Remove this digit from the original number\\noriginal / 10 = 543 / 10 = 54.3\\n~~54.3 = 54\\noriginal: 54\\n\\n//Repeat\\noriginal % 10 = 54 % 10 = 4\\nreverse * 10 + digit = 3 * 10 + 4 = 30 + 4 = 34\\nreverse: 34\\noriginal / 10 = 54 / 10 = 5.4\\n~~5.4 = 5\\noriginal: 5\\n\\n//Repeat\\noriginal % 10 = 5 % 10 = 5\\nreverse * 10 + digit = 34 * 10 + 5 = 340 + 5 = 345\\nreverse: 345\\noriginal / 10 = 5 / 10 = 0.5\\n~~0.5 = 0\\noriginal: 0\\n\\ninput: 543\\noutput: 345\\n\\n```\\n\\nSo if the reverse number is equal to the original number, then it is a palindrome\\n\\n```\\n345 != 543 //not palindrome\\n272 == 272 //is palindrome\\n```\\n\\n**Please upvote if it was helpful!**\\n\\n``` JavaScript []\\nvar isPalindrome = function(x) {\\n    var reverse = 0;\\n    var copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      const digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = ~~(copy / 10);\\n    }\\n\\n    return reverse == x;\\n};\\n```\\n``` Dart []\\nclass Solution {\\n  bool isPalindrome(int x) {\\n    int reverse = 0;\\n    int copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      final digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = copy ~/ 10;\\n    }\\n\\n    return reverse == x;\\n  }\\n}\\n\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/786157401/)",
                "solutionTags": [
                    "JavaScript",
                    "Dart"
                ],
                "code": "```\\noriginal number: 543\\nreverse number: 0\\n\\n//Get the last digit of the original number\\noriginal % 10 = 543 % 10 = 3\\n//Put this digit as the last one in the reverse number\\nreverse * 10 + digit = 0 * 10 + 3 = 0 + 3 = 3\\nreverse: 3\\n//Remove this digit from the original number\\noriginal / 10 = 543 / 10 = 54.3\\n~~54.3 = 54\\noriginal: 54\\n\\n//Repeat\\noriginal % 10 = 54 % 10 = 4\\nreverse * 10 + digit = 3 * 10 + 4 = 30 + 4 = 34\\nreverse: 34\\noriginal / 10 = 54 / 10 = 5.4\\n~~5.4 = 5\\noriginal: 5\\n\\n//Repeat\\noriginal % 10 = 5 % 10 = 5\\nreverse * 10 + digit = 34 * 10 + 5 = 340 + 5 = 345\\nreverse: 345\\noriginal / 10 = 5 / 10 = 0.5\\n~~0.5 = 0\\noriginal: 0\\n\\ninput: 543\\noutput: 345\\n\\n```\n```\\n345 != 543 //not palindrome\\n272 == 272 //is palindrome\\n```\n``` JavaScript []\\nvar isPalindrome = function(x) {\\n    var reverse = 0;\\n    var copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      const digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = ~~(copy / 10);\\n    }\\n\\n    return reverse == x;\\n};\\n```\n``` Dart []\\nclass Solution {\\n  bool isPalindrome(int x) {\\n    int reverse = 0;\\n    int copy = x;\\n\\n    //The loop break when the copy of original number becomes zero\\n    //Also negative number cannot be a palindrome\\n    while (copy > 0) {\\n      final digit = copy % 10;\\n      reverse = reverse * 10 + digit;\\n      copy = copy ~/ 10;\\n    }\\n\\n    return reverse == x;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398168,
                "title": "c-three-simple-and-short-different-solutions",
                "content": "**Solution I:**\\nConvert the number to a string, revert it and compare.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string rev = to_string(x);\\n        reverse(rev.begin(), rev.end());\\n        return to_string(x) == rev;\\n    }\\n};\\n```\\n**Solution II:**\\nConvert the number to a string, then use two pointers at beginning and end to check if it\\'s a palindrome.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.size()-1;\\n        while (i <= j) if (s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n};\\n```\\n**Solution III:**\\nReverse the second half of the number and then compare.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x % 10 == 0 && x != 0)) return false;\\n        int rev = 0;\\n        while (rev < x) {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        \\n        return x == rev || x == rev / 10;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string rev = to_string(x);\\n        reverse(rev.begin(), rev.end());\\n        return to_string(x) == rev;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.size()-1;\\n        while (i <= j) if (s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x % 10 == 0 && x != 0)) return false;\\n        int rev = 0;\\n        while (rev < x) {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        \\n        return x == rev || x == rev / 10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387961,
                "title": "no-string-or-array-conversion-4-lines-99-66-beat",
                "content": "Use a varibale to reverse number then check with given number\\n```\\nvar isPalindrome = function(x) {\\n  if (x < 0) return false\\n\\n  let rev = 0\\n  for(let i = x; i >= 1; i = Math.floor(i/10)) rev = rev*10 + i%10\\n  return rev === x\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n  if (x < 0) return false\\n\\n  let rev = 0\\n  for(let i = x; i >= 1; i = Math.floor(i/10)) rev = rev*10 + i%10\\n  return rev === x\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5188,
                "title": "o-1-space-o-lgn-time-java-solution-no-overflow-risk",
                "content": "    public boolean isPalindrome(int x) {\\n        \\n        if (x < 0) return false;\\n\\n        int p = x; \\n        int q = 0; \\n        \\n        while (p >= 10){\\n            q *=10; \\n            q += p%10; \\n            p /=10; \\n        }\\n        \\n        return q == x / 10 && p == x % 10;\\n    }\\n\\n// so the reversed version of int is always  1 time short in the factor of 10s . \\n\\nin case of Int16,  check 63556  will finally check if (6553 == 6355 && 6 == 63556%10)  so there will have no concerns about the overflow.",
                "solutionTags": [],
                "code": "    public boolean isPalindrome(int x) {\\n        \\n        if (x < 0) return false;\\n\\n        int p = x; \\n        int q = 0; \\n        \\n        while (p >= 10){\\n            q *=10; \\n            q += p%10; \\n            p /=10; \\n        }\\n        \\n        return q == x / 10 && p == x % 10;\\n    }\\n\\n// so the reversed version of int is always  1 time short in the factor of 10s . \\n\\nin case of Int16,  check 63556  will finally check if (6553 == 6355 && 6 == 63556%10)  so there will have no concerns about the overflow.",
                "codeTag": "Unknown"
            },
            {
                "id": 5128,
                "title": "python-solution-based-on-the-algorithm-in-leetcode-blog",
                "content": "    class Solution:\\n        # @param x, an integer\\n        # @return a boolean\\n        def isPalindrome(self, x):\\n            if x < 0:\\n                return False\\n    \\n            ranger = 1\\n            while x / ranger >= 10:\\n                ranger *= 10\\n    \\n            while x:\\n                left = x / ranger\\n                right = x % 10\\n                if left != right:\\n                    return False\\n                \\n                x = (x % ranger) / 10\\n                ranger /= 100\\n    \\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param x, an integer\\n        # @return a boolean\\n        def isPalindrome(self, x):\\n            if x < 0:\\n                return False\\n    \\n            ranger = 1\\n            while x / ranger >= 10:\\n                ranger *= 10\\n    \\n            while x:\\n                left = x / ranger\\n                right = x % 10\\n                if left != right:\\n                    return False\\n                \\n                x = (x % ranger) / 10\\n                ranger /= 100\\n    \\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 316164,
                "title": "python-no-string-involved",
                "content": "Reads the number backwards and checks if the numbers are equal.\\n<br>\\n```\\nimport math \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        orig = x\\n        back_x = 0\\n        while x > 0:\\n            back_x = (back_x * 10) + (x % 10)\\n            x = x // 10\\n        return orig == back_x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        orig = x\\n        back_x = 0\\n        while x > 0:\\n            back_x = (back_x * 10) + (x % 10)\\n            x = x // 10\\n        return orig == back_x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176639,
                "title": "java-c-best-solution-simple-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      String s = String.valueOf(x);  \\n\\n        int i = 0;                   \\n        int j = s.length() - 1; \\n       \\n          while(i <= j)      \\n        {\\n            if(s.charAt(i) != s.charAt(j))  \\n                return false;\\n            i++;                                \\n            j--;                                \\n        }  \\n        \\n        return true;\\n        \\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      String s = String.valueOf(x);  \\n\\n        int i = 0;                   \\n        int j = s.length() - 1; \\n       \\n          while(i <= j)      \\n        {\\n            if(s.charAt(i) != s.charAt(j))  \\n                return false;\\n            i++;                                \\n            j--;                                \\n        }  \\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047788,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        stack<int> st;\\n        if(x<0)\\n            return false;\\n        int y=x;\\n        while(x)\\n        {\\n            st.push(x%10);\\n            x/=10;\\n        }\\n        while(y)\\n        {\\n            if(st.top()!=(y%10))\\n               return false;\\n             st.pop();\\n               y/=10;\\n        }\\n        return true;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        stack<int> st;\\n        if(x<0)\\n            return false;\\n        int y=x;\\n        while(x)\\n        {\\n            st.push(x%10);\\n            x/=10;\\n        }\\n        while(y)\\n        {\\n            if(st.top()!=(y%10))\\n               return false;\\n             st.pop();\\n               y/=10;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5408,
                "title": "simple-java-o-1-space-solution",
                "content": "    public boolean isPalindrome(int x) {\\n        if(x<0 || (x!=0 && x%10==0))\\n        return false;\\n        int res = 0;\\n           while(x>res){\\n            res = res*10 + x%10;\\n            x = x/10;\\n           }\\n        return (x==res || x==res/10);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isPalindrome(int x) {\\n        if(x<0 || (x!=0 && x%10==0))\\n        return false;\\n        int res = 0;\\n           while(x>res){\\n            res = res*10 + x%10;\\n            x = x/10;\\n           }\\n        return (x==res || x==res/10);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1136330,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return x < 0 ? false : method(x: x) == x\\n    }\\n    private func method(x: Int) -> Int {\\n        var r = 0\\n        var x = x\\n        while x != 0 {\\n            r = r * 10\\n            r = r + x % 10\\n            x /= 10\\n        }\\n        return (r < Int32.min || r > Int32.max) ? 0 : r\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<br>\\n\\n<pre>\\n<b>Result:</b> Executed 4 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isPalindrome(121)\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.isPalindrome(-121)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test2() {\\n        let value = solution.isPalindrome(10)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test3() {\\n        let value = solution.isPalindrome(-101)\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return x < 0 ? false : method(x: x) == x\\n    }\\n    private func method(x: Int) -> Int {\\n        var r = 0\\n        var x = x\\n        while x != 0 {\\n            r = r * 10\\n            r = r + x % 10\\n            x /= 10\\n        }\\n        return (r < Int32.min || r > Int32.max) ? 0 : r\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isPalindrome(121)\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.isPalindrome(-121)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test2() {\\n        let value = solution.isPalindrome(10)\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test3() {\\n        let value = solution.isPalindrome(-101)\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471810,
                "title": "168-ms-faster-than-97-26",
                "content": "```\\nvar isPalindrome = function(x) {\\n    const arr = String(x).split(\\'\\');\\n        \\n    while (arr.length > 1) {\\n        if (arr.shift() !== arr.pop()) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n    const arr = String(x).split(\\'\\');\\n        \\n    while (arr.length > 1) {\\n        if (arr.shift() !== arr.pop()) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976350,
                "title": "simple-java-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst we have to understand what is meant by a \"**PALINDROME**\" number.\\nSuppose we have a number \\'x\\'. If we **REVERSE** x and store it in \\'y\\' then x and y should be EQUAL.\\n\\nMathematically, x is palindrome iff x = y where y = reverse of x.\\n\\n    Example 1:\\n    let x = 123,\\n    then y = reverse of x = 321;\\n    Since, 123 != 321, Hence, x is NOT palindrome.\\n\\n    Example 2:\\n    let x = 1221,\\n    then y = reverse of x = 1221;\\n    Since 1221 == 1221, Hence, x is palindrome.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> Two-Pointer Approach       \\n        \\n    Step1: Convert the integer into string.\\n    Step2: Point two variable at first and last indices of the string.\\n    Step3: Compare the characters at those indices.\\n    Step4: Update the variables.\\nYou will get the answer.\\n\\n        **If this solution helped you, give it a like to help others.**\\n\\n# Complexity\\n- Time complexity: O(n), where n = length of integer.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        // Two-Pointer Approach\\n        \\n        \\n        // Step1: Convert the integer into string.\\n        // Step2: Point two variable at first and last indices of the string.\\n        // Step3: Compare the characters at those indices.\\n        // Step4: Update the variables.\\n\\n        String s = String.valueOf(x);  // convert integer to string.\\n\\n        int i = 0;                     // i will initially point to first index.\\n        int j = s.length() - 1;        // j will initially point to last index. \\n        \\n        // i and j are opposite indices of the string. \\n        // 1. If \\'i\\' is first then \\'j\\' is last.\\n        // 2. Similarly, if \\'i\\' is second then \\'j\\' is second last index of s.\\n        // This is because they are updated simultaneously.\\n\\n        while(i <= j)                   // loop will break when i and j cross each other\\n        {\\n            if(s.charAt(i) != s.charAt(j))  // characters at indices i and j will be compared.\\n                // If the characters are unequal then false will be returned.\\n                return false;\\n            i++;                                // i is incremented.\\n            j--;                                // j is decremented.\\n        }\\n        \\n        // If loop ends without returning false, it means that every \\'ith\\' character\\n        // is equal to every \\'jth\\' character. Thus, the number is palindrome.\\n        // Hence, return true;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        // Two-Pointer Approach\\n        \\n        \\n        // Step1: Convert the integer into string.\\n        // Step2: Point two variable at first and last indices of the string.\\n        // Step3: Compare the characters at those indices.\\n        // Step4: Update the variables.\\n\\n        String s = String.valueOf(x);  // convert integer to string.\\n\\n        int i = 0;                     // i will initially point to first index.\\n        int j = s.length() - 1;        // j will initially point to last index. \\n        \\n        // i and j are opposite indices of the string. \\n        // 1. If \\'i\\' is first then \\'j\\' is last.\\n        // 2. Similarly, if \\'i\\' is second then \\'j\\' is second last index of s.\\n        // This is because they are updated simultaneously.\\n\\n        while(i <= j)                   // loop will break when i and j cross each other\\n        {\\n            if(s.charAt(i) != s.charAt(j))  // characters at indices i and j will be compared.\\n                // If the characters are unequal then false will be returned.\\n                return false;\\n            i++;                                // i is incremented.\\n            j--;                                // j is decremented.\\n        }\\n        \\n        // If loop ends without returning false, it means that every \\'ith\\' character\\n        // is equal to every \\'jth\\' character. Thus, the number is palindrome.\\n        // Hence, return true;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549534,
                "title": "python-simple-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x) == str(x)[::-1]\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x) == str(x)[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3497184,
                "title": "c-java-python-javascript-2-approach-brute-and-optimized-fully-explained",
                "content": "# Brute Force Solution:\\n\\n### Intuition: \\nConvert the integer to a string and check if the string is equal to its reverse.\\n\\n### Approach:\\n1. Convert the integer to a string using to_string() method.\\n2. Reverse the string using the reverse() method.\\n3. Compare the original and reversed strings to check if they are equal.\\n4. If they are equal, return true. Otherwise, return false.\\n\\n## Time Complexity:\\nO(n), where n is the number of digits in the integer.\\n## Space Complexity: \\nO(n), where n is the number of digits in the integer.\\n\\n---\\n\\n\\n# Optimized Solution:\\n\\n### Intuition: \\nCheck half of the digits of the integer by extracting the last digit of the integer and adding it to a new integer.\\n\\n### Approach:\\n1. Check if the integer is negative or ends with a zero. If it is, return false.\\n2. Initialize a new integer half to 0.\\n3. While the original integer x is greater than half, extract the last digit of x and add it to half by multiplying half by 10 and adding the last digit of x.\\n4. If the length of x is odd, we need to remove the middle digit from half. To do this, we can simply divide half by 10.\\n5. Check if x is equal to half or half divided by 10.\\n6. If they are equal, return true. Otherwise, return false.\\n\\n### Time Complexity: \\nO(log n), where n is the value of the integer.\\n### Space Complexity: \\nO(1), as we only need to store two integers, x and half.\\n\\n---\\n# C++\\n### Brute Force\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```\\n### Optimized\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n};\\n\\n```\\n\\n---\\n# JAVA\\n### Brute Force\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = Integer.toString(x);\\n        String t = new StringBuilder(s).reverse().toString();\\n        return s.equals(t);\\n    }\\n}\\n```\\n### Optimized\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n### Brute Force\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        s = str(x)\\n        t = s[::-1]\\n        return s == t\\n```\\n### Optimized\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n        half = 0\\n        while x > half:\\n            half = half * 10 + x % 10\\n            x //= 10\\n        return x == half or x == half // 10\\n```\\n\\n---\\n# JavaScript\\n### Brute Force\\n```\\nvar isPalindrome = function(x) {\\n    var s = x.toString();\\n    var t = s.split(\"\").reverse().join(\"\");\\n    return s === t;\\n};\\n```\\n### Optimized\\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || (x !== 0 && x % 10 === 0)) {\\n        return false;\\n    }\\n    var half = 0;\\n    while (x > half) {\\n        half = half * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return x === half || x === Math.floor(half / 10);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s == t;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String s = Integer.toString(x);\\n        String t = new StringBuilder(s).reverse().toString();\\n        return s.equals(t);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        int half = 0;\\n        while (x > half) {\\n            half = half * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return x == half || x == half / 10;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        s = str(x)\\n        t = s[::-1]\\n        return s == t\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n        half = 0\\n        while x > half:\\n            half = half * 10 + x % 10\\n            x //= 10\\n        return x == half or x == half // 10\\n```\n```\\nvar isPalindrome = function(x) {\\n    var s = x.toString();\\n    var t = s.split(\"\").reverse().join(\"\");\\n    return s === t;\\n};\\n```\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || (x !== 0 && x % 10 === 0)) {\\n        return false;\\n    }\\n    var half = 0;\\n    while (x > half) {\\n        half = half * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return x === half || x === Math.floor(half / 10);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5156,
                "title": "two-python-solution-with-o-1-space",
                "content": "\\nI. reverse the number first and see if it is equal to the original number.\\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        p, res = x, 0\\n        while p:\\n            res = res * 10 + p % 10\\n            p /= 10\\n        return res == x\\n\\nII. find the largest power of 10 which is smaller then x first. Then check if left most digit is equal to right most digit and so on. \\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        b = 1\\n        while x / b >= 10:\\n            b *= 10\\n        while b >= 10:\\n            if x / b != x % 10:\\n                return False\\n            x, b = (x % b) / 10, b / 100\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nI. reverse the number first and see if it is equal to the original number.\\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        p, res = x, 0\\n        while p:\\n            res = res * 10 + p % 10\\n            p /= 10\\n        return res == x\\n\\nII. find the largest power of 10 which is smaller then x first. Then check if left most digit is equal to right most digit and so on. \\n\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        b = 1\\n        while x / b >= 10:\\n            b *= 10\\n        while b >= 10:\\n            if x / b != x % 10:\\n                return False\\n            x, b = (x % b) / 10, b / 100\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 2996838,
                "title": "python-one-line-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString has method to reverse\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwith reversing it is possible to write in one line\\n\\'[::]\\' this means print all, and this \\'[::-1]\\' reverses, it is mostly used with list in python \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return True if str(x)==str(x)[::-1] else False",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString has method to reverse\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwith reversing it is possible to write in one line\\n\\'[::]\\' this means print all, and this \\'[::-1]\\' reverses, it is mostly used with list in python \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return True if str(x)==str(x)[::-1] else False",
                "codeTag": "Java"
            },
            {
                "id": 234068,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;\\n\\t\\n    // reverse the string representation of x\\n    const reverse = `${x}`.split(\\'\\').reverse().join(\\'\\');\\n    // compare the value regardless of types\\n    return x == reverse;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;\\n\\t\\n    // reverse the string representation of x\\n    const reverse = `${x}`.split(\\'\\').reverse().join(\\'\\');\\n    // compare the value regardless of types\\n    return x == reverse;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5262,
                "title": "neat-ac-java-code-o-n-time-complexity",
                "content": "    public boolean isPalindrome(int x) {\\n            int palindromeX = 0;\\n            int inputX = x;\\n            while(x>0){\\n                palindromeX = palindromeX*10 + (x % 10);\\n                x = x/10;\\n            }\\n            return palindromeX==inputX;\\t\\n        }",
                "solutionTags": [],
                "code": "    public boolean isPalindrome(int x) {\\n            int palindromeX = 0;\\n            int inputX = x;\\n            while(x>0){\\n                palindromeX = palindromeX*10 + (x % 10);\\n                x = x/10;\\n            }\\n            return palindromeX==inputX;\\t\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2739816,
                "title": "java-no-string-faster-than-97-easy",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int original = x;\\n        int rev = 0;\\n        while(x>0){\\n            rev = x%10 + rev*10;\\n            x= x/10;\\n        }\\n        return rev==original ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int original = x;\\n        int rev = 0;\\n        while(x>0){\\n            rev = x%10 + rev*10;\\n            x= x/10;\\n        }\\n        return rev==original ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122215,
                "title": "js-one-liner-beats-93",
                "content": "**Please Upvote if you like this solution.**\\n\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    return x < 0 ? false : (x === +x.toString().split(\"\").reverse().join(\"\"));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    return x < 0 ? false : (x === +x.toString().split(\"\").reverse().join(\"\"));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5230,
                "title": "7-line-simple-c-solution-beats-90-submissions-in-o-1-space-two-pointers",
                "content": "Use two pointers concept, find the half point, and compare first half and 2nd half. \\n\\nVariable ***revhalf*** is the reversed 2nd half(x has even number of digits), or 2nd half with the middle digit(if x has odd number of digits)\\n\\n    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x < 0) return false;\\n            int revhalf = 0, slow = x, fast = x;\\n            while(fast){ \\n                revhalf = revhalf * 10 + slow % 10;\\n                slow /= 10;\\n                fast /= 100;\\n            }\\n            return slow == revhalf || slow == revhalf / 10;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(x < 0) return false;\\n            int revhalf = 0, slow = x, fast = x;\\n            while(fast){ \\n                revhalf = revhalf * 10 + slow % 10;\\n                slow /= 10;\\n                fast /= 100;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2732678,
                "title": "js-91-45-no-string",
                "content": "*Upvote if you like my solution ;-)*\\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || x % 10 == 0 && x !=0)  {\\n        return false;\\n    }\\n    let t = 0;\\n    while (x > t) {\\n        t = t * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return t==x || x==Math.floor(t/10);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if (x < 0 || x % 10 == 0 && x !=0)  {\\n        return false;\\n    }\\n    let t = 0;\\n    while (x > t) {\\n        t = t * 10 + x % 10;\\n        x = Math.floor(x / 10);\\n    }\\n    return t==x || x==Math.floor(t/10);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212525,
                "title": "python-scala-with-explanations",
                "content": "We add corner cases to reduce runtime: a negative number or positive number with tailing 0s are not palindromes.\\nThen we reverse the number to check whether it equals to the original one.\\n****\\n> Python\\n```\\n    def isPalindrome(self, x):\\n        if x < 0 or (x > 0 and x % 10 == 0):\\n            return False\\n        \\n        return x == self.reverseUtil(x)\\n        \\n    def reverseUtil(self, x):\\n        result = 0\\n\\n        while x != 0:\\n            digit = x % 10\\n            result = result * 10 + digit\\n            x = int(x / 10)\\n            \\n        return result \\n```\\n> Scala\\n```\\n    def isPalindrome(x: Int): Boolean = {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false\\n        }\\n        var reversedX = reverseNumber(x)\\n        reversedX == x\\n    }\\n    \\n    def reverseNumber(x: Int): Int = {\\n        var varx = x\\n        var result = 0\\n        \\n        while (varx != 0) {\\n            result = result * 10 + varx % 10\\n            varx /= 10\\n        }\\n        \\n        return result\\n    }\\n```\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    def isPalindrome(self, x):\\n        if x < 0 or (x > 0 and x % 10 == 0):\\n            return False\\n        \\n        return x == self.reverseUtil(x)\\n        \\n    def reverseUtil(self, x):\\n        result = 0\\n\\n        while x != 0:\\n            digit = x % 10\\n            result = result * 10 + digit\\n            x = int(x / 10)\\n            \\n        return result \\n```\n```\\n    def isPalindrome(x: Int): Boolean = {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false\\n        }\\n        var reversedX = reverseNumber(x)\\n        reversedX == x\\n    }\\n    \\n    def reverseNumber(x: Int): Int = {\\n        var varx = x\\n        var result = 0\\n        \\n        while (varx != 0) {\\n            result = result * 10 + varx % 10\\n            varx /= 10\\n        }\\n        \\n        return result\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3109195,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long int copy=x;\\n       long long int rev=0;\\n        while(x!=0){\\n            long long int rem;\\n            rem=x%10;\\n            rev=rev*10 +rem;\\n            x=x/10;\\n            \\n        }\\n         bool check=false;\\n        if(rev<0){\\n            return check;\\n        }\\n       \\n        else if(rev==copy){\\n            check=true;\\n            return check;\\n        }else return check;\\n        \\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long int copy=x;\\n       long long int rev=0;\\n        while(x!=0){\\n            long long int rem;\\n            rem=x%10;\\n            rev=rev*10 +rem;\\n            x=x/10;\\n            \\n        }\\n         bool check=false;\\n        if(rev<0){\\n            return check;\\n        }\\n       \\n        else if(rev==copy){\\n            check=true;\\n            return check;\\n        }else return check;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5317,
                "title": "9-ms-java-beats-99-5-java-solutions-easy-to-understand",
                "content": "    public class Solution {\\n        static int v;\\n        public static boolean isPalindrome(int x) {\\n            //optimizations\\n            if(x<0) return false;\\n            if(x<10) return true;\\n            if(x%10==0) return false;\\n            if(x<100&&x%11==0) return true;\\n            if(x<1000&&((x/100)*10+x%10)%11==0) return true;\\n\\n            //actual logic\\n            v=x%10;\\n            x=x/10;\\n            while(x-v>0)\\n            {\\n                    v=v*10+x%10;\\n                    x/=10;\\n            }\\n            if(v>x){v/=10;}\\n            return v==x?true:false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        static int v;\\n        public static boolean isPalindrome(int x) {\\n            //optimizations\\n            if(x<0) return false;\\n            if(x<10) return true;\\n            if(x%10==0) return false;\\n            if(x<100&&x%11==0) return true;\\n            if(x<1000&&((x/100)*10+x%10)%11==0) return true;\\n\\n            //actual logic\\n            v=x%10;\\n            x=x/10;\\n            while(x-v>0)\\n            {\\n                    v=v*10+x%10;\\n                    x/=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 519779,
                "title": "noob-friendly-python-code-o-1-space-o-n-time",
                "content": "Let me know if a comment or code needs to be clarified so I can make it even easier to understand. Thanks!\\n\\n```\\ndef isPalindrome(self, num):\\n\\t#negatives can\\'t be palindromes cause of their minus sign so\\n\\t#instead of dealing with this in our main code, we get rid of this possibility immediately\\n    if num < 0: return False\\n\\n    \"\"\"\\n\\tSteps in this algorithm:\\n    1. get the reversed number (the original number but its digits reversed). e.g. 125 becomes 521\\n    2. if the reversed number == original number, its a palindrome! Done!\\n    \\n\\tHow to get reversed number (rev_num):\\n    1. we do this by \\'popping\\' the num\\'s last digit. e.g. 125 becomes 12, we store 5 as last_digit\\n    2. and then \\'appending\\' that last digit to rev_num. e.g. rev_num starts at 0. 0 becomes 5 after appending 5. 5 becomes 52 after appending 2 \\n    3. we keep doing this until all num\\'s digits have been popped, which happens when num becomes 0. e.g. when num is 0, rev_num will be 521\\n\\tNote: the \\'popping\\' and \\'appending\\' is done with cute math tricks, which is more space saving & usually faster than converting the number to a string\\n\\t\"\"\"\\n\\t\\n    original_num = num\\n    rev_num = 0\\n\\t#each line inside the while loop below does a neat math trick, try them w/ pencil & paper to understand why they work\\n    while num > 0:\\n\\t  #get last digit from num. e.g. 125 % 10 returns 5\\n      last_digit = num % 10\\n\\t  #remove last digit from num. e.g. lets say num is 125. num is then set to 125 // 10 which is 12\\n      num = num // 10\\n\\t  #effectively, the above two lines of code have simply popped the last digit from num and saved it. e.g. num is changed from 125 to 12. last_digit is set to 5\\n\\n      #append last digit to right of rev_num, e.g. 5 becomes 52 after appending 2\\n      rev_num = rev_num*10 + last_digit\\n    \\n\\t#once the while loop is done, rev_num represents the reversed number of the original number\\n\\t#in below code, if they match, its a palindrome, since palindromes are symmetrical! e.g. 125 does not equal 521 so this condition would fail\\n    return original_num == rev_num\\n\\t\\n\\t\"\"\"\\n\\tside note: the while loop gets completely skipped if num is initially 0.\\n\\tHere that situation conviently still gives us the right answer as rev_num will be 0 so its no problem, but\\n\\tstill its good to think about edge cases.\\n\\t\"\"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(self, num):\\n\\t#negatives can\\'t be palindromes cause of their minus sign so\\n\\t#instead of dealing with this in our main code, we get rid of this possibility immediately\\n    if num < 0: return False\\n\\n    \"\"\"\\n\\tSteps in this algorithm:\\n    1. get the reversed number (the original number but its digits reversed). e.g. 125 becomes 521\\n    2. if the reversed number == original number, its a palindrome! Done!\\n    \\n\\tHow to get reversed number (rev_num):\\n    1. we do this by \\'popping\\' the num\\'s last digit. e.g. 125 becomes 12, we store 5 as last_digit\\n    2. and then \\'appending\\' that last digit to rev_num. e.g. rev_num starts at 0. 0 becomes 5 after appending 5. 5 becomes 52 after appending 2 \\n    3. we keep doing this until all num\\'s digits have been popped, which happens when num becomes 0. e.g. when num is 0, rev_num will be 521\\n\\tNote: the \\'popping\\' and \\'appending\\' is done with cute math tricks, which is more space saving & usually faster than converting the number to a string\\n\\t\"\"\"\\n\\t\\n    original_num = num\\n    rev_num = 0\\n\\t#each line inside the while loop below does a neat math trick, try them w/ pencil & paper to understand why they work\\n    while num > 0:\\n\\t  #get last digit from num. e.g. 125 % 10 returns 5\\n      last_digit = num % 10\\n\\t  #remove last digit from num. e.g. lets say num is 125. num is then set to 125 // 10 which is 12\\n      num = num // 10\\n\\t  #effectively, the above two lines of code have simply popped the last digit from num and saved it. e.g. num is changed from 125 to 12. last_digit is set to 5\\n\\n      #append last digit to right of rev_num, e.g. 5 becomes 52 after appending 2\\n      rev_num = rev_num*10 + last_digit\\n    \\n\\t#once the while loop is done, rev_num represents the reversed number of the original number\\n\\t#in below code, if they match, its a palindrome, since palindromes are symmetrical! e.g. 125 does not equal 521 so this condition would fail\\n    return original_num == rev_num\\n\\t\\n\\t\"\"\"\\n\\tside note: the while loop gets completely skipped if num is initially 0.\\n\\tHere that situation conviently still gives us the right answer as rev_num will be 0 so its no problem, but\\n\\tstill its good to think about edge cases.\\n\\t\"\"\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3188691,
                "title": "c-without-converting-to-string-simple-solution-92",
                "content": "# Intuition\\nconstruct reverse integer and check if it is the same as the original\\n\\n# Approach\\ncreate a copy c and use it to construct the reverse integer using modulo arithmetics\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nwhere n is the number of digits\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int r = 0, c = x;\\n        while (c > 0)\\n        {\\n            r = r * 10 + c % 10;\\n            c /= 10;\\n        }\\n        return r == x; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int r = 0, c = x;\\n        while (c > 0)\\n        {\\n            r = r * 10 + c % 10;\\n            c /= 10;\\n        }\\n        return r == x; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745571,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5409,
                "title": "straightforward-java-code",
                "content": "    public class Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum = 0,target = x;\\n        while (x > 0) {\\n            int temp = x % 10;\\n            x /= 10;\\n            sum = sum * 10 + temp;\\n        }\\n        return sum == target;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum = 0,target = x;\\n        while (x > 0) {\\n            int temp = x % 10;\\n            x /= 10;\\n            sum = sum * 10 + temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 5595,
                "title": "solution-using-32-bit-integer-without-overflow",
                "content": "\\nThe idea is to reverse only half of the digits and compare them.\\n\\n        public boolean isPalindrome1(int x) {\\n        if (x == 0) return true;\\n        // in leetcode, negative numbers and numbers with ending zeros\\n        // are not palindrome\\n        if (x < 0 || x % 10 == 0)\\n            return false;\\n\\n        // reverse half of the number\\n        // the exit condition is y >= x\\n        // so that overflow is avoided.\\n        int y = 0;\\n        while (y < x) {\\n            y = y * 10 + (x % 10);\\n            if (x == y)  // to check numbers with odd digits\\n                return true;\\n            x /= 10;\\n        }\\n        return x == y; // to check numbers with even digits\\n    }",
                "solutionTags": [],
                "code": "\\nThe idea is to reverse only half of the digits and compare them.\\n\\n        public boolean isPalindrome1(int x) {\\n        if (x == 0) return true;\\n        // in leetcode, negative numbers and numbers with ending zeros\\n        // are not palindrome\\n        if (x < 0 || x % 10 == 0)\\n            return false;\\n\\n        // reverse half of the number\\n        // the exit condition is y >= x\\n        // so that overflow is avoided.\\n        int y = 0;\\n        while (y < x) {\\n            y = y * 10 + (x % 10);\\n            if (x == y)  // to check numbers with odd digits\\n                return true;\\n            x /= 10;\\n        }\\n        return x == y; // to check numbers with even digits\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 151374,
                "title": "javascript-solution",
                "content": "```js\\nfunction isPalindrome(x) {\\n  if (x < 0) return false;\\n  if (x < 10) return true;\\n  if (x % 10 === 0) return false;\\n\\n  let rev = 0;\\n  while (rev < x) {\\n    rev *= 10;\\n    rev += x%10;\\n    x = Math.trunc(x/10);\\n  }\\n  return rev === x || Math.trunc(rev/10) === x;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction isPalindrome(x) {\\n  if (x < 0) return false;\\n  if (x < 10) return true;\\n  if (x % 10 === 0) return false;\\n\\n  let rev = 0;\\n  while (rev < x) {\\n    rev *= 10;\\n    rev += x%10;\\n    x = Math.trunc(x/10);\\n  }\\n  return rev === x || Math.trunc(rev/10) === x;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5133,
                "title": "my-c-solution",
                "content": "    class Solution {\\n\\npublic:\\n\\n    bool isPalindrome(int x) {\\n        if(x<0)\\n            return false;\\n\\n        int num=x;\\n        int a=0;\\n        while(x)\\n        {\\n            a=a*10 + x%10;\\n            x=x/10;\\n        }\\n        if(a==num)\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n\\n\\n----------\\n## Heading ##",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    bool isPalindrome(int x) {\\n        if(x<0)\\n            return false;\\n\\n        int num=x;\\n        int a=0;\\n        while(x)\\n        {\\n            a=a*10 + x%10;\\n            x=x/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3095055,
                "title": "beats-96-beginner-friendly-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/c64fe0ee-2baf-4edc-810e-7bb0d6b71035_1674583737.648591.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n    if(x<0)return false;\\n    int temp=x;\\n    int sum=0;\\n    while(x!=0){\\n    sum=(sum*10)+(x%10);\\n    x=x/10;\\n    }\\n    return (temp==sum);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n\\n    if(x<0)return false;\\n    int temp=x;\\n    int sum=0;\\n    while(x!=0){\\n    sum=(sum*10)+(x%10);\\n    x=x/10;\\n    }\\n    return (temp==sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435115,
                "title": "solution-in-c",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Palindrome Number.\\nMemory Usage: 5.8 MB, less than 97.02% of C online submissions for Palindrome Number.\\n\\n```\\nbool isPalindrome(int x){\\nlong int rev = 0;\\nint temp = x;\\nif(x<0)\\n\\treturn false;\\n\\nwhile(x){\\n    rev = rev * 10 + x % 10;\\n    x /= 10;\\n\\t}\\n        \\nreturn (temp == rev);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPalindrome(int x){\\nlong int rev = 0;\\nint temp = x;\\nif(x<0)\\n\\treturn false;\\n\\nwhile(x){\\n    rev = rev * 10 + x % 10;\\n    x /= 10;\\n\\t}\\n        \\nreturn (temp == rev);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 513145,
                "title": "four-short-python-solutions",
                "content": "S1: Integer-only (compare the original number with the completely reversed number)\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n        return False\\n    a, b = x, 0\\n    while x:\\n        b *= 10\\n        b += x % 10\\n        x //= 10\\n    return a == b\\n```\\nS2: Integer-only with early stop (reversing only half number of digits is enough)\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n    if x and not x % 10:\\n        return False\\n    y = 0\\n    while x > y:\\n        y *= 10\\n        y += x % 10\\n        x //= 10\\n    return x == y or x == y // 10   # even/odd number of digits\\n```\\nS3: 1-line string (could it be shorter?)\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x)[::-1] == str(x)\\n```\\nS4: String with early stop\\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\ts = str(x)\\n    for i in range(len(s) // 2):\\n        if s[i] != s[~i]:\\n            return False\\n    return True\\n```\\nVote up if you find them helpful, thanks!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\tif x < 0:\\n        return False\\n    a, b = x, 0\\n    while x:\\n        b *= 10\\n        b += x % 10\\n        x //= 10\\n    return a == b\\n```\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n    if x and not x % 10:\\n        return False\\n    y = 0\\n    while x > y:\\n        y *= 10\\n        y += x % 10\\n        x //= 10\\n    return x == y or x == y // 10   # even/odd number of digits\\n```\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\treturn str(x)[::-1] == str(x)\\n```\n```python\\ndef isPalindrome(self, x: int) -> bool:\\n\\ts = str(x)\\n    for i in range(len(s) // 2):\\n        if s[i] != s[~i]:\\n            return False\\n    return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 974775,
                "title": "c-4-line-solution-fast-easy-and-light-full-explanation-with-tips-and-tricks",
                "content": "**About:**\\nThis is a quick and easy way to solve this problem, which is both fast and consistent for any input within the integer range. Leetcode has input constraints, so integer overflow will never occur but in the real world you should first check that (x > INT_MAX), from a defensive programming standpoint.\\n\\n**A tip before beginning:**\\n*(Aimed at beginners, or those with a more formal, non-CP experience with C++)*\\nLeetcode automatically specifies ```using namespace std;``` so we do *not* need to prefix operations like \\'reverse\\' with the library identifier ```std``` using the scope operator ```::``` , such as ```std::reverse```. In the real world, it is bad practice to import the entire std namespace, and also bad practice to not specify the library that a function is a part of explicitly since it can cause conflicts during compilation. For competitive programming, it allows us to write faster, though, so definitely use it!\\n\\n**Performance:**\\nRuntime (leetcode runtime is inconsistent): 8ms.\\nMemory usage (consistent): 6.3MB.\\n\\n**Big idea:**\\nIf a reversed string representation of int x is the same as its original (forward) representation, it is a palindrome (return true). Otherwise, it is not, and we return false.\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x); //convert int x to a string\\n        string s2 = s; //make a copy of the string representation of int x to reverse\\n        reverse(s2.begin(), s2.end()); //use reverse to reverse s2  from its beginning to end\\n        return (s == s2); //*see note below\\n    }\\n};\\n```\\n**Notes, tips, and tricks:**\\n*Since (s == s2) is a conditional, and evaluates to a boolean, true or false, we can simplify the following\\n```\\nif(s == s2) {\\n\\treturn true;\\n} else {\\n\\treturn false;\\n}\\n```\\nto \\n```\\nreturn (s == s2);\\n``` \\nwhich will either return true or false.\\n\\nNote also that if you wanted the full if-else statement, you can choose to omit the brackets\\n(i.e.)\\n```\\nif(s == s2)\\n\\treturn true;\\nelse\\n\\treturn false;\\n```\\n\\nwhich is valid for compilation, and common in competitive programming, but bad practice in the real world. This is because you can only have one statement after the conditional if you omit brackets, and it\\'s easy to miss that there aren\\'t brackets and add another statement while working on a project/codebase. So, include brackets in actual programming work! Keep the quick and dirty stuff for competitive programming!\\n\\nI hope this helps :)\\n-ayyitsnicmag",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```using namespace std;```\n```std```\n```::```\n```std::reverse```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x); //convert int x to a string\\n        string s2 = s; //make a copy of the string representation of int x to reverse\\n        reverse(s2.begin(), s2.end()); //use reverse to reverse s2  from its beginning to end\\n        return (s == s2); //*see note below\\n    }\\n};\\n```\n```\\nif(s == s2) {\\n\\treturn true;\\n} else {\\n\\treturn false;\\n}\\n```\n```\\nreturn (s == s2);\\n```\n```\\nif(s == s2)\\n\\treturn true;\\nelse\\n\\treturn false;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981758,
                "title": "go-8ms-solution",
                "content": "```\\nfunc isPalindrome(num int) bool {\\n\\tif num < 0 {\\n\\t\\treturn false\\n\\t}\\n\\tx := num\\n\\treversed := 0\\n\\tfor x != 0 {\\n\\t\\treversed = 10*reversed + x%10\\n\\t\\tx /= 10\\n\\t}\\n\\treturn (reversed == num)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPalindrome(num int) bool {\\n\\tif num < 0 {\\n\\t\\treturn false\\n\\t}\\n\\tx := num\\n\\treversed := 0\\n\\tfor x != 0 {\\n\\t\\treversed = 10*reversed + x%10\\n\\t\\tx /= 10\\n\\t}\\n\\treturn (reversed == num)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 467842,
                "title": "javascript",
                "content": "Runtime: 180 ms, faster than 86.82% of JavaScript online submissions for Palindrome Number.\\nMemory Usage: 45.4 MB, less than 64.65% of JavaScript online submissions for Palindrome Number.\\n\\n```\\nvar isPalindrome = function(x) {\\n    const s = x.toString();\\n    if (s.length === 1) {\\n        return true;\\n    }\\n    const start = s[0];\\n    const end = s[s.length - 1];\\n    if (start !== end) {\\n        return false;\\n    }\\n    if (s.length === 2) {\\n        return true;\\n    }\\n    const subStr = s.substring(1, s.length - 1);\\n    return isPalindrome(subStr);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    const s = x.toString();\\n    if (s.length === 1) {\\n        return true;\\n    }\\n    const start = s[0];\\n    const end = s[s.length - 1];\\n    if (start !== end) {\\n        return false;\\n    }\\n    if (s.length === 2) {\\n        return true;\\n    }\\n    const subStr = s.substring(1, s.length - 1);\\n    return isPalindrome(subStr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5583,
                "title": "is-this-simple-enough-what-is-the-so-called-generic-way",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            int i = 0;;\\n            if ((x % 10 == 0 && x != 0) || x < 0) return false;\\n            while (i < x) {\\n                i = i * 10 + x % 10;\\n                x = x / 10;\\n            }\\n            return (i == x || i / 10 == x);        \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            int i = 0;;\\n            if ((x % 10 == 0 && x != 0) || x < 0) return false;\\n            while (i < x) {\\n                i = i * 10 + x % 10;\\n                x = x / 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2686747,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```\\nWe convert the integer to a string and reverse it using index slicing (str(x)[::-1]). Next, we compare the reversed string to the original (str(x) == str(x)[::-1]). We perform the check in the return statement so that our function will return true if the number is a palindrome and false if it is not.\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310664,
                "title": "simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(long int x) {\\n       long int r,sum=0,t;\\n        t=x;\\n        while(t>0)\\n        {\\n            r=t%10;\\n            sum=sum*10+r;\\n            t/=10;\\n        }\\n        if(sum==x)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(long int x) {\\n       long int r,sum=0,t;\\n        t=x;\\n        while(t>0)\\n        {\\n            r=t%10;\\n            sum=sum*10+r;\\n            t/=10;\\n        }\\n        if(sum==x)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010225,
                "title": "c-3-line-solution-faster-than-99-65-explained",
                "content": "# Intuition\\nWe can easily solve this problem by looking at the definition of a palindrome. \"An integer is a palindrome when it reads the same forward and backward.\"\\n\\nFirst, we can convert `x` to a string, reverse it, and check if it is equal to the original.\\n\\nWe can convert the string into a char array and reverse it using `Array.Reverse()`.\\n\\nThen, we can concatenate all the values of the array by saying `new string(arr)`.\\n\\n\\n\\n\\nFor context in the solution below:\\n`y` is the char array where x is reversed in.\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\tvar y = x.ToString().ToCharArray();  \\n        Array.Reverse(y); //Reverses char array.\\n        return x.ToString() == new string(y);\\n        //Checks if original string is equal to its reverse.\\n    }\\n}\\n```\\n\\nEdit: Thanks to the comments below, I\\'ve learned that there is a built-in function for reversing the string (no need to convert it to a CharArray). Probably could be done in one line, Python style.\\n\\nInstead, it could be done like this:\\n\\n```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\treturn x.ToString().Reverse() == x.ToString()\\n    }\\n}\\n```\\n\\n(Much thanks to @rhazizi and @akimz08)",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\tvar y = x.ToString().ToCharArray();  \\n        Array.Reverse(y); //Reverses char array.\\n        return x.ToString() == new string(y);\\n        //Checks if original string is equal to its reverse.\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n\\t\\treturn x.ToString().Reverse() == x.ToString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178022,
                "title": "simple-and-clear-c",
                "content": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int rev = 0, temp = x;\\n        while(temp > 0){\\n            rev = rev*10 + temp%10;\\n            temp /= 10;\\n        }\\n        return x == rev;\\n        \\n    }\\n}\\n```\\n\\nAnother Approach using String in C#\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string str = x.ToString();\\n        int low = 0;\\n        while(low < str.Length - low - 1){\\n            if(str[low] != str[str.Length-low-1])\\n                return false;\\n            low++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        int rev = 0, temp = x;\\n        while(temp > 0){\\n            rev = rev*10 + temp%10;\\n            temp /= 10;\\n        }\\n        return x == rev;\\n        \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string str = x.ToString();\\n        int low = 0;\\n        while(low < str.Length - low - 1){\\n            if(str[low] != str[str.Length-low-1])\\n                return false;\\n            low++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797115,
                "title": "easy-python-solution-with-o-1-space",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n        \\n        res = 0\\n        temp = x\\n        \\n        while temp:\\n            temp, n = divmod(temp, 10)\\n            res = (res * 10) + n\\n                \\n        return res == x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x < 0:\\n            return False\\n        \\n        res = 0\\n        temp = x\\n        \\n        while temp:\\n            temp, n = divmod(temp, 10)\\n            res = (res * 10) + n\\n                \\n        return res == x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744540,
                "title": "piss-easy-javascript-solution-even-noobs-can-understand",
                "content": "```\\nvar isPalindrome = function(x) {\\n    let pali = x.toString()\\n    .split(\\'\\')\\n    .reverse()\\n    .join(\\'\\')\\n    let normal = x.toString()\\n   return (pali === normal)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n    let pali = x.toString()\\n    .split(\\'\\')\\n    .reverse()\\n    .join(\\'\\')\\n    let normal = x.toString()\\n   return (pali === normal)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350136,
                "title": "rust-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        return x.to_string().chars().rev().eq(x.to_string().chars())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        return x.to_string().chars().rev().eq(x.to_string().chars())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527951,
                "title": "java-tc-o-log10-n-2-sc-o-1-optimal-reverse-half-compare",
                "content": "```java\\n/**\\n * Reverse Half & Compare\\n *\\n * Time Complexity: O((log10 N) / 2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of digits in input number.\\n */\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        if (x < 10) {\\n            return true;\\n        }\\n\\n        int reverse = 0;\\n        while (reverse < x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n       /**\\n         * If input number has even number of digits then check `x == reverse`.\\n         *\\n         * If input number has odd number of digits then check `x == reverse / 10`. This\\n         * is because, reverse will have one extra digit. Middle digit of original\\n         * number will be least significant digit of reverse.\\n         */\\n        return reverse == x || reverse / 10 == x;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Palindrome questions on LeetCode:\\n- [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/discuss/1539190/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Two-Optimized-solutions-with-Early-Exit-Condition)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n- [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/discuss/1539193/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimized-solution-for-continuous-repeating-chars)\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Reverse Half & Compare\\n *\\n * Time Complexity: O((log10 N) / 2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of digits in input number.\\n */\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\\n            return false;\\n        }\\n        if (x < 10) {\\n            return true;\\n        }\\n\\n        int reverse = 0;\\n        while (reverse < x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n\\n       /**\\n         * If input number has even number of digits then check `x == reverse`.\\n         *\\n         * If input number has odd number of digits then check `x == reverse / 10`. This\\n         * is because, reverse will have one extra digit. Middle digit of original\\n         * number will be least significant digit of reverse.\\n         */\\n        return reverse == x || reverse / 10 == x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5594,
                "title": "sharing-my-simple-and-straightforward-solution-with-explanation",
                "content": "    bool isPalindrome(int x) {\\n        long reverse = 0;\\n        long num = abs(x);\\n        while(x != 0){\\n            reverse *= 10;\\n            reverse += x % 10;\\n            x /= 10;\\n        }\\n        return reverse == num;\\n    }\\n\\nThe basic idea is to reverse `x`.\\n\\nHowever, we need to handle two issues. First of all, what if reverse number overflows? We use `long` to solve. Secondly, negative number doesn't have palindrome. So we make num = abs(x).",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    bool isPalindrome(int x) {\\n        long reverse = 0;\\n        long num = abs(x);\\n        while(x != 0){\\n            reverse *= 10;\\n            reverse += x % 10;\\n            x /= 10;\\n        }\\n        return reverse == num;\\n    }\\n\\nThe basic idea is to reverse `x`.\\n\\nHowever, we need to handle two issues. First of all, what if reverse number overflows? We use `long` to solve. Secondly, negative number doesn't have palindrome. So we make num = abs(x).",
                "codeTag": "Unknown"
            },
            {
                "id": 4033190,
                "title": "c-java-python-two-methods-explained-intuition",
                "content": "# Problem Description\\n**Given** an integer x, return **true** if x is a **palindrome**, and **false** otherwise.\\n\\n**Palindrome** is a **word**, **phrase**, **number**, or **other sequence of characters** that **reads** the **same** **forward** and **backward**. In simpler terms, it\\'s something that `remains unchanged when its order is reversed`.\\n\\nHere are a few examples of palindromes:\\n- Words :\"racecar\", \"madam\"\\n- Numbers: 121, 1331, 12321\\n\\n---\\n# Intuition\\n## First Approach (Convert to String)\\nThe **first** approach is to **convert our number into a string** and there we can **access** any digit **freely** unlike the integer that we can\\'t do that there.\\nthen we can make a **mirror** around the middle of the string and **compare** the first char with last char, the second with the one before last and so on.\\nif there is a **difference** then return false otherwise return true. \\n\\n![image.png](https://assets.leetcode.com/users/images/d6c0868b-843e-4f69-a092-4a5f4c39051f_1694475883.578209.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/cf45160a-6169-463a-a4d0-8c85c5fa029a_1694475917.7519221.png)\\n\\n\\n## Second Approach (Extract Digits using %)\\n\\n**Modulo operation** is is a mathematical operation that returns the remainder when one number is divided by another.\\n- 7 % 3 = 1\\n- 9 % 5 = 4\\n\\nModulo operation is very helpful in our problem since it helps us to **extract the least digit in our number**.\\nThe solution is **extract** the digit from the original number then **put it as least digit** in our new reversed number then **delete** that digit by dividing by 10.\\n\\n**Example : 121**\\n```\\nnumber = 121 , reversed = 0 \\ndigit = 121 % 10 = 1 \\nreversed = 0 * 10 + 1 = 1\\nnumber = 121 / 10 = 12\\n```\\n```\\nnumber = 12 , reversed = 1 \\ndigit = 12 % 10 = 2 \\nreversed = 1 * 10 + 2 = 2\\nnumber = 12 / 10 = 1\\n```\\n```\\nnumber = 1 , reversed = 12\\ndigit = 1 % 10 = 1 \\nreversed = 12 * 10 + 1 = 121\\nnumber = 1 / 10 = 0\\n```\\nWe can see that reversed number **equal** to original number which means it is palindrome.\\n\\n\\n---\\n\\n\\n# Approach\\n## First Approach (Convert to String)\\n- **Convert** the integer x to a string representation.\\n- Determine the **length** of the string.\\n- Set up a for **loop** that iterates from the beginning of the string (index 0) to halfway through the string (length / 2).\\n- Inside the loop, **compare** the character at the **current** position (number[i]) with the character at the **corresponding** position from the end of the string (number[length - i - 1]).\\n- If the characters **do not match** (i.e., the number is not palindrome from the center outward), return **false** immediately, indicating that it\\'s not a palindrome.\\n- If the **loop** **completes** without finding any mismatches (all digits match), return **true**, indicating that the integer is a palindrome.\\n\\n# Complexity\\n- **Time complexity:**$$O(N)$$\\nSince we are iterating over all the digits.\\n- **Space complexity:**$$O(N)$$\\nSince we are storing the number as a string where `N` here is the number of the digits.\\n---\\n## Second Approach (Extract Digits using %)\\n- Create **two long variables**, number and reversed, both initially set to the value of the input integer x. The number variable stores the **original** number, and reversed will store the **number in reverse order**.\\n- Enter a while **loop** that continues as long as the value of x is greater than 0.\\n- Inside the **loop**:\\n    - Calculate the **last digit of x** by taking the remainder of x when divided by 10 **(x % 10)**. This digit is stored in the digit variable.\\n    - **Update the reversed variable** by multiplying it by 10 (shifting digits left) and then adding the digit to it. This effectively builds the reversed number digit by digit.\\n    - **Remove the last digit** from x by dividing it by 10 (x /= 10).\\n- After the loop completes, all digits of x have been processed and reversed in reversed.\\n- Check if the number (the original input) is **equal** to the reversed (the reversed input). If they are equal, return **true**, indicating that the integer is a palindrome. If they are not equal, return **false**.\\n\\n# Complexity\\n- **Time complexity:**$$O(N)$$\\nSince we are iterating over all the digits.\\n- **Space complexity:**$$O(1)$$\\nWe only store two additional variables.\\n\\n# Code\\n## First Approach (Convert to String)\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string number = to_string(x) ;\\n        int length = number.size() ;\\n        for(int i = 0 ; i < length / 2 ; i ++){\\n            if(number[i] != number[length - i - 1])\\n                return false ;\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String number = Integer.toString(x);\\n        int length = number.length();\\n        for (int i = 0; i < length / 2; i++) {\\n            if (number.charAt(i) != number.charAt(length - i - 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = str(x)\\n        length = len(number)\\n        \\n        for i in range(length // 2):\\n            if number[i] != number[length - i - 1]:\\n                return False\\n        \\n        return True\\n```\\n## Second Approach (Extract Digits using %)\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long number = x, reversed = 0;\\n        while(x > 0){\\n            int digit = x % 10 ;\\n            reversed = (reversed * 10) + digit ; \\n            x /= 10 ;\\n        }\\n        return number == reversed ;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long number = x;\\n        long reversed = 0;\\n        \\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = (reversed * 10) + digit;\\n            x /= 10;\\n        }\\n        return number == reversed;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = x\\n        reversed_num = 0\\n        \\n        while x > 0:\\n            digit = x % 10\\n            reversed_num = (reversed_num * 10) + digit\\n            x //= 10\\n        \\n        return number == reversed_num\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nnumber = 121 , reversed = 0 \\ndigit = 121 % 10 = 1 \\nreversed = 0 * 10 + 1 = 1\\nnumber = 121 / 10 = 12\\n```\n```\\nnumber = 12 , reversed = 1 \\ndigit = 12 % 10 = 2 \\nreversed = 1 * 10 + 2 = 2\\nnumber = 12 / 10 = 1\\n```\n```\\nnumber = 1 , reversed = 12\\ndigit = 1 % 10 = 1 \\nreversed = 12 * 10 + 1 = 121\\nnumber = 1 / 10 = 0\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string number = to_string(x) ;\\n        int length = number.size() ;\\n        for(int i = 0 ; i < length / 2 ; i ++){\\n            if(number[i] != number[length - i - 1])\\n                return false ;\\n        }\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String number = Integer.toString(x);\\n        int length = number.length();\\n        for (int i = 0; i < length / 2; i++) {\\n            if (number.charAt(i) != number.charAt(length - i - 1)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = str(x)\\n        length = len(number)\\n        \\n        for i in range(length // 2):\\n            if number[i] != number[length - i - 1]:\\n                return False\\n        \\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long number = x, reversed = 0;\\n        while(x > 0){\\n            int digit = x % 10 ;\\n            reversed = (reversed * 10) + digit ; \\n            x /= 10 ;\\n        }\\n        return number == reversed ;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long number = x;\\n        long reversed = 0;\\n        \\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = (reversed * 10) + digit;\\n            x /= 10;\\n        }\\n        return number == reversed;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        number = x\\n        reversed_num = 0\\n        \\n        while x > 0:\\n            digit = x % 10\\n            reversed_num = (reversed_num * 10) + digit\\n            x //= 10\\n        \\n        return number == reversed_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928466,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x<0:\\n            return False\\n\\n        empty = []\\n\\n        while x > 0:\\n            x, remd = divmod(x, 10)\\n            empty.append(remd)\\n\\n        a=empty[::-1]\\n        if a==empty:\\n            return True\\n        \\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x<0:\\n            return False\\n\\n        empty = []\\n\\n        while x > 0:\\n            x, remd = divmod(x, 10)\\n            empty.append(remd)\\n\\n        a=empty[::-1]\\n        if a==empty:\\n            return True\\n        \\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065237,
                "title": "palindrome-number-easy-c-using-string",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing to_string\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x  <  0)return false;\\n        string s = to_string(x);\\n        for(int i=0;i<s.length()/2;i++){\\n            if(s[i] != s[s.length() -1 - i])return false;\\n        }\\n        return true;\\n\\n    }\\n};\\n```\\nupvote if you like it\\n",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x  <  0)return false;\\n        string s = to_string(x);\\n        for(int i=0;i<s.length()/2;i++){\\n            if(s[i] != s[s.length() -1 - i])return false;\\n        }\\n        return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946947,
                "title": "java-runtime-4-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to determining whether a given integer is a palindrome involves reversing the digits of the number and comparing the reversed number with the original number. If they are the same, the number is a palindrome.\\n\\n# Approach\\nI will reverse the digits of the given integer by repeatedly extracting the last digit of the number and building the reversed number. I\\'ll compare the reversed number with the original number, and if they match, the number is a palindrome.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n  The number of digits in the input number is proportional to the logarithm of the number with respect to the base 10. Reversing the digits takes logarithmic time.\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of extra space to store the reversed number and some variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int revers = 0;\\n        int temp =  x;\\n        while (x > 0) {\\n            int digit = x % 10;\\n\\n\\n           revers = revers*10 + digit;\\n\\n\\n            x /= 10;\\n\\n\\n        }\\n\\n        if(revers==temp){\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int revers = 0;\\n        int temp =  x;\\n        while (x > 0) {\\n            int digit = x % 10;\\n\\n\\n           revers = revers*10 + digit;\\n\\n\\n            x /= 10;\\n\\n\\n        }\\n\\n        if(revers==temp){\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469770,
                "title": "o-logn-time-complexity-beginner-friendly-solution-c",
                "content": "- Description:\\n              Firstly, I declare two variables one is copy of x and another is sum which stores reverse number.\\n              I start one loop which stop when my original number is less than or equal to 0. inside it I just reverse that number by using modulo-division method. firstly, I do (x%10) which equal to last digit of original number which stores in sum but after each iteration I multiply 10 to it. and also divides original number to 10.\\n              After that loop I have one copy of original number(Here I can not compare to original number because after looping my original number is becomes 0 causing division in loop). so I compare that copy of number with sum variable which stores reverse number.\\n              If my reverse number is equal to original number then It is palindrome otherwise it doesn\\'t.\\n\\n# Complexity\\n- **Time complexity: O(logn) or O(lengthof(x)) or O(no.ofdigitsin(x))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long on=x;\\n        long long sum=0;\\n        while(x>0)\\n        {\\n            sum=(sum*10)+(x%10);\\n            x/=10;\\n        }\\n        if(sum==on)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/d7e96e70-e0b8-4bd1-8949-6de3276d7cb0_1682854946.7058163.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long on=x;\\n        long long sum=0;\\n        while(x>0)\\n        {\\n            sum=(sum*10)+(x%10);\\n            x/=10;\\n        }\\n        if(sum==on)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569908,
                "title": "easy-c-soution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int temp = x;\\n        long long int rev=0;\\n        while(x>0)\\n        {\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        if(rev==temp)\\n            return true;\\n        return false;\\n    }\\n};\\n\\nup vote if you like it\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int temp = x;\\n        long long int rev=0;\\n        while(x>0)\\n        {\\n            rev = rev*10 + x%10;\\n            x = x/10;\\n        }\\n        if(rev==temp)\\n            return true;\\n        return false;\\n    }\\n};\\n\\nup vote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770500,
                "title": "easy-c-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.length() - 1;\\n        \\n        while(i <= j)\\n        {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        int i = 0, j = s.length() - 1;\\n        \\n        while(i <= j)\\n        {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756913,
                "title": "100-fastest-solution-explained",
                "content": "Easy to understand, detailed solution with step by step explanation and code in multiple languages:\\n\\nhttps://www.code-recipe.com/post/palindrome-number\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer.\\n\\n**Kindly upvote if this helps you. Thank You**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 5443,
                "title": "44ms-c-solution",
                "content": "You can also view more solution on [Github](https://github.com/flexwang/CodeTest)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPalindrome(int x) {\\n\\t\\t\\tif (x < 0) return false;\\n\\t\\t\\tint p1 = 0, p2 = x;\\n\\t\\t\\twhile (p2 > 0) {\\n\\t\\t\\t\\tp1 = p1*10 + p2%10;\\n\\t\\t\\t\\tp2 /= 10;\\n\\t\\t\\t}\\n\\t\\t\\treturn p1 == x;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isPalindrome(int x) {\\n\\t\\t\\tif (x < 0) return false;\\n\\t\\t\\tint p1 = 0, p2 = x;\\n\\t\\t\\twhile (p2 > 0) {\\n\\t\\t\\t\\tp1 = p1*10 + p2%10;\\n\\t\\t\\t\\tp2 /= 10;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3341636,
                "title": "javascript-100-easy-explanation-overall-o-1-space",
                "content": "# Intuition\\nThis approach converts the input integer x into a string using the toString() method. It then creates two pointers, leftIndex and rightIndex, that start at opposite ends of the string. The algorithm then iterates over the string, comparing the characters at the leftIndex and rightIndex. If they are not the same, the function returns false, indicating that x is not a palindrome. If the pointers meet in the middle of the string and all characters match, the function returns true, indicating that x is a palindrome.\\n\\nThis approach has a time complexity of O(n), where n is the length of the string representation of x, and a space complexity of O(1), because it uses a constant amount of extra memory.\\n\\n# Approach\\nThis code checks if a given number is a palindrome or not by converting it into a string and then comparing its characters. A simpler approach can be to directly compare the digits of the number by reversing them and checking if they are equal.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function (x) {\\n  //TIME-COMPLEXITY: O(n);\\n  //MEMORY: O(1);\\n  const str = x.toString();\\n  let leftIndex = 0;\\n  let rightIndex = str.length - 1;\\n\\n  while (leftIndex < rightIndex) {\\n    if (str.charAt(leftIndex) !== str.charAt(rightIndex)) {\\n      return false;\\n    }\\n    leftIndex++;\\n    rightIndex--;\\n  }\\n\\n  return true;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function (x) {\\n  //TIME-COMPLEXITY: O(n);\\n  //MEMORY: O(1);\\n  const str = x.toString();\\n  let leftIndex = 0;\\n  let rightIndex = str.length - 1;\\n\\n  while (leftIndex < rightIndex) {\\n    if (str.charAt(leftIndex) !== str.charAt(rightIndex)) {\\n      return false;\\n    }\\n    leftIndex++;\\n    rightIndex--;\\n  }\\n\\n  return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728864,
                "title": "c-easy-to-understand-palindrome-number",
                "content": "# Upvote if its helps\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        vector<int> idkw;\\n        if(x<0) return false;\\n        int temp=x;\\n        while(temp){\\n            idkw.push_back(temp%10);\\n            temp/=10;\\n        }\\n        int l=0,r=idkw.size()-1;\\n        while(l<r){\\n            if(idkw[l]!=idkw[r]) return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        vector<int> idkw;\\n        if(x<0) return false;\\n        int temp=x;\\n        while(temp){\\n            idkw.push_back(temp%10);\\n            temp/=10;\\n        }\\n        int l=0,r=idkw.size()-1;\\n        while(l<r){\\n            if(idkw[l]!=idkw[r]) return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429373,
                "title": "easy-java-solutions",
                "content": "##### Approach 1: Two-Pointer solution\\n``` java\\n     public boolean isPalindrome(int x) {\\n\\t\\t // convert input into an array and rest is nothing but a simple two pointer solution\\n         char[] nums = String.valueOf(x).toCharArray();\\n         int start = 0;\\n         int end = nums.length-1;\\n         while(start < end) {\\n             if(nums[start] != nums[end]) return false;\\n             start++; end--;\\n         }\\n        return true;\\n    }\\n```\\n##### Complexity Analysis\\n* Time Complexity: O(n)\\n* Space Complexity: O(n)\\n\\n##### Approach 2: Intuitive Arithematic Solution\\n```java\\n    public boolean isPalindrome(int x) {\\n\\t\\t// negative case\\n        if(x < 0 || (x!=0 && x%10 == 0)) return false;\\n        int res = 0;\\n\\t\\t// idea here is to recontruct the given input from reverse and later check whether \\n\\t\\t// the input and the result match\\n        while(res < x) {\\n            res = res*10 + x%10;\\n            x = x/10;\\n        }\\n        \\n        return (x==res || res/10 == x);\\n    }\\n```\\n##### Complexity Analysis\\n* Time Complexity: O(n)\\n* Space Complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\n     public boolean isPalindrome(int x) {\\n\\t\\t // convert input into an array and rest is nothing but a simple two pointer solution\\n         char[] nums = String.valueOf(x).toCharArray();\\n         int start = 0;\\n         int end = nums.length-1;\\n         while(start < end) {\\n             if(nums[start] != nums[end]) return false;\\n             start++; end--;\\n         }\\n        return true;\\n    }\\n```\n```java\\n    public boolean isPalindrome(int x) {\\n\\t\\t// negative case\\n        if(x < 0 || (x!=0 && x%10 == 0)) return false;\\n        int res = 0;\\n\\t\\t// idea here is to recontruct the given input from reverse and later check whether \\n\\t\\t// the input and the result match\\n        while(res < x) {\\n            res = res*10 + x%10;\\n            x = x/10;\\n        }\\n        \\n        return (x==res || res/10 == x);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 272592,
                "title": "java-concise-6ms-beats-100",
                "content": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0, y = x;\\n        while (y > 0) {\\n            rev = rev * 10 + y % 10;\\n            y /= 10;\\n        }\\n        return rev == x;\\n    }\\n}\\n```\\nTime complexity: O(logN)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0, y = x;\\n        while (y > 0) {\\n            rev = rev * 10 + y % 10;\\n            y /= 10;\\n        }\\n        return rev == x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5141,
                "title": "javascript-fast-optimized",
                "content": "Hi guys, let's check this optimised solution for JS\\n```\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;        // only positive number\\n    if (x < 10) return true;        // for 1-9 cases\\n    if (x % 10 === 0) return false; // in case of last 0 [3330, 123320, 1000, etc]\\n    let rev = 0;                    // reversed number\\n    while (x >= 10) {\\n        let cur = x % 10;\\n        rev = rev*10 + cur;\\n        if (x === rev) return true; // check before changing\\n        x = ~~(x / 10); // better replace for Math.floor(), bit operator '~' inverts all the bits in your number and in the process converts the number to an int\\n        if (x === rev) return true; // check after changing\\n        if (x < rev) return false;  // stop in case reversed number becomes greater than original value\\n    }\\n    return false; // the longest case (diff in the middle) // [77778777, 10004001] \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if (x < 0) return false;        // only positive number\\n    if (x < 10) return true;        // for 1-9 cases\\n    if (x % 10 === 0) return false; // in case of last 0 [3330, 123320, 1000, etc]\\n    let rev = 0;                    // reversed number\\n    while (x >= 10) {\\n        let cur = x % 10;\\n        rev = rev*10 + cur;\\n        if (x === rev) return true; // check before changing\\n        x = ~~(x / 10); // better replace for Math.floor(), bit operator '~' inverts all the bits in your number and in the process converts the number to an int\\n        if (x === rev) return true; // check after changing\\n        if (x < rev) return false;  // stop in case reversed number becomes greater than original value\\n    }\\n    return false; // the longest case (diff in the middle) // [77778777, 10004001] \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588907,
                "title": "simple-python-solution",
                "content": "This solution is a direct one, i am just comapring reverse of the string to the original string. As we are taking input as integer x. So, first convert it to a str() and then do [::-1] reverse.\\n\\n        if str(x)[::-1] == str(x):\\n            \\n            return True\\n        else:\\n            return False\\n        \\n        \\n You can directly return as well.\\n \\n \\n return True if str(x)[::-1] == str(x) else False\\n \\n \\n If you liked it, give it a Upvote.",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "This solution is a direct one, i am just comapring reverse of the string to the original string. As we are taking input as integer x. So, first convert it to a str() and then do [::-1] reverse.\\n\\n        if str(x)[::-1] == str(x):\\n            \\n            return True\\n        else:\\n            return False\\n        \\n        \\n You can directly return as well.\\n \\n \\n return True if str(x)[::-1] == str(x) else False\\n \\n \\n If you liked it, give it a Upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 733411,
                "title": "palindrome-number-solution-with-c",
                "content": "bool isPalindrome(int x){\\n    int reverse = 0;\\n    int temp = x; \\n    if (x < 0 || x > 0 && x%10 == 0){\\n        return 0;\\n    }\\n    else{\\n        while(temp!= 0){\\n            if (reverse<= INT_MAX/10){\\n                reverse = reverse*10 + temp%10;\\n                temp /= 10; \\n            }\\n            else break;\\n        }\\n    }\\n    return x == reverse;\\n}",
                "solutionTags": [],
                "code": "bool isPalindrome(int x){\\n    int reverse = 0;\\n    int temp = x; \\n    if (x < 0 || x > 0 && x%10 == 0){\\n        return 0;\\n    }\\n    else{\\n        while(temp!= 0){\\n            if (reverse<= INT_MAX/10){\\n                reverse = reverse*10 + temp%10;\\n                temp /= 10; \\n            }\\n            else break;\\n        }\\n    }\\n    return x == reverse;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 5325,
                "title": "an-accepted-solution-using-no-extra-variable",
                "content": "Yes I misunderstood the meaning of 'no extra space' and I took it for no extra local variable.\\nNevertheless I post a messy one here for those who are by any chance interested.\\nI know it's not what the author intended and it is quite inefficient because of all the repetitive formulas but the basic approach is simple and clear so please don't vote me down :)\\n```\\n#include <math.h>\\n\\n//number of digits of x\\n#define n_digit_of(x) ((int)log10(x))\\n\\n//10^n\\n#define ten_to_power_of(n) ((int)exp(log(10) * (n)))\\n\\n//e.g. the 'order' of 1221 is 1000\\n#define order_of(x) (ten_to_power_of(n_digit_of(x)))\\n\\n//e.g. the number of 'front' 0s of 3000458 is 3.\\n#define n_front_zero_of(x) (n_digit_of(x) - n_digit_of((x) % order_of(x)) - 1)\\n\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false;\\n    }\\n   \\n    while (x >= 10) {\\n        //compare the most significant and least significant digits\\n        if (x / order_of(x) != (x % 10)) {\\n            return false;\\n        }\\n        \\n        //in case like 400303004, we have to judge more digits\\n        if (n_digit_of(x) - n_digit_of(x % order_of(x)) > 1) {\\n            if (x % ten_to_power_of(n_front_zero_of(x) + 1) != (x % 10)) {\\n                return false;\\n            }\\n        }\\n\\n        //now strip the most significant and least significant parts and continue\\n        //e.g. 400303004 => 303        \\n        x = x % order_of(x) / ten_to_power_of((n_front_zero_of(x) + 1));\\n     }\\n    \\n    return true;\\n}",
                "solutionTags": [],
                "code": "Yes I misunderstood the meaning of 'no extra space' and I took it for no extra local variable.\\nNevertheless I post a messy one here for those who are by any chance interested.\\nI know it's not what the author intended and it is quite inefficient because of all the repetitive formulas but the basic approach is simple and clear so please don't vote me down :)\\n```\\n#include <math.h>\\n\\n//number of digits of x\\n#define n_digit_of(x) ((int)log10(x))\\n\\n//10^n\\n#define ten_to_power_of(n) ((int)exp(log(10) * (n)))\\n\\n//e.g. the 'order' of 1221 is 1000\\n#define order_of(x) (ten_to_power_of(n_digit_of(x)))\\n\\n//e.g. the number of 'front' 0s of 3000458 is 3.\\n#define n_front_zero_of(x) (n_digit_of(x) - n_digit_of((x) % order_of(x)) - 1)\\n\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false;\\n    }\\n   \\n    while (x >= 10) {\\n        //compare the most significant and least significant digits\\n        if (x / order_of(x) != (x % 10)) {\\n            return false;\\n        }\\n        \\n        //in case like 400303004, we have to judge more digits\\n        if (n_digit_of(x) - n_digit_of(x % order_of(x)) > 1) {\\n            if (x % ten_to_power_of(n_front_zero_of(x) + 1) != (x % 10)) {\\n                return false;\\n            }\\n        }\\n\\n        //now strip the most significant and least significant parts and continue\\n        //e.g. 400303004 => 303        \\n        x = x % order_of(x) / ten_to_power_of((n_front_zero_of(x) + 1));\\n     }\\n    \\n    return true;\\n}",
                "codeTag": "C++"
            },
            {
                "id": 5173,
                "title": "beat-90-in-java",
                "content": "     public boolean isPalindrome(int x) {\\n            if (x < 0) return false;\\n            int ans = 0;\\n            int num = x;\\n            while ( num > 0) {\\n                ans = ans * 10 + num % 10;\\n                num = num / 10;\\n            }\\n            if (ans != x) return false;\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public boolean isPalindrome(int x) {\\n            if (x < 0) return false;\\n            int ans = 0;\\n            int num = x;\\n            while ( num > 0) {\\n                ans = ans * 10 + num % 10;\\n                num = num / 10;\\n            }\\n            if (ans != x) return false;\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 5478,
                "title": "my-72-ms-c-solution",
                "content": "Just remember two x==y checks needed to deal with odd and even digits cases.\\n\\n    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(!x) return true;\\n            if(x<0 || 0 == x%10 ) return false;\\n            int y =0;\\n            while(x>y)\\n            {\\n                y = y*10 + x%10;\\n                if(x==y) return true; // to deal with odd digits case, e.g. 232\\n                x = x/10; \\n            }\\n            return x==y; // to deal with even digits case, e.g. 22\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if(!x) return true;\\n            if(x<0 || 0 == x%10 ) return false;\\n            int y =0;\\n            while(x>y)\\n            {\\n                y = y*10 + x%10;\\n                if(x==y) return true; // to deal with odd digits case, e.g. 232\\n                x = x/10; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 5550,
                "title": "two-pointer-style-solution-walking-from-left-and-right-to-the-middle",
                "content": "I wanted to check if the number is a palindrome the same way you would check if a string is a palindrome, with a left pointer and right pointer that walk toward the middle. The only trick is finding the largest multiple of 10 smaller than x, for which I use the pow, floor, and log10 functions:\\n\\n    bool isPalindrome(int x) {\\n        if (x < 0) return false;\\n        \\n        int left = pow(10, floor(log10(x)));\\n        int right = 1;\\n        while (right < left) {\\n            if ((x / left - x / right) % 10 != 0) {\\n                return false;\\n            }\\n            right *= 10;\\n            left /= 10;\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "I wanted to check if the number is a palindrome the same way you would check if a string is a palindrome, with a left pointer and right pointer that walk toward the middle. The only trick is finding the largest multiple of 10 smaller than x, for which I use the pow, floor, and log10 functions:\\n\\n    bool isPalindrome(int x) {\\n        if (x < 0) return false;\\n        \\n        int left = pow(10, floor(log10(x)));\\n        int right = 1;\\n        while (right < left) {\\n            if ((x / left - x / right) % 10 != 0) {\\n                return false;\\n            }\\n            right *= 10;\\n            left /= 10;\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5598,
                "title": "a-straightforward-log-n-ac-solution",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(long long x) {\\n            if (x < 0) return false;\\n            long long d = 10, e = 10;\\n            while (x / d) d *= 10;\\n            while (d > e)\\n            {\\n                if ((x % d) / (d / 10) != (x % e) / (e / 10))\\n                    return false;\\n                d /= 10;\\n                e *= 10;\\n            }\\n            return true;\\n        }\\n    };\\n\\ncompare the highest digit and lowest digit in each iteration. should the local variable d and e be regarded as 'extra memory'?",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(long long x) {\\n            if (x < 0) return false;\\n            long long d = 10, e = 10;\\n            while (x / d) d *= 10;\\n            while (d > e)\\n            {\\n                if ((x % d) / (d / 10) != (x % e) / (e / 10))\\n                    return false;\\n                d /= 10;\\n                e *= 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3871467,
                "title": "palindrome-without-using-convertation-to-str",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe hint was not to use convertation x to string , so I used tricks of division. \\n\\n# Approach\\nWe start from the latest digit of initial number and build reverted number. Then check is real number equals to reverted and returns the result. \\n\\n# Complexity\\n- Time complexity: O(n) \\n*where n is length of x , we just go through all numbers of initial x \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        reversed_number = 0\\n        number = x\\n        while x > 0:\\n            digit = x % 10\\n            x = x // 10\\n            reversed_number = reversed_number * 10 + digit\\n\\n        return number == reversed_number\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0:\\n            return False\\n        reversed_number = 0\\n        number = x\\n        while x > 0:\\n            digit = x % 10\\n            x = x // 10\\n            reversed_number = reversed_number * 10 + digit\\n\\n        return number == reversed_number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278892,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       int y=x;\\n        if(x<0)\\n            return false;\\n            \\n        long int temp=0;\\n        while(y)\\n        {\\n            temp=temp*10+y%10;\\n            y/=10;\\n        }\\n        if(temp==x)\\n            return true;\\n        else\\n            return false;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       int y=x;\\n        if(x<0)\\n            return false;\\n            \\n        long int temp=0;\\n        while(y)\\n        {\\n            temp=temp*10+y%10;\\n            y/=10;\\n        }\\n        if(temp==x)\\n            return true;\\n        else\\n            return false;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954045,
                "title": "5-line-c-code-beats-100",
                "content": "//-------------> \\uD83D\\uDC7B Pls Upvote if it is helpful for You \\uD83D\\uDC7B <--------------//\\n\\n\\n# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n - TypeCasting Integer  to String using \\n - to_string()  function\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s=to_string(x);      // convert int to string \\n        string s1=s;               \\n        reverse(s.begin(),s.end()); // reverse the string \\n        if(s==s1) return 1;        // check they are equal or not  \\n        return 0;\\n    }\\n};\\n```\\n---\\n\\n- \\uD83D\\uDC7B IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION\\uD83D\\uDC7B*\\n![image.png](https://assets.leetcode.com/users/images/27dc1e17-5bbd-4e60-a870-bb322c16992f_1678436893.0397103.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s=to_string(x);      // convert int to string \\n        string s1=s;               \\n        reverse(s.begin(),s.end()); // reverse the string \\n        if(s==s1) return 1;        // check they are equal or not  \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297591,
                "title": "simple-java-code-faster-than-99-97-and-89-47-in-memory",
                "content": "please upvote if u find it usefull :)\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      int num = 0,temp = x;\\n      while(x>0){\\n              num = num*10 + x%10;\\n              x = x/10;\\n            }\\n      if(temp == num){\\n        return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n      int num = 0,temp = x;\\n      while(x>0){\\n              num = num*10 + x%10;\\n              x = x/10;\\n            }\\n      if(temp == num){\\n        return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878340,
                "title": "best-java-solution",
                "content": "Best JAVA Solution\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n        \\n        int sub = x;\\n        int reversed = 0;\\n        while (sub != 0) {\\n            reversed = reversed * 10 + sub % 10;\\n            sub /= 10;\\n        }\\n        \\n        return x == reversed;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if (x < 0) {\\n            return false;\\n        }\\n        \\n        int sub = x;\\n        int reversed = 0;\\n        while (sub != 0) {\\n            reversed = reversed * 10 + sub % 10;\\n            sub /= 10;\\n        }\\n        \\n        return x == reversed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5507,
                "title": "my-simplest-ac-code-with-o-zero-space",
                "content": "    #define order(x) ((int)pow(10, (int)log10(x)))\\n    \\n    bool isPalindrome(int x) {\\n    \\t// non palindrome number for negative numbers\\n    \\tif (x < 0)\\n    \\t\\treturn false;\\n    \\n    \\twhile (x) {\\n    \\t\\t// non palindrome if the most significant digit\\n    \\t\\t// doesn't match the least one\\n    \\t\\tif (x % 10 != x / order(x))\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// remove both the most and the least digit\\n    \\t\\t// if the second most significant digit is NOT 0,\\n    \\t\\tif (order(x) / 10 == order(x - x % 10 * order(x)))\\n    \\t\\t\\tx = (x - x % 10 * order(x)) / 10;\\n    \\n    \\t\\t// it's 0, then make sure the second least is also 0\\n    \\t\\t// non palindrome if otherwise\\n    \\t\\telse if (x / 10 % 10 != 0)\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// now the second most and the second least are both 0,\\n    \\t\\t// remove the most and the least, and change the two 0's to 1's\\n    \\t\\telse\\n    \\t\\t\\tx = (x - x % 10 * order(x) + order(x) / 10) / 10 + 1;\\n    \\t}\\n    \\n    \\treturn true;\\n    }",
                "solutionTags": [],
                "code": "    #define order(x) ((int)pow(10, (int)log10(x)))\\n    \\n    bool isPalindrome(int x) {\\n    \\t// non palindrome number for negative numbers\\n    \\tif (x < 0)\\n    \\t\\treturn false;\\n    \\n    \\twhile (x) {\\n    \\t\\t// non palindrome if the most significant digit\\n    \\t\\t// doesn't match the least one\\n    \\t\\tif (x % 10 != x / order(x))\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// remove both the most and the least digit\\n    \\t\\t// if the second most significant digit is NOT 0,\\n    \\t\\tif (order(x) / 10 == order(x - x % 10 * order(x)))\\n    \\t\\t\\tx = (x - x % 10 * order(x)) / 10;\\n    \\n    \\t\\t// it's 0, then make sure the second least is also 0\\n    \\t\\t// non palindrome if otherwise\\n    \\t\\telse if (x / 10 % 10 != 0)\\n    \\t\\t\\treturn false;\\n    \\n    \\t\\t// now the second most and the second least are both 0,\\n    \\t\\t// remove the most and the least, and change the two 0's to 1's\\n    \\t\\telse\\n    \\t\\t\\tx = (x - x % 10 * order(x) + order(x) / 10) / 10 + 1;\\n    \\t}\\n    \\n    \\treturn true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4082932,
                "title": "video-visualization-using-modulo-and-floor-division",
                "content": "https://www.youtube.com/watch?v=OlTk8wM48ww\\n\\nThe idea here is that we don\\'t need to reverse all the digits, only <i>half</i> the digits.  The first line checks some edge cases, and returns False immediately if the number is negative or ends with a 0 (with the exception of the number 0 itself).  The loop then uses the modulo and floor division operators to reverse the digits and transfer them to the `half` variable.\\n\\nOnce the halfway point is reached, we return True if the two halves are equal to each other.  If the number originally had an <i>odd</i> number of digits, then the two halves will be off by 1 digit, so we also remove that digit using floor division, then compare for equality.\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        half = 0\\n        while x > half:\\n            half = (half * 10) + (x % 10)\\n            x = x // 10\\n\\n        return x == half or x == half // 10\\n```\\n\\n# Alternate solution\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        return x == x[::-1]\\n```\\nAlternate solution: turn the number into a string, reverse it, and see if they\\'re equal.  This is the simplest solution, but the question does challenge us to solve it <i>without</i> turning the number into a string.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        if x < 0 or (x != 0 and x % 10 == 0):\\n            return False\\n\\n        half = 0\\n        while x > half:\\n            half = (half * 10) + (x % 10)\\n            x = x // 10\\n\\n        return x == half or x == half // 10\\n```\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        return x == x[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230465,
                "title": "faster-than-96-of-java-solutions-java",
                "content": "# Approach\\nStore the value of x in an integer, then reverse the original number using a while loop, where you will keep using modulous to get the remainder and keep adding that to the rev int initilized at the beginning.\\nLastly, check if the rev and the original are equal and or original >=0, return true else false.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev =0;\\n        int original = x;\\n        while(x !=0){\\n            int num = x % 10;\\n            rev = rev *10 + num;\\n            x = x/10;\\n\\n        }\\n\\n        if(original >= 0 && original == rev){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev =0;\\n        int original = x;\\n        while(x !=0){\\n            int num = x % 10;\\n            rev = rev *10 + num;\\n            x = x/10;\\n\\n        }\\n\\n        if(original >= 0 && original == rev){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873538,
                "title": "one-line-solution-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean {\\n\\n   return   x.toString().reversed() ==  x.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean {\\n\\n   return   x.toString().reversed() ==  x.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744506,
                "title": "two-pointers",
                "content": "```\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683670,
                "title": "code-along-with-explaination-faster-then-81",
                "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n \\n//         frst convert the number into string\\n        string str=to_string(x);\\n//         using builtin reverse function find reverse\\n        reverse(str.begin(),str.end());\\n//         convert original value of int into string and compare it with rev\\n        bool flag=to_string(x)==str;\\n        return flag;\\n            \\n    }\\n};\\n**upvote if u found it helpful**",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n \\n//         frst convert the number into string\\n        string str=to_string(x);\\n//         using builtin reverse function find reverse\\n        reverse(str.begin(),str.end());\\n//         convert original value of int into string and compare it with rev\\n        bool flag=to_string(x)==str;\\n        return flag;\\n            \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2329273,
                "title": "c-java-python3-javascript-solution-90-99-faster",
                "content": "See the code : \\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/5afaf588-9ac5-4ce7-ba46-bfbddb3e7586_1658709281.7354767.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "See the code : \\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/5afaf588-9ac5-4ce7-ba46-bfbddb3e7586_1658709281.7354767.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1334247,
                "title": "two-c-solutions-competitive-other",
                "content": "Competative Solution\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        if(s == string(s.rbegin(), s.rend())) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\\n\\nOther Solution\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int rev = 0; \\n       int digit = 0, temp = x;\\n        if(x<0) {\\n            return false;\\n        } else {\\n            while(x != 0) {\\n            digit = x % 10;\\n            rev = rev * 10 + digit;\\n            x = x/10;\\n        }\\n        }      \\n        if(rev == temp) {\\n            return true;\\n        } else {\\n            return false;\\n        }     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        string s = to_string(x);\\n        if(s == string(s.rbegin(), s.rend())) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int rev = 0; \\n       int digit = 0, temp = x;\\n        if(x<0) {\\n            return false;\\n        } else {\\n            while(x != 0) {\\n            digit = x % 10;\\n            rev = rev * 10 + digit;\\n            x = x/10;\\n        }\\n        }      \\n        if(rev == temp) {\\n            return true;\\n        } else {\\n            return false;\\n        }     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986012,
                "title": "simple-c-solution",
                "content": "# Simple C++ Solution\\n\\n``` CPP\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        long long y = 0, t = x;\\n        while (t != 0) {\\n    \\t    y = y * 10 + t % 10;\\n    \\t    t /= 10;\\n\\t    }\\n\\t    return x == y;\\n    }\\n};\\n```\\n\\n>- Just reverse the numbers of x to y and compare them.\\n>- You would not to care the overflow,  cause I used \"long long\".",
                "solutionTags": [],
                "code": "``` CPP\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        long long y = 0, t = x;\\n        while (t != 0) {\\n    \\t    y = y * 10 + t % 10;\\n    \\t    t /= 10;\\n\\t    }\\n\\t    return x == y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771404,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307258,
                "title": "9-php-string-and-math-solutions",
                "content": "The string-based solution looks faster than the math-based solution.\\n\\n> Runtime: **16 ms**, faster than *99.55%* of PHP online submissions\\n> Memory Usage: **14.9 MB**, less than *32.64%* of PHP online submissions\\n\\n```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        return (string)$x === strrev($x);\\n    }\\n}\\n```\\n\\n> Runtime: **36 ms**, faster than *80.98%* of PHP online submissions\\n> Memory Usage: **14.9 MB**, less than *27.78%* of PHP online submissions\\n\\n```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        if ($r = 0 === $x % 10 && $x !== 0 || $x < 0) return false;\\n        while ($r < $x) list($r, $x) = [$r * 10 + $x % 10, (int)($x / 10)];\\n        return $x === $r || $x === (int)($r / 10);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Math",
                    "String"
                ],
                "code": "```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        return (string)$x === strrev($x);\\n    }\\n}\\n```\n```php\\nclass Solution\\n{\\n\\n    /**\\n     * @param Integer $x\\n     * @return Boolean\\n     */\\n    function isPalindrome($x)\\n    {\\n        if ($r = 0 === $x % 10 && $x !== 0 || $x < 0) return false;\\n        while ($r < $x) list($r, $x) = [$r * 10 + $x % 10, (int)($x / 10)];\\n        return $x === $r || $x === (int)($r / 10);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258209,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        x.to_string()==x.to_string().chars().rev().collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        x.to_string()==x.to_string().chars().rev().collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164574,
                "title": "can-you-please-explain-this-bit-of-code-used-for-fast-io",
                "content": "I understand this is used for fast input output using cin at speeds comparable to scanf.\\n\\n But I don\\'t understand what is this function looking thing inside which they have wrapped \\nthe fast IO code  ? It has [] of array, () of functions and also a return type of function\\n\\n```\\nstatic const auto _____ = []()\\n{\\n    // fast IO code : this I understand\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```\\n\\nCan you kindly explain, what is this feature of C++ ?\\n``` \\nstatic const auto _____ = [] ()\\n{\\n    // fast IO code\\n}(); \\n```",
                "solutionTags": [],
                "code": "```\\nstatic const auto _____ = []()\\n{\\n    // fast IO code : this I understand\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```\n``` \\nstatic const auto _____ = [] ()\\n{\\n    // fast IO code\\n}(); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5266,
                "title": "32ms-c-language-solution",
                "content": "    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        if(x < 10) return true;\\n        int y = 0;\\n        int tmp = x;\\n        while(tmp)\\n        {\\n            y = y * 10 + (tmp % 10);\\n            tmp /= 10;\\n        }\\n        \\n        return x == y;\\n    }",
                "solutionTags": [],
                "code": "    bool isPalindrome(int x) {\\n        if(x < 0) return false;\\n        if(x < 10) return true;\\n        int y = 0;\\n        int tmp = x;\\n        while(tmp)\\n        {\\n            y = y * 10 + (tmp % 10);\\n            tmp /= 10;\\n        }\\n        \\n        return x == y;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3611963,
                "title": "c-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n            int num = x;\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n            unsigned int rev=0;\\n            while(x!=0){\\n                 int rem = x % 10;\\n                 rev=rev*10 + rem ;\\n                 x = x/10;\\n            }\\n            if(num==rev){\\n                 return true;\\n            }\\n        \\n            else{\\n                 return false ;\\n            } \\n        }   \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n            int num = x;\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n            unsigned int rev=0;\\n            while(x!=0){\\n                 int rem = x % 10;\\n                 rev=rev*10 + rem ;\\n                 x = x/10;\\n            }\\n            if(num==rev){\\n                 return true;\\n            }\\n        \\n            else{\\n                 return false ;\\n            } \\n        }   \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059925,
                "title": "one-liner-in-swift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return String(String(x).reversed()) == String(x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isPalindrome(_ x: Int) -> Bool {\\n        return String(String(x).reversed()) == String(x)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739236,
                "title": "c-two-pointers-math-with-comments",
                "content": "I\\'d love to stick to two pointers technique to check if the integer is palindrome like we do with strings :)\\nInstead of converting the integer to a string, some math can do we the favor.\\n```cpp\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nbool isPalindrome(int x) {\\n    if (x < 0) \\n        return false;\\n    if (x == 0) // to avoid log10(0)\\n        return true;\\n\\n    int n = log10(x) + 1; // compute -> n digits\\n    int times = n / 2; // we need to compare n / 2 times (move two pointers at one move)\\n    int l = (int) pow(10, n - 1), r = 1;\\n    while (times--) { \\n        if ((x / l) % 10 != (x / r) % 10) { // if (left digit != right digit)\\n            return false;\\n        }\\n        l /= 10;\\n        r *= 10;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711457,
                "title": "palindrome-number-using-recursion",
                "content": "Different and simple approach using Recursion, if useful please upvote\\n```\\nclass Solution {\\npublic:\\n    \\n    bool Check_Palindrome(int x, int left)\\n    {\\n\\t\\t//Convert the Integer to String\\n        stringstream ss;\\n        ss<<x;\\n        string s;\\n        ss>>s;\\n\\t\\t\\n\\t\\t//Since we use the two pointer concept using a single pointer (i.e left)\\n        if(left > s.length()/2)\\n        {\\n            return true;\\n        }\\n        \\n\\t\\t//Compare the String from Start and End(char by char)\\n        if(s[left] != s[s.length()-left-1])\\n        {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//Keep repeating till any two of the base conditions execute\\n        return Check_Palindrome(x, left+1);\\n    }\\n    \\n    bool isPalindrome(int x)\\n    {\\n        int start = 0;\\n\\t\\t\\n\\t\\t//If not palindrome return false else true\\n        if(!Check_Palindrome(x, start))\\n        {\\n            return false;\\n        }\\n        return true;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool Check_Palindrome(int x, int left)\\n    {\\n\\t\\t//Convert the Integer to String\\n        stringstream ss;\\n        ss<<x;\\n        string s;\\n        ss>>s;\\n\\t\\t\\n\\t\\t//Since we use the two pointer concept using a single pointer (i.e left)\\n        if(left > s.length()/2)\\n        {\\n            return true;\\n        }\\n        \\n\\t\\t//Compare the String from Start and End(char by char)\\n        if(s[left] != s[s.length()-left-1])\\n        {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//Keep repeating till any two of the base conditions execute\\n        return Check_Palindrome(x, left+1);\\n    }\\n    \\n    bool isPalindrome(int x)\\n    {\\n        int start = 0;\\n\\t\\t\\n\\t\\t//If not palindrome return false else true\\n        if(!Check_Palindrome(x, start))\\n        {\\n            return false;\\n        }\\n        return true;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514381,
                "title": "c-faster-than-80-60-easy-to-understand",
                "content": "Palindrome Number -\\n\\n```\\nclass Solution \\n{\\npublic:\\n    bool isPalindrome(int x) \\n    {\\n       long int digit,reverse=0;\\n       int temp=x;\\n       while(x>0)\\n       {\\n           digit=x%10;\\n           reverse=(reverse*10)+digit;\\n           x=x/10;\\n       }\\n      if(temp==reverse)\\n      {return true;}\\n      else\\n      {return false;}  \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isPalindrome(int x) \\n    {\\n       long int digit,reverse=0;\\n       int temp=x;\\n       while(x>0)\\n       {\\n           digit=x%10;\\n           reverse=(reverse*10)+digit;\\n           x=x/10;\\n       }\\n      if(temp==reverse)\\n      {return true;}\\n      else\\n      {return false;}  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480907,
                "title": "javascript-easy-to-read-solution",
                "content": "tried to go for something simple and clear. \\ntime & space: 98.33% & 96.55%\\n\\n```\\nvar isPalindrome = function(x) {\\n   const original = x\\n   let reversed = 0\\n   \\n   if(x < 10 && x >= 0) {\\n       return true\\n   }\\n    \\n    if(x % 10 === 0 || x < 0) {\\n       return false\\n   }\\n    \\n    while(x !== 0 ) {\\n        reversed = reversed * 10 + x % 10\\n        x = Math.trunc(x/10)\\n    }\\n    \\n    return !(original - reversed)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function(x) {\\n   const original = x\\n   let reversed = 0\\n   \\n   if(x < 10 && x >= 0) {\\n       return true\\n   }\\n    \\n    if(x % 10 === 0 || x < 0) {\\n       return false\\n   }\\n    \\n    while(x !== 0 ) {\\n        reversed = reversed * 10 + x % 10\\n        x = Math.trunc(x/10)\\n    }\\n    \\n    return !(original - reversed)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5274,
                "title": "python-in-one-line",
                "content": "    class Solution(object):\\n        def isPalindrome(self, x):\\n            return x >= 0 and x == int(str(x)[::-1])",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def isPalindrome(self, x):\\n            return x >= 0 and x == int(str(x)[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 5427,
                "title": "very-simple-java-solution",
                "content": "  \\n\\n    public boolean isPalindrome(int x) {\\n            int xx = x;\\n            int reversed = 0;\\n            \\n            while(xx > 0) {\\n                reversed = reversed * 10 + xx % 10;\\n                xx /= 10;\\n            }\\n            return x == reversed;\\n        }",
                "solutionTags": [],
                "code": "  \\n\\n    public boolean isPalindrome(int x) {\\n            int xx = x;\\n            int reversed = 0;\\n            \\n            while(xx > 0) {\\n                reversed = reversed * 10 + xx % 10;\\n                xx /= 10;\\n            }\\n            return x == reversed;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3944219,
                "title": "putta-easy-solution-c-beats-95",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        double ans = 0;\\n        int temp = x;\\n\\n        while(x>0){\\n            ans = ans*10 + x%10;\\n            x = x/10;\\n        }\\n        return temp == ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        double ans = 0;\\n        int temp = x;\\n\\n        while(x>0){\\n            ans = ans*10 + x%10;\\n            x = x/10;\\n        }\\n        return temp == ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280798,
                "title": "python3-one-liner-easiest-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- convert integer x to string.\\n- now return true if reverse of x and original order is same else false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270193,
                "title": "typescript-int-solution",
                "content": "```\\nfunction isPalindrome(x: number): boolean {\\n    let reverseX: number\\n    const tempReverseString = x.toString().split(\"\").reverse().join(\\'\\')\\n    reverseX = parseInt(tempReverseString)\\n\\n    return reverseX === x\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isPalindrome(x: number): boolean {\\n    let reverseX: number\\n    const tempReverseString = x.toString().split(\"\").reverse().join(\\'\\')\\n    reverseX = parseInt(tempReverseString)\\n\\n    return reverseX === x\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3053140,
                "title": "converting-to-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    x = x.toString();\\n    let k = x.length;\\n    for (let i = 0; i < k; i++) {\\n        if (x[i] != x[k - 1]) {\\n            return false;\\n        }\\n        k--;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    x = x.toString();\\n    let k = x.length;\\n    for (let i = 0; i < k; i++) {\\n        if (x[i] != x[k - 1]) {\\n            return false;\\n        }\\n        k--;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005334,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005289,
                "title": "op",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332990,
                "title": "one-line-python-solution",
                "content": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```\\n\\nplease upvote if you like",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311737,
                "title": "python3-one-liner-solution",
                "content": "In this approach we are converting the interger into a string so that we can reverse the string using slicing method. Then we are comparing the original string to a reversed string and returning the boolean value.\\n\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003259,
                "title": "python-32ms-beats-99-79-two-pointers-simple-with-explanation",
                "content": "We have two pointers, `i` and `j`, pointing at the start and end of the number respectively:\\n\\n1023201\\ni--> <--j\\n\\nEach iteration we move `i` to the left and `j` to the right, until they are on the same number (until `i >= j`). If the number `i` is pointing at is **not** equal to the number `j` is pointing at, then the number is not a palindrome. Otherwise, after the loop finishes, return `True`.\\n\\nThis is a better solution than reversing the string and comparing the two because not only do you use extra space, but comparing 2 strings is a linear operation, while iterating `i` and `j` simulaneously compare each side of the number.\\n\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        nums = str(x)\\n        \\n        i = 0\\n        j = len(nums) - 1\\n        \\n        while i <= j:\\n            if nums[i] != nums[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n```\\n\\n**If you liked this, please upvote to support me!**\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        nums = str(x)\\n        \\n        i = 0\\n        j = len(nums) - 1\\n        \\n        while i <= j:\\n            if nums[i] != nums[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980816,
                "title": "java-c-python-javascript-kotlin-4lines-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "<iframe src=\"https://leetcode.com/playground/V3ZoeKhz/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/V3ZoeKhz/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1871376,
                "title": "c-6-line-simple-code-easy-to-understand-tc-o-log-n-sc-o-1",
                "content": "Please Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool isPalindrome(int x) {\\n        if(x<0) return 0;\\n        long long int temp=x,rev=0;\\n        while(temp){\\n            rev=rev*10+temp%10;\\n            temp/=10;\\n        }\\n        return x==rev;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Please Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool isPalindrome(int x) {\\n        if(x<0) return 0;\\n        long long int temp=x,rev=0;\\n        while(temp){\\n            rev=rev*10+temp%10;\\n            temp/=10;\\n        }\\n        return x==rev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 827129,
                "title": "0-ms-faster-than-100-00-c-solution",
                "content": "bool isPalindrome(int x) {\\n\\tbool arr[2] = { true, false };\\n\\tint revertedNumber = 0;\\n\\tint tmp = x;\\n\\n\\tif (x < 0 || (x % 10 == 0 && x != 0)) \\n\\t\\treturn false;\\n\\n\\twhile (x > revertedNumber) {\\n\\t\\trevertedNumber = revertedNumber * 10 + x % 10;\\n\\t\\tx /= 10;\\n\\t}\\n\\t\\n\\tif (x == revertedNumber || x == revertedNumber / 10)\\n\\t\\treturn true;\\n\\telse\\n\\t\\treturn false;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "bool isPalindrome(int x) {\\n\\tbool arr[2] = { true, false };\\n\\tint revertedNumber = 0;\\n\\tint tmp = x;\\n\\n\\tif (x < 0 || (x % 10 == 0 && x != 0)) \\n\\t\\treturn false;\\n\\n\\twhile (x > revertedNumber) {\\n\\t\\trevertedNumber = revertedNumber * 10 + x % 10;\\n\\t\\tx /= 10;\\n\\t}\\n\\t\\n\\tif (x == revertedNumber || x == revertedNumber / 10)\\n\\t\\treturn true;\\n\\telse\\n\\t\\treturn false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 495963,
                "title": "1-line-kotlin-solution",
                "content": "```kotlin\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean =\\n        x.toString().let { it == it.reversed() }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun isPalindrome(x: Int): Boolean =\\n        x.toString().let { it == it.reversed() }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333683,
                "title": "rust-0ms-4ms",
                "content": "![image](https://assets.leetcode.com/users/obliquemotion/image_1563649353.png)\\n\\n\\n```rust\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 {\\n            return false;\\n        }\\n        let digit_count = 1 + (x as f32).log10() as u32;\\n        let half = (digit_count / 2) as usize;\\n        let digits = (0..digit_count).map(|exp| x / 10_i32.pow(exp) % 10);\\n        digits\\n            .clone()\\n            .take(half)\\n            .zip(digits.rev().take(half))\\n            .all(|(lhs, rhs)| lhs == rhs)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 {\\n            return false;\\n        }\\n        let digit_count = 1 + (x as f32).log10() as u32;\\n        let half = (digit_count / 2) as usize;\\n        let digits = (0..digit_count).map(|exp| x / 10_i32.pow(exp) % 10);\\n        digits\\n            .clone()\\n            .take(half)\\n            .zip(digits.rev().take(half))\\n            .all(|(lhs, rhs)| lhs == rhs)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299402,
                "title": "go",
                "content": "```\\nfunc isPalindrome(x int) bool {\\n    s := strconv.Itoa(x)\\n    r := []rune(s)\\n    for i, j := 0, len(r) - 1; i < j; i, j = i + 1, j - 1 {\\n        if r[i] != r[j] {return false}\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPalindrome(x int) bool {\\n    s := strconv.Itoa(x)\\n    r := []rune(s)\\n    for i, j := 0, len(r) - 1; i < j; i, j = i + 1, j - 1 {\\n        if r[i] != r[j] {return false}\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278450,
                "title": "faster-than-100-of-python-submissions-in-one-line",
                "content": "```python\\ndef isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef isPalindrome(self, x: int) -> bool:\\n        return str(x) == str(x)[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 5124,
                "title": "javascript-two-pointers-solution",
                "content": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x = x.toString()\\n    var i = 0;\\n    var j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x = x.toString()\\n    var i = 0;\\n    var j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        i++;\\n        j--;\\n    }\\n    return true;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 5131,
                "title": "3-line-c-solution",
                "content": "Not the fastest or smartest of course, just trying to make the codes shorter.\\n```\\nlong long t = x, r = 0;\\nwhile (t) r = r * 10 + t % 10, t /= 10;\\nreturn x >= 0 && r == x;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long t = x, r = 0;\\nwhile (t) r = r * 10 + t % 10, t /= 10;\\nreturn x >= 0 && r == x;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5281,
                "title": "golang-58ms-concise-solution",
                "content": "Please let me know if there is room to optimize this code.\\n\\n```\\nfunc isPalindrome(x int) bool {\\n    if x < 0 {\\n        return false\\n    } else if x <= 9 {\\n        return true\\n    } else if x % 10 == 0 {\\n        return false\\n    }\\n    \\n    var y int\\n    for x > y {\\n        r := x % 10\\n        x = x / 10\\n        y = y * 10 + r\\n        \\n        if x == y || x / 10 == y {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPalindrome(x int) bool {\\n    if x < 0 {\\n        return false\\n    } else if x <= 9 {\\n        return true\\n    } else if x % 10 == 0 {\\n        return false\\n    }\\n    \\n    var y int\\n    for x > y {\\n        r := x % 10\\n        x = x / 10\\n        y = y * 10 + r\\n        \\n        if x == y || x / 10 == y {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5411,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if (x < 0) return false;\\n            if (x < 10) return true;\\n            \\n            int high = 0, low = 0, weight = 1;\\n            \\n            while (x / weight > 9)\\n                weight *= 10;\\n            \\n            while (x > 0)\\n            {\\n                high = x / weight;\\n                low = x % 10;\\n                if (low != high)\\n                    return false;\\n                //x -= (high * weight);\\n                x %= weight;\\n                x /= 10;\\n                weight /= 100;\\n            }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPalindrome(int x) {\\n            if (x < 0) return false;\\n            if (x < 10) return true;\\n            \\n            int high = 0, low = 0, weight = 1;\\n            \\n            while (x / weight > 9)\\n                weight *= 10;\\n            \\n            while (x > 0)\\n            {\\n                high = x / weight;\\n                low = x % 10;\\n                if (low != high)\\n                    return false;\\n                //x -= (high * weight);\\n                x %= weight;\\n                x /= 10;\\n                weight /= 100;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3726660,
                "title": "c-java-python3-solutions-90-99-faster",
                "content": "### C#,Java,Python3 different solutions with explanation\\n**\\u2B50[zyrastory.com - LeetCode #9 Solutions](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50**\\n\\n##### **Example : C# Code ( \\u2B06You can also find other languages  in the post )**\\nsolution1 - reverse the string and compare\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string first = x.ToString();             //turn to string (easy to reverse)\\n        char[] charArr = first.ToCharArray();   //the original target\\n        char[] reverseArr = first.ToCharArray();   \\n\\n        Array.Reverse(reverseArr );                 \\n     \\n        return charArr.SequenceEqual(reverseArr); //compare two array\\n    }\\n}\\n```\\n\\n\\u2B50solution2\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string k = x.ToString();        \\n        \\n        for(int i=0;i<k.Length/2;i++)   \\n        {\\n            if(k[i] != k[k.Length-1-i]) \\n            {\\n                return false;           // if any char not the same, return false\\n            }\\n        }\\n        return true;                    \\n    }\\n}\\n```\\n---\\n\\n#### **Java Solution**\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String k = String.valueOf(x);\\n      \\n        for(int i=0;i<k.length()/2;i++)\\n        {\\n            if(k.charAt(i) != k.charAt(k.length()-1-i))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n---\\n#### **Python3 Solution**\\nsolution1\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x);\\n```\\n\\nsolution2\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xx = str(x);\\n        ll = int(len(xx)/2);\\n        \\n        for i in range(ll):\\n            if(xx[i] != xx[-i-1]):\\n                return False;\\n        return True;\\n```\\n---\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).\\n\\n**Thanks!**\\n\\nYou can find out other LeetCode problems solution here\\n**\\uD83E\\uDDE1[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string first = x.ToString();             //turn to string (easy to reverse)\\n        char[] charArr = first.ToCharArray();   //the original target\\n        char[] reverseArr = first.ToCharArray();   \\n\\n        Array.Reverse(reverseArr );                 \\n     \\n        return charArr.SequenceEqual(reverseArr); //compare two array\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        string k = x.ToString();        \\n        \\n        for(int i=0;i<k.Length/2;i++)   \\n        {\\n            if(k[i] != k[k.Length-1-i]) \\n            {\\n                return false;           // if any char not the same, return false\\n            }\\n        }\\n        return true;                    \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String k = String.valueOf(x);\\n      \\n        for(int i=0;i<k.length()/2;i++)\\n        {\\n            if(k.charAt(i) != k.charAt(k.length()-1-i))\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)[::-1] == str(x);\\n```\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xx = str(x);\\n        ll = int(len(xx)/2);\\n        \\n        for i in range(ll):\\n            if(xx[i] != xx[-i-1]):\\n                return False;\\n        return True;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509462,
                "title": "js-palindrome-super-fast-more-95-with-explain",
                "content": "# Intuition\\nMy way to determine if a number is a palindrome is to reverse the number and then compare it to the original. If they are the same, then it is a palindrome.\\n\\n# Approach\\nThe approach we are taking here is to construct the reverse of the given number and then compare it to the original number.\\n\\n1. We start by checking if the number is less than 0 or if it ends with 0 (but is not 0 itself). If either of these conditions is true, the number cannot be a palindrome and we return false.\\n\\n2. We initialize a variable reverse to 0. This will hold the reverse of our given number.\\n\\n3. We then enter a while loop where we continue to reverse the number. In each iteration, we multiply reverse by 10 (to shift the digits one place to the left) and add the last digit of our given number (which we get by num % 10).\\n\\n4. After adding the last digit of our given number to reverse, we remove the last digit from our given number by doing a floor division by 10 (num = Math.floor(num / 10)).\\n\\n5. We continue this process until our given number becomes 0, which means we have reversed all its digits.\\n\\n6. Finally, we compare the reversed number to the original number. If they are the same, we return true, indicating that the number is a palindrome. If they are different, we return false.\\n\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n     if (x < 0 || (x % 10 === 0 && x !== 0)) {\\n        return false;\\n    }\\n    let num = x;\\n    let reverse = 0;\\n    while (num > 0) {\\n        reverse = reverse * 10 + (num % 10);\\n        num = Math.floor(num / 10);\\n    }\\n    return x === reverse\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n     if (x < 0 || (x % 10 === 0 && x !== 0)) {\\n        return false;\\n    }\\n    let num = x;\\n    let reverse = 0;\\n    while (num > 0) {\\n        reverse = reverse * 10 + (num % 10);\\n        num = Math.floor(num / 10);\\n    }\\n    return x === reverse\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343410,
                "title": "91-beats-for-time-complexity-o-n-finding-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBotirjon Shokirov\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are checking first and last element, if they are equal, we are going to check next numbers. if they are not equal, we are simply returning false as it will not be a Palindrome number.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n  const str = x.toString();\\n  let left = 0;\\n  let right = str.length - 1;\\n  \\n  while (left < right) {\\n    if (str.charAt(left) !== str.charAt(right)) {\\n      return false;\\n    }\\n    left++;\\n    right--;\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n  const str = x.toString();\\n  let left = 0;\\n  let right = str.length - 1;\\n  \\n  while (left < right) {\\n    if (str.charAt(left) !== str.charAt(right)) {\\n      return false;\\n    }\\n    left++;\\n    right--;\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3127339,
                "title": "rust-iterators",
                "content": "- Using rust iterators \\n- Reducing runtime by 1/2\\n# Code\\n```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        let x = x.to_string();\\n        let n = x.len();\\n        let x = x.chars().collect::<Vec<char>>();\\n        let head = x[..n/2].iter();\\n        let tail = x[n/2..].iter().rev();\\n        head.zip(tail).all(|(a, b)| a==b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        let x = x.to_string();\\n        let n = x.len();\\n        let x = x.chars().collect::<Vec<char>>();\\n        let head = x[..n/2].iter();\\n        let tail = x[n/2..].iter().rev();\\n        head.zip(tail).all(|(a, b)| a==b)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080053,
                "title": "brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long  n=x;\\n        long ans=0;\\n        while(x>0)\\n        {\\n            ans+=x%10;\\n            ans = ans*10;\\n            x=x/10;\\n        }\\n        ans = ans/10;\\n        // System.out.println(ans);\\n        if(ans == n)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        long  n=x;\\n        long ans=0;\\n        while(x>0)\\n        {\\n            ans+=x%10;\\n            ans = ans*10;\\n            x=x/10;\\n        }\\n        ans = ans/10;\\n        // System.out.println(ans);\\n        if(ans == n)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005338,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       long long  int d=x,m=0,z;\\n\\t\\tfor (int i = x; i > 0; i=i/10)\\n\\t\\t{z=i%10;\\n\\t     m=m*10+z;\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\tif(d==m)\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003018,
                "title": "solution-using-array-no-string-conversion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMany of array operation are similar to string,thinking of the follow up question\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can store all digits of array in string and iterate till its mid in reverse direction and match it with the digits of x with the help of modulo operator(default method to access digits of a number)\\nFor ex-\\nI/P: 10\\nthen arraylist would have\\n     [0,1] (in forward index manner)\\nwhen using modulo operator to access digits again we will get 0 as first element that\\'s why we start traversing from back of the arraylist \\nand match the elements,here in first iteration\\n0(from digits) and 1(from arraylist) will be checked ,they don\\'t match hence we return false\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(digits of n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(digits of n)\\n# Code\\n```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        ArrayList<Integer> list\\n            = new ArrayList<Integer>();\\n            int n=x;\\n\\n        while(n>0){\\n            list.add(n%10);\\n            n=n/10;\\n        }\\n        \\n        n=x;\\n        for(int i=list.size()-1;i>=list.size()/2;i--){\\n            if((n%10)!=list.get(i)){\\n                return false;\\n            }\\n            n=n/10;\\n           // System.out.println(list.get(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        ArrayList<Integer> list\\n            = new ArrayList<Integer>();\\n            int n=x;\\n\\n        while(n>0){\\n            list.add(n%10);\\n            n=n/10;\\n        }\\n        \\n        n=x;\\n        for(int i=list.size()-1;i>=list.size()/2;i--){\\n            if((n%10)!=list.get(i)){\\n                return false;\\n            }\\n            n=n/10;\\n           // System.out.println(list.get(i));\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972970,
                "title": "python-no-string-conversion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        if x < 0:\\n            return False\\n        lis = []\\n        while x >= 10:\\n            lis.append(x % 10)\\n            x //= 10\\n        lis.append(x)\\n        for i in range(int(math.ceil(len(lis)/2))):\\n            if lis[i] != lis[len(lis)-i-1]:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        if x < 0:\\n            return False\\n        lis = []\\n        while x >= 10:\\n            lis.append(x % 10)\\n            x //= 10\\n        lis.append(x)\\n        for i in range(int(math.ceil(len(lis)/2))):\\n            if lis[i] != lis[len(lis)-i-1]:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658882,
                "title": "solving-it-without-using-string-in-javascript",
                "content": "**Step one : declare two varables , one for reverse number and one for original number**\\nsince we are going to use reverse algorithm, the original number is gonna change so we need a refrence to the original number to compare it to the reversed one.\\n\\n```javascript\\nlet num = x;\\nlet reverse = 0\\n```\\n\\n**Step two : reverse algorithm**\\nfirst of all if it\\'s negative number, it is not Palindrome because in one side we have a negative sign and not on the other side\\n lets see how we can reverse a number like 124  \\n so we have the `reverse` variable and it is set to 0 and we want to somehow get the **last digit** and add it to our variable.   \\n we can find the last digit of a number by diving it by 10 , and the reminder is our last digit (we can get reminder of a number using `%` operator)\\n ```\\n 124 / 10 = 12.4  (124 % 10 = 4) // 4 is the reminder\\n 321/10 = 32.1  (321 % 10 = 1)  // 1 is the reminder\\n ```\\n**awesome!** so now we know how to find the last digit and we add it to `reverse`\\nnow we need to find a way to remove the last digit so we can add another digit to our `reverse` variable\\n**but how?** when we divide our number by 10 , we get a **decimal point**. in the examples above we have `12.4` and `32.1`. if we remove those we end up with `12` and `32`  (in javascript we do it with `Math.floor()` method)\\n**what now?** now we divide the new number by 10 , and get the reminder, so lets do it\\n```\\nfirst step\\n124 / 10 = 12.4 // we get the 4 and add it to the reverse . remove the decimal point and we have 12\\nsecond step\\n12 / 10 = 1.2 // we get the 2  but we don\\'t add it to reverse! because we will get 6. to go one level up we multipy the reverse by 10 so 4 * 10 = 40 and then we add the 2 so we have 42 .\\n```\\nwe keep doing (aka `loop`) this untill when we remove the decimal point , we get 0 and that\\'s when we are done!\\n\\n**Step three : lets implement this**\\n```javascript\\n// first if number is negative we return false, meaning it\\'s not palindrome;\\nif(x < 0) return false;\\n// our variables\\nlet num = x;\\nlet reverse = 0;\\n\\n// we use a while . we keep going untill we get x = 0\\nwhile( x > 0) {\\n\\t// multiply reverse by 10 and add the reminder\\n\\treverse = reverse * 10 + ( x % 10 )\\n\\t\\n\\t// devide x by 10 and remove decimal point. if x === 0 then it exists the loop\\n\\tx = Math.floor(x / 10)\\n}\\n\\n// now we are out of the while loop and we have the reverse number\\n// lastly we compare the original number with the reverse. we use return and compare these two numbers\\n// this will return True ( if they are equal ) or false( if they are not )\\nreturn reverse === num;\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nlet num = x;\\nlet reverse = 0\\n```\n```\\n 124 / 10 = 12.4  (124 % 10 = 4) // 4 is the reminder\\n 321/10 = 32.1  (321 % 10 = 1)  // 1 is the reminder\\n ```\n```\\nfirst step\\n124 / 10 = 12.4 // we get the 4 and add it to the reverse . remove the decimal point and we have 12\\nsecond step\\n12 / 10 = 1.2 // we get the 2  but we don\\'t add it to reverse! because we will get 6. to go one level up we multipy the reverse by 10 so 4 * 10 = 40 and then we add the 2 so we have 42 .\\n```\n```javascript\\n// first if number is negative we return false, meaning it\\'s not palindrome;\\nif(x < 0) return false;\\n// our variables\\nlet num = x;\\nlet reverse = 0;\\n\\n// we use a while . we keep going untill we get x = 0\\nwhile( x > 0) {\\n\\t// multiply reverse by 10 and add the reminder\\n\\treverse = reverse * 10 + ( x % 10 )\\n\\t\\n\\t// devide x by 10 and remove decimal point. if x === 0 then it exists the loop\\n\\tx = Math.floor(x / 10)\\n}\\n\\n// now we are out of the while loop and we have the reverse number\\n// lastly we compare the original number with the reverse. we use return and compare these two numbers\\n// this will return True ( if they are equal ) or false( if they are not )\\nreturn reverse === num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458263,
                "title": "java-solution-easy-using-recursion",
                "content": "```\\nclass Solution {\\n    //finding reverse of the number using recursion\\n    int rev(int n,int s){\\n        if(n==0) return s;\\n        int sum=s*10+n%10;\\n        return rev(n/10,sum);\\n    }\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        if(rev(x,0)==x) return true; \\n        \\n        //if the reverse of the number is\\n        //equal to the number returm true\\n        \\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //finding reverse of the number using recursion\\n    int rev(int n,int s){\\n        if(n==0) return s;\\n        int sum=s*10+n%10;\\n        return rev(n/10,sum);\\n    }\\n    public boolean isPalindrome(int x) {\\n        if(x<0) return false;\\n        if(rev(x,0)==x) return true; \\n        \\n        //if the reverse of the number is\\n        //equal to the number returm true\\n        \\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969553,
                "title": "typescript-strings-are-bad",
                "content": "Reverse number and compare.\\nNegatives filter out at first.\\nAvoid modulo operator to gain some perfornace points.\\n\\n```typescript\\nfunction isPalindrome(x: number): boolean {\\n    if (x < 0) return false;\\n    \\n    let x1 = 0;\\n    let div = x;\\n    while (div > 0) {\\n        const quotient = Math.floor(div / 10);\\n        const reminder = div - quotient * 10;\\n        div = quotient;\\n        x1 = x1 * 10 + reminder;\\n    }\\n    \\n    return x === x1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction isPalindrome(x: number): boolean {\\n    if (x < 0) return false;\\n    \\n    let x1 = 0;\\n    let div = x;\\n    while (div > 0) {\\n        const quotient = Math.floor(div / 10);\\n        const reminder = div - quotient * 10;\\n        div = quotient;\\n        x1 = x1 * 10 + reminder;\\n    }\\n    \\n    return x === x1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914722,
                "title": "simple-rust",
                "content": "```rust\\nfn is_palindrome(x: i32) -> bool {\\n\\tlet mut acc = x;\\n\\tlet mut y = 0;\\n\\twhile (acc > 0) {\\n\\t\\ty = y * 10 + acc % 10;\\n\\t\\tacc /= 10;\\n\\t}\\n\\tx == y\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nfn is_palindrome(x: i32) -> bool {\\n\\tlet mut acc = x;\\n\\tlet mut y = 0;\\n\\twhile (acc > 0) {\\n\\t\\ty = y * 10 + acc % 10;\\n\\t\\tacc /= 10;\\n\\t}\\n\\tx == y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635684,
                "title": "one-line-js-solution-o-n",
                "content": "This may not be the idle interview way to answer this question but just wanted to share the beauty(?) of JS\\n\\n```\\nvar isPalindrome = function (x) {\\n  return x.toString() === x.toString().split(\"\").reverse().join(\"\");\\n};\\n```\\n\\nRuntime: 168 ms, faster than **92.57%** of JavaScript online submissions for Palindrome Number.\\nMemory Usage: 47.7 MB, less than **91.86%** of JavaScript online submissions for Palindrome Number.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPalindrome = function (x) {\\n  return x.toString() === x.toString().split(\"\").reverse().join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539657,
                "title": "ruby-simple-solution",
                "content": "Quick and easy solution in Ruby without converting to string (convert to array). 2 line solution.\\n```\\ndef is_palindrome(x)\\n   return false if x < 0\\n    return x.digits.join.to_i == x\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array"
                ],
                "code": "```\\ndef is_palindrome(x)\\n   return false if x < 0\\n    return x.digits.join.to_i == x\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1145916,
                "title": "javascript-easy",
                "content": "````\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    let arr = x.toString().split(\\'\\');\\n    let left = 0,\\n        right = arr.length - 1;\\n    while (left < right) {\\n        if (arr[left++] !== arr[right--]) return false;\\n    }\\n    return true;\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n/**\\n * @param {number} x\\n * @return {boolean}\\n */\\nvar isPalindrome = function(x) {\\n    let arr = x.toString().split(\\'\\');\\n    let left = 0,\\n        right = arr.length - 1;\\n    while (left < right) {\\n        if (arr[left++] !== arr[right--]) return false;\\n    }\\n    return true;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1045945,
                "title": "rust-loop-solution",
                "content": "Runtime: 8 ms, faster than 55.97% of Rust online submissions for Palindrome Number.\\nMemory Usage: 2 MB, less than 91.77% of Rust online submissions for Palindrome Number.\\n```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 || (x % 10 == 0 && x != 0) {\\n            return false\\n        }\\n        \\n        let (mut x, mut rev) = (x, 0);\\n        while x > rev {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        x == rev || x == rev / 10\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_palindrome(x: i32) -> bool {\\n        if x < 0 || (x % 10 == 0 && x != 0) {\\n            return false\\n        }\\n        \\n        let (mut x, mut rev) = (x, 0);\\n        while x > rev {\\n            rev = rev * 10 + x % 10;\\n            x /= 10;\\n        }\\n        x == rev || x == rev / 10\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042511,
                "title": "python-solution",
                "content": "Python solution:\\n```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        pal = x\\n        n = 0\\n        while x > 0:\\n            n = n * 10 + x % 10\\n            x = x //10\\n        if pal == n:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        pal = x\\n        n = 0\\n        while x > 0:\\n            n = n * 10 + x % 10\\n            x = x //10\\n        if pal == n:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747909,
                "title": "swift",
                "content": "```\\nfunc isPalindrome(_ x: Int) -> Bool {\\n        \\n     guard x >= 0 else {\\n        return false\\n    }\\n    \\n    if x < 10 {\\n        return true\\n    }\\n    \\n    var temp = x;\\n    var rev = 0;\\n    \\n    while temp != 0 {\\n        rev = (rev * 10) + (temp % 10)\\n        temp /= 10;\\n    }\\n    \\n    \\n    return  rev == x\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPalindrome(_ x: Int) -> Bool {\\n        \\n     guard x >= 0 else {\\n        return false\\n    }\\n    \\n    if x < 10 {\\n        return true\\n    }\\n    \\n    var temp = x;\\n    var rev = 0;\\n    \\n    while temp != 0 {\\n        rev = (rev * 10) + (temp % 10)\\n        temp /= 10;\\n    }\\n    \\n    \\n    return  rev == x\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 593587,
                "title": "python-one-line-solution-48ms-python-explained",
                "content": "In this problem we just need to reverse the integer and check for both.\\nFirst we will check if it\\'s less than \\'zero\\' return False if that\\'s the case else return the comparision between the both reversed string and the given. \\nIf Type cast the integer x to string first and then using x[::-1] we reversed it.\\nAnd we can write this is one line as given below\\n```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return False if x<0 else str(x)[::-1]==str(x)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return False if x<0 else str(x)[::-1]==str(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483133,
                "title": "9-javascript-math-solution",
                "content": "Here\\'s a math-based solution solution different from any of the others I see here.\\n\\n> Runtime: **184 ms**, faster than *81.12%* of JavaScript online submissions\\n> Memory Usage: **44.7 MB**, less than *98.28%* of JavaScript online submissions\\n\\n```javascript\\nconst isPalindrome = x => {\\n  if (x < 0) return false;\\n  let left = 10 ** Math.trunc(Math.log10(Math.abs(x)));\\n  while (0 < x) {\\n    if (Math.trunc(x / left) !== x % 10) return false;\\n    x = Math.trunc((x % left) / 10);\\n    left /= 100;\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript\\nconst isPalindrome = x => {\\n  if (x < 0) return false;\\n  let left = 10 ** Math.trunc(Math.log10(Math.abs(x)));\\n  while (0 < x) {\\n    if (Math.trunc(x / left) !== x % 10) return false;\\n    x = Math.trunc((x % left) / 10);\\n    left /= 100;\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 317510,
                "title": "cpp-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x > 0 && x % 10 == 0))\\n            return false;\\n        int tmp = 0;\\n        while(tmp < x && tmp < x / 10) {\\n            tmp *= 10;\\n            tmp += x % 10;\\n            x /= 10;\\n        }\\n        return tmp == x || tmp == x/10;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x > 0 && x % 10 == 0))\\n            return false;\\n        int tmp = 0;\\n        while(tmp < x && tmp < x / 10) {\\n            tmp *= 10;\\n            tmp += x % 10;\\n            x /= 10;\\n        }\\n        return tmp == x || tmp == x/10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287547,
                "title": "c-80ms-14-8mb",
                "content": "Runtime: 80 ms, faster than 99.96% of C# online submissions for Palindrome Number.\\nMemory Usage: 14.8 MB, less than 100.00% of C# online submissions for Palindrome Number.\\n\\n```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        //all negetive integer are not palindrome\\n        if(x < 0){\\n            return false;\\n        } else {\\n            int y = 0;\\n            int temp = x;\\n            while(temp != 0) {\\n                y = y * 10 + temp % 10;\\n                temp = temp / 10;\\n            }\\n            if(y == x){\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n        //all negetive integer are not palindrome\\n        if(x < 0){\\n            return false;\\n        } else {\\n            int y = 0;\\n            int temp = x;\\n            while(temp != 0) {\\n                y = y * 10 + temp % 10;\\n                temp = temp / 10;\\n            }\\n            if(y == x){\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176640,
                "title": "python3-solution-without-str",
                "content": "    def isPalindrome(self,x):\n        if ((x<0)or(x%10==0 and x!=0)):\n            return False\n        else:\n            revnum=0\n            while(x>revnum):\n                revnum=revnum*10 + x%10\n                x=x//10\n                \n            return (x == revnum) or (x == revnum//10)",
                "solutionTags": [],
                "code": "    def isPalindrome(self,x):\n        if ((x<0)or(x%10==0 and x!=0)):\n            revnum=0\n            while(x>revnum):\n                revnum=revnum*10 + x%10\n                x=x//10\n            return (x == revnum) or (x == revnum//10)",
                "codeTag": "Python3"
            },
            {
                "id": 164337,
                "title": "javascript-solution",
                "content": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x += \"\";\\n    let i = 0; \\n    let j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        else{\\n            i ++;\\n            j --;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPalindrome = function(x) {\\n    if(x < 0) return false;\\n    x += \"\";\\n    let i = 0; \\n    let j = x.length - 1;\\n    while(i < j){\\n        if(x[i] !== x[j]) return false;\\n        else{\\n            i ++;\\n            j --;\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5358,
                "title": "you-wanted-solution-with-no-extra-space-you-got-it",
                "content": "But it's terribly silly. And the compiler might want to optimize it by using temporary variables, and that's a kind of extra space I'm not responsible for.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || x > 0 && x % 10 == 0) {\\n            return false;\\n        } else {\\n            return x / 10 == 0 || x / 10 == x % 10 || x / 100 > 0 && x / 100 == x % 10 // 1-3 digits\\n                   || x / 100 > 0 && x / 100 ==       x % 10 * 10   + x % 100 / 10 // 4 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 10   + x % 100 / 10 // 5 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 6 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 7 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 8 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 9 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 10000 + x % 100 / 10 * 1000 + x % 1000 / 100 * 100\\n                                                      + x % 10000 / 1000 * 10 + x % 100000 / 10000; // 10 digits\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "But it's terribly silly. And the compiler might want to optimize it by using temporary variables, and that's a kind of extra space I'm not responsible for.\\n\\n    public boolean isPalindrome(int x) {\\n        if (x < 0 || x > 0 && x % 10 == 0) {\\n            return false;\\n        } else {\\n            return x / 10 == 0 || x / 10 == x % 10 || x / 100 > 0 && x / 100 == x % 10 // 1-3 digits\\n                   || x / 100 > 0 && x / 100 ==       x % 10 * 10   + x % 100 / 10 // 4 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 10   + x % 100 / 10 // 5 digits\\n                   || x / 1000 > 0 && x / 1000 ==     x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 6 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 100  + x % 100 / 10 * 10  + x % 1000 / 100 // 7 digits\\n                   || x / 10000 > 0 && x / 10000 ==   x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 8 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 1000 + x % 100 / 10 * 100 + x % 1000 / 100 * 10\\n                                                      + x % 10000 / 1000 // 9 digits\\n                   || x / 100000 > 0 && x / 100000 == x % 10 * 10000 + x % 100 / 10 * 1000 + x % 1000 / 100 * 100\\n                                                      + x % 10000 / 1000 * 10 + x % 100000 / 10000; // 10 digits\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5480,
                "title": "accepted-java-solution-with-short-lines",
                "content": "    public class Solution {\\n        public boolean isPalindrome(int x) {\\n            int temp = Math.abs(x);\\n            int n = temp % 10;\\n            while(temp / 10 != 0){\\n                temp = temp / 10;    \\n                n = n * 10 + temp % 10; \\n            }\\n            if(n == x){\\n                return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPalindrome(int x) {\\n            int temp = Math.abs(x);\\n            int n = temp % 10;\\n            while(temp / 10 != 0){\\n                temp = temp / 10;    \\n                n = n * 10 + temp % 10; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 5544,
                "title": "380ms-accepted-java-solution-what-no-extra-space-mean-though",
                "content": "    public boolean isPalindrome(int x) {\\n    \\n    if (x < 0) return false;\\n    else if (x < 10) return true;\\n    \\n    int n = (int) Math.log10(x);\\n    \\n    for (int i = n; i > n / 2; i--) {\\n    \\tif (x / (int) Math.pow(10, i) % 10 != x / (int) Math.pow(10, n - i) % 10)\\n    \\t\\treturn false;\\n    }\\n    \\n    return true;\\n    \\n    }",
                "solutionTags": [],
                "code": "    public boolean isPalindrome(int x) {\\n    \\n    if (x < 0) return false;\\n    else if (x < 10) return true;\\n    \\n    int n = (int) Math.log10(x);\\n    \\n    for (int i = n; i > n / 2; i--) {\\n    \\tif (x / (int) Math.pow(10, i) % 10 != x / (int) Math.pow(10, n - i) % 10)\\n    \\t\\treturn false;\\n    }\\n    \\n    return true;\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5571,
                "title": "my-c-code-compare-the-first-half-and-the-second-half-of-x",
                "content": "Here, it is assumed that  Palindrome numbers are non-negative and 0 is considered as \"true\"\\nThe basic idea is to construct a rX which includes the second half digits (in the reverse order) and x, which includes the first half digits (in the normal order) and compare them. Attention should be paid to the odd/even digits cases. In such way, overflow issue is avoided.\\n\\n       class Solution {\\n        public:\\n            bool isPalindrome(int x) {\\n                int rX = 0; // the second half of x\\n                if(!x)\\n                { // if x==0\\n                    return true;\\n                }\\n                else if(x<0 || x%10 == 0)\\n                { // all negative numbers are not Palindrome numbers by definition, also for \"0\" digit, false too\\n                    return false;\\n                }\\n                else\\n                {\\n                    while(rX < x)\\n                    {\\n                        rX = rX*10 + x % 10;\\n                        x = x/10;\\n                    }\\n                    return (rX==x) || (rX/10 == x); //(rX==x) is for the even digits case, (rX/10 == x) is for the odd digits case\\n                    \\n                }\\n                \\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            bool isPalindrome(int x) {\\n                int rX = 0; // the second half of x\\n                if(!x)\\n                { // if x==0\\n                    return true;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574279,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564695,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565223,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1567692,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564646,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1711906,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565275,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566467,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1636603,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566451,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1574279,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564695,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565223,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1567692,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1564646,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1711906,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1565275,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566467,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1636603,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1566451,
                "content": [
                    {
                        "username": "NowyKumara",
                        "content": "First convert x into string \\nx = str(x)\\nThen get reverse of x\\nn = x[::-1]\\nNow equate if they are palindrome then teh values must be same>\\nif x == n:\\n\\treturn True\\nelse:\\n\\treturn False.\\nThis is my first ever code that I wrote myself without any help and I am moved to tears right now seeing it compile\\nI am sorry but had to say it, thanks to the community for being there, it means a lot."
                    },
                    {
                        "username": "SivaKrishna-2002",
                        "content": "can you write in java \\n"
                    },
                    {
                        "username": "daliamukherjee216",
                        "content": "[@Moonbeam8773](/Moonbeam8773) i am getting the use of undeclared identifier \\'x_str\\' error. any solution?"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Solution in java :\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "I feel you when you said without any help lol, it gives you a sense of relief from having imposter syndrome"
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "What you\\'re typing is essentially:\\nif True:\\n  return True\\nelse:\\n  return False\\n\\nJust do:\\nx_str = str(x)\\nreturn x_str == x_str[::-1]"
                    },
                    {
                        "username": "Aurof",
                        "content": "you didnt read the follow up, the real challenge is do it without converting the int to a string"
                    },
                    {
                        "username": "muvvalasairamakrishna",
                        "content": "i wrote the same but its giving an erroe\\n"
                    },
                    {
                        "username": "rellik",
                        "content": "I am wondering how the other people got their code ACed, the testing result of **\"-2147447412\"** seems a little odd to me. Should it be a palindromic number or not?\\n\\nNote: I believe the range of int is [-2147483648, 2147483647] and **\"-2147447412\"** is not overflowed, plus I handled the overflow cases already (test case \"-2147483648\" in particular).\\n\\n\\n11499 / 11502 test cases passed.\\n\\nStatus: Wrong Answer\\n\\n\\nInput:\\t-2147447412\\n\\nOutput:\\ttrue\\n\\nExpected:\\tfalse\\n\\n------------------------------------------------------------------\\nHere's my second question:\\n\\n**Why does the function take \"int\" as input instead of \"unsigned int\", when we assume all negative numbers are NOT palindromic.**"
                    },
                    {
                        "username": "rohanrambroo",
                        "content": "i think in your code you should do if x<0 return false because we can never accept -ve numbers"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "Input: x = -121\\nOutput: false\\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\\n\\n"
                    },
                    {
                        "username": "izzattulaev",
                        "content": "Input: -2147447412 and output must show \"false\" (in the description)\\n"
                    },
                    {
                        "username": "kojosimtema",
                        "content": "i believe all negative numbers are not palindrome because \"-\" is considered part of the number, and in the reverse you will get the \"-\"  at the end of the number. \\n\\nSo in this case \"-2147447412\"  will be \"2147447412-\"  in the reverse"
                    },
                    {
                        "username": "LMunique",
                        "content": "If it says O(1) space I can understand how to do that, but what does no \"extra space\" mean? If I use another integer to save the reversed number does it mean I'm still using extra space? Or when I simply am using an integer i for loop does it mean I have extra space?"
                    },
                    {
                        "username": "hp273",
                        "content": "O(1) does not mean extra space, it means the space you are using is independent of any other factor for example if you are using fixed size array then the size will not grow as i/p size grows."
                    },
                    {
                        "username": "blueshipswims",
                        "content": "by \\'extra space\\' what it means is that does the space required for all the cases change with case ? is the space required \\'variable\\' . If you reverse a number like 123 it yields 321 and this would consume the same memory when you reverse a number like 94729726 because both are integers BUT if you are using an array to store the digits and then reverse it or whatever then the memory required becomes variable because the individual digits have their own space in the array and thus costing EXTRA SPACE. Hope it helps. "
                    },
                    {
                        "username": "krishankanhaya_",
                        "content": "yes, i get your intension but O(1) due to this extra space which you needed for solving problem not grow as your input size varies that\\'s why it is O(1)."
                    },
                    {
                        "username": "haikeren61",
                        "content": "![image](https://assets.leetcode.com/users/images/e119a3a4-d25c-4396-b675-ad1ff971633f_1636894502.7062209.png)\\n"
                    },
                    {
                        "username": "CandyRobbery",
                        "content": "- Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack.\\n\\n- If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space."
                    },
                    {
                        "username": "Sudheer474",
                        "content": "what the hell output is whats wrong with my code\\n   int rev=0;\\n        if(x<0){\\n            return false;\\n        }\\n        while(x!=0){\\n            rev= rev*10 + x%10;\\n            x=x/10;\\n        }\\n        if(x!=rev){\\n            return false;\\n        }\\n        return true;\\n\\nit gives wrong for 121 test case my output is false.."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "class Solution {\\n\\n        public boolean isPalindrome(int x) {\\n\\n    if (x < 0 || (x != 0 && x % 10 == 0)) {\\n        return false;\\n    }\\n\\n    int reversed = 0;\\n    int originalX = x;\\n\\n\\n    while (x > 0) {\\n        int digit = x % 10;\\n        reversed = reversed * 10 + digit;\\n        x /= 10;\\n    }\\n\\n\\n    return reversed == originalX;\\n}\\nUse this approach"
                    },
                    {
                        "username": "Hari_Seenu_7",
                        "content": "bro just omit last if and return statement then write return rev "
                    },
                    {
                        "username": "omprakash1353",
                        "content": "Bro you have changed the value of x then you tried to compare them it obviously goona return wrong ans"
                    },
                    {
                        "username": "biswassubhojit6831",
                        "content": "your rev val will be 121 and x will be \"0\" either change the code or start focusing more on every line to find the solution"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "a/c to your code \\nx is changing (i.e., in while loop) &\\nyou are comparing with x.\\nSo you\\'ve to just copy x with y\\nthen you\\'ve compare y with rev.\\nlike...\\n\\nint rev=0,y;\\ny=x;\\nif(x<0) return false;\\nwhile(x!=0){\\n       rev= rev*10 + x%10;\\n       x=x/10;\\n}\\nif(y != rev) return false;\\nreturn true;\\n\\nthanks :)"
                    },
                    {
                        "username": "ps_27",
                        "content": "acc to your code x is changing ....and you are comparing with x ."
                    },
                    {
                        "username": "Rishiraj_30",
                        "content": "just store the value of x before performing any operation x.\\n\\nint copy_of_x = x;\\nint rev=0;\\nif(x<0){\\nreturn false;\\n}\\nwhile(x!=0){\\nrev= rev*10 + x%10;\\nx=x/10;\\n}\\nif(copy_of_x !=rev){\\nreturn false;\\n}\\nreturn true;"
                    },
                    {
                        "username": "satyamgarg1308",
                        "content": "if(x<0) this is your problem , Program says the value of X can be negative or positive ."
                    },
                    {
                        "username": "MenaiAla",
                        "content": "[@sonu2231kumar](/sonu2231kumar) It does not work."
                    },
                    {
                        "username": "f_murshid_",
                        "content": "due to x is gradually decresing so first initialize temp variable and declear x in it and then compare rev and temp"
                    },
                    {
                        "username": "sonu2231kumar",
                        "content": "rev = (rev*10)+(x%10)\\nor \\nif(x==rev)\\n          true;\\nfalse;\\n"
                    },
                    {
                        "username": "harshitgaur600",
                        "content": "[@MayankRathore](/MayankRathore) x is changing in the loop as you did x=x/10. so try to make a temp variable to store x.\\n"
                    },
                    {
                        "username": "Bit-creatorCK",
                        "content": "[@MayankRathore](/MayankRathore) The Value of x changes in while loop and ends to 0 i.e. the condition of your while loop. To check whether it\\'s palindrome or not, you have to keep a copy of the value of x into another variable. \\n\\nJust think, if the value of x wasn\\'t changing in your while loop, then why did it not end up to infinite loop? Hope you got it now."
                    },
                    {
                        "username": "brahadeeshram",
                        "content": "last if condition has wrong condition and return statement also wrong "
                    },
                    {
                        "username": "HegdeRam",
                        "content": "keep original copy of X at initial step. int org = x;"
                    },
                    {
                        "username": "Sofiyan_M",
                        "content": "use temp to store value x . bcoz  x\\'s value changes through out the program from original one\\'s and use if(temp != rev)"
                    },
                    {
                        "username": "MayankRathore",
                        "content": " bool isPalindrome(int x) {\\n        long long int ans=0;\\n        while(x!=0)\\n        {\\n            int temp= x % 10;\\n           \\n            ans= (ans *10 )+ temp;\\n             x = x / 10;\\n        }\\n        if(ans==x){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\nsame problem with my code also......."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "cherishlc",
                        "content": "If a number is a palindrome,,  its reverse equals itself.  \\nWhich means its reverse is NOT overflow!!!\\nSo that ' reversed integer might overflow'  doesn't matter at all, since a overlowed number isn't a palindrome.\\n\\n\\nNow the question becomes whether a NONE palindrome  == its reverse if we do NOT deal with overflow."
                    },
                    {
                        "username": "aivanilov",
                        "content": "Integer max = 2147483647 and Integer min = -2147483648. May be this is the case?"
                    },
                    {
                        "username": "run2explore99",
                        "content": "BEATS 97%\\n `class Solution {\\n    public boolean isPalindrome(int x) {\\n       int reverse=0;\\n        int temp = x;\\n\\n        if (x < 0) return false;\\n        while(temp != 0)   \\n        {  \\n        int remainder = temp % 10;  \\n        reverse = reverse * 10 + remainder;  \\n        temp = temp/10;  \\n        }  \\n        return reverse == x;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1568819,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1876487,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1850648,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1575867,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1802228,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1575578,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1574137,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1567056,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1715373,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1576968,
                "content": [
                    {
                        "username": "tang3117022",
                        "content": "\\nHi,\\n\\nI am a little confused about the restriction of this question.\\n\\nWe are not allowed to use extra space in this question, does it mean we can not declare any variables except for x?\\n\\nThanks."
                    },
                    {
                        "username": "sakshichoudhary148",
                        "content": "we can. it is not possible without using another variable."
                    },
                    {
                        "username": "luqmansen",
                        "content": "extra space that grow as the input grow. Defining variable that use constant memory is allowed"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the official LeetCode solution:\n\nhttps://www.youtube.com/watch?v=OlTk8wM48ww"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "A small hint for negative numbers, return false."
                    },
                    {
                        "username": "raja_1234_raja",
                        "content": "woww what a hit abhinav tqs da "
                    },
                    {
                        "username": "princejacob",
                        "content": "Folks, like many of you (maybe?) I stumbled on this question.  It\\'s categorized as Easy.  Sure...easy if you know the answer.  The challenge is, you can\\'t (shouldn\\'t) convert the integer to a string.  Why?  Because the question is about **math**.  \\n\\nThey\\'re not looking for substring manipulation, they\\'re looking for integer manipulation.  \\n"
                    },
                    {
                        "username": "yasaminashoori",
                        "content": "Hi, i run my code in Vs code and everything wroks correctly but I don't know why did it give me error in leetcode  and says WRONG ANSWER. Any idea ? "
                    },
                    {
                        "username": "krushna2604",
                        "content": "same problem in two other code also, but why?"
                    },
                    {
                        "username": "nasta978",
                        "content": "\\u0418 \\u0443 \\u043C\\u0435\\u043D\\u044F \\u0442\\u043E\\u0436\\u0435(("
                    },
                    {
                        "username": "Suryam_Pathak",
                        "content": "same problem bro"
                    },
                    {
                        "username": "pth_1641",
                        "content": "var isPalindrome = (x) => x.toString().split(\\'\\').reverse().join(\\'\\') === x.toString() ? true : false;"
                    },
                    {
                        "username": "emailsemails7",
                        "content": "let isPalindrome = x => x === +[...\\'\\'+x].reverse().join(\\'\\')"
                    },
                    {
                        "username": "jwheeler27",
                        "content": "return str(x) == str(x)[::-1]\\n\\nGotta love typecasting and string slicing."
                    },
                    {
                        "username": "saikot1223",
                        "content": "How can i make the int x into string in c++??"
                    },
                    {
                        "username": "user6235iz",
                        "content": "one would use google for that"
                    },
                    {
                        "username": "batrapunit1999",
                        "content": "Use to_string()."
                    },
                    {
                        "username": "mijitsu",
                        "content": "![image](https://assets.leetcode.com/users/images/906f8bfe-a327-4d38-b9a3-4fc94e417e41_1656541936.6629639.png)\\n"
                    },
                    {
                        "username": "shivamsingh_",
                        "content": "How did you resolve the problem?"
                    }
                ]
            },
            {
                "id": 1576136,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1568482,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 2013450,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1845665,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576849,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576802,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576801,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576564,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1576325,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1574621,
                "content": [
                    {
                        "username": "sairamravuri",
                        "content": "![image](https://assets.leetcode.com/users/images/69176788-e14e-48f0-9949-17b2faa2dd31_1640783105.5426483.jpeg)\\n"
                    },
                    {
                        "username": "camoverride",
                        "content": "Reversing the number and checking whether it equals the un-reversed version is a test of your coding ability, and might appear in a basic coding interview. The \"don\\'t convert to a string\" variation will NEVER appear in an interview and is a bullshit question. Here\\'s why:\\n\\n1) You solved the problem by stringifying it. Why overthink things and use complicated and hard-to-debug math?\\n2) The \"algorithmic\" component of this is NOT part of a broader problem-solving paradigm in comptuer science (think of dynamic programming, graph algorithms, etc). Rather, it\\'s a one-off math trick.\\n"
                    },
                    {
                        "username": "ananyaa1204",
                        "content": " `class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n      int temp, rev=0;\\n      temp = x;\\n      \\n      while(x != 0) {\\n         rev = (rev*10) + (x%10);\\n         x = x/10;\\n      }\\n      \\n      if(temp == rev)\\n        return true;\\n      else \\n       return false;\\n    }\\n};`\\nIDK what\\'s wrong with my  code. however the testcase is being failed for -121"
                    },
                    {
                        "username": "user3522n",
                        "content": "Make sure to short circuit the function if x is a negative number."
                    },
                    {
                        "username": "levebrains",
                        "content": "Hello. \\nI have problem with case x = 10. When I run my progam in PyCharm it works and return \\'false\\' but when I run it here I got wrong (my output \\'true\\'). Could anyone tell me please why it so? "
                    },
                    {
                        "username": "jayasrinadhp",
                        "content": "try this, i also had problem with test cases like 10,100.... Below code may resolve it.\\n\\nString s = Integer.toString(x);\\n    int i =0,j=s.length()-1;\\n    boolean f = true;\\n    while(i<=j){\\n        if(s.charAt(i)!=s.charAt(j))\\n          return false;\\n        i++;\\n        j--;\\n    }\\n    return f;"
                    },
                    {
                        "username": "zyrastory",
                        "content": "Which have included C#, Java, Python3 solution\\n**(6/4 updated JavaScript version)**\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-9-palindrome-number-solution-and-explanation-en/)\\u2B50\\n\\nThe solutions will have detailed explaination.\\n\\n![image](https://assets.leetcode.com/users/images/51586908-d770-44cf-8230-cd33d5906577_1654333005.8973863.jpeg)\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know.**\\n\\nSee more LeetCode solution : [https://zyrastory.com/en/category/coding-en/leetcode-en/](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\n\\nThanks!\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "gd_daredevil",
                        "content": "![image](https://assets.leetcode.com/users/images/40d82a71-08a9-42ee-a9a2-fbbcf986ba2d_1653364187.5387318.png)\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/\\n"
                    },
                    {
                        "username": "ny25",
                        "content": "\\t\\n\\treturn str(x)==str(x)[::-1]\\n\\t"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gignupg",
                        "content": "For all the noobs like me who struggle to understand the time complexity in the solution:\\nThe time complexity in this solution is O(log10(n)). Note that O(log10(n)) is ESSENTIALLY equivalent to O(n) if we use different values for n. So let\\'s do that real quick. Let\\'s replace each n with something else. O(log10(a)) where \"a\" is the input value itself and O(b) where \"b\" is the length of the input. \\nIf let\\'s say our input is 100, \"a\" will be 100 and \"b\" will be 3 (our input 100 consists of three numbers and has therefore a length of 3). \\nNote that O(a) does not equal O(b). However, O(log10(a)) equals O(b) or in other words log10(a) equals \"b\". \\nLet\\'s replace \"a\" with our input 100. So we get log10(100) which we can put in our calculator or simply do in our heads or on paper. Anyway, the result is 2. In other words, log10(100) = 2. Because 10\\xB2 = 100.  \\nWith an input of 1000, O(log10(1000)) will be 3 and with an input of 10000, O(log10(10000)) will be 4. As you can see, O(log10(a)) as well as O(b) both get gradually bigger as the input becomes bigger. So in both cases we\\'re dealing with linear time complexity and they are essentially saying the same thing. I hope that made sense and I hope it helped ;)"
                    }
                ]
            },
            {
                "id": 1574605,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1574085,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1573659,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1573497,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1573267,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1572721,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1572239,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1571013,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1571014,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1571015,
                "content": [
                    {
                        "username": "Conane",
                        "content": "![image](https://assets.leetcode.com/users/images/4651264c-5e47-43f7-befe-b864610d07ac_1605656670.2109852.png)\\nWould you please do the complexity analysis for this solution.\\nThank you in advance"
                    },
                    {
                        "username": "msn_user",
                        "content": "No need for reversing the second half. There was more effcient ways to check for palindrome -\\nhttps://www.techiedelight.com/determine-given-number-palindrome-not/\\n"
                    },
                    {
                        "username": "Maruthi2000",
                        "content": "return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "muzik999",
                        "content": "return (x>=0 and x == int(str(x)[::-1]))"
                    },
                    {
                        "username": "Podilatis23",
                        "content": "return str(x) == str(x)[::-1]\\n\\n"
                    },
                    {
                        "username": "zhuzhua",
                        "content": "return x==int(str(abs(x))[::-1])"
                    },
                    {
                        "username": "hanburger97",
                        "content": "Perhaps someone can help me understand the time and space complexity here.\\nSince we are only processing integer, assuming that we convert it into a string, or an array of character, the fact that x is an integer (assuming long signed) makes it bounded by -2,147,483,648 to 2,147,483,647. Which means converting such into a string can never exceeds an array of 11 character.\\nSimilarly iterating through this character array can never exceed 11 iterations.\\nHence wouldn\\'t that make the string conversion O(1) for both space and time?"
                    },
                    {
                        "username": "HidyHan",
                        "content": "I think being nonnegative is a requirement of palindromes in this question. If so, I feel that it should be specified, since it does not seem intuitive to me..."
                    },
                    {
                        "username": "zhouji",
                        "content": "I don't think this is self-evident or has an obviously accepted convention. The question should be clarified."
                    },
                    {
                        "username": "ttsshh1990",
                        "content": "If a integer is palindrome number, then reversing this number will not cause overflow.\\nIn other words if overflow happened this number is not a palindrome number. \\nSo I am just wondering why we cannot just return false when overflow happens.\\nCan someone explain to me? Thanks a lot!"
                    }
                ]
            },
            {
                "id": 1570890,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1576335,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1568820,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1576400,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1576051,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 1571012,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2077156,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2076655,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2076086,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2074609,
                "content": [
                    {
                        "username": "tanay1502",
                        "content": "return str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Omyx",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab.\\n\\n2. The problem discussion tab is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "Vgn",
                        "content": "Dear LeetCode,\\n\\nI don't think there is a boolean data type in C language. When we select the language as C, it shows the following function signature which I suppose is not correct.\\n\\n    bool isPalindrome(int x){\\n    }\\n\\nPlease correct it.\\n\\nThanks."
                    },
                    {
                        "username": "cattishToast",
                        "content": "bool Is a data type added in the <stdbool.h> header file"
                    },
                    {
                        "username": "alimjanovff",
                        "content": "IsPalindrome"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/palindrome-number-leetcode-python-python-solutions/"
                    },
                    {
                        "username": "4n33s",
                        "content": "return str(x)[::-1] == str(x)"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "RETURN (str(x)[::-1] == str(x))\\nWHY WE ARE USING STR(X)  AS IN QUESTION  IT MIGHT THE CONDITION AT WHICH ANY FLOAT VALUE CAN INPUT WHICH GOING TO CONVERTED INTO STRING AS WE ARE TYPECASTING X VALUE IN STR CLASS"
                    },
                    {
                        "username": "jsmith7677",
                        "content": "Input: -101\\nOutput: true\\nExpected: false\\n\\nHow can 101 not be a palindrome?"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "BRO SORRY BUT \\nFIRST GO AND HAVE TUTORIAL WHAT IS PALINDROME."
                    },
                    {
                        "username": "BishalGupta0",
                        "content": "its -101 not 101 i think"
                    },
                    {
                        "username": "shivahi",
                        "content": "This is very easiest question for me .I solve with in 2 min.\\nApproach :\\nSo we have to see is it palindrome or not.In string we use two pointer approach or we reverse it Then see is it same as x.\\nIt hard to this approach for me do with int.So I type caste the int into string(st) then \\nmake one blank string (result) to store the reverse value\\nthen i iterate the string from right to left and every iteration i store the value in the result.\\nAfter wards i check it is equal to st then True .else false\\n\\n\\nBut I want to anyother approach can i solve this without type casting or using list..\\nPlease feel free to reply??"
                    },
                    {
                        "username": "Iviwe_M",
                        "content": "I keep getting \"Time Limit Exceeded\" for:\\n\\npublic class Solution {\\n    public bool IsPalindrome(int x) {\\n\\n  int rev = 0;\\n\\n        while (x > 0) {\\n            rev *= 10 + (x % 10);\\n            rev /= 10;\\n        }\\n    return rev == x;\\n\\n  }  \\n}\\n\\nAny help as to why?"
                    },
                    {
                        "username": "kmooventhan98",
                        "content": "\nfor 10 I am getting true, but it should return false\nany error in this code\n\ndef is_palindrome(x)\n    return false if x < 0\n    div = 1\n    while div <= x\n      div *= 10\n    end\n    while x > 0\n      first_value = x / div\n      last_value = x % 10 \n     return false if first_value != last_value\n      # update x\n      x = (x/10) % div\n      # update div\n      div /= 100\n    end\n  true\nend\n\n"
                    },
                    {
                        "username": "unknownghost64",
                        "content": "\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        temp = x  \n        rev = 0  \n        while(x > 0):  \n            dig = x % 10  \n            rev = rev * 10 + dig  \n            x = x // 10  \n        if(temp != rev) or x<0:  \n            return \"false\"\n        else:  \n            return \"true\"        \n\nI have wrote this code on but it failed in the 2 and 3 and if run the same test case in PyCharm it well and good is something wrong in my code or is it something else. I have copied pasted the code so the indexing might me off  but indexing in my code is correct\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must  INCLUDE one more condition were you check weather the x is greater then  0 or not\\nIF (X<0):\\n     RETURN FALSE\\n"
                    }
                ]
            },
            {
                "id": 2073192,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2072974,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2072824,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2071623,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2070501,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2068681,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2068645,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2068641,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2066216,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2065681,
                "content": [
                    {
                        "username": "arshiyankhan92",
                        "content": "#include<iostream>\\n#include<climits>\\nusing namespace std;\\nint main(){ \\n      int x;\\n        int rev=0;\\n        int rem=0;\\n        cout<<\"Enter number to check palindrome: \";\\n        cin>>x;\\n        while(x!=0){\\n            rem=x%10;\\n            rev=(rev*10)+rem;\\n            x=x/10;\\n        }\\n            if(rev){\\n                cout<<rev<<\" is palindrome\";\\n            }\\n              else\\n            cout<<rev<<\" is not palindrome\";\\n            }\\n          \\n        \\n        \\n\\n\\n   \\n        \\n       \\n        \\n    \\n    \\n    \\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro you must INCLUDE one more condition were you check weather the x is greater then 0 or not\\nIF (X<0):\\nRETURN FALSE"
                    },
                    {
                        "username": "shreya_chaturvedi18",
                        "content": "what the hell with my code....plz help\\nclass Solution {\\n    public boolean isPalindrome(int no) \\n    {\\n        int no1= no;\\n        int rev=0;\\n        \\n        \\nwhile( no1!=0)\\n{\\nint rem=no1%10;\\n rev=rev*10+rem;\\nno1=no1/10;\\n}\\nif(  rev==no)\\n{\\nreturn true;\\n}\\nelse\\n{\\n    return false;\\n}\\n}\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "   if(no<0) return false;\\nyou have not check the condition if the n must greater than 0\\nin Result  case 2 will showing wrong Answer"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "just add a condition at the starting which returns false if input no. is less than 0. as the code requires false output for a negative no which can't be obtained by digit separation\nif(no<0){\n  return false;\n} \nthis at start would be enough to solve your problem"
                    },
                    {
                        "username": "shakhzodmakhmasoatov",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x)==str(x)[::-1]:\\n            r=True\\n        else:\\n            r=False\\n\\n        return r"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "bro your solution is correct but it is  python"
                    },
                    {
                        "username": "AbhishekChoubey_081",
                        "content": "one line solution\n\nin these question we are checking palindrome or not \nfor that we can check [::-1] of that element is same to the  original element\n return(str(x)==str(x)[::-1])\nstr(x)[::-1} these means slicing the x\nwe are using (str) because it may that value will in float  or integer and it is necessary to convert it into string \nfor getting  perfect value of x\n\n"
                    },
                    {
                        "username": "ChrisKeyber",
                        "content": "Using python, beat 90% of users in memory, but get beaten by 90% users in run time. "
                    },
                    {
                        "username": "nalluchakradhar",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        k=str(x)\\n        l=k[::-1]\\n        if k==l:\\n                   return(\"True\")\\n        else:\\n                   return(\"False\")\\ncan anyone help me with this code ...I\\'m getting wrong output"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "I Thought of using the coversion to string method but when i read the challenge below the problem to do it withtout a string then...\\nI Tried a basic c++solution  applying digit separation and comparing the numbers and returning it.\\nFor negative numbers i simply returned false as they cant be pallindrome acc to problem statement\\nWHEN I SUBMITTED MY ANS I GOT 3ms TIME AND SO I REMOVED SOME VARIABLE CREATION THINKING IT WOULD BE BETTER BUT INSTEAD I GOT 17 MS RUNTIME SO I JUST SUBMITTED MY PREVIOUS SOL. AND I GOT 17 MS RUNTIME AGAIN THEN AGAIN I TRIED AND I GOT 11 . \\n\\nIDK WHATS HAPPENING BUT WHY IS LEETCODE GIVING DIFF RUNTIME FOR SAME SOLUTION .....HOW DOES IT WORK PLEASE HELP"
                    },
                    {
                        "username": "pseudo_Coder1",
                        "content": "[@gregoryderner](/gregoryderner) Thanks brother, If i am not disturbing you will you please tell me what do you mean by creating an isolated environment here.How can i create that to compare time taken."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This happens because some values are generated randomly and therefore, even if you send the same code you will have different results. In javascript I created an isolated mechanism to test performance in a more controlled way and compare with other solutions to see how my code performs. Maybe it\\'s the case that you do something similar for yours."
                    },
                    {
                        "username": "hunterxcobby",
                        "content": "Wow, I am a junior developer who just got introduced to Leetcode and i am already loving it. This  is the best platform ever.\\n\\nso i kind of first used the extraction method which ended up not  satisfying the fifth edge cases and it made sense. So i checked the follow up and realised i could easily use string conversion"
                    },
                    {
                        "username": "IshaqAlkhairi",
                        "content": "my solution compiles perfectly anywhere but here and i keep facing this problem: \\nCompile Error\\n0 / 0 testcases passed\\nLine 49: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   52 | int main(int argc, char *argv[]) {\\n      |     ^~~~"
                    },
                    {
                        "username": "nein4matic",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        result = True if str(x) == str(x)[::-1] else False\\n        return result"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2062151,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2061890,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2061155,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2060827,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2060085,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2059748,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2059343,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2056356,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2054536,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2052856,
                "content": [
                    {
                        "username": "ankitsingh01818",
                        "content": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int reverse=0\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        while(temp!=0){\n            int reminder=temp%10;\n            reverse=reverse*10+reminder;\n            temp/=10;\n        }\n        return x==reverse; \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user4230Em",
                        "content": "My code is working on pyCharm and all the usecases are passed . But it is failing in LeetCode for usecase 2 & 3 and not sure why. \\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        a=str(x)\\n        length = len(a)-1\\n        j=bool\\n        i=0\\n        while i <= length:\\n            if a[i] == a[length]:\\n                length -= 1\\n                i += 1\\n                j=\\'true\\'\\n            else:\\n                j =\\'false\\'\\n                break\\n        return j\\nsol=Solution()\\nb=int(input(\"Enter a number\"))\\nprint(sol.isPalindrome(b))"
                    },
                    {
                        "username": "Codex_Psycho",
                        "content": "Hi, I am new to this platform, I generally use the IntelliJ IDEA compiler, and when I want to compile the code it does not work, but if it works in the IDEA compiler, how can I solve the problem? (the code is in java):\\n\\nimport java.util.Scanner;\\n\\npublic class IsPalindrome{\\n     public static void main(String[] args) {\\n         Scanner scanner = new Scanner(System.in);\\n         String num = \"0\";\\n         String palindrome = \"\";\\n         System.out.println(\"Enter an integer\");\\n         num = String.valueOf(scanner.nextInt());\\n         if(num.length()==1){\\n             System.out.println(\"the number \".concat(num).concat(\" is a palindrome\"));\\n         } else {\\n             int barrier = num.length()-1;\\n             for(int cycles = 0; cycles<num.length(); cycles++){\\n                 palindrome = palindrome + String.valueOf(num.charAt(barrier-cycles));\\n             }\\n             System.out.println(\"palindrome = \" + palindrome);\\n             if (num.equals(palindrome)){\\n                 System.out.println(\"the number: \".concat(num).concat(\" is a palindrome\"));\\n             }\\n             else{\\n                 System.out.println(\"the number : \".concat(num).concat(\" is not a palindrome\"));\\n             }\\n         }\\n     }\\n}"
                    },
                    {
                        "username": "anksum2022",
                        "content": "What is the point of allowing -ve numbers for this? ARen\\'t all -ve numbers going to return `False`?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "So that your code deals with this type of data.\\nFor example, there is code that deals directly with the data and goes into the process of validating the palindrome. Some just deny the information (as you rightly said) it will always be false."
                    },
                    {
                        "username": "Raknid",
                        "content": "why is my code showing runtime 4ms and memory 42.35 mb\nand sometimes it is showing runtime as 12ms or 10ms and memory 46 mb?\n "
                    },
                    {
                        "username": "gregoryderner",
                        "content": "This is because some data is generated randomly. And this also bothered me, as I really wanted to know the values, I created a git to do tests."
                    },
                    {
                        "username": "Kalpesh9090",
                        "content": "can somebody explain it to me ?"
                    },
                    {
                        "username": "gregoryderner",
                        "content": "A palindrome is a palindrome, regardless of whether it is a number or not. \"eye\" is a palindrome. Palindrome in simple definition would be being able to read the characters backwards and it remains the same. That\\'s why we see several solutions immediately converting to a string. That\\'s why (it should be read the same backwards) that \"-101\" would not be a palindrome."
                    },
                    {
                        "username": "Raknid",
                        "content": "So a palindrome number is a number is a number whose value is the same even after reversing it.\\nWhen the number is negative, it can\\'t be a palindrome.       Eg:  -101 ,reversed number-> 101- , not same!\\nWhen the number is have a zero in the end ,it can\\'t be palindrome.\\nEg: 110 ,reversed number-> 011, not same!\\nconsidering these conditions try solving for the Palindrome problem."
                    },
                    {
                        "username": "Aayush_2511",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        x = str(x)\\n        y = x[::-1]\\n        return bool (y == x)"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gregoryderner",
                        "content": "If anyone else, like me, was bothered to see that the \"runtime\" results were different even when sending the same algorithm, and like me, you want to know the performance of your code based on others. I did this benchmark to be able to test in a more isolated way.\\n\\nhttps://github.com/gregoryderner/leetcode-palindrome-benchmark"
                    },
                    {
                        "username": "badrsouhar",
                        "content": "how to convert int x to string or char * in c++, idk why itoa() isn\\'t working i want to code my own itoa but I got \"heap-buffer-overflow\"."
                    },
                    {
                        "username": "loveworld",
                        "content": "This question is very important to learn and know the simple way."
                    }
                ]
            },
            {
                "id": 2049855,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2049752,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2048270,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2047711,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2038707,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2038283,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2035993,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2033938,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2027545,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2020910,
                "content": [
                    {
                        "username": "Akash-jaiswar786",
                        "content": "Tips  which beats 100%-> Just simply convert the integer into  string using (to_string) and than take two variables (i,j) take i = 0 and j = string.size()-1 and check if ( i != j ) return false and i++,j--\\nelse return true "
                    },
                    {
                        "username": "vishwa_099",
                        "content": "hey there look at my code.\\nI solved it without converting the number to the string.class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long long int ans=0;\\n        if(x<0){\\n            return 0;\\n        }\\n        long long int copy=x;\\n        while(copy!=0){\\n            int digit=copy%10;\\n            ans=(ans*10)+digit;\\n            copy/=10;\\n        }\\n        if(ans==x){\\n            return 1;\\n        }\\n        else\\n           return 0;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "VaibhavChougule_475",
                        "content": "1000000001 > INT_MAX /10  then it should return false\\noutput : false\\nexpected : true \\nwhy this ?"
                    },
                    {
                        "username": "yorachidi94",
                        "content": "my solution got accepted using C language but i know i can reduce time to half but i dont know how , if anyone can check my code and tell me how to let it check only yo the half of of numbers in x ?\\ndidnt use STRING ! Only math "
                    },
                    {
                        "username": "kcruz92",
                        "content": "I got 75% faster than other leet code submissions where I reversed the int and compared it to the original int using a while loop. Is there a faster approach to finding out the given int is a palindrome?\\n"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why is my code wrong? Its showing false for 121\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int y =0;\\n        y = x;\\n\\n        string ans1 = to_string(x);\\n        string ans2 = \"\";\\n        while(y > 0){\\n            ans2.push_back(y%10);\\n            y = y/10;\\n        }\\n        if(ans1 == ans2) return true;\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "BanjiBear",
                        "content": "Hi, I am new to coding here. \\nI am encountering something I do not know why. Any hints or explanation would be appreciated.\\n\\nThe following code is my solution but results in: Line 8: Char 27: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' [solution.c]\\nHowever, if I remove the variable value and use x directly, the error is gone, but x will be changed.\\nI wonder what causes all the things above.\\nThank you so much for your time\\n\\nbool isPalindrome(int x){\\n    if(x < 0){\\n        return false;\\n    }\\n\\n    int compare = 0, value = x;\\n    while(value > 0){\\n        compare = compare * 10 + value % 10;\\n        value = value / 10;\\n    }\\n    if(x == compare){\\n        return true;\\n    }\\n    return false;\\n}"
                    },
                    {
                        "username": "kyleTumlinson",
                        "content": "the issue is that the number will be too big for an integer. The only way i found around that case is to change from an int to a long int, long int has more space. however this takes up more memory so there is a trade off."
                    },
                    {
                        "username": "hibak27",
                        "content": "guys why my time limit is getting exeeded ? :(\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rev=0\\n        temp=x\\n        while temp!=0:\\n            last=temp%10\\n            rev=rev*10+last\\n            temp=temp//10\\n        return (rev==x)`"
                    },
                    {
                        "username": "zlinkkk",
                        "content": "in vsc when i test my code with 1 example it outputs true, and here it outputs false :("
                    },
                    {
                        "username": "nitya_333",
                        "content": "my all three test cases have passed.But for x=123 it returns true and i dont know what is wrong\\n"
                    }
                ]
            },
            {
                "id": 2015533,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 2014980,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 2002794,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1997618,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1997513,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1996201,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1994518,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1994457,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1983130,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1978337,
                "content": [
                    {
                        "username": "Anil-Gehlot",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n\\n        int num = x;\\n        int rev = 0;\\n\\n        \\n        if(x<0){\\n            return false;\\n        }\\n        while(num!=0){\\n            int l_digit = num%10;\\n            rev = (rev*10) + l_digit;\\n            num = num/10;\\n\\n        }\\n        if (x==rev){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek09012004",
                        "content": "why am I getting time limit exceeded as the result?"
                    },
                    {
                        "username": "nurim",
                        "content": "it\\'s so easy but i can\\'t solve 121 in my IDE return True and in leetcode it return like False,why....\\nlast_digit=x % 10\\nfirst_digit = x\\nwhile first_digit >= 10:\\n     first_digit//=10\\n\\nr=str(x)\\nif r == r[::-1]:\\n      print(\\'True\\')\\n else:\\n      print(\\'False\\')"
                    },
                    {
                        "username": "s99000",
                        "content": "#include<bits/stdc++.h>\\n\\nusing namespace std;\\nint main()\\n{\\nint x;\\ncin>>x;\\n   int c=x;\\n   int rev=0;\\n    while(x>0)\\n    {\\n        int ld=x%10;\\n     rev =(rev*10)+ld;\\n    x=x/10;\\n    }\\n    if (c==rev)\\n    cout<<\"true\";\\n    else \\n    cout<<\"false\";\\n}\\n\\n\\n what is the solution of this\\n"
                    },
                    {
                        "username": "theshrish46",
                        "content": "let pali = x.toString().split(\\'\\').reverse().join()\\nlet temp = x.toString()\\nreturn (temp == pali)\\n\\ncan anybody tell me whats wrong with this code"
                    },
                    {
                        "username": "JordanDMcGuire",
                        "content": "Something missing from the explanation of this problem. When I run the code in my IDE I get the correct answer but when I run it on this site it says its wrong."
                    },
                    {
                        "username": "ingilteremuhasebe",
                        "content": "really good idea"
                    },
                    {
                        "username": "_SamChristopher_",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int reverse = 0;\\n        int originalNum=x;\\n        for(;x!=0;){\\n            int remind = x%10;\\n            reverse = reverse *10 +remind;\\n            x/=10;\\n        }\\n        if(reverse == originalNum){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhat wrong in my code ?? i get error"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Try to convert int reverse into long reverse "
                    },
                    {
                        "username": "guptasam318",
                        "content": "The real challenge was to solve this question without converting to string, almost all the top solutions are converting int to string.\nBut I managed to solve this question without converting to string....woohoooo :D\nif you are thinking how -121 will be marked as false then the solution is really really simple, you just need a condition for that (number<0)."
                    },
                    {
                        "username": "MynameisTri-2004",
                        "content": "Hi. I am a newbie. What happened to my code ? Can you help me to fix this code ? thank you for reading this comment . \nBool isPalindrome(int x){\n  int x  ;   \nfor (x=0, x<10, x++) \n  if (\"x is palindrome\") { \n  printf (\"It is true\") ;\n  scanf (\"%d\", x) ; \n  return true ; \n  }\n}\nelse if (\"x is not a palindrome\") {\n  printf (\"it is not true\"); \n  scanf (\"%d\", x); \n  return false ; \n} \n"
                    }
                ]
            },
            {
                "id": 1978048,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1975173,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1974947,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1966197,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1960174,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1957078,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1956501,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1953797,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1947646,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1943413,
                "content": [
                    {
                        "username": "piyush_malviya22",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int rev = 0;\\n        int temp = x;\\n        while(x != 0){\\n            int d = x%10;\\n            rev = rev*10+d;\\n            x = x/10;\\n            if(rev >= 0){\\n            if(rev == temp){\\n                \\n                return true;\\n            }\\n            }\\n\\n    }\\n    return false;\\n}\\n}\\n\\nthis give wrong answer in case x=0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "class Solution {\\n    public static boolean isPalindrome(int x) {\\n    String str = String.valueOf(x);\\n    int left = 0;\\n    int right = str.length() - 1;\\n    while (left < right) {\\n      if (str.charAt(left) != str.charAt(right)) {\\n        return false;\\n      }\\n      left++;\\n      right--;\\n    }\\n\\n    return true;\\n  }\\n}"
                    },
                    {
                        "username": "SSelahattin",
                        "content": "Is there anyone solved this with 8ms runtime \\nI searched but couldn\\'t find\\nmy best try was 9ms "
                    },
                    {
                        "username": "mbedru",
                        "content": "6ms, 42.97mb\\n\\nif(x<0) return false;\\n\\n        char [] xString = String.valueOf(x).toCharArray();\\n        int a=0, b=xString.length-1;\\n        while(a!=b && a<b) {\\n            if(a==b) break;\\n            if(xString[a] != xString[b]) return false;\\n            a++; b--;"
                    },
                    {
                        "username": "piyush_malviya22",
                        "content": "my is also 9ms"
                    },
                    {
                        "username": "CamMcG",
                        "content": "I know this isn\\'t the most efficient way of coding this but I\\'m confused on why it\\'s wrong please may you reply if you understand my mistake as when i print palindromeChecker and x they both equal the same number for 121 but don\\'t equal eachother\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        convertedX = str(x)\\n        convertedXlen = len(convertedX)\\n        palindromeChecker = \"\"\\n        for i in range(convertedXlen):\\n            numberGrabber = convertedX[-i - 1]\\n            palindromeChecker += numberGrabber\\n        print(palindromeChecker)\\n        print(x)\\n        if palindromeChecker == x:\\n            return True\\n        else:\\n            return False\\n\\n\\n            "
                    },
                    {
                        "username": "Divvyesh",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        StringBuilder a = new StringBuilder(Integer.toString(x));\\n        if(a.equals(a.reverse())){\\n            return true;\\n        }\\n        else{\\n            return false; \\n        }\\n    }\\n}\\n\\nwhat is wrong with my code"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(x==s):\\n            return True\\n        else:\\n            return False\\nwhy is it showing wrong for x=121"
                    },
                    {
                        "username": "ASRISATWIK",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        xi=str(x)\\n        s=xi[::-1]\\n        if(s==x):\\n            print(\"True\")\\n        else:\\n            print(\"False\")\\n\\n  IT IS SHOWING ERROR\\n\\n\\nfor this code the \\nstdout is False\\n output is false\\n expected is true"
                    },
                    {
                        "username": "rahulthakurking2017",
                        "content": "Best Solution for C Language \\n\\nbool isPalindrome(int x){\\nint num=x,rem;\\nint sum=0;\\n    while(x>0){\\n        rem=x%10;\\n        sum=(sum*10)+rem;\\n        x/=10;\\n    }\\n    if(sum==num)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }"
                    },
                    {
                        "username": "Janani_2104",
                        "content": "what is the issue in my code.. i got a error in case 1?\\nbool isPalindrome(int x){\\n    int r,sum=0,temp;\\n    x=temp;\\n    while(x>0)\\n    {\\n        r=x%10;\\n        sum=(sum*10)+r;\\n        x=x/10;\\n    }\\n\\n     return sum;\\n}"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "Read the example 2: They are assuming the x value as a string and checking for pallin. x = -121. Reversing as a text will give you 121-  . Which is not equal to -121.  So just return false for all negative values of x"
                    },
                    {
                        "username": "amanthapliyal14",
                        "content": "Hey please explain why -121 is not palindrone when i reverse it i get -121 which is equal to that no"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "bro listen last digit of -121 is 1 and first digit of -121 is -1 . see here and compare the last digit and first digit of given number ,1 and -1 is equal ? ofcourse not .\\nhope you understand.\\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "adarsh_91",
                        "content": "because modular function does not work for negative number"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "no when you revers it you'll get 121-.  you have to treat it like string i wish you understand\n"
                    }
                ]
            },
            {
                "id": 1943029,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1942933,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1937206,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1936957,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1935873,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1934685,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1934140,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1930986,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1930402,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1925672,
                "content": [
                    {
                        "username": "rumi",
                        "content": "can someone do it without converting to string?\n"
                    },
                    {
                        "username": "abhishekmuhuri",
                        "content": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)return false;\n        int orig_x=x;\n        long long num=0;\n        while(x>0)\n        {\n            int r=x%10;\n            num*=10;\n            num+=r;\n            x=x/10;\n        }\n        return orig_x==num;\n    }\n};"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": " why he told me Time Limit Exceeded  "
                    },
                    {
                        "username": "adarsh_91",
                        "content": "so many codes i have seen one major change in brute force approach is make \\nfun==ans  && fun>=0 in if condition ur code will run\\n"
                    },
                    {
                        "username": "veers24774",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc=String.valueOf(x);\\n        StringBuffer cd= new StringBuffer(abc);\\n        return cd.reverse().toString()==abc;\\n    }\\n} why this is failing and always giving false\\n"
                    },
                    {
                        "username": "ankitcse2410",
                        "content": "The code you provided is close, but there\\'s a small issue. In Java, you should use the \\' .equals() \\' method to compare strings for equality, not the \\' == \\' operator. The \\' == \\' operator compares object references, not the actual contents of the strings. Here\\'s the corrected version of the code:\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        String abc = String.valueOf(x);\\n        StringBuffer cd = new StringBuffer(abc);\\n        return cd.reverse().toString().equals(abc);\\n    }\\n}\\n"
                    },
                    {
                        "username": "0901_muki",
                        "content": "#include <stdio.h>\\n#include <stdbool.h>\\n\\nbool isPalindrome(int x) {\\n    if (x < 0) {\\n        return false; // Negative numbers cannot be palindromes\\n    }\\n    \\n    int reversed = 0;\\n    int original = x;\\n    \\n    while (x > 0) {\\n        int remainder = x % 10;\\n        reversed = reversed * 10 + remainder;\\n        x /= 10;\\n    }\\n    \\n    return original == reversed;\\n}\\n\\nint main() {\\n    int x=121;\\n   \\n    \\n    bool result = isPalindrome(x);\\n    \\n    if (result) {\\n        printf(\"true\\\\n\");\\n    } else {\\n        printf(\"false\\\\n\");\\n    }\\n    \\n    return 0;\\n}\\n\\n\\nLine 37: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n     ^~~~\\n\\nwhy am getting this error?\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "I am unable to use void datatype method in this program, when I am using void rather than boolean type by default. In the terminal it is showing compile error because incompatible types: void cannot be converted to boolean [in __Driver__.java]"
                    },
                    {
                        "username": "Asabito",
                        "content": "how to solve it wihtout convert it to str?"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "Read the question carefully, here all the outputs are in numerical form, so there is no chance to using String datatype parameter or any String datatype variables to use, use simply integer datatype parameter. Add a \\'reverted number\\' variable and initialize it 0. Then solve it."
                    },
                    {
                        "username": "harmeet-io",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\nI am getting this everytime I am running any code here. \\nalso, when  I submit the code, it works by on running it shows me this. Can anyone help?"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "-2^31 = -2147483648\\n2^31 - 1 = 2147483647"
                    },
                    {
                        "username": "Mohammed_Asad",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        unsigned int reverse=0;\\n        int remainder;\\n        if(x<0){\\n            return false;\\n        }\\n        else{\\n        while(x!=0){\\n        remainder=x%10;\\n        reverse=reverse*10+remainder;\\n        x=x/10;\\n        }\\n        if(x==reverse){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n        }\\n    }\\n};\\n\\nwhy my code is always returning false?? "
                    }
                ]
            },
            {
                "id": 1922076,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1921431,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1920384,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1918185,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1918012,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1917667,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1914886,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1914166,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1906518,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1905849,
                "content": [
                    {
                        "username": "user2646kj",
                        "content": "class Solution {\\n     public static void main(String[] args) {\\n\\n        System.out.println(isPalindrome(10));\\n\\n\\n    }\\n    static boolean isPalindrome(int x)\\n   {\\n       int temp=x;\\n       int rev=0;\\n\\n       while(x>0)\\n       {\\n           int digit=x%10;\\n           rev=(rev*10)+digit;\\n           x=x/10;\\n       }\\n       if(rev==temp)\\n       {\\n           return true;\\n       }\\nreturn false;\\n\\n   }\\n}\\n"
                    },
                    {
                        "username": "saeed0home",
                        "content": "# Is palindrome\n\n\"\"\nclass Solution:\n    def isPalindrome(self, x):\n        x_ = str(x)\n        y = x_[::-1]\n\n        if y == x_:\n            print('true')\n        else:\n            print('false')\n\nSolution().isPalindrome(int(input()))\n\"\"\n\n\nSomebody tell me what is wrong in this code !"
                    },
                    {
                        "username": "nebula1776",
                        "content": "Well this prints true and false, isn't it supposed to ### return ### true and false?"
                    },
                    {
                        "username": "AnubhavDevnath",
                        "content": "y = x\\nrev = 0\\nr = 0\\nwhile x>0:\\n                rev = ((rev*10)+x%10)\\n                x = x//10\\nif rev == y:\\n                return True\\nelse:\\n                return False"
                    },
                    {
                        "username": "sharad907",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int n) {\\n        int rem, rev = 0;\\n        int temp = n;\\n        while (temp) {\\n            rem = temp % 10;\\n            rev = rev * 10 + rem;\\n            temp = temp / 10;\\n        }\\n        \\n        return rev == n;\\n    }\\n};\\nwhy mine not working  on negativw no how to make it work\\n"
                    },
                    {
                        "username": "Deep_down",
                        "content": "I think it is easy .\\nLet try to solve yourself.\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Piyapiku",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        int reverse =0;\\n        int originalX = x;\\n        while(x>0)\\n        {\\n            reverse = (reverse*10) + (x%10);\\n            x/=10;\\n        }\\n        if(reverse == originalX )\\n        {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\nwhat is the problem in this code\\nI am getting error in this // reverse = (reverse*10) + (x%10); \\ncan someone help me with this."
                    },
                    {
                        "username": "Abi0800",
                        "content": "what is the difference between these codes...(check out loops)\n\n\n\nbool isPalindrome(int x){\n    long long int i,j,z;\n    for(i=x;i>0;i/10){\n        j=i%10;\n        z=z*10+j;\n    }\n    if(x==z)\n        return true;\n    else\n        return false;\n\n}\n\nthis code says error\nOn other hand check these code\n\nbool isPalindrome(int x){\n    long long int i,j,k;\n    for(i=x;i>0;){\n        j=i%10;\n        k=k*10+j;\n        i=i/10;\n\n    }\n    if(x==k)\n        return true;\n    else\n        return false;\n\n}"
                    },
                    {
                        "username": "Rehan_khan_07",
                        "content": "   int ans = 0, sol = 0;\\n   \\n    int originalNumber = x;\\n    \\n    while (x != 0) {\\n        int digit = x % 10;\\n        if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            if(x<0){\\n                return false;\\n            }\\n        ans = (ans * 10) + digit;\\n        x /= 10;\\n    }\\n    \\n   \\n    \\n    if (originalNumber == ans) {\\n       return true;\\n    } else {\\n        return false;\\n    }\\n    \\n\\n}\\n    \\n};\\ni have solved this by broot force."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "Trying to solve it without converting, I need to figure out the number of digits in x"
                    },
                    {
                        "username": "foodmanhuffy",
                        "content": "why th is my code wrong?\\n\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            print(o)\\n            print(l)\\n            return(\"true\")\\n        else:\\n            print(o)\\n            print(l)\\n            return(\"false\")"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, your code is correct. However, you forgot to add the \"class\" and \"def\" keywords. Without these, LeetCode cannot check the test cases.\\n\\nThe corrected code would be (Btw. I removed the print functions):\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        l = list(str(x))\\n        o = list(str(x))\\n        o.reverse()\\n        if o == l:\\n            return True\\n        else:\\n            return False\\n\\n\\nPlease notice that this code is pretty slow. I highly recommend trying to solve this problem using the \"slice\" method.\\n\\nIf you have any questions, feel free to ask me anytime. :)"
                    }
                ]
            },
            {
                "id": 1905582,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1905413,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1904849,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1904023,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1903278,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1900327,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1897681,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1895626,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1888070,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1887277,
                "content": [
                    {
                        "username": "motl_c",
                        "content": "I am new to C++ and am having so trouble with this one. \n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        int r, revnum = 0 ;\n        const int n = x; \n        while( x > 0){\n            r = x%10; \n            x = x / 10;\n            revnum = (revnum * 10)+ r ; \n            return (revnum); \n\n        }\n        return x== revnum || x == revnum /10; \n    }\n};\n\n\nthis is my code so far and it works for 11500/11511 of the test cases. Was wondering if anyone knew why it is not work for 11 of the cases. an example of a case it doesn't work for is 123. Let me know if anyone has an idea. Thanks :) "
                    },
                    {
                        "username": "vigneshwa027",
                        "content": "i dont see a way to do without converting to string.. is thr any?\\n"
                    },
                    {
                        "username": "aasthajain7078",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n      if(x < 0){\\n}\\n\\n        int reverse = 0;\\n        int num=x;\\n\\n\\n        while(x > 0){\\n            reverse = reverse*10 + x%10;\\n            x = x/10;\\n        }\\n\\n        if(reverse == num)\\n          return true;\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "Pooriya740",
                        "content": "My code is working correctly when i run it in my console (with same test cases and other tests), but here it shows wrong output. why?? "
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, could u please share your code? "
                    },
                    {
                        "username": "sammeshach023",
                        "content": "x = input()\\ny = x[::-1]\\nif x == y:\\n    print(\"true\")\\nelse:\\n    print(\"false\")\\n\\n CAN ANYONE FIND THE ERROR??"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, you understood the problem at its core. However, there are some issues in your code.\n1. The variable `x` doesn't need to be explicitly defined since you are using a \"def\" method. Platforms like LeetCode automatically assign a value to `x` when testing your code.\n\n2. In this case, slicing `x` and assigning it to `y` causes unnecessary trouble and conflicts with your code (as mentioned in point 3).\n\n3.Because x is not an input (string), you have to define x as a string. In your example str(x). Make always sure to convert an int. into a string, if u want to slice it.  (You can't slice integers, because they are not sequences.)\n\n4. Using the `print` function is fine, but for long-term use (especially in advanced tasks), using the `return` statement is preferred. Instead of using `print(\"true\")`, you can simply use `return True`, or `return False`.\n\nIf you have any questions, feel free to ask me anytime. Moreover, if you would like the solution, I can provide mine. Have a nice day and good luck on your coding adventure!\n\n"
                    },
                    {
                        "username": "hamzakhan_15",
                        "content": "Can any one tell why it is showing runtime error\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int rem;\\n        int v=x;\\n        while(v!=0)\\n        {   \\n            rem=v%10;\\n            rev= (rev*10) + rem;\\n            v/10;\\n        }\\n        if(v==x)\\n            return(true);\\n        else\\n            return(false);\\n\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "NSAIBALAJI",
                        "content": "when im testing same code in pycharm im getting correct answer but when im testing here its showing wrong answer and this is the code i written\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x=str(x)\\n        if(x[::-1]==x):\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\nobj=Solution()\\nobj.isPalindrome(int(input()))\\nanyone reply why its showing a mistake"
                    },
                    {
                        "username": "Maruuuko",
                        "content": "Hey, just write: \\nx_str = str(x)\\nreturn x_str == x_str[::-1]\\n\\nThe problem is, that you print true, if the condition is true and the same thing for false. This can lead to missunderstandings and errors in future. Because there are plenty of missunderstandings of the difference between return and print, wich are 2 completely different things, I highly recommend the awnser of \"Thavas Antonio\" ( https://stackoverflow.com/questions/67941485/python-why-do-we-use-boolean-values-in-functions-to-return-print-statement-in-o ).\\nHave a nice day and good luck!\\n"
                    },
                    {
                        "username": "mechatron2022",
                        "content": "This testing guys are reversing sign also\\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02(121-) which is never happen. How could you reverse a sign of a number in maths."
                    },
                    {
                        "username": "sunjidarahmanmysha",
                        "content": "why is showing compile error for this code?what is wrong\\n\\n#include <iostream>\\nusing namespace std;\\n\\nvoid isPalindrome(int x) {\\n    if (x < 0) {\\n        cout << \"false\" << endl;\\n    } else {\\n        int original = x;\\n        int reversed = 0;\\n        while (x > 0) {\\n            int digit = x % 10;\\n            reversed = reversed * 10 + digit;\\n            x /= 10;\\n        }\\n        if (original == reversed) {\\n            cout << \"true\" << endl;\\n        } else {\\n            cout << \"false\" << endl;\\n        }\\n    }\\n}\\n\\nint main() {\\n     int x;\\n    cin>>x;\\n    isPalindrome(x);\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "himanshugola1111",
                        "content": "just use modulo operator to reverse a number and for negetive numbers use if(x < 0){\\n        return false;\\n    }\\nbecause negetive numbers never equals to their palindrome"
                    }
                ]
            },
            {
                "id": 1887272,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1880246,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1878994,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1876627,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1872250,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1869646,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1865403,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1863442,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1861099,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1860789,
                "content": [
                    {
                        "username": "samarofficial65",
                        "content": "just take input as a number and for negetive which is not equals to its palindrome write if (x<0){return false}"
                    },
                    {
                        "username": "ivanpadeliya",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n\\nWhat is the problem with this code why is it showing error in the test case 1 while 2,3 are passed and even if i run this code in the python application it does not show wrong answer while it does in leetcode"
                    },
                    {
                        "username": "amaturecoder18",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int num,n =x;\\n        float  sum=0;\\n        \\n        while(n!=0)\\n        {\\n                        num = n%10;\\n                        sum = sum*10+num;\\n                        n=n/10;\\n                    \\n            \\n        }\\n        \\n        if(sum == x)\\n        {\\n            return true;\\n        }\\n        else if( x<0)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n       \\n        \\n    }\\n};\\n\\nCan someone tell me what\\'s wrong with this code? I\\'m facing problem with testcase 2 where the answer for -121 should be false, but I\\'m getting true ."
                    },
                    {
                        "username": "user5835xp",
                        "content": "in every case it gives false result what\\'s wrong with this code\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int y = 0;\\n        while(x != 0){\\n\\n           y = y*10 + x%10;\\n           x = x/10;\\n        }\\n        if(y == x)\\n         return true;\\n        \\n        else\\n        return false;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "younusalinahid",
                        "content": "testing "
                    },
                    {
                        "username": "WajahatFarooq",
                        "content": "Hello, A little suggestion would be appreciated!\\nI have written the code and it\\'s running successfully but I\\'m getting \"wrong answer\"  with a Run time: 0ms. So Let me explain my problem, When I give -121 to x then it shows green dot on both case 2 and 3 and red dot on case 1 but when i remove it, it shows green dot on case 1 but red dot on both case 2 and 3. It\\'s kinda complicated lol"
                    },
                    {
                        "username": "harshitg141975",
                        "content": "bool checkPalindrome(char str[]) {\\n    // Write your code here\\n     int  count = 0 ; \\n\\n    for (int  i = 0 ; str[i] != \\'\\\\0\\' ; i++)\\n    {\\n        count = count + 1  ; \\n    }\\n\\n    for ( int i = 0 ,  j = count - 1  ;  i <= j  ; i++ , j-- )\\n    {\\n        if ( str[i] != str[j] )\\n        {\\n              return false ;\\n        }\\n        else\\n        {\\n\\n        }\\n    }\\n     return true ; \\n}"
                    },
                    {
                        "username": "DevilGuru",
                        "content": "Tooooooooooooo Easy\\n\\nclass Solution {\\n\\n    \\n    public boolean isPalindrome(int x) {\\nint rem = 0;\\n        if( x<0){\\n            return false;\\n        }\\n\\n        if(x==0){\\n            return true;\\n        }\\n        int temp = x;\\n        while(x!=0){\\n\\n\\n          rem = rem* 10 + x%10;\\n          x /= 10;\\n           \\n        }\\n\\n        if(rem == temp){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n\\n          \\n        \\n    }\\n}"
                    },
                    {
                        "username": "Joshua0711",
                        "content": "I would like to know if the number is an even digit like 1221 is it a palindrome?"
                    },
                    {
                        "username": "potatoGuy",
                        "content": "Best way how to solved  this problem\\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\nif(x<0||x==10){\\n    return false;\\n}return true;\\n}\\n}   \\n \\n\\n"
                    }
                ]
            },
            {
                "id": 1857630,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1856775,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1853214,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1852840,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1846138,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1846137,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1846136,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1844382,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1843462,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1841640,
                "content": [
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        x = str(x)\\n        s = \\'\\'\\n        for i in range(len(x) - 1, -1, -1):\\n            s += x[i]\\n        if s == x:\\n            return True\\n        else:\\n            return False\\n```\\nEasy way \\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "albertshorov",
                        "content": "can someone help me? why i get this Runtime Error?\\n\\nUnhandled exception. System.FormatException: Input string was not in a correct format.\\nAt System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)\\nAt Solution.IsPalindrome(Int32 x)\\nAt __Driver__.Main(String[] args)\\n\\nin VS all working without any problems. My code:\\npublic class Solution\\n{\\n    public bool IsPalindrome(int x)\\n    {\\n        string array = int.Parse(x.ToString()).ToString();\\n        int[] firstArray = new int[array.Length];\\n        int[] secondArray = new int[array.Length];\\n        string firstString;\\n        string secondString;\\n        for (int i = 0; i < array.Length; i++)\\n        {\\n            firstArray[i] = int.Parse(array[i].ToString());\\n        }\\n        for (int i = array.Length - 1; i >= 0; i--)\\n        {\\n            secondArray[array.Length - 1 - i] = int.Parse(array[i].ToString());\\n        }\\n        return(string.Join(\"\", firstArray) == string.Join(\"\", secondArray));\\n    }\\n}"
                    },
                    {
                        "username": "miha4406",
                        "content": "Array.Reverse() is not working?"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "**Note for passersby:**\\n\\nif implementing this in a language that would keep the fractional part of num after division (looser typing), you\\'ll need to make that `num = floor(num / 10).`"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "use long long for reversed number"
                    },
                    {
                        "username": "tarikulislamriko910",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int c=x ,remainder;\\n        long long  rev=0;\\n        if(x<0)\\n        return false;\\n        while(x>0)\\n        {\\n        remainder=x%10;\\n        rev=rev*10+remainder;\\n        x=x/10;\\n        }\\n        if(c!=rev)\\n        return false;\\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "ankush920",
                        "content": "quick read comment code with optimized approach\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking last half ==first half\\n\\nApproach\\nreverse last half and compare with first half\\n\\nComplexity\\nTime complexity:\\n0(n)\\n\\nSpace complexity:\\n0(n)\\n\\nCode\\n//find useful upvote it vro :)\\n\\n//we can do full reverse but for that we need to take rev -->double type  but  is so, simple \\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0||x%10==0 & x!=0) //negative is always not palindrome and 10 mutliple is edge case for this approach \\n        {\\n             return false;\\n        }\\n        if(x==0)\\n        {\\n             return true;\\n        }\\nint rev =0;\\n\\n        while( x>rev)\\n        {\\n     rev = rev*10+x%10;\\n             \\n             x=x/10;\\n      \\n        }\\n        if( x==rev||(rev/10==x) )   // rev/10==x because if odd digit no. exist\\n             {\\n                  return true ;\\n             }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "user5940qQ",
                        "content": "\nHello,  what the hell is wrong with these code? I've been looking at it for hours.\n\n\nclass Solution {\npublic:\n    bool isPalindrome(int x){\n      int base = x;\n      \n\n      \n      if(x<0){\n        return false;\n      }\n  \n      int number = 0;\n\n      while(x>0){\n        number = number * 10 + (x%10);\n        x=x/10;\n      }\n      if(base==number){\n        return true;\n      } else {\n        return false;\n      }\n            \n}\n        \n    \n        \n};\n"
                    },
                    {
                        "username": "teddu_lokesh18",
                        "content": "bro can anyone tell me what\\'s the use of (self, parameter ) in these problem?"
                    },
                    {
                        "username": "abdealidiwan",
                        "content": " `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if x >= 0:\\n            y = str(x)\\n            reversed(y)\\n            if x in reversed(y) == x:\\n                return True\\n        else:\\n            return False`\\n\\nThe follow code is working for all cases other than 121. Please help me understand why"
                    }
                ]
            },
            {
                "id": 1826383,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825934,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1823284,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1816438,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1813478,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1810922,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1807668,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1807169,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806824,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1806823,
                "content": [
                    {
                        "username": "GoldenMode",
                        "content": "Can you help please!\\nThe code written in Visual Studio Code writes \"true\", and the verified code here writes \"false\" and complains about the number \"11\"\\nWhat could be the problem?\\nI published a post in solutions called \"Can you help please? GoldenMode\""
                    },
                    {
                        "username": "AsmitaMutgekar",
                        "content": "Below is my code for Palindrome\nwhen input is 0 it says false but as per code it should be true\n\npublic boolean isPalindrome(int x) {\n        int n=x;\n        int sum=0; \n        if(x<0 || x%10==0 )\n            return false;\n        while (n>0) {\n        sum=sum *10 + (n%10);\n         n=n/10;   \n        }\n        return x==sum; //  when x=0 it should directly come here which means true since sum=0 and x=0 but the result says false\n    }"
                    },
                    {
                        "username": "kumarryogeshh",
                        "content": "Using Typescript\\n `return x.toString() === x.toString().split(\\'\\').reverse().join(\\'\\')`"
                    },
                    {
                        "username": "Ganesh_Reddy_G",
                        "content": "My code is working fine in local but not here\\n\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        x = str(x)\\n        y = x[::-1]\\n\\n        try:\\n            if int(x) == int(y):\\n                return \"true\"\\n            else:\\n                return \"fasle\"\\n        except ValueError as v:\\n            return \"false\""
                    },
                    {
                        "username": "shubh_214",
                        "content": "This is my code but it is not working why...?\\n\\nimport java.util.Scanner;\\nclass Solution {\\n    static boolean isPal(int n){\\n        int sum=0, d, temp=n;\\n        while(n>0){\\n            d=n%10;\\n            sum=sum*10+d;\\n            n=n/10;\\n        }\\n        return sum==temp;\\n    }\\n   public static void main(String args[]){\\n       Scanner sc = new Scanner(System.in);\\n       int n=sc.nextInt();\\n       boolean p = isPal(n);\\n       System.out.println(p);\\n   }\\n}\\n\\nShowing that error only :-\\nLine 7: error: cannot find symbol [in __Driver__.java]\\n      boolean ret = new Solution().isPalindrome(param_1);\\n                                  ^\\n  symbol:   method isPalindrome(int)\\n  location: class Solution"
                    },
                    {
                        "username": "ajayshetty",
                        "content": "Is there anything wrong in the below code. I am getting test cases failed.\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        num = x;\\n        if num < 0:\\n            print(\\'negative\\');\\n            \\n        else :\\n            print(\\'positive\\');\\n            num = str(num);\\n            print(num);\\n            print(num[::-1]);\\n            if num == num[::-1]:\\n                print(num);\\n                return \\'true\\';\\n            \\n        return \\'false\\';"
                    },
                    {
                        "username": "IAmJuniorB",
                        "content": "My code doesn\\'t pass the first test, why?\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        if str(x) == str(x)[::-1]:\\n            print(\"true\")\\n        else:\\n            print(\"false\")\\n"
                    },
                    {
                        "username": "AchintyaShende",
                        "content": "What is wrong whit this code...\\nERROR IS :\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp=x;\\n        int rev=0;\\n        if(x<0)\\n        {\\n            return false;\\n        }\\n        while(x>0)\\n        {\\n            \\n            rev=rev*10+x%10;\\n            x/=10;\\n        }\\n        if(temp==rev)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        \\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "shyam_pandey",
                        "content": "class Solution {\\n    \\n    int reverse(int x){\\n        long long int temp = 0;\\n        int d = 0;\\n\\n        while(x!=0){\\n            d = x%10;\\n            temp = temp*10 + d;\\n            x = x/10;\\n        }\\n        return temp;\\n    }\\n\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0) return 0;\\n\\n        else{\\n\\n            long long int check = reverse(x);\\n\\n            if(check-x ==0 ) return 1;\\n\\n            else return 0;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1805990,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1805091,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1801030,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1800344,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1799247,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1796467,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1795623,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1794129,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1793838,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1793608,
                "content": [
                    {
                        "username": "raghavbakshee",
                        "content": "Getting exception - WHY??\n\njava.lang.NumberFormatException: For input string: \"\"\n \nSmall part of Code Snippet - \n..\n..\n..\nString answer = \"\";\n        while(temp != 0){\n            res = res * 10 + temp % 10;\n            answer = answer + temp % 10;\n            temp = temp / 10;\n        }\n        if(res > Integer.MAX_VALUE || res < Integer.MIN_VALUE) return false;\n        if(Integer.parseInt(answer) == x) return true;\n        return false;"
                    },
                    {
                        "username": "2k20csbs22",
                        "content": " `JAVA CODE\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int sum=0,r,n;\\n        n =x;\\n        while(n>0){\\n            r = n%10;\\n            sum = (sum*10)+r;\\n            n = n/10;\\n        }\\n        if(x==sum)\\n            return true;\\n        else\\n            return false;\\n    }\\n}`"
                    },
                    {
                        "username": "rishabhdevbandhudas",
                        "content": "without converting into string ,, see my solution"
                    },
                    {
                        "username": "SouvikDas2002",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int rev=0;\\n        int n=x;\\n        int ld;\\n\\n        if(x<0)\\n        return false;\\n\\n        while(x>0){\\n            ld=x%10;\\n            rev=rev*10+ld;\\n            x=x/10;\\n        }\\n        if(rev==n){\\n            return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\nwhy this code give me this type error?\\n\\nLine 13: Char 20: runtime error: signed integer overflow: 998765432 * 10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:22:20"
                    },
                    {
                        "username": "Casual_0101",
                        "content": "\\u30B3\\u30FC\\u30C9\\u826F\\u3044\\n"
                    },
                    {
                        "username": "samadhan_03",
                        "content": "Line 19: Char 5: error: non-void function does not return a value [-Werror,-Wreturn-type]\\n    }\\n    ^\\n1 error generated.\\n\\n\\nmy solution is correct but its shows the error\\n\\n"
                    },
                    {
                        "username": "aravindnethi1632",
                        "content": "Hey Everyone,\\n\\nI have used below code 11509/11510 testcase passed only one test case not passed can anyone please check it.\\n\\n`` strr=str(x)\\n  if (strr==strr[::-1]):\\n            return x\\n`` "
                    },
                    {
                        "username": "taiyaljitin",
                        "content": "can anyone tell me why is this error showing when i run\\n\\nlong long int rev = 0;\\n\\n..........\\n\\nrev = (10*rev) +rem;\\n\\n\\nError\\n\\nLine 9: Char 19: runtime error: signed integer overflow: 10 * 1210000000000000000 cannot be represented in type \\'long long\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:19"
                    },
                    {
                        "username": "Captainslate01",
                        "content": "My while loop is not exiting??\\na=0\\n        b=x\\n        z=1\\n        while b!=0:\\n            m=b%10\\n            a=a*10+m\\n            b=b//10\\n            print(b)"
                    },
                    {
                        "username": "Chernikc1",
                        "content": "lol my solution. Bad in test 11509 when i take error that 0 true but how??) If x > 0  it is false\\npublic bool IsPalindrome(int x) {\\n        if (x > 0)\\n        {\\n            int num = x;\\n            int rev = 0;\\n            while (x >= 1)\\n            {\\n                int r = x % 10;\\n                rev = rev * 10 + r;\\n                x = x / 10;\\n            }\\n\\n            if(num == rev)\\n            {\\n                return true;\\n            } \\n            return false;\\n        } \\n        return false;\\n    }\\n"
                    }
                ]
            },
            {
                "id": 1790282,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1787932,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1787910,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1786888,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1786082,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1782337,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1782218,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1777916,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1777829,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1774484,
                "content": [
                    {
                        "username": "Evil_123",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n       string s=to_string(x);\\n       int n=s.size();\\n       for(int i=0;i<(n/2);i++){\\n           if(s[i]!=s[n-(i+1)]){\\n              return false;\\n           }\\n       }\\n       return true;\\n    }\\n};"
                    },
                    {
                        "username": "kawsarlog",
                        "content": "This is my solution hope it is easy enough!\\n\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        y = str(x)\\n        return str(x) == y[::-1]"
                    },
                    {
                        "username": "Vee__",
                        "content": "Solution in C++  \\n\\n`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n\\n        string z = to_string(x);\\n        string y = to_string(x);\\n        reverse(y.begin(), y.end());\\n\\n        if(z == y){\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};`"
                    },
                    {
                        "username": "arpit1910",
                        "content": "\\ndoes any one suggest what wrong with this code\\nit gives error. on input = 121 \\n\\n\\n `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num=0;\\n        while(x>0){\\n            int digit = x%10;\\n\\n            num = num*10+digit;\\n\\n            x = x/10;\\n        }\\n        if(num == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n`\\n"
                    },
                    {
                        "username": "gelehasan",
                        "content": "Easy solution using javascript\\n\\nvar isPalindrome = function(x) {\\n   let palindrom=\"\";\\n  let xString= x.toString();\\n\\n    for(let i=xString.length-1; i>=0; i--){\\n        // console.log(xString[i])\\n        palindrom +=xString[i];\\n    }\\n  \\n    if(palindrom === xString ){\\n        return true\\n    }else{\\n       return false\\n    }\\n    \\n    \\n    \\n    \\n    \\n};"
                    },
                    {
                        "username": "dilipkumar8117",
                        "content": "JAVA SOLUTION\\n\\npublic boolean isPalindrome(int x) {\\n        String s=Integer.toString(x);\\n        String res=\"\";\\n//reverse the string\\n        for(int i=s.length()-1;i>=0;i--){\\n            res=res+s.charAt(i);\\n        }\\n\\n        if(s.equals(res)){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "nikhilgaba03",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        cin>>x;\\n        int m = 0;\\n        int dup =x;\\n        while(x!=0){\\n            int digit = x%10;\\n            m = (m*10)+digit;\\n            x = x/10;\\n        }\\n        if(dup==m){\\n            return 1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n\\nIt is throwing run time error, kindly look into it what could be the reason for this"
                    },
                    {
                        "username": "Pan2125",
                        "content": "why this code is not working for input number 11??\\n\\nvar isPalindrome = function(x) {\\n    if(x<0 ||(x%10===0 && x!==0)){\\n        return false\\n    }\\n\\n    let reverseNum=0\\n    while(x=>reverseNum){\\n        reverseNum=reverseNum*10+x%10\\n        x=x/10\\n    }\\n\\n    return x===reverseNum || x===reverseNum/10\\n\\n};"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "i don\\'t know. i have done code in php. for example:- input 11 or 121 is not working for the code. please tell me what i have done wrong.\\n"
                    },
                    {
                        "username": "benipalmanpreet1207",
                        "content": "# for the first case, my prgram is not working. so please help me . what i have done wrong.\\nclass Solution {\\n    function isPalindrome($x) {\\n        $reverse=0;\\n        $temp=$x;\\n        while($temp>0){\\n            $reminder=$temp%10;\\n            $reverse=$reverse*10+$reminder;\\n            $temp=$temp/10;\\n        }\\n        return $reverse==$x;\\n    }\\n}"
                    },
                    {
                        "username": "Pan2125",
                        "content": "u should change the reminder to reminder=temp%10....\\notherwise your solution will add temp to reminder"
                    },
                    {
                        "username": "tushargola958",
                        "content": "test case 1 is showing error please help \\n\\n\\n\\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        \\n        int rem = 0 ;\\n        while(x>0 ){\\n            rem = rem*10 + x%10;\\n           x = x/10;\\n}\\n        if(rem==x){\\nreturn true;\\n        }\\n        else{\\n           return false;\\n        }\\n    }\\n}\\n\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1773686,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1773559,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1773051,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1771021,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1766431,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1765823,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1765325,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1762242,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1759812,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1759091,
                "content": [
                    {
                        "username": "alimjanovf",
                        "content": "I have solved this problem without converting integer to string \\n`public bool IsPalindrome(int x) {\\n        var q = 0;\\n        var t = x;\\n        \\n        while (x!=0)\\n        {\\n            var s = 10;\\n            q = q * s + x % s;\\n            x /= s;\\n\\n            if( q == t && q >=0 )\\n                return true;\\n        }\\n        return q == 0 ? true : false ;     \\n    }.`"
                    },
                    {
                        "username": "MadanBaduwal",
                        "content": "I used the string reverse function to check the palindrome.\\nHere is the code\\n `class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        rv_string = str(x)[::-1]\\n        if str(x) == rv_string:\\n            return True\\n        else:\\n            return False`"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Steps:\\n1. negative numbers are not palindrome\\n2. calculate reverse of the number and compare with the original number\\n\\ncalculate reverse of a number:\\n```py\\nreverse(a):\\n     rev = 0\\n     while a != 0:\\n          rev = (rev*10) + (a%10)\\n          a = a/10\\n     return rev\\n```"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "The time complexity can be reduced to O(N) to O(N/2) by only reversing the half number from the LSB and compare it its half from the MSB."
                    },
                    {
                        "username": "xsukhmeet",
                        "content": "String a=Integer.toString(x);\\n        String b=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            b+=a.charAt(i)+\"\";\\n        }\\n        if(a==b){\\n            return true;\\n        }\\n        return false\\n\\n\\nI have written this my 2 test cases are passing but first test case not passed.Anyone knowing what is the problem with this please respond."
                    },
                    {
                        "username": "TMuhammadqodir",
                        "content": "class Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        return str(x)==str(x)[::-1]"
                    },
                    {
                        "username": "kingctan",
                        "content": "My solution in Java without using string reverse, to integer array or any other push and pop stack trick. A bit long maybe someone can make it shorter.\n    public static boolean isPalindrome(int x) {\n          if (x < 0) return false;\n          if (x < 10) return true;\n          if (x % 10 == 0) return false;\n          int num = x;\n          int num2 = x;\n          int length = 0;\n    //find the length/size of the input integer.     \n       while (true) {\n              length++;\n              int quotient = num / 10;\n              if (quotient == 0) break;\n              num = quotient;\n           }\n\n        double pow = 0;\n       //Loop through the length of the integer and multiply each remain to the power of 10 * count of length.\n      //sum them up with double type instead of integer because if int x = 2147483647 when it's flipped to 7463847412 which is too big for integer\n        while (length > 0) {\n              int i = x % 10;\n              pow = pow + Math.pow(10, length - 1) * i;\n              int rem = x / 10;\n              if (rem == 0) break;\n              x = rem;\n              length--;\n        }\n          return num2 * 1.0 == pow;\n    }"
                    },
                    {
                        "username": "quangkelvin",
                        "content": "\\'class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)return false;\\n        else{\\n            char [] numberArr = String.valueOf(x).toCharArray();\\n            int lastIndex=numberArr.length-1;\\n            int i=0;\\n\\n            while (lastIndex - i >= 0) {\\n                if(numberArr[i]==numberArr[lastIndex]){\\n                    i++;\\n                    lastIndex--;\\n                }else{\\n                    return false;\\n                }\\n            }\\n\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\'"
                    },
                    {
                        "username": "goyalishika132",
                        "content": "else\\n        {  \\n        while(no>0)\\n        {\\n            int temp=x;\\n            rem=temp%10;\\n            no=temp/10;\\n            val= val*10+ rem;\\n        }\\n        if(val==x)\\n          return true;\\n        else\\n            return false; \\n        }\\n\\ncan someone help me out, I am not getting favorable output from this part"
                    },
                    {
                        "username": "tisaconundrum",
                        "content": "I bet there is a really easy bit manipulation that could pull this off, but I\\'m not smart enough to think through how that could work. \\uD83D\\uDE02"
                    },
                    {
                        "username": "Aspirant_coder",
                        "content": "can someone explain me why I am getting reached end of file error in this code.\\n\\nclass Solution {\\n     public static int helper(int si,int ei,int[]arr){\\n        if(si>=ei){\\n            return 1;\\n        }\\n        if(si!= ei){\\n            return 0;\\n        }\\n        return isPalindrome(si+1,ei-1,arr);\\n        \\n    }\\n    public boolean isPalindrome(int num) {\\n        String str = (new Integer(number)).toString();\\n    char[] chArr = str.toCharArray();\\n    int[] arr = new int[chArr.length];\\n    for (int i = 0; i< chArr.length; i++) {\\n        arr[i] = Character.getNumericValue(chArr[i]);\\n    }\\n        return helper(0,arr.length-1,arr);\\n}"
                    }
                ]
            },
            {
                "id": 1758894,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1758602,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753201,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1749355,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1746135,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743546,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743465,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1743067,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1740130,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1740069,
                "content": [
                    {
                        "username": "lucky_jain",
                        "content": "I am able to get the correct ans in other idle but not here "
                    },
                    {
                        "username": "mohiuddinr22",
                        "content": "why does none of the solutions work for 1001???"
                    },
                    {
                        "username": "tarif_zaman_",
                        "content": "Its running but why its not accepting what problem in line 7?\\n\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    int n = 0;\\n    int a = x;\\n    while(x > 0) {\\n    n = n * 10 + x%10;\\n    x /= 10;\\n    }\\n    if(n==a){\\n        return true;\\n    }\\n    return false;\\n    }\\n};"
                    },
                    {
                        "username": "sivarajraja",
                        "content": "if a single digit number would be a palindrome"
                    },
                    {
                        "username": "savy07",
                        "content": "var isPalindrome = function(x) {\\n    let s=x.toString().split(\"\");\\n    let ispalindrom=true;\\n  for(let i=0;i<s.length/2;i++){\\n     if(s[i]!== s[s.length-i-1]){\\n       ispalindrom= false;\\n     }\\n  }\\n  return ispalindrom;\\n};\\n"
                    },
                    {
                        "username": "hemang-h",
                        "content": "I am trying to solve this question, and this is my code: \\n ```class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0 || (x%10==0 && x != 0 ) ){\\n            return false;            \\n        }\\n        else {\\n            int reverseNum = 0;\\n            while ( x > 0) {\\n                reverseNum = reverseNum * 10 +  x % 10;\\n                x /= 10;\\n            }\\n            if ( x == reverseNum ) return true;\\n            else return false;\\n        }\\n    }\\n}; \\n```\\nOn running this, My testcase is failing for the value \\'121\\' and I don\\'t get it why? Can anyone help me out here? "
                    },
                    {
                        "username": "stack-prince",
                        "content": "Easy To understand : \\n\\nLanguage Python03\\n\\nCode :\\nclass Solution:\\n    def isPalindrome(self, x: int) -> bool:\\n        \\n        sum = 0\\n        temp = 0\\n        count = 1\\n        ov = x\\n        if (x < 0) or (x != 0 and x% 10 == 0)  : \\n            return False\\n        while (x != 0):\\n            rem = x % 10\\n            sum = sum*10 + rem\\n            x = x // 10\\n        if sum == ov:\\n            return True\\n        else :\\n            return False"
                    },
                    {
                        "username": "damivx",
                        "content": "can someone tell me what is wrong with this code please\\nbool isPalindrome(int x){\\n    int reverse = 0, reminder;\\n    if (x < 0 || (x % 10 == 0 && x!=0) )\\n    {\\n        return false;\\n    }     \\n    while(x!=0)\\n    {\\n        reminder = x % 10;\\n        reverse = reverse * 10 + reminder;\\n        x/=10;\\n    }\\n    if(x == reverse){\\n     return true;\\n     }\\n    else \\n    return false;\\n\\n}\\nit seems to not run for the most basic palindrome case (121) but is correct for the other two case could someone point out if there is a mistake I am making here."
                    },
                    {
                        "username": "zohaib53hassan",
                        "content": "A Simple Solution for all Palindrome problems\\n\\ndef isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        return str(x)[::-1]==str(x)"
                    },
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1740068,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1738472,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1738384,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1737817,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1736747,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1734865,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1734502,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1734196,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1732677,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1731470,
                "content": [
                    {
                        "username": "rajkumr",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int store=x;\\n        long int sum=0;\\n        \\n        while(store>0){\\n            int r=store%10;\\n            sum=sum*10+r;\\n            store=store/10;\\n        }\\n        if(sum == x) {\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "mohdakram_30",
                        "content": "int ans=0;\\n        while(x!=0){\\n           \\n            int digit = x%10;\\n            ans= (ans*10) + digit;\\n            x=x/10;\\n             if((ans>INT_MAX/10)||(ans<INT_MIN/10))\\n            return false;\\n            if(ans==x)\\n            return true;\\n        }\\n        return false; \\ncan someone tell me what is wrong in this "
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\n\\nhttps://leetcode.com/problems/palindrome-number/solutions/2976350/simple-java-beats-98-easy-to-understand/"
                    },
                    {
                        "username": "abdoulkarim",
                        "content": "\\nreturn str(x) == str(x)[::-1]"
                    },
                    {
                        "username": "Prasanta_123",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        if(x<0)\\n        return false;\\n\\n        int rev=0;\\n        int n=x;\\n        while(n>0){\\n            rev=rev*10+n%10;\\n            n=n/10;\\n        }\\n        if(rev==x)\\n        return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "ghemanth2303",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n    \\n    if (x<0)\\n    return false;\\n       int d=0;\\n       while(x>0){\\n           d=x%10+d*10;\\n           x=x/10;\\n       }\\n           if(x==d)\\n           return true;\\n           else\\n           return false;\\n           \\n\\n       }\\n    \\n};\\n\\n// what is mistake in that\\n"
                    },
                    {
                        "username": "sakausha11",
                        "content": "u are comparing wrong values in the if condition. Because x will always become 0. store the value of x in another variable and then compare it with d"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        if(x<0)\\n        return false;\\n        if(x==0)\\n        return true;\\n        if(x>=1&&x<10)\\n         return true;\\n         int rev=0;\\n         int tmp=x;\\n         while(tmp!=0)\\n        {\\n            int ld= tmp%10;\\n            rev= rev*10+ld;\\n            tmp/=10;\\n        }\\n        if(tmp==rev)\\n        return true;\\n        \\n        else\\n        return false;\\n    }\\n};\\n\\n\\nwhy this code is wrong?"
                    },
                    {
                        "username": "sakausha11",
                        "content": "Hey,\nin the 4th last line, i.e,  the if condition u are comparing wrong values. Change it to (x ==rev).\nAlso Change the datatype of rev to long instead of int... it will work then."
                    },
                    {
                        "username": "hemanth_asp",
                        "content": "bool isPalindrome(int x){\\n    int a=x;\\nint rev=0;\\nint lastdigi=0;\\nwhile(x>0)\\n{\\n    lastdigi=x%10;\\n    rev=rev*10+lastdigi;\\n    x=x/10;\\n}\\n\\n\\nif(a==rev && rev>0){\\n printf(\"true\");\\n}\\nelse{ printf(\"false\");\\n}\\nreturn 0;\\n}\\n\\n\\n\\nwhy the test case is being failed please check it and give an idea"
                    },
                    {
                        "username": "sakausha11",
                        "content": "can anybody tell why this approach isn\\'t working ? \\n\\npublic:\\n    long rev=0; \\n    bool isPalindrome(int x) {\\n        static int t = x;\\n        if(x<=0){\\n            if(rev==t) return 1;\\n            else return 0;\\n        }\\n        rev = rev*10 + x%10;\\n        x /= 10;\\n        return isPalindrome(x);\\n    }\\n}; "
                    },
                    {
                        "username": "ec1912",
                        "content": "`class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        long int revNum = 0;\\n        long int Num = x;\\n\\n        while (Num > 0) {\\n\\n            long int LDigit = Num % 10;\\n            revNum = revNum * 10 + LDigit;\\n            Num = Num / 10;\\n        }\\n\\n        if (x == revNum) {\\n            return true;\\n        } else {\\n            return false;\\n        } \\n    }\\n}; `"
                    }
                ]
            },
            {
                "id": 1730757,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1730630,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1728385,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1725481,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1722491,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1720340,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1719178,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1718138,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1717769,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1717444,
                "content": [
                    {
                        "username": "danilodejesusgomes",
                        "content": "This one test said me is wrong.\\nInput: -1\\nOutput: true\\nExpected: false\\n\\nBut this test said is correct.\\nInput: 0\\nOutput: true\\nExpected: true\\n\\nWhat is the difference between them?\\nWhen we have just one digit, it should be correct."
                    },
                    {
                        "username": "Raja_Sharma",
                        "content": "palindrome no.\\n\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n        int temp = x;\\n        int rev = 0, rem;\\n        while(temp != 0){\\n            rem = temp % 10;\\n            rev = rev*10+rem;\\n            temp = temp/10;\\n        }\\n        if(x != rev){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public static void main(String args[]){\\n        int x = 121;\\n        System.out.println(isPalindrome(x));\\n        x = -121;\\n        System.out.println(isPalindrome(x));\\n        x = 10;\\n        System.out.println(isPalindrome(x));\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "My Simple output in java solution \\nclass Solution {\\n    public boolean isPalindrome(int x) {\\n        int r,sum=0,temp;\\n        temp=x;\\n        while(x>0)\\n        {\\n            r=x%10;\\n            sum=(sum*10)+r;\\n            x=x/10;\\n        }\\n        if(temp==sum)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ajaypanchal000411",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }\\n\\n        int num = x;\\n       long long int sum = 0;\\n       \\n        while(num != 0){\\n            int r = num%10;\\n            sum = sum*10 + r;\\n            num = num/10;\\n\\n\\n        }\\n\\n\\n        if(sum == x){\\n            return true;\\n        }\\n        else {\\n            return false;\\n        }\\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "ryzhuk",
                        "content": "I used \"//\" and \"%\" in order to separate digits. If number < 0 it can\\'t be palindrome ))"
                    },
                    {
                        "username": "Manav2603",
                        "content": "Can anyone tell me what is the error in this code \\nLine 59: Char 18: error: use of undeclared identifier \\'Solution\\'\\n      bool ret = Solution().isPalindrome(param_1); return ret;\\n                 ^\\n\\n#include<iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int n,num,s;\\n    char rev = 0;\\n   \\n   \\n    while (1)\\n    {\\n        rev = 0;\\n        n = num;\\n        cout << \"Enter the number: \" << endl;\\n    cin>>num;\\n    \\n        s = num % 10;\\n        rev = rev*10+s;\\n        num = num /10;\\n        \\n        cout << rev;\\n        \\n        if(n == rev)\\n        {\\n            cout<<\" The entered number is Palindrome number\";\\n            \\n        }\\n        else\\n        {\\n            cout<<\"The entered number is not plindrome number\";\\n            \\n        }\\n        \\n        cout<<\"\\\\n Would you like to check another number(Y/N): \";\\n        \\n        cin>>rev;\\n        \\n        if(rev == \\'Y\\' or rev == \\'y\\')\\n        {\\n            cout << \" \" << endl;\\n            \\n        }\\n        else\\n        {\\n            cout << \" Thank you \" << endl;\\n            break;\\n            \\n        }\\n}\\n    return 0;\\n}\\n"
                    },
                    {
                        "username": "anmolsudhakar",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        \\n        int xx = x;\\n        if(x<0){\\n            return false;\\n        }\\n        long long t = 0;\\n\\n        while(x>0){\\n             t = t*10+x%10;\\n            x/=10;\\n        }\\n\\n         return t==xx;\\n    }\\n};"
                    },
                    {
                        "username": "pranjalssharma97",
                        "content": "a=str(x)\\n        b=a[::-1]\\n        if a==b:\\n            return(\"true\")\\n        else:\\n            return(\"false\")\\n\\n\\nthis code is running on jupyter but not here. please help"
                    },
                    {
                        "username": "rakesh_123456",
                        "content": " `your inline code...your inline code..."
                    },
                    {
                        "username": "I_have_no_idea_whats_happening",
                        "content": " [@saikot1223](/saikot1223) About your comment on converting an int to a string.\\n1. under the string.h library is the to_string() function.\\n\\n2. you could use string stream \\nex: \\nint x = 102;\\nstringstream ss;\\nss << 102;\\nstring s = ss.str();\\n\\n3. At the end of the problems description is a little note that challenges you to do it without converting the number to a string. It\\'s not required but better in the long run. "
                    }
                ]
            },
            {
                "id": 1714731,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1711366,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1711184,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1709056,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1707182,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1701906,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1700870,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1692815,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1692472,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1692096,
                "content": [
                    {
                        "username": "aivanilov",
                        "content": "Two pointers approach with conversion to String gives really nice performance. Math approach gives O(logN) and conversion to String should be O(n) but performance, calculated by Leetcode, is extremely high in the following approach. Any thought why? \\n\\n ```\\npublic boolean isPalindrome(int x) {\\n        String number = String.valueOf(x);\\n        int left = 0;\\n        int right = number.length() - 1;\\n        while (left < right){\\n            if (number.charAt(left) != number.charAt(right)) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }"
                    },
                    {
                        "username": "agnivS",
                        "content": "Simply convert this integer to a String and then find a way to check for palindromes via using string methods. StringBuilder class might be helpful. I don\\'t believe this problem is beneficial enough of an exercise in algorithms as the most naive methods can easily solve it. "
                    },
                    {
                        "username": "vishal_2970",
                        "content": "//Bhaii Dekho isme kya galat hai\\n//run karne p sahi de raha hai test case 3 p lekin submit karne p galat de raha\\nclass Solution {\\n    static int sum[]=new int[1];\\n    public boolean isPalindrome(int x) {\\n        // int x=12321;\\n        if(x<0){\\n            return false;\\n        }\\n        if(x==0 || x==1){\\n            return true;\\n        }\\n        int temp=x;\\n        rev(temp);\\n        if(x==sum[0]){\\n            return true;\\n        } \\n        return false;\\n    }\\n    static void rev(int x){\\n        if(x==0){\\n            return;\\n        }\\n        int rem=x%10;\\n        sum[0] = sum[0]*10+rem;\\n        rev(x/10);\\n    }\\n}"
                    },
                    {
                        "username": "Yugant_Singh",
                        "content": "bool isPalindrome(long x) {\\n        long n = x;\\n        long sum = 0;\\n        while(n>0){\\n            long r = n%10;\\n            sum = sum*10 + r;\\n            n = n/10;\\n        }\\n        if(sum == x and x>=0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        \\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        \\n        if(x==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n    }\\n};\\n\\n\\n\\n\\nam not getting the right output after this, can you just review and tell?\\n"
                    },
                    {
                        "username": "harshitsinghcode",
                        "content": "CORRECT CODE FROM MY SIDE - \\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int ans=0;\\n        int t=x;\\n        while(x!=0){\\n            \\n            int lastDig=x%10;\\n            \\n            if((ans>INT_MAX/10)||(ans<INT_MIN/10)){\\n                return 0;\\n            }\\n            \\n            ans=(ans*10)+lastDig;\\n            \\n            x=x/10;\\n        }\\n        if(t<0)\\n        cout<<\"false\"<<endl;\\n        else{\\n        if(t==ans){\\n            return true;\\n        }\\n        \\n        \\n        else{\\n        return false;\\n        }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "For C++ ans PLS CHECKOUT THIS LINK\\nLEAVE A STAR if you find it useful\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/09_pallindrome.cpp"
                    },
                    {
                        "username": "Miakiru",
                        "content": " `def isPalindrome(self, x):    \\n    my_list = list(str(x))\\n    reversed_list = list(reversed(my_list))\\n    res = my_list==reversed_list\\n    print(res)\\n    `\\n\\nWhy that doesn\\'t work? It gives the false result to everything in this website, other environment is working fine."
                    },
                    {
                        "username": "silent_voice143",
                        "content": "testcases are little weird if i m giving -121 it showing false but it is also palindrome but anyway output coming ."
                    },
                    {
                        "username": "alex_arpit",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n        int temp,r;\\n        int sum=0;\\n        if(x<0)\\n        return false;\\n        else{\\n            temp=x;\\n            while(x>0){\\n             r=x%10;\\n             sum=(sum*10)+r;\\n             x/=10;\\n             \\n            }\\n            if(temp==sum){\\n            return true;\\n            }\\n            else{\\n                return false;\\n            } \\n            \\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mudssira01",
                        "content": "Best 17 ms solution\\n \\n``\\npublic boolean isPalindrome(int x) {\\n        int check = x;\\n        int result = 0;\\n        int reminder = 0;\\n        int modMultiplie = 10;\\n\\n        if(x < 0) {\\n            return false;\\n        } else if(x == 0) {\\n            return true;\\n        }\\n\\n        while(check > 0) {\\n            reminder = check % modMultiplie;\\n            check = check / modMultiplie;\\n\\n            result = (result * modMultiplie) + reminder;\\n        }\\n        if(result == x) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n``"
                    }
                ]
            },
            {
                "id": 1691105,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1689697,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1678539,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1677535,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1672244,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1672205,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1671237,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1670990,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1666934,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1666748,
                "content": [
                    {
                        "username": "mustahid19",
                        "content": "class Solution(object):\\n    def isPalindrome(self, x):\\n        \"\"\"\\n        :type x: int\\n        :rtype: bool\\n        \"\"\"\\n        reverse = str(x)[::-1]\\n        if str(x) == reverse:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "RachelWealth",
                        "content": "I don\\'t understand why it doesn\\'t break out of the while loop while temp==0:\\n`` `\\nclass Solution(object):\\n    def isPalindrome(self, x):\\n        # method one-------------------\\n        reverseNumber = 0\\n        remainder = 0\\n        temp = x\\n        while (temp != 0):\\n            reverseNumber = reverseNumber*10+temp%10\\n            temp = temp // 10\\n            \\n        return x == reverseNumber\\n```"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "I am new here  I am unable to pass the first case. All my test cases are passing well except first one."
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int sum=0,rem;\\n        int n=x;\\n        while(n!=0){\\n            rem = n%10;\\n            sum = sum*10 + rem;\\n            n/=10;\\n        }\\n        if(sum==x){\\n            return true;\\n        }\\n        else if(sum!=x && x<0){\\n            return false;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\n\\ncan anyone tell ? what is wrong with my code?"
                    },
                    {
                        "username": "arjunpatel007",
                        "content": "c++ easy to understand Solution\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int temp = x;\\n        long long result = 0;\\n        while(temp){\\n        int rem = temp % 10;\\n        result = result*10 + rem;\\n        temp /= 10;\\n        }\\n        if(x==0){return true;}\\n        else if(x==result && x>0){\\n            return true;\\n        }\\n        else return false;\\n    }\\n};"
                    },
                    {
                        "username": "prathamrajsri2003",
                        "content": "why does it take main as a global variable in c++ when I try to write the palindrome code in pure cpp"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-palindrome-number-problem-solution.html)"
                    },
                    {
                        "username": "BhagyashreeArakeri",
                        "content": "Here is easy solution :\\npublic boolean isPalindrome(int x) {\\n        int origi = x, res = 0;\\n        if(x < 0)\\n            return false;\\n        while(x > 0){\\n            int rem = x % 10;\\n            res = (res * 10) + rem;\\n            x = x / 10;\\n        }\\n        if(origi == res)\\n            return true;\\n        return false;\\n    }\\n\\n"
                    },
                    {
                        "username": "Gavaskar004",
                        "content": "class Solution:\\n     def isPalindrome(self,number):\\n        \\n        n=number\\n        org=number\\n        j=0\\n        while n>1:\\n            \\n            if n>1:\\n                j=j+1\\n            else:\\n                break\\n            n=n/10\\n        i=j\\n       \\n        new=0\\n        x=number\\n        while i>=1:\\n            x=(int(number/10**(i-1)))\\n            new=new+x*10**(j-i)\\n            number=abs(number-x*10**(i-1))\\n            i=i-1\\n            \\n        if new==org:\\n            print(\"True\")\\n            \\n        else:\\n            print(\\'False\\')\\n        \\nSolution.isPalindrome(\\'name\\',121)\\n\\nWhy this isn\\'t working here, For 121. I get correct in other IDE"
                    },
                    {
                        "username": "tarunkesavk",
                        "content": "i am also facing same issue"
                    },
                    {
                        "username": "prateek_singh26",
                        "content": "class Solution {\\n    public boolean isPalindrome(int x) {\\n       String str = String.valueOf(x);\\n       for(int i = 0, j  = str.length()-1; i<str.length(); j--, i++)\\n           if(str.charAt(i)!=str.charAt(j))\\n               return false;\\n        return true;\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Convert Sorted List to Binary Search Tree",
        "question_content": "<p>Given the <code>head</code> of a singly linked list where elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/linked.jpg\" style=\"width: 500px; height: 388px;\" />\n<pre>\n<strong>Input:</strong> head = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 35476,
                "title": "share-my-java-solution-1ms-very-short-and-concise",
                "content": "    public class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        return toBST(head,null);\\n    }\\n    public TreeNode toBST(ListNode head, ListNode tail){\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        if(head==tail) return null;\\n        \\n        while(fast!=tail&&fast.next!=tail){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode thead = new TreeNode(slow.val);\\n        thead.left = toBST(head,slow);\\n        thead.right = toBST(slow.next,tail);\\n        return thead;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        return toBST(head,null);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 35472,
                "title": "share-my-o-1-space-and-o-n-time-java-code",
                "content": "    private ListNode node;\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n    \\tif(head == null){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint size = 0;\\n    \\tListNode runner = head;\\n    \\tnode = head;\\n    \\t\\n    \\twhile(runner != null){\\n    \\t\\trunner = runner.next;\\n    \\t\\tsize ++;\\n    \\t}\\n    \\t\\n    \\treturn inorderHelper(0, size - 1);\\n    }\\n\\n    public TreeNode inorderHelper(int start, int end){\\n    \\tif(start > end){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint mid = start + (end - start) / 2;\\n    \\tTreeNode left = inorderHelper(start, mid - 1);\\n    \\t\\n    \\tTreeNode treenode = new TreeNode(node.val);\\n    \\ttreenode.left = left;\\n    \\tnode = node.next;\\n\\n    \\tTreeNode right = inorderHelper(mid + 1, end);\\n    \\ttreenode.right = right;\\n    \\t\\n    \\treturn treenode;\\n    }",
                "solutionTags": [],
                "code": "    private ListNode node;\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n    \\tif(head == null){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint size = 0;\\n    \\tListNode runner = head;\\n    \\tnode = head;\\n    \\t\\n    \\twhile(runner != null){\\n    \\t\\trunner = runner.next;\\n    \\t\\tsize ++;\\n    \\t}\\n    \\t\\n    \\treturn inorderHelper(0, size - 1);\\n    }\\n\\n    public TreeNode inorderHelper(int start, int end){\\n    \\tif(start > end){\\n    \\t\\treturn null;\\n    \\t}\\n    \\t\\n    \\tint mid = start + (end - start) / 2;\\n    \\tTreeNode left = inorderHelper(start, mid - 1);\\n    \\t\\n    \\tTreeNode treenode = new TreeNode(node.val);\\n    \\ttreenode.left = left;\\n    \\tnode = node.next;\\n\\n    \\tTreeNode right = inorderHelper(mid + 1, end);\\n    \\ttreenode.right = right;\\n    \\t\\n    \\treturn treenode;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3282028,
                "title": "java-easy-using-slow-fast-pointer-recursively",
                "content": "**Let\\'s think how can we approach this problem. One thing we can make sure of that our middle element of the sorted list will be our root. Now you will ask why? We will do this way because in the question it has stated that the bst that we will form from the list should be a height balanced bst. Now what is height balanced bst?? Height balanced bst means the difference between the heights of the left and the right subtree for any node is not more than one. So due to this condition our intuitive mind will always take the mid element of the list as the root of the bst. So to get the middle of the list I used tortoise-hare method or floyd cycle method. Here the slow starts from head and fast from head.next.next so that our slow pointer will stop at previous element of mid element of list. This will ensure that the slow\\'s next is the root and the slow itself is the part of left subtree. Doing this will help to detach the left part from remaining part of list by making the next of slow to null. We create a node of tree and assign slow\\'s next node\\'s value to it and ensured that it is the root of the tree. We then store the pointer of right subtree (here it\\'s righthalf node) by moving two step ahead because we know our right subtree will start after the root or you can say mid element of the list. After storing we make slow\\'s next to null so there will be no link with further elements of list. Now, we will start making the tree from left and right by assigning the root\\'s left as the head and root\\'s right as  righthalf node. Then this process goes on recursively again and again until we reach the base condition.**\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/2a469114-af57-494c-865a-6650b9d13bab_1678496081.7235246.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35483,
                "title": "my-accepted-c-solution",
                "content": "    class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head)\\n        {\\n        \\treturn sortedListToBST( head, NULL );\\n        }\\n        \\n    private:\\n        TreeNode *sortedListToBST(ListNode *head, ListNode *tail)\\n        {\\n        \\tif( head == tail )\\n        \\t\\treturn NULL;\\n        \\tif( head->next == tail )    // \\n        \\t{\\t\\n        \\t\\tTreeNode *root = new TreeNode( head->val );\\n        \\t\\treturn root;\\n        \\t}\\n        \\tListNode *mid = head, *temp = head;\\n        \\twhile( temp != tail && temp->next != tail )    // \\u5bfb\\u627e\\u4e2d\\u95f4\\u8282\\u70b9\\n        \\t{\\n        \\t\\tmid = mid->next;\\n        \\t\\ttemp = temp->next->next;\\n        \\t}\\n        \\tTreeNode *root = new TreeNode( mid->val );\\n        \\troot->left = sortedListToBST( head, mid );\\n        \\troot->right = sortedListToBST( mid->next, tail );\\n        \\treturn root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head)\\n        {\\n        \\treturn sortedListToBST( head, NULL );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 596899,
                "title": "java-python-2-solutions-clean-concise-o-n-time-o-logn-space",
                "content": "**\\u2714\\uFE0F Solution 1: Convert linked list to array then do PreOrder Traversal**\\n- Convert `linked list` to `array`, then the problem become [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n- Choose `arr[mid]` as a root\\n- Solve sub problem `(left, mid - 1)`, make it as left node\\n- Solve sub problem `(mid + 1, right)`, make it as right node\\n\\n<iframe src=\"https://leetcode.com/playground/Z96ZK7Tx/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra space: `O(N)`, because we need an extra `O(N)` space for `arr` \\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: InOrder Traversal**\\n- It\\'s a good chance to use In Order Traveral here, where we traverse Left - Root - Right.\\n- Firstly, we calculate of number of elements in the linked list, let name it `n`.\\n- We keep global `head`, in the beginning `head` points to the first element in the BST.\\n- Let `dfs(left, right)` return the root of the **height balanced BST** when building in elements from `left` to `right` of the linked list.\\n- Our answer is the root which is returned from `dfs(0, n-1)`.\\n- In `dfs(left, right)` function:\\n\\t- `mid = (left + right) / 2`\\n\\t- Firstly, we build BST left subtree, by `leftNode = dfs(left, mid-1)`, after finish building left subtree, now `head` will point to the `mid` element.\\n\\t- So we take the root value from `head.val` and move `head` to next, by `root = TreeNode(head.val); head = head.val`\\n\\t- Finally, we build the right node of the root, by `rightNode = dfs(mid+1, right)`.\\n\\n<iframe src=\"https://leetcode.com/playground/ijCqBuCC/shared\" frameBorder=\"0\" width=\"100%\" height=\"530\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra Space: `O(logN)`, because the depth of the `buildBST` recursion take `logN`\\n\\nPlease help to **UPVOTE** if this post is useful for you. If you have any questions, feel free to comment below. Happy coding!",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Convert linked list to array then do PreOrder Traversal**\\n- Convert `linked list` to `array`, then the problem become [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n- Choose `arr[mid]` as a root\\n- Solve sub problem `(left, mid - 1)`, make it as left node\\n- Solve sub problem `(mid + 1, right)`, make it as right node\\n\\n<iframe src=\"https://leetcode.com/playground/Z96ZK7Tx/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra space: `O(N)`, because we need an extra `O(N)` space for `arr` \\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: InOrder Traversal**\\n- It\\'s a good chance to use In Order Traveral here, where we traverse Left - Root - Right.\\n- Firstly, we calculate of number of elements in the linked list, let name it `n`.\\n- We keep global `head`, in the beginning `head` points to the first element in the BST.\\n- Let `dfs(left, right)` return the root of the **height balanced BST** when building in elements from `left` to `right` of the linked list.\\n- Our answer is the root which is returned from `dfs(0, n-1)`.\\n- In `dfs(left, right)` function:\\n\\t- `mid = (left + right) / 2`\\n\\t- Firstly, we build BST left subtree, by `leftNode = dfs(left, mid-1)`, after finish building left subtree, now `head` will point to the `mid` element.\\n\\t- So we take the root value from `head.val` and move `head` to next, by `root = TreeNode(head.val); head = head.val`\\n\\t- Finally, we build the right node of the root, by `rightNode = dfs(mid+1, right)`.\\n\\n<iframe src=\"https://leetcode.com/playground/ijCqBuCC/shared\" frameBorder=\"0\" width=\"100%\" height=\"530\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`\\n- Extra Space: `O(logN)`, because the depth of the `buildBST` recursion take `logN`\\n\\nPlease help to **UPVOTE** if this post is useful for you. If you have any questions, feel free to comment below. Happy coding!",
                "codeTag": "Unknown"
            },
            {
                "id": 35474,
                "title": "python-recursive-solution-with-detailed-comments-operate-linked-list-directly",
                "content": "        \\n    # recursively\\n    def sortedListToBST(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        # here we get the middle point,\\n        # even case, like '1234', slow points to '2',\\n        # '3' is root, '12' belongs to left, '4' is right\\n        # odd case, like '12345', slow points to '2', '12'\\n        # belongs to left, '3' is root, '45' belongs to right\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        # tmp points to root\\n        tmp = slow.next\\n        # cut down the left child\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        return root",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "        \\n    # recursively\\n    def sortedListToBST(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        # here we get the middle point,\\n        # even case, like '1234', slow points to '2',\\n        # '3' is root, '12' belongs to left, '4' is right\\n        # odd case, like '12345', slow points to '2', '12'\\n        # belongs to left, '3' is root, '45' belongs to right\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n        # tmp points to root\\n        tmp = slow.next\\n        # cut down the left child\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 35525,
                "title": "share-my-code-with-o-n-time-and-o-1-space",
                "content": "count is a function to calculate the size of list.\\n\\nKey words: inorder traversal.\\n\\n    class Solution {\\n    public:\\n        ListNode *list;\\n        int count(ListNode *node){\\n            int size = 0;\\n            while (node) {\\n                ++size;\\n                node = node->next;\\n            }\\n            return size;\\n        }\\n        \\n        TreeNode *generate(int n){\\n            if (n == 0)\\n                return NULL;\\n            TreeNode *node = new TreeNode(0);\\n            node->left = generate(n / 2);\\n            node->val = list->val;\\n            list = list->next;\\n            node->right = generate(n - n / 2 - 1);\\n            return node;\\n        }\\n        \\n        TreeNode *sortedListToBST(ListNode *head) {\\n            this->list = head;\\n            return generate(count(head));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *list;\\n        int count(ListNode *node){\\n            int size = 0;\\n            while (node) {\\n                ++size;\\n                node = node->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3282118,
                "title": "image-explanation-slow-fast-pointer-recursion-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/cN823mo1r4k\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/e4022e7b-2e95-4f21-8e2e-74faa5dc76fa_1678501530.4593227.png)\\n![image.png](https://assets.leetcode.com/users/images/a3fe3a63-12fe-4d34-8841-9afeeabb3ec6_1678501541.154464.png)\\n![image.png](https://assets.leetcode.com/users/images/8da565b0-74e6-4b6a-b5cf-a3ef2cc00380_1678501553.1902893.png)\\n![image.png](https://assets.leetcode.com/users/images/4655f600-a847-45ce-9f46-8b27559c2ac1_1678501562.9293156.png)\\n![image.png](https://assets.leetcode.com/users/images/bb1a5509-5c97-48ef-ac55-f74c9599f864_1678501581.0625086.png)\\n![image.png](https://assets.leetcode.com/users/images/8b37776f-dca2-4485-bfe0-a914c2b8031b_1678501594.5740566.png)\\n![image.png](https://assets.leetcode.com/users/images/8056ea2c-9f10-47fd-a259-2d1054e467d5_1678501606.667109.png)\\n![image.png](https://assets.leetcode.com/users/images/8bc35695-59fc-4f00-bfbf-8ecefa91c910_1678501633.2509317.png)\\n![image.png](https://assets.leetcode.com/users/images/ac9d172a-5899-40bd-9fc4-31f3bc2fb1e2_1678501643.2698946.png)\\n![image.png](https://assets.leetcode.com/users/images/58cebc1b-d810-46d9-b167-bb1e6f67dc7a_1678501653.2449741.png)\\n![image.png](https://assets.leetcode.com/users/images/667d287d-78e5-4842-ad8f-2f153f1e5c03_1678501666.6580515.png)\\n![image.png](https://assets.leetcode.com/users/images/05dc0244-5772-4f9b-a933-f8c2834f6675_1678501673.2652276.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35470,
                "title": "recursive-bst-construction-using-slow-fast-traversal-on-linked-list",
                "content": "    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null)\\n            return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev =null; \\n        while(fast != null && fast.next != null)\\n        {\\n            fast = fast.next.next;\\n            prev =slow;\\n            slow=slow.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        if(prev != null)\\n            prev.next = null;\\n        else\\n            head  = null;\\n            \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n\\nTraverse the list to get the middle element and make that the root. left side of the list forms left sub-tree and right side of the middle element forms the right sub-tree.",
                "solutionTags": [],
                "code": "    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null)\\n            return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev =null; \\n        while(fast != null && fast.next != null)\\n        {\\n            fast = fast.next.next;\\n            prev =slow;\\n            slow=slow.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        if(prev != null)\\n            prev.next = null;\\n        else\\n            head  = null;\\n            \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n\\nTraverse the list to get the middle element and make that the root. left side of the list forms left sub-tree and right side of the middle element forms the right sub-tree.",
                "codeTag": "Unknown"
            },
            {
                "id": 3281968,
                "title": "beats-100-video-java-c-python",
                "content": "# Intuition \\nIn a balanced binary search Tree height difference b/w left and right node cannot be more than 1 or in other words they contain almost equal number of nodes. \\n\\nThis can be achieved by dividing the Linked List into 2 parts first half = left Node, middle = root and right = second half. Repeat the above process recursively to generate the BST.\\n\\nTo find middle element use 2 pointer approach: The fast moves 2 steps  and slow 1 step at a time. Hence when fast is finished, slow will be at middle.\\n\\neg: Find the middle element below = 0 and form root. The LinkedList on left of middle will form a new BST and right will form a new BST using same function. i.e -3 will be mid and left = -10 and right = -1 . \\n![image](https://assets.leetcode.com/users/images/d62c97df-6f71-4fc7-8452-752aab7ac249_1678497515.3905432.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a0653699-208d-4bf5-a27f-1d26a0e77afd_1678497561.5658028.jpeg)\\n\\n\\n# Approach \\n1. Find the middle element of the linked list.\\n2. Create a new node with the middle element as its value.\\n3. Set the left subtree of the new node to the result of recursively calling the function on the left half of the sorted list.\\n4. Set the right subtree of the new node to the result of recursively calling the function on the right half of the sorted list.\\n5. Return the new node.\\n\\nHow to find middle element:\\n\\n1. Initialize two pointers, slow and fast, to head.\\n2. Move fast two steps ahead and slow one step ahead, until fast reaches the end of the list or goes past it.\\n3. The element pointed to by slow is the middle element of the list.\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pWjxJPY-DIo\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image](https://assets.leetcode.com/users/images/88e7cad3-cab3-4e1f-ae9d-039ac2bccfa9_1678494974.1775608.jpeg)\\n\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* middle = getMiddle(head);\\n        TreeNode* root = new TreeNode(middle->val);\\n        root->right = sortedListToBST(middle->next);\\n        middle->next = NULL;\\n        root->left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    ListNode* getMiddle(ListNode* head){\\n        //if(head == NULL || head->next==NULL) return NULL;\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        ListNode* prev = NULL;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        if(prev!=NULL) prev->next = NULL;\\n        return slow;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n        middle = self.getMiddle(head)\\n        root = TreeNode(middle.val)\\n        root.right = self.sortedListToBST(middle.next)\\n        middle.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n    \\n    def getMiddle(self, head: ListNode) -> ListNode:\\n        fast = head\\n        slow = head\\n        prev = None\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            prev = slow\\n            slow = slow.next\\n        if prev:\\n            prev.next = None\\n        return slow\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* middle = getMiddle(head);\\n        TreeNode* root = new TreeNode(middle->val);\\n        root->right = sortedListToBST(middle->next);\\n        middle->next = NULL;\\n        root->left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    ListNode* getMiddle(ListNode* head){\\n        //if(head == NULL || head->next==NULL) return NULL;\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        ListNode* prev = NULL;\\n        while(fast!=NULL && fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        if(prev!=NULL) prev->next = NULL;\\n        return slow;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n        middle = self.getMiddle(head)\\n        root = TreeNode(middle.val)\\n        root.right = self.sortedListToBST(middle.next)\\n        middle.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n    \\n    def getMiddle(self, head: ListNode) -> ListNode:\\n        fast = head\\n        slow = head\\n        prev = None\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            prev = slow\\n            slow = slow.next\\n        if prev:\\n            prev.next = None\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35555,
                "title": "clean-c-solution-recursion-o-nlogn-with-comment",
                "content": "Recursively build tree. <br>\\n1. find midpoint by fast/slow method, use middle node as root.  <br>\\n2. build left child by first half of the list  <br>\\n3. build right child by second half of the list (head is midpoint->next)\\n\\n<pre><code><cpp>\\n    class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            pre->next = 0; // break two halves \\n            \\n            // slow is the midpoint, use as root\\n            TreeNode* root = new TreeNode(slow->val);\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            \\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 35589,
                "title": "share-my-easy-understatnd-java-solution",
                "content": "    public class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode temp=null;\\n        \\n        //find the mid node\\n        while(fast.next!=null && fast.next.next!=null){\\n            fast = fast.next.next;\\n            temp = slow;\\n            slow = slow.next;\\n        }\\n        \\n        if(temp!=null)\\n            temp.next = null; //break the link\\n        else\\n            head = null;\\n            \\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode temp=null;\\n        \\n        //find the mid node\\n        while(fast.next!=null && fast.next.next!=null){\\n            fast = fast.next.next;\\n            temp = slow;\\n            slow = slow.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 35526,
                "title": "python-solutions-convert-to-array-first-top-down-approach-bottom-up-approach",
                "content": "    # convert linked list to array\\n    def sortedListToBST1(self, head):\\n        ls = []\\n        while head:\\n            ls.append(head.val)\\n            head = head.next\\n        return self.helper(ls, 0, len(ls)-1)\\n\\n    def helper(self, ls, start, end):\\n        if start > end:\\n            return None\\n        if start == end:\\n            return TreeNode(ls[start])\\n        mid = (start+end) >> 1\\n        root = TreeNode(ls[mid])\\n        root.left = self.helper(ls, start, mid-1)\\n        root.right = self.helper(ls, mid+1, end)\\n        return root\\n\\n    # top-down approach, O(n*logn)\\n    def sortedListToBST2(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        slow, fast = dummy, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        root = TreeNode(slow.next.val)\\n        root.right = self.sortedListToBST(slow.next.next)\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n        \\n    # bottom-up approach, O(n)\\n    def sortedListToBST3(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        return self.convert([head], 0, l-1)\\n        \\n    def convert(self, head, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(head, start, mid-1)\\n        root = TreeNode(head[0].val)\\n        root.left = l\\n        head[0] = head[0].next \\n        root.right = self.convert(head, mid+1, end)\\n        return root\\n    \\n    # bottom-up approach, O(n)    \\n    def sortedListToBST(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        self.node = head\\n        return self.convert(0, l-1)\\n        \\n    def convert(self, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(start, mid-1)\\n        root = TreeNode(self.node.val)\\n        root.left = l\\n        self.node = self.node.next \\n        root.right = self.convert(mid+1, end)\\n        return root",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # convert linked list to array\\n    def sortedListToBST1(self, head):\\n        ls = []\\n        while head:\\n            ls.append(head.val)\\n            head = head.next\\n        return self.helper(ls, 0, len(ls)-1)\\n\\n    def helper(self, ls, start, end):\\n        if start > end:\\n            return None\\n        if start == end:\\n            return TreeNode(ls[start])\\n        mid = (start+end) >> 1\\n        root = TreeNode(ls[mid])\\n        root.left = self.helper(ls, start, mid-1)\\n        root.right = self.helper(ls, mid+1, end)\\n        return root\\n\\n    # top-down approach, O(n*logn)\\n    def sortedListToBST2(self, head):\\n        if not head:\\n            return \\n        if not head.next:\\n            return TreeNode(head.val)\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        slow, fast = dummy, head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        root = TreeNode(slow.next.val)\\n        root.right = self.sortedListToBST(slow.next.next)\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        return root\\n        \\n    # bottom-up approach, O(n)\\n    def sortedListToBST3(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        return self.convert([head], 0, l-1)\\n        \\n    def convert(self, head, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(head, start, mid-1)\\n        root = TreeNode(head[0].val)\\n        root.left = l\\n        head[0] = head[0].next \\n        root.right = self.convert(head, mid+1, end)\\n        return root\\n    \\n    # bottom-up approach, O(n)    \\n    def sortedListToBST(self, head):\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        self.node = head\\n        return self.convert(0, l-1)\\n        \\n    def convert(self, start, end):\\n        if start > end:\\n            return None\\n        mid = (start + end) >> 1\\n        l = self.convert(start, mid-1)\\n        root = TreeNode(self.node.val)\\n        root.left = l\\n        self.node = self.node.next \\n        root.right = self.convert(mid+1, end)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 1194284,
                "title": "python-optimal-o-n-inorder-traversal-explained",
                "content": "There are solutions with different time/space complexities.\\n1. We can just transform everything to array and then create bst, in `O(n)` time and `O(n)` space.\\n2. Or we can not create array, but then each time we need to find middle, and time will be `O(n log n)`.\\n\\nImagine now, that we can reuse nodes of our linked list to create nodes of bst. This is not the case in this problem, but if it was the case than we can have space complexity smaller than `O(n)`. The main complexity in idea `2` is that we always need to find the middle element in list, which is quite heavy: we need to traverse all (or half) of the list. Let us use function `helper(beg, end)`, with:\\n\\n1. `(beg, end)` are indexes in original linked list we want to traverse and create BST from these elements.\\n2. Output will be the root of BST\\n3. We also keep one more piece of information: `self.head`: global variable, which will help us to have quick access to desired elements: on step `i` in inorder traversal it will point to `i`-th element in linked list. More precisely when we run `helper(beg, end)`, after execution of this code, `self.head` will point to the element with index `end + 1`. This is **invariant** of our `helper` functioun.\\n\\nNow, function will look like this:\\n1. Check if `beg > end` and if it is the case, we out of nodes, we return `None`.\\n2. Find `mid` element as `(beg + end)//2`.\\n3. Run our `helper` function recursively: `helper(beg, mid - 1)`. Note where our `self.head` is now. It is changed after we run this funtion and now points at element with index `mid`.\\n4. Create `root`: we use `self.head` for this.\\n5. Move `self.head` one step to the right.\\n6. Now, it is time to attach left subtree to our root.\\n7. Finally, attach right subtree: `helper(mid + 1, end)` to our root. Note howe `self.head` changed after this: it will point at element with index `end + 1`. So, we proved, that our **invariant** holds.\\n8. Return `root`.\\n\\n#### Complexity\\nTime complexity is `O(n)`: we traverse every node only once. Space complexity is also `O(n)`, because we need to create object with `n` elements in the end. However why this is better than creating array, is because if we allowed to modify elements of the linked list to make them directly elements of BST, then space complexity would have been `O(log n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        def helper(beg, end):\\n            if beg > end: return None\\n            mid = (beg + end)//2\\n            left = helper(beg, mid - 1)\\n            root = TreeNode(self.head.val)\\n            self.head = self.head.next\\n            root.left = left\\n            root.right = helper(mid + 1, end)\\n            return root\\n        \\n        self.head, copy, n = head, head, 0\\n        while copy:\\n            copy = copy.next\\n            n += 1\\n            \\n        return helper(0, n-1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List",
                    "Binary Search Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        def helper(beg, end):\\n            if beg > end: return None\\n            mid = (beg + end)//2\\n            left = helper(beg, mid - 1)\\n            root = TreeNode(self.head.val)\\n            self.head = self.head.next\\n            root.left = left\\n            root.right = helper(mid + 1, end)\\n            return root\\n        \\n        self.head, copy, n = head, head, 0\\n        while copy:\\n            copy = copy.next\\n            n += 1\\n            \\n        return helper(0, n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194036,
                "title": "explained-algorithm-c-code",
                "content": "Intuition is we need to find middle and divide list in two halves and keep doing same till single node.\\n\\n**Algorithm:**\\n```\\n1. We know middle node will be our root , so we will calculate middle using findMiddle()\\n2. We should also track prev of middle to mark the end of first list before middle node.\\n3. Now we have two lists - \\n\\tlist1:  [head....middle_prev] \\n    list2: [middle_next.....lastnode]\\n4. middle is the root.\\n5. put list1 in left of root and list2 in right of root.\\n6. Repeat the process from beginning for list1 and list2.\\n7. return root\\n```\\n\\nRecursion is difficult untill you make your code dry run following ladder-structure.\\n\\n**Working Code:**\\n```\\nclass Solution {\\npublic:\\n    pair<ListNode*,ListNode*> findMiddle(ListNode *head){\\n        if(nullptr == head || nullptr == head->next)\\n            return {nullptr,head};\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        ListNode *prev = nullptr;\\n        \\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        return {prev,slow};\\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(nullptr == head)\\n            return nullptr;\\n        \\n        //returning {prev_middle,middle}\\n        pair<ListNode*,ListNode*> p = findMiddle(head);\\n        \\n        ListNode* prev = p.first;\\n        ListNode* middle = p.second;\\n        \\n        TreeNode* root = new TreeNode(middle->val);\\n        \\n        if(prev){\\n            prev->next = nullptr;\\n            root->left = sortedListToBST(head);\\n        }\\n        \\n        root->right = sortedListToBST(middle->next);\\n        return root;\\n    }\\n};\\n```\\n**Time Complexity** - O(nlogn) \\n**Space Compexity** - O(logn) ---> (Not considering the space taken by output tree nodes, if consider them then O(n) )\\nwhere n is no of nodes in list\\n\\n\\n**If you find this post helpful, please help to upvote**. Thanks in advance.\\nFeel free to shoot your queries in comments.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n1. We know middle node will be our root , so we will calculate middle using findMiddle()\\n2. We should also track prev of middle to mark the end of first list before middle node.\\n3. Now we have two lists - \\n\\tlist1:  [head....middle_prev] \\n    list2: [middle_next.....lastnode]\\n4. middle is the root.\\n5. put list1 in left of root and list2 in right of root.\\n6. Repeat the process from beginning for list1 and list2.\\n7. return root\\n```\n```\\nclass Solution {\\npublic:\\n    pair<ListNode*,ListNode*> findMiddle(ListNode *head){\\n        if(nullptr == head || nullptr == head->next)\\n            return {nullptr,head};\\n        \\n        ListNode *slow = head;\\n        ListNode *fast = head->next;\\n        ListNode *prev = nullptr;\\n        \\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        return {prev,slow};\\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(nullptr == head)\\n            return nullptr;\\n        \\n        //returning {prev_middle,middle}\\n        pair<ListNode*,ListNode*> p = findMiddle(head);\\n        \\n        ListNode* prev = p.first;\\n        ListNode* middle = p.second;\\n        \\n        TreeNode* root = new TreeNode(middle->val);\\n        \\n        if(prev){\\n            prev->next = nullptr;\\n            root->left = sortedListToBST(head);\\n        }\\n        \\n        root->right = sortedListToBST(middle->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194228,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to build a **height-balanced binary tree**, we need to ensure that roughly half of the total number of nodes are on either side of the root, and the only way to know what half of the total number of nodes is requires finding the total number of nodes first.\\n\\nWith this in mind, one easy solution would be to convert the linked list to an array, then we have handy access not only to the total length of the array, but also index-access to the node values, as well. At that point, we could define a **recursive** helper to build a tree from the middle node, recursively calling itself to build subtrees from the nodes on the left and right of the middle node. This option would take an **extra O(N) space** to complete.\\n\\nShould we not want to use up that much extra space, we could instead keep the linked list and lose the index-access nature of the array, using **Floyd\\'s Cycle Detection Algorithm** to easily find the middle node on each recursion step. This would, however, require iterating through parts of the linked list repeatedly, driving the **time complexity** from **O(N)** to **O(N log N)**.\\n\\nBut we can do even better: We can complete this problem in **O(N) time** with only **O(log N) extra space** (in excess of the output space).\\n\\nFirst, we\\'ll have to iterate once through the linked list to count the total number of nodes (**count**). Then, we can define our recursive helper (**treeify()**)using index numbers as our arguments. Even though we won\\'t be able to access the listnodes directly by index number, we can take advantage of an **inorder tree traversal** to force our access to go in iterative order.\\n\\nWe\\'ll need to have our list pointer (**curr**) have global scope in order to update properly via recursion. In an inorder traversal, we recursively process the left subtree, then process the middle node, then recursively process the right subtree. For this solution, we\\'ll just need to make sure we move **curr** to **curr.next** at the end of processing the middle node.\\n\\nWe can then **return** the full tree built by our recursive helper.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of the linked list_\\n - _**Space Complexity: O(log N)** in excess of the space needed for the input/output, due to the recursion stack_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Python, we can store our list index pointer (**curr**) in a list to give it global scope so that it will update properly.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **92ms / 43.6MB** (beats 91% / 95%).\\n```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **120ms / 20.0MB** (beats 95% / 60%).\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 39.8MB** (beats 100% / 56%).\\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **16ms / 30.9MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35572,
                "title": "very-simple-recursive-solution-in-c-o-n-time",
                "content": "    struct ListNode * current;\\n    struct TreeNode * build_tree(int low,int up)\\n    {\\n        if(low >= up ) return NULL;\\n        struct TreeNode * tmp = malloc(sizeof(struct TreeNode));\\n        int mid = low + ((up - low)>>1);\\n        tmp -> left = build_tree(low,mid);\\n        tmp -> val = current -> val;\\n        current = current -> next;\\n        tmp -> right = build_tree(mid+1,up);\\n        return tmp;\\n    }\\n\\n    struct TreeNode* sortedListToBST(struct ListNode* head) {\\n         current = head;\\n        int len = 0;\\n        while(head) \\n            len++, head = head->next;\\n        return build_tree(0,len);\\n    }",
                "solutionTags": [],
                "code": "    struct ListNode * current;\\n    struct TreeNode * build_tree(int low,int up)\\n    {\\n        if(low >= up ) return NULL;\\n        struct TreeNode * tmp = malloc(sizeof(struct TreeNode));\\n        int mid = low + ((up - low)>>1);\\n        tmp -> left = build_tree(low,mid);\\n        tmp -> val = current -> val;\\n        current = current -> next;\\n        tmp -> right = build_tree(mid+1,up);\\n        return tmp;\\n    }\\n\\n    struct TreeNode* sortedListToBST(struct ListNode* head) {\\n         current = head;\\n        int len = 0;\\n        while(head) \\n            len++, head = head->next;\\n        return build_tree(0,len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3281995,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconquer approach similar to how we construct a binary search tree from a sorted array. The idea is to find the middle element of the linked list, make it the root of the tree, and then recursively construct the left and right subtrees using the nodes before and after the middle element, respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find the middle node of the linked list. To do this, we can use the two-pointer technique where one pointer moves one step at a time while the other pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer will be at the\\nmiddle node.\\n2. Create a new TreeNode with the value of the middle node.\\n3. Recursively construct the left subtree using the nodes before the middle node and the right subtree using the nodes after the middle node.\\n4. Return the root node of the tree\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\nThe time complexity of this approach is O(nlogn) because we divide the list into two halves at each level of the recursion tree, and there are a total of logn levels. At each level, we need to traverse the entire sublist to find the middle node, which takes O(n) time. Therefore, the overall time complexity is O(nlogn).\\n\\n- Space complexity: $$O(logn)$$\\nThe space complexity of this approach is O(logn) because we use the call stack to keep track of the recursive function calls. Since the maximum depth of the recursion tree is logn, the space complexity is O(logn).\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` Python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def sortedListToBST(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[TreeNode]\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if not head.next:\\n            return TreeNode(head.val)\\n        \\n        # Find the middle element of the linked list\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Create a new TreeNode with the middle element as the root\\n        root = TreeNode(slow.next.val)\\n        \\n        # Recursively construct the left and right subtrees\\n        right_head = slow.next.next\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(right_head)\\n        \\n        return root\\n\\n```\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        ListNode mid = findMiddle(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(mid.next);\\n        return root;\\n    }\\n    \\n    private ListNode findMiddle(ListNode head) {\\n        ListNode prev = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        if (prev != null) {\\n            prev.next = null;\\n        }\\n        return slow;\\n    }\\n}\\n\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n        ListNode* mid = findMiddle(head);\\n        TreeNode* root = new TreeNode(mid->val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        return root;\\n    }\\n    \\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if (prev) {\\n            prev->next = nullptr;\\n        }\\n        return slow;\\n    }\\n};\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Python []\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def sortedListToBST(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[TreeNode]\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        if not head.next:\\n            return TreeNode(head.val)\\n        \\n        # Find the middle element of the linked list\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # Create a new TreeNode with the middle element as the root\\n        root = TreeNode(slow.next.val)\\n        \\n        # Recursively construct the left and right subtrees\\n        right_head = slow.next.next\\n        slow.next = None\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(right_head)\\n        \\n        return root\\n\\n```\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        ListNode mid = findMiddle(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(mid.next);\\n        return root;\\n    }\\n    \\n    private ListNode findMiddle(ListNode head) {\\n        ListNode prev = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        if (prev != null) {\\n            prev.next = null;\\n        }\\n        return slow;\\n    }\\n}\\n\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) {\\n            return nullptr;\\n        }\\n        ListNode* mid = findMiddle(head);\\n        TreeNode* root = new TreeNode(mid->val);\\n        if (head == mid) {\\n            return root;\\n        }\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        return root;\\n    }\\n    \\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if (prev) {\\n            prev->next = nullptr;\\n        }\\n        return slow;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421697,
                "title": "faster-simpler-recursion-javascript-submission",
                "content": "**Please don\\'t forget to upvote, it only motivates me to write much better code**\\n**And, as always all the suggestions are welcomed**\\n\\n```\\nvar sortedListToBST = function(head) {\\n//     Converting LL into array\\n    let arr = getarr(head);\\n    \\n//     Now, using tree function to get an tree out of SORTED ARRAY\\n    return tree(arr);\\n    \\n};\\n\\nfunction getarr(head){\\n    if(!head) return [];\\n    let temp = head;\\n    let out = []\\n    while(temp){\\n        out.push(temp.val);\\n        temp = temp.next;\\n    }\\n    return out;\\n}\\n\\nfunction tree(nums, start=0, end = nums.length-1) {\\n    if(start<=end){\\n        let mid = Math.floor((start+end)/2);\\n        // console.log(mid, end)\\n        let root = new TreeNode(nums[mid]);\\n        root.left = tree(nums, start, mid-1);\\n        root.right = tree(nums, mid+1, end);\\n        return root;\\n    }\\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sortedListToBST = function(head) {\\n//     Converting LL into array\\n    let arr = getarr(head);\\n    \\n//     Now, using tree function to get an tree out of SORTED ARRAY\\n    return tree(arr);\\n    \\n};\\n\\nfunction getarr(head){\\n    if(!head) return [];\\n    let temp = head;\\n    let out = []\\n    while(temp){\\n        out.push(temp.val);\\n        temp = temp.next;\\n    }\\n    return out;\\n}\\n\\nfunction tree(nums, start=0, end = nums.length-1) {\\n    if(start<=end){\\n        let mid = Math.floor((start+end)/2);\\n        // console.log(mid, end)\\n        let root = new TreeNode(nums[mid]);\\n        root.left = tree(nums, start, mid-1);\\n        root.right = tree(nums, mid+1, end);\\n        return root;\\n    }\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282266,
                "title": "c-easy-solution-recursion-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFRecursion Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* func(ListNode*head,int n){\\n        //if we have the length of list 0 then we will simply return the nullptr\\n        if(n<=0){\\n            return nullptr;\\n        }\\n\\t\\t//if we are remaining with only one length then we will make node of it and return it\\n        if(n==1){\\n            return new TreeNode(head->val);\\n        }\\n        int mid=n/2;\\n        ListNode*temp=head;\\n\\t\\t//traversing to the mid of the list from head\\n        while(mid--){\\n            temp=temp->next;\\n        }\\n\\t\\t//then we will get our ans\\n        TreeNode*ans=new TreeNode(temp->val,func(head,n/2),func(temp->next,n-n/2-1));\\n\\t\\t//returning the ans\\n        return ans;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head){\\n            return nullptr;\\n        }\\n        int n=0;\\n\\t\\t//we are calculating the length of the linked list\\n\\t\\t//so that we can divide the linked list from middle\\n        ListNode*temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->next;\\n        }\\n\\t\\t//then we are calling the function\\n        return func(head,n);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* func(ListNode*head,int n){\\n        //if we have the length of list 0 then we will simply return the nullptr\\n        if(n<=0){\\n            return nullptr;\\n        }\\n\\t\\t//if we are remaining with only one length then we will make node of it and return it\\n        if(n==1){\\n            return new TreeNode(head->val);\\n        }\\n        int mid=n/2;\\n        ListNode*temp=head;\\n\\t\\t//traversing to the mid of the list from head\\n        while(mid--){\\n            temp=temp->next;\\n        }\\n\\t\\t//then we will get our ans\\n        TreeNode*ans=new TreeNode(temp->val,func(head,n/2),func(temp->next,n-n/2-1));\\n\\t\\t//returning the ans\\n        return ans;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head){\\n            return nullptr;\\n        }\\n        int n=0;\\n\\t\\t//we are calculating the length of the linked list\\n\\t\\t//so that we can divide the linked list from middle\\n        ListNode*temp=head;\\n        while(temp){\\n            n++;\\n            temp=temp->next;\\n        }\\n\\t\\t//then we are calling the function\\n        return func(head,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194033,
                "title": "convert-sorted-list-to-binary-search-tree-simple-solution-explained",
                "content": "We need to construct **height-balanced BST** using LinkedList. The main idea is,\\n```\\n-> we want height of the BST to balanced, which can be acheived by selecting mid of List as root of BST.\\n-> follow the same for both left and right trees by calling the function ToBST recursively.\\n\\t1. Left substree can be constructed by first half of List.\\n\\t2. Right subtree can be constructed ny second half of List \\n```\\n\\n**DO UPVOTE if you find it helpful!!**\\n\\n```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        return ToBST(head,NULL);\\n    }\\n    TreeNode* ToBST(ListNode* head, ListNode* tail){\\n        if(head==tail)\\n            return NULL;\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=ToBST(head,slow);\\n        root->right=ToBST(slow->next,tail);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n-> we want height of the BST to balanced, which can be acheived by selecting mid of List as root of BST.\\n-> follow the same for both left and right trees by calling the function ToBST recursively.\\n\\t1. Left substree can be constructed by first half of List.\\n\\t2. Right subtree can be constructed ny second half of List \\n```\n```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        return ToBST(head,NULL);\\n    }\\n    TreeNode* ToBST(ListNode* head, ListNode* tail){\\n        if(head==tail)\\n            return NULL;\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=ToBST(head,slow);\\n        root->right=ToBST(slow->next,tail);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282693,
                "title": "c-o-1-space-using-middle-of-the-linked-list-readable-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // Finds the middle of the linked list\\n    ListNode *middleNode(ListNode *head)\\n    {\\n        ListNode *slow = head, *fast = head;\\n        while (fast and fast->next)\\n            slow = slow->next, fast = fast->next->next;\\n        return slow;\\n    }\\n\\n    TreeNode *build(ListNode *head)\\n    {\\n        // If the list is empty then return null\\n        if (!head)\\n            return NULL;\\n\\n        // If the list contains only one element then return TreeNode of that value\\n        if (middleNode(head) == head)\\n            return new TreeNode(head->val);\\n\\n        // Finding the middle node\\n        ListNode *middle = middleNode(head);\\n\\n        // Making middle node as root\\n        TreeNode *root = new TreeNode(middle->val);\\n\\n        // Dividing list into to parts\\n        // 1. Left part will have elements which is left to \\'middle\\' node\\n        // 2. Right part will have elements which is right to \\'middle\\' node\\n        ListNode *ptr = head;\\n        while (ptr->next != middle)\\n            ptr = ptr->next;\\n\\n        ListNode *first = head;\\n        ListNode *second = middle->next;\\n\\n        // Removing middle from the list\\n        ptr->next = NULL;\\n        middle->next = NULL;\\n\\n        // building BST recursively\\n        root->left = build(first);\\n        root->right = build(second);\\n\\n        // returning root\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (!head)\\n            return NULL;\\n        return build(head);\\n    }\\n};\\n```\\n\\n### [Middle Of the Linked List (LeetCode)](https://leetcode.com/problems/middle-of-the-linked-list/description/)",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Finds the middle of the linked list\\n    ListNode *middleNode(ListNode *head)\\n    {\\n        ListNode *slow = head, *fast = head;\\n        while (fast and fast->next)\\n            slow = slow->next, fast = fast->next->next;\\n        return slow;\\n    }\\n\\n    TreeNode *build(ListNode *head)\\n    {\\n        // If the list is empty then return null\\n        if (!head)\\n            return NULL;\\n\\n        // If the list contains only one element then return TreeNode of that value\\n        if (middleNode(head) == head)\\n            return new TreeNode(head->val);\\n\\n        // Finding the middle node\\n        ListNode *middle = middleNode(head);\\n\\n        // Making middle node as root\\n        TreeNode *root = new TreeNode(middle->val);\\n\\n        // Dividing list into to parts\\n        // 1. Left part will have elements which is left to \\'middle\\' node\\n        // 2. Right part will have elements which is right to \\'middle\\' node\\n        ListNode *ptr = head;\\n        while (ptr->next != middle)\\n            ptr = ptr->next;\\n\\n        ListNode *first = head;\\n        ListNode *second = middle->next;\\n\\n        // Removing middle from the list\\n        ptr->next = NULL;\\n        middle->next = NULL;\\n\\n        // building BST recursively\\n        root->left = build(first);\\n        root->right = build(second);\\n\\n        // returning root\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (!head)\\n            return NULL;\\n        return build(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549841,
                "title": "c-dsw",
                "content": "We can apply the second part of DSW algorithm here. For more details, see a similar solution for [1382. Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)).\\n\\nFirst, we can create a vine (or backbone) tree directly from the linked list. Then, using left rotations, we turn the vine into the ballanced tree.\\n\\n```cpp\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}    \\nTreeNode* sortedListToBST(ListNode* head) {\\n    TreeNode grand;\\n    TreeNode *node = &grand;\\n    int cnt = 0;\\n    while (head != nullptr) {\\n        ++cnt;\\n        node->right = new TreeNode(head->val);\\n        node = node->right;\\n        head = head->next;\\n    }\\n    int m = pow(2, int(log2(cnt + 1))) - 1;\\n    compress(&grand, cnt - m);\\n    for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n    return grand.right;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1). There is no recursion and we do create any data structure besides the tree itself.",
                "solutionTags": [],
                "code": "```cpp\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}    \\nTreeNode* sortedListToBST(ListNode* head) {\\n    TreeNode grand;\\n    TreeNode *node = &grand;\\n    int cnt = 0;\\n    while (head != nullptr) {\\n        ++cnt;\\n        node->right = new TreeNode(head->val);\\n        node = node->right;\\n        head = head->next;\\n    }\\n    int m = pow(2, int(log2(cnt + 1))) - 1;\\n    compress(&grand, cnt - m);\\n    for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n    return grand.right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282713,
                "title": "sorted-linked-list-to-balanced-bst-recursive-slow-fast-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, we see we have to balance the height so the best way to choose the root is such that there are mostly an equal number of values on both ends. Then, call the same approach for the left and right subparts of the linked list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we try to discover the base cases:\\n\\nIf the list is empty, we have to do nothing as there will be no element in the BST and we simply return NULL.\\nIf there is only one element in the list, the sole element in the list will be the root, and thus we return the node which will be assigned with head->val.\\nNow we have cleared all the base cases and move onto the real task, which is how to find the mid of the LinkedList. We use the concept of slow and fast pointers. If we want to find the mid of, for example,\\n1 2 3 4 5,\\nwe assign fast and slow pointers to head, which is the first node of the linked list, and we try to move slow one step at a time until our fast pointer reaches the last node or second last node of the list.\\n\\nFirst Iteration: Slow: 2 and Fast: 3.\\nSecond Iteration: Slow: 3 and Fast: 5.\\nWe stop here as we cannot move the fast pointer further.\\nNow we have found the mid element, which is slow, and add it to the tree:\\n\\nTreeNode *root = new TreeNode(slow->val);\\n\\nand call the SortedListToBST function for the left part of the linked list (head to prev where pre is the pointer just before slow) and the right part (from slow->next to end) as follows:\\n\\npre->next = NULL;\\nroot->left = SortedListToBST(head);\\nroot->right = SortedListToBST(slow->next);\\n\\nFinally we return the root\\n\\n\\n\\n\\n\\n# Complexity\\nTime complexity:\\nO(NlogN) where N is the size of the linked list.\\n\\nSpace complexity:\\nO(logN) as in the worst case, the maximum number of elements in the recursion tree will be logN.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return new TreeNode(head->val);\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        ListNode *prev=head;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode *root = new TreeNode(slow->val);\\n        prev->next=NULL;\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```\\n<img src=\"https://steemitimages.com/p/7ohP4GDMGPrUi4qw3TPEWfuCDmSuTPmBXGkQRjfyZswY5pR3tTkEohRmm23uDrcGV1ikBAnciRrryiVsxHVhX95oT5UG3EBrbUfY?format=match&mode=fit&width=640\" alt=\"drawing\" height=\"150\"/>\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return new TreeNode(head->val);\\n        ListNode *slow=head;\\n        ListNode *fast=head;\\n        ListNode *prev=head;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode *root = new TreeNode(slow->val);\\n        prev->next=NULL;\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678147,
                "title": "c-3-different-approaches-clean-code",
                "content": "Please let me know if you have another approach for this problem or if you have suggestions for one of the existing approaches.\\n\\n\\n### Approach 1: convert to vector and recursion\\n\\nThis is maybe a bit cheating, but this is a fast solution. This is building up on the solution for problem [108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/).\\n\\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        vector<int> nums;\\n        while (head) {\\n            nums.push_back(head->val);\\n            head = head->next;\\n        }\\n        return sortedArrayToBST(cbegin(nums), cend(nums));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedArrayToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ as we need to visit each node.\\n  * Space complexity: $$O(n)$$ for the temporary vector. The stack space only grows with $$O(\\\\log n)$$, but we are also creating $$O(n)$$ ```TreeNode```s as output.\\n\\n\\n### Approach 2: repeatedly find the list midpoint, recursively\\n\\nIn this approach we are not using a temporary vector, we just find the mid point every time with a fast and slow pointer. Besides from this the approach is basically the same as approach 1.\\n\\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, nullptr);\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode* b, const ListNode* e) {\\n        if (b == e) return nullptr;\\n        \\n        // Find the midpoint between |b| and |e| using a fast and slow pointer.\\n        const ListNode* mid = b;\\n        const ListNode* fast = b;\\n        \\n        while (fast != e && fast->next != e) {\\n            fast = fast->next->next;\\n            mid = mid->next;\\n        }\\n        \\n        return\\n            new TreeNode(\\n                mid->val,\\n                sortedListToBST(b, mid),\\n                sortedListToBST(mid->next, e));\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n \\\\log n)$$ because the list is of length $$n$$ and we need to scan the list $$\\\\log n$$ times.\\n  * Space complexity: $$O(\\\\log n)$$ for the implict call stack, we are creating $$O(n)$$ ```TreeNode```s though as the output.\\n\\n\\n### Approach 3: simulate inorder traversal\\n\\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, 0, listSize(head));\\n    }\\n\\n    static int listSize(const ListNode* head) {\\n        int length = 0;\\n        while (head) {\\n            head = head->next;\\n            ++length;\\n        }\\n        return length;\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode*& node, int b, int e) {\\n        if (b == e) return nullptr;\\n        \\n        const int mid = b + (e - b) / 2;\\n\\n        // Construct the left sub-tree.\\n        TreeNode* left = sortedListToBST(node, b, mid);\\n        // Consume the next node in the list.\\n        const int val = node->val;\\n        node = node->next;\\n        // Construct the right sub-tree.\\t\\t\\n        TreeNode* right = sortedListToBST(node, mid + 1, e);\\n\\n        return new TreeNode(val, left, right);\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ we still need to visit all the nodes.\\n  * Space complexity: $$O(\\\\log n)$$ for the call stack, but we still need $$O(n)$$ for the output.\\n\\n### Bonus Approach: custom stl iterator\\n\\nThe core logic looks like approach 1, but in reality it\\'s more like approach 2, with the down side that the ```std::distance()``` will loop over parts of the the linked list again and again. It was still fun to code this up. :)\\n\\n```cpp\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    Iterator(ListNode* head) : curr_(head) {}\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        curr_ = curr_->next;\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    ListNode* curr_;\\n};\\n\\nstruct Iterator begin(ListNode* head) {\\n    return Iterator(head);\\n}\\n\\nstruct Iterator end(ListNode* head) {\\n    return Iterator(nullptr);\\n}\\n\\nclass Solution {\\npublic:\\n    static TreeNode* sortedListToBST(ListNode* head) {\\n        return sortedListToBST(begin(head), end(head));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedListToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nThis is basically the same as approach 2, while the constant factor is larger the time complexity doesn\\'t change.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        vector<int> nums;\\n        while (head) {\\n            nums.push_back(head->val);\\n            head = head->next;\\n        }\\n        return sortedArrayToBST(cbegin(nums), cend(nums));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedArrayToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n```\n```TreeNode```\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, nullptr);\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode* b, const ListNode* e) {\\n        if (b == e) return nullptr;\\n        \\n        // Find the midpoint between |b| and |e| using a fast and slow pointer.\\n        const ListNode* mid = b;\\n        const ListNode* fast = b;\\n        \\n        while (fast != e && fast->next != e) {\\n            fast = fast->next->next;\\n            mid = mid->next;\\n        }\\n        \\n        return\\n            new TreeNode(\\n                mid->val,\\n                sortedListToBST(b, mid),\\n                sortedListToBST(mid->next, e));\\n    }\\n```\n```TreeNode```\n```cpp\\n    static TreeNode* sortedListToBST(const ListNode* head) {\\n        return sortedListToBST(head, 0, listSize(head));\\n    }\\n\\n    static int listSize(const ListNode* head) {\\n        int length = 0;\\n        while (head) {\\n            head = head->next;\\n            ++length;\\n        }\\n        return length;\\n    }\\n\\n    static TreeNode* sortedListToBST(const ListNode*& node, int b, int e) {\\n        if (b == e) return nullptr;\\n        \\n        const int mid = b + (e - b) / 2;\\n\\n        // Construct the left sub-tree.\\n        TreeNode* left = sortedListToBST(node, b, mid);\\n        // Consume the next node in the list.\\n        const int val = node->val;\\n        node = node->next;\\n        // Construct the right sub-tree.\\t\\t\\n        TreeNode* right = sortedListToBST(node, mid + 1, e);\\n\\n        return new TreeNode(val, left, right);\\n    }\\n```\n```std::distance()```\n```cpp\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    Iterator(ListNode* head) : curr_(head) {}\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        curr_ = curr_->next;\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    ListNode* curr_;\\n};\\n\\nstruct Iterator begin(ListNode* head) {\\n    return Iterator(head);\\n}\\n\\nstruct Iterator end(ListNode* head) {\\n    return Iterator(nullptr);\\n}\\n\\nclass Solution {\\npublic:\\n    static TreeNode* sortedListToBST(ListNode* head) {\\n        return sortedListToBST(begin(head), end(head));\\n    }\\n    \\n    template <typename iterator>\\n    static TreeNode* sortedListToBST(iterator b, iterator e) {\\n        if (b == e) return nullptr;\\n        \\n        iterator mid = next(b, distance(b, e) / 2);\\n        return\\n            new TreeNode(\\n                *mid,\\n                sortedArrayToBST(b, mid),\\n                sortedArrayToBST(next(mid), e));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194230,
                "title": "convert-sorted-list-to-bst-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to build a **height-balanced binary tree**, we need to ensure that roughly half of the total number of nodes are on either side of the root, and the only way to know what half of the total number of nodes is requires finding the total number of nodes first.\\n\\nWith this in mind, one easy solution would be to convert the linked list to an array, then we have handy access not only to the total length of the array, but also index-access to the node values, as well. At that point, we could define a **recursive** helper to build a tree from the middle node, recursively calling itself to build subtrees from the nodes on the left and right of the middle node. This option would take an **extra O(N) space** to complete.\\n\\nShould we not want to use up that much extra space, we could instead keep the linked list and lose the index-access nature of the array, using **Floyd\\'s Cycle Detection Algorithm** to easily find the middle node on each recursion step. This would, however, require iterating through parts of the linked list repeatedly, driving the **time complexity** from **O(N)** to **O(N log N)**.\\n\\nBut we can do even better: We can complete this problem in **O(N) time** with only **O(log N) extra space** (in excess of the output space).\\n\\nFirst, we\\'ll have to iterate once through the linked list to count the total number of nodes (**count**). Then, we can define our recursive helper (**treeify()**)using index numbers as our arguments. Even though we won\\'t be able to access the listnodes directly by index number, we can take advantage of an **inorder tree traversal** to force our access to go in iterative order.\\n\\nWe\\'ll need to have our list pointer (**curr**) have global scope in order to update properly via recursion. In an inorder traversal, we recursively process the left subtree, then process the middle node, then recursively process the right subtree. For this solution, we\\'ll just need to make sure we move **curr** to **curr.next** at the end of processing the middle node.\\n\\nWe can then **return** the full tree built by our recursive helper.\\n\\n - _**Time Complexity: O(N)** where **N** is the length of the linked list_\\n - _**Space Complexity: O(log N)** in excess of the space needed for the input/output, due to the recursion stack_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Python, we can store our list index pointer (**curr**) in a list to give it global scope so that it will update properly.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **92ms / 43.6MB** (beats 91% / 95%).\\n```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **120ms / 20.0MB** (beats 95% / 60%).\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 39.8MB** (beats 100% / 56%).\\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **16ms / 30.9MB** (beats 100% / 68%).\\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        curr, count = head, 0\\n        while curr:\\n            curr = curr.next\\n            count += 1\\n        def treeify(i: int, j: int) -> TreeNode:\\n            if j < i: return None\\n            mid, node = i + j >> 1, TreeNode()\\n            node.left = treeify(i, mid - 1)\\n            node.val, curr[0] = curr[0].val, curr[0].next\\n            node.right = treeify(mid + 1, j)\\n            return node\\n        curr = [head]\\n        return treeify(1, count)\\n```\n```java\\nclass Solution {\\n    ListNode curr;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr != null) {\\n            curr = curr.next;\\n            count++;\\n        }\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n    private TreeNode treeify(int i, int j) {\\n        if (j < i) return null;\\n        int mid = i + j >> 1;\\n        TreeNode node = new TreeNode();\\n        node.left = treeify(i, mid - 1);\\n        node.val = curr.val;\\n        curr = curr.next;\\n        node.right = treeify(mid + 1, j);\\n        return node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\nprivate:\\n    ListNode* curr;\\n    TreeNode* treeify(int i, int j) {\\n        if (j < i) return nullptr;\\n        int mid = (i + j) >> 1;\\n        TreeNode* node = new TreeNode();\\n        node->left = treeify(i, mid - 1);\\n        node->val = curr->val, curr = curr->next;\\n        node->right = treeify(mid + 1, j);\\n        return node;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int count = 0;\\n        curr = head;\\n        while (curr) curr = curr->next, count++;\\n        curr = head;\\n        return treeify(1, count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684494,
                "title": "c-2-different-solutions-detailed-explanation",
                "content": "**SOLUTION 1**\\n\\nTo get a height balanced tree from sorted elements, we make the middle element as the\\nroot and recurse its left and right sides for left and right subtrees respectively.\\n\\nSince we are not working with an array, we cant access a data element directly by its position\\nand hence cant use a merge sort like logic directly. So we use tortoise-hare algo to find the middle \\nnode of linked list, use that to split the list in two parts. The next node becomes the root node and \\nthe node after that becomes the head of the second list.\\n\\nT(n) = T(n/2) + O(n)\\n\\t= O(nlogn)\\nSC: O(logn), recursive stack\\n```\\n/*\\n    https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*****************************  SOLUTION 1 ************************************/\\n    \\n    // Finds floor(N/2), 1-based indexing\\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(slow && fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    // TC: O(nlogn)\\n    TreeNode* logSolution(ListNode* head) {\\n        // base case: when 0 or 1 node\\n        if(!head)\\n            return nullptr;\\n        if(!head->next)\\n            return new TreeNode(head->val);\\n        \\n        // find the middle node, use it as the end of first list\\n        ListNode *mid = findMiddle(head);\\n        // create tree node with next of middle node\\n        TreeNode* root = new TreeNode(mid->next->val);\\n        \\n        // split the two lists\\n        ListNode *second_head = (mid->next)->next;\\n        mid->next = nullptr;\\n        \\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(second_head);\\n        \\n        return root;\\n    }\\n```\\n\\n**SOLUTION 2**\\n\\nThe main time consuming part in above solution is finding the middle each time, we\\ncan actually reduce that part. The idea is to make the current head point to the middle element \\nin each recursive call with elements from [l:r]. This can be done by making the tree in inorder fashion\\nand keep a reference to the list head across all the calls. Everytime we create a node, we traverse the\\nnode by 1 step.\\nEg: index range: [1:3] and list: 1->2->3, head=1\\nWhen we reach 1([1:1]), we create 1, update head=2\\nSo when we go to the parent recursive call with limit[1:3], our head point to middle 2 and \\ncreate a node with that, head=3.\\nIn [3:3] our head =3, which is the node req. \\n\\nT(n) = T(n/2) + O(1)\\n\\t= O(n)\\nSC: O(logn), recursive stack\\n```\\n    /*************************************** SOLUTION 2 **************************/\\n    // Finds the total number of nodes in list\\n    int listCount(ListNode* head) {\\n        ListNode *curr = head;\\n        int c = 0;\\n        \\n        while(curr) {\\n            ++c;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n    \\n    // TC: O(n)\\n    // Create the tree in inorder manner.\\n    TreeNode* linearSolution(ListNode*& head, int n) {\\n        // base case: when 0 or 1 node\\n        if(n == 0)\\n            return nullptr;\\n        \\n        TreeNode *left = linearSolution(head, n/2);\\n        \\n        // create the root node\\n        TreeNode *root = new TreeNode(head->val);\\n        // go to the next node in list, so that\\n        // it will middle node in its previous call\\n        head = head->next;\\n        root->left = left;\\n        \\n        root->right = linearSolution(head, n - n/2 - 1);\\n        return root;\\n    }\\n```\\n\\n**Driver function**\\n``` \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //return logSolution(head);\\n        \\n        // find the number of nodes in list\\n        int n_nodes = listCount(head);\\n        return linearSolution(head, n_nodes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/submissions/\\n*/\\n\\nclass Solution {\\npublic:\\n    /*****************************  SOLUTION 1 ************************************/\\n    \\n    // Finds floor(N/2), 1-based indexing\\n    ListNode* findMiddle(ListNode* head) {\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(slow && fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    // TC: O(nlogn)\\n    TreeNode* logSolution(ListNode* head) {\\n        // base case: when 0 or 1 node\\n        if(!head)\\n            return nullptr;\\n        if(!head->next)\\n            return new TreeNode(head->val);\\n        \\n        // find the middle node, use it as the end of first list\\n        ListNode *mid = findMiddle(head);\\n        // create tree node with next of middle node\\n        TreeNode* root = new TreeNode(mid->next->val);\\n        \\n        // split the two lists\\n        ListNode *second_head = (mid->next)->next;\\n        mid->next = nullptr;\\n        \\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(second_head);\\n        \\n        return root;\\n    }\\n```\n```\\n    /*************************************** SOLUTION 2 **************************/\\n    // Finds the total number of nodes in list\\n    int listCount(ListNode* head) {\\n        ListNode *curr = head;\\n        int c = 0;\\n        \\n        while(curr) {\\n            ++c;\\n            curr = curr->next;\\n        }\\n        return c;\\n    }\\n    \\n    // TC: O(n)\\n    // Create the tree in inorder manner.\\n    TreeNode* linearSolution(ListNode*& head, int n) {\\n        // base case: when 0 or 1 node\\n        if(n == 0)\\n            return nullptr;\\n        \\n        TreeNode *left = linearSolution(head, n/2);\\n        \\n        // create the root node\\n        TreeNode *root = new TreeNode(head->val);\\n        // go to the next node in list, so that\\n        // it will middle node in its previous call\\n        head = head->next;\\n        root->left = left;\\n        \\n        root->right = linearSolution(head, n - n/2 - 1);\\n        return root;\\n    }\\n```\n``` \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //return logSolution(head);\\n        \\n        // find the number of nodes in list\\n        int n_nodes = listCount(head);\\n        return linearSolution(head, n_nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282008,
                "title": "explanation-with-images-easy-to-understand-simple-recursion",
                "content": "**startNode = start Node of curr Linked List\\nendNode = last Node of curr Linked List\\nnextToEndNode = next Node after end node (End of list marker)**\\n\\n![image](https://assets.leetcode.com/users/images/7b753a68-84c6-4b55-8f36-507cd2f33d10_1678497231.1457791.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* getMidNode(ListNode* start, ListNode* nextToEnd)\\n    {\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        while(fast != nextToEnd && fast->next != nextToEnd)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n    TreeNode* getRoot(ListNode* startNode, ListNode* nextToEndNode)\\n    {\\n        if (startNode == nextToEndNode) return NULL;  //Most important \\n        \\n        ListNode* midNode =  getMidNode(startNode, nextToEndNode);\\n        TreeNode* currRoot = new TreeNode(midNode->val);\\n        \\n        currRoot->left = getRoot(startNode, midNode);\\n        currRoot->right = getRoot(midNode->next, nextToEndNode);\\n        \\n        return currRoot;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head)\\n    {\\n        TreeNode* root = getRoot(head, NULL);\\n        return root;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* getMidNode(ListNode* start, ListNode* nextToEnd)\\n    {\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        while(fast != nextToEnd && fast->next != nextToEnd)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        return slow;\\n    }\\n    TreeNode* getRoot(ListNode* startNode, ListNode* nextToEndNode)\\n    {\\n        if (startNode == nextToEndNode) return NULL;  //Most important \\n        \\n        ListNode* midNode =  getMidNode(startNode, nextToEndNode);\\n        TreeNode* currRoot = new TreeNode(midNode->val);\\n        \\n        currRoot->left = getRoot(startNode, midNode);\\n        currRoot->right = getRoot(midNode->next, nextToEndNode);\\n        \\n        return currRoot;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head)\\n    {\\n        TreeNode* root = getRoot(head, NULL);\\n        return root;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779781,
                "title": "c-solutions",
                "content": "```\\n  class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            pre->next = 0; // break two halves \\n            \\n            // slow is the midpoint, use as root\\n            TreeNode* root = new TreeNode(slow->val);\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            \\n            return root;\\n        }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  class Solution {\\n    public:\\n        TreeNode *sortedListToBST(ListNode *head) {\\n            if(!head) return NULL;\\n            if(!head->next) return new TreeNode(head->val);\\n            \\n            // fast/slow pointer to find the midpoint\\n            auto slow = head;\\n            auto fast = head;\\n            auto pre = head;\\n            while(fast && fast->next) {\\n                pre = slow;\\n                slow = slow->next;\\n                fast = fast->next->next;\\n            }\\n            pre->next = 0; // break two halves \\n            \\n            // slow is the midpoint, use as root\\n            TreeNode* root = new TreeNode(slow->val);\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            \\n            return root;\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753913,
                "title": "python-recursive-solution-100-speed",
                "content": "**Python, Recursive Solution | 100% Speed**\\n\\n**A) Simple Solution using Recursion**\\n\\nThe code below presents a simple Python Solution that achieves up to 99% Speed rating on LeetCode. We simply create an array with all nodes in the Linked List that we are given, and then choose the middle node as the root. We repeat this process recursively until we build our BST (Binary Search Tree).\\n\\n```\\nclass Solution:\\n    def make(self,A):\\n        if A:\\n            m       =  len(A)//2\\n            n       =  TreeNode(A[m])\\n            n.left  = self.make(A[   :m])\\n            n.right = self.make(A[m+1:] )\\n            return n\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        return self.make(A)\\n```\\n\\n**B) Optimized Code (Array Pointers)**\\n\\nDespite the High Speed rating of Solution (A), we can note that the code copies snippets of the initial array in every function call. While this process still has O(n) time complexity overall, it\\'s more efficient to use pointers to a global array instead. The code below presents an alternative:\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        def make(i,j):\\n            if i<=j:\\n                m       =  (i+j)//2\\n                n       = TreeNode(A[m])\\n                n.left  = make(i  ,m-1)\\n                n.right = make(m+1,j  )\\n                return n\\n        return make(0, len(A)-1)\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def make(self,A):\\n        if A:\\n            m       =  len(A)//2\\n            n       =  TreeNode(A[m])\\n            n.left  = self.make(A[   :m])\\n            n.right = self.make(A[m+1:] )\\n            return n\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        return self.make(A)\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head):\\n        A, n = [], head\\n        while n:\\n            A.append(n.val)\\n            n = n.next\\n        def make(i,j):\\n            if i<=j:\\n                m       =  (i+j)//2\\n                n       = TreeNode(A[m])\\n                n.left  = make(i  ,m-1)\\n                n.right = make(m+1,j  )\\n                return n\\n        return make(0, len(A)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928048,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35636,
                "title": "my-simple-java-solution",
                "content": "\\npublic class Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        if (head == null) { return null; }\\n        if (head.next == null) { return new TreeNode(head.val); }\\n\\n        ListNode mid = head;\\n        ListNode pre_mid = null;\\n        ListNode fast = head;\\n\\n        while (true) {\\n            if (fast != null && fast.next != null) {\\n                fast = fast.next.next;\\n            } else {\\n                break;\\n            }\\n            pre_mid = mid;\\n            mid = mid.next;\\n        }\\n        if (pre_mid != null)\\n            pre_mid.next = null;\\n\\n\\n        TreeNode root = new TreeNode(mid.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(mid.next);\\n\\n        return root;\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        if (head == null) { return null; }",
                "codeTag": "Java"
            },
            {
                "id": 1194192,
                "title": "visual-explanation-simple-solution-using-recursion",
                "content": "**Approach**\\nFind middle of the list using slow and fast pointer. Finding mid will ensure that left and right subtrees are balanced. \\n\\n```\\n// find mid of the list\\nwhile (fast!=tail && fast->next!=tail) {\\n     slow = slow->next;\\n     fast = fast->next->next;\\n}\\n```\\n\\nNow after this slow will point to the middle node, which can be allocated to root of the tree, and we can do same thing for left and right of subtree.\\n\\n`head to slow : Left Tree = Left half of the list`\\n`slow->next to tail : Right Tree = Right half of the list`\\n\\nWe have shown the graphical rep of left subtree construction from half of the list, Similar happens for right list --\\n\\n![image](https://assets.leetcode.com/users/images/eaa57f11-2c0e-48c7-8d4e-07a0e7904cba_1620296733.8417244.png)\\n\\n\\nSolving furthur \\n![image](https://assets.leetcode.com/users/images/2f341b50-f1ce-432f-bee4-cdfc74c5979f_1620296769.1294112.png)\\n\\nand finally - \\n![image](https://assets.leetcode.com/users/images/daf689fe-8f94-4516-9c02-b05a3103b85c_1620296797.1408124.png)\\n\\nSimilarly for Right half, and we get the required balanced tree.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head, ListNode* tail) {\\n        \\n        if (head == tail)\\n            return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // find mid of the list\\n        while (fast!=tail && fast->next!=tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = helper(head, slow);\\n        root->right = helper(slow->next, tail);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head, NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// find mid of the list\\nwhile (fast!=tail && fast->next!=tail) {\\n     slow = slow->next;\\n     fast = fast->next->next;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head, ListNode* tail) {\\n        \\n        if (head == tail)\\n            return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        \\n        // find mid of the list\\n        while (fast!=tail && fast->next!=tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = helper(head, slow);\\n        root->right = helper(slow->next, tail);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head, NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35567,
                "title": "java-fast-slow-pointer-recursive-solution",
                "content": "        \\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null; \\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode fast = head, slow = head;\\n        if (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n        }\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode node = new TreeNode(slow.next.val);\\n        node.right = sortedListToBST(slow.next.next);\\n        slow.next = null;\\n        node.left = sortedListToBST(head);\\n        return node;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "        \\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null; \\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode fast = head, slow = head;\\n        if (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n        }\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode node = new TreeNode(slow.next.val);\\n        node.right = sortedListToBST(slow.next.next);\\n        slow.next = null;\\n        node.left = sortedListToBST(head);\\n        return node;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 35564,
                "title": "my-accepted-cpp-answer-clear-and-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            return buildTree(head,nullptr);\\n        }\\n        TreeNode* buildTree(ListNode* head, ListNode* afterLast){\\n            if(head==afterLast)\\n            return nullptr;\\n            ListNode* fast=head;\\n            ListNode* slow=head;\\n            while(fast!=afterLast&&fast->next!=afterLast){\\n                slow=slow->next;\\n                fast=fast->next->next;\\n            }\\n            TreeNode* root=new TreeNode(slow->val);\\n            root->left=buildTree(head,slow);\\n            root->right=buildTree(slow->next,afterLast);\\n            return root;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            return buildTree(head,nullptr);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3284395,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284126,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next == null) return new TreeNode(head.val);\\n        ListNode middle = getMiddle(head);\\n        TreeNode root = new TreeNode(middle.val);\\n        root.right = sortedListToBST(middle.next);\\n        middle.next =null;\\n        root.left = sortedListToBST(head);\\n        return root;\\n    }\\n    \\n    public ListNode getMiddle(ListNode head){\\n        //if(head == null || head.next==null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = null;\\n        while(fast!=null && fast.next!=null){\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n            \\n        }\\n        if(prev!=null)prev.next =null;\\n        return slow;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622424,
                "title": "find-middle-left-in-left-right-in-right-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(!head) return nullptr;\\n        \\n        if(!head->next) return new TreeNode(head->val);\\n        \\n        if(!head->next->next){\\n            TreeNode* r = new TreeNode(head->val);\\n            r->right = new TreeNode(head->next->val);\\n            return r;\\n        } \\n        \\n        ListNode*fast=head;\\n        ListNode*mid=head;\\n        ListNode*prev=mid;\\n        \\n        while(fast && fast->next){\\n             fast = fast->next->next;\\n             prev = mid;\\n             mid= mid->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(mid->val);\\n        prev->next = nullptr;\\n        root->left  = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(!head) return nullptr;\\n        \\n        if(!head->next) return new TreeNode(head->val);\\n        \\n        if(!head->next->next){\\n            TreeNode* r = new TreeNode(head->val);\\n            r->right = new TreeNode(head->next->val);\\n            return r;\\n        } \\n        \\n        ListNode*fast=head;\\n        ListNode*mid=head;\\n        ListNode*prev=mid;\\n        \\n        while(fast && fast->next){\\n             fast = fast->next->next;\\n             prev = mid;\\n             mid= mid->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(mid->val);\\n        prev->next = nullptr;\\n        root->left  = sortedListToBST(head);\\n        root->right = sortedListToBST(mid->next);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35596,
                "title": "java-1ms-solution-easy-understood-the-main-idea-of-the-solution-is-similar-to-merge-sort",
                "content": "    //The main idea of the solution is similar to merge sort.(#148 Sort List https://leetcode.com/problems/sort-list/) \\n     //Divide the sorted list into halves. \\n     //The middle of the list is root. \\n     //The left half of the list is the left child of root. \\n     //The right half of the list is the right child of root. \\n     //Then do the same to the left child and right child recursively. \\n     //Pay attention to the type: ListNode TreeNode\\n    public class Solution {\\n        public TreeNode sortedListToBST(ListNode head) {\\n            if(head==null){\\n                return null;\\n            }\\n            if(head.next==null){\\n                TreeNode treeNode=new TreeNode(head.val);\\n                return treeNode;\\n            }\\n            ListNode slow=head;\\n            ListNode fast=head.next.next;\\n            while(fast!=null&&fast.next!=null){\\n                slow=slow.next;\\n                fast=fast.next.next;\\n            }\\n            TreeNode root=new TreeNode(slow.next.val);\\n            ListNode temp=slow.next.next;\\n            slow.next=null;\\n            root.left=sortedListToBST(head);\\n            root.right=sortedListToBST(temp);\\n            return root;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode sortedListToBST(ListNode head) {\\n            if(head==null){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1884288,
                "title": "c-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        if(!head)\\n            return NULL;\\n        if(!head->next)\\n        {\\n            return new TreeNode(head->val);\\n        }\\n        ListNode *slow=head,*fast=head->next;\\n        while(fast->next&&fast->next->next)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n            \\n        }\\n        ListNode *mid=slow->next;\\n        slow->next=NULL;\\n        \\n        TreeNode *root=new TreeNode(mid->val);\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(mid->next);\\n        return root;\\n        \\n    }\\n};\\n// If you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        if(!head)\\n            return NULL;\\n        if(!head->next)\\n        {\\n            return new TreeNode(head->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1354648,
                "title": "java-easy-approach-with-explanation-o-n-log-n-dfs-postorder",
                "content": "```\\nclass Solution \\n{\\n    public TreeNode sortedListToBST(ListNode head)\\n    {//DFS(postorder)\\n        if(head == null)//base case \\n            return null;\\n        if(head.next == null)//leaf node \\n            return new TreeNode(head.val, null, null);\\n    \\n        ListNode slow, fast, mid;\\n        mid= slow= fast= head;//intializing \\n        \\n        while(fast != null && fast.next != null)//terminating condition \\n        {\\n            mid= slow;//mid is like a previous pointer \\n            slow= slow.next;//one step\\n            fast= fast.next.next;//two step\\n        }\\n        mid.next= null;//to disconnect the list \\n        \\n        int data= slow.val;//root value \\n        \\n        //breaking into partition \\n        TreeNode left= sortedListToBST(head);//left half\\n        TreeNode right= sortedListToBST(slow.next);//right half\\n        \\n        TreeNode node= new TreeNode(data, left, right);//Root node creation as their child information has been received \\n        \\n        return node;//linking the child node with the parent node \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode sortedListToBST(ListNode head)\\n    {//DFS(postorder)\\n        if(head == null)//base case \\n            return null;\\n        if(head.next == null)//leaf node \\n            return new TreeNode(head.val, null, null);\\n    \\n        ListNode slow, fast, mid;\\n        mid= slow= fast= head;//intializing \\n        \\n        while(fast != null && fast.next != null)//terminating condition \\n        {\\n            mid= slow;//mid is like a previous pointer \\n            slow= slow.next;//one step\\n            fast= fast.next.next;//two step\\n        }\\n        mid.next= null;//to disconnect the list \\n        \\n        int data= slow.val;//root value \\n        \\n        //breaking into partition \\n        TreeNode left= sortedListToBST(head);//left half\\n        TreeNode right= sortedListToBST(slow.next);//right half\\n        \\n        TreeNode node= new TreeNode(data, left, right);//Root node creation as their child information has been received \\n        \\n        return node;//linking the child node with the parent node \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387324,
                "title": "easy-peasy-python-divide-and-conquer-recursive-solution",
                "content": "\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if head is None:\\n            return None\\n        \\n        if head.next is None:\\n            return TreeNode(head.val)\\n        \\n        slow = head\\n        fast = head.next\\n        prev = None\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        if prev:\\n            prev.next = None\\n        else:\\n            head = None #means slow is still at my head\\n        \\n        node = TreeNode(slow.val)\\n        node.left = self.sortedListToBST(head)\\n        node.right = self.sortedListToBST(slow.next)\\n        \\n        return node",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if head is None:\\n            return None\\n        \\n        if head.next is None:\\n            return TreeNode(head.val)\\n        \\n        slow = head\\n        fast = head.next\\n        prev = None\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        if prev:\\n            prev.next = None\\n        else:\\n            head = None #means slow is still at my head\\n        \\n        node = TreeNode(slow.val)\\n        node.left = self.sortedListToBST(head)\\n        node.right = self.sortedListToBST(slow.next)\\n        \\n        return node",
                "codeTag": "Python3"
            },
            {
                "id": 35673,
                "title": "how-about-like-this",
                "content": "    TreeNode *sortedListToBST(ListNode *head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode *step1 = head;\\n        ListNode *step2 = head->next;\\n        while(step2->next != NULL && step2->next->next != NULL){\\n            step1 = step1->next;\\n            step2 = step2->next->next;\\n        }\\n        TreeNode *root  = new TreeNode(step1->next->val);\\n        ListNode *head2 = step1->next->next;\\n        delete step1->next;\\n        step1->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(head2);\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "    TreeNode *sortedListToBST(ListNode *head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode *step1 = head;\\n        ListNode *step2 = head->next;\\n        while(step2->next != NULL && step2->next->next != NULL){\\n            step1 = step1->next;\\n            step2 = step2->next->next;\\n        }\\n        TreeNode *root  = new TreeNode(step1->next->val);\\n        ListNode *head2 = step1->next->next;\\n        delete step1->next;\\n        step1->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(head2);\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3282617,
                "title": "fastest-solution",
                "content": "# Code\\n``` JAVA []\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```\\n\\n![upvote_me.jpeg](https://assets.leetcode.com/users/images/f7733362-6e4c-40a4-a904-407cf962ed31_1678512692.1215184.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282455,
                "title": "o-n-solution-using-concept-of-complete-binary-tree-c",
                "content": "# Intuition\\nWe know that binary search tree can be in the form of complete binary tree which is also height balanced ofc and we can also get the length of the list in O(n) time.\\nNow, as we know the no.of nodes in the tree and it is a complete binary tree, we can build the skeleton of the tree first in O(n) time.\\n\\nAfter completing the skeleton , as we have the sorted list(i.e inorder traversal of a binary tree), we can set the values of the nodes in the tree using NLR recursive approach\\n\\nPlease Dont forget to upvote !!!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* createTree(int index,int len){\\n\\n        if(index >= len) return NULL;\\n\\n        TreeNode* head = new TreeNode(-1);\\n\\n        head->left  =createTree(2*index + 1,len);\\n        head->right = createTree(2*index + 2,len);\\n\\n        return head;\\n\\n    }\\n    void buildTree(ListNode* &head,TreeNode* &tree){\\n\\n        if(!head) return ;\\n        if(!tree) return ;\\n\\n        buildTree(head,tree->left);\\n        tree->val = head->val;\\n        head = head->next;\\n        buildTree(head,tree->right);\\n\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\n        int len = 0;\\n        ListNode* ptr = head;\\n        while(ptr){\\n            len++;\\n            ptr = ptr->next;\\n        }\\n\\n        TreeNode* tree = createTree(0,len);\\n\\n        buildTree(head,tree);\\n\\n        return tree;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* createTree(int index,int len){\\n\\n        if(index >= len) return NULL;\\n\\n        TreeNode* head = new TreeNode(-1);\\n\\n        head->left  =createTree(2*index + 1,len);\\n        head->right = createTree(2*index + 2,len);\\n\\n        return head;\\n\\n    }\\n    void buildTree(ListNode* &head,TreeNode* &tree){\\n\\n        if(!head) return ;\\n        if(!tree) return ;\\n\\n        buildTree(head,tree->left);\\n        tree->val = head->val;\\n        head = head->next;\\n        buildTree(head,tree->right);\\n\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\n        int len = 0;\\n        ListNode* ptr = head;\\n        while(ptr){\\n            len++;\\n            ptr = ptr->next;\\n        }\\n\\n        TreeNode* tree = createTree(0,len);\\n\\n        buildTree(head,tree);\\n\\n        return tree;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433937,
                "title": "java-simple-solution",
                "content": "```\\npublic TreeNode sortedListToBST(ListNode head) {\\n        return toBST(head,null);\\n    }\\n    \\n    public TreeNode toBST(ListNode head, ListNode tail) {\\n        if(head == tail) return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast.next != tail && fast.next.next != tail) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode n = new TreeNode(slow.val);\\n        n.left = toBST(head, slow);\\n        n.right = toBST(slow.next, tail);\\n        return n;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode sortedListToBST(ListNode head) {\\n        return toBST(head,null);\\n    }\\n    \\n    public TreeNode toBST(ListNode head, ListNode tail) {\\n        if(head == tail) return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast.next != tail && fast.next.next != tail) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        TreeNode n = new TreeNode(slow.val);\\n        n.left = toBST(head, slow);\\n        n.right = toBST(slow.next, tail);\\n        return n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195125,
                "title": "c-in-order-traversal-solution-explained-100-time-70-space",
                "content": "The base idea is to find the middle of our linked list, then cut it out of said list, create a `TreeNode` with it and have as `left` and `right` branches what we would get recursively calling `sortedListToBST` with the first and second chunk of the list respectively.\\n\\nWe will also need a base case to stop our recursion, which is what we are going to do first for when we have `0 - 1` nodes, in which case we will `return`:\\n* `new TreeNode(head->val)` for when we have a sole element;\\n* just `NULL` for when we have no elements in the list.\\n\\nWith that out of the way, we can now focus on finding the middle of the list; to do so, we will need a couple more variables, both being `ListNode` pointers:\\n* `turtle` will be initialised to be `head`;\\n* `hare` will be initialised to be `head->next->next`  (since we want `turtle` to stop one step before the mid, we are giving `hare`a headstart).\\n\\nWe will then proceed to loop as long as `hare && hare->next`, advancing `turtle` by one step and `hare` by two steps.\\n\\nOnce done, we will have `turtle` pointing at the node right before the middle, so we can assign the middle itself to `hare` and then cut it out of the list; similarly, we can now assign the node right after the middle to `turtle` (since the second chunk of the list will start from there) and then again cut it out of the list.\\n\\nAll that is left to do, it so create a new `TreeNode` with `hare->val` as value for the root and the recursive calls `sortedListToBST(head)` and `sortedListToBST(turtle)` to generate its `left` and `right` branches respectively :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        // base case: 0 - 1 nodes\\n        if (!head || !head->next) return head ? new TreeNode(head->val) : NULL;\\n        // support variables\\n        ListNode *turtle = head, *hare = head->next->next;\\n        // finding the middle\\n        while (hare && hare->next) {\\n            turtle = turtle->next;\\n            hare = hare->next->next;\\n        }\\n        // turtle is no pre-mid, so we set hare to be the mid, and we cut it\\n        hare = turtle->next;\\n        turtle->next = NULL;\\n        // we now set turtle to be the head of the right branch and we cut it too\\n        turtle = hare->next;\\n        hare->next = NULL;\\n        return new TreeNode(hare->val, sortedListToBST(head), sortedListToBST(turtle));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        // base case: 0 - 1 nodes\\n        if (!head || !head->next) return head ? new TreeNode(head->val) : NULL;\\n        // support variables\\n        ListNode *turtle = head, *hare = head->next->next;\\n        // finding the middle\\n        while (hare && hare->next) {\\n            turtle = turtle->next;\\n            hare = hare->next->next;\\n        }\\n        // turtle is no pre-mid, so we set hare to be the mid, and we cut it\\n        hare = turtle->next;\\n        turtle->next = NULL;\\n        // we now set turtle to be the head of the right branch and we cut it too\\n        turtle = hare->next;\\n        hare->next = NULL;\\n        return new TreeNode(hare->val, sortedListToBST(head), sortedListToBST(turtle));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191945,
                "title": "convert-sorted-list-to-binary-search-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find the length of the linked list.\\n2. Define a helper function that takes a start and end index and constructs a subtree from the linked list.\\n3. Recursively construct the left and right subtrees by calling the helper function with the appropriate indices.\\n4. Return the root of the constructed tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def getLength(head: ListNode) -> int:\\n            length = 0\\n            while head:\\n                length += 1\\n                head = head.next\\n            return length\\n\\n        def buildBST(start: int, end: int) -> TreeNode:\\n            nonlocal head\\n\\n            if start > end:\\n                return None\\n\\n            mid = (start + end) // 2\\n            left = buildBST(start, mid - 1)\\n            root = TreeNode(head.val)\\n            head = head.next\\n            right = buildBST(mid + 1, end)\\n            root.left = left\\n            root.right = right\\n            return root\\n\\n        length = getLength(head)\\n        return buildBST(0, length - 1)\\n\\n```\\nIn the helper function buildBST, we use the nonlocal keyword to access and modify the head variable from the enclosing function. The mid variable is computed as the average of the start and end indices, and we recursively construct the left and right subtrees by passing in the appropriate start and end indices. Finally, we create the root node and connect it to the left and right subtrees.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree"
                ],
                "code": "```\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def getLength(head: ListNode) -> int:\\n            length = 0\\n            while head:\\n                length += 1\\n                head = head.next\\n            return length\\n\\n        def buildBST(start: int, end: int) -> TreeNode:\\n            nonlocal head\\n\\n            if start > end:\\n                return None\\n\\n            mid = (start + end) // 2\\n            left = buildBST(start, mid - 1)\\n            root = TreeNode(head.val)\\n            head = head.next\\n            right = buildBST(mid + 1, end)\\n            root.left = left\\n            root.right = right\\n            return root\\n\\n        length = getLength(head)\\n        return buildBST(0, length - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886094,
                "title": "turtle-and-hare-approach-100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev;\\n        while(fast!= NULL and fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        prev->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev;\\n        while(fast!= NULL and fast->next!=NULL){\\n            fast = fast->next->next;\\n            prev = slow;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        prev->next = NULL;\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670792,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        prev = slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        prev.next = None \\n        return TreeNode(slow.val,self.sortedListToBST(head),self.sortedListToBST(slow.next)) \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        prev = slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        prev.next = None \\n        return TreeNode(slow.val,self.sortedListToBST(head),self.sortedListToBST(slow.next)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 35582,
                "title": "13-lines-concise-and-easy-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode* fast = head, * slow = head, * pre = NULL;\\n            while(fast && fast->next){\\n                fast = fast->next->next;\\n                pre = slow;\\n                slow = slow->next;\\n            }\\n            TreeNode* root = new TreeNode(slow->val);\\n            if(pre != NULL) pre->next = NULL;\\n            else head = NULL;\\n            root->left = sortedListToBST(head);\\n            root->right = sortedListToBST(slow->next);\\n            return root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode* fast = head, * slow = head, * pre = NULL;\\n            while(fast && fast->next){\\n                fast = fast->next->next;\\n                pre = slow;\\n                slow = slow->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 35609,
                "title": "easy-java-solution",
                "content": "\\n\\n\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n        HashMap<Integer,TreeNode> map = new HashMap<Integer,TreeNode>();\\n\\t\\tListNode p ;\\n\\t\\t\\n\\t\\tint i = 0;\\n\\t\\tfor(p=head ; p!=null ; p = p.next){\\n\\t\\t\\tmap.put(i, new TreeNode(p.val));\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn buildTree(map,0,i-1);\\n    }\\n    \\n\\n    public static TreeNode buildTree(HashMap<Integer,TreeNode> map, int start , int end){\\n\\t\\tif(start<=end){\\n\\t\\t\\tint mid = (start+end)/2;\\n\\t\\t\\tTreeNode t = map.get(mid);\\n\\t\\t\\tt.left = buildTree(map,start,mid-1);\\n\\t\\t\\tt.right = buildTree(map,mid+1,end);\\n\\t\\t\\treturn t;\\n\\t\\t}\\n\\t\\telse return null;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n        HashMap<Integer,TreeNode> map = new HashMap<Integer,TreeNode>();\\n\\t\\tListNode p ;\\n\\t\\t\\n\\t\\tint i = 0;\\n\\t\\tfor(p=head ; p!=null ; p = p.next){\\n\\t\\t\\tmap.put(i, new TreeNode(p.val));\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn buildTree(map,0,i-1);\\n    }\\n    \\n\\n    public static TreeNode buildTree(HashMap<Integer,TreeNode> map, int start , int end){\\n\\t\\tif(start<=end){\\n\\t\\t\\tint mid = (start+end)/2;\\n\\t\\t\\tTreeNode t = map.get(mid);\\n\\t\\t\\tt.left = buildTree(map,start,mid-1);\\n\\t\\t\\tt.right = buildTree(map,mid+1,end);\\n\\t\\t\\treturn t;\\n\\t\\t}\\n\\t\\telse return null;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3282214,
                "title": "simple-c-fully-explained-solution-o-n-recursive",
                "content": "# Intuition\\nThe list provided is sorted in ascending order, and if we perform an inorder traversal of a binary search tree (BST), the resulting traversal will also be sorted in ascending order. This is because the in-order traversal of a BST visits the nodes in ascending order of their values. Therefore, the resulting traversal of a BST constructed from a sorted list will also be in ascending order.\\n\\n---\\n\\n\\n# Approach\\nTo construct a binary search tree (BST) from a sorted list, we can use a recursive algorithm that repeatedly divides the list into two halves using the middle element as the pivot. Within the recursive function (which we can call solver() in our case), we first find the middle point of the current list and create a new TreeNode with its value. We then call solver() again with the left part of the list as the input to construct the left subtree of the current node and the right part of the list as the input to construct the right subtree of the current node. By repeating this process recursively, we can construct the entire BST.\\n\\n- See code for further uderstanding\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(n)**\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* solver(vector<int> &vect, int start, int end){\\n        if(start>end) return nullptr;\\n        int mid = (start+end)/2;\\n        TreeNode* curr = new TreeNode(vect[mid]);\\n        curr->left = solver(vect,start,mid-1);\\n        curr->right = solver(vect,mid+1,end);\\n        return curr;\\n\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = 0;\\n        ListNode* h = head;\\n        vector<int> vect;\\n        while(h){\\n            vect.push_back(h->val);\\n            h = h->next;\\n        }\\n        if(vect.size()==0) return nullptr;\\n        TreeNode*  res = solver(vect,0,vect.size()-1);\\n        return res;\\n    }\\n};\\n```\\n\\n\\nPlease upvote if it helped you.",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* solver(vector<int> &vect, int start, int end){\\n        if(start>end) return nullptr;\\n        int mid = (start+end)/2;\\n        TreeNode* curr = new TreeNode(vect[mid]);\\n        curr->left = solver(vect,start,mid-1);\\n        curr->right = solver(vect,mid+1,end);\\n        return curr;\\n\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = 0;\\n        ListNode* h = head;\\n        vector<int> vect;\\n        while(h){\\n            vect.push_back(h->val);\\n            h = h->next;\\n        }\\n        if(vect.size()==0) return nullptr;\\n        TreeNode*  res = solver(vect,0,vect.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282150,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getArray(ListNode* head){\\n        vector<int> ans;\\n        while(head){\\n            ans.push_back(head->val);\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n    TreeNode* createBinarySearchTree(TreeNode* root,vector<int>& arr,int s,int e){\\n        if(s>e) return NULL;\\n        int mid=s+(e-s)/2;\\n        root=new TreeNode(arr[mid]);\\n        root->left=createBinarySearchTree(root->left,arr,s,mid-1);\\n        root->right=createBinarySearchTree(root->right,arr,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root=NULL;\\n        vector<int> arr=getArray(head);\\n        return createBinarySearchTree(root,arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Divide and Conquer",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getArray(ListNode* head){\\n        vector<int> ans;\\n        while(head){\\n            ans.push_back(head->val);\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n    TreeNode* createBinarySearchTree(TreeNode* root,vector<int>& arr,int s,int e){\\n        if(s>e) return NULL;\\n        int mid=s+(e-s)/2;\\n        root=new TreeNode(arr[mid]);\\n        root->left=createBinarySearchTree(root->left,arr,s,mid-1);\\n        root->right=createBinarySearchTree(root->right,arr,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root=NULL;\\n        vector<int> arr=getArray(head);\\n        return createBinarySearchTree(root,arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281942,
                "title": "using-recusion-easiest-solution-beginner-friendly-detailed-explanation",
                "content": "# Intuition\\nUse the concept of divide and conquer.\\n# Approach\\n1. first take two linkedlist pointer head and tail, where initialize tail to NULL.\\n2. check head or next of head is null or not, if it is null then return null or create an node and return it.\\n3. find mid node in linked list, for the root of binry tree.\\n4. then create root node of mid.\\n5. for left of root, call head to mid by recursion = solve(head,mid).\\n6. for right of root, call mid->next to tail by recursion = solve(mid->next,tail).\\n7. At last return root.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(ListNode* head, ListNode* tail)\\n    {\\n        if(head == tail)\\n            return NULL;\\n        \\n        if(head->next == tail)\\n        {\\n            TreeNode* root = new TreeNode(head->val);\\n            return root;\\n        }\\n        ListNode *mid = head,*temp = head;\\n        while(temp!=tail && temp->next!=tail)\\n        {\\n            mid = mid->next;\\n            temp = temp->next->next;\\n        }\\n        TreeNode* root = new TreeNode(mid->val);\\n        root->left = solve(head,mid);\\n        root->right = solve(mid->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        return solve(head,NULL);    \\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/28c24656-d151-49a4-aca1-8268bf2f4a69_1678493866.3012052.png)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(ListNode* head, ListNode* tail)\\n    {\\n        if(head == tail)\\n            return NULL;\\n        \\n        if(head->next == tail)\\n        {\\n            TreeNode* root = new TreeNode(head->val);\\n            return root;\\n        }\\n        ListNode *mid = head,*temp = head;\\n        while(temp!=tail && temp->next!=tail)\\n        {\\n            mid = mid->next;\\n            temp = temp->next->next;\\n        }\\n        TreeNode* root = new TreeNode(mid->val);\\n        root->left = solve(head,mid);\\n        root->right = solve(mid->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) \\n    {\\n        return solve(head,NULL);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528095,
                "title": "easy-understanding-solution-c",
                "content": "Contructing tree using vector to store list values and then construct BST using the same with binary search to construct tree\\n```\\nclass Solution {\\npublic:\\n    TreeNode* maketree(vector<int>& vec, int start, int end)\\n    {\\n        if(start==end) return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = new TreeNode(vec[mid]);\\n        \\n        root->left = maketree(vec, start, mid);\\n        root->right =  maketree(vec, mid+1, end);\\n        \\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        if(!head) return NULL;\\n        for(auto temp = head; temp!=NULL; temp = temp->next)\\n        {\\n            vec.push_back(temp->val);\\n        }\\n        TreeNode* root = maketree(vec, 0, vec.size());\\n        \\n        return root;\\n    }\\n};\\n```\\nPlease UPVOTE if liked the solution. Thank you",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* maketree(vector<int>& vec, int start, int end)\\n    {\\n        if(start==end) return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = new TreeNode(vec[mid]);\\n        \\n        root->left = maketree(vec, start, mid);\\n        root->right =  maketree(vec, mid+1, end);\\n        \\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        if(!head) return NULL;\\n        for(auto temp = head; temp!=NULL; temp = temp->next)\\n        {\\n            vec.push_back(temp->val);\\n        }\\n        TreeNode* root = maketree(vec, 0, vec.size());\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431891,
                "title": "easy-solution-2-approach-1-using-vector-2-linked-list-c",
                "content": "**Using Vector to store elements and then convert it into BST**\\nUsing mid element and then appending it as a root , similarily for the left and right part , after that recursion will handle all the stuffs.\\n```\\nTreeNode* solve(vector<int>&v,int s ,int e){\\n        if(s>e) return nullptr;\\n        int mid  = s+(e-s)/2;\\n        TreeNode* root = new TreeNode (v[mid]);\\n        root->left = solve(v,s,mid-1);\\n        root->right = solve(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        int s=0;\\n        int e=v.size()-1;\\n        return solve(v,s,e);\\n    }\\n```\\n\\n**Using Linked List Fast and Slow Pointer** \\nUsing Fast and slow Pointer to find the middle element and append it as root , similarily do for right and left node and rest leave on recursion.\\n```\\nTreeNode* solve(ListNode* head, ListNode* tail){\\n        if(head==tail) return nullptr;\\n        ListNode* fast = head , * slow = head;\\n        while(fast!=tail and fast->next!=tail){\\n            fast = fast->next;\\n            if(fast->next) fast = fast->next;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = solve(head,slow);\\n        root->right = solve(slow->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode* tail = NULL;\\n        return solve(head,tail);\\n    }\\n```\\n\\n**Do upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* solve(vector<int>&v,int s ,int e){\\n        if(s>e) return nullptr;\\n        int mid  = s+(e-s)/2;\\n        TreeNode* root = new TreeNode (v[mid]);\\n        root->left = solve(v,s,mid-1);\\n        root->right = solve(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        int s=0;\\n        int e=v.size()-1;\\n        return solve(v,s,e);\\n    }\\n```\n```\\nTreeNode* solve(ListNode* head, ListNode* tail){\\n        if(head==tail) return nullptr;\\n        ListNode* fast = head , * slow = head;\\n        while(fast!=tail and fast->next!=tail){\\n            fast = fast->next;\\n            if(fast->next) fast = fast->next;\\n            slow = slow->next;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = solve(head,slow);\\n        root->right = solve(slow->next,tail);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode* tail = NULL;\\n        return solve(head,tail);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2010993,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic class Solution {\\npublic TreeNode sortedListToBST(ListNode head) {\\n    if(head==null) return null;\\n    return toBST(head,null);\\n}\\npublic TreeNode toBST(ListNode head, ListNode tail){\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==tail) return null;\\n    \\n    while(fast!=tail&&fast.next!=tail){\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    TreeNode thead = new TreeNode(slow.val);\\n    thead.left = toBST(head,slow);\\n    thead.right = toBST(slow.next,tail);\\n    return thead;\\n}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n    \\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef sortedListToBST(self, head):\\n    if not head:\\n        return \\n    if not head.next:\\n        return TreeNode(head.val)\\n    # here we get the middle point,\\n    # even case, like \\'1234\\', slow points to \\'2\\',\\n    # \\'3\\' is root, \\'12\\' belongs to left, \\'4\\' is right\\n    # odd case, like \\'12345\\', slow points to \\'2\\', \\'12\\'\\n    # belongs to left, \\'3\\' is root, \\'45\\' belongs to right\\n    slow, fast = head, head.next.next\\n    while fast and fast.next:\\n        fast = fast.next.next\\n        slow = slow.next\\n    # tmp points to root\\n    tmp = slow.next\\n    # cut down the left child\\n    slow.next = None\\n    root = TreeNode(tmp.val)\\n    root.left = self.sortedListToBST(head)\\n    root.right = self.sortedListToBST(tmp.next)\\n    return root\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nfun sortedListToBST(head: ListNode?): TreeNode? {\\n        val N = size(head) // size of LL\\n        if (N == 0) return null\\n        if (N == 1) return TreeNode(head!!.`val`)\\n        val A = IntArray(N) // LL data in array\\n        populate(A, head) // fill the array\\n        return construct(head, A, 0, N - 1)\\n    }\\n    \\n    private fun construct(head: ListNode?, A: IntArray, start: Int, end: Int): TreeNode? {\\n        if (start > end) return null\\n        val mid = (start + end) / 2\\n        val root = TreeNode(A[mid])\\n        root.left = construct(head, A, start, mid - 1)\\n        root.right = construct(head, A, mid + 1, end)\\n        return root\\n    }\\n    \\n    private fun size(head: ListNode?): Int {\\n        if (head == null) return 0\\n        if (head.next == null) return 1\\n        var ans = 0\\n        var node = head\\n        while (node != null) {\\n            ans++\\n            node = node.next\\n        }\\n        return ans\\n    }\\n    \\n    private fun populate(A: IntArray, head: ListNode?) {\\n        var node = head\\n        for (i in A.indices) {\\n            A[i] = node!!.`val`\\n            node = node?.next\\n        }\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic class Solution {\\npublic TreeNode sortedListToBST(ListNode head) {\\n    if(head==null) return null;\\n    return toBST(head,null);\\n}\\npublic TreeNode toBST(ListNode head, ListNode tail){\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    if(head==tail) return null;\\n    \\n    while(fast!=tail&&fast.next!=tail){\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    TreeNode thead = new TreeNode(slow.val);\\n    thead.left = toBST(head,slow);\\n    thead.right = toBST(slow.next,tail);\\n    return thead;\\n}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n    \\n};\\n```\n```\\n```\n```\\n```\n```\\ndef sortedListToBST(self, head):\\n    if not head:\\n        return \\n    if not head.next:\\n        return TreeNode(head.val)\\n    # here we get the middle point,\\n    # even case, like \\'1234\\', slow points to \\'2\\',\\n    # \\'3\\' is root, \\'12\\' belongs to left, \\'4\\' is right\\n    # odd case, like \\'12345\\', slow points to \\'2\\', \\'12\\'\\n    # belongs to left, \\'3\\' is root, \\'45\\' belongs to right\\n    slow, fast = head, head.next.next\\n    while fast and fast.next:\\n        fast = fast.next.next\\n        slow = slow.next\\n    # tmp points to root\\n    tmp = slow.next\\n    # cut down the left child\\n    slow.next = None\\n    root = TreeNode(tmp.val)\\n    root.left = self.sortedListToBST(head)\\n    root.right = self.sortedListToBST(tmp.next)\\n    return root\\n```\n```\\n```\n```\\n```\n```\\nvar sortedListToBST = function(head) {\\n    let curr = head, count = 0\\n    while (curr) curr = curr.next, count++\\n    const treeify = (i, j) => {\\n        if (j < i) return null\\n        let mid = i + j >> 1, node = new TreeNode()\\n        node.left = treeify(i, mid - 1)\\n        node.val = curr.val, curr = curr.next\\n        node.right = treeify(mid + 1, j)\\n        return node\\n    }\\n    curr = head\\n    return treeify(1, count)\\n};\\n```\n```\\n```\n```\\n```\n```\\nfun sortedListToBST(head: ListNode?): TreeNode? {\\n        val N = size(head) // size of LL\\n        if (N == 0) return null\\n        if (N == 1) return TreeNode(head!!.`val`)\\n        val A = IntArray(N) // LL data in array\\n        populate(A, head) // fill the array\\n        return construct(head, A, 0, N - 1)\\n    }\\n    \\n    private fun construct(head: ListNode?, A: IntArray, start: Int, end: Int): TreeNode? {\\n        if (start > end) return null\\n        val mid = (start + end) / 2\\n        val root = TreeNode(A[mid])\\n        root.left = construct(head, A, start, mid - 1)\\n        root.right = construct(head, A, mid + 1, end)\\n        return root\\n    }\\n    \\n    private fun size(head: ListNode?): Int {\\n        if (head == null) return 0\\n        if (head.next == null) return 1\\n        var ans = 0\\n        var node = head\\n        while (node != null) {\\n            ans++\\n            node = node.next\\n        }\\n        return ans\\n    }\\n    \\n    private fun populate(A: IntArray, head: ListNode?) {\\n        var node = head\\n        for (i in A.indices) {\\n            A[i] = node!!.`val`\\n            node = node?.next\\n        }\\n    }\\n```\n```\\n```\n```\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func sortedListToBST(_ head: ListNode?) -> TreeNode? {\\n        var nums: [ListNode] = []\\n        var curr = head\\n        \\n        while curr != nil {\\n            nums.append(curr!)\\n            curr = curr?.next\\n        }\\n        \\n        return sortedArrayToBST(nums)\\n    }\\n    \\n    \\n    func sortedArrayToBST(_ nums: [ListNode]) -> TreeNode? {\\n        let count = nums.count\\n        guard count > 0 else { return nil }\\n        \\n        let rootIndex = count / 2\\n        let root = TreeNode(nums[rootIndex].val)\\n        \\n        root.left = rootIndex > 0 ? sortedArrayToBST(Array(nums[0..<rootIndex])) : nil\\n        root.right = rootIndex < count - 1 ? sortedArrayToBST(Array(nums[rootIndex + 1..<count])) : nil\\n        return root\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315253,
                "title": "java-ez-approach-beats-100",
                "content": "Hopefully u will find it useful!\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        return listToBST(head, null);\\n    }\\n    private TreeNode listToBST(ListNode head, ListNode tail) {\\n        if (head == null || head == tail) return null;\\n        ListNode mid = findMid(head, tail);\\n        TreeNode root = new TreeNode(mid.val);\\n        root.left = listToBST(head, mid);\\n        root.right = listToBST(mid.next, tail);\\n        return root;\\n    }\\n    private ListNode findMid(ListNode head, ListNode tail) {\\n        ListNode l1 = head, l2 = head;\\n        while (l2 != tail && l2.next != tail) {\\n            l1 = l1.next;\\n            l2 = l2.next.next;\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        return listToBST(head, null);\\n    }\\n    private TreeNode listToBST(ListNode head, ListNode tail) {\\n        if (head == null || head == tail) return null;\\n        ListNode mid = findMid(head, tail);\\n        TreeNode root = new TreeNode(mid.val);\\n        root.left = listToBST(head, mid);\\n        root.right = listToBST(mid.next, tail);\\n        return root;\\n    }\\n    private ListNode findMid(ListNode head, ListNode tail) {\\n        ListNode l1 = head, l2 = head;\\n        while (l2 != tail && l2.next != tail) {\\n            l1 = l1.next;\\n            l2 = l2.next.next;\\n        }\\n        return l1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502147,
                "title": "easy-to-understand-javascript-solution",
                "content": "Though this might look a bit confusing at first, I think it is ultimately easier to remember because the code is so short and nothing is ambiguous. It might be hard to imagine the traversal state on the spot though.\\n\\n1. Find the mid point by counting length of the list\\n2. Traverse left subtree using the midpoint as your upper bound\\n3. Set left subtree to the midpoint root.left\\n4. Shift head to the next element\\n5. Traverse right subtree with the new head (length of list - number of nodes in the left subtree - root)\\n6. Set right subtree to root.right\\n```\\nvar sortedListToBST = function(head) {\\n    const numOfNodes = countNodes(head)\\n    return traverse(numOfNodes)\\n    \\n    function traverse(n) {\\n        if (n <= 0) return null\\n        \\n        const left = traverse(Math.floor(n / 2))\\n        const root = new TreeNode(head.val)       \\n        root.left = left\\n        head = head.next\\n        root.right = traverse(n - Math.floor(n / 2) - 1)\\n        \\n        return root\\n    }\\n    \\n    function countNodes(node) {\\n        if (!node) return 0\\n        return 1 + countNodes(node.next)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortedListToBST = function(head) {\\n    const numOfNodes = countNodes(head)\\n    return traverse(numOfNodes)\\n    \\n    function traverse(n) {\\n        if (n <= 0) return null\\n        \\n        const left = traverse(Math.floor(n / 2))\\n        const root = new TreeNode(head.val)       \\n        root.left = left\\n        head = head.next\\n        root.right = traverse(n - Math.floor(n / 2) - 1)\\n        \\n        return root\\n    }\\n    \\n    function countNodes(node) {\\n        if (!node) return 0\\n        return 1 + countNodes(node.next)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488205,
                "title": "javascript-solution",
                "content": "### The idea\\n1. in order to create a balanced BST from sorted numbers, the best approach is to take the middle number as the subtree root value and do so for every subtree. \\n\\n### O(NlogN) Solution\\n``` javascript\\nvar sortedListToBST1 = function(head) {\\n    \\n    let recur = function(listNode) {\\n        if (listNode == null) return null;\\n        \\n        let slow = listNode, fast = listNode, leftTail = null, leftHead = listNode;\\n        while(fast.next && fast.next.next) {\\n            leftTail = slow;\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        \\n        let root = new TreeNode(slow.val);\\n        let rightHead = slow.next;\\n\\n        if (leftTail == null) leftHead = null;\\n        else leftTail.next = null;\\n        \\n        \\n        root.left = recur(leftHead);\\n        root.right = recur(rightHead);\\n        \\n        return root;\\n    }\\n    \\n    return recur(head);\\n};\\n```\\n\\n### O(N) Solution\\n``` javascript \\nvar sortedListToBST2 = function(head) {\\n    let nums = [];\\n    while(head) {\\n        nums.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    let recur = function(left, right){\\n        if (left > right) return null;\\n        let mid = left + parseInt((right - left) / 2);\\n        let root = new TreeNode(nums[mid]);\\n        if (left == right) return root;\\n        root.left = recur(left, mid - 1);\\n        root.right = recur(mid + 1, right);\\n        return root;\\n    }\\n    \\n    return recur(0, nums.length-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar sortedListToBST1 = function(head) {\\n    \\n    let recur = function(listNode) {\\n        if (listNode == null) return null;\\n        \\n        let slow = listNode, fast = listNode, leftTail = null, leftHead = listNode;\\n        while(fast.next && fast.next.next) {\\n            leftTail = slow;\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        \\n        let root = new TreeNode(slow.val);\\n        let rightHead = slow.next;\\n\\n        if (leftTail == null) leftHead = null;\\n        else leftTail.next = null;\\n        \\n        \\n        root.left = recur(leftHead);\\n        root.right = recur(rightHead);\\n        \\n        return root;\\n    }\\n    \\n    return recur(head);\\n};\\n```\n``` javascript \\nvar sortedListToBST2 = function(head) {\\n    let nums = [];\\n    while(head) {\\n        nums.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    let recur = function(left, right){\\n        if (left > right) return null;\\n        let mid = left + parseInt((right - left) / 2);\\n        let root = new TreeNode(nums[mid]);\\n        if (left == right) return root;\\n        root.left = recur(left, mid - 1);\\n        root.right = recur(mid + 1, right);\\n        return root;\\n    }\\n    \\n    return recur(0, nums.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463758,
                "title": "2-python-solution-top-down-bottom-up-with-detailed-explanation-as-tree-traversal",
                "content": "I read some answers with top votes treat the different approach as top-down / bottom up.\\nFor the top-down method which starts from root, it is eaiser to understand: we find the mid point first and convert to a root, then place the left subtree, and finally place the right subtree.\\nA trick here I think is interesting is using the \"slow & fast pointers\", which help us avoid converting the linked list to array first.\\nThe solution I have referred to is from @caikehe: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/35474/Python-recursive-solution-with-detailed-comments-(operate-linked-list-directly).\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        \\n        slow, fast = head, head.next.next \\n    \\n        # Note the initialization part: slow = 0, fast = 2\\n\\t\\t# we do this to make the slower pointers \\u3010stop before the mid point\\u3011\\n        # -> slow + steps = n // 2 - 1; fast + 2*steps = 2 + n - 2 = n\\n        # examples:\\n        # n = 2m:   1, 2, 3, 4 -> A[2] = 3\\n        #           slow -> (index) 1; fast -> null, exit the loop\\n        #     \\n        # n = 2m-1: 1, 2, 3, 4, 5 -> A[2] = 3\\n        #           slow -> 1; fast -> 5, fast.next == null, exit the loop\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        tmp = slow.next\\n        # get the previous half lists off\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        \\n        return root\\n```\\n\\nThen I found I have difficulty in understanding what does \"bottom-up\" mean. After writing the code and seeing the test cases, I realize that it may be easier to understand \"bottom-up\" as \"pre-order\". Corresponding, \"top-down\" actually means \\'in-order\". Here is my code modified with reference to @caikehe: https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/35526/Python-solutions-(convert-to-array-first-top-down-approach-bottom-up-approach)\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        \\n        def convert(start, end):\\n            if start > end:\\n                return None\\n            mid = (start + end) >> 1\\n            l = convert(start, mid - 1)\\n            nonlocal head\\n            root = TreeNode(head.val)\\n            root.left = l\\n            head = head.next\\n            root.right = convert(mid + 1, end)\\n            return root\\n        \\n        return convert(0, l - 1)\\n```\\n\\nAs the code shows, we place the left subtree first, then root, and finally the right tree. Note that \"bottom-up\" does mean we deal with leave nodes first, but it may not be the smallest node.\\nFor example, run the code with given array [-10, -3, 0, 5, 9], we will get a tree as:\\n\\n![image](https://assets.leetcode.com/users/aglover/image_1577590529.png)\\n\\nThe code will start from the range [0, 4] -> deal with the left part [0, 1], currently head= -10, then we continue to deal with the left part, finding the range change to [0, -1] since mid =0. Then we generate a new tree node -10, place the left child of node -10 to be None, move the head to -3. then deal with the right part, with the range [1, 1] In this way, we place the left subtree. Similar process for the right part.\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head: return None\\n        if not head.next: return TreeNode(head.val)\\n        \\n        slow, fast = head, head.next.next \\n    \\n        # Note the initialization part: slow = 0, fast = 2\\n\\t\\t# we do this to make the slower pointers \\u3010stop before the mid point\\u3011\\n        # -> slow + steps = n // 2 - 1; fast + 2*steps = 2 + n - 2 = n\\n        # examples:\\n        # n = 2m:   1, 2, 3, 4 -> A[2] = 3\\n        #           slow -> (index) 1; fast -> null, exit the loop\\n        #     \\n        # n = 2m-1: 1, 2, 3, 4, 5 -> A[2] = 3\\n        #           slow -> 1; fast -> 5, fast.next == null, exit the loop\\n        \\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        tmp = slow.next\\n        # get the previous half lists off\\n        slow.next = None\\n        root = TreeNode(tmp.val)\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(tmp.next)\\n        \\n        return root\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        l, p = 0, head\\n        while p:\\n            l += 1\\n            p = p.next\\n        \\n        def convert(start, end):\\n            if start > end:\\n                return None\\n            mid = (start + end) >> 1\\n            l = convert(start, mid - 1)\\n            nonlocal head\\n            root = TreeNode(head.val)\\n            root.left = l\\n            head = head.next\\n            root.right = convert(mid + 1, end)\\n            return root\\n        \\n        return convert(0, l - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169275,
                "title": "java-2-solutions-o-n-o-nlogn-solutions-with-explanation",
                "content": "Soultion-1:\\nTime Complexity O(nlogn) which n is size of the List - 1ms beats 100%\\nIn this solution, we construct from root to leaves;\\nThe first solution is using SLOW and FAST method.\\nWhenever we reach to fast==null || fast.next==null it means slow node is at the middle of the list. We keep track of the prev node which is prev.next=slow to set the prev.next==null.\\nStart to prev is going to be our left node(s) \\nSlow is going to be our Root Node\\nSlow.next to fast is going to be our right node(s)\\nWe keep doing that till read all the values in the list.\\n```\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\tif(head==null) return null;\\n\\t\\tif(head.next==null) return new TreeNode(head.val);\\n\\t\\tListNode slow=head, fast=head,prev=null;\\n\\t\\twhile(fast!=null && fast.next!=null){\\n\\t\\t\\tprev=slow;\\n\\t\\t\\tslow=slow.next;\\n\\t\\t\\tfast=fast.next.next;\\n\\t\\t}\\n\\t\\tprev.next=null;\\n\\t\\tTreeNode root = new TreeNode(slow.val);\\n\\t\\troot.left=sortedListToBST(head);\\n\\t\\troot.right=sortedListToBST(slow.next);\\n\\t\\treturn root;\\n    } \\n```\\nSoultion-2:\\nTime Complexity O(n) which n is size of the List - 1ms beats 100%\\nIn this solution, we construct from leaves to root;\\nWe first count the number of nodes in our list.\\nWe build left nodes which is from 0 to n/2\\nThen after building the left side, we create the root which is n/2 node\\nand then we build the right nodes which is from n/2+1 till n\\n```\\n\\tListNode head=null;\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\t int size=0;\\n\\t\\t ListNode curr = head;\\n\\t\\t while(curr!=null){\\n\\t\\t\\tsize++;\\n\\t\\t\\tcurr=curr.next;\\n\\t\\t }\\t\\t \\n\\t\\t this.head=head;\\n\\t\\t return sortedListToBST(0,size);\\n\\t } \\n\\tTreeNode sortedListToBST(int start, int end){\\n\\t\\tif(start>=end) return null; \\n\\t\\t if(start+1==end) {\\n\\t\\t\\t TreeNode node = new TreeNode(head.val);\\n\\t\\t\\t head=head.next; \\n\\t\\t\\t return node;\\n\\t\\t }\\n\\t\\tint middle = (start+end)/2; \\n\\t\\tTreeNode left = sortedListToBST(start,middle); \\n\\t\\tTreeNode root = sortedListToBST(middle, middle+1);  \\n\\t\\tTreeNode right = sortedListToBST(middle+1,end);\\n\\t\\troot.left=left; root.right=right;\\t\\t\\n\\t\\t \\n\\t\\treturn root;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\tif(head==null) return null;\\n\\t\\tif(head.next==null) return new TreeNode(head.val);\\n\\t\\tListNode slow=head, fast=head,prev=null;\\n\\t\\twhile(fast!=null && fast.next!=null){\\n\\t\\t\\tprev=slow;\\n\\t\\t\\tslow=slow.next;\\n\\t\\t\\tfast=fast.next.next;\\n\\t\\t}\\n\\t\\tprev.next=null;\\n\\t\\tTreeNode root = new TreeNode(slow.val);\\n\\t\\troot.left=sortedListToBST(head);\\n\\t\\troot.right=sortedListToBST(slow.next);\\n\\t\\treturn root;\\n    } \\n```\n```\\n\\tListNode head=null;\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\t\\t int size=0;\\n\\t\\t ListNode curr = head;\\n\\t\\t while(curr!=null){\\n\\t\\t\\tsize++;\\n\\t\\t\\tcurr=curr.next;\\n\\t\\t }\\t\\t \\n\\t\\t this.head=head;\\n\\t\\t return sortedListToBST(0,size);\\n\\t } \\n\\tTreeNode sortedListToBST(int start, int end){\\n\\t\\tif(start>=end) return null; \\n\\t\\t if(start+1==end) {\\n\\t\\t\\t TreeNode node = new TreeNode(head.val);\\n\\t\\t\\t head=head.next; \\n\\t\\t\\t return node;\\n\\t\\t }\\n\\t\\tint middle = (start+end)/2; \\n\\t\\tTreeNode left = sortedListToBST(start,middle); \\n\\t\\tTreeNode root = sortedListToBST(middle, middle+1);  \\n\\t\\tTreeNode right = sortedListToBST(middle+1,end);\\n\\t\\troot.left=left; root.right=right;\\t\\t\\n\\t\\t \\n\\t\\treturn root;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35515,
                "title": "javascript-solution-using-dfs",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {TreeNode}\\n */\\nvar sortedListToBST = function(head) {\\n    if (!head) { return null; }\\n    \\n    return helper(head, null);\\n};\\n\\nvar helper = function(head, tail) {\\n    if (head === tail) { return null; }\\n    \\n    let slow = head;\\n    let fast = head;\\n    while (fast !== tail && fast.next !== tail) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    \\n    let root = new TreeNode(slow.val);\\n    root.left = helper(head, slow);\\n    root.right = helper(slow.next, tail);\\n\\n    return root; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {TreeNode}\\n */\\nvar sortedListToBST = function(head) {\\n    if (!head) { return null; }\\n    \\n    return helper(head, null);\\n};\\n\\nvar helper = function(head, tail) {\\n    if (head === tail) { return null; }\\n    \\n    let slow = head;\\n    let fast = head;\\n    while (fast !== tail && fast.next !== tail) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    \\n    let root = new TreeNode(slow.val);\\n    root.left = helper(head, slow);\\n    root.right = helper(slow.next, tail);\\n\\n    return root; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35586,
                "title": "o-n-c-code-without-breakdowning-listnode-into-two-halves",
                "content": "   we can use variable `size` to control the subtree size, and use in-order traversal to construct the BST.\\n\\n     class Solution {\\n        public:\\n            TreeNode* sortedListToBST(ListNode* head) {\\n                int size=0;\\n                ListNode *save=head;\\n                while(head){\\n                    size++;\\n                    head = head->next;\\n                }\\n                head = save;\\n                TreeNode* root = helper(head,size);\\n        \\t\\treturn root;\\n            }\\n            TreeNode* helper(ListNode*& head,int size){\\n                if(head==NULL ||size<=0) return NULL;\\n        \\t\\tint rightSize = (size-1)/2; \\n        \\t\\tTreeNode* left = helper(head,size-1-rightSize);\\n        \\t\\tTreeNode* root = new TreeNode(head->val);\\n        \\t\\thead = head->next;\\n        \\t\\troot->left = left;\\n        \\t\\troot->right = helper(head,rightSize);\\n                return root;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            TreeNode* sortedListToBST(ListNode* head) {\\n                int size=0;\\n                ListNode *save=head;\\n                while(head){\\n                    size++;\\n                    head = head->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3283377,
                "title": "python-divide-in-middle-and-recursion-of-left-and-right-parts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert form middle of list\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDivide list in middle\\nCreate `TreeNode` with middle and recursion of left and right part\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#   def __init__(self, val=0, next=None):\\n#     self.val = val\\n#     self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#   def __init__(self, val=0, left=None, right=None):\\n#     self.val = val\\n#     self.left = left\\n#     self.right = right\\n\\nclass Solution:\\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n    if not head: return None\\n    prev = node = mid = head\\n    while node and node.next:\\n      prev = mid\\n      mid = mid.next\\n      node = node.next.next\\n    if head == mid:\\n      return TreeNode(mid.val)\\n    prev.next = None # cul left part of List\\n    return TreeNode(mid.val, self.sortedListToBST(head), self.sortedListToBST(mid.next))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#   def __init__(self, val=0, next=None):\\n#     self.val = val\\n#     self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#   def __init__(self, val=0, left=None, right=None):\\n#     self.val = val\\n#     self.left = left\\n#     self.right = right\\n\\nclass Solution:\\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n    if not head: return None\\n    prev = node = mid = head\\n    while node and node.next:\\n      prev = mid\\n      mid = mid.next\\n      node = node.next.next\\n    if head == mid:\\n      return TreeNode(mid.val)\\n    prev.next = None # cul left part of List\\n    return TreeNode(mid.val, self.sortedListToBST(head), self.sortedListToBST(mid.next))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282812,
                "title": "approach-explained-with-example-divide-conquer-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way to solve this problem is by recursively dividing the linked list into two halves and assigning the middle element as the root of the BST. \\n\\n# Example\\n\\n```\\n linked list: -10 -> -7 -> -4 -> 0 -> 5 -> 8 -> 10\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b1870610-10b1-4b8b-a27f-9d1a35a399d6_1678516149.0537305.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function takes a linked list as input and returns a pointer to the root of the BST. It first checks if the input head is NULL. If it is, then the function returns NULL. If the head points to the last element in the list, then the function creates a new node with the value of the head and returns it.\\n\\nIf the list has more than one element, then the function uses a two-pointer technique to find the middle element of the list. The fast pointer moves two nodes at a time, while the slow pointer moves one node at a time. When the fast pointer reaches the end of the list, the slow pointer points to the middle element. The function creates a new node with the value of the middle element and assigns it to the root of the BST.\\n\\nThe function then recursively constructs the left subtree of the BST using the help function with the first half of the linked list. Similarly, the function recursively constructs the right subtree of the BST using the help function with the second half of the linked list.\\n\\nFinally, the function returns the root of the constructed BST.\\n\\n# Complexity\\n- Time complexity: The time complexity is **O(nlogn)**, where n is the number of nodes in the linked list. This is because the function recursively constructs a balanced BST, where each node is visited only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the is **O(logn)**, where n is the number of nodes in the linked list. This is because the function recursively constructs a balanced BST, where the maximum height of the BST is logn.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* help(ListNode* head){\\n        if(!head)return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n\\n        ListNode *pre=NULL, *slow=head, *fast=head; //slow is to store the middle value\\n\\n        while(fast and fast->next){\\n            pre=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        pre->next=NULL; // this breaks the linkedlist into two parts\\n        TreeNode* root=new TreeNode(slow->val); // mid value is assigned to the root\\n        root->left=help(head); //recursively build the left subtree using head to mid-1\\n        root->right=help(slow->next); //recursively build the right subtree using mid+1 to end\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return help(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n linked list: -10 -> -7 -> -4 -> 0 -> 5 -> 8 -> 10\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* help(ListNode* head){\\n        if(!head)return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n\\n        ListNode *pre=NULL, *slow=head, *fast=head; //slow is to store the middle value\\n\\n        while(fast and fast->next){\\n            pre=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        pre->next=NULL; // this breaks the linkedlist into two parts\\n        TreeNode* root=new TreeNode(slow->val); // mid value is assigned to the root\\n        root->left=help(head); //recursively build the left subtree using head to mid-1\\n        root->right=help(slow->next); //recursively build the right subtree using mid+1 to end\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return help(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282006,
                "title": "awesome-logic-and-made-me-passionate-on-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head==None:\\n            return None\\n        if head.next==None:\\n            return TreeNode(head.val)\\n        slow,fast=head,head.next\\n        while fast.next and fast.next.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        mid=slow.next\\n        slow.next=None\\n        root=TreeNode(mid.val)\\n        root.left=self.sortedListToBST(head)\\n        root.right=self.sortedListToBST(mid.next)\\n        return root\\n    #please upvote me it would encourage me alot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head==None:\\n            return None\\n        if head.next==None:\\n            return TreeNode(head.val)\\n        slow,fast=head,head.next\\n        while fast.next and fast.next.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        mid=slow.next\\n        slow.next=None\\n        root=TreeNode(mid.val)\\n        root.left=self.sortedListToBST(head)\\n        root.right=self.sortedListToBST(mid.next)\\n        return root\\n    #please upvote me it would encourage me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455904,
                "title": "python-recursive",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        \\n        def root(l):\\n            if l != []:\\n                mid =len(l)//2\\n                node = TreeNode(l[mid])\\n                node.left = root(l[:mid])\\n                node.right = root(l[mid+1:])\\n                return node\\n            else:\\n                return None\\n            \\n        l = []\\n        while(head):\\n            l.append(head.val)\\n            head = head.next\\n        return root(l)`\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        \\n        def root(l):\\n            if l != []:\\n                mid =len(l)//2\\n                node = TreeNode(l[mid])\\n                node.left = root(l[:mid])\\n                node.right = root(l[mid+1:])\\n                return node\\n            else:\\n                return None\\n            \\n        l = []\\n        while(head):\\n            l.append(head.val)\\n            head = head.next\\n        return root(l)`\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295332,
                "title": "c-cleanest-code-easiest-to-understand",
                "content": "Saw a lot of solutions which are not beginner friendly and a beginner might easily stumble upon these solutions and feel overwhelmed.So,I wrote a beginner friendly code which is easiest to understand.\\n**Method:**\\nUse the method of fast and slow pointer fast/slow to locate to the midpoint of the chain table, which is the root node, and then cut the ListNode before the midpoint. The left subtree of the root node can call sortedListToBST(head) recursively, and the right subtree can call sortedListToBST(slow-next) recursively.\\n**Edge cases:**\\nIn order to break the ListNode before the midpoint, you need to set a temp to hold the old value of the slow pointer.\\nNote the recursive boundary conditions too,\\nfirstly **(head==NULL)** must be handled separately.\\nSecondly **(head->next==NULL)** also need to be treated separately\\nThe last **(head->next->next==NULL)** also needs to be handled separately *because in this case the fast pointer cannot be advanced and the midpoint of the chain table cannot be located.*\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\t//edge cases\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return new TreeNode(head->val);\\n        }\\n        if(head->next->next==NULL){\\n             TreeNode* root=new TreeNode(head->val);\\n            root->right=new TreeNode(head->next->val);\\n            return root;\\n        }\\n\\t\\t//main code\\n        ListNode *fast,*slow,*temp;\\n        fast=head,slow=head;\\n        while(fast->next and fast->next->next){\\n            temp=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n\\t//edge cases\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            return new TreeNode(head->val);\\n        }\\n        if(head->next->next==NULL){\\n             TreeNode* root=new TreeNode(head->val);\\n            root->right=new TreeNode(head->next->val);\\n            return root;\\n        }\\n\\t\\t//main code\\n        ListNode *fast,*slow,*temp;\\n        fast=head,slow=head;\\n        while(fast->next and fast->next->next){\\n            temp=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=sortedListToBST(head);\\n        root->right=sortedListToBST(slow->next);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652776,
                "title": "100-fast-java",
                "content": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next==null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = null;\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n}\\n```\\n\\nIf you are looking for solution: <a href = \"https://github.com/Devn913/leetcode\">GIthub Repo</a>\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next==null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = null;\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525470,
                "title": "using-recursion-and-slow-fast-approach-in-c",
                "content": "class Solution {\\npublic:\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return makebst(head,NULL);\\n    }\\n    TreeNode* makebst(ListNode* head, ListNode* tail){\\n        if(head==tail){\\n            return NULL;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=makebst(head,slow);\\n        root->right=makebst(slow->next,tail);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return makebst(head,NULL);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1416071,
                "title": "recursion-c-easy-and-straight-forward-asked-in-google-interview",
                "content": "This question has been asked in google interview.\\n\\n* First i found the middle element in the list using floyd algorithm.\\n* then i kept a track of node one before the middle element *say temp*\\n* i made a treeNode with the middle element *say root*\\n* then root->left =function(temp);\\n\\troot->right=function(tortoise->next);\\n\\t\\n\\t\\n\\n\\n\\n```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)\\n        {\\n            TreeNode* t=new TreeNode(head->val);\\n            return t;\\n        }   \\n        ListNode* hare=head;\\n        ListNode* temp=head;\\n        ListNode* tortoise=head;\\n        while(hare!=NULL && hare->next!=NULL )\\n        {\\n            hare=hare->next->next;\\n            temp=tortoise;\\n            tortoise=tortoise->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(tortoise->val);\\n        root->left=sortedListToBST(head);        \\n       root->right=sortedListToBST(tortoise->next);\\n        return root;\\n    }\\n```\\n\\n\\n**please upvote if you liked my solution.\\n#happy_coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)\\n        {\\n            TreeNode* t=new TreeNode(head->val);\\n            return t;\\n        }   \\n        ListNode* hare=head;\\n        ListNode* temp=head;\\n        ListNode* tortoise=head;\\n        while(hare!=NULL && hare->next!=NULL )\\n        {\\n            hare=hare->next->next;\\n            temp=tortoise;\\n            tortoise=tortoise->next;\\n        }\\n        temp->next=NULL;\\n        TreeNode* root=new TreeNode(tortoise->val);\\n        root->left=sortedListToBST(head);        \\n       root->right=sortedListToBST(tortoise->next);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388255,
                "title": "java-0ms-easy-to-understand-solution",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n    if(head == null) return null;\\n    ListNode slow = head, fast = head, slowPre = null;\\n    while(fast.next != null && fast.next.next != null){\\n      slowPre = slow;\\n      slow = slow.next;\\n      fast = fast.next.next;\\n    }\\n\\n    if(slowPre != null) slowPre.next = null;\\n    if(slow == null) return null;\\n    TreeNode node = new TreeNode(slow.val);\\n    if(head != slow)node.left = sortedListToBST(head);\\n    node.right = sortedListToBST(slow.next);\\n    return node;\\n  }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n    if(head == null) return null;\\n    ListNode slow = head, fast = head, slowPre = null;\\n    while(fast.next != null && fast.next.next != null){\\n      slowPre = slow;\\n      slow = slow.next;\\n      fast = fast.next.next;\\n    }\\n\\n    if(slowPre != null) slowPre.next = null;\\n    if(slow == null) return null;\\n    TreeNode node = new TreeNode(slow.val);\\n    if(head != slow)node.left = sortedListToBST(head);\\n    node.right = sortedListToBST(slow.next);\\n    return node;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370438,
                "title": "golang-recursive-solution-o-n-o-1",
                "content": "``` go\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil {\\n        return nil\\n    }\\n    \\n    prev, turtle, hare := head, head, head\\n\\n    for hare != nil && hare.Next != nil {\\n        hare = hare.Next.Next\\n        prev = turtle\\n        turtle = turtle.Next\\n    }\\n\\n    res := &TreeNode{ Val : turtle.Val, }\\n    \\n    if turtle.Next != nil {\\n        res.Right = sortedListToBST(turtle.Next)\\n    }\\n\\n    if prev.Next != nil {\\n        prev.Next = nil\\n        res.Left = sortedListToBST(head)\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "``` go\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil {\\n        return nil\\n    }\\n    \\n    prev, turtle, hare := head, head, head\\n\\n    for hare != nil && hare.Next != nil {\\n        hare = hare.Next.Next\\n        prev = turtle\\n        turtle = turtle.Next\\n    }\\n\\n    res := &TreeNode{ Val : turtle.Val, }\\n    \\n    if turtle.Next != nil {\\n        res.Right = sortedListToBST(turtle.Next)\\n    }\\n\\n    if prev.Next != nil {\\n        prev.Next = nil\\n        res.Left = sortedListToBST(head)\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229306,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return newBST(head,NULL);\\n    }\\n    TreeNode* newBST(ListNode* head, ListNode* tail){\\n        if(head==tail)\\n            return NULL;\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast != tail &&fast->next != tail){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        root->left=newBST(head,slow);\\n        root->right=newBST(slow->next,tail);\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return newBST(head,NULL);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1195386,
                "title": "java-simple-and-easy-to-understand-solution-t-o-n-s-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        //covert lindked list to Array List\\n        List<Integer> list = getList(head);\\n        \\n        return getTree(list, 0, list.size() - 1);\\n    }\\n    \\n    private List<Integer> getList(ListNode head){\\n        List<Integer> list = new ArrayList();\\n        \\n        ListNode curr = head;\\n        while(curr != null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private TreeNode getTree(List<Integer> list, int l, int r){\\n        //Invalid case\\n        if(l > r) return null;\\n        \\n        //Leaf node, no child\\n        if(l == r) return new TreeNode(list.get(l));\\n        \\n        //Mid index\\n        int mid = l + ((r - l) / 2);\\n        \\n        //Create node using mid value\\n        TreeNode root = new TreeNode(list.get(mid));\\n        \\n        //Left child\\n        root.left = getTree(list, l, mid - 1);\\n        \\n        //Right child\\n        root.right = getTree(list, mid + 1, r);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        //covert lindked list to Array List\\n        List<Integer> list = getList(head);\\n        \\n        return getTree(list, 0, list.size() - 1);\\n    }\\n    \\n    private List<Integer> getList(ListNode head){\\n        List<Integer> list = new ArrayList();\\n        \\n        ListNode curr = head;\\n        while(curr != null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        return list;\\n    }\\n    \\n    private TreeNode getTree(List<Integer> list, int l, int r){\\n        //Invalid case\\n        if(l > r) return null;\\n        \\n        //Leaf node, no child\\n        if(l == r) return new TreeNode(list.get(l));\\n        \\n        //Mid index\\n        int mid = l + ((r - l) / 2);\\n        \\n        //Create node using mid value\\n        TreeNode root = new TreeNode(list.get(mid));\\n        \\n        //Left child\\n        root.left = getTree(list, l, mid - 1);\\n        \\n        //Right child\\n        root.right = getTree(list, mid + 1, r);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194315,
                "title": "rust-recursive-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut len = 0;\\n        let mut node = &head;\\n        while let Some(n) = node {\\n            len += 1;\\n            node = &n.next;\\n        }\\n        let mut head = head;\\n        Self::helper(&mut head, len)\\n    }\\n    fn helper(list: &mut Option<Box<ListNode>>, len: usize) -> Option<Rc<RefCell<TreeNode>>> {\\n        if len == 0 {\\n            return None;\\n        }\\n        let left = Self::helper(list, len / 2);\\n        if let Some(head) = list {\\n            let mut node = TreeNode::new(head.val);\\n            *list = head.next.take();\\n            node.left = left;\\n            node.right = Self::helper(list, len - len / 2 - 1);\\n            Some(Rc::new(RefCell::new(node)))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        let mut len = 0;\\n        let mut node = &head;\\n        while let Some(n) = node {\\n            len += 1;\\n            node = &n.next;\\n        }\\n        let mut head = head;\\n        Self::helper(&mut head, len)\\n    }\\n    fn helper(list: &mut Option<Box<ListNode>>, len: usize) -> Option<Rc<RefCell<TreeNode>>> {\\n        if len == 0 {\\n            return None;\\n        }\\n        let left = Self::helper(list, len / 2);\\n        if let Some(head) = list {\\n            let mut node = TreeNode::new(head.val);\\n            *list = head.next.take();\\n            node.left = left;\\n            node.right = Self::helper(list, len - len / 2 - 1);\\n            Some(Rc::new(RefCell::new(node)))\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540242,
                "title": "avl-tree-solution",
                "content": "it\\'s a bit weird in this way ,but somehow intresting too:)\\nAVL tree remains balance by  four kind of roations during insertion or deletion,what rotation we choose is based on the position relationship of the unbalanced node and the inserted node.\\n## in the problem we always insert to the tree with a increasing sequence,so just need a simple left rotation to rebalance the tree.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> heights;//the given node has not height attribute\\n    \\n    TreeNode* leftRotation(TreeNode* A){\\n        TreeNode* B=A->right;\\n        A->right=B->left;\\n        B->left=A;\\n        updateHeight(A);\\n        updateHeight(B);\\n        return B;\\n    }\\n    int getHeight(TreeNode* t){\\n        if(!t) return -1;\\n        return heights[t];\\n    }\\n    int updateHeight(TreeNode* t){\\n       return heights[t]=max(getHeight(t->left),getHeight(t->right))+1;\\n    }\\n    TreeNode* insert(TreeNode* root,int x){\\n        if(!root){\\n            auto ans = new TreeNode(x);\\n            heights[ans]=0;\\n            return ans;\\n        }\\n        else if(x>root->val){\\n            root->right=insert(root->right,x);\\n            if(getHeight(root->right)-getHeight(root->left)==2){\\n                root=leftRotation(root);\\n            }\\n        }\\n        updateHeight(root);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        auto p=head;\\n        TreeNode* root=NULL;\\n        while(p){\\n            root=insert(root,p->val);\\n            p=p->next;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,int> heights;//the given node has not height attribute\\n    \\n    TreeNode* leftRotation(TreeNode* A){\\n        TreeNode* B=A->right;\\n        A->right=B->left;\\n        B->left=A;\\n        updateHeight(A);\\n        updateHeight(B);\\n        return B;\\n    }\\n    int getHeight(TreeNode* t){\\n        if(!t) return -1;\\n        return heights[t];\\n    }\\n    int updateHeight(TreeNode* t){\\n       return heights[t]=max(getHeight(t->left),getHeight(t->right))+1;\\n    }\\n    TreeNode* insert(TreeNode* root,int x){\\n        if(!root){\\n            auto ans = new TreeNode(x);\\n            heights[ans]=0;\\n            return ans;\\n        }\\n        else if(x>root->val){\\n            root->right=insert(root->right,x);\\n            if(getHeight(root->right)-getHeight(root->left)==2){\\n                root=leftRotation(root);\\n            }\\n        }\\n        updateHeight(root);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        auto p=head;\\n        TreeNode* root=NULL;\\n        while(p){\\n            root=insert(root,p->val);\\n            p=p->next;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199162,
                "title": "javascript-97",
                "content": "https://www.geeksforgeeks.org/sorted-array-to-balanced-bst/\\n\\nBasic idea is traverse the linked list and create an array, then use binary search algorithm to recursively generate the left and right nodes...\\n\\n```\\nvar sortedListToBST = function(head) {\\n    if(!head) return null;\\n    \\n    const sorted = [];\\n    \\n    let cur = head;\\n    \\n    while(cur) {\\n        sorted.push(cur.val);\\n        \\n        cur = cur.next;\\n    }\\n    \\n    const generate = (l, r) => {\\n        if(l > r) return null;\\n        \\n        const mid = Math.floor((r+l)/2);\\n    \\n        let val = sorted[mid];\\n        \\n        const node = new TreeNode(val);\\n\\n        node.left = generate(l, mid-1);\\n        node.right = generate(mid + 1, r);\\n        \\n        return node;\\n    };\\n    \\n    return generate(0, sorted.length-1);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sortedListToBST = function(head) {\\n    if(!head) return null;\\n    \\n    const sorted = [];\\n    \\n    let cur = head;\\n    \\n    while(cur) {\\n        sorted.push(cur.val);\\n        \\n        cur = cur.next;\\n    }\\n    \\n    const generate = (l, r) => {\\n        if(l > r) return null;\\n        \\n        const mid = Math.floor((r+l)/2);\\n    \\n        let val = sorted[mid];\\n        \\n        const node = new TreeNode(val);\\n\\n        node.left = generate(l, mid-1);\\n        node.right = generate(mid + 1, r);\\n        \\n        return node;\\n    };\\n    \\n    return generate(0, sorted.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35588,
                "title": "sharing-my-28ms-c-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            else if(head->next == NULL)\\n                return (new TreeNode(head->val));\\n            \\n            ListNode* fast = head->next->next;\\n            ListNode* slow = head;\\n            while(fast && fast->next)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n            }\\n            \\n            TreeNode* tree = new TreeNode(slow->next->val);\\n            tree->right = sortedListToBST(slow->next->next);\\n            slow->next = NULL;\\n            tree->left = sortedListToBST(head);\\n            \\n            return tree;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* sortedListToBST(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            else if(head->next == NULL)\\n                return (new TreeNode(head->val));\\n            \\n            ListNode* fast = head->next->next;\\n            ListNode* slow = head;\\n            while(fast && fast->next)\\n            {\\n                fast = fast->next->next;\\n                slow = slow->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 35558,
                "title": "divide-conquer-java-solution-complexity",
                "content": "The question is what is time complexity? \\n\\n    public class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        \\n        ListNode slow = head, fast = head.next;\\n        while(fast!=null&&fast.next!=null&&fast.next.next!=null){\\n            fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        \\n        TreeNode root = new TreeNode(slow.next.val);\\n        \\n        \\n        ListNode second=slow.next.next;\\n        slow.next=null;\\n        \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(second);\\n        \\n        return root;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        \\n        ListNode slow = head, fast = head.next;\\n        while(fast!=null&&fast.next!=null&&fast.next.next!=null){\\n            fast=fast.next.next;\\n            slow=slow.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3513899,
                "title": "c-easy-solution-beats-82-4-time-35-50-space",
                "content": "![image.png](https://assets.leetcode.com/users/images/cf5f4ba5-2a84-47cb-af10-3d36c8a18112_1683842127.922867.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (head == nullptr)\\n        {\\n            return nullptr;\\n        }\\n        vector<int> result = LinkedList_TO_Array(head);\\n\\n        return TreeBuilder(result, 0, result.size() - 1);\\n    }\\n\\n    vector<int> LinkedList_TO_Array(ListNode *head)\\n    {\\n        vector<int> result;\\n        while (head != nullptr)\\n        {\\n            result.push_back(head->val);\\n            head = head->next;\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *TreeBuilder(vector<int> &array, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return nullptr;\\n        }\\n        int mid = (left + right) / 2;\\n        TreeNode *root = new TreeNode(array[mid]);\\n        root->left = TreeBuilder(array, left, mid - 1);\\n        root->right = TreeBuilder(array, mid + 1, right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        if (head == nullptr)\\n        {\\n            return nullptr;\\n        }\\n        vector<int> result = LinkedList_TO_Array(head);\\n\\n        return TreeBuilder(result, 0, result.size() - 1);\\n    }\\n\\n    vector<int> LinkedList_TO_Array(ListNode *head)\\n    {\\n        vector<int> result;\\n        while (head != nullptr)\\n        {\\n            result.push_back(head->val);\\n            head = head->next;\\n        }\\n        return result;\\n    }\\n\\n    TreeNode *TreeBuilder(vector<int> &array, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return nullptr;\\n        }\\n        int mid = (left + right) / 2;\\n        TreeNode *root = new TreeNode(array[mid]);\\n        root->left = TreeBuilder(array, left, mid - 1);\\n        root->right = TreeBuilder(array, mid + 1, right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364616,
                "title": "java-easy-solution-using-slow-fast-concept-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode convert(ListNode head){\\n          if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val) ;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        \\n        TreeNode root=new TreeNode(slow.next.val);\\n        ListNode right1=slow.next.next;\\n        slow.next=null;\\n        root.left=convert(head);\\n        root.right=convert(right1);\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n        TreeNode root=convert(head);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode convert(ListNode head){\\n          if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val) ;\\n        \\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        \\n        TreeNode root=new TreeNode(slow.next.val);\\n        ListNode right1=slow.next.next;\\n        slow.next=null;\\n        root.left=convert(head);\\n        root.right=convert(right1);\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n        TreeNode root=convert(head);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285353,
                "title": "c-fully-explained-simple-divide-and-conquer",
                "content": "```\\n/*\\nIntution Algorithm : Recursion to make BST with Divide and conquer technique\\n\\nFirst thing need to understand is there is multiple answer available because we do not have to make complete BST we just have to make BST that\\'s said which follows the rule for basic BST like parent should be greater than child and left child shuld smaller than parent and right child should be greater than its parent.\\nSteps:\\n    1. We divide whole array in two parts and mid one will our root like eg. [1,-10,-3,0,4,5,9]  0 out root and {1,-10, -3} on left, and {4,5,9} on right\\n    2. Now again if we take left {1, -10, -3} which connected from its parent 0, the root of left will again same procedure the root is -10 and {1} on left and {-3} on right\\n    3. Now again if we go right side we have {1} which itself be a root and no other left or right after making next call it will fall into base case and return null as left and right of 1\\n    4. Same procedures right sides nodes\\n\\nIf you finds my solution useFull please do upvote\\n\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\n\\n//  Definition for singly-linked list.\\n/*  struct ListNode {\\n     int val;\\n     ListNode *next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n };\\n\\n// Definition for a binary tree node.\\n struct TreeNode {\\n     int val;\\n     TreeNode *left;\\n     TreeNode *right;\\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n }; */\\n\\nclass Solution\\n{\\npublic:\\n    TreeNode *makeBst(vector<int> &nodes, int l, int h)\\n    {\\n        if (l > h)\\n            return NULL;\\n        int mid = l + (h - l) / 2;\\n        TreeNode *root = new TreeNode(nodes[mid]);\\n        root->left = makeBst(nodes, l, mid - 1);\\n        root->right = makeBst(nodes, mid + 1, h);\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        vector<int> nodes;\\n        ListNode *curr = head;\\n        while (curr)\\n        {\\n            nodes.emplace_back(curr->val);\\n            curr = curr->next;\\n        }\\n        return makeBst(nodes, 0, nodes.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/*\\nIntution Algorithm : Recursion to make BST with Divide and conquer technique\\n\\nFirst thing need to understand is there is multiple answer available because we do not have to make complete BST we just have to make BST that\\'s said which follows the rule for basic BST like parent should be greater than child and left child shuld smaller than parent and right child should be greater than its parent.\\nSteps:\\n    1. We divide whole array in two parts and mid one will our root like eg. [1,-10,-3,0,4,5,9]  0 out root and {1,-10, -3} on left, and {4,5,9} on right\\n    2. Now again if we take left {1, -10, -3} which connected from its parent 0, the root of left will again same procedure the root is -10 and {1} on left and {-3} on right\\n    3. Now again if we go right side we have {1} which itself be a root and no other left or right after making next call it will fall into base case and return null as left and right of 1\\n    4. Same procedures right sides nodes\\n\\nIf you finds my solution useFull please do upvote\\n\\n */\\n/* ====>>> Solution for Leetcode <<<=====  */\\n\\n//  Definition for singly-linked list.\\n/*  struct ListNode {\\n     int val;\\n     ListNode *next;\\n     ListNode() : val(0), next(nullptr) {}\\n     ListNode(int x) : val(x), next(nullptr) {}\\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n };\\n\\n// Definition for a binary tree node.\\n struct TreeNode {\\n     int val;\\n     TreeNode *left;\\n     TreeNode *right;\\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n }; */\\n\\nclass Solution\\n{\\npublic:\\n    TreeNode *makeBst(vector<int> &nodes, int l, int h)\\n    {\\n        if (l > h)\\n            return NULL;\\n        int mid = l + (h - l) / 2;\\n        TreeNode *root = new TreeNode(nodes[mid]);\\n        root->left = makeBst(nodes, l, mid - 1);\\n        root->right = makeBst(nodes, mid + 1, h);\\n        return root;\\n    }\\n\\n    TreeNode *sortedListToBST(ListNode *head)\\n    {\\n        vector<int> nodes;\\n        ListNode *curr = head;\\n        while (curr)\\n        {\\n            nodes.emplace_back(curr->val);\\n            curr = curr->next;\\n        }\\n        return makeBst(nodes, 0, nodes.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284878,
                "title": "easy-solution-and-implementation-of-fully-explained-approach",
                "content": "# Intuition\\nTo convert a singly linked list to a height-balanced binary search tree, we need to find the middle element of the list and use it as the root of the tree. We can recursively apply this process to the left and right halves of the list to construct the left and right subtrees of the root.\\n\\n# Approach\\nIn this implementation, we use two pointers slow and fast to find the middle element of the list. We also keep track of the previous node prev so that we can split the list into two halves.\\n\\nOnce we have found the middle element, we create a new TreeNode with its value and recursively construct the left and right subtrees using the left and right halves of the list.\\n\\nNote that we handle the base cases where the list is empty or contains only one element separately, since in these cases the tree has only one node.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode(head->val);\\n\\n        // Find the middle element of the list\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Split the list in two halves\\n        prev->next = nullptr;\\n\\n        // Create the root of the tree\\n        TreeNode* root = new TreeNode(slow->val);\\n\\n        // Recursively construct the left and right subtrees\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode(head->val);\\n\\n        // Find the middle element of the list\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Split the list in two halves\\n        prev->next = nullptr;\\n\\n        // Create the root of the tree\\n        TreeNode* root = new TreeNode(slow->val);\\n\\n        // Recursively construct the left and right subtrees\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284224,
                "title": "c-easy-recursive-solution-o-n-time-complexity",
                "content": "# Intuition\\nBST is a Tree in which the left children are smaller than the root and right children are greater than the root. We can convert the linked list into a array and traverse it recursively using two pointers.\\n\\n# Approach\\nWe convert the Linkedlist into a array and we use two pointers `l` and `r` to split the array into two parts. We convert the middle element into a node of BST. We then recursively traverse the two splits and make them the left and right child respectively for our `mid` node.We return when `l`\\'s position becomes greater than `r`.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& nums,int l,int r){\\n        if(r<l) return NULL;\\n        int mid = l + (r-l)/2;\\n        TreeNode* root = new TreeNode(nums[mid]);\\n        root->left = helper(nums,l,mid-1);\\n        root->right = helper(nums,mid+1,r);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> nums;\\n        while(head!=NULL){\\n            nums.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        return helper(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& nums,int l,int r){\\n        if(r<l) return NULL;\\n        int mid = l + (r-l)/2;\\n        TreeNode* root = new TreeNode(nums[mid]);\\n        root->left = helper(nums,l,mid-1);\\n        root->right = helper(nums,mid+1,r);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> nums;\\n        while(head!=NULL){\\n            nums.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        return helper(nums,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283965,
                "title": "go-python-o-n-log-n-time-o-log-n-time",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n*log(n))$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil{\\n        return nil\\n    }\\n    if head.Next == nil{\\n        return &TreeNode{head.Val,nil,nil}\\n    }\\n    prev := head\\n    slow := head.Next\\n    fast := head.Next.Next\\n    \\n    for fast != nil && fast.Next != nil{\\n        prev = slow\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    prev.Next = nil\\n    root := TreeNode{slow.Val,nil,nil}\\n\\n    root.Left = sortedListToBST(head)\\n    root.Right = sortedListToBST(slow.Next)\\n    return &root\\n}\\n```\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n\\n        prev = head\\n        slow = head.next\\n        fast = head.next.next\\n\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        prev.next = None\\n        root = TreeNode(slow.val)\\n\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(slow.next)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Two Pointers",
                    "Divide and Conquer",
                    "Binary Search Tree"
                ],
                "code": "```golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n    if head == nil{\\n        return nil\\n    }\\n    if head.Next == nil{\\n        return &TreeNode{head.Val,nil,nil}\\n    }\\n    prev := head\\n    slow := head.Next\\n    fast := head.Next.Next\\n    \\n    for fast != nil && fast.Next != nil{\\n        prev = slow\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    prev.Next = nil\\n    root := TreeNode{slow.Val,nil,nil}\\n\\n    root.Left = sortedListToBST(head)\\n    root.Right = sortedListToBST(slow.Next)\\n    return &root\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head:\\n            return None\\n        if not head.next:\\n            return TreeNode(head.val)\\n\\n        prev = head\\n        slow = head.next\\n        fast = head.next.next\\n\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        prev.next = None\\n        root = TreeNode(slow.val)\\n\\n        root.left = self.sortedListToBST(head)\\n        root.right = self.sortedListToBST(slow.next)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283668,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n        TreeNode* node = new TreeNode(slow->val);\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n        return node;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n        TreeNode* node = new TreeNode(slow->val);\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n        return node;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282489,
                "title": "c-recursive-use-of-slow-fast-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind middle of list and create node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(logn) recursive stack space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            TreeNode* root=new TreeNode(head->val);\\n            return root;\\n        }\\n        \\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        ListNode* prev=slow;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        prev->next=NULL;\\n        \\n        root->left=helper(head);\\n        root->right=helper(slow->next);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* helper(ListNode* head){\\n        if(head==NULL){\\n            return NULL;\\n        }\\n        if(head->next==NULL){\\n            TreeNode* root=new TreeNode(head->val);\\n            return root;\\n        }\\n        \\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        ListNode* prev=slow;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        TreeNode* root=new TreeNode(slow->val);\\n        prev->next=NULL;\\n        \\n        root->left=helper(head);\\n        root->right=helper(slow->next);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return helper(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282203,
                "title": "java-simple-recursion-7-lines-o-n-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<Integer> list = new ArrayList<>();\\n\\n  private TreeNode createBst(int l, int r) {\\n    if (l > r) return null;\\n\\n    var m = l + (r-l) / 2;\\n    return new TreeNode(list.get(m), createBst(l, m-1), createBst(m+1, r));\\n  }\\n\\n  public TreeNode sortedListToBST(ListNode head) {\\n    for (; head != null; head = head.next)\\n      list.add(head.val);\\n\\n    return createBst(0, list.size() - 1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  List<Integer> list = new ArrayList<>();\\n\\n  private TreeNode createBst(int l, int r) {\\n    if (l > r) return null;\\n\\n    var m = l + (r-l) / 2;\\n    return new TreeNode(list.get(m), createBst(l, m-1), createBst(m+1, r));\\n  }\\n\\n  public TreeNode sortedListToBST(ListNode head) {\\n    for (; head != null; head = head.next)\\n      list.add(head.val);\\n\\n    return createBst(0, list.size() - 1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281940,
                "title": "recursion-easy-explained-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N) time complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N) space complexity\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(int i,int j, vector<int>& help)\\n    {\\n        if(i>j) return NULL; // if starting index is greater than ending index simply return NULL;\\n        int mid=i+(j-i)/2;// calculating mid \\n        TreeNode* root=new TreeNode(help[mid]);// making a node with the value of the mid of the vector\\n// as the vector is sorted , element smaller than the mid will be at the left side of the mid and larger element will be at the right side\\n        root->left=solve(i,mid-1,help);// for left children\\n        root->right=solve(mid+1,j,help);// for right children\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         vector<int>help; // creating a vector help in which all the value of node will be inserted.\\n         while(head)\\n         {\\n            // pushing all the value of the linked list into the vector\\n             help.push_back(head->val);\\n             head=head->next;\\n         }\\n         int n=help.size(); \\n         // here solve(starting index, ending index, vector)\\n         return solve(0,n-1,help);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(int i,int j, vector<int>& help)\\n    {\\n        if(i>j) return NULL; // if starting index is greater than ending index simply return NULL;\\n        int mid=i+(j-i)/2;// calculating mid \\n        TreeNode* root=new TreeNode(help[mid]);// making a node with the value of the mid of the vector\\n// as the vector is sorted , element smaller than the mid will be at the left side of the mid and larger element will be at the right side\\n        root->left=solve(i,mid-1,help);// for left children\\n        root->right=solve(mid+1,j,help);// for right children\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         vector<int>help; // creating a vector help in which all the value of node will be inserted.\\n         while(head)\\n         {\\n            // pushing all the value of the linked list into the vector\\n             help.push_back(head->val);\\n             head=head->next;\\n         }\\n         int n=help.size(); \\n         // here solve(starting index, ending index, vector)\\n         return solve(0,n-1,help);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281920,
                "title": "daily-leetcoding-challenge-march-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Recursion + Conversion to Array\n\n  \n**Approach 3:** Inorder Simulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3035288,
                "title": "c-recursion-linked-list-slow-fast-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n \\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n\\n        TreeNode* node = new TreeNode(slow->val);\\n\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n\\n        return node;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(ListNode* head) {\\n        if(!head) return nullptr;\\n\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n \\n        while(fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        if(prev) prev -> next = nullptr;\\n        if(slow == head) head = nullptr;\\n\\n        TreeNode* node = new TreeNode(slow->val);\\n\\n        node -> left = buildBST(head);\\n        node -> right = buildBST(slow->next);\\n\\n        return node;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return buildBST(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009324,
                "title": "well-detailed-linear-time-complexity-algorithm",
                "content": "# Intuition\\nThe intuition behind this approach is to closely mimic the convert sorted array into a BST.\\n\\n# Approach\\nThe approach is based on the Ionrder Traversal of a Binary tree. First, we find the midpoint of the tree. We then recursively call the function on the left division. Once the base condition is reached, we have just passed the leftmost child. Hence, it returns null and go back to the leftmost child. Now, we are guaranteed that the head (root) will be pointing at the leftmost child. root.left will now be the result of our function on the left division. \\n\\nThe head is then advanced and the function is called on the last part.\\n\\n# Complexity\\n- Time complexity:\\nT(n) = O(n)\\n\\n- Space complexity:\\nT(n) = (logn)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private ListNode node;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) return null;\\n        int n = 0;\\n        ListNode current = head;\\n        node = head;\\n        while (current != null) {\\n            n++;\\n            current = current.next;\\n        }\\n\\n        return helper(0, n - 1);   \\n    }\\n\\n    private TreeNode helper(int start, int end) {\\n        if (start > end) return null;           // is linked list is empty?\\n        int mid = start + (end - start) / 2;\\n\\n        TreeNode leftSubtree = helper(start, mid - 1);\\n        // Recursion is now at the head.\\n\\n        TreeNode root = new TreeNode(node.val);\\n        root.left = leftSubtree;\\n\\n        node = node.next;\\n\\n        TreeNode rightSubtree = helper(mid + 1, end);\\n        root.right = rightSubtree;\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private ListNode node;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) return null;\\n        int n = 0;\\n        ListNode current = head;\\n        node = head;\\n        while (current != null) {\\n            n++;\\n            current = current.next;\\n        }\\n\\n        return helper(0, n - 1);   \\n    }\\n\\n    private TreeNode helper(int start, int end) {\\n        if (start > end) return null;           // is linked list is empty?\\n        int mid = start + (end - start) / 2;\\n\\n        TreeNode leftSubtree = helper(start, mid - 1);\\n        // Recursion is now at the head.\\n\\n        TreeNode root = new TreeNode(node.val);\\n        root.left = leftSubtree;\\n\\n        node = node.next;\\n\\n        TreeNode rightSubtree = helper(mid + 1, end);\\n        root.right = rightSubtree;\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767308,
                "title": "python-beats-86-recursive-solution",
                "content": "```\\nclass Solution:\\n    l = \\'left\\'\\n    r = \\'right\\'\\n    \\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        \\n        nums = []\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n        \\n        mid = len(nums) // 2\\n        treeNode = TreeNode(nums[mid])\\n        \\n        self.binarySearchTree(nums[:mid], self.l, treeNode)\\n        self.binarySearchTree(nums[(mid + 1):], self.r, treeNode)\\n        \\n        return treeNode\\n            \\n            \\n    def binarySearchTree(self, nums, direction, treeNode):\\n        if len(nums) <= 0: return\\n        \\n        mid = len(nums) // 2\\n        left, right = nums[:mid], nums[(mid + 1):]\\n        \\n        if direction == self.l:\\n            treeNode.left = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.left)\\n            self.binarySearchTree(right, self.r, treeNode.left)\\n        else:\\n            treeNode.right = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.right)\\n            self.binarySearchTree(right, self.r, treeNode.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    l = \\'left\\'\\n    r = \\'right\\'\\n    \\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if not head: return None\\n        \\n        nums = []\\n        while head:\\n            nums.append(head.val)\\n            head = head.next\\n        \\n        mid = len(nums) // 2\\n        treeNode = TreeNode(nums[mid])\\n        \\n        self.binarySearchTree(nums[:mid], self.l, treeNode)\\n        self.binarySearchTree(nums[(mid + 1):], self.r, treeNode)\\n        \\n        return treeNode\\n            \\n            \\n    def binarySearchTree(self, nums, direction, treeNode):\\n        if len(nums) <= 0: return\\n        \\n        mid = len(nums) // 2\\n        left, right = nums[:mid], nums[(mid + 1):]\\n        \\n        if direction == self.l:\\n            treeNode.left = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.left)\\n            self.binarySearchTree(right, self.r, treeNode.left)\\n        else:\\n            treeNode.right = TreeNode(nums[mid])\\n            self.binarySearchTree(left, self.l, treeNode.right)\\n            self.binarySearchTree(right, self.r, treeNode.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414212,
                "title": "convert-sorted-list-to-binary-search-tree-using-recursion-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* construct_tree(ListNode* start, ListNode* end){\\n\\t // base case\\n        if(start==end) return NULL;\\n        \\n           // find the mid using slow and fast pointer\\n        \\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        \\n        while(fast!=end && fast->next!=end){\\n            slow = slow ->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        //slow poimter will retuen mid val \\n        \\n        // create a node and put slow -> val as value\\n        \\n        TreeNode* root = new TreeNode(slow -> val);\\n        root->left = construct_tree(start, slow);\\n        \\n        root->right = construct_tree(slow->next,end);\\n        \\n        \\n        return root;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         return construct_tree(head, NULL);\\n    }\\n};\\n```\\nIf it helps, please do **Upvote**\\nHappy coding :)",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* construct_tree(ListNode* start, ListNode* end){\\n\\t // base case\\n        if(start==end) return NULL;\\n        \\n           // find the mid using slow and fast pointer\\n        \\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n        \\n        while(fast!=end && fast->next!=end){\\n            slow = slow ->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        //slow poimter will retuen mid val \\n        \\n        // create a node and put slow -> val as value\\n        \\n        TreeNode* root = new TreeNode(slow -> val);\\n        root->left = construct_tree(start, slow);\\n        \\n        root->right = construct_tree(slow->next,end);\\n        \\n        \\n        return root;\\n        \\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n         return construct_tree(head, NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240775,
                "title": "c-simple-and-short-recursive-solution-o-n-time-and-o-1-space",
                "content": "**If you find this is helpfull**\\n**Please Upvote it!!**\\n```\\n  TNode* sortedListToBST(LNode *head , LNode *tail = NULL) {\\n        //code here\\n        if(head == tail) return NULL;\\n        \\n        LNode *slow = head , *fast = head;\\n        \\n        while(fast != tail and fast->next != tail){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TNode *root = new TNode(slow->data);\\n        root->left = sortedListToBST(head , slow);\\n        root->right = sortedListToBST(slow->next , tail);\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n  TNode* sortedListToBST(LNode *head , LNode *tail = NULL) {\\n        //code here\\n        if(head == tail) return NULL;\\n        \\n        LNode *slow = head , *fast = head;\\n        \\n        while(fast != tail and fast->next != tail){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TNode *root = new TNode(slow->data);\\n        root->left = sortedListToBST(head , slow);\\n        root->right = sortedListToBST(slow->next , tail);\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230434,
                "title": "python-easy-and-simple",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        lst = []\\n        \\n        if head == None:\\n            return head\\n        \\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n            \\n        \\n        return self.BST(lst)\\n    \\n    def BST(self,lst):\\n      \\n        if not lst:\\n            return None\\n        \\n        mid = len(lst)//2\\n        \\n        root = TreeNode(lst[mid])\\n        \\n        root.left = self.BST(lst[:mid])\\n        root.right = self.BST(lst[mid+1:])\\n        \\n        return root\\n```\\nIf you like please upvote my solution. :)",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        lst = []\\n        \\n        if head == None:\\n            return head\\n        \\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n            \\n        \\n        return self.BST(lst)\\n    \\n    def BST(self,lst):\\n      \\n        if not lst:\\n            return None\\n        \\n        mid = len(lst)//2\\n        \\n        root = TreeNode(lst[mid])\\n        \\n        root.left = self.BST(lst[:mid])\\n        root.right = self.BST(lst[mid+1:])\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190381,
                "title": "c-recursive-solution-simple-approach-explained",
                "content": "The Approach to the problem is very simple.\\nStep 1. Find the mid of the list.\\nStep 2. Make a new node of the tree(say N) with the same value as the mid element found(mid->val).\\nStep 3. Divide the list into two parts from the mid element i.e. a left part and a right part.\\nAfter dividing the list into two make the left of the node(N->left) equal to the mid of the left list and similarly make the right of the node(N->right) equal to the mid of the right list.\\n\\nKeep repeating this process until all elements of the List are traversed.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        if(head->next==NULL)\\n            return new TreeNode(head->val);\\n        \\n        ListNode *prev = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n\\t\\t\\n        //Step 1. Find the mid of the list.\\n\\n        while(fast!=NULL && fast->next!=NULL){\\n            \\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n        }\\n        prev->next = NULL;\\n        //Step 2. Make a new node of the tree(say N) with the same value as the mid element found(mid->val).\\n        TreeNode *root = new TreeNode(slow->val);\\n\\t\\t\\n\\t\\t//Step 3. Divide the list into two parts from the mid element i.e. a left part and a right part.\\n\\t\\t //After dividing the list into two make the left of the node(N->left) equal to the mid of //the left list and similarly make the right of the node(N->right) equal to the mid of the right list.\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n      \\n        return root;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        if(head->next==NULL)\\n            return new TreeNode(head->val);\\n        \\n        ListNode *prev = NULL;\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n\\t\\t\\n        //Step 1. Find the mid of the list.\\n\\n        while(fast!=NULL && fast->next!=NULL){\\n            \\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            \\n        }\\n        prev->next = NULL;\\n        //Step 2. Make a new node of the tree(say N) with the same value as the mid element found(mid->val).\\n        TreeNode *root = new TreeNode(slow->val);\\n\\t\\t\\n\\t\\t//Step 3. Divide the list into two parts from the mid element i.e. a left part and a right part.\\n\\t\\t //After dividing the list into two make the left of the node(N->left) equal to the mid of //the left list and similarly make the right of the node(N->right) equal to the mid of the right list.\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n      \\n        return root;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845418,
                "title": "c-solution-in-o-n-time",
                "content": "```class Solution {\\npublic:\\n    TreeNode * helper(ListNode *head,ListNode *tail=NULL)\\n    {\\n        if(head==tail)\\n            return NULL;\\n        ListNode *slow=head,*fast=head;\\n        while(fast!=tail&&fast->next!=tail)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            \\n        }\\n        TreeNode * node=new TreeNode(slow->val);\\n        node->left=helper(head,slow);\\n        node->right=helper(slow->next,tail);\\n            return node;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        ListNode *tail=head;\\n        while(tail)\\n        {\\n            tail=tail->next;\\n        }\\n     \\n         return     helper(head,tail);      \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode * helper(ListNode *head,ListNode *tail=NULL)\\n    {\\n        if(head==tail)\\n            return NULL;\\n        ListNode *slow=head,*fast=head;\\n        while(fast!=tail&&fast->next!=tail)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1690438,
                "title": "c-eassy-to-understand-simple-code",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(vector<int> &v,int s,int e)\\n    {\\n        if(s>e)\\n        return NULL;\\n        \\n        int mid=(s+e)/2;\\n        int rootData=v[mid];\\n        TreeNode* root=new TreeNode(rootData);\\n        root->left=constructBST(v,s,mid-1);\\n        root->right=constructBST(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> sortedArray;\\n        while(head)\\n        {\\n            sortedArray.push_back(head->val);\\n            head=head->next;\\n        }\\n        return constructBST(sortedArray,0,sortedArray.size()-1);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(vector<int> &v,int s,int e)\\n    {\\n        if(s>e)\\n        return NULL;\\n        \\n        int mid=(s+e)/2;\\n        int rootData=v[mid];\\n        TreeNode* root=new TreeNode(rootData);\\n        root->left=constructBST(v,s,mid-1);\\n        root->right=constructBST(v,mid+1,e);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> sortedArray;\\n        while(head)\\n        {\\n            sortedArray.push_back(head->val);\\n            head=head->next;\\n        }\\n        return constructBST(sortedArray,0,sortedArray.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508547,
                "title": "small-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode **slow = &head, **fast = &head;\\n\\t\\t\\n\\t\\t// Get the middle\\n        while((*fast) && (*fast)->next) {\\n            slow = &(*slow)->next;\\n            fast = &(*fast)->next->next;\\n        }\\n\\t\\t\\n\\t\\t// isolate the middle and the left and the right part\\n        ListNode *right = (*slow)->next;\\n        ListNode *cur = (*slow);\\n        (*slow) = nullptr;\\n        cur->next = nullptr;\\n\\t\\t\\n\\t\\t// recursively make the ans\\n        TreeNode *root = new TreeNode(cur->val, sortedListToBST(head), sortedListToBST(right));\\n\\t\\t\\n\\t\\t//fix the list\\n        cur->next = right;\\n        (*slow) = cur;\\n\\t\\t\\n\\t\\t// return ans\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return nullptr;\\n        ListNode **slow = &head, **fast = &head;\\n\\t\\t\\n\\t\\t// Get the middle\\n        while((*fast) && (*fast)->next) {\\n            slow = &(*slow)->next;\\n            fast = &(*fast)->next->next;\\n        }\\n\\t\\t\\n\\t\\t// isolate the middle and the left and the right part\\n        ListNode *right = (*slow)->next;\\n        ListNode *cur = (*slow);\\n        (*slow) = nullptr;\\n        cur->next = nullptr;\\n\\t\\t\\n\\t\\t// recursively make the ans\\n        TreeNode *root = new TreeNode(cur->val, sortedListToBST(head), sortedListToBST(right));\\n\\t\\t\\n\\t\\t//fix the list\\n        cur->next = right;\\n        (*slow) = cur;\\n\\t\\t\\n\\t\\t// return ans\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376926,
                "title": "simple-and-efficient-solution-c-faster-than-92",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return createTree(head,NULL,NULL);\\n    }\\n    TreeNode* createTree(ListNode* l,ListNode* r,TreeNode* root){\\n        if(l==r)\\n            return root;\\n        ListNode* mid=findMid(l,r);\\n        if(root==NULL){\\n            root=new TreeNode(mid->val);\\n        }\\n        root->left=createTree(l,mid,root->left);\\n        root->right=createTree(mid->next,r,root->right);\\n        return root;\\n    }\\n    \\n    ListNode* findMid(ListNode * head,ListNode* endNode){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!=NULL&&fast!=endNode&&fast->next!=endNode){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        return slow;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        return createTree(head,NULL,NULL);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1358727,
                "title": "c-short-and-easy",
                "content": "```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        TreeNode *new_node = new TreeNode();\\n        ListNode *lo = head, *hi = head, *prev;\\n\\t\\t\\n        while(hi -> next && hi -> next -> next) {\\n            hi = hi -> next -> next;\\n            prev = lo;\\n            lo = lo -> next;\\n        }\\n\\t\\t\\n        new_node -> val = lo -> val;\\n        if(prev) {\\n            prev -> next = NULL;\\n            new_node -> left = sortedListToBST(head);\\n        }\\n        if(lo -> next) {\\n            new_node -> right = sortedListToBST(lo -> next);\\n        }\\n\\t\\t\\n        return new_node;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        TreeNode *new_node = new TreeNode();\\n        ListNode *lo = head, *hi = head, *prev;\\n\\t\\t\\n        while(hi -> next && hi -> next -> next) {\\n            hi = hi -> next -> next;\\n            prev = lo;\\n            lo = lo -> next;\\n        }\\n\\t\\t\\n        new_node -> val = lo -> val;\\n        if(prev) {\\n            prev -> next = NULL;\\n            new_node -> left = sortedListToBST(head);\\n        }\\n        if(lo -> next) {\\n            new_node -> right = sortedListToBST(lo -> next);\\n        }\\n\\t\\t\\n        return new_node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244022,
                "title": "python-o-n-iterative-with-stack-need-not-to-convert-to-array",
                "content": "Code First\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        self.head = head\\n        curr = head\\n        cnt = 0\\n        while curr:\\n            cnt += 1\\n            curr = curr.next\\n        \\n        root = TreeNode(float(\\'inf\\'))\\n        stack = [[0, cnt-1, root, False]]\\n\\n        while stack:\\n            start, end, node, status = stack.pop()\\n            \\n            mid = (start + end) >> 1\\n            \\n            if status is False:\\n                if mid+1 <= end:\\n                    node.right = TreeNode(-1)\\n                    stack.append([mid+1, end, node.right, False])\\n\\n                stack.append([start, end, node, True])\\n                \\n                if start <= mid-1:\\n                    node.left = TreeNode(-1)\\n                    stack.append([start, mid-1, node.left, False])\\n            else:\\n                node.val = head.val\\n                head = head.next\\n        \\n        return root\\n```\\n\\nFirstly we need to understand how to in-order traverse with stack. Let\\'s solve an easier problem - https://leetcode.com/problems/binary-tree-inorder-traversal with the following sample code. \\n\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        stack = [[root, False]]\\n        \\n        while stack:\\n            node, status = stack.pop()\\n            \\n            if status is False:\\n                if node.right:\\n                    stack.append([node.right, False])\\n                stack.append([node, True])\\n                if node.left:\\n                    stack.append([node.left, False])\\n            else:\\n                ans.append(node.val)\\n        \\n        return ans\\n```\\n\\nThe idea is: when we push a node to a stack, we not only save the node itself, but also saves a bool variable - `status`. The rule is\\n\\n  * We always push a node to stack with `status = False`, at first time\\n  * When we retrieve a node with `status = False`, we push left/right child following rule1. At the same time, in the middle of left/right child, we push a `<node, True>`\\n  * When we retrieve a node with `status = True`, we are ready to add the `node.val` to answer list. \\n\\nWe just follow the template and make a little modification. Remember, when we traverse, we use the left/right pointer to get more nodes and push it to stack. When we build (the reverse process of traverse), we need to create left/right pointers, but still push them to stack.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        if not head:\\n            return None\\n        self.head = head\\n        curr = head\\n        cnt = 0\\n        while curr:\\n            cnt += 1\\n            curr = curr.next\\n        \\n        root = TreeNode(float(\\'inf\\'))\\n        stack = [[0, cnt-1, root, False]]\\n\\n        while stack:\\n            start, end, node, status = stack.pop()\\n            \\n            mid = (start + end) >> 1\\n            \\n            if status is False:\\n                if mid+1 <= end:\\n                    node.right = TreeNode(-1)\\n                    stack.append([mid+1, end, node.right, False])\\n\\n                stack.append([start, end, node, True])\\n                \\n                if start <= mid-1:\\n                    node.left = TreeNode(-1)\\n                    stack.append([start, mid-1, node.left, False])\\n            else:\\n                node.val = head.val\\n                head = head.next\\n        \\n        return root\\n```\n```\\nclass Solution:\\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        stack = [[root, False]]\\n        \\n        while stack:\\n            node, status = stack.pop()\\n            \\n            if status is False:\\n                if node.right:\\n                    stack.append([node.right, False])\\n                stack.append([node, True])\\n                if node.left:\\n                    stack.append([node.left, False])\\n            else:\\n                ans.append(node.val)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241291,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail=NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail=NULL) {\\n        if (head == tail) \\n            return NULL;\\n        \\n        ListNode* fast = head, *slow = head;\\n        while (fast != tail && fast->next != tail) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        TreeNode* root = new TreeNode(slow->val);\\n        root->left = sortedListToBST(head, slow);\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226248,
                "title": "c-o-n-solution-no-mid-node-calculation-faster-than-92-time",
                "content": "**Approach**-we construct from leaves to root. The idea is to insert nodes in BST in the same order as they appear in Linked List so that the tree can be constructed in O(n) time complexity. We first count the number of nodes in the given Linked List. Let the count be n. After counting nodes, we take left n/2 nodes and recursively construct the left subtree. After left subtree is constructed, we allocate memory for root and link the left subtree with root. Finally, we recursively construct the right subtree and link it with root.\\nWhile constructing the BST, we also keep moving the list head pointer to next so that we have the appropriate pointer in each recursive call.\\n\\n**please upvote if you liked it**\\n\\n**Code** \\n```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp = head ;\\n        int l=0 ;\\n        while(temp){\\n            temp=temp->next ;\\n            l++ ;\\n        }\\n        \\n        return l ;\\n    }\\n\\t\\n    TreeNode* helper(ListNode **head , int n){\\n        if(n<=0) return NULL ;\\n        \\n        TreeNode* left = helper(head,n/2) ;\\n        TreeNode* root = new TreeNode((*head)->val) ;\\n        root->left = left ;\\n        \\n\\t\\t/* Change head pointer of Linked List\\n    for parent recursive calls */\\n        (*head)=(*head)->next ;\\n        \\n\\t\\t/* Recursively construct the right \\n        subtree and link it with root \\n        The number of nodes in right subtree\\n        is total nodes - nodes in \\n        left subtree - 1 (for root) which is n-n/2-1*/\\n\\t\\t\\n        root->right = helper(head , n-n/2-1) ;\\n        return root ;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = length(head) ;\\n        \\n        return helper(&head, n) ;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp = head ;\\n        int l=0 ;\\n        while(temp){\\n            temp=temp->next ;\\n            l++ ;\\n        }\\n        \\n        return l ;\\n    }\\n\\t\\n    TreeNode* helper(ListNode **head , int n){\\n        if(n<=0) return NULL ;\\n        \\n        TreeNode* left = helper(head,n/2) ;\\n        TreeNode* root = new TreeNode((*head)->val) ;\\n        root->left = left ;\\n        \\n\\t\\t/* Change head pointer of Linked List\\n    for parent recursive calls */\\n        (*head)=(*head)->next ;\\n        \\n\\t\\t/* Recursively construct the right \\n        subtree and link it with root \\n        The number of nodes in right subtree\\n        is total nodes - nodes in \\n        left subtree - 1 (for root) which is n-n/2-1*/\\n\\t\\t\\n        root->right = helper(head , n-n/2-1) ;\\n        return root ;\\n        \\n    }\\n    \\n    TreeNode* sortedListToBST(ListNode* head) {\\n        int n = length(head) ;\\n        \\n        return helper(&head, n) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203579,
                "title": "3-liner",
                "content": "**Recursive**\\n**time: `O(NlogN)`, space: `O(logN)`**\\n\\n```\\nTreeNode* sortedListToBST(ListNode* h, ListNode* t=nullptr) \\n{ \\n\\tauto p{h};\\n\\tfor(auto q{h}; q!=t and q->next!=t; p=p->next, q=q->next->next);\\n\\treturn p!=t ? new TreeNode(p->val, sortedListToBST(h, p), sortedListToBST(p->next, t)) : nullptr;\\n}\\n```\\n`h` - head, `t` - tail, `p` - \"tortoise\", `q`  - \"hair\".\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/366fce31-4e61-406d-b8c7-9fe77c220f6e_1620778812.8718257.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nTreeNode* sortedListToBST(ListNode* h, ListNode* t=nullptr) \\n{ \\n\\tauto p{h};\\n\\tfor(auto q{h}; q!=t and q->next!=t; p=p->next, q=q->next->next);\\n\\treturn p!=t ? new TreeNode(p->val, sortedListToBST(h, p), sortedListToBST(p->next, t)) : nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195009,
                "title": "python-clean-simple",
                "content": "1. Extract to an array\\n\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        arr = []\\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\t\\t\\n        def dfs(l, r):\\n            if l > r: return None\\n            mid = l + (r - l) // 2\\n            return TreeNode(arr[mid], dfs(l, mid-1), dfs(mid+1, r))\\n\\t\\t\\n        return dfs(0, len(arr)-1)\\n```\\n\\n2. Slow fast pointers\\n\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def dfs(head, tail):\\n            if head == tail: return None\\n            slow = fast = head\\n            while fast != tail and fast.next != tail:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return TreeNode(slow.val, dfs(head, slow), dfs(slow.next, tail))\\n\\t\\t\\n        return dfs(head, None)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        arr = []\\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n\\t\\t\\n        def dfs(l, r):\\n            if l > r: return None\\n            mid = l + (r - l) // 2\\n            return TreeNode(arr[mid], dfs(l, mid-1), dfs(mid+1, r))\\n\\t\\t\\n        return dfs(0, len(arr)-1)\\n```\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def dfs(head, tail):\\n            if head == tail: return None\\n            slow = fast = head\\n            while fast != tail and fast.next != tail:\\n                slow = slow.next\\n                fast = fast.next.next\\n            return TreeNode(slow.val, dfs(head, slow), dfs(slow.next, tail))\\n\\t\\t\\n        return dfs(head, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194985,
                "title": "c-using-binary-search-property-easy-approach-commented",
                "content": "```\\n  TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        while(head)\\n        {\\n            vec.push_back(head->val);       //store values in vector for easy navigation\\n            head = head->next;\\n        }\\n        int l, r;\\n        l=0; r = vec.size()-1;\\n        TreeNode *root;\\n        root= generateBST(vec, l, r);      \\n        return root;\\n    }\\n    \\n    TreeNode * generateBST(vector<int> &vec, int l, int r)\\n    {\\n        if(l>r)\\n            return NULL;\\n        int mid = l+(r-l)/2;        // find middle node and make it root\\n        TreeNode *newNode = new TreeNode(vec[mid]);\\n        \\n        newNode->left = generateBST(vec, l, mid-1);     // root->left = binary search on left half vector\\n        newNode->right = generateBST(vec, mid+1, r);    //root->right = binary search on right half vector\\n        \\n        return newNode;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n  TreeNode* sortedListToBST(ListNode* head) {\\n        vector<int> vec;\\n        while(head)\\n        {\\n            vec.push_back(head->val);       //store values in vector for easy navigation\\n            head = head->next;\\n        }\\n        int l, r;\\n        l=0; r = vec.size()-1;\\n        TreeNode *root;\\n        root= generateBST(vec, l, r);      \\n        return root;\\n    }\\n    \\n    TreeNode * generateBST(vector<int> &vec, int l, int r)\\n    {\\n        if(l>r)\\n            return NULL;\\n        int mid = l+(r-l)/2;        // find middle node and make it root\\n        TreeNode *newNode = new TreeNode(vec[mid]);\\n        \\n        newNode->left = generateBST(vec, l, mid-1);     // root->left = binary search on left half vector\\n        newNode->right = generateBST(vec, mid+1, r);    //root->right = binary search on right half vector\\n        \\n        return newNode;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194900,
                "title": "c-simple-recursive-and-short-solution",
                "content": "Please feel free to ask questions if there is any difficulty understanding the code!\\n\\n```\\nclass Solution {\\npublic:\\n\\t// initialize an array which is used to store the list values as we \\n\\t// can\\'t afford to traverse everytime we require a value\\n    vector<int> v; \\n    \\n\\t// helper function to take care of the tree values\\n    TreeNode* helper(int st, int en){\\n\\t\\t// let recursion do the hectic work \\n\\t\\t// and we focus only on end points\\n        if(st>en)\\n            return NULL;\\n        else if(st==en)\\n            return new TreeNode(v[st]);\\n        int mid=(st+en)/2;\\n\\t\\t\\n\\t\\t// using the TreeNode constructor to provide value\\n\\t\\t// and both the pointer values which we get by recursion\\n        return new TreeNode(v[mid], helper(st,mid-1), helper(mid+1,en));\\n    }\\n    \\n\\t// set our vector v according to the linked list provided\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }    \\n        return helper(0,v.size()-1);\\n    }\\n};\\n```\\n\\nPlease upvote if you like my code!",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// initialize an array which is used to store the list values as we \\n\\t// can\\'t afford to traverse everytime we require a value\\n    vector<int> v; \\n    \\n\\t// helper function to take care of the tree values\\n    TreeNode* helper(int st, int en){\\n\\t\\t// let recursion do the hectic work \\n\\t\\t// and we focus only on end points\\n        if(st>en)\\n            return NULL;\\n        else if(st==en)\\n            return new TreeNode(v[st]);\\n        int mid=(st+en)/2;\\n\\t\\t\\n\\t\\t// using the TreeNode constructor to provide value\\n\\t\\t// and both the pointer values which we get by recursion\\n        return new TreeNode(v[mid], helper(st,mid-1), helper(mid+1,en));\\n    }\\n    \\n\\t// set our vector v according to the linked list provided\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }    \\n        return helper(0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194780,
                "title": "java-clean-concise-optimal-code-two-pointer-technique-100-beats-solution",
                "content": "```\\nclass Solution {\\n    \\n    public ListNode middleOfLinkedList (ListNode head, ListNode tail) {\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    public TreeNode constructBST (ListNode head, ListNode tail) {\\n        \\n        if (head == tail) {\\n            return null;\\n        }\\n        \\n        ListNode middle = middleOfLinkedList (head, tail);\\n        \\n        TreeNode root = new TreeNode (middle.val);\\n        root.left = constructBST (head, middle);\\n        root.right = constructBST (middle.next, tail);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        return constructBST (head, null);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public ListNode middleOfLinkedList (ListNode head, ListNode tail) {\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n    public TreeNode constructBST (ListNode head, ListNode tail) {\\n        \\n        if (head == tail) {\\n            return null;\\n        }\\n        \\n        ListNode middle = middleOfLinkedList (head, tail);\\n        \\n        TreeNode root = new TreeNode (middle.val);\\n        root.left = constructBST (head, middle);\\n        root.right = constructBST (middle.next, tail);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        return constructBST (head, null);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194021,
                "title": "c-recursion",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) \\n    {\\n        // further tree can\\'t be constructed\\n        if (head == tail) \\n            return NULL;\\n        \\n        // slow is used to divide the current list into two equal parts\\n        // fast is just used to ensure that list is appropriately divided\\n        ListNode* fast = head, *slow = head;\\n        \\n        while (fast != tail && fast->next != tail) \\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // slow is the root of current subtree\\n        TreeNode* root = new TreeNode(slow->val);\\n        \\n        // left subtree is the list from head to slow-1\\n        root->left = sortedListToBST(head, slow);\\n        \\n        // right subtree is the list from slow->next to tail-1\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail = NULL) \\n    {\\n        // further tree can\\'t be constructed\\n        if (head == tail) \\n            return NULL;\\n        \\n        // slow is used to divide the current list into two equal parts\\n        // fast is just used to ensure that list is appropriately divided\\n        ListNode* fast = head, *slow = head;\\n        \\n        while (fast != tail && fast->next != tail) \\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // slow is the root of current subtree\\n        TreeNode* root = new TreeNode(slow->val);\\n        \\n        // left subtree is the list from head to slow-1\\n        root->left = sortedListToBST(head, slow);\\n        \\n        // right subtree is the list from slow->next to tail-1\\n        root->right = sortedListToBST(slow->next, tail);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063345,
                "title": "javascript-convert-to-array-and-recursion-time-and-space-o-n",
                "content": "```\\nvar sortedListToBST = function (head) {\\n\\n  if (head === null) {\\n    return null;\\n  }\\n\\n  const list = [];\\n  while (head !== null) {\\n    list.push(head.val);\\n    head = head.next;\\n  }\\n\\n  return findHead(0, list.length - 1);\\n\\n  function findHead(start, end) {\\n\\n    if (start > end) {\\n      return null;\\n    }\\n    const middle = Math.ceil((start + end) / 2);\\n\\n    const left = findHead(start, middle - 1);\\n    const right = findHead(middle + 1, end);\\n\\n    return new TreeNode(list[middle], left, right);\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar sortedListToBST = function (head) {\\n\\n  if (head === null) {\\n    return null;\\n  }\\n\\n  const list = [];\\n  while (head !== null) {\\n    list.push(head.val);\\n    head = head.next;\\n  }\\n\\n  return findHead(0, list.length - 1);\\n\\n  function findHead(start, end) {\\n\\n    if (start > end) {\\n      return null;\\n    }\\n    const middle = Math.ceil((start + end) / 2);\\n\\n    const left = findHead(start, middle - 1);\\n    const right = findHead(middle + 1, end);\\n\\n    return new TreeNode(list[middle], left, right);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 787041,
                "title": "python-3-recursive-solution-convert-to-array-first-124ms",
                "content": "Approach:\\n1. The linked list is traversed and its elements are appended into an array ```L```.\\n2. Because this array is sorted, it becomes **similar** to problem [108. Convert Sorted Array to BST](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n3. The middle element ```mid``` is calculated which **becomes the root**.\\n4. The values of the left and right nodes are `recursively` calculated.\\n\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        L = []\\n        while (head != None):\\n            L.append(head.val)\\n            head = head.next\\n\\t\\t\\t\\n        def createBST(L):\\n            if not L:\\n                return None\\n            else:\\n                mid = len(L) // 2\\n                root = TreeNode(L[mid])\\n                root.left, root.right = createBST(L[:mid]), createBST(L[mid+1:])\\n            return root\\n        return createBST(L)\\n#32/32 test cases passed.\\n```\\n![image](https://assets.leetcode.com/users/images/f0c3ec5c-2c8e-4423-b92d-d45bf858483f_1597210618.4942033.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```L```\n```mid```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        L = []\\n        while (head != None):\\n            L.append(head.val)\\n            head = head.next\\n\\t\\t\\t\\n        def createBST(L):\\n            if not L:\\n                return None\\n            else:\\n                mid = len(L) // 2\\n                root = TreeNode(L[mid])\\n                root.left, root.right = createBST(L[:mid]), createBST(L[mid+1:])\\n            return root\\n        return createBST(L)\\n#32/32 test cases passed.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720615,
                "title": "python-3-sorted-linkedlist-sorted-list-binary-search-tree",
                "content": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def traverseList(head):\\n            while head:\\n                linkedListVal.append(head.val)\\n                head = head.next\\n        def constructBST(arr):\\n            if not arr:\\n                return None\\n            mid = len(arr) // 2\\n            tree = TreeNode(arr[mid])\\n            tree.left = constructBST(arr[ : mid])\\n            tree.right = constructBST(arr[mid + 1 : ])     \\n            return tree\\n        linkedListVal = []\\n        traverseList(head)\\n        print(linkedListVal)\\n        root = constructBST(linkedListVal)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def traverseList(head):\\n            while head:\\n                linkedListVal.append(head.val)\\n                head = head.next\\n        def constructBST(arr):\\n            if not arr:\\n                return None\\n            mid = len(arr) // 2\\n            tree = TreeNode(arr[mid])\\n            tree.left = constructBST(arr[ : mid])\\n            tree.right = constructBST(arr[mid + 1 : ])     \\n            return tree\\n        linkedListVal = []\\n        traverseList(head)\\n        print(linkedListVal)\\n        root = constructBST(linkedListVal)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331051,
                "title": "python3-solution-with-slow-fast-pointer",
                "content": "\\tclass Solution:\\n\\t\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\tif not head.next:\\n\\t\\t\\t\\treturn TreeNode(head.val)\\n\\t\\t\\tmid=self.findMid(head)\\n\\t\\t\\troot=TreeNode(mid.val)\\n\\t\\t\\troot.left=self.sortedListToBST(head)\\n\\t\\t\\troot.right=self.sortedListToBST(mid.next)\\n\\t\\t\\treturn root\\n\\n\\t\\tdef findMid(self,head):\\n\\t\\t\\tfast=slow=head\\n\\t\\t\\tpre=None\\n\\t\\t\\twhile fast and fast.next:\\n\\t\\t\\t\\tpre=slow\\n\\t\\t\\t\\tslow=slow.next\\n\\t\\t\\t\\tfast=fast.next.next\\n\\t\\t\\tpre.next=None\\n\\t\\t\\treturn slow",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef sortedListToBST(self, head: ListNode) -> TreeNode:\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\tif not head.next:\\n\\t\\t\\t\\treturn TreeNode(head.val)\\n\\t\\t\\tmid=self.findMid(head)\\n\\t\\t\\troot=TreeNode(mid.val)\\n\\t\\t\\troot.left=self.sortedListToBST(head)\\n\\t\\t\\troot.right=self.sortedListToBST(mid.next)\\n\\t\\t\\treturn root\\n\\n\\t\\tdef findMid(self,head):\\n\\t\\t\\tfast=slow=head\\n\\t\\t\\tpre=None\\n\\t\\t\\twhile fast and fast.next:\\n\\t\\t\\t\\tpre=slow\\n\\t\\t\\t\\tslow=slow.next\\n\\t\\t\\t\\tfast=fast.next.next\\n\\t\\t\\tpre.next=None\\n\\t\\t\\treturn slow",
                "codeTag": "Java"
            },
            {
                "id": 138146,
                "title": "python-231-ms-recursive-solution-beat-97-1",
                "content": "My solution is very straight forward, convert the linkedlist to list. And making use of recursion to build the tree. But I got confused, what does the interviewer want to see from this problem ? Should we still retain the linkedlist ? Should we not to use extra O(n) space ? Well, I tried the one from @caikehe, but now it`s no longer accepted by the OJ because some new test cases added. https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/discuss/35555/Clean-C++-solution.-Recursion.-O(nlogn).-With-comment\\nAnyway, here is my code:\\n```\\n        tree = []\\n        while head:\\n            tree.append(head.val)\\n            head = head.next\\n        root = self.constructTree(tree)        \\n        return root\\n    \\n    def constructTree(self, tree):\\n        if not tree:\\n            return\\n        mid = len(tree)/2\\n        root = TreeNode(tree[mid])\\n        root.left = self.constructTree(tree[:mid])\\n        root.right = self.constructTree(tree[mid+1:])\\n        return root\\n ```",
                "solutionTags": [],
                "code": "```\\n        tree = []\\n        while head:\\n            tree.append(head.val)\\n            head = head.next\\n        root = self.constructTree(tree)        \\n        return root\\n    \\n    def constructTree(self, tree):\\n        if not tree:\\n            return\\n        mid = len(tree)/2\\n        root = TreeNode(tree[mid])\\n        root.left = self.constructTree(tree[:mid])\\n        root.right = self.constructTree(tree[mid+1:])\\n        return root\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 35488,
                "title": "simple-c-divide-conquer-o-1-space",
                "content": "```\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        ListNode* pre = new ListNode(0);\\n        pre->next = slow;\\n        // Root is the mid position of the linked list\\n        while(fast){\\n            slow = slow->next;\\n            pre = pre->next;\\n            fast = fast->next ? fast->next->next : NULL;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        pre->next = NULL;\\n        // Call recursively to left and right part of linked list\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "```\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(!head) return NULL;\\n        if(!head->next) return new TreeNode(head->val);\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        ListNode* pre = new ListNode(0);\\n        pre->next = slow;\\n        // Root is the mid position of the linked list\\n        while(fast){\\n            slow = slow->next;\\n            pre = pre->next;\\n            fast = fast->next ? fast->next->next : NULL;\\n        }\\n        TreeNode* root = new TreeNode(slow->val);\\n        pre->next = NULL;\\n        // Call recursively to left and right part of linked list\\n        root->left = sortedListToBST(head);\\n        root->right = sortedListToBST(slow->next);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35565,
                "title": "javascript-solution",
                "content": "    function sortedListToBST(head) {\\n        if (!head) {\\n            return null;\\n        }\\n        \\n        if (!head.next) {\\n            return new TreeNode(head.val);\\n        }\\n        \\n        var m = head;\\n        var prev = head;\\n        var tail = head;\\n        \\n        // head, prev, m -> ... -> null\\n        while (tail && tail.next) {\\n            tail = tail.next.next;\\n            prev = m;\\n            m = m.next;\\n        }\\n        // head -> ... -> prev -> m -> ... -> null\\n        \\n        prev.next = null;\\n        \\n        var n = new TreeNode(m.val);\\n        n.left = sortedListToBST(head);\\n        n.right = sortedListToBST(m.next);\\n        return n;\\n    }",
                "solutionTags": [],
                "code": "    function sortedListToBST(head) {\\n        if (!head) {\\n            return null;\\n        }\\n        \\n        if (!head.next) {\\n            return new TreeNode(head.val);\\n        }\\n        \\n        var m = head;\\n        var prev = head;\\n        var tail = head;\\n        \\n        // head, prev, m -> ... -> null\\n        while (tail && tail.next) {\\n            tail = tail.next.next;\\n            prev = m;\\n            m = m.next;\\n        }\\n        // head -> ... -> prev -> m -> ... -> null\\n        \\n        prev.next = null;\\n        \\n        var n = new TreeNode(m.val);\\n        n.left = sortedListToBST(head);\\n        n.right = sortedListToBST(m.next);\\n        return n;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 35571,
                "title": "clear-and-easy-c-solution",
                "content": "    TreeNode* sortedListToBST(ListNode* head) {\\n    \\tint len = 0;\\n    \\tListNode *cur = head;\\n    \\twhile (cur) {\\n    \\t\\tlen++;\\n    \\t\\tcur = cur->next;\\n    \\t}\\n    \\treturn help(head, len);\\n    }\\n    TreeNode* help(ListNode* head, int len) {\\n    \\tif (len <= 0)\\n    \\t\\treturn NULL;\\n    \\tListNode *cur = head;\\n    \\tint mid = len / 2;\\n    \\twhile (mid) {\\n    \\t\\tcur = cur->next;\\n    \\t\\tmid--;\\n    \\t}\\n    \\tTreeNode *root = new TreeNode(cur->val);\\n    \\troot->left = help(head, len/2);\\n    \\troot->right = help(cur->next, len-len/2-1);\\n    \\treturn root;\\n    }",
                "solutionTags": [],
                "code": "    TreeNode* sortedListToBST(ListNode* head) {\\n    \\tint len = 0;\\n    \\tListNode *cur = head;\\n    \\twhile (cur) {\\n    \\t\\tlen++;\\n    \\t\\tcur = cur->next;\\n    \\t}\\n    \\treturn help(head, len);\\n    }\\n    TreeNode* help(ListNode* head, int len) {\\n    \\tif (len <= 0)\\n    \\t\\treturn NULL;\\n    \\tListNode *cur = head;\\n    \\tint mid = len / 2;\\n    \\twhile (mid) {\\n    \\t\\tcur = cur->next;\\n    \\t\\tmid--;\\n    \\t}\\n    \\tTreeNode *root = new TreeNode(cur->val);\\n    \\troot->left = help(head, len/2);\\n    \\troot->right = help(cur->next, len-len/2-1);\\n    \\treturn root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4056958,
                "title": "similar-as-convert-sorted-array-to-binary-search-tree",
                "content": "###### Same as [https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/solutions/4027619/easy-solution/]\\n\\n\\n# Intuition\\n### we use here List and store element we know in quetion it is given that  linkedlist is sorted\\n### And we know that in BST left element is smaller then root and right is greater \\n\\n### so we find here middle of list \\n### put node.left = middle -1\\n### node.right = middle+1;\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)return null;\\n        List<Integer>ans= new ArrayList<>();\\n         \\n        while(head!=null){\\n            ans.add(head.val);\\n            head=head.next;\\n        }\\n         return f(ans,0,ans.size()-1);\\n    }\\n    public TreeNode f(List<Integer>nums,int l,int h){\\n        if(l>h)return null;\\n        int mid=(l+h)/2;\\n        TreeNode node=new TreeNode(nums.get(mid));\\n        node.left=f(nums,l,mid-1);\\n        node.right=f(nums,mid+1,h);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)return null;\\n        List<Integer>ans= new ArrayList<>();\\n         \\n        while(head!=null){\\n            ans.add(head.val);\\n            head=head.next;\\n        }\\n         return f(ans,0,ans.size()-1);\\n    }\\n    public TreeNode f(List<Integer>nums,int l,int h){\\n        if(l>h)return null;\\n        int mid=(l+h)/2;\\n        TreeNode node=new TreeNode(nums.get(mid));\\n        node.left=f(nums,l,mid-1);\\n        node.right=f(nums,mid+1,h);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994172,
                "title": "easiest-clean-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode (head->val);\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = nullptr;\\n        TreeNode *node = new TreeNode (slow->val);\\n        node->left = sortedListToBST(head);\\n        node->right = sortedListToBST(slow->next);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return nullptr;\\n        if (!head->next) return new TreeNode (head->val);\\n        ListNode *slow = head, *fast = head, *prev = nullptr;\\n        while (fast && fast->next) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = nullptr;\\n        TreeNode *node = new TreeNode (slow->val);\\n        node->left = sortedListToBST(head);\\n        node->right = sortedListToBST(slow->next);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979949,
                "title": "best-c-solution-simple-linked-list-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head){\\n    \\treturn create( head, NULL );\\n    }\\n\\n    TreeNode *create(ListNode *head, ListNode *tail){\\n    \\t// base case\\n        if(head == tail)\\n    \\t\\treturn NULL;\\n\\n        // find middle of LL\\n    \\tListNode *mid = head, *temp = head;\\n    \\twhile( temp != tail && temp->next != tail ) {\\n    \\t\\tmid = mid->next;\\n    \\t\\ttemp = temp->next->next;\\n    \\t}\\n\\n        // Create new node with mid->val and recursively find its left and right subtree\\n    \\tTreeNode *root = new TreeNode( mid->val );\\n    \\troot->left = create( head, mid );\\n    \\troot->right = create( mid->next, tail );\\n    \\treturn root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *sortedListToBST(ListNode *head){\\n    \\treturn create( head, NULL );\\n    }\\n\\n    TreeNode *create(ListNode *head, ListNode *tail){\\n    \\t// base case\\n        if(head == tail)\\n    \\t\\treturn NULL;\\n\\n        // find middle of LL\\n    \\tListNode *mid = head, *temp = head;\\n    \\twhile( temp != tail && temp->next != tail ) {\\n    \\t\\tmid = mid->next;\\n    \\t\\ttemp = temp->next->next;\\n    \\t}\\n\\n        // Create new node with mid->val and recursively find its left and right subtree\\n    \\tTreeNode *root = new TreeNode( mid->val );\\n    \\troot->left = create( head, mid );\\n    \\troot->right = create( mid->next, tail );\\n    \\treturn root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973266,
                "title": "easy-to-understand-code-with-high-efficiency",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void create(TreeNode* &root, vector<int> &arr, int s, int e){\\n        if(s>e) return;\\n        int mid = (s+e)/2;\\n        root = new TreeNode(arr[mid]);\\n        create(root->left, arr, s, mid-1);\\n        create(root->right, arr, mid+1 , e);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root = NULL;\\n        vector<int> arr;\\n        while(head) {\\n        arr.push_back(head->val);\\n        head=head->next;}\\n        create(root, arr, 0, arr.size()-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Divide and Conquer",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void create(TreeNode* &root, vector<int> &arr, int s, int e){\\n        if(s>e) return;\\n        int mid = (s+e)/2;\\n        root = new TreeNode(arr[mid]);\\n        create(root->left, arr, s, mid-1);\\n        create(root->right, arr, mid+1 , e);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        TreeNode* root = NULL;\\n        vector<int> arr;\\n        while(head) {\\n        arr.push_back(head->val);\\n        head=head->next;}\\n        create(root, arr, 0, arr.size()-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873221,
                "title": "a-c-solution",
                "content": "recursive solution you basically want every mid point of a sub link list to have its left child to be the mid of its left and the right to be the mid of its right\\n(help me clean up my code i know its quite bad)\\n# Code\\n```\\nstruct TreeNode* sortedListToBST(struct ListNode* head){\\n    if(!head) return NULL;\\n    if(!head->next) {\\n        struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n        node->val = head->val;\\n        node->left = NULL;\\n        node->right = NULL;\\n        return node;\\n    }\\n\\n    struct ListNode* slow = head;\\n    struct ListNode* fast = head;\\n    struct ListNode* prev = head;\\n\\n    while(fast && fast->next) {\\n        fast = fast->next->next;\\n        prev = slow;\\n        slow = slow->next;\\n    }\\n\\n    prev->next = NULL;\\n\\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n    node->val = slow->val;\\n    node->left = sortedListToBST(head);\\n    node->right = sortedListToBST(slow->next);\\n\\n    return node;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct TreeNode* sortedListToBST(struct ListNode* head){\\n    if(!head) return NULL;\\n    if(!head->next) {\\n        struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n        node->val = head->val;\\n        node->left = NULL;\\n        node->right = NULL;\\n        return node;\\n    }\\n\\n    struct ListNode* slow = head;\\n    struct ListNode* fast = head;\\n    struct ListNode* prev = head;\\n\\n    while(fast && fast->next) {\\n        fast = fast->next->next;\\n        prev = slow;\\n        slow = slow->next;\\n    }\\n\\n    prev->next = NULL;\\n\\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n    node->val = slow->val;\\n    node->left = sortedListToBST(head);\\n    node->right = sortedListToBST(slow->next);\\n\\n    return node;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3535639,
                "title": "east-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* findmid(ListNode* head){\\n        if(head->next == NULL) return head;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n        \\n        while(slow  != NULL && fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast=fast->next->next;\\n        }\\n        if(prev !=  NULL) prev->next = NULL; // DISCONNECT LINK PREV OF THE MIDDLE  \\n        return slow;\\n    }\\n    TreeNode* solve(ListNode* head){\\n        // BASE CASE \\n        if(head == NULL) return NULL;\\n       \\n        // IF WE HAVE ONLY ONE NODE THEN CREATE TREE AND RETURN \\n        if(head->next == NULL){\\n           TreeNode*root = new TreeNode(head->val);\\n           return root;\\n        }\\n        // FIND MIDDLE NODE OF THE LINK LIST\\n        ListNode*mid = findmid(head);\\n        TreeNode*root = NULL;\\n\\n        // IF MID NULL RETURN NULL\\n        if(mid == NULL ) return NULL;\\n        else root = new TreeNode(mid->val); // ELSE CREATE TREE NODE\\n    \\n         root->left = solve(head); // SOLVE LEFT PART\\n         root->right = solve(mid->next); // SOLVE RIGHT PART\\n         return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n       \\n        if(head == NULL) return NULL;\\n        return solve(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* findmid(ListNode* head){\\n        if(head->next == NULL) return head;\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n        \\n        while(slow  != NULL && fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast=fast->next->next;\\n        }\\n        if(prev !=  NULL) prev->next = NULL; // DISCONNECT LINK PREV OF THE MIDDLE  \\n        return slow;\\n    }\\n    TreeNode* solve(ListNode* head){\\n        // BASE CASE \\n        if(head == NULL) return NULL;\\n       \\n        // IF WE HAVE ONLY ONE NODE THEN CREATE TREE AND RETURN \\n        if(head->next == NULL){\\n           TreeNode*root = new TreeNode(head->val);\\n           return root;\\n        }\\n        // FIND MIDDLE NODE OF THE LINK LIST\\n        ListNode*mid = findmid(head);\\n        TreeNode*root = NULL;\\n\\n        // IF MID NULL RETURN NULL\\n        if(mid == NULL ) return NULL;\\n        else root = new TreeNode(mid->val); // ELSE CREATE TREE NODE\\n    \\n         root->left = solve(head); // SOLVE LEFT PART\\n         root->right = solve(mid->next); // SOLVE RIGHT PART\\n         return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n       \\n        if(head == NULL) return NULL;\\n        return solve(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418157,
                "title": "java-inorder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince the give list is sorted which is equivalent to inorder traversal of binary search tree that is left root right.\\nso it is clear that the root is the middle node of sorted list so using this intuition we are gonna come up with the solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple just always find the middle element in the list using fast and slow pointers.\\nAfter finding the root node that is middle element in the given sorted list we will have to cut the link in order to find the nodes left and right since they are nothing but middle elements in left and right half of the list.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: recursive stack space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        ListNode mid=null;\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            mid=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode node=new TreeNode(slow.val);\\n        mid.next=null;\\n        node.left=sortedListToBST(head);\\n        node.right=sortedListToBST(slow.next);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        if(head.next==null) return new TreeNode(head.val);\\n        ListNode mid=null;\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            mid=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode node=new TreeNode(slow.val);\\n        mid.next=null;\\n        node.left=sortedListToBST(head);\\n        node.right=sortedListToBST(slow.next);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370795,
                "title": "solve-3-questions-with-this-approach-easy-java-fast",
                "content": "```\\n// Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n    List<Integer> ls=new ArrayList<>();\\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        \\n        while(head!=null){\\n            ls.add(head.val);\\n            head=head.next;\\n        }\\n        int start=0;\\n        int end=ls.size()-1;\\n        return createBBST(start,end);\\n        \\n    }\\n    \\n      public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=new TreeNode(ls.get(mid));\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n    List<Integer> ls=new ArrayList<>();\\n    public TreeNode sortedListToBST(ListNode head) {\\n        \\n        \\n        while(head!=null){\\n            ls.add(head.val);\\n            head=head.next;\\n        }\\n        int start=0;\\n        int end=ls.size()-1;\\n        return createBBST(start,end);\\n        \\n    }\\n    \\n      public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=new TreeNode(ls.get(mid));\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287287,
                "title": "my-short-and-concise-java-solution-0ms-and-100-accuracy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode f(ListNode head,ListNode tail){\\n        if(head==tail ) return null;\\n         ListNode slow = head;\\n        ListNode fast =head;\\n       \\n         while(fast!=null && fast.next!=null&& fast != tail&& fast.next!=tail){\\n            slow = slow.next;\\n           \\n            fast = fast.next.next;\\n           \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left =f(head,slow);\\n        root.right = f(slow.next,tail);\\n\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n        return f(head,null);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    private TreeNode f(ListNode head,ListNode tail){\\n        if(head==tail ) return null;\\n         ListNode slow = head;\\n        ListNode fast =head;\\n       \\n         while(fast!=null && fast.next!=null&& fast != tail&& fast.next!=tail){\\n            slow = slow.next;\\n           \\n            fast = fast.next.next;\\n           \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left =f(head,slow);\\n        root.right = f(slow.next,tail);\\n\\n        return root;\\n    }\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n        return f(head,null);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286859,
                "title": "recursive-approach-fast-n-slow-pointer-for-mid-easy-approach",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate mid and consider it as root,then using recursion traverse to the right and left of the list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* middle(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=node && fast->next!=node){\\n             \\n              slow=slow->next;\\n              fast=fast->next->next;\\n        }\\n        return slow;\\n\\n    }\\n    \\n  \\n    TreeNode* solve(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n       ListNode* mid=middle(head,node);\\n       TreeNode* root=new TreeNode(mid->val);\\n        root->left=solve(head,mid);\\n        root->right=solve(mid->next,node);\\n        return root;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n        return NULL;\\n        return solve(head,NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* middle(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=node && fast->next!=node){\\n             \\n              slow=slow->next;\\n              fast=fast->next->next;\\n        }\\n        return slow;\\n\\n    }\\n    \\n  \\n    TreeNode* solve(ListNode* head,ListNode* node){\\n        if(!head|| head==node )\\n        return NULL;\\n       ListNode* mid=middle(head,node);\\n       TreeNode* root=new TreeNode(mid->val);\\n        root->left=solve(head,mid);\\n        root->right=solve(mid->next,node);\\n        return root;\\n    }\\npublic:\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        \\n        if(head==NULL)\\n        return NULL;\\n        return solve(head,NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285640,
                "title": "ultra-simple-dart-solution-o-1-space-how",
                "content": "# Intuition\\nGet the len and the split the list in the middle\\n\\n# Approach\\nThe helper function is needed, because I don\\'t want to modify the start list\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n  TreeNode? _sortedListToBSTHelper(ListNode? head, int len) {\\n      // recursion exit\\n      if (len == 0) {\\n          return null;\\n      }\\n\\n      // go to middle\\n      var middle = head!;\\n      for (int i = 0; i < len ~/ 2; i++) {\\n          middle = middle.next!;\\n      }\\n\\n      var leftSubtree = _sortedListToBSTHelper(head, len ~/ 2);\\n      var rightSubtree = _sortedListToBSTHelper(middle.next, len ~/ 2 - 1 + len % 2);\\n      return new TreeNode(middle.val, leftSubtree, rightSubtree);\\n  }\\n\\n  TreeNode? sortedListToBST(ListNode? head) {\\n      var current = head;\\n\\n      // count len\\n      int len = 0;\\n      while (current != null) {\\n          len++;\\n          current = current.next;\\n      }\\n\\n      return _sortedListToBSTHelper(head, len);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  TreeNode? _sortedListToBSTHelper(ListNode? head, int len) {\\n      // recursion exit\\n      if (len == 0) {\\n          return null;\\n      }\\n\\n      // go to middle\\n      var middle = head!;\\n      for (int i = 0; i < len ~/ 2; i++) {\\n          middle = middle.next!;\\n      }\\n\\n      var leftSubtree = _sortedListToBSTHelper(head, len ~/ 2);\\n      var rightSubtree = _sortedListToBSTHelper(middle.next, len ~/ 2 - 1 + len % 2);\\n      return new TreeNode(middle.val, leftSubtree, rightSubtree);\\n  }\\n\\n  TreeNode? sortedListToBST(ListNode? head) {\\n      var current = head;\\n\\n      // count len\\n      int len = 0;\\n      while (current != null) {\\n          len++;\\n          current = current.next;\\n      }\\n\\n      return _sortedListToBSTHelper(head, len);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285060,
                "title": "beats-100-0ms-fast-slow-pointer-recursion-java-detailed-explanation",
                "content": "# Intuition\\nThe problem requires us to convert a singly linked list to a height-balanced binary search tree. A binary search tree (BST) is a binary tree in which each node has at most two children, and the left subtree of a node contains only nodes with values less than the node\\'s value, and the right subtree contains only nodes with values greater than the node\\'s value. A height-balanced binary search tree is a binary search tree in which the difference in height between the left and right subtrees of any node is at most 1.\\n\\nThe problem seems daunting at first, but it can be solved by using a recursive approach. The key insight is to find the middle element of the linked list and use it as the root of the BST. Since the linked list is sorted in ascending order, the middle element will be the median element, and all the elements to the left of it will be smaller, and all the elements to the right of it will be larger.\\n\\nTo find the middle element of the linked list, we can use the two-pointer approach. We initialize two pointers, slow and fast, to the head of the list. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer points to the middle element.\\n\\nOnce we have the middle element, we create a new node with its value and make it the root of the BST. We then recursively build the left subtree and right subtree of the root node. The left subtree will be built using the elements to the left of the middle element, and the right subtree will be built using the elements to the right of the middle element.\\n\\nThe recursive function should return the root node of the BST. The base cases for the recursion are when the linked list is empty or has only one element. If the linked list is empty, we return null, and if it has only one element, we create a new node with its value and return it.\\n\\nOverall, the problem requires a good understanding of linked lists and binary search trees. The recursive approach can be a bit tricky to implement, but once we understand the intuition behind it, the implementation becomes straightforward.\\n# Approach\\nFirst, we need to check the base cases. If the head is null, return null. If the head has only one element, create a new TreeNode with the value of the head and return it.\\n\\nIf the list has more than one element, we can find the middle element of the list using the two-pointer approach. We initialize two pointers, slow and fast, to the head of the list. The slow pointer moves one step at a time, and the fast pointer moves two steps at a time. When the fast pointer reaches the end of the list, the slow pointer points to the middle element.\\n\\nNow, we create a new TreeNode with the value of the middle element. We set the left child of the new TreeNode to the result of recursively calling the function on the left half of the list (from the head to the element before the middle element). We set the right child of the new TreeNode to the result of recursively calling the function on the right half of the list (from the element after the middle element to the end of the list).\\n\\nFinally, we return the new TreeNode.\\n\\n# Complexity\\n- Time complexity:  $$O(N)$$\\nThe algorithm visits every node in the linked list once to find the middle element, and every node in the BST once to insert it. Therefore, the time complexity of the algorithm is O(n), where n is the number of nodes in the linked list.\\n\\n- Space complexity: $$O(N)$$\\nThe algorithm uses O(log n) space on the call stack due to the recursive calls. The maximum depth of the call stack is log n since the height of the BST is balanced. In addition, the algorithm uses O(n) space to store the BST, where n is the number of nodes in the linked list, since each node in the linked list becomes a node in the BST. Therefore, the overall space complexity of the algorithm is O(n + log n), which simplifies to O(n) since O(n) is greater than O(log n).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/28e4e843-4e64-4b0f-88f2-2c9b6987c802_1678555457.6311016.png)\\n\\n---\\n\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)\\n![image.png](https://assets.leetcode.com/users/images/f36a288e-bdb7-4264-b2d5-8d7275e29330_1678259367.2213438.png)",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null)\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        TreeNode res=new TreeNode(slow.next.val);\\n        ListNode righthalf=slow.next.next;\\n        slow.next=null;\\n        res.left=sortedListToBST(head);\\n        res.right=sortedListToBST(righthalf);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284875,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n    TreeNode* convertToBST(ListNode* start, ListNode* end){\\n        if(start == end) return nullptr;\\n        ListNode* slow = start;\\n        ListNode* fast = start;\\n\\n        while(fast!=end && fast->next!=end){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        TreeNode* head = new TreeNode(slow->val);\\n        head->left = convertToBST(start, slow);\\n        head->right = convertToBST(slow->next, end);\\n        return head;\\n    }\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if(head == nullptr) return nullptr;\\n        return convertToBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284844,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur task is to convert the sorted linked list into binary search tree.\\nTo meet our requirement we have to first find the middle of the linked list which is root of our subtree.\\nThen we create a subtree for first half as for the second half as well. \\nIf any place we find left == right that means we are already done with this node then simply return the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Find the middle node of the current linked list then make it root of the subtree (Note:- https://leetcode.com/problems/middle-of-the-linked-list/submissions/863862488/ *Find middle node of linked list*).\\n* After that do recursive call to build\\n    * left subtree\\n    * right subtree\\n* Return root of the subtree\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n# Code\\n```C++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(ListNode *leftSubtree, ListNode *rightSubtree) {\\n        if (leftSubtree == rightSubtree)\\n            return nullptr;\\n        ListNode *slow = leftSubtree, *fast = leftSubtree;\\n        while (fast != rightSubtree && fast -> next != rightSubtree) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        TreeNode *root = new TreeNode(slow -> val);\\n        root -> left = constructBST(leftSubtree, slow);\\n        root -> right = constructBST(slow -> next, rightSubtree);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (head == nullptr)\\n            return nullptr;\\n        if (head -> next == nullptr) {\\n            TreeNode *root = new TreeNode(head -> val);\\n            return root;\\n        }\\n        return constructBST(head, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* constructBST(ListNode *leftSubtree, ListNode *rightSubtree) {\\n        if (leftSubtree == rightSubtree)\\n            return nullptr;\\n        ListNode *slow = leftSubtree, *fast = leftSubtree;\\n        while (fast != rightSubtree && fast -> next != rightSubtree) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        TreeNode *root = new TreeNode(slow -> val);\\n        root -> left = constructBST(leftSubtree, slow);\\n        root -> right = constructBST(slow -> next, rightSubtree);\\n        return root;\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (head == nullptr)\\n            return nullptr;\\n        if (head -> next == nullptr) {\\n            TreeNode *root = new TreeNode(head -> val);\\n            return root;\\n        }\\n        return constructBST(head, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284699,
                "title": "python-3-one-line-bonus-day-stout-warren-dsw",
                "content": "One line (list expansion):\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        return (f:=lambda i,j:None if i>j else TreeNode(v[(m:=(i+j)//2)],f(i,m-1),f(m+1,j)))(0,len(v:=(g:=lambda x:x and[x.val]+g(x.next)or[])(head))-1)\\n```\\nDSW (taken from wiki verbatim): https://en.wikipedia.org/wiki/Day%E2%80%93Stout%E2%80%93Warren_algorithm\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def list_to_vine(head):\\n            size = 0\\n            curr = root = TreeNode()\\n            while head:\\n                curr.right = TreeNode(head.val)\\n                curr = curr.right\\n                head = head.next\\n                size += 1\\n            return root, size\\n\\n        def vine_to_tree(root, size):\\n            leaves = size + 1 - int(2**int(log2(size+1)))\\n            compress(root, leaves)\\n            size -= leaves\\n            while size > 1:\\n                size //= 2\\n                compress(root, size)\\n\\n        def compress(root, count):\\n            scanner = root\\n            for _ in range(count):\\n                child = scanner.right\\n                scanner.right = child.right\\n                scanner = scanner.right\\n                child.right = scanner.left\\n                scanner.left = child\\n\\n        root, size = list_to_vine(head)\\n        vine_to_tree(root, size)\\n        return root.right\\n```\\nThe latter is O(1) memory considering we still need to allocate a tree.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        return (f:=lambda i,j:None if i>j else TreeNode(v[(m:=(i+j)//2)],f(i,m-1),f(m+1,j)))(0,len(v:=(g:=lambda x:x and[x.val]+g(x.next)or[])(head))-1)\\n```\n```\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\\n        def list_to_vine(head):\\n            size = 0\\n            curr = root = TreeNode()\\n            while head:\\n                curr.right = TreeNode(head.val)\\n                curr = curr.right\\n                head = head.next\\n                size += 1\\n            return root, size\\n\\n        def vine_to_tree(root, size):\\n            leaves = size + 1 - int(2**int(log2(size+1)))\\n            compress(root, leaves)\\n            size -= leaves\\n            while size > 1:\\n                size //= 2\\n                compress(root, size)\\n\\n        def compress(root, count):\\n            scanner = root\\n            for _ in range(count):\\n                child = scanner.right\\n                scanner.right = child.right\\n                scanner = scanner.right\\n                child.right = scanner.left\\n                scanner.left = child\\n\\n        root, size = list_to_vine(head)\\n        vine_to_tree(root, size)\\n        return root.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284181,
                "title": "solved-using-recursion-java-divide-and-conquer",
                "content": "# Intuition\\nDivide the list in 2 lists and a node in middle and then make binary tree using that node are root and 1st list before that node as left part of tree and 2nd list after that middle node as right part of the tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null )\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode fst = head;\\n        ListNode snd = head.next.next;\\n        while(snd!=null && snd.next!=null){\\n            fst=fst.next;\\n            snd=snd.next.next;\\n        }\\n        TreeNode node = new TreeNode(fst.next.val);\\n        ListNode rhalf = fst.next.next;\\n        fst.next=null;\\n        node.left = sortedListToBST(head);\\n        node.right = sortedListToBST(rhalf);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null )\\n            return null;\\n        if(head.next==null)\\n            return new TreeNode(head.val);\\n        ListNode fst = head;\\n        ListNode snd = head.next.next;\\n        while(snd!=null && snd.next!=null){\\n            fst=fst.next;\\n            snd=snd.next.next;\\n        }\\n        TreeNode node = new TreeNode(fst.next.val);\\n        ListNode rhalf = fst.next.next;\\n        fst.next=null;\\n        node.left = sortedListToBST(head);\\n        node.right = sortedListToBST(rhalf);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283888,
                "title": "java-solution-using-slow-and-fast-pointer",
                "content": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        if(head.next==null){\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode slowPrevious = null;\\n        \\n        while(fast!=null && fast.next!=null){\\n            slowPrevious = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        slowPrevious.next = null;\\n        \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        \\n        return root;\\n    }\\n}\\n```\\n\\n\\uD83D\\uDC46 vote if you like it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if(head==null){\\n            return null;\\n        }\\n        if(head.next==null){\\n            return new TreeNode(head.val);\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode slowPrevious = null;\\n        \\n        while(fast!=null && fast.next!=null){\\n            slowPrevious = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n            \\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        slowPrevious.next = null;\\n        \\n        root.left = sortedListToBST(head);\\n        root.right = sortedListToBST(slow.next);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283095,
                "title": "best-java-solution-for-easy-understand-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse recursion method approach here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nStep 1] Create ArrayList.\\nStep 2] Count of the element in the linked list.\\nStep 3] Create method with start and end index with ArrayList.\\nStep 4] if (start > end) return null;\\nStep 5] Get mid by mid formula.\\nStep 6] Add into treeNode as root.\\nStep 7] Do recursion for root.left for (0 to mid-1).\\nStep 8] Do recursion for root.right for (mid+1 to end).\\nStep 9] return root to created method.\\nStep 10] return recursive method.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\n        while(head != null)\\n        {\\n            list.add(head.val); \\n            head = head.next;\\n        }\\n\\n        return BST(0,list,list.size()-1);\\n    }\\n\\n    public TreeNode BST(int start, ArrayList<Integer> list, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n\\n        int mid = (start + end + 1)/2;\\n\\n        TreeNode root = new TreeNode(list.get(mid));\\n\\n        root.left = BST(start, list , mid-1);\\n        \\n        root.right = BST(mid+1, list , end);\\n\\n        return root;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public TreeNode sortedListToBST(ListNode head) {\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\n        while(head != null)\\n        {\\n            list.add(head.val); \\n            head = head.next;\\n        }\\n\\n        return BST(0,list,list.size()-1);\\n    }\\n\\n    public TreeNode BST(int start, ArrayList<Integer> list, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n\\n        int mid = (start + end + 1)/2;\\n\\n        TreeNode root = new TreeNode(list.get(mid));\\n\\n        root.left = BST(start, list , mid-1);\\n        \\n        root.right = BST(mid+1, list , end);\\n\\n        return root;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283019,
                "title": "share-my-java-solution-easy-and-beginner-friend-bina",
                "content": "# Intitution\\nDivide linked into two parts start to mid and mid to end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find mid of linkedList\\n2. mid point is root node of tree.\\n3. divide problem into sub problem like head to mid of linked list is left side of tree and mid + 1 to tail of linkedlist is right side of tree.\\n4. find mid point in left side and right side.\\n5. Repeat step 2, 3 and 4. till head and tail both are equal.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        return toBst(head, null);\\n    }\\n\\n    private TreeNode toBst(ListNode head, ListNode tail) {\\n        if (head == tail) {\\n            return null;\\n        }\\n\\n        ListNode slow = head, fast = head;\\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = toBst(head, slow);\\n        root.right = toBst(slow.next, tail);\\n        return root;\\n    }\\n}\\n```\\n\\n# Deep Explanation In Hindi\\nhttps://youtu.be/kHyfyzYC7vA",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        return toBst(head, null);\\n    }\\n\\n    private TreeNode toBst(ListNode head, ListNode tail) {\\n        if (head == tail) {\\n            return null;\\n        }\\n\\n        ListNode slow = head, fast = head;\\n        while (fast != tail && fast.next != tail) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        TreeNode root = new TreeNode(slow.val);\\n        root.left = toBst(head, slow);\\n        root.right = toBst(slow.next, tail);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282944,
                "title": "plz-don-t-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n\\t    \\t\\n\\t    \\tif(head == null)\\n\\t    \\t\\treturn null;\\n            if(head.next==null) {\\n\\t\\t\\tTreeNode node = new TreeNode(head.val);\\n\\t\\t\\treturn node;\\n\\t\\t}\\n\\t    \\t\\n\\t    \\tListNode mid = findMid(head);\\n\\t    \\tTreeNode node = new TreeNode(mid.val);\\n\\t    \\tnode.left = sortedListToBST(head);\\n\\t    \\tnode.right = sortedListToBST(mid.next);\\n\\t    \\t\\n\\t        return node;\\n\\t     \\n    }\\n\\n      public ListNode findMid(ListNode start) {\\n\\t    \\t\\n\\t    \\tListNode fast = start;\\n\\t    \\tListNode prev = start;\\n\\t    \\t\\n\\t    \\twhile(fast!=null && fast.next!=null) {\\n\\t    \\t\\tprev = start;\\n\\t    \\t\\tstart = start.next;\\n\\t    \\t\\tfast=fast.next.next;\\n\\t    \\t}\\n\\t    \\tprev.next = null;\\n\\t    \\treturn start;\\n\\t    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n       \\n\\t    \\t\\n\\t    \\tif(head == null)\\n\\t    \\t\\treturn null;\\n            if(head.next==null) {\\n\\t\\t\\tTreeNode node = new TreeNode(head.val);\\n\\t\\t\\treturn node;\\n\\t\\t}\\n\\t    \\t\\n\\t    \\tListNode mid = findMid(head);\\n\\t    \\tTreeNode node = new TreeNode(mid.val);\\n\\t    \\tnode.left = sortedListToBST(head);\\n\\t    \\tnode.right = sortedListToBST(mid.next);\\n\\t    \\t\\n\\t        return node;\\n\\t     \\n    }\\n\\n      public ListNode findMid(ListNode start) {\\n\\t    \\t\\n\\t    \\tListNode fast = start;\\n\\t    \\tListNode prev = start;\\n\\t    \\t\\n\\t    \\twhile(fast!=null && fast.next!=null) {\\n\\t    \\t\\tprev = start;\\n\\t    \\t\\tstart = start.next;\\n\\t    \\t\\tfast=fast.next.next;\\n\\t    \\t}\\n\\t    \\tprev.next = null;\\n\\t    \\treturn start;\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282805,
                "title": "c-binary-search-clean-code",
                "content": "# Intuition\\nList is sorted so we can take an element as a root then left side element of we can say smaller element should be in the left subtree and greater element should be in the right of the root .Similarly we can proceed for all the element .Just like we do in binary search we find the mid then again we solve for its left and right .\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwe can choose any element as a root .If we will choose middle element as a root then height of the BST will be minimum because left and right subtree will have almost same element whereas if we will not choose the middle element as a root then one subtree have mre number of node then the other leads to larger height.\\n\\nSo here i have used binary search approach.First of all store the element of list in a vector , now we will find the mid of the vector this will be the root for example([0,1,4,9,23]) mid = (0 + 5)/2 i.e 2.\\nso index 2 will be the mid this will be the root ,  [0,1] will be in left subtree and [9,23] will in the right subtree again solve for [0,1] and [9,23] separately\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n) where n is the size of the list \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n) where n is the size of the list \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode *ans = NULL;\\n    void solve(vector<int>&v , int l , int r , TreeNode *root , int side){\\n        if(l > r)return;\\n\\n        int mid = (l+r)/2;\\n        TreeNode *temp = new TreeNode(v[mid]);\\n        if(root == NULL){\\n            ans = temp;//if root is Null it means it is root of the tree\\n            root = temp;\\n        }else{\\n            //side variable i have used to recognize child\\n            //-1 means left child and +1 means right child\\n            if(side == -1){\\n                root->left = temp;\\n            }else{\\n                root->right = temp;\\n            }\\n        }\\n\\n        //solve for left subtree\\n        solve(v , l , mid-1 , temp , -1);\\n\\n        //solve for right subtree\\n        solve(v , mid + 1 , r , temp , 1);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //we can use the divide and conquer method \\n        vector<int>v;\\n        ListNode *temp = head;\\n        while(temp){\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        //now we got the sorted vector\\n        TreeNode *node = NULL;\\n        int n = v.size();\\n        solve(v , 0 , n-1 , node , 0);\\n        return ans;\\n    }\\n};\\n upvote if it was helpful\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode *ans = NULL;\\n    void solve(vector<int>&v , int l , int r , TreeNode *root , int side){\\n        if(l > r)return;\\n\\n        int mid = (l+r)/2;\\n        TreeNode *temp = new TreeNode(v[mid]);\\n        if(root == NULL){\\n            ans = temp;//if root is Null it means it is root of the tree\\n            root = temp;\\n        }else{\\n            //side variable i have used to recognize child\\n            //-1 means left child and +1 means right child\\n            if(side == -1){\\n                root->left = temp;\\n            }else{\\n                root->right = temp;\\n            }\\n        }\\n\\n        //solve for left subtree\\n        solve(v , l , mid-1 , temp , -1);\\n\\n        //solve for right subtree\\n        solve(v , mid + 1 , r , temp , 1);\\n    }\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        //we can use the divide and conquer method \\n        vector<int>v;\\n        ListNode *temp = head;\\n        while(temp){\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        //now we got the sorted vector\\n        TreeNode *node = NULL;\\n        int n = v.size();\\n        solve(v , 0 , n-1 , node , 0);\\n        return ans;\\n    }\\n};\\n upvote if it was helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282679,
                "title": "rust-two-pointer-solution",
                "content": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        Self::_sorted_list_to_bst(head.as_ref(), None)\\n    }\\n\\n    fn _sorted_list_to_bst(\\n        head: Option<&Box<ListNode>>,\\n        tail: Option<&Box<ListNode>>,\\n    ) -> Option<Rc<RefCell<TreeNode>>> {\\n        // 1. head is None\\n        // 2. head is tail node\\n        if head == tail {\\n            return None;\\n        }\\n        // two pointer\\n        let mut slow = head;\\n        let mut fast = head;\\n\\n        // fast is not None or tail node\\n        while fast != tail {\\n            let fast_next = fast.and_then(|n| n.next.as_ref());\\n            if fast_next == tail {\\n                break;\\n            }\\n            // move one step\\n            slow = slow.and_then(|n| n.next.as_ref());\\n            // move  two step\\n            fast = fast_next.and_then(|n| n.next.as_ref());\\n        }\\n        let mut tree_node = TreeNode::new(slow.unwrap().val);\\n        tree_node.left = Self::_sorted_list_to_bst(head, slow);\\n        tree_node.right = Self::_sorted_list_to_bst(slow.unwrap().next.as_ref(), tail);\\n\\n        Some(Rc::new(RefCell::new(tree_node)))\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\n\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\nimpl Solution {\\n    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        Self::_sorted_list_to_bst(head.as_ref(), None)\\n    }\\n\\n    fn _sorted_list_to_bst(\\n        head: Option<&Box<ListNode>>,\\n        tail: Option<&Box<ListNode>>,\\n    ) -> Option<Rc<RefCell<TreeNode>>> {\\n        // 1. head is None\\n        // 2. head is tail node\\n        if head == tail {\\n            return None;\\n        }\\n        // two pointer\\n        let mut slow = head;\\n        let mut fast = head;\\n\\n        // fast is not None or tail node\\n        while fast != tail {\\n            let fast_next = fast.and_then(|n| n.next.as_ref());\\n            if fast_next == tail {\\n                break;\\n            }\\n            // move one step\\n            slow = slow.and_then(|n| n.next.as_ref());\\n            // move  two step\\n            fast = fast_next.and_then(|n| n.next.as_ref());\\n        }\\n        let mut tree_node = TreeNode::new(slow.unwrap().val);\\n        tree_node.left = Self::_sorted_list_to_bst(head, slow);\\n        tree_node.right = Self::_sorted_list_to_bst(slow.unwrap().next.as_ref(), tail);\\n\\n        Some(Rc::new(RefCell::new(tree_node)))\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282633,
                "title": "solution-with-explanation-golang-recursive-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo to be sorted array with height balanced sorted tree, we need to take middle number from already sorted list of numbers and put it to the base of the tree; Numbers of the left from middle would be on the left of the base and The numbers on the right from middle should be on the right of the base. \\nExample: -5,-2,0,1,3,5,7,9,10\\n```\\n                3   \\n        0       |           9    \\n    -2  |    1  |       7   |    10\\n-5      |       |   5       |\\n```\\nso the heights are equal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is to take the numbers from linked list and store them in a slice. Then construct height balanced binary tree from that slice of numbers(int). I assumed that given linked list is already sorted and there is no need to sort slice after getting numbers. If it is not sorted, just use standart library to sort. Ofc there is a way to construct height balanced binary tree from not sorted list of numbers using rotations.\\nNow we have our list of numbers, wecan recursively add numbers to Tree.\\n\\n```\\nfunc sortedArrayToBST(nums []int) *TreeNode\\n```\\n1. Construct Binary Search Tree Node - `bnode`\\n2. `if len(nums)` equal to zero then - we reached the end of Tree return nil\\n3. `if len(nums) == 1` then we reached end of Tree then just return that number\\n4. `If len(nums) > 1` then add value in the middle of nums to bnode\\n5. Call this function with numbers to the left of the middle `nums[:mid]` and assign it `bnode.Left`\\n6. Call this function with numbers to the right of the middle `nums[mid:]` and assign it `bnode.Right`\\n7. Return `bnode`\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n- Space complexity:` O(n)`\\n\\n\\n\\n# Code\\n```Golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sortedArrayToBST(nums []int) *TreeNode {\\n\\tbnode := &TreeNode{}\\n\\tif len(nums) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tif len(nums) == 1 {\\n\\t\\tbnode.Val = nums[0]\\n\\t\\treturn bnode\\n\\t}\\n\\tmid := len(nums) / 2\\n\\tbnode.Val = nums[mid]\\n\\tbnode.Left = sortedArrayToBST(nums[:mid])\\n\\tbnode.Right = sortedArrayToBST(nums[mid+1:])\\n\\treturn bnode\\n\\n}\\n\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n\\tnumbers := []int{}\\n\\n\\tfor head != nil {\\n\\t\\tnumbers = append(numbers, head.Val)\\n\\t\\thead = head.Next\\n\\t}\\n\\treturn sortedArrayToBST(numbers)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n                3   \\n        0       |           9    \\n    -2  |    1  |       7   |    10\\n-5      |       |   5       |\\n```\n```\\nfunc sortedArrayToBST(nums []int) *TreeNode\\n```\n```Golang []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc sortedArrayToBST(nums []int) *TreeNode {\\n\\tbnode := &TreeNode{}\\n\\tif len(nums) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\tif len(nums) == 1 {\\n\\t\\tbnode.Val = nums[0]\\n\\t\\treturn bnode\\n\\t}\\n\\tmid := len(nums) / 2\\n\\tbnode.Val = nums[mid]\\n\\tbnode.Left = sortedArrayToBST(nums[:mid])\\n\\tbnode.Right = sortedArrayToBST(nums[mid+1:])\\n\\treturn bnode\\n\\n}\\n\\nfunc sortedListToBST(head *ListNode) *TreeNode {\\n\\tnumbers := []int{}\\n\\n\\tfor head != nil {\\n\\t\\tnumbers = append(numbers, head.Val)\\n\\t\\thead = head.Next\\n\\t}\\n\\treturn sortedArrayToBST(numbers)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282616,
                "title": "explained-with-pic-begineer-freindly-o-log-n-2-ways",
                "content": "# IF U LIKE EXPLAINATION ==> PLZ UPVOTE\\n![bst1.jpeg](https://assets.leetcode.com/users/images/366eaeca-4ee9-46fe-ac4d-b78dde84e422_1678513492.1197546.jpeg)\\n\\n\\nA. Solution 1: Convert linked list to array then do PreOrder Traversal\\n\\n1. Convert linked list to PRIMATIVE INT array\\n2. Choose A[mid] as a root\\n3. Solve sub problem (left, mid - 1), make it as left node\\n4. Solve sub problem (mid + 1, right), make it as right node\\n5. USING PRIMATIVES INT ARRAY RANDOM ACCESS IS CONSTANT O(1);\\n\\n![bst2.jpeg](https://assets.leetcode.com/users/images/4067be1d-3f4e-4009-8869-83e10710e2f9_1678513499.681521.jpeg)\\n\\nB. Solution : InOrder Traversal\\n\\n1. It\\'s a good chance to use In Order Traveral here, where we traverse Left - Root - Right.\\n2. Firstly, we calculate of number of elements in the linked list, let name it n.\\n3. We keep global head, in the beginning root points to the first element in the BST.\\n4. Let dfs(left, right) return the root of the height balanced BST when building in elements from left to right of the linked list.\\nOur answer is the root which is returned from dfs(0, n-1).\\n5. In dfs(left, right) function:\\nmid = (left + (right-left) / 2)\\n6. Firstly, we build BST left subtree, by leftNode = dfs(left, mid-1), after finish building left subtree, now root will point to the mid element.\\n7. So we take the root value from head.val and move head to next, by root = TreeNode(root.val); root = root.val\\nFinally, we build the right node of the root, by rightNode = dfs(mid+1, right).\\n\\n# Code\\n```SOLUTION_A []\\nprivate int[] A;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int len=0;\\n        if(head==null) return null;\\n        ListNode tem=head;\\n        while(tem!=null){\\n            len++;\\n            tem=tem.next;\\n        }\\n        this.A = new int[len];\\n        int i=0;\\n        ListNode root=head;\\n        while(root!=null){\\n            A[i++]=root.val;\\n            root=root.next;\\n        }\\n        return bst(0,len-1);\\n    }\\nprivate TreeNode bst(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode ans = new TreeNode(A[mid]);\\n        ans.left=bst(left,mid-1);\\n        ans.right=bst(mid+1,right);\\n        return ans;\\n    }\\n```\\n```SOLUTION_B []\\nprivate ListNode root;\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        this.root=head;\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }\\n        return dfs(0,len-1);\\n    }\\nprivate TreeNode dfs(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode leftNode =dfs(left,mid-1);\\n        TreeNode ans = new TreeNode(root.val);\\n        root=root.next;\\n        ans.left=leftNode;\\n        ans.right=dfs(mid+1,right);\\n        return ans;\\n    }\\n```\\n\\n# Complexity\\n- Time complexity: s1=s2==O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) FOR INT ARRAY, s2=(logN) for rec call stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![MEME.png](https://assets.leetcode.com/users/images/457ac5b7-bb2f-4d6b-bdc6-6e415dd82708_1678511465.7266335.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Tree"
                ],
                "code": "```SOLUTION_A []\\nprivate int[] A;\\n    public TreeNode sortedListToBST(ListNode head) {\\n        int len=0;\\n        if(head==null) return null;\\n        ListNode tem=head;\\n        while(tem!=null){\\n            len++;\\n            tem=tem.next;\\n        }\\n        this.A = new int[len];\\n        int i=0;\\n        ListNode root=head;\\n        while(root!=null){\\n            A[i++]=root.val;\\n            root=root.next;\\n        }\\n        return bst(0,len-1);\\n    }\\nprivate TreeNode bst(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode ans = new TreeNode(A[mid]);\\n        ans.left=bst(left,mid-1);\\n        ans.right=bst(mid+1,right);\\n        return ans;\\n    }\\n```\n```SOLUTION_B []\\nprivate ListNode root;\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if(head==null) return null;\\n        this.root=head;\\n        int len=0;\\n        while(head!=null){\\n            len++;\\n            head=head.next;\\n        }\\n        return dfs(0,len-1);\\n    }\\nprivate TreeNode dfs(int left,int right){\\n        if(left>right) return null;\\n        int mid = left+(right-left)/2;\\n        TreeNode leftNode =dfs(left,mid-1);\\n        TreeNode ans = new TreeNode(root.val);\\n        root=root.next;\\n        ans.left=leftNode;\\n        ans.right=dfs(mid+1,right);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3282471,
                "title": "python-short-and-clean-beats-99-5-runtime-functional-programming",
                "content": "# Approach\\n1. Find the length `n` of the `LinkedList`.\\n\\n2. A balanced BST of `n` nodes would have, say `[nl, 1, nr]` nodes for `[left_BST, root, right_BST]` respecitively.\\n\\n3. `1` out of `n` is used for `root`.\\n    The remaining `n - 1` nodes are divided into:\\n    `nl = (n - 1) // 2`,\\n    `nr = (n - 1) - nl`\\n\\n4. Recursively construct the `BST` by:\\n    Consuming first `nl` nodes of the `LinkedList` to construct `left_BST`.\\n    Consuming `1` node for `root`.\\n    Consuming remaining `nr` nodes of the `LinkedList` to construct `right_BST`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(log(n))$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n        def iter_LL(ll: ListNode | None) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n        \\n        def len_LL(ll: ListNode | None) -> int:\\n            return sum(1 for _ in iter_LL(ll))\\n        \\n        def sorted_iter_to_BST(xs: Iterator, n: int) -> TreeNode | None:\\n            if n == 0: return None\\n\\n            nl = (n - 1) // 2\\n            nr = (n - 1) - nl\\n\\n            l_bst = sorted_iter_to_BST(xs, nl)\\n            val = next(xs)\\n            r_bst = sorted_iter_to_BST(xs, nr)\\n\\n            return TreeNode(val, l_bst, r_bst)\\n        \\n        return sorted_iter_to_BST((x.val for x in iter_LL(head)), len_LL(head))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Divide and Conquer",
                    "Binary Search Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\\n        def iter_LL(ll: ListNode | None) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n        \\n        def len_LL(ll: ListNode | None) -> int:\\n            return sum(1 for _ in iter_LL(ll))\\n        \\n        def sorted_iter_to_BST(xs: Iterator, n: int) -> TreeNode | None:\\n            if n == 0: return None\\n\\n            nl = (n - 1) // 2\\n            nr = (n - 1) - nl\\n\\n            l_bst = sorted_iter_to_BST(xs, nl)\\n            val = next(xs)\\n            r_bst = sorted_iter_to_BST(xs, nr)\\n\\n            return TreeNode(val, l_bst, r_bst)\\n        \\n        return sorted_iter_to_BST((x.val for x in iter_LL(head)), len_LL(head))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282466,
                "title": "o-nlogn-solution",
                "content": "**1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.**\\n\\n**2.Create a new node with the value of the middle element, and make it the root of the binary search tree.**\\n\\n**3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.**\\n\\n**4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.**\\n\\n**5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.**\\n\\n**6.Return the root of the binary search tree.**\\n```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // find the middle element of the linked list\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // create a new node with the value of the middle element\\n        TreeNode root = new TreeNode(slow.val);\\n        // recursively convert the left half of the linked list to the left subtree of the root\\n        if (prev != null) {\\n            prev.next = null;\\n            root.left = sortedListToBST(head);\\n        }\\n        // recursively convert the right half of the linked list to the right subtree of the root\\n        root.right = sortedListToBST(slow.next);\\n        return root;  \\n    }\\n}\\n```\\n# UPVOTING IS MUCH APPRECIATED",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // find the middle element of the linked list\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // create a new node with the value of the middle element\\n        TreeNode root = new TreeNode(slow.val);\\n        // recursively convert the left half of the linked list to the left subtree of the root\\n        if (prev != null) {\\n            prev.next = null;\\n            root.left = sortedListToBST(head);\\n        }\\n        // recursively convert the right half of the linked list to the right subtree of the root\\n        root.right = sortedListToBST(slow.next);\\n        return root;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282438,
                "title": "recursive-approach-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head is None:return head\\n        if head.next is None:return TreeNode(head.val)\\n        slow,fast=head,head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        data,right,slow.next=slow.next.val,slow.next.next,None\\n        return TreeNode(val=data,left=self.sortedListToBST(head), \\n\\t\\t    right=self.sortedListToBST(right))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        if head is None:return head\\n        if head.next is None:return TreeNode(head.val)\\n        slow,fast=head,head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        data,right,slow.next=slow.next.val,slow.next.next,None\\n        return TreeNode(val=data,left=self.sortedListToBST(head), \\n\\t\\t    right=self.sortedListToBST(right))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282339,
                "title": "solution-and-explanation-to-the-problem-convert-sorted-list-to-bst-java-code",
                "content": "# Intuition\\nIt is easy to oserve that there must be nearly equal number of elements in the left and right subtree to make it height balanced so in a list of sorted elements the middle element can act as the most appropritate root value and the elements to the left will form the left subtree and the elements to the right will form the right subtree.\\n\\n# Approach\\nThe entire problem can be broken into 2 parts:-\\n1) Storing the list in such a way that its elements can be accessed in O(1) time.\\n2) Use the above created data structure to find the root node at each level and the elements which should be in the left and right subtree respectively.\\n3) Create the node which we are currently at and recussively call the function for the left half and the right half until no element is left.\\n\\n# Complexity\\n- Time complexity:\\nAll the nodes are visited once and the left and right subtree is computed accordingly. The time complexity is O(n).\\n\\n- Space complexity:\\n Space Complexity is O(n) since we use an extra array to store the elements of the list.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode sortedListToBST(ListNode head) {\\n        \\n        ArrayList<Integer> l1=new ArrayList<>();\\n        while(head!=null)\\n        {\\n            l1.add(head.val);\\n            head=head.next;\\n        }\\n        return func(l1,0,l1.size()-1);\\n    }\\n    public static TreeNode func(ArrayList<Integer> l1,int lo,int hi)\\n    {\\n        if(lo>hi) return null;\\n\\n        int mid=(lo+hi)/2;\\n        TreeNode t1=new TreeNode(l1.get(mid));\\n        t1.left=func(l1,lo,mid-1);\\n        t1.right=func(l1,mid+1,hi);\\n        return t1;\\n    }\\n}\\n\\n```\\n# PLEASE DO UPVOTE THE SOLUTION !! :)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode sortedListToBST(ListNode head) {\\n        \\n        ArrayList<Integer> l1=new ArrayList<>();\\n        while(head!=null)\\n        {\\n            l1.add(head.val);\\n            head=head.next;\\n        }\\n        return func(l1,0,l1.size()-1);\\n    }\\n    public static TreeNode func(ArrayList<Integer> l1,int lo,int hi)\\n    {\\n        if(lo>hi) return null;\\n\\n        int mid=(lo+hi)/2;\\n        TreeNode t1=new TreeNode(l1.get(mid));\\n        t1.left=func(l1,lo,mid-1);\\n        t1.right=func(l1,mid+1,hi);\\n        return t1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1828890,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568047,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828583,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828578,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828562,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828726,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568930,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828659,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1571228,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828892,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828890,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568047,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828583,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828578,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828562,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828726,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1568930,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828659,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1571228,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828892,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Fact - Britishers were/are good at Divide and Conquer algorithms."
                    },
                    {
                        "username": "stefan1096",
                        "content": "yes I am"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "So, I started of this problem by first solvin gthe array version of this problem here: https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/, which is marked under the easy version. \\n\\nSo when I saw this question, my initial question was, why dont I convert the list into an array and solve it like the array version which would give me O(n) solution. After I did that, I looked at the other submitted solutions under the discussion tab and noticed that most people were using the two pointer method and recursion, which at best would give an O(nlogn) method.\\n\\nSo my question is why did a lot of people choose that option? There is nothing in the constraints that indicate we can not use an external buffer or space. And converting to another datastructure and solving it like before is by far the first and easiest solution that comes to mind.\\n\\n* *PS: Sorry if this question seems midly dumb. I just want to find out if I missed something.*"
                    },
                    {
                        "username": "rajAbhinav",
                        "content": "bro then whats the point of using linked list  or trees if u can convert every single such question into an array format?\nthe linked List and tree itself stands for its own properties which make it differs from contagious memory allocations though u r right about the absence constraints but u shoukd challenge yourself to solve it in the given space format."
                    },
                    {
                        "username": "rosie-i",
                        "content": "Yeah, I was thinking this and did go for an array solution, but I guess you could say that if it\\'s a linked list question, the point is to see if you can work with that data structure. I know what you mean though and I wonder whether it\\'s ok to do that in an interview or not."
                    },
                    {
                        "username": "sk03167",
                        "content": "I just though of it like yesterday\\'s question. What if you don\\'t have access to all the elements at the same time. What if the linked list is ever expanding and you need to check each time a new element is added. Hence, I didn\\'t want to do this using an array otherwise it\\'d just be an array problem."
                    },
                    {
                        "username": "cskrisz",
                        "content": "It can be done in O(n) even without converting to array."
                    },
                    {
                        "username": "charonme",
                        "content": "depends on your application, sometimes you don\\'t have a lot of data, have enough memory and want to do it fast, other times you have a lot of data, little memory and don\\'t mind taking it a bit longer"
                    },
                    {
                        "username": "vpaliwal16",
                        "content": "In real world, you would always want to optimise your solution."
                    },
                    {
                        "username": "Hakuuu",
                        "content": "Trying new approach never hurts \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "Diamantis",
                        "content": "If you want some tips without the full solution keep reading:\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n1. The problem is easier if you use extra space to store the linked list in a more convenient data structure.\n2. You can store the list into an array so that you can conveniently choose any index in $O(1)$ time complexity.\n3. Use recursion to create the height-balanced BST.\n4. [Here](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/) is an easier version of this problem.\n5. If you want to solve the problem in $O(1)$ space complexity, without increasing your time complexity, think in terms of an inorder traversal."
                    },
                    {
                        "username": "nikhilpatil2532000",
                        "content": "ooaa thanks, I really don\\'t know that we can use array to solve this problem ;)"
                    },
                    {
                        "username": "indrazit",
                        "content": "Using recursion takes O(log n) extra memory, because the recursion depth is O(log n), which means we consume O(log n) memory in the function calls, though we do not use the memory in the form of variables.  It will be clearer if we convert the recursion to a loop."
                    },
                    {
                        "username": "Shahad-H",
                        "content": "Linked list week !!"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "[@aeroabrar_31](/aeroabrar_31) from where do you get to know the schedule?may i know? would help me to prepare"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Linked lists are planned to be only from 9-12 march"
                    },
                    {
                        "username": "Movsar",
                        "content": "Inorder traversal will solve this question for you :) \n**height-balanced binary search tree** - left side of tree will be **until mid of LL** and right side **after mid of LL**. Find mid point of LL first"
                    },
                    {
                        "username": "amaan7",
                        "content": "[@batsy01](/batsy01) I think the only efficient approach is by using the fast and slow pointers to find the mid of LL which take constant space so TC: O(N) SC: O(1)"
                    },
                    {
                        "username": "batsy01",
                        "content": "how can we find mid of ll in O(1) as we can find in array?\nIf it was an array -> then tc will be o(N) and space is OlogN"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach To Solve this Problem :-\\n\\n1.Find the middle element of the linked list. This can be done by using two pointers, one that moves one step at a time and another that moves two steps at a time. When the faster pointer reaches the end of the list, the slower pointer will be pointing to the middle element.\\n\\n2.Create a new node with the value of the middle element, and make it the root of the binary search tree.\\n\\n3.Recursively convert the left half of the linked list to the left subtree of the root, and the right half of the linked list to the right subtree of the root.\\n\\n4.To convert the left half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the left of the middle element.\\n\\n5.To convert the right half of the linked list, recursively repeat steps 1-3 on the sublist of elements to the right of the middle element.\\n\\n6.Return the root of the binary search tree."
                    },
                    {
                        "username": "santhos-13",
                        "content": "whats the time complexity ?\\n"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Nice"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference :-\\n\\nhttps://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282466/o-nlogn-solution/"
                    },
                    {
                        "username": "iaming",
                        "content": "I used an extra array to do this, it has O(n) storage and time. \\nBut I have a feeling that this one can be solved with O(1) memory, of course, linear time."
                    },
                    {
                        "username": "amaan7",
                        "content": "yes you can use the property of BST that in order traversal of BST is an increasing sorted number "
                    },
                    {
                        "username": "Diamantis",
                        "content": "You can use an inorder traversal:\\n1. Recursively call the function for left side.\\n2. Create your current TreeNode and move the global node variable to the next position.\\n3. Recursively call the function for the right side."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "If you convert the linked-list in array or vector it is pretty much Easy question, but it is expected to be solved using linked-list. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Yes, LinkedList is the key of this question."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "According to this post, there is an O(n) way to do this problem:\\nhttp://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/\\n\\nWould they expect us to come up with this, or is O(nlogn) good enough? Has anyone had experience with this? I heard that this question was recently asked in facebook phone interview, which is why I am asking."
                    },
                    {
                        "username": "Rigby29",
                        "content": "I am a bit confused. Do not know why my approach is incorrect.\n\n1. Convert list to an array\n2. Find mid and build left subtree from an array[0:mid) and build right subtree from an array(mid: len(array) -1]\n3. We will get a tree shaped like a big V bottom up (each node besides root has only one child)\n\nCan someone please point me why this tree is not height balanced BST?\n\nUPD. \ninput: [0,1,2,3,4,5]\noutput: [2,1,3,0,null,null,4,null,null,null,5]\nexpected: [3,1,5,0,2,4]"
                    },
                    {
                        "username": "sahilsoodplp",
                        "content": "Do not convert to an array just find mid of LL and Make a new node out of it TO BE USED AS ROOT OF BST"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Per the definition a \"height-balanced\" BST is a binary search tree in which the depth of the two subtrees of **every node** never differs by more than one. So a 'V'-shaped tree would fail because the children of the root node are unbalanced.\n\nThe answer is quite easily achieved if you use the algorithm you provided (w/o step 3) and repeat it recursively."
                    },
                    {
                        "username": "victorlau_",
                        "content": "I think the question should be modified to height balanced complete BST instead, and the expected answer will make sense.\\nOtherwise I think your answer should also be accepted as well."
                    },
                    {
                        "username": "dongliang14",
                        "content": "If the length is even, take the right one of the middle two as head"
                    },
                    {
                        "username": "Pinzauti",
                        "content": "Yep I have the exact same problem, should be correct in theory"
                    }
                ]
            },
            {
                "id": 1828869,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1828650,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1828617,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1572339,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1571229,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1571230,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 2005692,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1956587,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1933728,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1839218,
                "content": [
                    {
                        "username": "06atul1998",
                        "content": "I just implemented AVL tree, then I just looped over the linked list and inserted each value in tree and returned the tree.\\n\\nIn Time: Beats 5.3%\\nIn memory: Beats 99.76%"
                    },
                    {
                        "username": "06atul1998",
                        "content": "[@joseville](/joseville) TC: Time complexity, SC: Space complexity"
                    },
                    {
                        "username": "joseville",
                        "content": "[@Swapnil07072000](/Swapnil07072000) What\\'s TC? What\\'s SC?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "FIrst I thought of AVL but its TC given was not good, but good for SC"
                    },
                    {
                        "username": "dumb_me",
                        "content": "I took the easy way in this \\uD83E\\uDD79\\n"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Are they asking is about AVL?"
                    },
                    {
                        "username": "Kinsapoon",
                        "content": "Correct me if I am wrong, each node will be visited at the height of the tree times. Shouldn\\'t the time complexity be h * n = nlogn for a balanced tree?"
                    },
                    {
                        "username": "zhiqing_xiao",
                        "content": "It seems that the recursive calling needs O(log n) space, which is ineluctable, isn't it?\\n\\n=======================\\n\\n(update) Converting the recursive version to non-recursive version does not reduce space since it still need a stack to store the status.\\n\\n(update) The recursive calling seems to be a top-bottom approach, but the bottom-top approaches do not help, either.\\n\\n(update) Is there a constant-space solution?\\n\\n(update) On Morris inorder tree traversal (@stellari): I googled the Morris traversal, and it is an inorder tree traversal without using stacks or recursion. That's really cool. Using the Morris traversal, we can convert a binary search tree to a sorted linked list with constant space. Detail explanations of the Morris traversal can be found here:\\nhttp://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/\\n\\n(update) Maybe the algorithm could be (pending):\\n\\n1. calculate the length of the sorted list, say N;\\n\\n2. construct a threaded balance tree of N nodes (without values in the nodes);\\n\\n3. inorder traversal the tree, put the values in the list into the nodes;\\n\\n4. delete the threads (it may take a bit more time).\\n\\n\\n=======================\\n\\n@Shangrila   Thank you for your kind answer.\\n\\n@stellari        Thank you very much for the Morris traversal. It is very cool."
                    },
                    {
                        "username": "nicixiu",
                        "content": "If build this tree using binary search, then the root node would be having a left node of 1 and a right node of 1. Is this a valid bst or we do not take care of duplicates here?"
                    },
                    {
                        "username": "mankisnoob",
                        "content": "I got confused with this problem as it stated heighted Binary search tree instead of balanced binary search tree \\nare they both different? although the logic for that is applicable to both problems"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "My code is giving me an output tree in which there is a difference of 1 unit in the heights of the right subtree and the left subtree. Last I heard, a binary tree is height balanced if the difference between its left and right subtrees is >= 1. But, the OJ is showing me that my answer is wrong.\\nSo, is my answer really wrong or is it just not the same as OJ?\\n\\npublic TreeNode sortedListToBST(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (head.next == null) {\\n            return new TreeNode(head.val);\\n        }\\n        ListNode mid = middleNode(head);\\n        TreeNode root = new TreeNode(mid.val);\\n        ListNode travBeg = null, nxt = head, tmp = nxt.next;\\n        ListNode travMid = mid, next = travMid.next, temp = null;\\n        TreeNode left = root, right = root;\\n        if (next != null) {\\n            temp = next.next;\\n        }\\n        while (nxt != next) { // reversing first half of list\\n            nxt.next = travBeg;\\n            travBeg = nxt;\\n            nxt = tmp;\\n            if (tmp != null) {\\n                tmp = tmp.next;\\n            }\\n        }\\n        while (next != null) { // reversing second half of list\\n            next.next = travMid;\\n            travMid = next;\\n            next = temp;\\n            if (temp != null) {\\n                temp = temp.next;\\n            }\\n        }\\n        if (travBeg != null) {\\n            travBeg = travBeg.next;\\n        }\\n        while (travBeg != null) { // creating left subtree\\n            left.left = new TreeNode(travBeg.val);\\n            left = left.left;\\n            travBeg = travBeg.next;\\n        }\\n        if (travMid != mid) {\\n            right.right = new TreeNode(travMid.val);\\n            right = right.right;\\n        }\\n        travMid = travMid.next;\\n        while (travMid != mid && travMid != null) { // creating right subtree\\n            right.left = new TreeNode(travMid.val);\\n            travMid = travMid.next;\\n            right = right.left;\\n        }\\n        return root;\\n    }\\n\\n    public ListNode middleNode(ListNode head) {\\n        ListNode s = head;\\n        ListNode f = head.next;\\n        if (f == null) {\\n            return head; \\n        }\\n        while (f.next != null && f.next.next != null) {\\n            f = f.next.next;\\n            s = s.next;\\n        }\\n        return s.next;\\n    }"
                    },
                    {
                        "username": "indrazit",
                        "content": "Please hover your mouse over \"height-balanced\" in the problem description.  It will show the following definition: \"A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\"  Every subtree should also be height-balanced, too."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "A bit confused by what about my answer is wrong - if anyone can help I'd appreciate it;\nHead = [0, 1, 2, 3, 4, 5]\nOutput = [3, 2, 4, 1, null, null, 5, 0]\n\nExpected = [3, 1, 5, 0, 2, 4]\n\nIsn't my output a height balanced binary tree? Or am I missing something?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@indrazit](/indrazit) I think I understand now. Thank you!"
                    },
                    {
                        "username": "indrazit",
                        "content": "Each subtree should be height-balanced.  In your output, the subtree of node 2 has height-2 left subtree and height-0 right subtree."
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Great problem to solve!"
                    }
                ]
            },
            {
                "id": 1833046,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1831818,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829650,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829447,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829427,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829403,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829400,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829314,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829216,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829092,
                "content": [
                    {
                        "username": "thawesu",
                        "content": "case 7  [0,1,2,3,4,5,6]\\nIs this also a valid simple BST with 3 as root node then 012 r on the left and 456 r on the right?\\n[3,2,4,1,null,null,5,0,null,null,6]"
                    },
                    {
                        "username": "Unpredictable007",
                        "content": "\"A binary tree is balanced if for **every interior node**, the height of its two children differ by at most 1.\""
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "How to resolve null not matching the output in python. I know my tree is correct but the representation is wrong interpreted by leetcode checker.\\n\\nOutput\\n[0,-3,9,-10,None,5,None]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\n-------- OR -------------\\n\\nOutput\\n[0,-3,9,-10,0,5,0]\\n\\nExpected\\n[0,-3,9,-10,null,5]\\n\\nThe definition of TreeNode initializes left and right as None and val = 0\\nclass TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n\\nAny Help is appreciated thanks!\\n"
                    },
                    {
                        "username": "milan-lakhani",
                        "content": "[@klaca](/klaca) Thanks for replying! But I am returning the head of the tree TreeNode Object. And that output is in fact generated by leetcode compiler. I think I will check solutions for this now how others have accomplished it in python3. "
                    },
                    {
                        "username": "klaca",
                        "content": "Are you returning a list? You're just supposed to return the root. The checker will walk through the tree. Yeah it was confusing for me, too. I still don't understand why it is like that, I just accepted it as being weird."
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "Hint: Binary search on the list to find the mid element in the list.\\n\\n1) The center element of the list is the root of the tree.\\n2) Center element of the left half of the list is the left child of the root, and the center element of the right half of the list is the right child of the root.\\n3) Recurse 1 and 2.\\n\\nStoring the linked list in an array will help."
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: It\\'s already sorted. Copying it to an arraylist [O(n) memory] works fine, probably not the \"ideal\" solution though"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello AVL tree!!"
                    },
                    {
                        "username": "_ajaykumar_01",
                        "content": "As I think from my point of view, they first find the middle element of the sorted lists and after that they find the end as according to that and after that they start comparing the elements and storing them as according to that to its respective place \\n-- like wise \"0\" is the centre of the lists and they place it in the middle of  the list\\n-- after that you can start from the right or left end, I will go for the left end then I make places as according to it and after that starting putting the element in it \\n-- same as for the right hand side \\n-- this can be better use using the AVL tree method."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 5 minutes, just try, worth every second https://youtu.be/03KzrNZhWRI"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Out of topic,\\nI did the O(n) solution using binary search on an array with recursion.\\nTo create the array i used a function and loop, it returned an array. This solution beat 35%\\nNow i created the same array using for loop inside of main function. This solution beat 95%\\nI understand some difference can be observed but isnt this too drastic?"
                    },
                    {
                        "username": "cskrisz",
                        "content": "There is some randomness to it as well, which has more impact the shorter the run time."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Find the mid, break the list into two parts, make a node out of the middle one. Repeat."
                    }
                ]
            },
            {
                "id": 1829068,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828842,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828802,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828655,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828628,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828623,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828606,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1828586,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1826481,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            },
            {
                "id": 1688043,
                "content": [
                    {
                        "username": "dankCoder007",
                        "content": "Linked Tree indeed"
                    },
                    {
                        "username": "shubh263",
                        "content": "For Input : [-11,-10,-3,0,5,9]\\nwhy Output : [-3, -10, 0, -11, null, 5, 9] is not valid "
                    },
                    {
                        "username": "klaca",
                        "content": "because 5 > 0"
                    },
                    {
                        "username": "pyxl",
                        "content": "Can someone explain to me why [0, -3, 5, -10, null, 9] wouldn't be a correct answer for [-10,-3,0,5,9]?"
                    },
                    {
                        "username": "klaca",
                        "content": "because 9 is a left node of 5 and larger than 5"
                    },
                    {
                        "username": "iammateus",
                        "content": "For some reason my TS solution breaks with the head = [0,1,2,3,4,5,6]\n\nMy logic seem to produce the tree data structure just fine, but the output seem wrong, I printed the tree and still no clue. The produced tree seem just fine.\n\n```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n function getLen(head) {\n    let len = 0;\n    let node = head;\n    while(node) {\n        len++;\n        node = node.next;\n    }\n    return len;\n }\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    const len = getLen(head);\n    const headIndex = Math.floor(len / 2);\n\n    let result = null;\n\n    let i = 0;\n    let node = head;\n    let lastTreeNode = null;\n    \n    while(node) {\n        console.log(lastTreeNode ? lastTreeNode.val : null, node.val)\n        const newTreeNode = new TreeNode(node.val);\n        if (i === headIndex) result = newTreeNode;\n        \n        if(len % 2 === 0 && i === 2 && len > 4) {\n            lastTreeNode.right = newTreeNode;\n            console.log(\"pegou\")\n        } else {\n            if(lastTreeNode) {\n                if(i <= headIndex) {\n                    newTreeNode.left = lastTreeNode;\n                    console.log(newTreeNode.val, \"tera o filho\", lastTreeNode ? lastTreeNode.val : null)\n                } else {\n                    lastTreeNode.right = newTreeNode;\n                    console.log(lastTreeNode.val, \"tera o filho\", newTreeNode.val)\n                }\n            }\n\n            lastTreeNode = newTreeNode\n        }\n        \n        node = node.next;\n        i++;\n    }\n\n    console.log(JSON.stringify(result))\n    return result;\n};\n\n{\"val\":3,\"left\":{\"val\":2,\"left\":{\"val\":1,\"left\":{\"val\":0,\"left\":null,\"right\":null},\"right\":null},\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":{\"val\":5,\"left\":null,\"right\":{\"val\":6,\"left\":null,\"right\":null}}}}\n```"
                    },
                    {
                        "username": "iammateus",
                        "content": "it seems that the valid tree is not accepted\n\nconst tree = new TreeNode(3);\n    tree.left = new TreeNode(2);\n    tree.left.left = new TreeNode(1);\n    tree.left.left.left = new TreeNode(0);\n    tree.right = new TreeNode(4);\n    tree.right.right = new TreeNode(5);\n    tree.right.right.right = new TreeNode(6);\n\n\n           3\n         /   \\\n        2     4\n       /       \\\n      1         5\n     /           \\\n    0             6"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "try it yourself\\nFollow the steps mentioned below to implement the approach:\\n\\n1. Set The middle element of the array as root.\\n2. Recursively do the same for the left half and right half.\\n3. Get the middle of the left half and make it the left child of the root created in step 1.\\n4. Get the middle of the right half and make it the right child of the root created in step 1.\\n5. Print the preorder of the tree."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "whole week playing with Linked list"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "meow_power",
                        "content": "I think I have to work on my Linked List part \\uD83D\\uDE14"
                    },
                    {
                        "username": "alu416",
                        "content": "title should be renamed to \"linked list\""
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": " `your inline code...your inline code...`\\nplease help me what is wrong in this code.\\nclass Solution {\\npublic:\\n\\nTreeNode* create(vector<int>&v, int start ,int end)\\n{\\n    if(start==end)\\n    {\\n        TreeNode* temp = new TreeNode(v[start]);\\n        return temp; \\n    }\\n    int mid =start+ (end-start)/2;\\n    TreeNode* temp = new TreeNode(v[mid]);\\n    temp->left = create(v,start,mid-1);\\n    temp->right = create(v,mid+1,end);\\n    return temp; \\n}\\n\\n    TreeNode* sortedListToBST(ListNode* head) {\\n        if (!head) return NULL;\\n        vector<int>v;\\n        while(head)\\n        {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        TreeNode* ans = create(v,0,v.size()-1);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Hakuuu",
                        "content": "1) TreeNode* create(vector&v, int start ,int end)\\n   TreeNode* create(vector<int>&v, int start ,int end)\\n2)break condition in recursion should be \\nif(start>end)\\n{\\nreturn NULL;\\n}\\nbecause (start==end) will be ture for 3 size array rest this condition will be never satisfied  and thus infinite recursion \\n\\n"
                    }
                ]
            }
        ]
    }
]