[
    {
        "title": "Beautiful Array",
        "question_content": "An array nums of length n is beautiful if:\n\n\tnums is a permutation of the integers in the range [1, n].\n\tFor every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j].\n\nGiven the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.\n&nbsp;\nExample 1:\nInput: n = 4\nOutput: [2,1,4,3]\nExample 2:\nInput: n = 5\nOutput: [3,1,2,5,4]\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000",
        "solutions": [
            {
                "id": 186679,
                "title": "odd-even-pattern-o-n",
                "content": "# **Intuition**:\\nTry to divide and conquer,\\nso we have left part, right part.\\n\\nOne way is to divide into [1, N / 2] and [N / 2 + 1, N].\\nBut it will cause problems when we merge them.\\n\\nAnother way is to divide into odds part and evens part.\\nSo there is no `k` with `A[k] * 2 = odd + even`\\n\\nI brute force all permutations when N = 5:\\n20 beautiful array found,\\nonly 4 don\\'t fit odd + even pattern:\\n`[2, 1, 4, 5, 3]`\\n`[3, 1, 2, 5, 4]`\\n`[3, 5, 4, 1, 2]`\\n`[4, 5, 2, 1, 3]`\\n</br>\\n\\n# **Beautiful Array Properties**\\n\\nSaying that an array is beautiful,\\nthere is no `i < k < j`,\\nsuch that `A[k] * 2 = A[i] + A[j]`\\n\\nApply these 3 following changes a beautiful array,\\nwe can get a new beautiful array\\n</br>\\n\\n**1. Deletion**\\nEasy to prove.\\n\\n**2. Addition**\\nIf we have `A[k] * 2 != A[i] + A[j]`,\\n`(A[k] + x) * 2 = A[k] * 2 + 2x != A[i] + A[j] + 2x = (A[i] + x) + (A[j] + x)`\\n\\nE.g: `[1,3,2] + 1  = [2,4,3]`.\\n\\n\\n**3. Multiplication**\\nIf we have `A[k] * 2 != A[i] + A[j]`,\\nfor any `x != 0`,\\n`(A[k] * x) * 2 = A[k] * 2 * x != (A[i] + A[j]) * x = (A[i] * x) + (A[j] * x)`\\n\\nE.g: `[1,3,2] * 2  = [2,6,4]`\\n</br>\\n\\n# **Explanation**\\nWith the observations above, we can easily construct any beautiful array.\\nAssume we have a beautiful array `A` with length `N`\\n\\n`A1 = A * 2 - 1` is beautiful with only odds from `1` to `N * 2 -1`\\n`A2 = A * 2` is beautiful with only even from `2` to `N * 2`\\n`B = A1 + A2` beautiful array with length `N * 2`\\n\\nE.g:\\n```\\nA = [2, 1, 4, 5, 3]\\nA1 = [3, 1, 7, 9, 5]\\nA2 = [4, 2, 8, 10, 6]\\nB = A1 + A2 = [3, 1, 7, 9, 5, 4, 2, 8, 10, 6]\\n```\\n</br>\\n\\n# **Time Complexity**:\\nI have iteration version here `O(N)`\\nNaive recursion is `O(NlogN)`\\nRecursion with one call or with cache is `O(N)`\\n</br>\\n# **Solution**:\\n**C++:**\\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        while (res.size() < N) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.add(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.add(i * 2);\\n            res = tmp;\\n        }\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n```\\n\\n**Python:**\\n```\\n    def beautifulArray(self, N):\\n        res = [1]\\n        while len(res) < N:\\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\\n        return [i for i in res if i <= N]\\n```\\n</br>\\n\\n## **Advanced**:\\nSome other ideas: https://leetcode.com/problems/beautiful-array/discuss/186680\\nAuthor: lee215\\n",
                "solutionTags": [],
                "code": "```\\nA = [2, 1, 4, 5, 3]\\nA1 = [3, 1, 7, 9, 5]\\nA2 = [4, 2, 8, 10, 6]\\nB = A1 + A2 = [3, 1, 7, 9, 5, 4, 2, 8, 10, 6]\\n```\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        while (res.size() < N) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.add(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.add(i * 2);\\n            res = tmp;\\n        }\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n```\n```\\n    def beautifulArray(self, N):\\n        res = [1]\\n        while len(res) < N:\\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\\n        return [i for i in res if i <= N]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187669,
                "title": "share-my-o-nlogn-c-solution-with-proof-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nFor some fixed ```N```, an array ```A``` is *beautiful* if it is a permutation of the integers ```1, 2, ..., N```, such that:\\n\\nFor every ```i < j```, there is **no** ```k``` with ```i < k < j``` such that ```A[k] * 2 = A[i] + A[j]```.\\n\\nGiven ```N```, return **any** beautiful array ```A```.  (It is guaranteed that one exists.)\\n\\n**Example 1:**\\n```\\nInput: 4\\nOutput: [2,1,4,3]\\n```\\n**Example 2:**\\n```\\nInput: 5\\nOutput: [3,1,2,5,4]\\n```\\nNote:\\n\\n* ```1 <= N <= 1000```\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Analysis\\n\\n---\\nThe problem is to make a permutation of integers 1 to N in an array A. For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].\\n\\n**A[k]** here is the **average number of A[i] and A[j]**, which means the rule here can be expressed as\\n\\n>#### There is **no average number of A[i] and A[j] between A[i] and A[j]** (i < j).\\n\\nAt first glance, the rule is a little bit complicated, but we can find an **interesting fact**.\\n\\nThe **fact** is\\n\\n>#### **The average number of an odd number and an even one is not an integer.**\\n\\n---\\n#### 2.2 First level partition\\n\\n---\\n\\nIn order to explain the problem easily, here we take **N = 10** as an example.\\n\\nThe numbers to be processed are\\n\\n**Universal set:**\\n>#### **S = [1,2,3,4,5,6,7,8,9,10]**.\\n\\nNow it is divided into 2 subsets **S1** and **S2**:\\n\\n**Subset 1 (odd):**\\n>#### **S1 = [1,3,5,7,9]**.\\n\\nIn **S1**, \\n>#### the **0-th binary digit(LSB) of all elements** are **same (equals 1)**.\\nwhich means for **all A[i] \\u2208 S1**\\n>#### **A[i] & 1 \\u2260 0**.\\n\\n**Subset 2 (even):**\\n>#### **S2 = [2,4,6,8,10]**.\\n\\nIn **S2**, \\n>#### the **0-th binary digit(LSB) of all elements** are **same (equals 0)**.\\nwhich means for **all A[i] \\u2208 S2**\\n>#### **A[i] & 1 = 0**.\\n\\nNow think about the average of **all A[i]-A[j] pairs** (i < j) in the **universal set**, there are **3 situations**:\\n1. **one** from **S1**, **the other** also from **S1**. **The average** may be\\n    * in **S1** (for example: 1 and 5, the average is 3).\\n    * in **S2** (for example: 1 and 3, the average is 2).\\n2. **one** from **S2**, **the other** also from **S2**. **The average** may be\\n    * in **S1** (for example: 2 and 4, the average is 3).\\n    * in **S2** (for example: 2 and 6, the average is 4).\\n3. **one** from **S1**, **the other** from **S2**. **The average** is **NOT** in **both S1 and S2**.\\n\\nIf we put all numbers of **S1** **before** all numbers of **S2**, we will get a permutation\\n>#### [**1**,**3**,**5**,**7**,**9**,*2*,*4*,*6*,*8*,*10*].\\n\\nIn this case, there are no need for us to worry about situation 3.\\n>#### **S1** and **S2** may be processed **separately**.\\n\\nBut how?\\n\\n---\\n#### 2.3 Second level partition\\n\\n---\\nIn section 2.2, although the position of a certain element in S hasn\\'t been determined yet, the relative position of all S1 elements and S2 elements has been determined.\\n\\nThe **Exclusion Rule** is\\n>#### After **dividing the universal set S into 2 subsets S1 and S2**, it should be **guaranteed** that\\n>#### For **any A[i] \\u2208 S1, A[j] \\u2208 S2**, **the average of A[i] and A[j] will NOT appear in BOTH S1 and S2.**\\n\\nIf the **universal set** is **S1 in section 2.2**, can it be divided into **2 new Subsets** following the **Exclusion Rule**?\\n\\nSince **S1 is an odd set**, all its elements p can be expressed as\\n>#### **p = 2k + 1**.\\n\\nChoosing 2 elements **m, n \\u2208 S1**, if\\n\\n>#### **m = 2x + 1, n = 2y + 1**.\\n\\nthe average will be\\n\\n>#### **(m + n)/2 = x + y + 1**.\\n\\nAs the rule says, if S1 can be divided into 2 subsets, the average\\n\\n>#### **x + y + 1** is **not in S1**.\\n\\nwhich means\\n\\n>#### **x + y + 1** is **even**, **x + y** is **odd**.\\n>#### **x** and **y** have **different parity**.\\n\\nNow S1 can be divided into 2 subsets according to k = (A[i] - 1) / 2.\\n**Subset 1.1 (odd k):**\\n>#### **S11 = [3,7]**.\\n\\nIn **S11**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 11)**.\\nwhich means for **all A[i] \\u2208 S11**\\n>#### **A[i] & 2 \\u2260 0**.\\n\\n**Subset 1.2 (even k):**\\n>#### **S12 = [1,5,9]**.\\n\\nIn **S12**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 01)**.\\nwhich means for **all A[i] \\u2208 S12**\\n>#### **A[i] & 2 = 0**.\\n\\n---\\n\\nNow we focus on S2.\\n\\nIf the **universal set** is **S2 in section 2.2**, can it be divided into **2 new Subsets** following the **Exclusion Rule**?\\n\\nSince **S2 is an even set**, all its elements p can be expressed as\\n>#### **p = 2k**.\\n\\nChoosing 2 elements **m, n \\u2208 S2**, if\\n\\n>#### **m = 2x, n = 2y**.\\n\\nthe average will be\\n\\n>#### **(m + n)/2 = x + y**.\\n\\nAs the rule says, if S2 can be divided into 2 subsets, the average\\n\\n>#### **x + y** is **not in S2**.\\n\\nwhich means\\n\\n>#### **x + y** is **odd**.\\n>#### **x** and **y** have **different parity**.\\n\\nNow S2 can be divided into 2 subsets according to k = A[i] / 2.\\n**Subset 2.1 (odd k):**\\n>#### **S21 = [2,6,10]**.\\n\\nIn **S21**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 10)**.\\nwhich means for **all A[i] \\u2208 S21**\\n>#### **A[i] & 2 \\u2260 0**.\\n\\n**Subset 2.2 (even k):**\\n>#### **S22 = [4,8]**.\\n\\nIn **S22**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 00)**.\\nwhich means for **all A[i] \\u2208 S22**\\n>#### **A[i] & 2 = 0**.\\n\\nAfter first and second level partition, the permutation becomes\\n>#### [**3**,**7**,*1*,*5*,*9*,***2***,***6***,***10***,4,8].\\n\\n---\\n#### 2.4 Two guesses\\n\\n---\\nIf A[i]\\'s binary representation is\\n\\n>#### **A[i] = M(r)M(r-1)M(r-2)...M(0), M(i) = 0 or 1, 0 \\u2264 i \\u2264 r, r > 0**.\\n\\nThe **first level partition** focuses on **A[i] & 1 - in other words, the 1st LSB M(0)**.\\n\\n* If M(0) = 1, A[i] \\u2208 S1. If M(0) = 0, A[i] \\u2208 S2.\\n\\nThe **second level partition** focuses on **A[i] & 2 - in other words, the 2nd LSB M(1)**.\\n\\n* If M(0) = 1,\\n  * If M(1) = 1, A[i] \\u2208 S11.\\n  * If M(1) = 0, A[i] \\u2208 S12.\\n* If M(0) = 0,\\n  * If M(1) = 1, A[i] \\u2208 S21.\\n  * If M(1) = 0, A[i] \\u2208 S22.\\n\\n**......**\\n\\nwe can infer that the **Partition Rule** is\\n>#### The k-th (k > 0) level partition is based on A[i] & 2^(k - 1) - in other words, the k-th LSB M(k-1) is 1 or 0.\\n\\nAs shown in section 2.2 and 2.3,\\n\\nAfter **first level partition**,\\n\\n>#### The **0-th binary digit (1 least significant bit, LSB)** of all elements in S1 (or S2) are **same**. \\n\\nAfter **second level partition**,\\n\\n>#### The **1-st, 0-th binary digits (2 LSBs)** of all elements in S11 (or S12, S21, S22) are same.\\n\\n**......**\\n\\nwe guess\\n\\n**Guess A:**\\nIf we follow the **Partition Rule**,\\n\\n>#### **after k-th (k > 0) level partition, the k LSBs of all elements in each generated subsets are same.**\\n\\n**Guess B:**\\nIf we follow the **Partition Rule**,\\n\\n>#### **the generated subsets will ALWAYS satisfy the Exclusion Rule in section 2.3.**\\n\\n---\\n#### 2.5 Proof\\n\\n---\\nIn order to prove Guess A and B, the mathematical Induction is applied.\\n\\n**Guess A:**\\n\\nif we follow the **Partition Rule**\\n\\n**Base case:**\\n\\nWhen k = 1, as shown in section 2.2,\\n\\nafter first level partition, the LSB of all elements in each generated subsets (S1 or S2) are same.\\n\\n**Step case:**\\n\\nAfter k-th level partition, the k LSBs of all elements in each generated subsets are same.\\n\\nChoosing any subset U generated after k-th level partition,\\n\\nsupposing the k+1 LSBs of one element x \\u2208 U is M(k)M(k-1)...M(0).\\n\\nwhen doing the k+1-th partition, the binary digit M(k) will be checked,\\n\\n* If M(k) = 1, x \\u2208 U1.\\n* If M(k) = 0, x \\u2208 U2.\\n\\nBefore k+1-th partition, all elements in U have same M(k-1)...M(0).\\n\\nAfter k+1-th partition, all elements with same M(k) are put into one subset, which means\\n\\n>#### **all elements in U1 (or U2) have same M(k)M(k-1)... M(0) (k + 1 LSBs). Proved.**\\n\\n---\\n**Guess B:**\\n\\nFor any elements A[i] \\u2208 S1, A[j] \\u2208 S2, if we follow the **Partition Rule**,\\n\\n**Base case:**\\n\\nWhen k = 1, as shown in section 2.2,\\n\\nif we follows the **Partition Rule**, the average of any A[i]-A[j] pair is not an integer. (not in both S1 and S2).\\n\\n**Step case:**\\n\\nAs proved Guess A, after k-th level partition, the k LSBs of all elements in each generated subsets are same.\\n\\nChoosing any subset U generated after k-th level partition,\\n\\nsupposing the k+1 LSBs of one element x \\u2208 U is M(k)M(k-1)...M(0).\\n\\nwhen doing the k+1-th partition, the binary digit M(k) will be checked,\\n\\n- If M(k) = 1, x \\u2208 U1.\\n- If M(k) = 0, x \\u2208 U2.\\n\\nChoosing any A[i] \\u2208 U1, A[j] \\u2208 U2\\n\\nif P is odd, Q is even (P,Q \\u2265 0), and\\n\\n>#### **res = M(k-1)...M(0).**\\n\\nA[i] and A[j] can be represented as\\n\\n>#### **A[i] = P \\xD7 2^k + res.**\\n\\n>#### **A[j] = Q \\xD7 2^k + res.**\\n\\nThe average\\n\\n>#### **(A[i] + A[j])/2 = (P + Q) \\xD7 2^(k - 1) + res.**\\n\\nSince P is odd, Q is even, P + Q is odd, which means\\n\\n>#### **1 will be added to M(k-1) - the most significant bit (MSB) of res.**\\n\\nwhich means\\n\\n>#### **The k LSBs of the average is different from those of both A[i] and A[j].**\\n\\nThat is to say,\\n\\n>#### **The average is not in both U1 and U2. Proved.**\\n\\n---\\n## 3. Algorithm\\n\\n---\\n\\nAs been discussed above, this is a divide and conquer problem, which is suitable for recursion.\\n\\n**Stop situation:**\\n\\nWhen the generated subset\\'s size is small enough (contains **0** or **1** element), the recursion should stop.\\n\\n**Recursion logic:**\\n\\nAs the problem can be treated as a special sorting problem, \\n\\nthe whole logic can be divided into patition part and sorting part .\\n\\nWhen sorting, there are 4 inputs,\\n\\n* vector **v**.\\n* start index **start**.\\n* end index **end**.\\n* **mask** for judging elements and put them into subsets.\\n\\nAfter the inputs are introduced to partition part,\\n\\nthe elements in **v** from **start** to **end** are swapped like doing quicksort, the border index **mid** is returned.\\n\\nAfter doing partition\\n\\n* all elements from index **start** to index **mid - 1** belongs to Subset **1**.\\n\\n* all elements from index **mid** to index **end** belongs to Subset **2**.\\n\\nWhen the partition finished, we can sort on **start** to **mid - 1** and **mid** to **end** recursively, \\n\\nAccoring to the **Partition Rule**, the **mask** should be **doubled**.\\n\\n**Initial values:**\\n\\n* v = [1,2,3,4,...,N].\\n* start = 0.\\n* end = N-1.\\n* mask = 1.\\n\\n---\\n## 4. Complexity Analysis\\n\\n---\\n\\n#### 4.1 Time complexity\\n\\n---\\nOn each level, the recursion branch will iterate over all elements.\\n\\nOn k-th level, the k-th LSB will be checked. \\n\\nThe number of iteration will be **AT MOST log2N**.\\n\\n>#### The time complexity is **O(NlogN)**.\\n\\n---\\n\\n#### 4.2 Space complexity\\n\\n---\\n\\nThe algorithm is an **in-place implementation**. \\nAs it\\'s a recursion algorithm, and the depth of the recursion tree is AT MOST log2N.\\n\\n>#### The space complexity is **O(N)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int partition(vector<int> &v, int start, int end, int mask)\\n    {\\n        int j = start;\\n        for(int i = start; i <= end; i++)\\n        {\\n            if((v[i] & mask) != 0)\\n            {\\n                swap(v[i], v[j]);\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    void sort(vector<int> & v, int start, int end, int mask)\\n    {\\n        if(start >= end) return;\\n        int mid = partition(v, start, end, mask);\\n        sort(v, start, mid - 1, mask << 1);\\n        sort(v, mid, end, mask << 1);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans;\\n        for(int i = 0; i < N; i++) ans.push_back(i + 1);\\n        sort(ans, 0, N - 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```N```\n```A```\n```1, 2, ..., N```\n```i < j```\n```k```\n```i < k < j```\n```A[k] * 2 = A[i] + A[j]```\n```N```\n```A```\n```\\nInput: 4\\nOutput: [2,1,4,3]\\n```\n```\\nInput: 5\\nOutput: [3,1,2,5,4]\\n```\n```1 <= N <= 1000```\n```\\nclass Solution {\\npublic:\\n    int partition(vector<int> &v, int start, int end, int mask)\\n    {\\n        int j = start;\\n        for(int i = start; i <= end; i++)\\n        {\\n            if((v[i] & mask) != 0)\\n            {\\n                swap(v[i], v[j]);\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    void sort(vector<int> & v, int start, int end, int mask)\\n    {\\n        if(start >= end) return;\\n        int mid = partition(v, start, end, mask);\\n        sort(v, start, mid - 1, mask << 1);\\n        sort(v, mid, end, mask << 1);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans;\\n        for(int i = 0; i < N; i++) ans.push_back(i + 1);\\n        sort(ans, 0, N - 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186680,
                "title": "python-three-1-line-solutions",
                "content": "Sort by reversed binary\\n```\\n    def beautifulArray(self, N):\\n        return sorted(range(1, N + 1), key=lambda x: bin(x)[:1:-1])\\n```\\n\\nNaive recursion\\n```\\n    def beautifulArray(self, N):\\n        return [i * 2 for i in self.beautifulArray(N / 2)] + [i * 2 - 1 for i in self.beautifulArray((N + 1) / 2)] if N > 1 else [1]\\n```\\n\\nBinary Reverse\\n```\\n    def beautifulArray(self, N):\\n        return [i for i in [int(\\'{:010b}\\'.format(i)[::-1], 2) for i in range(1, 1 << 10)] if i <= N]\\n```",
                "solutionTags": [],
                "code": "```\\n    def beautifulArray(self, N):\\n        return sorted(range(1, N + 1), key=lambda x: bin(x)[:1:-1])\\n```\n```\\n    def beautifulArray(self, N):\\n        return [i * 2 for i in self.beautifulArray(N / 2)] + [i * 2 - 1 for i in self.beautifulArray((N + 1) / 2)] if N > 1 else [1]\\n```\n```\\n    def beautifulArray(self, N):\\n        return [i for i in [int(\\'{:010b}\\'.format(i)[::-1], 2) for i in range(1, 1 << 10)] if i <= N]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 583910,
                "title": "easy-explanation-of-concept-concise-c",
                "content": "Credit : i_love_xiaoshagua_cpp for code.\\nUPVOTE will be highly appreciated!\\n\\nFirstly we must understand that :PROPERTY 1: given a series of beautiful-array if we\\n* multiply each element by 2 OR\\n* multiply each element by 2 and subtract one from it\\n\\nthe resulting series is also beautiful (just take them a,b,c and try out, the twos get cancelled in A[k] * 2 = A[i] + A[j].)\\n\\nPROPERTY 2 : Now second thing is combining two beautiful arrays:\\n RESULT  = {ARRAY ONE} {ARRAY TWO}\\n If array one & array two are beautiful then\\n if array one is made up of all odd nos. and array 2 is made up of all even nos.\\n And let a1 & a2 be elements from array1 and array2 respectively.\\n (a1+a2)/2 is fraction and is not present in resulting array thus by 3 reasons:\\n \\n*array1 is beautiful  \\n*array2 is beautiful  \\n*(a1+a2)/2 is fraction and is not present in resulting array\\n\\nresulting array is also beautiful.\\n\\nNow lastly to make a beautiful array of N.\\n* make beautiful array of all even nos. till N \\n* make beautiful array of all odd nos. till N \\nJOIN them up !\\n\\nTo make beautiful arrays of all even and odd smaller than N will use property 1.\\n\\nEx: For N = 5        beautiful( { 2 , 4 } ) +  beautiful( { 1 , 3 , 5} )\\n\\nTo get beautiful of { 2 , 4 } get beautiful of N = 2 and multiply by 2\\nTo get beautiful of { 1 , 3 , 5}  get beautiful of N = 3 and multiply by 2 and subtract by 1.\\nThen JOIN them !\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int> even = beautifulArray(n/2);\\n        vector<int> odd = beautifulArray(n-(n/2));\\n        vector<int>ans;\\n        for(auto e:even)\\n            ans.push_back(2*e);\\n        for(auto e:odd)\\n            ans.push_back((2*e)-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int> even = beautifulArray(n/2);\\n        vector<int> odd = beautifulArray(n-(n/2));\\n        vector<int>ans;\\n        for(auto e:even)\\n            ans.push_back(2*e);\\n        for(auto e:odd)\\n            ans.push_back((2*e)-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368125,
                "title": "detailed-explanation-with-diagrams-a-collection-of-ideas-from-multiple-posts-python3",
                "content": "## 0. Introduction\\nThis post is a collection of all the posts, comments and discussions of the LeetCode community. References mentioned at the bottom! I\\'ve attempted to explain things in detail, with diagrams to help understand the intuitions as well.\\n\\n## 1. Naive Solution\\nThe first thing anyone can think of is using `permutations(array)` to enumerate all the permutations in `O(N!)` time. This is bad in itself, but it gets worse. We still need to check the validity of the resultant array. We can do this in `O(N^3)` time, iterative over every possible combination of `i`, `j` and `k`.\\n\\nBelow is the code for it.\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def invalid(self, x):\\n        n = len(x)\\n        flag = False\\n        for i in range(n):\\n            if flag: break\\n            for j in range(i+2, n):\\n                if flag: break\\n                for k in range(i+1, j):\\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\\n        return flag\\n        \\n    def beautifulArray(self, n: int) -> List[int]:\\n        for perm in permutations(range(1, n+1)):\\n            if not self.invalid(perm):\\n                return perm\\n```\\n\\nThis is clearly a dead end. The time complexity is enormous and impractical. But, what to do?\\n\\n## 2. Thinking in Terms of Bits\\n**Whenever stuck, think in terms of bits.**\\n\\nIt always helps to think in terms of bits, so let\\'s do that. Reformulating the problem, `nums[i]+nums[j] = 2*nums[k]` is not allowed.\\n\\nIn terms of bits, we can start with thinking what would happen if `nums[i]` or `nums[j]` is odd or even.\\n\\n\\n| nums[i] | nums[j] |   nums[k]    |\\n| ------- | ------- |:------------:|\\n| even    | even    |   even/odd   |\\n| odd     | odd     |   even/odd   |\\n| even    | odd     | non-existent |\\n| odd     | even    | non-existent |\\n\\n**Clearly, it looks like we want to focus on the last two cases. Ensuring that will ensure the validity of the solution.**\\n\\n## 3. Finding Recursion\\nWe know splitting the array into odds and evens is beneficial. The trivial case is `[odd numbers here] [even numbers here]`, or the opposite `[even numbers here] [odd numbers here]`. Both will work. For convenience, I\\'ll take the first one.\\n\\nexample: `n = 7`\\n`1 2 3 4 5 6 7` -> `1 3 5 7 | 2 4 6`\\n\\nThis clearly won\\'t work since `1 3 5 7` and `2 4 6` are troublesome in themselves, but if `i` is pointing to `1 3 5 7` and `j` to `2 4 6`, we can stay safe.\\n\\nNow, what if ... we break the `1 3 5 7` into two again? How? Just do a right-shift operation. (this is one of those problems whose solutions make sense once you know them lmao)\\n\\nThis makes the problem: `0 1 2 3`. Doesn\\'t this look eerily similar to the orignial problem? We can break this down as `1 3 | 0 2`. This will work for `evens` as well (think why). **We have found a recursion!** \\n\\nThe below diagram should explain it better.\\n\\n![](https://i.imgur.com/sxoCWG0.png)\\n\\nNote that the right shifting is done for explaination reasons, the goal is to actually just consider alternate elements. \\n\\n## 4. Code for Recursive Solution\\n```\\nclass Solution:\\n    def recurse(self, nums):\\n        if len(nums) <= 2: return nums\\n        return self.recurse(nums[::2]) + self.recurse(nums[1::2])\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        return self.recurse([i for i in range(1, n+1)])\\n```\\n\\n## 5. One-liner Solution\\nThe final one-liner solution is based on a very interesting observation. Recall how we worked with the trees, where each following height involved right-shifting the binary representation by one. Alternatively, think like this: What happened in the grand scheme? We considered the 0th bit first, then the 1st, then the 2nd and so on.\\n\\n![](https://i.imgur.com/r2w55ie.png)\\n\\nIf you note, this is equivalent to a sorting problem! The only difference is that we are considering the number in reverse, in binary. This brings us to the godly one liner solution by lee215.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=lambda x: bin(x)[:1:-1])\\n```\\n\\n## 6. References\\n- https://leetcode.com/r0bertz/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/644612/Python3-solution-with-detailed-explanation-Beautiful-Array\\n- https://leetcode.com/lee215/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/186680/Python-Three-1-line-Solutions\\n- https://leetcode.com/lee215/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)\\n\\n\\nIf you want another look at the problem in a different format, here\\'s my video explanation.\\nhttps://www.youtube.com/watch?v=jHHdiMIJcr0.\\n\\nFeel free to ask any questions! Criticisms and comments are most welcome. If this helps you, upvote! It gives me motivation to be better :D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\nclass Solution:\\n    def invalid(self, x):\\n        n = len(x)\\n        flag = False\\n        for i in range(n):\\n            if flag: break\\n            for j in range(i+2, n):\\n                if flag: break\\n                for k in range(i+1, j):\\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\\n        return flag\\n        \\n    def beautifulArray(self, n: int) -> List[int]:\\n        for perm in permutations(range(1, n+1)):\\n            if not self.invalid(perm):\\n                return perm\\n```\n```\\nclass Solution:\\n    def recurse(self, nums):\\n        if len(nums) <= 2: return nums\\n        return self.recurse(nums[::2]) + self.recurse(nums[1::2])\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        return self.recurse([i for i in range(1, n+1)])\\n```\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=lambda x: bin(x)[:1:-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367891,
                "title": "python-o-n-solution-with-proof-explained",
                "content": "In this problem we have `n = 1000`, which is too big to use dfs/backtracking, so we need to find some pattern. We need to avoid structures like `i < k < j` with `nums[i] + nums[j] = 2 * nums[k]`, which means that `nums[i]` and `nums[j]` has the same parity: they are both odd or even. This lead us to the following idea: let us split all numbers into `2` groups: all **odd** numbers and then all **even** numbers.\\n\\n`[ odd numbers ] [ even numbers ]`\\n\\nThen if `i, j, k` lies in two different groups, we are OK, we will hever have forbidden pattern. Also, if we look at odd numbers, imagine `n = 12`, then we have `[1, 3, 5, 7, 9, 11]` and if we subtract `1` to each number and divide each number by `2` then we have  `[0, 1, 2, 3, 4, 5]`. Note, that is **linear** transform: when we did this transformation, if we did not have forbidden pattern, we still do not have it! So, what we need to do is to run function recursively for `odd` and `even` numbers and concatenate them.\\n\\n#### Complexity\\nFrom the first sight, time complexity is `O(n log n)`, because we have recursion `C(n) = C(n//2) + C((n+1)//2)`, which lead to `O(n log n)`. However it can be shown that it is `O(n)`. Imagine case `n = 105`, then we have `105 -> (52, 53) -> (26, 26, 27, 27) -> (13, 13, 13, 13, 14, 14, 14, 14)` and if we use memoisation, no need to solve problem each time for `13`, we can do it only once. On each level we will have at most **two** values in our recursion tree. Space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186901,
                "title": "javascript-how-i-understand-the-solution-with-verification-of-the-solution",
                "content": "### How I got the pattern by analysing the answer of input 100\\nI didn\\'t know how to solve this problem but I got the answer right by submitting and checking the right answer of input `100`. \\nYes I got lucky and got it right.\\nThe feedback answer was\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63,2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\nAnd after I analysed it, I find that it can be divided into two parts:\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\nAnd each part can be divided into two parts, and so on......\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61]\\n[3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62]\\n[4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\n```\\n......\\n```\\nAnd as you can see the pattern is pretty clear here. So I came up with the code below.\\n\\n### The Code\\n```\\nvar beautifulArray = function(N) {\\n    let arr=Array.from({length:N}, (x,i)=>i+1);\\n    return helper(arr);\\n\\n    function helper(arr){\\n    \\tif(arr.length===1) return arr;\\n    \\tlet o=[], e=[]; //odd index and even index\\n    \\tfor(let i=0; i<arr.length; i++){\\n    \\t\\tif(i%2===0) e.push(arr[i]);\\n    \\t\\telse o.push(arr[i]);\\n    \\t}\\n    \\treturn helper(e).concat(helper(o));\\n    }\\n};\\n```\\n\\n### The Why\\nWhy can this solution come up with a beautiful array? I tried to figure it out.\\nThe rule of a beautiful array is : `for every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].`\\nMeaning the **difference** between any `i` and `k` and `k` and `j` **can not be the same**.\\nSo how the above solution guarantees this?\\nFirst, by dividing the array into **odd** part and **even** part:\\n```\\n1,3,5,7,9..... | 2,4,6,8,10.....\\n```\\nIt guarantees that there is no such `j` for `i` and `k`:\\n```\\ni      k                j\\n-------------------------\\n1      2,4,6,8,10...\\n3      2,4,6,8,10...\\n5      2,4,6,8,10...\\n7      2,4,6,8,10...\\n9      2,4,6,8,10...\\n......\\n```\\nThen let\\'s see the first part (the second part will be similar):\\n```\\n1,3,5,7,9......\\n```\\nIt will be divided into two parts:\\n```\\n1,5,9,... | 3,7,11,...\\n```\\nAnd this time it guarantees that there is no such `j` for `i` and `k`:\\n```\\ni      k                j\\n--------------------------\\n1      3,7,11,...\\n5      3,7,11,...\\n9      3,7,11,...\\n......\\n```\\nAnd we continue this process until the length of the odd and even array reach 1, which means that there will be no `j` for any `i` and `k` ( for input 100):\\n```\\ni      k      j\\n----------------\\n1      65\\n......\\n```\\n### Conclusion\\nBecause by doing so we can always guarantee that:\\n1. there is no `j` in the **second part** for any `i` `k` in the **first part**, (this pattern I didn\\'t point it out above but it\\'s pretty clear)\\n2. there is no `j` for `i` in the **first part** and `k` in the **second part**, (this pattern is pointed out above)\\n3. the **second part** can always be transformed from the first part ( by adding one to all elements in the first part, which influence nothing), which means that it holds the same rule as the **first part**,\\n4. the **first part** is a beautiful array.\\n\\nwe can safely conclude that in this way we can always come up with a beautiful array.\\n\\n### PS\\nIt may be a little tricky to follow the thought.\\nIf you are still confused, try analysing the array of input 100.\\nBy dividing the array until its length reach 1, you\\'ll know why.",
                "solutionTags": [],
                "code": "```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63,2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61]\\n[3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62]\\n[4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n......\\n```\n```\\nvar beautifulArray = function(N) {\\n    let arr=Array.from({length:N}, (x,i)=>i+1);\\n    return helper(arr);\\n\\n    function helper(arr){\\n    \\tif(arr.length===1) return arr;\\n    \\tlet o=[], e=[]; //odd index and even index\\n    \\tfor(let i=0; i<arr.length; i++){\\n    \\t\\tif(i%2===0) e.push(arr[i]);\\n    \\t\\telse o.push(arr[i]);\\n    \\t}\\n    \\treturn helper(e).concat(helper(o));\\n    }\\n};\\n```\n```\\n1,3,5,7,9..... | 2,4,6,8,10.....\\n```\n```\\ni      k                j\\n-------------------------\\n1      2,4,6,8,10...\\n3      2,4,6,8,10...\\n5      2,4,6,8,10...\\n7      2,4,6,8,10...\\n9      2,4,6,8,10...\\n......\\n```\n```\\n1,3,5,7,9......\\n```\n```\\n1,5,9,... | 3,7,11,...\\n```\n```\\ni      k                j\\n--------------------------\\n1      3,7,11,...\\n5      3,7,11,...\\n9      3,7,11,...\\n......\\n```\n```\\ni      k      j\\n----------------\\n1      65\\n......\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370870,
                "title": "java-break-up-every-arithmetic-sequence-with-visual-intuition",
                "content": "**Short algorithm:**\\n* On every step, split array in half by taking all odd-indexed elements in one half and even-indexed in another half. \\n* recursively repeat it with already split parts\\n* return any array of size 2 or less, because it is already beautifully arranged by definition\\n* combine the results of the recursive calls into one array and return it.\\n\\n**Some visual intuition:**\\n\\nWe\\'re basically splitting all possible arithmetic sequences of the original sequence. Arithmetic sequence is a sequence of numbers such that the difference between the consecutive terms is constant.\\n\\nLet\\'s take an example of `n = 15`:\\n![image](https://assets.leetcode.com/users/images/17363ba3-3bdb-4f08-9bb9-de4e4dc081cf_1627578554.3805828.png)\\n\\nNumbers in the original array form an arithmetic sequence with distance between elements equal to 1.\\n\\nIf you pick any start number, and then start counting from it at regular intervals, you will get yourself another arithmetic sequence with bigger intervals between elements.\\n\\nHere\\'s a bunch of arithmetic subsequences with distance 2:\\n![image](https://assets.leetcode.com/users/images/24f56eeb-680d-4471-aa4e-a8fba8fcda15_1627578918.2668414.png)\\n\\nHere\\'s arithmetic subsequences with distance 3:\\n![image](https://assets.leetcode.com/users/images/f008b8c8-f0c8-4e6e-a1d0-420fe85c5cc3_1627583177.4423501.png)\\n\\nAny arithmetic sequence in our output will be problematic. Here\\'s why. In the original arithmetic sequence, if you take any consequent three numbers, the beautiful condition will always be violated, and the doubled middle element will always be equal to the sum of its neighbours:\\n\\n![image](https://assets.leetcode.com/users/images/a5ba7916-6dad-4db4-931d-b61223d59761_1627579282.14404.png)\\nIt\\'s very easy to prove, take three elements: `n - 1`, `n`, `n + 1`\\nAnd you can see that the sum of the neighbours is `n - 1 + n + 1 = 2n` \\n\\nThe same holds on the larger scale:\\n![image](https://assets.leetcode.com/users/images/a7076ad8-f082-4116-89fd-eccdb3779bf3_1627579651.9805753.png)\\n\\nSimilarly easy to prove, take three elements: `n - a`, `n`, `n + a`\\nSum of the neighbours is `n - a + n + a = 2n`\\n\\nSo in case of `1`, `2,` `3`, it\\'s important that in our output 2 is never between `1` and `3`, so you can split these numbers into two groups, grouping up `1` and `3`:\\n![image](https://assets.leetcode.com/users/images/cbaec3c3-f872-4696-9e51-ebe73318bcd2_1627580260.6508982.png)\\n\\nSimilarly for bigger numbers, you never want the middle to be between two numbers that are at the same distance from it, so in case of 3 elements, you can group the equidistant elements up:\\n\\n![image](https://assets.leetcode.com/users/images/5b3e8e03-ccc8-427e-b2be-e6bfdf768bc8_1627580424.684246.png)\\n\\n**Visual example of how algorithm works:**\\n\\nNow let\\'s apply the algorithm described above to earlier example of `n = 15` and let\\'s look what happenes when we split array in half on each step by taking every other element:\\n\\n**Step 1:**\\n\\n![image](https://assets.leetcode.com/users/images/f8392c5d-ca94-425f-9b62-bd5ef5e89b4c_1627582766.3520532.png)\\n\\nWe split array into two subarrays, taking every other element.\\nNotice how left subarray is still forming an arithmetic subsequence, and right one is forming another one.\\n\\n**Step 2:**\\n![image](https://assets.leetcode.com/users/images/1b3b1b8d-6444-44f9-9875-6b8adc0f95c6_1627582818.6821275.png)\\nWe repeat the process for subarrays formed on the previous step.\\nSimilarly, each subarray is still anarithmetic subsequence with bigger distance than on the previous step, so those need to be split up.\\n\\n**Step 3:**\\n![image](https://assets.leetcode.com/users/images/18c228da-50ab-46cb-8763-a8568fa7483c_1627582851.741937.png)\\n\\nHere, each smaller array is of size 2 or less, so we can stop, since two elements are arranged beautifully by definition.\\nSo `1`, `9`, `5,` `13`, `3`, `11`, `7`, `15`, `2`, `10`, `6`, `14`, `4`, `12`, `8` is our final answer.\\n\\nIf you trace these formed groups back in the original array, you\\'ll have this picture:\\n![image](https://assets.leetcode.com/users/images/4406f5f6-890a-45f1-b6a5-c876e0c18a79_1627583022.382805.png)\\n\\nNotice how each pair has the same distance between each other, `9 - 1 = 8`, `10-2 = 8`, and so on. We\\'re basically splitting array into (n / 2) pairs of grouped elements, with equal distance between them.\\n\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n      \\n    public int[] beautifulArray(int n) {\\n        List<Integer> ordered = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toList());\\n        return arrangeBeautifully(ordered).stream().mapToInt(it -> it).toArray();\\n    }\\n   \\n    private List<Integer> arrangeBeautifully(List<Integer> numbers) {\\n        // two numbers or less are already arranged\\n        if (numbers.size() <= 2) {\\n            return numbers;\\n        }\\n        \\n        // split into two lists by taking every other number. all odds indexes go left, all even indexes go right\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int i = 0; i < numbers.size(); ++i) {\\n            if (i % 2 == 0) {\\n                left.add(numbers.get(i));\\n            } else {\\n                right.add(numbers.get(i));\\n            }            \\n        }\\n        \\n        // arrange both halves recursively\\n        List<Integer> arrangedLeft = arrangeBeautifully(left);\\n        List<Integer> arrangedRight = arrangeBeautifully(right);\\n        \\n        // combine arranged halves into one list\\n        arrangedLeft.addAll(arrangedRight);\\n        return arrangedLeft;        \\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n      \\n    public int[] beautifulArray(int n) {\\n        List<Integer> ordered = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toList());\\n        return arrangeBeautifully(ordered).stream().mapToInt(it -> it).toArray();\\n    }\\n   \\n    private List<Integer> arrangeBeautifully(List<Integer> numbers) {\\n        // two numbers or less are already arranged\\n        if (numbers.size() <= 2) {\\n            return numbers;\\n        }\\n        \\n        // split into two lists by taking every other number. all odds indexes go left, all even indexes go right\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int i = 0; i < numbers.size(); ++i) {\\n            if (i % 2 == 0) {\\n                left.add(numbers.get(i));\\n            } else {\\n                right.add(numbers.get(i));\\n            }            \\n        }\\n        \\n        // arrange both halves recursively\\n        List<Integer> arrangedLeft = arrangeBeautifully(left);\\n        List<Integer> arrangedRight = arrangeBeautifully(right);\\n        \\n        // combine arranged halves into one list\\n        arrangedLeft.addAll(arrangedRight);\\n        return arrangedLeft;        \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367982,
                "title": "c-0ms-100-bit-sorting-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 6.8 MB, less than 97.21% of C++ online submissions for Beautiful Array.\\n![image](https://assets.leetcode.com/users/images/bd208253-2d55-46f9-b7e3-0a2fd16665f5_1627465447.185023.png)\\n**note** we will have other right answer = {7, 11, 3, 13, 5, 9, 1, 6, 10, 2, 12, 4, 8}, because we sort strictly (for not equal bit position we give preference for bit \\'1\\'). We also can change condition in sorting comparator and we will have in answer firstly numbers with \\'0\\' in bit position. \\n\\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n    int mask = 1;\\n    while(true)\\n      if((a&mask) == (b&mask)) mask = mask<<1;\\n      else return (a&mask) > (b&mask); \\n  }\\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\\n**p.s.** I think we also can find out \"sorting condition\" in bit operation for this bit problem.\\n\\n**and I done it :**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 6.8 MB, less than 93.03% of C++ online submissions for Beautiful Array.\\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n \\xA0 \\xA0int mask = (a^b); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  //xOr for transform the same right most positions into \\'0\\'\\n    mask = mask & (-mask);             //fetch the most right \\'1\\'\\n    return a & mask;                     //check if the right most \\'1\\' is belonged a or b   \\n  }\\n  \\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n    int mask = 1;\\n    while(true)\\n      if((a&mask) == (b&mask)) mask = mask<<1;\\n      else return (a&mask) > (b&mask); \\n  }\\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n \\xA0 \\xA0int mask = (a^b); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  //xOr for transform the same right most positions into \\'0\\'\\n    mask = mask & (-mask);             //fetch the most right \\'1\\'\\n    return a & mask;                     //check if the right most \\'1\\' is belonged a or b   \\n  }\\n  \\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186727,
                "title": "leetcode-weekly-contest-108-screencast-only-record-10-mins",
                "content": "I record the screencast on Windows with a trial version of Bandicam, didn't realize only the first 10 mins is recorded...\n\nHope next time, I won't screw it up.\n\nhttps://www.youtube.com/watch?v=X3sYZBBviY8",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=X3sYZBBviY8",
                "codeTag": "Unknown"
            },
            {
                "id": 186661,
                "title": "3-solutions-4-lines-in-python-divide-conquer-dp-top-down-and-bottom-up",
                "content": "**Divide and Conquer:**\\n\\nDivide and conquer strategy:\\n  l gives beautiful array of even numbers\\n\\tr gives beautiful array of odd numbers\\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n\\tl=self.beautifulArray(N//2)\\n\\tr=self.beautifulArray(N-N//2)\\n\\treturn [x*2 for x in l]+[x*2-1 for x in r]\\n```\\nYou can optimize this by having only 1 recrusive call :\\n```\\ndef beautifulArray(self, N):\\n        if N == 1: return [1]\\n        half = self.beautifulArray(N - N / 2)\\n        return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]\\n```\\nThanks [@lee215](https://leetcode.com/lee215/) for suggesting this.\\n\\n**Top-Down DP (memoization):**\\n\\nYou can see overallping subproblems if you draw recursion tree, hence you can use memoization:\\n```\\n\\nclass Solution:\\n    memo = {}\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n        if N in self.memo: return self.memo[N]\\n        l=self.beautifulArray(N//2)\\n        r=self.beautifulArray(N-N//2)\\n        self.memo[N] = [x*2 for x in l]+[x*2-1 for x in r]\\n        return self.memo[N]\\n```\\n\\n**DP (bottom up):**\\nYou construct the tree in bottom up manner:\\n\\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp = {}\\n        dp[1] = [1]\\n        for i in range(2,N+1):\\n            dp[i] = [x*2 for x in dp[i//2]] + [x*2-1 for x in dp[i-i//2]]\\n        \\n        return dp[N]\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n\\tl=self.beautifulArray(N//2)\\n\\tr=self.beautifulArray(N-N//2)\\n\\treturn [x*2 for x in l]+[x*2-1 for x in r]\\n```\n```\\ndef beautifulArray(self, N):\\n        if N == 1: return [1]\\n        half = self.beautifulArray(N - N / 2)\\n        return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]\\n```\n```\\n\\nclass Solution:\\n    memo = {}\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n        if N in self.memo: return self.memo[N]\\n        l=self.beautifulArray(N//2)\\n        r=self.beautifulArray(N-N//2)\\n        self.memo[N] = [x*2 for x in l]+[x*2-1 for x in r]\\n        return self.memo[N]\\n```\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp = {}\\n        dp[1] = [1]\\n        for i in range(2,N+1):\\n            dp[i] = [x*2 for x in dp[i//2]] + [x*2-1 for x in dp[i-i//2]]\\n        \\n        return dp[N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367779,
                "title": "beautiful-array-easy-clean-w-2-approach",
                "content": "# **APPROACH 1:**\\n* **Iterative/sorting-**\\n![Meaning Of Using Bits](https://assets.leetcode.com/users/images/8a56cda7-5496-49b8-89be-2eae3e4ad95b_1627456380.537388.png)\\n\\n\\n```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\\n**Time Complexity: O(NlogN)\\nSpace Complexity: O(1)**\\n\\n\\n\\n# **APPROACH 2:**\\n**ALGORITHM:**\\n* Create a vector called ans, insert 1 into ans\\n* While size of ans < N\\n\\t* create a vector temp\\n\\t* for i in range 0 to size of ans \\u2013 1 \\n\\t\\t* if ans[i] * 2 \\u2013 1 <= N, then insert ans[i] * 2 \\u2013 1 into temp array \\n\\t* for i in range 0 to size of ans \\u2013 1\\n\\t\\t* if ans[i] * 2 <= N, then insert ans[i] * 2 into temp array\\n\\t* set ans := temp\\n* return ans\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186660,
                "title": "python-recursion",
                "content": "\\n\\nExample:\\n1,2,3,4,5,6,7,8,9\\n-->\\n1,3,5,7,9,2,4,6,8\\n-->\\n1,5,9,3,7,2,6,4,8\\n-->\\n1,9,5,3,7,2,6,4,8\\n```\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.helper(range(1,N+1))\\n        \\n    def helper(self, lst):\\n        if len(lst)<=2:         return lst\\n        return self.helper(lst[::2]) + self.helper(lst[1::2])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.helper(range(1,N+1))\\n        \\n    def helper(self, lst):\\n        if len(lst)<=2:         return lst\\n        return self.helper(lst[::2]) + self.helper(lst[1::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644612,
                "title": "python3-solution-with-detailed-explanation-beautiful-array",
                "content": "First, divide the array into even numbers and odd numbers so that we only need to further arrange numbers within even or odd numbers themselves because nums[i] and nums[j] must be both even or odd and can\\'t be one even and one old. \\n\\nThen, further divide each division into numbers at even indices and odd indices till the division length is either 1 or 2 at which time just return the division. This works the same way as the first step, because if you divide all even numbers by 2, you will have even and odd number again, e.g. `[2,4,6,8,10] -> [1,2,3,4,5]`. If you add odd numbers by 1 and divide by 2, you will also have even and odd numbers, e.g. `[1,3,5,7,9] -> [2,4,6,8,10] -> [1,2,3,4,5]`.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        nums = list(range(1, N+1))\\n        \\n        def helper(nums) -> List[int]:\\n            if len(nums) < 3:\\n                return nums\\n            even = nums[::2]\\n            odd = nums[1::2]\\n            return helper(even) + helper(old)\\n        return helper(nums)   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        nums = list(range(1, N+1))\\n        \\n        def helper(nums) -> List[int]:\\n            if len(nums) < 3:\\n                return nums\\n            even = nums[::2]\\n            odd = nums[1::2]\\n            return helper(even) + helper(old)\\n        return helper(nums)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 371380,
                "title": "c-separate-odd-index-with-even-index",
                "content": "Different with the most voted solution, I generate the permutaion in the begining. \\n```\\nint S* = {1,2,3,4,5,6,7,8}\\n```\\nObviously, it\\'s not a beautiful array, let\\'s make it a beautiful one.\\nMy intuition is: sifting all possible  A[k] out until it\\'s beautiful.\\n\\nI extract the elements with even index(i.e. 0,2,4...) to the front of subarray while the odd to the back of subarray. Like\\n```\\nint A* = {1,3,5,7};\\nint B* = {2,4,6,8};\\n//update S\\nS= {1,3,5,7,2,4,6,8};\\n```\\nBut in subarray itself, it\\'s still not beautiful, let\\'s look at left subarray.\\n```\\nint * A = {1,3,5,7} \\n2*A[1] = A[0] * A[2]; //broke the rule\\n```\\nSo let\\'s do the same thing for this subarray, move elements with even index forward, while the odd backward.\\n```\\n//update A\\nA = {1,5,3,7}\\n```\\nKeep dividing until the array size <= 2,  then all the possible A[k] are separted with A[i], A[j].\\n//Talk is cheap, here is the code:)\\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> S;\\n        for (int i = 1; i <= N; ++i) {\\n            S.push_back(i);\\n        }\\n        divide(S, 0, N - 1);\\n        return S;\\n    }\\n    \\n    void divide(vector<int>& S, int l, int r) {\\n        if (r - l <= 1) return;\\n        vector<int> odd, even;\\n        for (int i = l; i <= r; ++i) {\\n            if ((i + 1 - l) & 1) { //using relative index\\n                odd.push_back(S[i]);\\n            } else {\\n                even.push_back(S[i]);\\n            }\\n        }\\n        std::copy(odd.begin(), odd.end(), S.begin() + l);\\n        std::copy(even.begin(), even.end(), S.begin() + l + odd.size());\\n        int m = (r - l) / 2 + l;\\n        divide(S, l, m);\\n        divide(S, m + 1, r);\\n    }\\n```\\nT(N) = 2(T/2) + O(N)\\naccording to master theorem\\uFF0C T(N) = O(NlogN)",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nint S* = {1,2,3,4,5,6,7,8}\\n```\n```\\nint A* = {1,3,5,7};\\nint B* = {2,4,6,8};\\n//update S\\nS= {1,3,5,7,2,4,6,8};\\n```\n```\\nint * A = {1,3,5,7} \\n2*A[1] = A[0] * A[2]; //broke the rule\\n```\n```\\n//update A\\nA = {1,5,3,7}\\n```\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> S;\\n        for (int i = 1; i <= N; ++i) {\\n            S.push_back(i);\\n        }\\n        divide(S, 0, N - 1);\\n        return S;\\n    }\\n    \\n    void divide(vector<int>& S, int l, int r) {\\n        if (r - l <= 1) return;\\n        vector<int> odd, even;\\n        for (int i = l; i <= r; ++i) {\\n            if ((i + 1 - l) & 1) { //using relative index\\n                odd.push_back(S[i]);\\n            } else {\\n                even.push_back(S[i]);\\n            }\\n        }\\n        std::copy(odd.begin(), odd.end(), S.begin() + l);\\n        std::copy(even.begin(), even.end(), S.begin() + l + odd.size());\\n        int m = (r - l) / 2 + l;\\n        divide(S, l, m);\\n        divide(S, m + 1, r);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373064,
                "title": "java-clear-thinking-process-divide-and-conquer",
                "content": "I did not solve the problem first. And I was also confused by looking at the official solutions. Here are my thinking process of how I finally got to understand it.\\n\\nBefore getting into the algorithmn, there are some observations we can make on a normal array with elements {1, 2, ... n}:\\n1. \\tThe only condition here is `2*nums[k] = nums[i] + nums[j] (i < k < j)`. If we know what nums[k] is, how can we make this equation true? The only way to achieve this equation is when nums[k] is the midpoint of the nums[i] and nums[j]. With math, it is simple to prove: 2*nums[k] = nums[i] + nums[j] --> nums[k] - nums[i] = nums[j] - nums[k] (nums[i] < nums[k] < nums[j] since we are on the normal array right now) Therefore, **to avoid making this equation true, we have to choose two values that each has a different distance from the other to nums[k], from each of the two sides of nums[k].**\\n2. \\t Based on observation 1, if we think further, if nums[i] and nums[j] both have equal distance to nums[k], nums[i] and nums[j] must be both odd or both even numbers, in a normal array (This is the start of the approach).\\n\\nTo conclude, in order to find a beautiful array, we need to rearrange each element so that whenever we choose an element as nums[k], **we cannot find any two elements nums[i] and nums[j] from each side with equal distance**. How are we going to do this? \\n\\nObservation 2 already gives part of the answer. We know for sure that nums[i] and nums[j] must have same distance from nums[k]. In this normal array, the interval between each element is 1. (1+1* 0, 1+1* 1, 1+1* 2, ... ) Therefore, the difference bewteen nums[k] to nums[i] and nums[j] has to be 1 * \"something\" (1 is the interval here). The only two results will be: it suffices the equation--the difference is the same; or it doesn\\'t fit--the difference is different. Now, what is one thing or the **property of natural numbers** that can categorize the \"something\" part of the interval into 2 groups so that we immediately know the number (nums[i]) we pick in that group will not have the same distance as the other number (nums[j]) we pick in the other part? \\n\\nEven and Odd! Since even numbers are always different, or to be speficic, 1 unit (This is the interval right now in the array, This is important for explanation later!) different from odd numbers. (Keep in mind that the even and odd here is the \"something\" part mentioned above, not the values in the array) So if we pick nums[i] from a bunch of odd numbers, we know for sure that if nums[j] is even (or different from nums[i], to be general), it is never going to fit the condition. \\n\\nHowever, if nums[i], and nums[j] are both odd or even, it still suffices the equation. How can we prevent this from happening?\\nRemember, there is another constraint hidden in the statement, that is i and j (the indices) has to be on the two sides of k. If we can put all odd numbers on one side and all even numbers on the other side of the array, we can make sure that if k (the index) is on the even side, if nums[i] or nums[j] is chosen among the odd numbers, it will not work because in that case nums[i] and nums[j] has both to be in the odd side, which is both on the left side of nums[k]. (If we put odd nums on the left and even nums on the right, see example below later)\\n\\nBut think about the statement above, \"if k (the index) is on the even side, nums[i] or nums[j] chosen among the odd numbers won\\'t work\", there is an extra case we didn\\'t address, that is if nums[i], nums[j] and nums[k] are all on the odd side or even side, it will still work. However, that leads us to a smaller version of the original problem on the normal array, where elements are no longer `1, 2, ... n` , but `1, 3, 5, 7...` or `2, 4, 6, 8 ...`.\\n\\nNow, which algorithmn allows us to break a large problem into smaller solvable problems while we need to keep cactegorizing and dividing the 2 groups of numbers?\\n\\n### **Divide and Conquer**\\n\\nThe algorithmn is already quite clear now:\\n1. construct a normal array\\n2. divide the array into 2 groups\\n3. put the one group of numbers all on the left and the other on the right\\n4. repeat steps 2 and 3\\n\\nWe only need to specify step 2 here. In above, we stopped after having the array with `1, 3, 5, 7... 2, 4, 6, 8...`. And now we need to make the equation wrong even when nums[i] and nums[j]  and nums[k] are all on one side. \\n\\nThe idea of interval becomes clear now. if we only look at the subarray on the left, which is `1, 3, 5, 7...`, we notice that every number still maintain equal distance with adjacent one, that is, (1+2* 0, 1+2* 1, 1+2* 2 ...). Same for the even numbers.\\nHere, the interval turns into 2 instead of 1. But the key doesn\\'t change, if have nums[i] even number of units away from nums[k], nums[j] has also to be an even number of units away from nums[k]. \"Units\" here is exactly the interval, which is 2 now, and 1 before. Similarly we can categorize these odd numbers into two groups, one contains numbers that have even number of intervals from each adjacent element, the other has numbers with odd number of intervals from each adjacent one.  Now whenever we choose nums[k] in one the two groups, nums[i] and nums[j] has to be at least both from one of the groups, which comes back to the same situation above, never gonna fit in the equation!\\n\\nHere is an example with `n=10`:\\n1. Creating original array \\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\\n2. First grouping\\n[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\\nLeft:\\n3. Group the left\\n[1, 5, 9, 3, 7...\\n4. Group the left from step 3\\n[1. 9, 5...\\n5. Group the right from step 3\\n[... 3, 7...\\nRight:\\n6. Group the right\\n... 2, 6, 10, 4, 8]\\n7. Group the left from step 6\\n... 2, 10, 6 ...]\\n8. Group the right from step 6\\n... 4, 8]\\n\\nFinal result:\\n[1, 9, 5, 3, 7, 2, 10, 6, 4, 8]\\n\\nThe steps above are described in a recursive structure. The implementation is below:\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] ans = new int[n];\\n        for(int i = 0; i  < n; i++){\\n            ans[i] = i+1;\\n        }\\n        recursion(ans, 0, n-1);\\n        return ans;\\n    }\\n    \\n    public void recursion(int[] arr, int left, int right){\\n        if(left >= right)\\n            return;\\n        ArrayList<Integer> l = new ArrayList<>();\\n        ArrayList<Integer> r = new ArrayList<>();\\n\\t\\t\\n        boolean alt = true;// Not worry about whether the factor of the interval is even or odd too much, they can be grouped by \\n\\t\\t\\t\\t\\t\\t\\t// just picking one and skip one\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(int i = left; i <= right; i++){ // picking the elements and put them into the two groups\\n            if(alt)\\n                l.add(arr[i]);\\n            else\\n                r.add(arr[i]);\\n            alt = !alt;\\n        }\\n\\n        for(int i = left; i <= right; i++){ // merging them into the final array\\n            if(!l.isEmpty())\\n                arr[i] = l.remove(0);\\n            else\\n                arr[i] = r.remove(0);\\n        }\\n        recursion(arr, left, (right+left)/2);\\n        recursion(arr, (left+right)/2+1, right);\\n    }\\n}\\n```\\n\\nMay not be the fastest, but hope to be the easiest to understand!\\nAnd this is my first time posting, please tell me if anything didn\\'t explain well!",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] ans = new int[n];\\n        for(int i = 0; i  < n; i++){\\n            ans[i] = i+1;\\n        }\\n        recursion(ans, 0, n-1);\\n        return ans;\\n    }\\n    \\n    public void recursion(int[] arr, int left, int right){\\n        if(left >= right)\\n            return;\\n        ArrayList<Integer> l = new ArrayList<>();\\n        ArrayList<Integer> r = new ArrayList<>();\\n\\t\\t\\n        boolean alt = true;// Not worry about whether the factor of the interval is even or odd too much, they can be grouped by \\n\\t\\t\\t\\t\\t\\t\\t// just picking one and skip one\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(int i = left; i <= right; i++){ // picking the elements and put them into the two groups\\n            if(alt)\\n                l.add(arr[i]);\\n            else\\n                r.add(arr[i]);\\n            alt = !alt;\\n        }\\n\\n        for(int i = left; i <= right; i++){ // merging them into the final array\\n            if(!l.isEmpty())\\n                arr[i] = l.remove(0);\\n            else\\n                arr[i] = r.remove(0);\\n        }\\n        recursion(arr, left, (right+left)/2);\\n        recursion(arr, (left+right)/2+1, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189066,
                "title": "a-concise-python-recursive-solution-with-explanation-o-n",
                "content": "```python\\nclass Solution:\\n\\t def beautifulArray(self, N):\\n        \"\"\"\\n        If we have a beautiful array A, then it means for any i < k < j. A[k] * 2 != A[i] + A[j]. Let\\'s add x to all\\n        elements of beautiful array. In that case (A[k] + x) * 2 != A[i] + x + A[j] + x => A[k] * 2 + 2x != A[i] + A[j] + 2x =>\\n        A[k] * 2 != A[i] + A[j]. Which proves that, adding same number to beatiful array doesn\\'t make it ugly.\\n        \\n        Now let\\'s multiply x with all numbers in beautiful array. (A[k] * 2) * x != A[i] * x + A[j] * x =>\\n        (A[k] * 2) * x != (A[i] + A[j]) * x => A[k] * 2 != A[i] + A[j]. Which proves that multiplying some number to \\n        beautiful array doesn\\'t make it ugly. If we delete some number from beautiful array, it\\'ll not make it ugly\\n        i.e. A[k] * 2 != A[i] + A[j] we can prove it by intuition.\\n        \\n        So If we want to know the beautiful array with element [1, N] and we already known the beautiful array for [1, N/2],\\n        We can multiply all elements of that array by 2, and we\\'ll get a new beautiful array with all even numbers from b/w\\n        [1, N] and if we subtract 1 from each element of this new even beauiful array, we get a new beautiful array with\\n        all odd elements b/w [1, N]. Now we got two beautiful arrays one has all odd elements and other has all even elements.\\n        Now we know that for beautiful array A[k] * 2 != A[i] + A[j]. If A[i] and A[j] have different partiy (one is odd and\\n        other is even) then their sum would be odd always and A[k] * 2 != A[i] + A[j] condition will always met as left side of\\n        the condition is even so for right side of the condition to be even both A[i] and A[j] shoud have same parity. It means\\n        that if we simply concatenate two beautiful arrays with even and odd elements, the new aray would still be beautiful.\\n        \\n        One Last observation is what if N is odd then it\\'s not divisible by 2. We can simply add 1 to it and make it even\\n        to find beautiful array for [1, N + 1] and once we find it, we can simply remove N + 1 from answer. \\n        \\n        In each function call, we are taking half of the elements so depth of recursion or total funcion calls would be O(LogN)\\n        and in each execution, O(N / k) process would be done. So in first call, O(N) work would be done in pre-processing\\n        and concatenation, in second, call O(N / 2), in third O(N / 4) and so on. If we add all these processing times then\\n        using geometric series Sum would be O(2N) = O(N) so runtime is O(N) and Memory complexity is O(N).\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N == 1: return [1]\\n        b_array = self.beautifulArray((N if N % 2 == 0 else N + 1) // 2)\\n        return filter(lambda x: x != N + 1, map(lambda x: 2 * x, b_array) + map(lambda x: 2 * x - 1, b_array))\\n\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\t def beautifulArray(self, N):\\n        \"\"\"\\n        If we have a beautiful array A, then it means for any i < k < j. A[k] * 2 != A[i] + A[j]. Let\\'s add x to all\\n        elements of beautiful array. In that case (A[k] + x) * 2 != A[i] + x + A[j] + x => A[k] * 2 + 2x != A[i] + A[j] + 2x =>\\n        A[k] * 2 != A[i] + A[j]. Which proves that, adding same number to beatiful array doesn\\'t make it ugly.\\n        \\n        Now let\\'s multiply x with all numbers in beautiful array. (A[k] * 2) * x != A[i] * x + A[j] * x =>\\n        (A[k] * 2) * x != (A[i] + A[j]) * x => A[k] * 2 != A[i] + A[j]. Which proves that multiplying some number to \\n        beautiful array doesn\\'t make it ugly. If we delete some number from beautiful array, it\\'ll not make it ugly\\n        i.e. A[k] * 2 != A[i] + A[j] we can prove it by intuition.\\n        \\n        So If we want to know the beautiful array with element [1, N] and we already known the beautiful array for [1, N/2],\\n        We can multiply all elements of that array by 2, and we\\'ll get a new beautiful array with all even numbers from b/w\\n        [1, N] and if we subtract 1 from each element of this new even beauiful array, we get a new beautiful array with\\n        all odd elements b/w [1, N]. Now we got two beautiful arrays one has all odd elements and other has all even elements.\\n        Now we know that for beautiful array A[k] * 2 != A[i] + A[j]. If A[i] and A[j] have different partiy (one is odd and\\n        other is even) then their sum would be odd always and A[k] * 2 != A[i] + A[j] condition will always met as left side of\\n        the condition is even so for right side of the condition to be even both A[i] and A[j] shoud have same parity. It means\\n        that if we simply concatenate two beautiful arrays with even and odd elements, the new aray would still be beautiful.\\n        \\n        One Last observation is what if N is odd then it\\'s not divisible by 2. We can simply add 1 to it and make it even\\n        to find beautiful array for [1, N + 1] and once we find it, we can simply remove N + 1 from answer. \\n        \\n        In each function call, we are taking half of the elements so depth of recursion or total funcion calls would be O(LogN)\\n        and in each execution, O(N / k) process would be done. So in first call, O(N) work would be done in pre-processing\\n        and concatenation, in second, call O(N / 2), in third O(N / 4) and so on. If we add all these processing times then\\n        using geometric series Sum would be O(2N) = O(N) so runtime is O(N) and Memory complexity is O(N).\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N == 1: return [1]\\n        b_array = self.beautifulArray((N if N % 2 == 0 else N + 1) // 2)\\n        return filter(lambda x: x != N + 1, map(lambda x: 2 * x, b_array) + map(lambda x: 2 * x - 1, b_array))\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192798,
                "title": "4-liner",
                "content": "**Iterative/sorting**\\n**time: `O(NlogN)`, space: `O(1)`**\\n```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> out(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn out;  \\n}\\n```\\n**Divide and conquer**\\n\\nFirst populate the array with numbers `1...N`. Now we need to rearrange the numbers in the array to make it beautiful.\\nThe logic is simple: in order `A[k]*2=A[i]+A[j] i<k<j` to hold we need `A[i]` and `A[j]` to have the same parity. So if you place all odd elements prior to all even elements you *divide* your problem *\"reposition elements in the array so that `A[k]*2\\u2260A[i]+A[j]`\"* into two \"nonoverlapping\" subproblems: \\n* *reposition elements in the contiguous \"odd subarray\" so that `A[k]*2\\u2260A[i]+A[j]`*;\\n* *reposition elements in the contiguous \"even subarray\" so that `A[k]*2\\u2260A[i]+A[j]`*.\\n\\n![image](https://assets.leetcode.com/users/images/6c2524a0-a463-4f6f-867a-0e166a34ccd7_1620233440.041865.png)\\n<br>\\n\\nNote that you\\'ve segregated the numbers based on the question *\"Do elements have the same remainder modulo `2`?\"*\\nYou can do the same using custom sorting so that odd elements are less than even. \\nThe next question will be `\"Do even/odd elements have the same remainder modulo `4`?\" etc...\\n\\n**Sorting**\\n\\nYou can do all segregating of the elements via sorting procedure.\\nComparison of elements should be based on their remainder modulo `1/2^i` \\u2014 binary digits of numbers `1..N`.\\nThe comparison lambda could be written in few ways and its work is equivalent to the following.\\n\\n> Travese binary digits from **right** to **left** untill `x` and `y` have **different** digits. \\nIf this digit is `1` for `x` and `0` for `y` then `x` is smaller, otherwise `y` is smaller.\\n\\n> Here\\'s another explanation. Let `x` has binary representation `\"00010101001000\"` and `y` - `\"00001011011000\"`.\\nYou can get the lambda\\'s result if you reverse these strings and `return` `reverse(\"00010101001000\") > reverse(\"00001011011000\")` \\n(**lexicographical order** of reversed strings that represent binary representation of numbers).\\n\\nMy lambda does exactly this but using bitwise magic. `-(x^y)` finds the first mismatching digit from the right (leaving some \"garbage\" to the left of it). Then you `&` it with `x` and `~y`. This deletes the \"gardage\" and returns `true` if `x` has `1` on the `first_from_the_right_mismatching_spot` and `y` has `0` on the same spot (and return `false` otherwise).\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/26ad4531-fa92-4553-9935-6aa0518cdaa0_1620226589.684505.png)\\n\\n<br>\\n\\n**Final note**: There exists a more efficient linear time solution based on the same idea. Check out the [post](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)) by Lee for this solution.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> out(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn out;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368347,
                "title": "recursive-java-solution-with-explanation",
                "content": "First of all, I want to explane why it works:\\n- the formula that defines a \"beautiful\" array is arr[k]***2** != arr[i]+arr[j] and it contains a doubling. It means that if arr[i] is odd and arr[j] is even, or vice versa, the formula won\\'t work. It means that if we put all odd elements in the left part of an array and all the even elements in the right, we should only be sure that an odd part is \"beautiful\" and an even part is \"beautiful\". If so, together they also are \"beautiful\".\\n- an array with n elements contains (n+1)/2 odd elements and n/2 even elements.\\n - If there is a \"beautiful\" array and we multiply every element of this array, it will still be \"beautiful\" because the formula above is linear. What I want to say is that\\n ```\\n [1,3,2] is \"beautiful\".\\n ```\\n If we double it, it still will be \"beautiful\" and all the elements will be **even**\\n ```\\n [1,3,2]*2 => [2,6,4]\\n ```\\n If we after doubling decrease 1, the array will also be \"beautiful\", but all the elements will be **odd**\\n \\n ```\\n  ([1,3,2]*2)-1 => [1,5,3]\\n ```\\n \\n Using the ideas above, it\\'s possible to conclude that it\\'s enough to break recursively the base array[n]. Than turn a \"beautiful\" subarray into the array of odd numbers and concatenate a \"beautiful\" subarray that was turned into an array of even numbers. And that\\'s it.\\n \\n The solution in Java:\\n\\n```\\n\\nclass Solution {\\n    Map<Integer,int[]> cache;\\n    public int[] beautifulArray(int n) {\\n        if (cache==null) cache = new HashMap();\\n        if (cache.containsKey(n)) return cache.get(n); //Beautiful array of this length already was created. Just get it from cache.\\n        \\n        int[] arr = new int[n];\\n        if (n==1){\\n            arr[0]=1;\\n        }else{\\n            int[] oddArr = beautifulArray((n+1)/2); //Beautiful subarray with a length as a number of odd elements in the current array;\\n            int[] evenArr = beautifulArray((n)/2);//The same for even numbers\\n            int j=0;\\n            for (int i=0; i<oddArr.length; i++){\\n                arr[j]=oddArr[i]*2-1;\\n                j++;\\n            }\\n            for (int i=0; i<evenArr.length; i++){\\n                arr[j]=evenArr[i]*2;\\n                j++;\\n            }\\n        }\\n        cache.put(n,arr);\\n        return arr;\\n    }    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n [1,3,2] is \"beautiful\".\\n ```\n```\\n [1,3,2]*2 => [2,6,4]\\n ```\n```\\n  ([1,3,2]*2)-1 => [1,5,3]\\n ```\n```\\n\\nclass Solution {\\n    Map<Integer,int[]> cache;\\n    public int[] beautifulArray(int n) {\\n        if (cache==null) cache = new HashMap();\\n        if (cache.containsKey(n)) return cache.get(n); //Beautiful array of this length already was created. Just get it from cache.\\n        \\n        int[] arr = new int[n];\\n        if (n==1){\\n            arr[0]=1;\\n        }else{\\n            int[] oddArr = beautifulArray((n+1)/2); //Beautiful subarray with a length as a number of odd elements in the current array;\\n            int[] evenArr = beautifulArray((n)/2);//The same for even numbers\\n            int j=0;\\n            for (int i=0; i<oddArr.length; i++){\\n                arr[j]=oddArr[i]*2-1;\\n                j++;\\n            }\\n            for (int i=0; i<evenArr.length; i++){\\n                arr[j]=evenArr[i]*2;\\n                j++;\\n            }\\n        }\\n        cache.put(n,arr);\\n        return arr;\\n    }    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905426,
                "title": "python3-o-nlogn-solution-without-mathematical-skills",
                "content": "Seriously, this question should be categorized as hard to those who have no experience of ACM, such like me.\\nhowever, there still is a way to come across the solution **without mathematical intuition and reasoning skills**, which needs a pen and  a paper, of coz, and a little bit observation.\\n\\nFirst, it is not hard to figure out that,\\n**odd + even = odd != 2 * x**\\nso devide the array from 1 to N into two parts (take N=10 as example),\\n*1 3 5 7 9 | 2 4 6 8 10*\\nthen the question becomes how to make the left or the right be \"beautiful array\". \\nlook at the right part that includes even numbers, here the pen and paper are in need.\\nsay we have *2 ,4*, where should we put 6? apprently not the right most position, while the left most slot is ok, so we get *6, 2, 4*.\\nlikewisely, we get *6, 2, 4, 8*, and it is beautiful too. Given this, it seems that we can rebuild the left part spirally, but can it work always?\\nUnfortunately, the answer is no. *10, 6, 2, 4, 8* is not beautiful. \\nhere comes the **KEY** -- if we splitted the spiral array into two parts and rebuild each part spirally again, we got two beautiful arrays,\\n*10 2 6 | 4 8*, **AND**, any number in the sub left plus any number in the sub right is a double of **odd**, while all numbers in this array are **even**.\\nbut are we to the end? *18 10 2 6 14* is not beautiful once more. so split and rebuild, *18 2 10 | 6 14*, **(left x + right y) / 2 is not in the array itself**.\\nit can be easily verified that all the above steps are also feasible on original odd subarrays.\\nhaving gone so far, it is not difficult to think of **devide and conquer** and **recursion**, and **TRY**.\\nso here comes the naive recursion solution,\\n```\\ndef beautifulArray(self, N: int) -> List[int]:\\n        def _split(arr):\\n            if len(arr) <= 2:\\n                return arr\\n            odd, even = [], []\\n            for i, n in enumerate(arr):\\n                if i % 2: even.append(n)\\n                else: odd.append(n)\\n            return _split(odd) + _split(even)\\n\\n        return _split([i for i in range(1, N + 1)])\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulArray(self, N: int) -> List[int]:\\n        def _split(arr):\\n            if len(arr) <= 2:\\n                return arr\\n            odd, even = [], []\\n            for i, n in enumerate(arr):\\n                if i % 2: even.append(n)\\n                else: odd.append(n)\\n            return _split(odd) + _split(even)\\n\\n        return _split([i for i in range(1, N + 1)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 762659,
                "title": "java-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        List<Integer> pass = new ArrayList<>();\\n        for(int i=1; i<N+1; i++) pass.add(i);\\n        \\n        List<Integer> ans = dfs(pass);\\n        \\n        return ans.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    private List<Integer> dfs(List<Integer> arr){\\n        if(arr.size() < 3) return arr;\\n        \\n        List<Integer> odd = new ArrayList<>();\\n        List<Integer> even = new ArrayList<>();\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(i%2 == 0) even.add(arr.get(i));\\n            else odd.add(arr.get(i));\\n        }\\n        \\n        odd = dfs(odd);\\n        even = dfs(even);\\n        List<Integer> tmp = new ArrayList<>();\\n        tmp.addAll(odd);\\n        tmp.addAll(even);\\n        \\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        List<Integer> pass = new ArrayList<>();\\n        for(int i=1; i<N+1; i++) pass.add(i);\\n        \\n        List<Integer> ans = dfs(pass);\\n        \\n        return ans.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    private List<Integer> dfs(List<Integer> arr){\\n        if(arr.size() < 3) return arr;\\n        \\n        List<Integer> odd = new ArrayList<>();\\n        List<Integer> even = new ArrayList<>();\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(i%2 == 0) even.add(arr.get(i));\\n            else odd.add(arr.get(i));\\n        }\\n        \\n        odd = dfs(odd);\\n        even = dfs(even);\\n        List<Integer> tmp = new ArrayList<>();\\n        tmp.addAll(odd);\\n        tmp.addAll(even);\\n        \\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315467,
                "title": "python3-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef beautifulArray(self, N: int) -> List[int]:\\n\\t\\t\\tres=[1]\\n\\t\\t\\twhile len(res)<N:\\n\\t\\t\\t\\todd=[2*i-1 for i in res]\\n\\t\\t\\t\\teven=[2*i for i in res]\\n\\t\\t\\t\\tres=odd+even\\n\\t\\t\\treturn [i for i in res if i<=N]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef beautifulArray(self, N: int) -> List[int]:\\n\\t\\t\\tres=[1]\\n\\t\\t\\twhile len(res)<N:\\n\\t\\t\\t\\todd=[2*i-1 for i in res]\\n\\t\\t\\t\\teven=[2*i for i in res]\\n\\t\\t\\t\\tres=odd+even\\n\\t\\t\\treturn [i for i in res if i<=N]",
                "codeTag": "Java"
            },
            {
                "id": 1367962,
                "title": "explained-recursion-fast-easy-c",
                "content": "Example 123456 -> 135 246 -> 15 3 26 4 -> 153264\\n\\n2. Use Divide n Conquer Algorithm\\n2. Take the odd alteranate numbers in t1 and even alternate in t2\\n3. Join them back if the size of t1 or t2 is less than 3\\n4. return final answer \\n\\n```\\nvector<int> fun(vector<int> v){\\n\\n\\tif(v.size()<3)\\n\\t\\treturn v;\\n\\n\\tvector<int> t1;\\n\\tvector<int> t2;\\n\\n\\tfor(int i=0;i<v.size();i++){\\n\\t\\tif(i%2==0)\\n\\t\\t\\tt1.push_back(v[i]);\\n\\t\\telse\\n\\t\\t\\tt2.push_back(v[i]);\\n\\t}\\n\\n\\tt1=fun(t1);\\n\\tt2=fun(t2);\\n\\n\\tvector<int> t3;\\n\\tfor(int i=0;i<t1.size();i++)\\n\\t\\tt3.push_back(t1[i]);\\n\\tfor(int i=0;i<t2.size();i++)\\n\\t\\tt3.push_back(t2[i]);\\n\\n\\treturn t3;\\n}\\nvector<int> beautifulArray(int n) {\\n\\n\\tvector<int> t(n);\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tt[i-1]=i;\\n\\n\\treturn fun(t);\\n}\\n```\\n\\nIf it helps. Do Upvote !",
                "solutionTags": [],
                "code": "```\\nvector<int> fun(vector<int> v){\\n\\n\\tif(v.size()<3)\\n\\t\\treturn v;\\n\\n\\tvector<int> t1;\\n\\tvector<int> t2;\\n\\n\\tfor(int i=0;i<v.size();i++){\\n\\t\\tif(i%2==0)\\n\\t\\t\\tt1.push_back(v[i]);\\n\\t\\telse\\n\\t\\t\\tt2.push_back(v[i]);\\n\\t}\\n\\n\\tt1=fun(t1);\\n\\tt2=fun(t2);\\n\\n\\tvector<int> t3;\\n\\tfor(int i=0;i<t1.size();i++)\\n\\t\\tt3.push_back(t1[i]);\\n\\tfor(int i=0;i<t2.size();i++)\\n\\t\\tt3.push_back(t2[i]);\\n\\n\\treturn t3;\\n}\\nvector<int> beautifulArray(int n) {\\n\\n\\tvector<int> t(n);\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tt[i-1]=i;\\n\\n\\treturn fun(t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367878,
                "title": "beautiful-array-recursion-with-short-explanation-c",
                "content": "Approach:\\n\\t\\n\\tRecursion: At first, we can put all even numbers on the left, and all odd numbers on the right.\\n\\t\\n    1. In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n    because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n    2.Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n    to the actual number from 1 to N.\\n    3.For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n    and we need to multiply 2 for each number.\\n    we need to make them as (1, 5, 3).\\n\\t\\n\\t\\n\\t\\nCode:\\n\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1};\\n        }\\n        int even=n/2;\\n        int odd=(n+1)/2;\\n        vector<int>right=beautifulArray(odd);\\n        vector<int>left=beautifulArray(even);\\n\\n        for(int i=0; i<left.size(); i++)\\n        {\\n            left[i]=left[i]*2;\\n        }\\n        for(int i=0; i<right.size(); i++)\\n        {\\n            right[i]=right[i]*2-1;\\n        }\\n\\n        left.insert(left.end(),right.begin(),right.end());\\n\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1}",
                "codeTag": "Java"
            },
            {
                "id": 552796,
                "title": "concise-c-solution",
                "content": "Very concise solution:\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        if (N == 1) return {1};\\n        vector<int> even = beautifulArray(N / 2);\\n        vector<int> odd = beautifulArray(N - N / 2);\\n        vector<int> rtn;\\n        for (int x : even) rtn.push_back(x * 2);\\n        for (int x : odd) rtn.push_back(x * 2 - 1);\\n        return rtn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        if (N == 1) return {1};\\n        vector<int> even = beautifulArray(N / 2);\\n        vector<int> odd = beautifulArray(N - N / 2);\\n        vector<int> rtn;\\n        for (int x : even) rtn.push_back(x * 2);\\n        for (int x : odd) rtn.push_back(x * 2 - 1);\\n        return rtn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368607,
                "title": "java-0-ms-100-00-fast-explained-2-solutions",
                "content": "**# Approach 1** \\uD83D\\uDE80\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.5 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\\n **- Using recursion**\\n\\nTake case of n=4 and n=8\\nfor n=4, we will get [1,3,2,4]\\n- which is derived when there are 2 array of size 2\\n- left = [1,2] and right = [1,2]\\n- we run 1st loop and it fills all even elements to result array\\nso array become [ _ , _ , 2 , 4 ]\\n- because every new element is calculated as right[i-left.length] * 2\\n- we run 2nd loop and it fills all odd elements to result array\\nso array become [ 1 , 3 , 2 , 4 ]\\n- because every new element is calculated as left[i] * 2 - 1\\n\\nnow if we observe the array it follows the key principle of magic array i.e.\\nAn array nums of length n is beautiful if:\\n- nums is a permutation of the integers in the range [1, n].\\n- For every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j]\\n\\nfor n=8, we will get [1,5,3,7,2,6,4,8]\\n- this is because 2 subarray were left==right==[1,3,2,4]\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       int[] answer = new int[n]; \\n        if(n == 1) {\\n            answer[0] = 1;\\n            return answer;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n\\t\\t\\t\\n            for(int i=left.length; i<n; i++) {      //This loop adds all even elements at end\\n                answer[i] = right[i-left.length] * 2; \\n            }\\n            for(int i=0; i<left.length; i++) {      //This loop adds all odd elements at start\\n                answer[i] = left[i] * 2 - 1;     \\n            }\\n        return answer;\\n    }\\n}\\n```\\n\\n**# Approach 2** \\uD83D\\uDE80\\n```\\n// Runtime: 4 ms, faster than 27.04% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.6 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\\n\\n - **Using loop to calculate next element**\\n\\nIdea is simple ->\\n* generate 2 sub array \\n  1st array calculate  elements as  -> 2 * element-1\\n  2nd array calculate elements as -> 2 * element\\n* add element in arrays only if new element is less than or equal to current length\\n* merge these array\\n\\n```\\n\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> answer=new ArrayList<>();\\n        answer.add(1);\\n        while(answer.size()<n){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n                    for(int element:answer)\\n                        if(2*element-1<=n)\\n                            temp.add(element*2-1);\\n            \\n                    for(int element:answer)\\n                        if(2*element<=n)\\n                            temp.add(element*2);\\n                    \\n\\t\\t\\t\\t\\t//in different loops because we want to maintain order\\n            answer=temp;\\n        }\\n        return answer.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\\n\\n \\nPlease upvote to motivate me \\uD83D\\uDE80\\uD83D\\uDE80\\uD83D\\uDE80",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.5 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       int[] answer = new int[n]; \\n        if(n == 1) {\\n            answer[0] = 1;\\n            return answer;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n\\t\\t\\t\\n            for(int i=left.length; i<n; i++) {      //This loop adds all even elements at end\\n                answer[i] = right[i-left.length] * 2; \\n            }\\n            for(int i=0; i<left.length; i++) {      //This loop adds all odd elements at start\\n                answer[i] = left[i] * 2 - 1;     \\n            }\\n        return answer;\\n    }\\n}\\n```\n```\\n// Runtime: 4 ms, faster than 27.04% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.6 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\n```\\n\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> answer=new ArrayList<>();\\n        answer.add(1);\\n        while(answer.size()<n){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n                    for(int element:answer)\\n                        if(2*element-1<=n)\\n                            temp.add(element*2-1);\\n            \\n                    for(int element:answer)\\n                        if(2*element<=n)\\n                            temp.add(element*2);\\n                    \\n\\t\\t\\t\\t\\t//in different loops because we want to maintain order\\n            answer=temp;\\n        }\\n        return answer.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367966,
                "title": "beautiful-array-cpp-simple-iterative-solution-explained",
                "content": "As per the the question if nums[k] multiply with 2 == nums[i]+nums[j] where i<k<j then the array is not beautiful . so we will use some basic maths now to solve this question .\\nnow as we know that (2 multiply with even number ) == even and also (odd*2) == even. so we can clearly say that in order to achieve desired result we have to make right hand side of following equation odd because left hand side be always even.\\nso in order to do that we will seperate both odd elements and even elements and place odd elements in left side of array and even in right side . hence making array beautiful.\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072005,
                "title": "c-recursion-with-short-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        // Recursion: first, we can put all even numbers on the left, and all odd numbers on the right.\\n        // In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n        // because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n        // Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n        // to the actual number from 1 to N.\\n        // For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n        // and we need to multiply 2 for each number.\\n        // For odd numbers, right[i] = right[i] * 2 - 1. E.g. if N = 5, the right subarray is (1, 3, 2), and \\n        // we need to make them as (1, 5, 3).\\n        if (N == 1)\\n        {\\n            return {1};\\n        }\\n        \\n        int evens = N / 2, odds = (N + 1) / 2;\\n        vector<int> left = beautifulArray(evens);\\n        vector<int> right = beautifulArray(odds);\\n        \\n        for (int i = 0; i < left.size(); ++i)\\n        {\\n            left[i] *= 2;\\n        }\\n        \\n        for (int i = 0; i < right.size(); ++i)\\n        {\\n            right[i] = right[i] * 2 - 1;\\n        }\\n        \\n        left.insert(left.end(), right.begin(), right.end());\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        // Recursion: first, we can put all even numbers on the left, and all odd numbers on the right.\\n        // In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n        // because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n        // Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n        // to the actual number from 1 to N.\\n        // For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n        // and we need to multiply 2 for each number.\\n        // For odd numbers, right[i] = right[i] * 2 - 1. E.g. if N = 5, the right subarray is (1, 3, 2), and \\n        // we need to make them as (1, 5, 3).\\n        if (N == 1)\\n        {\\n            return {1};\\n        }\\n        \\n        int evens = N / 2, odds = (N + 1) / 2;\\n        vector<int> left = beautifulArray(evens);\\n        vector<int> right = beautifulArray(odds);\\n        \\n        for (int i = 0; i < left.size(); ++i)\\n        {\\n            left[i] *= 2;\\n        }\\n        \\n        for (int i = 0; i < right.size(); ++i)\\n        {\\n            right[i] = right[i] * 2 - 1;\\n        }\\n        \\n        left.insert(left.end(), right.begin(), right.end());\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687713,
                "title": "c-solution-beautiful-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        return solve(n);\\n    }\\n    \\n    vector<int> solve(int n){\\n        //base case\\n        if(n==1) {\\n            vector<int> k = {1};\\n            return k;\\n        }\\n        \\n        vector<int> ans = solve(n-1);\\n        vector<int> temp;\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i]-1 <= n) temp.push_back(2*ans[i]-1);\\n        }\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i] <= n) temp.push_back(2*ans[i]);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        return solve(n);\\n    }\\n    \\n    vector<int> solve(int n){\\n        //base case\\n        if(n==1) {\\n            vector<int> k = {1};\\n            return k;\\n        }\\n        \\n        vector<int> ans = solve(n-1);\\n        vector<int> temp;\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i]-1 <= n) temp.push_back(2*ans[i]-1);\\n        }\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i] <= n) temp.push_back(2*ans[i]);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401361,
                "title": "easy-solution-c-without-recursion",
                "content": "the key observation here is we can make beautiful arr from a beautiful arr by multiplying 2i and 2i-1 to all element of arr and taking value which is <=n\\n\\nlet me explain..\\n\\nlets just start with smallest beautiful array \\nwhen n=1\\narr->{1} now this is a beautiful array \\n\\nnow coming on equation 2*arr[k]!=arr[i]+arr[j]\\nif we multiply 2*i on both side equation remain same  //here i is any element of beautiful array\\n->2i*(2*arr[k])!=2i*(arr[i]+arr[j])\\n->this means that if i multiply 2 with all element of array then new array will also be beautiful\\n\\nfor ex:when n=1 arr={1}\\n->now multiplying 2 to every element arr become :{2} you can see that this also a beautiful arr\\n\\nnow again if we multiply (2i-1) to both side the equation remain same \\n->2i-1*(2*nums[k])!=(2i-1)*(nums[i]+nums[j])\\n->this means that if we multiply 2i-1 to arr element than new arr is also beautiful arr\\n\\nfor ex: n=1 arr={1}\\n->now multiply 2i-1 to every element : arr={1} you can see that rhis is beautiful array \\n\\n->now if we concatenate to beautiful arr we get a beautiful arr\\n\\nso concatenating {1}+{2}={1,2} is also a beautiful array \\n->now we got arr of size 2 from 1 \\n->for n=3 we have arr={1,2}\\nmultiply 2 to every element\\narr={2,4} //beautiful\\n\\nmultiply 2*i-1 to every element     // here i is element like when i=2 =2*2-1=3\\narr={1,3}\\n\\nnow add to arr={2,4}+{1,3}={2,4,1,3} //beautiful arr\\nbut here 4>3 so we delete it \\nnow arr become ->{2,1,3} // beautiful arr\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n      vector<int>ans;\\n        ans.push_back(1); //smallest beautiful arr\\n        \\n        int val=2; \\n        while(val<=n)\\n        {\\n            vector<int>temp;\\n            for(int it:ans)\\n                if(2*it-1<=val) //checking the element in bound of arr size\\n                    temp.push_back(2*it-1);\\n            \\n            for(int it:ans)\\n                if(2*it<=val)\\n                    temp.push_back(2*it);\\n            \\n            ans=temp;\\n            val++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n      vector<int>ans;\\n        ans.push_back(1); //smallest beautiful arr\\n        \\n        int val=2; \\n        while(val<=n)\\n        {\\n            vector<int>temp;\\n            for(int it:ans)\\n                if(2*it-1<=val) //checking the element in bound of arr size\\n                    temp.push_back(2*it-1);\\n            \\n            for(int it:ans)\\n                if(2*it<=val)\\n                    temp.push_back(2*it);\\n            \\n            ans=temp;\\n            val++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368108,
                "title": "java-easy-to-understand-even-odd-pattern-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {            \\n        int[] res = new int[n];     //odd,even \\n        if(n == 1) {\\n            res[0] = 1;\\n            return res;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n            //Adding The Even nos.\\n            for(int i=left.length; i<n; i++) {\\n                res[i] = right[i-left.length] * 2; \\n            }\\n            // Adding the  odd nos.\\n            for(int i=0; i<left.length; i++) {\\n                res[i] = left[i] * 2 - 1;     \\n            }\\n        return res;\\n}\\n}\\n```\\n**Please Upvote If You Liked The Soln**",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {            \\n        int[] res = new int[n];     //odd,even \\n        if(n == 1) {\\n            res[0] = 1;\\n            return res;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n            //Adding The Even nos.\\n            for(int i=left.length; i<n; i++) {\\n                res[i] = right[i-left.length] * 2; \\n            }\\n            // Adding the  odd nos.\\n            for(int i=0; i<left.length; i++) {\\n                res[i] = left[i] * 2 - 1;     \\n            }\\n        return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184882,
                "title": "python3-divide-conquer",
                "content": "\\n```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        \\n        def fn(nums): \\n            \"\"\"Return beautiful array by rearraning elements in nums.\"\"\"\\n            if len(nums) <= 1: return nums\\n            return fn(nums[::2]) + fn(nums[1::2])\\n        \\n        return fn(list(range(1, N+1)))\\n```\\n\\nEdited on 7/28/2021\\nAlternative bottom-up implementation\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        ans = [1]\\n        while len(ans) < n: \\n            ans = [2*x-1 for x in ans] + [2*x for x in ans]\\n        return [x for x in ans if x <= n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        \\n        def fn(nums): \\n            \"\"\"Return beautiful array by rearraning elements in nums.\"\"\"\\n            if len(nums) <= 1: return nums\\n            return fn(nums[::2]) + fn(nums[1::2])\\n        \\n        return fn(list(range(1, N+1)))\\n```\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        ans = [1]\\n        while len(ans) < n: \\n            ans = [2*x-1 for x in ans] + [2*x for x in ans]\\n        return [x for x in ans if x <= n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798542,
                "title": "simple-iterative-solution-c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res{1};\\n        if(n==1) return res ; \\n        \\n        while(res.size()<n){\\n            vector<int> tmp;\\n            for(int i  :res){\\n                if(2*i <= n){\\n                    tmp.push_back(2*i);\\n                }\\n            }\\n             for(int i  :res){\\n                if(2*i -1 <= n){\\n                    tmp.push_back(2*i-1);\\n                }\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\ngo through solution and observe output for n = 1,2,3,....\\n```\\nn=1\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1\\nn=2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2 1\\nn=3\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   2 1 3\\nn=4\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4 2 3 1\\nn=5\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 4 2 3 5 1\\nn=6\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4 6 2 3 5 1\\nn=7\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4 6 2 7 3 5 1\\nn=8\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  8 4 6 2 7 3 5 1\\n```\\nstart from 1 an at each step take the previous beautiful array and insrt even elements less than n in the same order as the previous arr by multiplying each element by 2 (insert 2*\\\\i in array )\\nthen add all odd elements into the array by taking previous array (beautiful(n-1)) multipying by 2 and suntract 1 ( insert 2\\\\*n -1 in array if 2\\\\*n-1 <n)\\nif u can\\'t understand read leetcode soln and if u want try generating the above pattern by hand. using  above code.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res{1};\\n        if(n==1) return res ; \\n        \\n        while(res.size()<n){\\n            vector<int> tmp;\\n            for(int i  :res){\\n                if(2*i <= n){\\n                    tmp.push_back(2*i);\\n                }\\n            }\\n             for(int i  :res){\\n                if(2*i -1 <= n){\\n                    tmp.push_back(2*i-1);\\n                }\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nn=1\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1\\nn=2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2 1\\nn=3\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   2 1 3\\nn=4\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4 2 3 1\\nn=5\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 4 2 3 5 1\\nn=6\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4 6 2 3 5 1\\nn=7\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4 6 2 7 3 5 1\\nn=8\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  8 4 6 2 7 3 5 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694087,
                "title": "divide-and-conquer",
                "content": "I would like to walk through my path to the final solution.\\n\\nFirstly I observed that the condition `2 * A[k]` is an even, so naturally I think of splitting the array into 2 parts: odds + evens, then any number in odd part + any number in even part will result in an odd, which will satisfy the condition.\\n\\nThen we need to make sure numbers in each part satisfies the condition as well. Let\\'s take a look at the odd part first. Each number in this array could be denoted using the form `2ni + 1`, where i is the index of this number.\\n\\nWe need to make sure\\n```\\n2ni + 1 + 2nj + 1 != 2 * (2nk + 1), which simplifies to\\ni + j != 2k, where i, j, k are index of each number\\n```\\n\\nWe are seeing this form again :D So we can apply the same strategy as we apply earlier: split the array into 2 parts based on their index, odd index into 1 array and even index into another, and doing this recursively for each array:\\n\\n```\\nfunc split(s []int) []int {\\n    if len(s) <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\t\\n\\todd, even := []int{}, []int{}\\n\\tfor i := 0; i < len(s); i ++ {\\n\\t\\tif i % 2 ==.0 {\\n\\t\\t\\teven = append(even, s[i])\\n\\t\\t} else {\\n\\t\\t\\todd = append(odd, s[i])\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn append(split(odd), split(even)...)\\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\n2ni + 1 + 2nj + 1 != 2 * (2nk + 1), which simplifies to\\ni + j != 2k, where i, j, k are index of each number\\n```\n```\\nfunc split(s []int) []int {\\n    if len(s) <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\t\\n\\todd, even := []int{}, []int{}\\n\\tfor i := 0; i < len(s); i ++ {\\n\\t\\tif i % 2 ==.0 {\\n\\t\\t\\teven = append(even, s[i])\\n\\t\\t} else {\\n\\t\\t\\todd = append(odd, s[i])\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn append(split(odd), split(even)...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186944,
                "title": "python-solution-with-chinese-explanation-showing-my-thinking-process",
                "content": "https://buptwc.github.io/2018/10/28/Leetcode-932-Beautiful-Array/\\nI can\\'t express my thoughts very well in English. Sorry for my poor English.\\nThe final idea is the same as others.\\n```python\\n# 28ms\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        cache = {}\\n        def solve(N):\\n            if N == 1: return [1]\\n            if N in cache: return cache[N]\\n            \\n            even_index = N // 2\\n            odd_index = N - even_index\\n            even = solve(even_index)\\n            odd = solve(odd_index)\\n            even = [2*val for val in even]\\n            odd = [2*val-1 for val in odd]\\n            cache[N] = even + odd\\n            return cache[N]\\n        return solve(N)\\n```",
                "solutionTags": [],
                "code": "```python\\n# 28ms\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        cache = {}\\n        def solve(N):\\n            if N == 1: return [1]\\n            if N in cache: return cache[N]\\n            \\n            even_index = N // 2\\n            odd_index = N - even_index\\n            even = solve(even_index)\\n            odd = solve(odd_index)\\n            even = [2*val for val in even]\\n            odd = [2*val-1 for val in odd]\\n            cache[N] = even + odd\\n            return cache[N]\\n        return solve(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676288,
                "title": "python-easy-solution",
                "content": "```\\ndef beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)\\n\\n\\t\\tfor el in ans: \\n\\t\\t\\tif 2 * el <= n:\\n\\t\\t\\t\\tres.append(el * 2)\\n\\n\\t\\tans = res\\n\\treturn ans\\n\\n# odd ele -> 2 * el - 1\\n# even ele -> 2 * el\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)\\n\\n\\t\\tfor el in ans: \\n\\t\\t\\tif 2 * el <= n:\\n\\t\\t\\t\\tres.append(el * 2)\\n\\n\\t\\tans = res\\n\\treturn ans\\n\\n# odd ele -> 2 * el - 1\\n# even ele -> 2 * el\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1483741,
                "title": "a-simple-solution-c-0ms-o-n-time-o-1-space-explanation",
                "content": "A very simple fast solution  (C++)  O(N) time O(1) space\\n\\nIt generates one specific beautiful array for each N. \\n\\n**The inspiration:**\\nIt comes from the 4 observations\\n\\n1  The binary tree shown naturally sorts 2^N numbers into beautiful arrays.\\n\\n![image](https://assets.leetcode.com/users/images/93eb1233-a128-49d4-927e-b9823dfa2b08_1632560687.4727483.jpeg)\\n\\n\\n2.  The binary is sorting numbers in reverse bit order\\n\\n3.  Every ordered subset of N items in such a 2^M array, where 1 <= N <= M and where elements > N are removed, is also a beautiful array. \\nNote: I have not bothered to prove that, but I tested it up to N = 1000 which is the problem limit. \\n\\n4.  The 1..N array is a specialisation of 0..N\\n\\n**The implementation:**\\nTake a group of  1 - N integers,   say 1,2,3,4,5,6,7,8 ,9\\nCalculate the smallest power of two greater than N, in this case is 16. \\nAll the numbers up to 16 can be represented by 4 bits. \\nReverse the order of the bits of each of the 4 bit numbers, from 1 to 15  \\n\\t1  = 0001   becomes   8  = 1000\\n\\t2  = 0010   becomes   4  = 0100\\n    etc.\\n\\t\\nHere is the conversion of each number from 1 to 15 \\n\\n    Numbers       1  2  3  4  5   6   7  8  9 10 11 12 13 14 15   \\n\\tBit reversed  8 4 12  2 10  6 14  1  9   5 13   3  11  7 15\\n\\t\\nIf you increase the depth of the binary tree to 4 bits, those numbers will be in that order along the bottom. \\n\\nThe 15 values give you a beautiful array for any N from 1 to 15  by selecting the values in order that are <= N.\\nFor example where N = 9  the number <= 9 in order\\n\\t8  4 12  2 10  6 14  1  9   5 13   3 11   7 15. \\n\\t8  4       2       6       1  9   5        3        7\\nThat is a beautiful array for N = 9 \\n\\nNote: The algorithm is O(1) as it doesn\\'t store  the 2^N - 1 array.\\n\\nFrom point 4 above, the 1 to N soultions are a specialisation of 0 to N \\nIf you change the code to work from 0 to N you get\\n[ 0 2 1 ] is beautiful\\n[ 0 2 1 3 ] is beautiful\\n[ 0 4 2 1 3 ] is beautiful\\n[ 0 4 2 1 5 3 ] is beautiful\\n[ 0 4 2 6 1 5 3 ] is beautiful\\n[ 0 4 2 6 1 5 3 7 ] is beautiful\\n[ 0 8 4 2 6 1 5 3 7 ] is beautiful\\n[ 0 8 4 2 6 1 9 5 3 7 ] is beautiful\\n[ 0 8 4 2 10 6 1 9 5 3 7 ] is beautiful\\n[ 0 8 4 2 10 6 1 9 5 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 1 9 5 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 1 9 5 13 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15 ] is beautiful\\n\\n\\n\\nTo calculate where  N  = 1000,  you make the table for 2^10 (1024) and use 10 bit numbers which you reverse in the same way. \\n\\nThe beautifull array it generates for N =1000 array is below (after the code) \\nFrom that you can extract a beautiful array for every N from 1 to 1000 from it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\tvector<int> beautifulArray(int n)\\n\\t\\t{\\t\\t\\t\\n    \\t    int maxbit; // max n is 1000\\n\\t\\t\\tfor (int i = 9; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n & (1 << i)) { maxbit = i;\\tbreak;\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\tint powerOfTwo = (1 << maxbit + 1);\\n\\t    \\tauto array = vector<int>(n); \\n\\t\\t\\tfor (int i = 1, a = 0; i < powerOfTwo; ++i)\\n\\t    \\t{\\n\\t    \\t    int x = invertBits(i, maxbit + 1);\\n\\t    \\t\\tif (x > 0 && x <= n)\\n\\t    \\t\\t{\\n\\t    \\t\\t \\tarray[a++] = x;\\n\\t\\t\\t\\t}\\t    \\t\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\treturn array;\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t    uint16_t invertBits(uint16_t b, int maxbits = 16) {\\n\\t\\t   uint16_t mask = 0b1111111100000000;\\n\\t\\t   b = (b & mask) >> 8 | (b & ~mask) << 8;\\n\\t\\t   mask = 0b1111000011110000;\\n\\t\\t   b = (b & mask) >> 4 | (b & ~mask) << 4;\\n\\t\\t   mask = 0b1100110011001100;\\n\\t\\t   b = (b & mask) >> 2 | (b & ~mask) << 2;\\n\\t\\t   mask = 0b1010101010101010;\\n\\t\\t   b = (b & mask) >> 1 | (b & ~mask) << 1;\\n\\t\\t   return b >> (16 - maxbits);\\n\\t\\t}\\n```\\n\\n\\n\\n```\\nvector<int> beautiful1000 = \\n{ 512, 256, 768, 128, 640, 384, 896, 64, 576, 320, 832, 192, 704, 448,\\n960, 32, 544, 288, 800, 160, 672, 416, 928, 96, 608, 352, 864, 224, \\n736, 480, 992, 16, 528, 272, 784, 144, 656, 400, 912, 80, 592, 336, \\n848, 208, 720, 464, 976, 48, 560, 304, 816, 176, 688, 432, 944, 112, \\n624, 368, 880, 240, 752, 496, 8, 520, 264, 776, 136, 648, 392, 904, \\n72, 584, 328, 840, 200, 712, 456, 968, 40, 552, 296, 808, 168, 680, \\n424, 936, 104, 616, 360, 872, 232, 744, 488, 1000, 24, 536, 280, 792, \\n152, 664, 408, 920, 88, 600, 344, 856, 216, 728, 472, 984, 56, 568, \\n312, 824, 184, 696, 440, 952, 120, 632, 376, 888, 248, 760, 504, 4, \\n516, 260, 772, 132, 644, 388, 900, 68, 580, 324, 836, 196, 708, 452, \\n964, 36, 548, 292, 804, 164, 676, 420, 932, 100, 612, 356, 868, 228, \\n740, 484, 996, 20, 532, 276, 788, 148, 660, 404, 916, 84, 596, 340, \\n852, 212, 724, 468, 980, 52, 564, 308, 820, 180, 692, 436, 948, 116, \\n628, 372, 884, 244, 756, 500, 12, 524, 268, 780, 140, 652, 396, 908, \\n76, 588, 332, 844, 204, 716, 460, 972, 44, 556, 300, 812, 172, 684, \\n428, 940, 108, 620, 364, 876, 236, 748, 492, 28, 540, 284, 796, 156, \\n668, 412, 924, 92, 604, 348, 860, 220, 732, 476, 988, 60, 572, 316, \\n828, 188, 700, 444, 956, 124, 636, 380, 892, 252, 764, 508, 2, 514, \\n258, 770, 130, 642, 386, 898, 66, 578, 322, 834, 194, 706, 450, 962, \\n34, 546, 290, 802, 162, 674, 418, 930, 98, 610, 354, 866, 226, 738, \\n482, 994, 18, 530, 274, 786, 146, 658, 402, 914, 82, 594, 338, 850, \\n210, 722, 466, 978, 50, 562, 306, 818, 178, 690, 434, 946, 114, 626, \\n370, 882, 242, 754, 498, 10, 522, 266, 778, 138, 650, 394, 906, 74, \\n586, 330, 842, 202, 714, 458, 970, 42, 554, 298, 810, 170, 682, 426,\\n938, 106, 618, 362, 874, 234, 746, 490, 26, 538, 282, 794, 154, 666, \\n410, 922, 90, 602, 346, 858, 218, 730, 474, 986, 58, 570, 314, 826, \\n186, 698, 442, 954, 122, 634, 378, 890, 250, 762, 506, 6, 518, 262, \\n774, 134, 646, 390, 902, 70, 582, 326, 838, 198, 710, 454, 966, 38, \\n550, 294, 806, 166, 678, 422, 934, 102, 614, 358, 870, 230, 742, 486, \\n998, 22, 534, 278, 790, 150, 662, 406, 918, 86, 598, 342, 854, 214, \\n726, 470, 982, 54, 566, 310, 822, 182, 694, 438, 950, 118, 630, 374, \\n886, 246, 758, 502, 14, 526, 270, 782, 142, 654, 398, 910, 78, 590, \\n334, 846, 206, 718, 462, 974, 46, 558, 302, 814, 174, 686, 430, 942, \\n110, 622, 366, 878, 238, 750, 494, 30, 542, 286, 798, 158, 670, 414, \\n926, 94, 606, 350, 862, 222, 734, 478, 990, 62, 574, 318, 830, 190, \\n702, 446, 958, 126, 638, 382, 894, 254, 766, 510, 1, 513, 257, 769, \\n129, 641, 385, 897, 65, 577, 321, 833, 193, 705, 449, 961, 33, 545, \\n289, 801, 161, 673, 417, 929, 97, 609, 353, 865, 225, 737, 481, 993, \\n17, 529, 273, 785, 145, 657, 401, 913, 81, 593, 337, 849, 209, 721, \\n465, 977, 49, 561, 305, 817, 177, 689, 433, 945, 113, 625, 369, 881, \\n241, 753, 497, 9, 521, 265, 777, 137, 649, 393, 905, 73, 585, 329, \\n841, 201, 713, 457, 969, 41, 553, 297, 809, 169, 681, 425, 937, 105, \\n617, 361, 873, 233, 745, 489, 25, 537, 281, 793, 153, 665, 409, 921, \\n89, 601, 345, 857, 217, 729, 473, 985, 57, 569, 313, 825, 185, 697, \\n441, 953, 121, 633, 377, 889, 249, 761, 505, 5, 517, 261, 773, 133, \\n645, 389, 901, 69, 581, 325, 837, 197, 709, 453, 965, 37, 549, 293, \\n805, 165, 677, 421, 933, 101, 613, 357, 869, 229, 741, 485, 997, 21, \\n533, 277, 789, 149, 661, 405, 917, 85, 597, 341, 853, 213, 725, 469, \\n981, 53, 565, 309, 821, 181, 693, 437, 949, 117, 629, 373, 885, 245, \\n757, 501, 13, 525, 269, 781, 141, 653, 397, 909, 77, 589, 333, 845, \\n205, 717, 461, 973, 45, 557, 301, 813, 173, 685, 429, 941, 109, 621, \\n365, 877, 237, 749, 493, 29, 541, 285, 797, 157, 669, 413, 925, 93, \\n605, 349, 861, 221, 733, 477, 989, 61, 573, 317, 829, 189, 701, 445, \\n957, 125, 637, 381, 893, 253, 765, 509, 3, 515, 259, 771, 131, 643, \\n387, 899, 67, 579, 323, 835, 195, 707, 451, 963, 35, 547, 291, 803, \\n163, 675, 419, 931, 99, 611, 355, 867, 227, 739, 483, 995, 19, 531, \\n275, 787, 147, 659, 403, 915, 83, 595, 339, 851, 211, 723, 467, 979, \\n51, 563, 307, 819, 179, 691, 435, 947, 115, 627, 371, 883, 243, 755, \\n499, 11, 523, 267, 779, 139, 651, 395, 907, 75, 587, 331, 843, 203, \\n715, 459, 971, 43, 555, 299, 811, 171, 683, 427, 939, 107, 619, 363, \\n875, 235, 747, 491, 27, 539, 283, 795, 155, 667, 411, 923, 91, 603, \\n347, 859, 219, 731, 475, 987, 59, 571, 315, 827, 187, 699, 443, 955, \\n123, 635, 379, 891, 251, 763, 507, 7, 519, 263, 775, 135, 647, 391, \\n903, 71, 583, 327, 839, 199, 711, 455, 967, 39, 551, 295, 807, 167, \\n679, 423, 935, 103, 615, 359, 871, 231, 743, 487, 999, 23, 535, 279, \\n791, 151, 663, 407, 919, 87, 599, 343, 855, 215, 727, 471, 983, 55, \\n567, 311, 823, 183, 695, 439, 951, 119, 631, 375, 887, 247, 759, 503, \\n15, 527, 271, 783, 143, 655, 399, 911, 79, 591, 335, 847, 207, 719, \\n463, 975, 47, 559, 303, 815, 175, 687, 431, 943, 111, 623, 367, 879, \\n239, 751, 495, 31, 543, 287, 799, 159, 671, 415, 927, 95, 607, 351, \\n863, 223, 735, 479, 991, 63, 575, 319, 831, 191, 703, 447, 959, 127, \\n639, 383, 895, 255, 767, 511 }; // beautiful\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\tvector<int> beautifulArray(int n)\\n\\t\\t{\\t\\t\\t\\n    \\t    int maxbit; // max n is 1000\\n\\t\\t\\tfor (int i = 9; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n & (1 << i)) { maxbit = i;\\tbreak;\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\tint powerOfTwo = (1 << maxbit + 1);\\n\\t    \\tauto array = vector<int>(n); \\n\\t\\t\\tfor (int i = 1, a = 0; i < powerOfTwo; ++i)\\n\\t    \\t{\\n\\t    \\t    int x = invertBits(i, maxbit + 1);\\n\\t    \\t\\tif (x > 0 && x <= n)\\n\\t    \\t\\t{\\n\\t    \\t\\t \\tarray[a++] = x;\\n\\t\\t\\t\\t}\\t    \\t\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\treturn array;\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t    uint16_t invertBits(uint16_t b, int maxbits = 16) {\\n\\t\\t   uint16_t mask = 0b1111111100000000;\\n\\t\\t   b = (b & mask) >> 8 | (b & ~mask) << 8;\\n\\t\\t   mask = 0b1111000011110000;\\n\\t\\t   b = (b & mask) >> 4 | (b & ~mask) << 4;\\n\\t\\t   mask = 0b1100110011001100;\\n\\t\\t   b = (b & mask) >> 2 | (b & ~mask) << 2;\\n\\t\\t   mask = 0b1010101010101010;\\n\\t\\t   b = (b & mask) >> 1 | (b & ~mask) << 1;\\n\\t\\t   return b >> (16 - maxbits);\\n\\t\\t}\\n```\n```\\nvector<int> beautiful1000 = \\n{ 512, 256, 768, 128, 640, 384, 896, 64, 576, 320, 832, 192, 704, 448,\\n960, 32, 544, 288, 800, 160, 672, 416, 928, 96, 608, 352, 864, 224, \\n736, 480, 992, 16, 528, 272, 784, 144, 656, 400, 912, 80, 592, 336, \\n848, 208, 720, 464, 976, 48, 560, 304, 816, 176, 688, 432, 944, 112, \\n624, 368, 880, 240, 752, 496, 8, 520, 264, 776, 136, 648, 392, 904, \\n72, 584, 328, 840, 200, 712, 456, 968, 40, 552, 296, 808, 168, 680, \\n424, 936, 104, 616, 360, 872, 232, 744, 488, 1000, 24, 536, 280, 792, \\n152, 664, 408, 920, 88, 600, 344, 856, 216, 728, 472, 984, 56, 568, \\n312, 824, 184, 696, 440, 952, 120, 632, 376, 888, 248, 760, 504, 4, \\n516, 260, 772, 132, 644, 388, 900, 68, 580, 324, 836, 196, 708, 452, \\n964, 36, 548, 292, 804, 164, 676, 420, 932, 100, 612, 356, 868, 228, \\n740, 484, 996, 20, 532, 276, 788, 148, 660, 404, 916, 84, 596, 340, \\n852, 212, 724, 468, 980, 52, 564, 308, 820, 180, 692, 436, 948, 116, \\n628, 372, 884, 244, 756, 500, 12, 524, 268, 780, 140, 652, 396, 908, \\n76, 588, 332, 844, 204, 716, 460, 972, 44, 556, 300, 812, 172, 684, \\n428, 940, 108, 620, 364, 876, 236, 748, 492, 28, 540, 284, 796, 156, \\n668, 412, 924, 92, 604, 348, 860, 220, 732, 476, 988, 60, 572, 316, \\n828, 188, 700, 444, 956, 124, 636, 380, 892, 252, 764, 508, 2, 514, \\n258, 770, 130, 642, 386, 898, 66, 578, 322, 834, 194, 706, 450, 962, \\n34, 546, 290, 802, 162, 674, 418, 930, 98, 610, 354, 866, 226, 738, \\n482, 994, 18, 530, 274, 786, 146, 658, 402, 914, 82, 594, 338, 850, \\n210, 722, 466, 978, 50, 562, 306, 818, 178, 690, 434, 946, 114, 626, \\n370, 882, 242, 754, 498, 10, 522, 266, 778, 138, 650, 394, 906, 74, \\n586, 330, 842, 202, 714, 458, 970, 42, 554, 298, 810, 170, 682, 426,\\n938, 106, 618, 362, 874, 234, 746, 490, 26, 538, 282, 794, 154, 666, \\n410, 922, 90, 602, 346, 858, 218, 730, 474, 986, 58, 570, 314, 826, \\n186, 698, 442, 954, 122, 634, 378, 890, 250, 762, 506, 6, 518, 262, \\n774, 134, 646, 390, 902, 70, 582, 326, 838, 198, 710, 454, 966, 38, \\n550, 294, 806, 166, 678, 422, 934, 102, 614, 358, 870, 230, 742, 486, \\n998, 22, 534, 278, 790, 150, 662, 406, 918, 86, 598, 342, 854, 214, \\n726, 470, 982, 54, 566, 310, 822, 182, 694, 438, 950, 118, 630, 374, \\n886, 246, 758, 502, 14, 526, 270, 782, 142, 654, 398, 910, 78, 590, \\n334, 846, 206, 718, 462, 974, 46, 558, 302, 814, 174, 686, 430, 942, \\n110, 622, 366, 878, 238, 750, 494, 30, 542, 286, 798, 158, 670, 414, \\n926, 94, 606, 350, 862, 222, 734, 478, 990, 62, 574, 318, 830, 190, \\n702, 446, 958, 126, 638, 382, 894, 254, 766, 510, 1, 513, 257, 769, \\n129, 641, 385, 897, 65, 577, 321, 833, 193, 705, 449, 961, 33, 545, \\n289, 801, 161, 673, 417, 929, 97, 609, 353, 865, 225, 737, 481, 993, \\n17, 529, 273, 785, 145, 657, 401, 913, 81, 593, 337, 849, 209, 721, \\n465, 977, 49, 561, 305, 817, 177, 689, 433, 945, 113, 625, 369, 881, \\n241, 753, 497, 9, 521, 265, 777, 137, 649, 393, 905, 73, 585, 329, \\n841, 201, 713, 457, 969, 41, 553, 297, 809, 169, 681, 425, 937, 105, \\n617, 361, 873, 233, 745, 489, 25, 537, 281, 793, 153, 665, 409, 921, \\n89, 601, 345, 857, 217, 729, 473, 985, 57, 569, 313, 825, 185, 697, \\n441, 953, 121, 633, 377, 889, 249, 761, 505, 5, 517, 261, 773, 133, \\n645, 389, 901, 69, 581, 325, 837, 197, 709, 453, 965, 37, 549, 293, \\n805, 165, 677, 421, 933, 101, 613, 357, 869, 229, 741, 485, 997, 21, \\n533, 277, 789, 149, 661, 405, 917, 85, 597, 341, 853, 213, 725, 469, \\n981, 53, 565, 309, 821, 181, 693, 437, 949, 117, 629, 373, 885, 245, \\n757, 501, 13, 525, 269, 781, 141, 653, 397, 909, 77, 589, 333, 845, \\n205, 717, 461, 973, 45, 557, 301, 813, 173, 685, 429, 941, 109, 621, \\n365, 877, 237, 749, 493, 29, 541, 285, 797, 157, 669, 413, 925, 93, \\n605, 349, 861, 221, 733, 477, 989, 61, 573, 317, 829, 189, 701, 445, \\n957, 125, 637, 381, 893, 253, 765, 509, 3, 515, 259, 771, 131, 643, \\n387, 899, 67, 579, 323, 835, 195, 707, 451, 963, 35, 547, 291, 803, \\n163, 675, 419, 931, 99, 611, 355, 867, 227, 739, 483, 995, 19, 531, \\n275, 787, 147, 659, 403, 915, 83, 595, 339, 851, 211, 723, 467, 979, \\n51, 563, 307, 819, 179, 691, 435, 947, 115, 627, 371, 883, 243, 755, \\n499, 11, 523, 267, 779, 139, 651, 395, 907, 75, 587, 331, 843, 203, \\n715, 459, 971, 43, 555, 299, 811, 171, 683, 427, 939, 107, 619, 363, \\n875, 235, 747, 491, 27, 539, 283, 795, 155, 667, 411, 923, 91, 603, \\n347, 859, 219, 731, 475, 987, 59, 571, 315, 827, 187, 699, 443, 955, \\n123, 635, 379, 891, 251, 763, 507, 7, 519, 263, 775, 135, 647, 391, \\n903, 71, 583, 327, 839, 199, 711, 455, 967, 39, 551, 295, 807, 167, \\n679, 423, 935, 103, 615, 359, 871, 231, 743, 487, 999, 23, 535, 279, \\n791, 151, 663, 407, 919, 87, 599, 343, 855, 215, 727, 471, 983, 55, \\n567, 311, 823, 183, 695, 439, 951, 119, 631, 375, 887, 247, 759, 503, \\n15, 527, 271, 783, 143, 655, 399, 911, 79, 591, 335, 847, 207, 719, \\n463, 975, 47, 559, 303, 815, 175, 687, 431, 943, 111, 623, 367, 879, \\n239, 751, 495, 31, 543, 287, 799, 159, 671, 415, 927, 95, 607, 351, \\n863, 223, 735, 479, 991, 63, 575, 319, 831, 191, 703, 447, 959, 127, \\n639, 383, 895, 255, 767, 511 }; // beautiful\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368251,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ff = {1};\\n        int n1 = 2;\\n        while((int)(ff.size()) < n){\\n            vector<int> odd;\\n            vector<int> even;\\n            // compute odd\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) - 1 <= n1){\\n                    odd.push_back(2*(ff[i])-1);  \\n                }\\n            }\\n            // compute even\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) <= n1){\\n                    even.push_back(2*(ff[i]));  \\n                }\\n            }\\n            // add both\\n            ff.clear();\\n            for(auto it : odd){\\n                ff.push_back(it);\\n            }\\n            for(auto it : even){\\n                ff.push_back(it);\\n            }\\n            n1+=1;\\n        }\\n        return ff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ff = {1};\\n        int n1 = 2;\\n        while((int)(ff.size()) < n){\\n            vector<int> odd;\\n            vector<int> even;\\n            // compute odd\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) - 1 <= n1){\\n                    odd.push_back(2*(ff[i])-1);  \\n                }\\n            }\\n            // compute even\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) <= n1){\\n                    even.push_back(2*(ff[i]));  \\n                }\\n            }\\n            // add both\\n            ff.clear();\\n            for(auto it : odd){\\n                ff.push_back(it);\\n            }\\n            for(auto it : even){\\n                ff.push_back(it);\\n            }\\n            n1+=1;\\n        }\\n        return ff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507089,
                "title": "c-6-line-code-100-100",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans = {1};\\n        while (ans.size() < N) {\\n            vector<int> temp;\\n            for (int i : ans) if (i * 2 - 1 <= N) temp.push_back(i * 2 - 1);\\n            for (int i : ans) if (i * 2 <= N) temp.push_back(i * 2);\\n            ans = temp;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans = {1}",
                "codeTag": "Java"
            },
            {
                "id": 3768579,
                "title": "easy-code-for-beginner-with-one-line",
                "content": "# Intuition\\nfirst i done it on 20 lines but now it is one line\\n\\n# Approach\\ndone through simple reccurrsion\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return [1] if n<2 else [i*2-1 for i in self.beautifulArray((n+1)//2)]+[i*2 for i in self.beautifulArray(n//2)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return [1] if n<2 else [i*2-1 for i in self.beautifulArray((n+1)//2)]+[i*2 for i in self.beautifulArray(n//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692187,
                "title": "recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n==1) return {1};\\n        \\n        vector<int> arr = beautifulArray(n-1);\\n\\n        vector<int> res;\\n        for (auto i: arr)\\n            if (2*i - 1 <= n) \\n                res.push_back(2*i-1);\\n\\n        for (auto i: arr)\\n            if (2*i <= n) \\n                res.push_back(2*i);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n==1) return {1};\\n        \\n        vector<int> arr = beautifulArray(n-1);\\n\\n        vector<int> res;\\n        for (auto i: arr)\\n            if (2*i - 1 <= n) \\n                res.push_back(2*i-1);\\n\\n        for (auto i: arr)\\n            if (2*i <= n) \\n                res.push_back(2*i);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826859,
                "title": "beautiful-array",
                "content": "//weird question no logic responded \\n//just you guys have seen the pattern \\n//**even odd type sequence after running few n=5,6,7 etc  you will understand the pattern..**\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        vector<int>ans={1};\\n        while(ans.size()<n)\\n        {\\n            vector<int>temp;\\n            //storing the even values \\n            for(auto x : ans)\\n                if(x*2<=n)\\n                    temp.push_back(x*2);\\n            // storing the odd values\\n            for(auto x : ans)\\n                if(x*2-1<=n)\\n                    temp.push_back(x*2-1);\\n            \\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        vector<int>ans={1}",
                "codeTag": "Java"
            },
            {
                "id": 1506453,
                "title": "c-short-and-simple-explanation",
                "content": "1. If the most left element is even and the most right element is odd, then arr[left] * arr[right] != 2 * arr[i] (it is any number, even or odd, in-between), because expression on the left is always odd and expression on the right is always even.\\n2. Let\\'s think about divide and conquer and get beautiful array for left and right part or array.\\n3. Then make all elements for left part even (multiply all of them to 2 and all elements of right odd (multiply all of them to 2 and substract 1).\\n4. So left and right parts are still beautiful (multiplication and substraction, which we did, will not affect its beauty) and left and right parts become odd and even as well. So concatenation of them will result into beautiful array.\\n\\n```\\nvector<int> beautifulArray(int n) { \\n\\tif (n == 1) return { 1 };\\n\\n\\tauto left = beautifulArray(n / 2);\\n\\tauto right = beautifulArray(n - (n / 2));\\n\\n\\tvector<int> res;\\n\\n\\tfor (auto l : left)\\n\\t\\tres.push_back(l * 2);\\n\\n\\tfor (auto r : right)\\n\\t\\tres.push_back(r * 2 - 1);\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> beautifulArray(int n) { \\n\\tif (n == 1) return { 1 };\\n\\n\\tauto left = beautifulArray(n / 2);\\n\\tauto right = beautifulArray(n - (n / 2));\\n\\n\\tvector<int> res;\\n\\n\\tfor (auto l : left)\\n\\t\\tres.push_back(l * 2);\\n\\n\\tfor (auto r : right)\\n\\t\\tres.push_back(r * 2 - 1);\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369666,
                "title": "python-different-o-n-solution-proof",
                "content": "My solution is completely different from what I\\'ve seen a bunch of other people do. Instead of divide and conquer, I build a sequence using repeated interleaving (the `double()` function below).\\n\\nProving that the interleaving works was pretty tricky to do; however, we can easily test that it works for N <= 1000 by making use of the fact that this code works for N = 1000. As we can see that the way the construction works gives the same output as if we just took the output for N=1000 and deleted the elements of the array that are too large. Since it\\'s fairly easy to see that if you take a beautiful array and delete some elements, then the resulting array is still beautiful.\\n\\nA proof, however, that this works for all N is below.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        # We can partition the array into an odd half \\n        # and an even half. This is because the only way \\n        # 2 * nums[k] == nums[i] + nums[j] \\n        # is if nums[i] and nums[j] are the same parity.\\n        \\n        odds = [1, 3]\\n        evens = [2, 4]\\n        \\n        def double(arr):\\n            ans = []\\n            for i in range(len(arr)):\\n                ans.append(arr[i])\\n                ans.append(arr[i] + len(arr) * 2)\\n            return ans\\n        \\n        while len(odds) + len(evens) < n:\\n            odds = double(odds)\\n            evens = double(evens)\\n        \\n\\t\\t# Deleting elements from an array doesn\\'t change whether it\\'s \\n\\t\\t# still beautiful or not.\\n        odds = [v for v in odds if v <= n]\\n        evens = [v for v in evens if v <= n]\\n        return odds + evens\\n```\\n\\nThe space usage is O(N) and the time is also O(N), but this is a bit harder to see. However, we know that `1/2 + 1/4 + 1/8 + ... = 1`, so the `while`-loop in total only takes O(N) time.\\n\\n# **Proof**\\n\\nWe will only prove that our double operation works for the `odds`. Since the `evens` array is just the `odds` array multiplied by 2 and multiplying every number by 2 doesn\\'t affect the beautifulness of an array. **Note that when I say beautiful, I\\'m only refering to the second property.**\\n\\nAssume we have numbers `1, 3, 5, ..., 2(n - 1) + 1`\\n \\nWe can shuffle them into a sequence:\\n \\n`a_1, a_2, ..., a_n`  (sequence 1)\\n \\nRunning `double()` on the above sequence we get:\\n \\n`a_1, a_1 + 2n, a_2, a_2 + 2n, ..., a_n, a_n + 2n` (sequence 2)\\n \\nRunning `double()` a second time we get\\n \\n`a_1, a_1 + 4n, a_1 + 2n, a_1 + 6n, a_2, a_2 + 4n, a_2 + 2n, a_2 + 6n, ..., a_n, a_n + 4n, a_n + 2n, a_n + 6n` (sequence 3)\\n\\n#### Theorem\\n\\nGiven that sequence 1 and 2 are beautiful, we can show that sequence 3 is beautiful too.\\n\\nIf we use [1, 3] and [1, 5, 3, 7] as sequences 1 and 2, respective, then this theorem means that the algorithm works for all N.\\n\\n#### Proof\\nUsing a proof by contraction: Let\\'s assume that sequence 3 isn\\'t beautiful. Then we have,\\n`a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)` where `i <= k <= j`\\n\\nNote that `{0,2,4,6}_i` means that we choose one value from 0, 2, 4 or 6. This is to account for the `+ 0`, `+ 2n`, `+ 4n` and `+ 6n` factors in sequence 3.\\n\\nNow we have 4 cases for `i <= k <= j` to consider.\\n \\n**Case 1**: If `a_i = a_k = a_j`:\\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_i + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + {0,2,4,6}_j*n = 2{0,2,4,6}_k*n\\n```\\n\\nThis is a contradiction as `{0,2,4,6}_i, {0,2,4,6}_k, {0,2,4,6}_j` is some subsequence of [0, 4, 2, 6], but subsequences of beautiful arrays are beautiful.\\n \\n**Case 2**: If `a_i = a_k` and `a_i != a_j`:\\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = a_i + {0,2,4,6}_k*n\\n=> a_j - a_i = {0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n```\\n \\nThe LHS is non-zero as `a_i != a_j`. So the RHS must be non-zero too.\\n \\nThe largest *absolute* (i.e., non-negative) value of the LHS is `(2(n - 1) + 1) - 1 = 2n - 2` as we maximize the difference between `a_j` and `a_i` by choosing the smallest and largest possible values.\\n\\nThe smallest non-zero *absolute* value of the RHS is `2n`.\\n \\nTherefore, the equality can never hold and we have a contradiction as the largest absolute value of the LHS is strictly less than the smallest absolute value of the RHS.\\n \\n**Case 3**: If `a_j = a_k` and `a_i != a_j`:\\nSame as argument as case 2.\\n \\n**Case 4**: if `i < k < j`:\\n```\\n    a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> 2a_k - a_i - a_j = 2{0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n ```\\n \\nThe LHS should be non-zero or sequence 1 would be not beautiful. As `2a_k - a_i - a_j = 0` implies `a_i + a_j  = 2a_k`\\n \\nThe greatest the LHS\\'s absolute value can be is `|1 - (2(n-1) - 1) - (2(n-1) - 3)| = |1 - 2n + 3 - 2n + 5| = 4n - 9`. We maximize this by chosing the 2 largest values (for `a_i` and `a_j`) and the smallest value (for `a_k`).\\nThe absolute value of the RHS is at least `2n`. \\n \\nTherefore, RHS absolute value is `2n` and, thus, either `a_i + a_j = 2a_k + 2n` (case 4a) holds or `a_i + a_j = 2a_k - 2n` (case 4b) holds\\n \\n**Case 4a**: `a_i + a_j = 2a_k + 2n`\\n```\\n   a_i + a_j = 2a_k + 2n\\n=> a_i + a_j + 2n = 2a_k + 4n = 2(a_k + 2n)\\n```\\n\\nHowever, if this is true then sequence 2 isn\\'t beautiful, which is a contradiction. This is because we can use the numbers `a_i` and `a_j + 2n` and `a_k + 2n` in sequence 2 and we know from i < k < j, that `a_k + 2n`  lies between `a_i` and `a_j + 2n`. \\n \\n**Case 4b**: `a_i + a_j = 2a_k - 2n`\\n```\\n   a_i + a_j = 2a_k - 2n\\n=> a_i + a_j + 2n = 2a_k\\n```\\n\\nHowever, if this is true then sequence 2 isn\\'t beautiful. Again, like in case 4a, this is because we can use the numbers `a_i` and `a_j + 2n` and `a_k` in sequence 2.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        # We can partition the array into an odd half \\n        # and an even half. This is because the only way \\n        # 2 * nums[k] == nums[i] + nums[j] \\n        # is if nums[i] and nums[j] are the same parity.\\n        \\n        odds = [1, 3]\\n        evens = [2, 4]\\n        \\n        def double(arr):\\n            ans = []\\n            for i in range(len(arr)):\\n                ans.append(arr[i])\\n                ans.append(arr[i] + len(arr) * 2)\\n            return ans\\n        \\n        while len(odds) + len(evens) < n:\\n            odds = double(odds)\\n            evens = double(evens)\\n        \\n\\t\\t# Deleting elements from an array doesn\\'t change whether it\\'s \\n\\t\\t# still beautiful or not.\\n        odds = [v for v in odds if v <= n]\\n        evens = [v for v in evens if v <= n]\\n        return odds + evens\\n```\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_i + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + {0,2,4,6}_j*n = 2{0,2,4,6}_k*n\\n```\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = a_i + {0,2,4,6}_k*n\\n=> a_j - a_i = {0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n```\n```\\n    a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> 2a_k - a_i - a_j = 2{0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n ```\n```\\n   a_i + a_j = 2a_k + 2n\\n=> a_i + a_j + 2n = 2a_k + 4n = 2(a_k + 2n)\\n```\n```\\n   a_i + a_j = 2a_k - 2n\\n=> a_i + a_j + 2n = 2a_k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368199,
                "title": "python3-recursive-one-liner",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return (\\n            [1, 2][:n]\\n            if n < 3\\n            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]\\n            + [x * 2 for x in self.beautifulArray(n // 2)]\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return (\\n            [1, 2][:n]\\n            if n < 3\\n            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]\\n            + [x * 2 for x in self.beautifulArray(n // 2)]\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367890,
                "title": "932-beautiful-array-python-24ms",
                "content": "```\\nimport functools\\n\\nfdict = {}\\nfdict[1] = [1]\\nfdict[2] = [1,2]\\nfdict[3] = [1,3,2]\\nfdict[4] = [2,1,4,3]\\nfdict[5] = [3,1,2,5,4]\\n\\n@functools.cache\\ndef f(n):\\n    if n < 6:\\n        return fdict[n]\\n    return [2*x-1 for x in f(n//2+n%2)] + [2*x for x in f(n//2)] \\n```\\n\\nNote that an even and odd number always sum to an odd number, which will not interfere with any numbers in between. So we can split the array into [odd numbers, even numbers] which will be beautiful as long as the odd and even sections are individually beautiful. \\n\\nNote that \"beauty\" does not change when numbers are scaled linearly. \\n```(a*i + b) + (a*j + b) = a*(i+j) + 2b ?= a*(2k) + 2b = 2(a*k+b)```\\nFor i+j = 2k, scaled i + scaled j = 2*(scaled k). So the odd and even sections can be made beautiful by using our beautiful array function recursively. \\n\\nThe cache is used to save time when using this function multiple times, and some (more than necessary) base cases are included to aid with the recursion.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nimport functools\\n\\nfdict = {}\\nfdict[1] = [1]\\nfdict[2] = [1,2]\\nfdict[3] = [1,3,2]\\nfdict[4] = [2,1,4,3]\\nfdict[5] = [3,1,2,5,4]\\n\\n@functools.cache\\ndef f(n):\\n    if n < 6:\\n        return fdict[n]\\n    return [2*x-1 for x in f(n//2+n%2)] + [2*x for x in f(n//2)] \\n```\n```(a*i + b) + (a*j + b) = a*(i+j) + 2b ?= a*(2k) + 2b = 2(a*k+b)```",
                "codeTag": "Python3"
            },
            {
                "id": 1004873,
                "title": "simplest-and-fastest-c-code-with-explanation",
                "content": "```\\n//EXPLANATION\\n/*\\nstart with 1 size array called result= [1]\\nwhile(size<=N){\\n    make a temp array for this iteration\\n    PUSH ODD NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1-1)into temp array, temp = {1}\\n    }\\n    PUSH EVEN NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1)into temp array, temp = {1,2}\\n    }\\n    new result array = temp \\n}\\nNEXT ITERATIONS\\n[1,2]=>Enter while loop =>first for loop, push 2*i-1=1(i=1),then 2*i-1=2*2-1=3 =>{1,3}\\n    Enter second while loop => (2*1=2),(2*2=4)={1,3,2,4}\\n[1,3,2,4] => {2*1-1,2*3-1,2*2-1,2*4-1}={1,5,3,7} and even=>{2*1,2*2,2*2,2*4}=>{2,6,4,8}\\n            => {1,5,3,7,2,6,4,8}\\n[1,5,3,7,2,4,6,8]......................and so on\\n\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//EXPLANATION\\n/*\\nstart with 1 size array called result= [1]\\nwhile(size<=N){\\n    make a temp array for this iteration\\n    PUSH ODD NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1-1)into temp array, temp = {1}\\n    }\\n    PUSH EVEN NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1)into temp array, temp = {1,2}\\n    }\\n    new result array = temp \\n}\\nNEXT ITERATIONS\\n[1,2]=>Enter while loop =>first for loop, push 2*i-1=1(i=1),then 2*i-1=2*2-1=3 =>{1,3}\\n    Enter second while loop => (2*1=2),(2*2=4)={1,3,2,4}\\n[1,3,2,4] => {2*1-1,2*3-1,2*2-1,2*4-1}={1,5,3,7} and even=>{2*1,2*2,2*2,2*4}=>{2,6,4,8}\\n            => {1,5,3,7,2,6,4,8}\\n[1,5,3,7,2,4,6,8]......................and so on\\n\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812831,
                "title": "beautiful-array-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233410,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res,v;\\n        for(int i=1;i<=N;i++)v.push_back(i);\\n        helper(res,v);\\n        return res;   \\n    }\\n    void helper(vector<int>&res,vector<int> v)\\n    {\\n        int size=v.size();\\n        if(size==1)res.push_back(v[0]);\\n        else\\n        {\\n            vector<int> odd,even;\\n            for(int i=0;i<size;i++)i%2?odd.push_back(v[i]):even.push_back(v[i]);\\n            helper(res,even);\\n            helper(res,odd);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res,v;\\n        for(int i=1;i<=N;i++)v.push_back(i);\\n        helper(res,v);\\n        return res;   \\n    }\\n    void helper(vector<int>&res,vector<int> v)\\n    {\\n        int size=v.size();\\n        if(size==1)res.push_back(v[0]);\\n        else\\n        {\\n            vector<int> odd,even;\\n            for(int i=0;i<size;i++)i%2?odd.push_back(v[i]):even.push_back(v[i]);\\n            helper(res,even);\\n            helper(res,odd);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186819,
                "title": "short-java-solution",
                "content": "\\nCredit goes to: https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n```\\n    public int[] beautifulArray(int N) {\\n        int[] cache = new int[2*N], ret = new int[N];\\n        cache[0] = 1;\\n        \\n        int l = 1;\\n        while(l < N) {\\n            for(int i = 0; i < l; i++) cache[i] *= 2;\\n            for(int i = l; i < l * 2; i++) cache[i] = cache[i-l] - 1;\\n            l *= 2;\\n        }\\n        \\n        int j = 0;\\n        for(int i = 0; i < l; i++) if(cache[i] <= N) ret[j++] = cache[i];\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] beautifulArray(int N) {\\n        int[] cache = new int[2*N], ret = new int[N];\\n        cache[0] = 1;\\n        \\n        int l = 1;\\n        while(l < N) {\\n            for(int i = 0; i < l; i++) cache[i] *= 2;\\n            for(int i = l; i < l * 2; i++) cache[i] = cache[i-l] - 1;\\n            l *= 2;\\n        }\\n        \\n        int j = 0;\\n        for(int i = 0; i < l; i++) if(cache[i] <= N) ret[j++] = cache[i];\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186724,
                "title": "python-solution",
                "content": "# solution\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        a = list(range(1, N + 1))\\n        return self.r_fun(a)\\n        pass\\n\\n    def r_fun(self, a):\\n        if len(a) <= 1:\\n            return a\\n        odd = [v for idx, v in enumerate(a) if idx % 2 == 1]\\n        even = [v for idx, v, in enumerate(a) if idx % 2 == 0]\\n        odd = self.r_fun(odd)\\n        even = self.r_fun(even)\\n        return odd + even\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        a = list(range(1, N + 1))\\n        return self.r_fun(a)\\n        pass\\n\\n    def r_fun(self, a):\\n        if len(a) <= 1:\\n            return a\\n        odd = [v for idx, v in enumerate(a) if idx % 2 == 1]\\n        even = [v for idx, v, in enumerate(a) if idx % 2 == 0]\\n        odd = self.r_fun(odd)\\n        even = self.r_fun(even)\\n        return odd + even\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521764,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() != n){\\n            vector<int> temp;\\n            for(auto &ele : res) if(ele*2-1<=n) temp.push_back(ele*2-1);\\n            for(auto &ele : res) if(ele*2<=n) temp.push_back(ele*2);\\n            res = temp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res=[1]\\n        while len(res)<n :\\n            odd=[2*i-1 for i in res]\\n            even=[2*i for i in res]\\n            res=odd+even\\n        return [i for i in res if i<=n]\\n```\\n\\n```Java []\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }\\n    public int[] f(int N) {\\n        if (memo.containsKey(N))\\n            return memo.get(N);\\n\\n        int[] ans = new int[N];\\n        if (N == 1) {\\n            ans[0] = 1;\\n        } else {\\n            int t = 0;\\n            for (int x: f((N+1)/2))\\n                ans[t++] = 2*x - 1;\\n            for (int x: f(N/2))\\n                ans[t++] = 2*x;\\n        }\\n        memo.put(N, ans);\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() != n){\\n            vector<int> temp;\\n            for(auto &ele : res) if(ele*2-1<=n) temp.push_back(ele*2-1);\\n            for(auto &ele : res) if(ele*2<=n) temp.push_back(ele*2);\\n            res = temp;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res=[1]\\n        while len(res)<n :\\n            odd=[2*i-1 for i in res]\\n            even=[2*i for i in res]\\n            res=odd+even\\n        return [i for i in res if i<=n]\\n```\n```Java []\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }\\n    public int[] f(int N) {\\n        if (memo.containsKey(N))\\n            return memo.get(N);\\n\\n        int[] ans = new int[N];\\n        if (N == 1) {\\n            ans[0] = 1;\\n        } else {\\n            int t = 0;\\n            for (int x: f((N+1)/2))\\n                ans[t++] = 2*x - 1;\\n            for (int x: f(N/2))\\n                ans[t++] = 2*x;\\n        }\\n        memo.put(N, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259787,
                "title": "c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return {1};\\n        vector<int> ans = {1};\\n\\n        while(ans.size()<n){\\n            vector< int> temp;\\n\\n            for(int it: ans){\\n                if((it*2)-1 <= n) temp.push_back(it*2-1);\\n            }\\n\\n            for(int it: ans){\\n                if((it*2) <= n) temp.push_back(it*2);\\n            }\\n\\n            for(int it: ans){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n\\n            ans = temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return {1};\\n        vector<int> ans = {1};\\n\\n        while(ans.size()<n){\\n            vector< int> temp;\\n\\n            for(int it: ans){\\n                if((it*2)-1 <= n) temp.push_back(it*2-1);\\n            }\\n\\n            for(int it: ans){\\n                if((it*2) <= n) temp.push_back(it*2);\\n            }\\n\\n            for(int it: ans){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n\\n            ans = temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2587160,
                "title": "java-solution-ugly-array-oops-it-s-beautiful-need-help-with-the-time-space-complexity",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(1);\\n\\n        while (list.size() < n) {\\n            List<Integer> temp = new ArrayList<>();\\n\\n            for (int i : list) {\\n                if (2*i -1 <= n) temp.add(2*i - 1);\\n            }\\n\\n            for (int i : list) {\\n                if (2*i <= n) temp.add(2 * i);\\n            }\\n\\n            list = temp;\\n        }\\n\\n        return list.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(1);\\n\\n        while (list.size() < n) {\\n            List<Integer> temp = new ArrayList<>();\\n\\n            for (int i : list) {\\n                if (2*i -1 <= n) temp.add(2*i - 1);\\n            }\\n\\n            for (int i : list) {\\n                if (2*i <= n) temp.add(2 * i);\\n            }\\n\\n            list = temp;\\n        }\\n\\n        return list.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158740,
                "title": "java-understandable-solution",
                "content": "We can see that if we seperate odd and even number then there is no possibility that even numbers will voilate rule with odd number and vice versa. Now we have to arrange even and odd numbers is such a way that they do not voilate rule with themselves. For doing so first let say we have a beautiful array of length n and we want to make n+1 size of array so what we do is first put all odd number that lie within 1 to n+1 and then even(WE can do even then odd also) . Beautiful array has property that if we multiply any number with array then it still remains beautiful or if we add or subtract any number from array then it still remains beautiful. For for only obtaining even number from n size array we do 2* num and for obtaining odd size array we do 2 * n-1 .\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        ans.add(1);\\n        \\n        for(int i=2;i<=n;i++){\\n            ArrayList<Integer>temp=new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e<=n)temp.add(e*2);\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1<=n)temp.add(e*2-1);\\n            }\\n            \\n            ans=temp;\\n        }\\n        \\n        int []arr=new int[n];\\n        int k=0;\\n        for(Integer i:ans){\\n            arr[k++]=i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        ans.add(1);\\n        \\n        for(int i=2;i<=n;i++){\\n            ArrayList<Integer>temp=new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e<=n)temp.add(e*2);\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1<=n)temp.add(e*2-1);\\n            }\\n            \\n            ans=temp;\\n        }\\n        \\n        int []arr=new int[n];\\n        int k=0;\\n        for(Integer i:ans){\\n            arr[k++]=i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891168,
                "title": "c-solution-divide-and-conquer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return vector<int>{1};\\n\\n        int evens = n/2;\\n        int odds = n-evens;\\n        auto oddarr = beautifulArray(odds);\\n        auto evenarr = beautifulArray(evens);\\n        vector<int> ans(n);\\n        int i = 0;\\n        for(int j:oddarr) ans[i++] = 2*(j-1)+1;\\n        for(int j:evenarr) ans[i++] = 2*j;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return vector<int>{1};\\n\\n        int evens = n/2;\\n        int odds = n-evens;\\n        auto oddarr = beautifulArray(odds);\\n        auto evenarr = beautifulArray(evens);\\n        vector<int> ans(n);\\n        int i = 0;\\n        for(int j:oddarr) ans[i++] = 2*(j-1)+1;\\n        for(int j:evenarr) ans[i++] = 2*j;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744094,
                "title": "simple-python-solution-divide-and-conquer",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        \\n        def divide(N):\\n            if N == 1:\\n                return [1]\\n            \\n            odds = divide(N//2 + N%2)\\n            even = divide(N//2)\\n            \\n            return [2*x-1 for x in odds] + [2*x for x in even]\\n        \\n        return divide(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        \\n        def divide(N):\\n            if N == 1:\\n                return [1]\\n            \\n            odds = divide(N//2 + N%2)\\n            even = divide(N//2)\\n            \\n            return [2*x-1 for x in odds] + [2*x for x in even]\\n        \\n        return divide(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590422,
                "title": "c-o-n-2-o-n-100-99-72-beautiful-binary-tree-https-leetcode-com-nduru",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        int a[n*2];\\n        int b[n*2];\\n        a[0] = 0;\\n        int *r =  a;\\n        int *r1 = b;\\n        for(int i = 1; i<=n; i*=2)\\n        {\\n            int *t = r;\\n            r = r1;\\n            r1 = t;\\n            for (int j=0,l=0; j<i; j++,l+=2)\\n            {\\n                r[l] = r1[j];                \\n                r[l+1] = r1[j]+i;\\n                // cout  << \", \" << r[l] << \", \" << r[l+1];\\n            }\\n            // cout << endl;\\n        }\\n        vector<int> ans(n);\\n        for(int i = 1, j = 0; j<n; i++)\\n        {\\n            if (r[i] <= n)\\n                ans[j++] = r[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        int a[n*2];\\n        int b[n*2];\\n        a[0] = 0;\\n        int *r =  a;\\n        int *r1 = b;\\n        for(int i = 1; i<=n; i*=2)\\n        {\\n            int *t = r;\\n            r = r1;\\n            r1 = t;\\n            for (int j=0,l=0; j<i; j++,l+=2)\\n            {\\n                r[l] = r1[j];                \\n                r[l+1] = r1[j]+i;\\n                // cout  << \", \" << r[l] << \", \" << r[l+1];\\n            }\\n            // cout << endl;\\n        }\\n        vector<int> ans(n);\\n        for(int i = 1, j = 0; j<n; i++)\\n        {\\n            if (r[i] <= n)\\n                ans[j++] = r[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369750,
                "title": "c-solution",
                "content": "**Intuition**\\n\\nIf there are two arrays ```A:[A1, A2, ..., An]``` that only has odd numbers and ```B:[B1, B2, ..., Bn]``` that only has even numbers. If we merge them as ```C:[A1, A2, ..., An,B1, B2, ..., Bn]```, then there won\\'t be any number pair ```A[i]``` and ```B[j]```, such that ```A[i] + B[j] = 2 * C[k]```, because ```A[i] + B[j]``` will always be odd, while ```2 * C[k]``` will always be even. This property ensures the first and second parts of ```C``` follow the beautiful array rule. Let\\'s call it Mege property.\\n\\nNow we need to make sure ```A``` and ```B``` themselves are beautiful arrays. We can achieve this by gradually expanding an exisiting beautiful array to get ```A``` and ```B```. If array ```N:[N1, N2, ..., Nn]``` is a beautiful array, then it has below 3 properties:\\n1. Deletion property: After deleting some numbers from ```N```, the new array ```N\\'``` will still be a beautiful array.\\n2. Addition property: ```N\\':[N1+k, N2+k, ..., Nn+k]``` will still be a beautiful array. \\n3. Multiplication property: ```N\\':[N1*k, N2*k, ..., Nn*k]``` will still be a beautiful array. \\n\\nThe three properties together with merge property can be used to expand a beautiful array. For example, ```N:[N1]``` is a beautiful array.\\n\\n* According to propety 2 and 3, ```N\\': [N1 * 2 - 1]``` and ```N\\'\\': [N1 * 2]``` are beautiful arrays.\\n* We can use property 1 to build ```N\\'``` and ```N\\'\\'``` based on the original array ```N```.\\n* Then we merge ```N\\'``` and ```N\\'\\'``` will be a new beautiful array, which double the length of the original array.\\n\\n\\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n     \\n        List<int> res = new List<int>(){1};\\n        \\n        while(res.Count < n)\\n        {\\n            List<int> odd = new List<int>();\\n            List<int> even = new List<int>();\\n            \\n            // expand an existing beautiful array to new beautiful array and double the size \\n            foreach(var num in res)\\n            {\\n                // ensure all the numbers in the new beautiful array still within [1,n]\\n                if(2 * num - 1 <= n)\\n                    odd.Add(2 * num - 1);\\n                \\n                if(2 * num <= n)\\n                    even.Add(2 * num);\\n            }\\n            \\n            // use  merge rule to merge the odd and even arrays. This will double the size of the beautiful array.\\n            odd.AddRange(even);\\n            // update the result\\n            res = odd;\\n        }\\n        \\n        return res.ToArray(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```A:[A1, A2, ..., An]```\n```B:[B1, B2, ..., Bn]```\n```C:[A1, A2, ..., An,B1, B2, ..., Bn]```\n```A[i]```\n```B[j]```\n```A[i] + B[j] = 2 * C[k]```\n```A[i] + B[j]```\n```2 * C[k]```\n```C```\n```A```\n```B```\n```A```\n```B```\n```N:[N1, N2, ..., Nn]```\n```N```\n```N\\'```\n```N\\':[N1+k, N2+k, ..., Nn+k]```\n```N\\':[N1*k, N2*k, ..., Nn*k]```\n```N:[N1]```\n```N\\': [N1 * 2 - 1]```\n```N\\'\\': [N1 * 2]```\n```N\\'```\n```N\\'\\'```\n```N```\n```N\\'```\n```N\\'\\'```\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n     \\n        List<int> res = new List<int>(){1};\\n        \\n        while(res.Count < n)\\n        {\\n            List<int> odd = new List<int>();\\n            List<int> even = new List<int>();\\n            \\n            // expand an existing beautiful array to new beautiful array and double the size \\n            foreach(var num in res)\\n            {\\n                // ensure all the numbers in the new beautiful array still within [1,n]\\n                if(2 * num - 1 <= n)\\n                    odd.Add(2 * num - 1);\\n                \\n                if(2 * num <= n)\\n                    even.Add(2 * num);\\n            }\\n            \\n            // use  merge rule to merge the odd and even arrays. This will double the size of the beautiful array.\\n            odd.AddRange(even);\\n            // update the result\\n            res = odd;\\n        }\\n        \\n        return res.ToArray(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369611,
                "title": "javascript-simple-solution",
                "content": "Thanks to [@lee215](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N))\\n```\\n\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar beautifulArray = function(n) {\\n    let arr = []\\n    arr.push(1)\\n    while(arr.length < n){\\n        let tmp = []\\n        for(const i of arr) if(i*2-1 <= n) tmp.push(i*2-1)\\n        for(const i of arr) if(i*2 <= n) tmp.push(i*2)\\n        arr = tmp\\n    }\\n\\n    \\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar beautifulArray = function(n) {\\n    let arr = []\\n    arr.push(1)\\n    while(arr.length < n){\\n        let tmp = []\\n        for(const i of arr) if(i*2-1 <= n) tmp.push(i*2-1)\\n        for(const i of arr) if(i*2 <= n) tmp.push(i*2)\\n        arr = tmp\\n    }\\n\\n    \\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369602,
                "title": "easy-java-solution-with-1-solved-example",
                "content": "```\\nclass Solution {\\n/*\\n    split the input array into two arrays of alternate numbers,\\n    recurse on those to splitted arrays and combine them\\n            [1,2,3,4,5,6,7]    \\n        [1,3,5, 7]         [2,4,6]\\n      [1, 5]  [3,7]      [2, 6] [4]\\n      [1, 5, 3, 7]       [2, 6, 4]\\n            [1,5,3,7,2,6,4] \\n*/\\n    public int[] beautifulArray(int n) {\\n        int[] arr = new int[n];\\n        for(int i=0; i < n; i++)\\n            arr[i] = i+1;\\n        return beautify(arr);\\n    }\\n    \\n    private int[] beautify(int[] arr){\\n        if(arr.length <= 2)\\n            return arr;\\n        int n = arr.length;\\n        int[] leftArray = new int[(n+1)/2];\\n        int[] rightArray = new int[n/2];\\n        \\n        populateAlternateLeftAndRight(leftArray, rightArray, arr);\\n        \\n        leftArray = beautify(leftArray);\\n        rightArray = beautify(rightArray);\\n        \\n        return concatenate(leftArray, rightArray);\\n    }\\n    \\n    void populateAlternateLeftAndRight(int[] left, int[] right, int[] arr){\\n        for(int i=0; i < arr.length; i++){\\n            if(i % 2 == 0)\\n                left[i/2] = arr[i];\\n            else\\n                right[i/2] = arr[i];\\n        }\\n    }\\n    \\n    int[] concatenate(int[] arr1, int[] arr2){\\n        int[] combinedArr = new int[arr1.length + arr2.length];\\n        copyToArr(arr1, 0, combinedArr);\\n        copyToArr(arr2, arr1.length, combinedArr);\\n        return combinedArr;\\n    }\\n    \\n    void copyToArr(int[] source, int start, int[] target){\\n        for(int i=0; i < source.length; i++)\\n            target[start++] = source[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n/*\\n    split the input array into two arrays of alternate numbers,\\n    recurse on those to splitted arrays and combine them\\n            [1,2,3,4,5,6,7]    \\n        [1,3,5, 7]         [2,4,6]\\n      [1, 5]  [3,7]      [2, 6] [4]\\n      [1, 5, 3, 7]       [2, 6, 4]\\n            [1,5,3,7,2,6,4] \\n*/\\n    public int[] beautifulArray(int n) {\\n        int[] arr = new int[n];\\n        for(int i=0; i < n; i++)\\n            arr[i] = i+1;\\n        return beautify(arr);\\n    }\\n    \\n    private int[] beautify(int[] arr){\\n        if(arr.length <= 2)\\n            return arr;\\n        int n = arr.length;\\n        int[] leftArray = new int[(n+1)/2];\\n        int[] rightArray = new int[n/2];\\n        \\n        populateAlternateLeftAndRight(leftArray, rightArray, arr);\\n        \\n        leftArray = beautify(leftArray);\\n        rightArray = beautify(rightArray);\\n        \\n        return concatenate(leftArray, rightArray);\\n    }\\n    \\n    void populateAlternateLeftAndRight(int[] left, int[] right, int[] arr){\\n        for(int i=0; i < arr.length; i++){\\n            if(i % 2 == 0)\\n                left[i/2] = arr[i];\\n            else\\n                right[i/2] = arr[i];\\n        }\\n    }\\n    \\n    int[] concatenate(int[] arr1, int[] arr2){\\n        int[] combinedArr = new int[arr1.length + arr2.length];\\n        copyToArr(arr1, 0, combinedArr);\\n        copyToArr(arr2, arr1.length, combinedArr);\\n        return combinedArr;\\n    }\\n    \\n    void copyToArr(int[] source, int start, int[] target){\\n        for(int i=0; i < source.length; i++)\\n            target[start++] = source[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369232,
                "title": "c-solution-o-n",
                "content": "Runtime: 4 ms, faster than 74.56% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.1 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n\\n\\n**Note** : Solution taken from other posts\\n\\n```\\nHere we need i<k<j such that A[k] * 2 != A[i] + A[j]\\nNow odd + even => odd which has no Integer when divided and so we can partition array in to 2 part\\nsuch that all odds are at the left half and all even are in the right half. Now odds and even list can mismatch\\nthe given condition also. Observation-\\n1. Beatiful array + c => Beautiful array\\n2. Beautiful array * c=> Beautiful array \\n3. Odd and even partition array can be Beautiful array\\n\\nUsing these properties we can build up the Beautiful array with initial array containing 1 only. \\n1. Add all values as Array A * 2 -1 in to temp which actually all odd values generated from current Beautiful array \\n2. Add all values as Array A * 2  in to temp which actually all even values generated from current Beautiful array \\n\\nHere we first add all odd and then the even values. So the result also stays Beautiful.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        \\n        // initial beatiful array\\n        vector<int>res={1};\\n        \\n        // loop until all N values are generated\\n        while(res.size()<N)\\n        {\\n            vector<int>temp;\\n            \\n            // push all odd values generated from current beautiful array\\n            for(auto &x : res)if(x*2-1 <=N)temp.push_back(x*2-1);\\n            \\n            // push all even values generated from current beautiful array\\n            for(auto &x : res)if(x*2 <=N)temp.push_back(x*2);\\n            \\n            // swap result\\n            res=temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nHere we need i<k<j such that A[k] * 2 != A[i] + A[j]\\nNow odd + even => odd which has no Integer when divided and so we can partition array in to 2 part\\nsuch that all odds are at the left half and all even are in the right half. Now odds and even list can mismatch\\nthe given condition also. Observation-\\n1. Beatiful array + c => Beautiful array\\n2. Beautiful array * c=> Beautiful array \\n3. Odd and even partition array can be Beautiful array\\n\\nUsing these properties we can build up the Beautiful array with initial array containing 1 only. \\n1. Add all values as Array A * 2 -1 in to temp which actually all odd values generated from current Beautiful array \\n2. Add all values as Array A * 2  in to temp which actually all even values generated from current Beautiful array \\n\\nHere we first add all odd and then the even values. So the result also stays Beautiful.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        \\n        // initial beatiful array\\n        vector<int>res={1};\\n        \\n        // loop until all N values are generated\\n        while(res.size()<N)\\n        {\\n            vector<int>temp;\\n            \\n            // push all odd values generated from current beautiful array\\n            for(auto &x : res)if(x*2-1 <=N)temp.push_back(x*2-1);\\n            \\n            // push all even values generated from current beautiful array\\n            for(auto &x : res)if(x*2 <=N)temp.push_back(x*2);\\n            \\n            // swap result\\n            res=temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369183,
                "title": "c-linq-solution",
                "content": "C# LINQ solution inspired by @lee215\\'s Python list comprehension solution.\\n\\n```res``` is doubled in size after each iteration of the ```while``` loop, keeping odd numbers on the left and evens on the right, making the time complexity O(n log n). At the end, any numbers greater than n are pruned.\\n\\nLoop iterations:\\n```\\n[1]\\n[1,2]\\n[1,3,2,4]\\n[1,5,3,7,2,6,4,8]\\n[1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]\\n...\\n```\\n\\n```\\npublic class Solution {\\n    public int [] BeautifulArray(int n) {\\n        List<int> res = new List<int>() {1};\\n        while(res.Count < n) {\\n            var odd = res.Select(a => a * 2 - 1);\\n            var even = res.Select(a => a * 2);\\n            res = odd.Concat(even).ToList();\\n        }\\n        return res.Where(a => a <= n).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```res```\n```while```\n```\\n[1]\\n[1,2]\\n[1,3,2,4]\\n[1,5,3,7,2,6,4,8]\\n[1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]\\n...\\n```\n```\\npublic class Solution {\\n    public int [] BeautifulArray(int n) {\\n        List<int> res = new List<int>() {1};\\n        while(res.Count < n) {\\n            var odd = res.Select(a => a * 2 - 1);\\n            var even = res.Select(a => a * 2);\\n            res = odd.Concat(even).ToList();\\n        }\\n        return res.Where(a => a <= n).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369029,
                "title": "easy-java-solution-pattern-based",
                "content": "This is the most weird question I have seen till now.\\n\\nSomeone found this great pattern to solve this question.\\n\\nFor odd length : **2 * element - 1**\\nFor even length : **2 * element**\\n\\nSo, start with adding with to the list and use the pattern above to create new list until you reach \\'n\\'.\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> list = new ArrayList();\\n        list.add(1);\\n        \\n        while(list.size() < n){\\n            ArrayList<Integer> temp = new ArrayList();\\n            \\n            for(int el : list){\\n                if(2 * el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            \\n            for(int el : list){\\n                if(2 * el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            list = temp;\\n        }\\n        \\n        int[] res = new int[n];\\n        for(int i = 0; i < list.size(); i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> list = new ArrayList();\\n        list.add(1);\\n        \\n        while(list.size() < n){\\n            ArrayList<Integer> temp = new ArrayList();\\n            \\n            for(int el : list){\\n                if(2 * el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            \\n            for(int el : list){\\n                if(2 * el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            list = temp;\\n        }\\n        \\n        int[] res = new int[n];\\n        for(int i = 0; i < list.size(); i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368809,
                "title": "python3",
                "content": "No one can do by own its pattern based and getting logic of pattern is very rare\\n```\\ndef beautifulArray(self, n: int) -> List[int]:\\n        if n==1:return [1]\\n        prev=self.beautifulArray(n-1)\\n        arr=[]\\n        for nums in prev:\\n            if 2*nums-1<=n:\\n                arr.append(2*nums-1)\\n        for nums in prev:\\n            if 2*nums<=n:\\n                arr.append(2*nums)\\n        return arr",
                "solutionTags": [],
                "code": "No one can do by own its pattern based and getting logic of pattern is very rare\\n```\\ndef beautifulArray(self, n: int) -> List[int]:\\n        if n==1:return [1]\\n        prev=self.beautifulArray(n-1)\\n        arr=[]\\n        for nums in prev:\\n            if 2*nums-1<=n:\\n                arr.append(2*nums-1)\\n        for nums in prev:\\n            if 2*nums<=n:\\n                arr.append(2*nums)\\n        return arr",
                "codeTag": "Python3"
            },
            {
                "id": 1368760,
                "title": "simple-java-solution-with-tracing",
                "content": "\\t\\t\\t\\t\\t\\n# Code:\\nclass Solution {\\n\\n    public int[] beautifulArray(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(1);\\n        while(result.size() < n) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for(int i : result) {\\n                if(i * 2 -1 <= n) temp.add(i * 2 - 1);\\n            }\\n            for(int i : result) {\\n                if(i * 2 <= n) temp.add(i * 2);\\n            }\\n            result = temp;\\n        }\\n        return result.stream().mapToInt(i->i).toArray();\\n    }\\n\\n}\\n\\n# Tracing:\\n\\n```\\nThe tracing of the algorithm seems far better than actual explanation.\\n\\nExample :  n = 13\\nresult : [1]\\n\\t\\t\\t\\t\\t\\t\\tresult                                                                temp   \\nsize = 1 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1,2]\\n\\t\\t\\t\\t\\t\\t\\t[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 2 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3,2,4]    \\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 4 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7,2,10,6]    \\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 7 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,513,3,11]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,5,13,3,11,2,10,6,4,12]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize =11 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7,2,10,6,4,12,8]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,3,11,7,2,10,6,4,12,8]\\n\\nsize = 13 < 13 ---X\\nresult = [1,9,5,3,11,7,2,10,6,4,12,8]\\t\\n```\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nThe tracing of the algorithm seems far better than actual explanation.\\n\\nExample :  n = 13\\nresult : [1]\\n\\t\\t\\t\\t\\t\\t\\tresult                                                                temp   \\nsize = 1 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1,2]\\n\\t\\t\\t\\t\\t\\t\\t[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 2 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3,2,4]    \\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 4 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7,2,10,6]    \\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 7 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,513,3,11]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,5,13,3,11,2,10,6,4,12]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize =11 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7,2,10,6,4,12,8]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,3,11,7,2,10,6,4,12,8]\\n\\nsize = 13 < 13 ---X\\nresult = [1,9,5,3,11,7,2,10,6,4,12,8]\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368758,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size() < n){\\n            vector<int>temp;\\n            for(auto i : ans) if(2*i - 1 <= n) temp.push_back(2*i - 1);   //odd numbers\\n            for(auto i : ans) if(2*i <= n) temp.push_back(2*i);   //even numbers\\n            ans = temp;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size() < n){\\n            vector<int>temp;\\n            for(auto i : ans) if(2*i - 1 <= n) temp.push_back(2*i - 1);   //odd numbers\\n            for(auto i : ans) if(2*i <= n) temp.push_back(2*i);   //even numbers\\n            ans = temp;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368755,
                "title": "c-dfs-memo-divide-conquer",
                "content": "Approach 1: DFS+memo, divide conquer [1]\\n Time complexity: O(NlogN)\\n Space complexity: O(NlogN)\\nThe solution is very conter-intuitive. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {        \\n        if(_memo.count(n)) return _memo[n];\\n        vector<int> ans(n);\\n        if(n == 1) ans[0]=1;\\n        else{\\n            int t = 0;\\n            for(int x: beautifulArray((n+1)/2)) ans[t++] = 2* x - 1; // odds\\n            for(int x: beautifulArray(n/2)) ans[t++] = 2* x;  // evens\\n        }\\n        return _memo[n]=ans;        \\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > _memo;\\n};\\n```\\nReference:\\n[1] https://leetcode.com/problems/beautiful-array/solution/",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {        \\n        if(_memo.count(n)) return _memo[n];\\n        vector<int> ans(n);\\n        if(n == 1) ans[0]=1;\\n        else{\\n            int t = 0;\\n            for(int x: beautifulArray((n+1)/2)) ans[t++] = 2* x - 1; // odds\\n            for(int x: beautifulArray(n/2)) ans[t++] = 2* x;  // evens\\n        }\\n        return _memo[n]=ans;        \\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > _memo;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368694,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        //ODD - 2*EL - 1\\n        //EVEN - 2*EL\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        res.add(1);\\n        \\n        while(res.size() < n){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            //odd\\n            for(int el : res){\\n                if(2*el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            //even\\n            for(int el : res){\\n                if(2*el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            res = temp;\\n        }\\n        \\n        int[] result = new int[n];\\n        for(int i = 0; i < n ; i++){\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        //ODD - 2*EL - 1\\n        //EVEN - 2*EL\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        res.add(1);\\n        \\n        while(res.size() < n){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            //odd\\n            for(int el : res){\\n                if(2*el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            //even\\n            for(int el : res){\\n                if(2*el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            res = temp;\\n        }\\n        \\n        int[] result = new int[n];\\n        for(int i = 0; i < n ; i++){\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368571,
                "title": "c-932-beautiful-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1}; \\n        while (ans.size() < n) {\\n            vector<int> tmp; \\n            for (auto& x : ans) if (2*x-1 <= n) tmp.push_back(2*x-1); \\n            for (auto& x : ans) if (2*x <= n) tmp.push_back(2*x); \\n            ans = tmp; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1}; \\n        while (ans.size() < n) {\\n            vector<int> tmp; \\n            for (auto& x : ans) if (2*x-1 <= n) tmp.push_back(2*x-1); \\n            for (auto& x : ans) if (2*x <= n) tmp.push_back(2*x); \\n            ans = tmp; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368527,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> v = {1};\\n        while(v.size() < n) {\\n            vector<int> temp;\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] - 1 <= n)\\n                    temp.push_back(2*v[i] - 1);\\n            }\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] <= n)\\n                    temp.push_back(2*v[i]);\\n            }\\n            v = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> v = {1};\\n        while(v.size() < n) {\\n            vector<int> temp;\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] - 1 <= n)\\n                    temp.push_back(2*v[i] - 1);\\n            }\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] <= n)\\n                    temp.push_back(2*v[i]);\\n            }\\n            v = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368510,
                "title": "python-o-n-simple",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        dp = [None]*(n+1)\\n        dp[1]= [1]\\n        for i in range(2,n+1):\\n            #considering odd cases and even cases\\n            dp[i]= [(2*j)-1 for j in dp[(i+1)//2]]+ [(2*j) for j in dp[i//2]]\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        dp = [None]*(n+1)\\n        dp[1]= [1]\\n        for i in range(2,n+1):\\n            #considering odd cases and even cases\\n            dp[i]= [(2*j)-1 for j in dp[(i+1)//2]]+ [(2*j) for j in dp[i//2]]\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368149,
                "title": "c-solution-using-dp-memoization",
                "content": "Algorithm:\\n1. total odd numbers:  (N+1) / 2  and N / 2 even numbers.\\n2. store these separatly into map (unordered map)\\n3. Add them. store them into dp array; (memoization)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        unordered_map<int, vector<int>> dp;\\n        if (dp.find(n) != dp.end()){\\n            return dp[n];\\n        }\\n            \\n        vector<int> result(n);\\n        if (n == 1) {\\n            result[0] = 1;\\n        } else {\\n            int i = 0;\\n            for (int x: beautifulArray((n+1)/2)){\\n                result[i++] = 2*x - 1;\\n            } \\n                \\n            for (int x: beautifulArray(n/2)){\\n                result[i++] = 2*x;\\n            }\\n        }\\n        dp[n] = result;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        unordered_map<int, vector<int>> dp;\\n        if (dp.find(n) != dp.end()){\\n            return dp[n];\\n        }\\n            \\n        vector<int> result(n);\\n        if (n == 1) {\\n            result[0] = 1;\\n        } else {\\n            int i = 0;\\n            for (int x: beautifulArray((n+1)/2)){\\n                result[i++] = 2*x - 1;\\n            } \\n                \\n            for (int x: beautifulArray(n/2)){\\n                result[i++] = 2*x;\\n            }\\n        }\\n        dp[n] = result;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368040,
                "title": "swift-odd-even-pattern-o-n",
                "content": "Swift solution based on Odd + Even Pattern suggested by lee215\\n\\nhttps://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)\\n\\n```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n        var result: [Int] = [1]\\n        while result.count < n {\\n            var tmp: [Int] = []\\n            for i in result {\\n                if (i * 2 - 1 <= n) {\\n                    tmp.append(i * 2 - 1)\\n                }\\n            }\\n            for i in result {\\n                if (i * 2 <= n) {\\n                    tmp.append(i * 2)\\n                }\\n            }\\n            result = tmp\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n        var result: [Int] = [1]\\n        while result.count < n {\\n            var tmp: [Int] = []\\n            for i in result {\\n                if (i * 2 - 1 <= n) {\\n                    tmp.append(i * 2 - 1)\\n                }\\n            }\\n            for i in result {\\n                if (i * 2 <= n) {\\n                    tmp.append(i * 2)\\n                }\\n            }\\n            result = tmp\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257565,
                "title": "why-my-answer-is-giving-wa",
                "content": "class Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        a=[]\\n        for _ in range(1,n+1):\\n            a.append(_)\\n        for _ in range(len(a)):\\n            if(_%2!=0):\\n                temp=a[_-1]\\n                a[_-1]=a[_]\\n                a[_]=temp\\n        return a\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nmy basic approach is i m swapping the elements present on the odd indecies with their previous elems.\\nthen the array generated by my approach is also a beautiful array!",
                "solutionTags": [],
                "code": "class Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        a=[]\\n        for _ in range(1,n+1):\\n            a.append(_)\\n        for _ in range(len(a)):\\n            if(_%2!=0):\\n                temp=a[_-1]\\n                a[_-1]=a[_]\\n                a[_]=temp\\n        return a\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nmy basic approach is i m swapping the elements present on the odd indecies with their previous elems.\\nthen the array generated by my approach is also a beautiful array!",
                "codeTag": "Java"
            },
            {
                "id": 1172071,
                "title": "java-beats-100-explained-happy-coding-friend",
                "content": "```\\n// example: N = 9\\n// 1. we divide it into two parts: all odds: 1, 3, 5, 7, 9; all evens: 2, 4, 6, 8\\n//    we put all odds before evens, then if A[i] is from odds and A[j] from even, we will already be valid\\n//    So, all our job is to make sure within all odds and all even themselves are valid!\\n// 2. for all odds if a sequence 5 1 3 9 7 is valid, we take each x as (x+1)/2, then we got --> 3 1 2 5 4 is also valid\\n//        which, is a subproblem beautifulArray(5)\\n// 3. for all even if a sequence 4 2 6 8 is valid, we take each x as x/2, then we got --> 2 1 3 4 is also valid\\n//        which, is a subproblem beautifulArray(4)    \\n// thus, we cal solve it recursively!    \\n\\nclass Solution {\\n    public int[] beautifulArray(int N) { // dfs is not available here for N ~ 1000\\n        int[] res = new int[N];\\n        if (N == 1) {\\n            return new int[] {1};\\n        } else if (N == 2) {\\n            return new int[] {1, 2};\\n        } else {\\n            int[] odds = beautifulArray((N + 1) / 2);\\n            int[] even = beautifulArray(N / 2);\\n            for (int i = 0; i < odds.length; i ++) {\\n                res[i] = odds[i] * 2 - 1;\\n            }\\n            for (int j = 0; j < even.length; j ++) {\\n                res[odds.length + j] = even[j] * 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] beautifulArray(int N) { // dfs is not available here for N ~ 1000\\n        int[] res = new int[N];\\n        if (N == 1) {\\n            return new int[] {1}",
                "codeTag": "Java"
            },
            {
                "id": 1148615,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        int[] arr=new int[N];\\n        List<Integer> ls=new ArrayList<>();\\n        ls.add(1);\\n        while(ls.size()<N){\\n            List<Integer> temp=new ArrayList<>();\\n            for(int i:ls){\\n                if(i*2-1<=N)\\n                    temp.add(2*i-1);\\n            }\\n             for(int i:ls){\\n                if(i*2<=N)\\n                    temp.add(2*i);\\n            }\\n             ls=temp;\\n        }\\n       for(int i=0;i<N;i++){\\n           arr[i]=ls.get(i);\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        int[] arr=new int[N];\\n        List<Integer> ls=new ArrayList<>();\\n        ls.add(1);\\n        while(ls.size()<N){\\n            List<Integer> temp=new ArrayList<>();\\n            for(int i:ls){\\n                if(i*2-1<=N)\\n                    temp.add(2*i-1);\\n            }\\n             for(int i:ls){\\n                if(i*2<=N)\\n                    temp.add(2*i);\\n            }\\n             ls=temp;\\n        }\\n       for(int i=0;i<N;i++){\\n           arr[i]=ls.get(i);\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760023,
                "title": "divide-and-conquer-in-python-47-100",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        res = [0] * N\\n        if N==1:\\n            return [1]\\n        if N==2:\\n            return [1,2]\\n        if N%2 == 0:\\n            half = self.beautifulArray(int(N/2))\\n            for i in range(int(N/2)):\\n                res[i] = half[i] * 2-1\\n            for i in range(int(N/2), N):\\n                res[i] = half[i-int(N/2)] * 2\\n        \\n        else:\\n            res[int((N-1)/2)] = N\\n            whole = self.beautifulArray(N-1)\\n            for i in range(int((N-1)/2)):\\n                res[i] = whole[i+int((N-1)/2)]\\n            for i in range(int((N-1)/2),N-1):\\n                res[i+1] = whole[i-int((N-1)/2)]\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        res = [0] * N\\n        if N==1:\\n            return [1]\\n        if N==2:\\n            return [1,2]\\n        if N%2 == 0:\\n            half = self.beautifulArray(int(N/2))\\n            for i in range(int(N/2)):\\n                res[i] = half[i] * 2-1\\n            for i in range(int(N/2), N):\\n                res[i] = half[i-int(N/2)] * 2\\n        \\n        else:\\n            res[int((N-1)/2)] = N\\n            whole = self.beautifulArray(N-1)\\n            for i in range(int((N-1)/2)):\\n                res[i] = whole[i+int((N-1)/2)]\\n            for i in range(int((N-1)/2),N-1):\\n                res[i+1] = whole[i-int((N-1)/2)]\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 656220,
                "title": "python",
                "content": "def beautifulArray(n):\\n\\n    arr = list(range(1, n + 1))\\n    def helper(arr):\\n        if len(arr) < 3:\\n            return arr\\n        even = arr[::2]\\n        odd = arr[1::2]\\n\\n        return helper(even) + helper(odd)\\n    return helper(arr)#pehl call\\n    \\n    \\n\\nn = int(input())\\nk = beautifulArray(n)\\nprint(*k)\\n\\n\\n",
                "solutionTags": [],
                "code": "def beautifulArray(n):\\n\\n    arr = list(range(1, n + 1))\\n    def helper(arr):\\n        if len(arr) < 3:\\n            return arr\\n        even = arr[::2]\\n        odd = arr[1::2]\\n\\n        return helper(even) + helper(odd)\\n    return helper(arr)#pehl call\\n    \\n    \\n\\nn = int(input())\\nk = beautifulArray(n)\\nprint(*k)\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 575240,
                "title": "java-solution-divide-conquer",
                "content": "Idea:\\n 1. We are going to find a arthemetic subsequence free array (example 1 3 5  or 2 6 10) can  not exist\\n2. If we can deal a small subset, let\\'s say the answer for N=3 is [1,3,2], [1,3,2] is arthemetic free. Is that the same for [2,6,4] and [1,5,3]??\\n```\\nclass Solution {\\n    //1 2 3 4 5 as example\\n    Map<Integer,int[]>dp=new HashMap<>();\\n    public int[] beautifulArray(int N) {\\n        if(dp.containsKey(N))return dp.get(N);\\n        int res[]=new int[N];\\n        if(N==1){\\n            res[0]=1;return res;\\n        }\\n        int index=0;\\n        int left[]=beautifulArray((N+1)/2); //dealing 1 2 3=>convert to 1 3 5\\n        int right[]=beautifulArray(N/2);\\n        for(int i:left){\\n            res[index++]=i*2-1;\\n        }\\n        for(int i:right){\\n            res[index++]=i*2;\\n        }\\n        dp.put(N,res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1 2 3 4 5 as example\\n    Map<Integer,int[]>dp=new HashMap<>();\\n    public int[] beautifulArray(int N) {\\n        if(dp.containsKey(N))return dp.get(N);\\n        int res[]=new int[N];\\n        if(N==1){\\n            res[0]=1;return res;\\n        }\\n        int index=0;\\n        int left[]=beautifulArray((N+1)/2); //dealing 1 2 3=>convert to 1 3 5\\n        int right[]=beautifulArray(N/2);\\n        for(int i:left){\\n            res[index++]=i*2-1;\\n        }\\n        for(int i:right){\\n            res[index++]=i*2;\\n        }\\n        dp.put(N,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214185,
                "title": "c-recursion-odd-even",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        fill(N, 0, v);\\n        return v;\\n    }\\n    \\n    void fill(int n, int beg, vector<int>& v)\\n    {\\n        if(n==1)\\n        {\\n            v[beg] = 1;\\n            return;\\n        }\\n       \\n        int n2 = n/2;\\n        fill(n2, beg, v); \\n        for(int i=0;i<n2;i++)\\n            v[beg+i] *= 2;\\n        fill(n-n2, beg+n2, v);\\n        for(int i=0;i<n-n2;i++)\\n            v[beg+n2+i] = v[beg+n2+i]*2-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        fill(N, 0, v);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 199427,
                "title": "c-o-n-recursive-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void bar(vector<int>& v, int strt, int size) {\\n        if (size < 3) return;\\n        \\n        int step  = (v[strt + 1] - v[strt])*2;\\n        int lsize = (size + 1)/2;\\n        int ridx  = strt + lsize;\\n        int rsize = size/2;\\n        \\n        v[ridx] = v[strt + 1];\\n        if (ridx + 1 < strt + size) v[ridx + 1] = v[ridx] + step;\\n        v[strt + 1] = v[strt] + step;\\n        \\n        bar(v, strt, lsize);\\n        bar(v, ridx, rsize);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        v[0] = 1;\\n        v[1] = 2;\\n        bar(v, 0, N);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void bar(vector<int>& v, int strt, int size) {\\n        if (size < 3) return;\\n        \\n        int step  = (v[strt + 1] - v[strt])*2;\\n        int lsize = (size + 1)/2;\\n        int ridx  = strt + lsize;\\n        int rsize = size/2;\\n        \\n        v[ridx] = v[strt + 1];\\n        if (ridx + 1 < strt + size) v[ridx + 1] = v[ridx] + step;\\n        v[strt + 1] = v[strt] + step;\\n        \\n        bar(v, strt, lsize);\\n        bar(v, ridx, rsize);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        v[0] = 1;\\n        v[1] = 2;\\n        bar(v, 0, N);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186786,
                "title": "c-dp-copied-from-someone-else-i-was-wondering-who-was-the-first-guy-hit-this-in-the-interview",
                "content": "credit goes to https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\nimpossible to figure it out in a 45mins interview. fml...\\n\\n```\\n// reference:\\n// https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> dp;\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res;\\n        if (N == 1) {\\n            res.push_back(1);\\n            return res;\\n        }\\n\\n        if (dp.find(N) != dp.end()) {\\n            return dp[N];\\n        }\\n\\n        auto left = beautifulArray(N / 2);\\n        auto right = beautifulArray(N - N / 2);\\n\\n        for (auto num : left) {\\n            res.push_back(2 * num);\\n        }\\n        for (auto num : right) {\\n            res.push_back(2 * num - 1);\\n        }\\n        dp[N] = res;\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// reference:\\n// https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> dp;\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res;\\n        if (N == 1) {\\n            res.push_back(1);\\n            return res;\\n        }\\n\\n        if (dp.find(N) != dp.end()) {\\n            return dp[N];\\n        }\\n\\n        auto left = beautifulArray(N / 2);\\n        auto right = beautifulArray(N - N / 2);\\n\\n        for (auto num : left) {\\n            res.push_back(2 * num);\\n        }\\n        for (auto num : right) {\\n            res.push_back(2 * num - 1);\\n        }\\n        dp[N] = res;\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4101508,
                "title": "python-o-n-solution",
                "content": "In this problem we have n = 1000, which is too big to use dfs/backtracking, so we need to find some pattern. We need to avoid structures like i < k < j with nums[i] + nums[j] = 2 * nums[k], which means that nums[i] and nums[j] has the same parity: they are both odd or even. This lead us to the following idea: let us split all numbers into 2 groups: all odd numbers and then all even numbers.\\n\\n[ odd numbers ] [ even numbers ]\\n\\nThen if i, j, k lies in two different groups, we are OK, we will hever have forbidden pattern. Also, if we look at odd numbers, imagine n = 12, then we have [1, 3, 5, 7, 9, 11] and if we subtract 1 to each number and divide each number by 2 then we have [0, 1, 2, 3, 4, 5]. Note, that is linear transform: when we did this transformation, if we did not have forbidden pattern, we still do not have it! So, what we need to do is to run function recursively for odd and even numbers and concatenate them.\\n\\n\\n\\n# Complexity\\nFrom the first sight, time complexity is O(n log n), because we have recursion C(n) = C(n//2) + C((n+1)//2), which lead to O(n log n). However it can be shown that it is O(n). Imagine case n = 105, then we have 105 -> (52, 53) -> (26, 26, 27, 27) -> (13, 13, 13, 13, 14, 14, 14, 14) and if we use memoisation, no need to solve problem each time for 13, we can do it only once. On each level we will have at most two values in our recursion tree. Space complexity is O(n).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807187,
                "title": "a-memory-efficient-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a single vector only. The erase operation can be expensive.\\nIf we use two vectors, it will be faster.\\n \\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> array{1};\\n        for (int m = 2; m <= n; m++) {     \\n          for (int i = 0; i < m-1; i++) {\\n              int k = array[i];\\n              if (2 * k -1 <= m) \\n                array.push_back(2 * k - 1);\\n          }\\n          for (int i = 0; i < m-1; i++) {\\n              int k = array.front();\\n              array.erase(array.begin());\\n              if (2 * k <= m) \\n                array.push_back(2 * k);\\n          }         \\n        }\\n\\n        return array; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> array{1};\\n        for (int m = 2; m <= n; m++) {     \\n          for (int i = 0; i < m-1; i++) {\\n              int k = array[i];\\n              if (2 * k -1 <= m) \\n                array.push_back(2 * k - 1);\\n          }\\n          for (int i = 0; i < m-1; i++) {\\n              int k = array.front();\\n              array.erase(array.begin());\\n              if (2 * k <= m) \\n                array.push_back(2 * k);\\n          }         \\n        }\\n\\n        return array; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790784,
                "title": "explanation-with-details",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBecause of item 2, there will be no average between the two numbers.\\n\\nThe odd part + even part will satisfy this situation. Because the average of an odd and an even will not be an integer.\\n\\nAnd we want to generate an array. So we may use Partition to solve this. \\n\\nAt first we have a beautiful array [1].\\n\\nWe will use it to generate longer array.\\n\\n2 * BA will also be BA\\n\\n2 * BA - 1 will also be BA\\n\\nSo we can use this to generate longer array.\\n\\nlength: 1 \\u2192 2 \\u2192 4 \\u2192 8\\n\\nwhat about length as 5?\\n\\nDeletion will not change the property of BA.\\n\\nSo we can just discard the element out of 1\\u2192n.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            for(auto& elem : res)\\n            {\\n                if(elem*2 - 1 <= n)\\n                    tmp.push_back(elem * 2 - 1);\\n            }\\n            for(auto & elem: res)\\n            {\\n                if(elem * 2 <= n)\\n                    tmp.push_back(elem * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            for(auto& elem : res)\\n            {\\n                if(elem*2 - 1 <= n)\\n                    tmp.push_back(elem * 2 - 1);\\n            }\\n            for(auto & elem: res)\\n            {\\n                if(elem * 2 <= n)\\n                    tmp.push_back(elem * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788157,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<N){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n           for(int ele : ans){\\n               if(2*ele-1 <= N)\\n               temp.add(ele*2-1);\\n           } \\n           for(int ele : ans){\\n               if(2*ele <= N)\\n               temp.add(ele*2);\\n           }\\n           ans=temp;\\n        }\\n        int[] res = new int[N];\\n        for(int i=0; i<N;i++)\\n        {\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<N){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n           for(int ele : ans){\\n               if(2*ele-1 <= N)\\n               temp.add(ele*2-1);\\n           } \\n           for(int ele : ans){\\n               if(2*ele <= N)\\n               temp.add(ele*2);\\n           }\\n           ans=temp;\\n        }\\n        int[] res = new int[N];\\n        for(int i=0; i<N;i++)\\n        {\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786654,
                "title": "approach-for-this-beautiful-array-1000-mind-blowing-question",
                "content": "# Source: https://youtu.be/7-RZ0Lw6VRg\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Divide and Conquer technique\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int> temp;\\n            for(int el:ans)\\n            {\\n                if(2*el-1<=n)\\n                {\\n                    temp.push_back(2*el-1);\\n                }\\n            }\\n            for(int el:ans)\\n            {\\n                if(2*el<=n)\\n                {\\n                    temp.push_back(2*el);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int> temp;\\n            for(int el:ans)\\n            {\\n                if(2*el-1<=n)\\n                {\\n                    temp.push_back(2*el-1);\\n                }\\n            }\\n            for(int el:ans)\\n            {\\n                if(2*el<=n)\\n                {\\n                    temp.push_back(2*el);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716792,
                "title": "my-solutions",
                "content": "**1. Use the iteration**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    constexpr int range = 2;\\n    vector<int> nums[range];\\n    int previous = 0;\\n    int current = 1;\\n    nums[previous].emplace_back(1);\\n    while (nums[previous].size() < n) {\\n      for (int delta = 0; delta < 2; ++delta) {\\n        for (const int num : nums[previous]) {\\n          nums[current].emplace_back(2 * num - delta);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      nums[current].clear();\\n    }\\n    \\n    if (nums[previous].size() == n) {\\n      return nums[previous];\\n    }\\n\\n    vector<int> ret;\\n    for (const int num : nums[previous]) {\\n      if (num >= 1 && num < n + 1) {\\n        ret.emplace_back(num);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the memorized Top-Down DP**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<vector<int>> memo(n);\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  const vector<int>& dfs(const int n, vector<vector<int>> &memo) {\\n    vector<int> &ret = memo[n - 1];\\n    if (!ret.empty()) {\\n      return ret;\\n    }\\n    \\n    if (n == 1) {\\n      ret.emplace_back(1);\\n      return ret;\\n    }\\n    \\n    const vector<int> &odd = dfs((n + 1) / 2, memo);\\n    const vector<int> &even = dfs(n / 2, memo);\\n    for (const int num : odd) {\\n      ret.emplace_back(2 * num - 1);\\n    }\\n    for (const int num : even) {\\n      ret.emplace_back(2 * num);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**3. Use the Bottom-Up DP**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> subarray_lengths({n});\\n    for (size_t i = 0; i < subarray_lengths.size() && subarray_lengths[i] != 1; ++i) {\\n      if ((subarray_lengths[i] + 1) / 2 != subarray_lengths.back()) {\\n        subarray_lengths.emplace_back((subarray_lengths[i] + 1) / 2);\\n      }\\n      if ((subarray_lengths[i] & 1) == 1) {\\n        // subarray_lengths[i] is odd\\n        subarray_lengths.emplace_back(subarray_lengths[i] / 2);\\n      }\\n    }\\n    \\n    vector<int> dp[n];\\n    dp[0].emplace_back(1);\\n    const int n_subarray_lengths = static_cast<int>(subarray_lengths.size());\\n    for (int i = n_subarray_lengths - 2; i > -1; --i) {\\n      const int subarray_length = subarray_lengths[i];\\n      const vector<int> &odd = dp[(subarray_length + 1) / 2 - 1];\\n      const vector<int> &even = dp[subarray_length / 2 - 1];\\n      for (const int num : odd) {\\n        dp[subarray_length - 1].emplace_back(2 * num - 1);\\n      }\\n      for (const int num : even) {\\n        dp[subarray_length - 1].emplace_back(2 * num);\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n};\\n```\\n**4. Sort the vector according to the binary representation of the element**\\n```\\n/**\\n * let bit(num, i) be `(num >> i) & 0b1`\\n * construct the array `nums` as [1, 2, ..., `n`]\\n * 1. sort the `nums` by `bit(num, 0)`\\n * 2. if `bit(lhs, 0)` == `bit(rhs, 0)`, sort them by `bit(num, 1)`\\n * 3. if `bit(lhs, 0)` == `bit(rhs, 0)` and `bit(lhs, 1)` == `bit(rhs, 1)`,\\n *    sort them by `bit(num, 2)`\\n * ...\\n * until the order of `num1` and `num2` is determined.\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> ret(n);\\n    iota(ret.begin(), ret.end(), 1);\\n    sort(ret.begin(), ret.end(), [](const int lhs, const int rhs) -> bool {\\n      int left = lhs;\\n      int right = rhs;\\n      for (; (left & 0b1) == (right & 0b1); left >>= 1, right >>= 1) {\\n      }\\n      return (left & 0b1) < (right & 0b1);\\n    });\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    constexpr int range = 2;\\n    vector<int> nums[range];\\n    int previous = 0;\\n    int current = 1;\\n    nums[previous].emplace_back(1);\\n    while (nums[previous].size() < n) {\\n      for (int delta = 0; delta < 2; ++delta) {\\n        for (const int num : nums[previous]) {\\n          nums[current].emplace_back(2 * num - delta);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      nums[current].clear();\\n    }\\n    \\n    if (nums[previous].size() == n) {\\n      return nums[previous];\\n    }\\n\\n    vector<int> ret;\\n    for (const int num : nums[previous]) {\\n      if (num >= 1 && num < n + 1) {\\n        ret.emplace_back(num);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<vector<int>> memo(n);\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  const vector<int>& dfs(const int n, vector<vector<int>> &memo) {\\n    vector<int> &ret = memo[n - 1];\\n    if (!ret.empty()) {\\n      return ret;\\n    }\\n    \\n    if (n == 1) {\\n      ret.emplace_back(1);\\n      return ret;\\n    }\\n    \\n    const vector<int> &odd = dfs((n + 1) / 2, memo);\\n    const vector<int> &even = dfs(n / 2, memo);\\n    for (const int num : odd) {\\n      ret.emplace_back(2 * num - 1);\\n    }\\n    for (const int num : even) {\\n      ret.emplace_back(2 * num);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> subarray_lengths({n});\\n    for (size_t i = 0; i < subarray_lengths.size() && subarray_lengths[i] != 1; ++i) {\\n      if ((subarray_lengths[i] + 1) / 2 != subarray_lengths.back()) {\\n        subarray_lengths.emplace_back((subarray_lengths[i] + 1) / 2);\\n      }\\n      if ((subarray_lengths[i] & 1) == 1) {\\n        // subarray_lengths[i] is odd\\n        subarray_lengths.emplace_back(subarray_lengths[i] / 2);\\n      }\\n    }\\n    \\n    vector<int> dp[n];\\n    dp[0].emplace_back(1);\\n    const int n_subarray_lengths = static_cast<int>(subarray_lengths.size());\\n    for (int i = n_subarray_lengths - 2; i > -1; --i) {\\n      const int subarray_length = subarray_lengths[i];\\n      const vector<int> &odd = dp[(subarray_length + 1) / 2 - 1];\\n      const vector<int> &even = dp[subarray_length / 2 - 1];\\n      for (const int num : odd) {\\n        dp[subarray_length - 1].emplace_back(2 * num - 1);\\n      }\\n      for (const int num : even) {\\n        dp[subarray_length - 1].emplace_back(2 * num);\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n};\\n```\n```\\n/**\\n * let bit(num, i) be `(num >> i) & 0b1`\\n * construct the array `nums` as [1, 2, ..., `n`]\\n * 1. sort the `nums` by `bit(num, 0)`\\n * 2. if `bit(lhs, 0)` == `bit(rhs, 0)`, sort them by `bit(num, 1)`\\n * 3. if `bit(lhs, 0)` == `bit(rhs, 0)` and `bit(lhs, 1)` == `bit(rhs, 1)`,\\n *    sort them by `bit(num, 2)`\\n * ...\\n * until the order of `num1` and `num2` is determined.\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> ret(n);\\n    iota(ret.begin(), ret.end(), 1);\\n    sort(ret.begin(), ret.end(), [](const int lhs, const int rhs) -> bool {\\n      int left = lhs;\\n      int right = rhs;\\n      for (; (left & 0b1) == (right & 0b1); left >>= 1, right >>= 1) {\\n      }\\n      return (left & 0b1) < (right & 0b1);\\n    });\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629961,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        n1=[1]\\n        while len(n1)<n:\\n            e=[2*i for i in n1]\\n            o=[2*i-1 for i in n1]\\n            n1=e+o\\n        return [i for i in n1 if i<=n]        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        n1=[1]\\n        while len(n1)<n:\\n            e=[2*i for i in n1]\\n            o=[2*i-1 for i in n1]\\n            n1=e+o\\n        return [i for i in n1 if i<=n]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608130,
                "title": "solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n,0);\\n        int i = 1;\\n        int j = n;\\n        int k =0;\\n        while(i<=j)\\n        {  res[k]=i;\\n           if((k+1)<n)\\n           res[k+1]=j;\\n           k+=2;\\n           j--;\\n           i++;\\n        }\\n         \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n,0);\\n        int i = 1;\\n        int j = n;\\n        int k =0;\\n        while(i<=j)\\n        {  res[k]=i;\\n           if((k+1)<n)\\n           res[k+1]=j;\\n           k+=2;\\n           j--;\\n           i++;\\n        }\\n         \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575996,
                "title": "beats-100-yet-again",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int>v={1};\\n        while(v.size()<n){\\n            vector<int>ans;\\n            for(int it:v){\\n                if((it*2)-1 <= n)\\n                    ans.push_back(it*2-1);\\n            }\\n            for(int it:v){\\n                if((it*2) <= n)\\n                    ans.push_back(it*2);\\n            }\\n            v=ans;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1}",
                "codeTag": "Java"
            },
            {
                "id": 3506180,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        Dictionary<int, int[]> map = new Dictionary<int, int[]>();\\n   \\n        return BeautifulArray(n, map);\\n    }\\n\\n    private int[] BeautifulArray(int n, Dictionary<int, int[]> map) {\\n      if(map.ContainsKey(n)) return map[n];\\n     \\n      int[] ans = new int[n];\\n      if(n == 1) {\\n        ans[0] = 1;\\n      } else {\\n        int i = 0;\\n        foreach(int x in BeautifulArray(n / 2, map)) {\\n          ans[i++] = x * 2;\\n        }\\n\\n        foreach(int x in BeautifulArray((n + 1)/ 2, map)) {\\n          ans[i++] = x * 2 - 1;\\n        }\\n      }\\n      map[n] = ans;\\n     \\n      return ans;\\n     }\\n\\n    public int[] BeautifulArray1(int n) {\\n        List<int> ans = new List<int>() {1};\\n        for(int i = 0; i <= n / 2; i++) {\\n          List<int> temp = new List<int>();\\n          foreach(int num in ans) {\\n            if(num * 2 <= n) temp.Add(num * 2);\\n          }\\n          foreach(int num in ans) {\\n            if(num * 2 - 1 <= n) temp.Add(num * 2 - 1);\\n          }\\n          ans = temp;\\n        }\\n   \\n        return ans.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        Dictionary<int, int[]> map = new Dictionary<int, int[]>();\\n   \\n        return BeautifulArray(n, map);\\n    }\\n\\n    private int[] BeautifulArray(int n, Dictionary<int, int[]> map) {\\n      if(map.ContainsKey(n)) return map[n];\\n     \\n      int[] ans = new int[n];\\n      if(n == 1) {\\n        ans[0] = 1;\\n      } else {\\n        int i = 0;\\n        foreach(int x in BeautifulArray(n / 2, map)) {\\n          ans[i++] = x * 2;\\n        }\\n\\n        foreach(int x in BeautifulArray((n + 1)/ 2, map)) {\\n          ans[i++] = x * 2 - 1;\\n        }\\n      }\\n      map[n] = ans;\\n     \\n      return ans;\\n     }\\n\\n    public int[] BeautifulArray1(int n) {\\n        List<int> ans = new List<int>() {1};\\n        for(int i = 0; i <= n / 2; i++) {\\n          List<int> temp = new List<int>();\\n          foreach(int num in ans) {\\n            if(num * 2 <= n) temp.Add(num * 2);\\n          }\\n          foreach(int num in ans) {\\n            if(num * 2 - 1 <= n) temp.Add(num * 2 - 1);\\n          }\\n          ans = temp;\\n        }\\n   \\n        return ans.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365948,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n      vector<int>ans;\\n      ans.push_back(1);\\n      while(ans.size()!=n) \\n      {\\n          vector<int>temp;\\n          for (auto it: ans)\\n          {\\n              if (it*2-1<=n)\\n              temp.push_back(it*2-1);\\n          }\\n          for (auto it: ans)\\n          {\\n           if(it*2<=n)\\n           temp.push_back(it*2);\\n          }\\n          ans=temp;\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n      vector<int>ans;\\n      ans.push_back(1);\\n      while(ans.size()!=n) \\n      {\\n          vector<int>temp;\\n          for (auto it: ans)\\n          {\\n              if (it*2-1<=n)\\n              temp.push_back(it*2-1);\\n          }\\n          for (auto it: ans)\\n          {\\n           if(it*2<=n)\\n           temp.push_back(it*2);\\n          }\\n          ans=temp;\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364210,
                "title": "jaa-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       List<Integer>ls=new ArrayList<>();\\n       ls.add(1);\\n       for(int i=0;i<n;i++)\\n       {\\n           ArrayList<Integer>temp=new ArrayList<>();\\n           for(int val:ls)\\n           {\\n               if(2*val<=n)temp.add(2*val);\\n               \\n           }\\n           for(int val:ls)\\n           {\\n               if(2*val-1<=n) temp.add(2*val-1);\\n           }\\n           ls=temp;\\n       } \\n       int[] ans=new int[n];\\n       int k=0;\\n       for(int i:ls)\\n       {\\n           ans[k++]=i;\\n       }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       List<Integer>ls=new ArrayList<>();\\n       ls.add(1);\\n       for(int i=0;i<n;i++)\\n       {\\n           ArrayList<Integer>temp=new ArrayList<>();\\n           for(int val:ls)\\n           {\\n               if(2*val<=n)temp.add(2*val);\\n               \\n           }\\n           for(int val:ls)\\n           {\\n               if(2*val-1<=n) temp.add(2*val-1);\\n           }\\n           ls=temp;\\n       } \\n       int[] ans=new int[n];\\n       int k=0;\\n       for(int i:ls)\\n       {\\n           ans[k++]=i;\\n       }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281644,
                "title": "simple-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmain logic is : odd = 2(element) - 1 || even = 2*(element)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple Iterative approach..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        for(int i=2; i<=n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e <= n){\\n                    temp.add(e*2);\\n                }\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1 <= n){\\n                    temp.add(e*2-1);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        int[] arr = new int[ans.size()];\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        for(int i=2; i<=n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e <= n){\\n                    temp.add(e*2);\\n                }\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1 <= n){\\n                    temp.add(e*2-1);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        int[] arr = new int[ans.size()];\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196915,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n\\n        let s = n / 2 + n % 2\\n        var o = [1]\\n        var d = 1\\n        var m = 0\\n        var j = 0\\n\\n        while o.count < s {\\n\\n            var i = 0\\n            d *= 2\\n            \\n            while o.count < s, i < o.count {\\n                if o[i] + d > n {\\n                    i += 1\\n                }\\n                else {\\n                    o.insert(o[i] + d, at: i + 1)\\n\\n                    if o[i] + d > m {\\n                        m = o[i] + d\\n                        j = i + 1\\n                    }\\n\\n                    i += 2\\n                }\\n            }\\n        }\\n\\n        var e = o.map { $0 + 1 }\\n        if n % 2 == 1 { e.remove(at: j) }\\n\\n        return o + e\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n\\n        let s = n / 2 + n % 2\\n        var o = [1]\\n        var d = 1\\n        var m = 0\\n        var j = 0\\n\\n        while o.count < s {\\n\\n            var i = 0\\n            d *= 2\\n            \\n            while o.count < s, i < o.count {\\n                if o[i] + d > n {\\n                    i += 1\\n                }\\n                else {\\n                    o.insert(o[i] + d, at: i + 1)\\n\\n                    if o[i] + d > m {\\n                        m = o[i] + d\\n                        j = i + 1\\n                    }\\n\\n                    i += 2\\n                }\\n            }\\n        }\\n\\n        var e = o.map { $0 + 1 }\\n        if n % 2 == 1 { e.remove(at: j) }\\n\\n        return o + e\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184256,
                "title": "c-solution-hashmap",
                "content": "# Code\\n```\\nint * bild_array(int n, int **ans_per_n){\\n    if (ans_per_n[n] != NULL){\\n        return ans_per_n[n];\\n    }\\n\\n    int* ans =(int*)malloc(sizeof(int)*n);\\n    if (n == 1){\\n        ans[0] = 1;\\n    } else{\\n        int j = 0;\\n        int * odds = bild_array((n+1)/2,ans_per_n);\\n        for (int x = 0; x < (n+1)/2; x++){\\n            ans[x] = 2*odds[x] - 1;\\n        }\\n        \\n        int * evens = bild_array(n/2,ans_per_n);\\n        for (int y = 0; y < n/2; y++){\\n            ans[((n+1)/2)+y] = 2*evens[y];\\n        }\\n    }\\n    ans_per_n[n] = ans;\\n    return ans;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }\\n    if (n == 2){\\n        sol[0] = 1;\\n        sol[1] = 2;\\n        return sol;\\n    }\\n\\n    // create array in this way: -odds-evens-\\n    int ** ans_per_n = (int**)malloc(sizeof(int*)*(n+1));\\n    for (int i = 0; i < n + 1; i++){\\n        ans_per_n[i] = NULL;\\n    }\\n    \\n    sol = bild_array(n,ans_per_n); \\n    *returnSize = n;\\n\\n\\n    // free\\n    for (int i = 0; i < n; i++){\\n        if (ans_per_n[i] != NULL){\\n            free(ans_per_n[i]);\\n        }\\n    }\\n    free(ans_per_n);\\n\\n    return sol;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint * bild_array(int n, int **ans_per_n){\\n    if (ans_per_n[n] != NULL){\\n        return ans_per_n[n];\\n    }\\n\\n    int* ans =(int*)malloc(sizeof(int)*n);\\n    if (n == 1){\\n        ans[0] = 1;\\n    } else{\\n        int j = 0;\\n        int * odds = bild_array((n+1)/2,ans_per_n);\\n        for (int x = 0; x < (n+1)/2; x++){\\n            ans[x] = 2*odds[x] - 1;\\n        }\\n        \\n        int * evens = bild_array(n/2,ans_per_n);\\n        for (int y = 0; y < n/2; y++){\\n            ans[((n+1)/2)+y] = 2*evens[y];\\n        }\\n    }\\n    ans_per_n[n] = ans;\\n    return ans;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }\\n    if (n == 2){\\n        sol[0] = 1;\\n        sol[1] = 2;\\n        return sol;\\n    }\\n\\n    // create array in this way: -odds-evens-\\n    int ** ans_per_n = (int**)malloc(sizeof(int*)*(n+1));\\n    for (int i = 0; i < n + 1; i++){\\n        ans_per_n[i] = NULL;\\n    }\\n    \\n    sol = bild_array(n,ans_per_n); \\n    *returnSize = n;\\n\\n\\n    // free\\n    for (int i = 0; i < n; i++){\\n        if (ans_per_n[i] != NULL){\\n            free(ans_per_n[i]);\\n        }\\n    }\\n    free(ans_per_n);\\n\\n    return sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3156812,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n        vector<int> res{1};\\n        \\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            \\n            for(auto &x: res)\\n            {\\n                if(2*x - 1 <= n)\\n                {\\n                    tmp.push_back(2*x-1);\\n                }\\n            }\\n            \\n            for(auto &x: res)\\n            {\\n                if(2*x  <= n)\\n                {\\n                    tmp.push_back(2*x);\\n                }\\n            }\\n            \\n            res = tmp;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n        vector<int> res{1}",
                "codeTag": "Java"
            },
            {
                "id": 3075044,
                "title": "c",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    *returnSize =  n ;\\n    int* ans = malloc(2 * n * sizeof(int) ) ;\\n    ans[0] = 1 ;\\n    if(n == 1){\\n        ans = realloc(ans, n * sizeof(int)) ;\\n        return ans ;\\n    }\\n    int idx = 1 ;\\n    while(idx < n){\\n        for(int i = idx ; i < idx*2; i++){\\n            ans[i] = ans[i-idx] * 2 ;\\n        }\\n        for(int i = 0; i < idx ; i++){\\n            ans[i] = 2 * ans[i] - 1 ;\\n        }\\n        idx *= 2 ;\\n    }\\n    int p = 0 ;\\n    for(int i = 0; i < idx ; i++){\\n        if(ans[i] <= n){\\n            ans[p] = ans[i] ;\\n            p++ ;\\n        }\\n    }\\n    ans = realloc(ans, n * sizeof(int) ) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    *returnSize =  n ;\\n    int* ans = malloc(2 * n * sizeof(int) ) ;\\n    ans[0] = 1 ;\\n    if(n == 1){\\n        ans = realloc(ans, n * sizeof(int)) ;\\n        return ans ;\\n    }\\n    int idx = 1 ;\\n    while(idx < n){\\n        for(int i = idx ; i < idx*2; i++){\\n            ans[i] = ans[i-idx] * 2 ;\\n        }\\n        for(int i = 0; i < idx ; i++){\\n            ans[i] = 2 * ans[i] - 1 ;\\n        }\\n        idx *= 2 ;\\n    }\\n    int p = 0 ;\\n    for(int i = 0; i < idx ; i++){\\n        if(ans[i] <= n){\\n            ans[p] = ans[i] ;\\n            p++ ;\\n        }\\n    }\\n    ans = realloc(ans, n * sizeof(int) ) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946364,
                "title": "c-o-n-time-and-o-1-extra-space",
                "content": "O(N) time and O(1) extra space (not including output array)!\\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1); \\n\\n    // fill in array up to what we can O(N)\\n    // if `n` was always a power of 2 this is all we would need to do\\n    int m;\\n    for (m = 1; 2 * m <= n; m *= 2) {\\n        for (int i = 0; i < m; i++) {\\n            ret[i] = ret[i + m] = ret[i] * 2; // make even and copy\\n            ret[i]--; // odd\\n        }\\n    }\\n    if (m != n) { // `n` is not a power of 2\\n        // one last iterations for the leftovers\\n        m = (n + 1) / 2;\\n        // construct odds on it\\'s own half\\n        for (int i = 0, j = 0; j < m; i++) \\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        \\n        // construct evens from odds\\n        for (int i = m, j = 0; j < m; j++) \\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```\\n\\nTechnically, this can be combined, but then most of logic is not obvious in the code:\\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1);\\n    for (int m = 1; m < n; m *= 2) {\\n        if (m > (n + 1) / 2)\\n            m = (n + 1) / 2;\\n        for (int i = 0, j = 0; j < m; i++) // odds\\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        for (int i = m, j = 0; j < m; j++) // evens\\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1); \\n\\n    // fill in array up to what we can O(N)\\n    // if `n` was always a power of 2 this is all we would need to do\\n    int m;\\n    for (m = 1; 2 * m <= n; m *= 2) {\\n        for (int i = 0; i < m; i++) {\\n            ret[i] = ret[i + m] = ret[i] * 2; // make even and copy\\n            ret[i]--; // odd\\n        }\\n    }\\n    if (m != n) { // `n` is not a power of 2\\n        // one last iterations for the leftovers\\n        m = (n + 1) / 2;\\n        // construct odds on it\\'s own half\\n        for (int i = 0, j = 0; j < m; i++) \\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        \\n        // construct evens from odds\\n        for (int i = m, j = 0; j < m; j++) \\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1);\\n    for (int m = 1; m < n; m *= 2) {\\n        if (m > (n + 1) / 2)\\n            m = (n + 1) / 2;\\n        for (int i = 0, j = 0; j < m; i++) // odds\\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        for (int i = m, j = 0; j < m; j++) // evens\\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927166,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int x : ans){\\n          if(2*x-1<=n)\\n          temp.add(x * 2 -1);\\n         }\\n        for(int x : ans){\\n            if(2*x<=n)\\n            temp.add(x * 2);\\n         }\\n        ans = temp;\\n     }\\n        int res[] = new int[n];\\n        for(int i=0;i<n;i++)\\n           res[i]=ans.get(i);\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int x : ans){\\n          if(2*x-1<=n)\\n          temp.add(x * 2 -1);\\n         }\\n        for(int x : ans){\\n            if(2*x<=n)\\n            temp.add(x * 2);\\n         }\\n        ans = temp;\\n     }\\n        int res[] = new int[n];\\n        for(int i=0;i<n;i++)\\n           res[i]=ans.get(i);\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911566,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> al = new ArrayList<>();\\n        if(n == 1){\\n            return new int[]{1};\\n        }\\n        if(n == 2){\\n            return new int[]{1, 2};\\n        }\\n        al.add(1);\\n        al.add(2);\\n        for(int i = 3; i <= n; i++){\\n            List<Integer> odd = new ArrayList<>();\\n            List<Integer> even = new ArrayList<>();\\n            for(int val : al){\\n                int el = 2 * val - 1;\\n                if(el <= n){\\n                    odd.add(el);\\n                }\\n            }\\n            for(int val : al){\\n                int el = 2 * val;\\n                if(el <= n){\\n                    even.add(el);\\n                }\\n            }\\n            al = new ArrayList<>(odd);\\n            for(int val : even){\\n                al.add(val);\\n            }\\n        }\\n        int [] arr = new int[al.size()];\\n        int i = 0;\\n        for(int val : al){\\n            arr[i++] = val;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> al = new ArrayList<>();\\n        if(n == 1){\\n            return new int[]{1};\\n        }\\n        if(n == 2){\\n            return new int[]{1, 2};\\n        }\\n        al.add(1);\\n        al.add(2);\\n        for(int i = 3; i <= n; i++){\\n            List<Integer> odd = new ArrayList<>();\\n            List<Integer> even = new ArrayList<>();\\n            for(int val : al){\\n                int el = 2 * val - 1;\\n                if(el <= n){\\n                    odd.add(el);\\n                }\\n            }\\n            for(int val : al){\\n                int el = 2 * val;\\n                if(el <= n){\\n                    even.add(el);\\n                }\\n            }\\n            al = new ArrayList<>(odd);\\n            for(int val : even){\\n                al.add(val);\\n            }\\n        }\\n        int [] arr = new int[al.size()];\\n        int i = 0;\\n        for(int val : al){\\n            arr[i++] = val;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909516,
                "title": "python-solution-iteration-divide-and-conquer-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Divide and Conquer\\n- Iteration\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res = [1]\\n        if n==1:\\n            return res \\n\\n        count = 1 \\n        while count<n: \\n            new_list = [2*x for x in res] + [2*x-1 for x in res]  \\n            res = new_list.copy() \\n            count *=2 \\n            new_list.clear() \\n        res_list = list()    \\n        for item in res:  \\n            if item<=n: \\n                res_list += [item]\\n        res.clear() \\n        return res_list \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res = [1]\\n        if n==1:\\n            return res \\n\\n        count = 1 \\n        while count<n: \\n            new_list = [2*x for x in res] + [2*x-1 for x in res]  \\n            res = new_list.copy() \\n            count *=2 \\n            new_list.clear() \\n        res_list = list()    \\n        for item in res:  \\n            if item<=n: \\n                res_list += [item]\\n        res.clear() \\n        return res_list \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723730,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n){\\n          ArrayList<Integer> tmp=new ArrayList<>();\\n          for(int el:ans){\\n              if(2*el-1<=n){\\n                  tmp.add(el*2-1);\\n              }\\n          }\\n              for(int el:ans){\\n                  if(2*el<=n){\\n                      tmp.add(el*2);\\n                  }\\n              }\\n              ans=tmp;\\n        }\\n        int[] res=new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n        }\\n    }\\n             \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n){\\n          ArrayList<Integer> tmp=new ArrayList<>();\\n          for(int el:ans){\\n              if(2*el-1<=n){\\n                  tmp.add(el*2-1);\\n              }\\n          }\\n              for(int el:ans){\\n                  if(2*el<=n){\\n                      tmp.add(el*2);\\n                  }\\n              }\\n              ans=tmp;\\n        }\\n        int[] res=new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n        }\\n    }\\n             \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721557,
                "title": "python-easy-to-understand",
                "content": "class Solution(object):\\n    \\n\\tdef beautifulArray(self, n):\\n       \\n        if n == 1:\\n            return [1]\\n        elif n == 2:\\n            return [1,2]\\n        \\n        even = self.beautifulArray(n // 2)\\n        odd = self.beautifulArray((n + 1)// 2)\\n        even = [2*n for n in even]\\n        odd = [2*n - 1 for n in odd]\\n        \\n        return even + odd\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "class Solution(object):\\n    \\n\\tdef beautifulArray(self, n):\\n       \\n        if n == 1:\\n            return [1]\\n        elif n == 2:\\n            return [1,2]\\n        \\n        even = self.beautifulArray(n // 2)\\n        odd = self.beautifulArray((n + 1)// 2)\\n        even = [2*n for n in even]\\n        odd = [2*n - 1 for n in odd]\\n        \\n        return even + odd\\n",
                "codeTag": "Java"
            },
            {
                "id": 2678256,
                "title": "c-solution-beautiful-array-odd-even-pattern-math",
                "content": "**Using Math - Odd Even Pattern**\\n* Time Complexity - O( N )\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1};\\n        \\n        while(ans.size() < n){\\n            vector<int> temp;\\n            //For ODD values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] - 1 <= n){\\n                    temp.push_back(2*ans[i] - 1);\\n                }\\n            }\\n            //For EVEN Values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] <= n){\\n                    temp.push_back(2*ans[i]);\\n                }\\n            }\\n            \\n            ans = temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1};\\n        \\n        while(ans.size() < n){\\n            vector<int> temp;\\n            //For ODD values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] - 1 <= n){\\n                    temp.push_back(2*ans[i] - 1);\\n                }\\n            }\\n            //For EVEN Values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] <= n){\\n                    temp.push_back(2*ans[i]);\\n                }\\n            }\\n            \\n            ans = temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555059,
                "title": "o-n-time-o-n-space-clear-explanation-three-lines-of-code",
                "content": "![image](https://assets.leetcode.com/users/images/be4bdebb-f990-42fa-a5dc-95b2db2b0912_1662750147.5099263.png)\\n\\n\\n\\tclass Solution:\\n\\t\\t@functools.cache\\n\\t\\tdef beautifulArray(self, n: int) -> List[int]:\\n\\t\\t\\t\"\"\" O(N)TS \"\"\"\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn [1]\\n\\t\\t\\treturn [2 * x - 1 for x in self.beautifulArray((n + 1) // 2)] + [2 * x for x in self.beautifulArray(n // 2)]\\n\\n\\n![image](https://assets.leetcode.com/users/images/eecd513a-c51d-4ff8-ab1a-adb99e7cbc4a_1662750200.8244958.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/be4bdebb-f990-42fa-a5dc-95b2db2b0912_1662750147.5099263.png)\\n\\n\\n\\tclass Solution:\\n\\t\\t@functools.cache\\n\\t\\tdef beautifulArray(self, n: int) -> List[int]:\\n\\t\\t\\t\"\"\" O(N)TS \"\"\"\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn [1]\\n\\t\\t\\treturn [2 * x - 1 for x in self.beautifulArray((n + 1) // 2)] + [2 * x for x in self.beautifulArray(n // 2)]\\n\\n\\n![image](https://assets.leetcode.com/users/images/eecd513a-c51d-4ff8-ab1a-adb99e7cbc4a_1662750200.8244958.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2203813,
                "title": "932-beautiful-array-c-100-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> beautifulArray(int n) {\\n\\n\\t\\t\\tvector<int> v = {1};\\n\\n\\t\\t\\twhile(v.size()<n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> x;\\n\\n\\t\\t\\t\\tfor(auto c:v)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(c*2-1<=n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tx.push_back(c*2-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(auto d:v)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(d*2<=n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tx.push_back(d*2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv=x;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> beautifulArray(int n) {\\n\\n\\t\\t\\tvector<int> v = {1}",
                "codeTag": "Java"
            },
            {
                "id": 2119515,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  (@a ||= [1, [1]])[n] ||= [0, 1].flat_map { |d| beautiful_array((n + d) / 2).map { _1 * 2 - d } }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  (@a ||= [1, [1]])[n] ||= [0, 1].flat_map { |d| beautiful_array((n + d) / 2).map { _1 * 2 - d } }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116653,
                "title": "ts-solution-divide-and-conquer",
                "content": "```\\nfunction beautifulArray(n: number): number[] {\\n        if(n === 1) return [1];\\n        return beautifulArray(Math.floor(n/2) + Math.floor(n%2))\\n            .map((num : number) => 2 * num -1)\\n            .concat(beautifulArray(Math.floor(n/2)).map((num : number) => 2 * num));\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Divide and Conquer"
                ],
                "code": "```\\nfunction beautifulArray(n: number): number[] {\\n        if(n === 1) return [1];\\n        return beautifulArray(Math.floor(n/2) + Math.floor(n%2))\\n            .map((num : number) => 2 * num -1)\\n            .concat(beautifulArray(Math.floor(n/2)).map((num : number) => 2 * num));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084864,
                "title": "c-code-editorial-explanation",
                "content": "The solution provided guarantees the left hand side are odd and right hand side are even numbers. so left and right won\\'t have duplicates.\\nIt is not trivial to say put them together it covers all number between (1...N). But not difficult to prove: left hand-side max = 2*((N+1)/2) - 1 = N if N is odd or N-1 if N is even. right hand side max = 2 * (N/2) = N if N is even, N-1 if N is odd. So max is always N.\\nNow check the beautifiulness:\\n3.1 Both sides by themselves are correct because each side just multiplied by a constant and possibly reduced by 1 from an already correct sequence. That won\\'t impact the beautifulness.\\n3.2 how about a sequence with a mixture of left and right? Well any such sequence would make A[i] + A[j] an odd number, which is impossible to be equal to 2*A[k], an even number.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> f(int n, unordered_map<int, vector<int>> &memo) {\\n      if(memo.count(n) > 0) {\\n        return memo[n];\\n      }\\n      vector<int> res(n, 0);\\n      if(n == 1) {\\n        res[0] = 1;\\n      }else {\\n        int pos = 0;\\n        for(auto &i : f((n+1)/2, memo)) {\\n          res[pos++] = 2*i - 1;\\n        }\\n        for(auto &i : f((n)/2, memo)) {\\n          res[pos++] = 2*i;\\n        }\\n      }\\n      memo[n] = res;\\n      return res;\\n    }\\n    vector<int> beautifulArray(int n) {\\n      unordered_map<int, vector<int>> memo;\\n      return f(n, memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> f(int n, unordered_map<int, vector<int>> &memo) {\\n      if(memo.count(n) > 0) {\\n        return memo[n];\\n      }\\n      vector<int> res(n, 0);\\n      if(n == 1) {\\n        res[0] = 1;\\n      }else {\\n        int pos = 0;\\n        for(auto &i : f((n+1)/2, memo)) {\\n          res[pos++] = 2*i - 1;\\n        }\\n        for(auto &i : f((n)/2, memo)) {\\n          res[pos++] = 2*i;\\n        }\\n      }\\n      memo[n] = res;\\n      return res;\\n    }\\n    vector<int> beautifulArray(int n) {\\n      unordered_map<int, vector<int>> memo;\\n      return f(n, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901472,
                "title": "why-my-output-isn-t-beautiful",
                "content": "Did I understand the question wrong?\\n\\n![image](https://assets.leetcode.com/users/images/755a6dce-7807-48fa-afe8-a1ce1f1abed8_1648758119.037145.png)\\n",
                "solutionTags": [],
                "code": "Did I understand the question wrong?\\n\\n![image](https://assets.leetcode.com/users/images/755a6dce-7807-48fa-afe8-a1ce1f1abed8_1648758119.037145.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1846093,
                "title": "a-novel-solution-that-manually-builds-the-array-o-n-2",
                "content": "```\\ntype Node struct {\\n    val int\\n    pre *Node\\n    next *Node\\n}\\n\\nfunc insertNode(dict *map[int]*Node, hash *map[int]int, head *Node, val int, insert *Node, op int) *Node {\\n    var node *Node = &Node{val:val}\\n    if insert != nil {\\n        if op == 1 {\\n            node.next = insert.next\\n            node.pre = insert\\n            if insert.next != nil {\\n                insert.next.pre = node\\n            }\\n            insert.next = node\\n            (*hash)[val] = (*hash)[insert.val]+1\\n            for tmp := node.next; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n        } else if op == -1 {\\n            node.pre = insert.pre\\n            node.next = insert\\n            if insert.pre != nil {\\n                insert.pre.next = node\\n            }\\n            insert.pre = node\\n            (*hash)[val] = (*hash)[insert.val]\\n            for tmp := insert; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n            if insert == head {\\n                head = node\\n            }\\n        }\\n    }\\n    if len(*dict) == 0 {\\n        (*hash)[val] = 1\\n        head = node\\n    }\\n    \\n    (*dict)[val] = node\\n    return head\\n}\\n\\nfunc beautifulArray(n int) []int {\\n    ij := [][]int{}\\n    for i := 1; i <= n; i++ {\\n        ij = append(ij, []int{})\\n    }\\n    \\n    for i := 1; i <= n; i++ {\\n        for j := i-1; j >= 1; j-- {\\n            if i*2-j > n {\\n                break  \\n            } \\n            ij[j-1] = append(ij[j-1], i*2-j)\\n            ij[i*2-j-1] = append(ij[i*2-j-1], j)\\n        }\\n    }\\n    \\n    var s, t int\\n    if n % 2 == 0 {\\n        t = -1\\n    } else {\\n        t = 1\\n    }\\n    l := (n+1)/2\\n    \\n    var dict = map[int]*Node{}\\n    var hash = map[int]int{}\\n    var head *Node\\n    for l > 0 && l <= n{\\n        var insertAt, op = (*Node)(nil), 1\\n        min, max := 0, n+1\\n        \\n        for _, r := range ij[l-1] {\\n            mid := (l+r)/2\\n            _, ok1 := dict[mid]\\n            _, ok2 := dict[r]\\n            \\n            if ok1 && ok2 {\\n                if hash[r] < hash[mid] {\\n                    if hash[mid] < max {\\n                        max = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], 1\\n                        }\\n                    }\\n                } else {\\n                    if hash[mid] > min {\\n                        min = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], -1\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if len(hash) > 0 && insertAt == nil{\\n            insertAt = dict[head.val]\\n        }\\n        \\n        head = insertNode(&dict, &hash, head, l, insertAt, op)\\n        \\n        t = -t\\n        s += 1\\n        l += t*s\\n    }\\n    \\n    res := []int{}\\n    for head != nil {\\n        res = append(res, head.val)\\n        head = head.next\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Node struct {\\n    val int\\n    pre *Node\\n    next *Node\\n}\\n\\nfunc insertNode(dict *map[int]*Node, hash *map[int]int, head *Node, val int, insert *Node, op int) *Node {\\n    var node *Node = &Node{val:val}\\n    if insert != nil {\\n        if op == 1 {\\n            node.next = insert.next\\n            node.pre = insert\\n            if insert.next != nil {\\n                insert.next.pre = node\\n            }\\n            insert.next = node\\n            (*hash)[val] = (*hash)[insert.val]+1\\n            for tmp := node.next; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n        } else if op == -1 {\\n            node.pre = insert.pre\\n            node.next = insert\\n            if insert.pre != nil {\\n                insert.pre.next = node\\n            }\\n            insert.pre = node\\n            (*hash)[val] = (*hash)[insert.val]\\n            for tmp := insert; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n            if insert == head {\\n                head = node\\n            }\\n        }\\n    }\\n    if len(*dict) == 0 {\\n        (*hash)[val] = 1\\n        head = node\\n    }\\n    \\n    (*dict)[val] = node\\n    return head\\n}\\n\\nfunc beautifulArray(n int) []int {\\n    ij := [][]int{}\\n    for i := 1; i <= n; i++ {\\n        ij = append(ij, []int{})\\n    }\\n    \\n    for i := 1; i <= n; i++ {\\n        for j := i-1; j >= 1; j-- {\\n            if i*2-j > n {\\n                break  \\n            } \\n            ij[j-1] = append(ij[j-1], i*2-j)\\n            ij[i*2-j-1] = append(ij[i*2-j-1], j)\\n        }\\n    }\\n    \\n    var s, t int\\n    if n % 2 == 0 {\\n        t = -1\\n    } else {\\n        t = 1\\n    }\\n    l := (n+1)/2\\n    \\n    var dict = map[int]*Node{}\\n    var hash = map[int]int{}\\n    var head *Node\\n    for l > 0 && l <= n{\\n        var insertAt, op = (*Node)(nil), 1\\n        min, max := 0, n+1\\n        \\n        for _, r := range ij[l-1] {\\n            mid := (l+r)/2\\n            _, ok1 := dict[mid]\\n            _, ok2 := dict[r]\\n            \\n            if ok1 && ok2 {\\n                if hash[r] < hash[mid] {\\n                    if hash[mid] < max {\\n                        max = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], 1\\n                        }\\n                    }\\n                } else {\\n                    if hash[mid] > min {\\n                        min = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], -1\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if len(hash) > 0 && insertAt == nil{\\n            insertAt = dict[head.val]\\n        }\\n        \\n        head = insertNode(&dict, &hash, head, l, insertAt, op)\\n        \\n        t = -t\\n        s += 1\\n        l += t*s\\n    }\\n    \\n    res := []int{}\\n    for head != nil {\\n        res = append(res, head.val)\\n        head = head.next\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727328,
                "title": "java-backtracking-memo",
                "content": "~~~java\\n\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    \\n    public int[] beautifulArray(int n) {\\n        memo = new HashMap<>();\\n        \\n        return helper(n);\\n    }\\n    \\n    private int[] helper(int n) {\\n        if (n == 1) {\\n            memo.put(1, new int[]{1});\\n            return new int[]{1};\\n        }\\n        \\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        \\n        int mid = (n + 1) / 2;\\n        int[] left = helper(mid);\\n        int[] right = helper(n - mid);\\n        int[] rst = new int[n];\\n        for (int i = 0; i < mid; i++) {\\n            rst[i] = left[i] * 2 - 1;\\n        }\\n        for (int i = mid; i < n; i++) {\\n            rst[i] = right[i - mid] * 2;\\n        }\\n        \\n        memo.put(n, rst);\\n        return rst;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, int[]> memo;\\n    \\n    public int[] beautifulArray(int n) {\\n        memo = new HashMap<>();\\n        \\n        return helper(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1643658,
                "title": "a-simple-three-line-solution-o-n",
                "content": "```\\n    def beautifulArray(self, n):\\n        nums = list(range(1,n+1))\\n        nums.sort(key=lambda x: bin(x)[:1:-1])\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def beautifulArray(self, n):\\n        nums = list(range(1,n+1))\\n        nums.sort(key=lambda x: bin(x)[:1:-1])\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1539991,
                "title": "golang-simple-solution-beat-100",
                "content": "```go\\nfunc beautifulArray(N int) []int {\\n\\tbeautArray1024 := make([]int, 0, 1024)\\n\\tbeautArray1024 = append(beautArray1024, 1, 2)\\n\\tfor i := 2; i <= 1024; i*=2 {\\n\\t\\ttemp := make([]int, len(beautArray1024))\\n\\t\\tcopy(temp, beautArray1024)\\n\\t\\tfor index, value := range temp {\\n\\t\\t\\ttemp[index] = 2*value\\n\\t\\t}\\n\\t\\tbeautArray1024 = append(beautArray1024, temp...)\\n\\t\\tfor index := range temp {\\n\\t\\t\\tbeautArray1024[index] = temp[index] - 1\\n\\t\\t}\\n\\t}\\n\\tbeautArray := make([]int, 0, N)\\n\\tfor _, v := range beautArray1024 {\\n\\t\\tif v <= N {\\n\\t\\t\\tbeautArray = append(beautArray, v)\\n\\t\\t}\\n\\t}\\n\\treturn beautArray\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc beautifulArray(N int) []int {\\n\\tbeautArray1024 := make([]int, 0, 1024)\\n\\tbeautArray1024 = append(beautArray1024, 1, 2)\\n\\tfor i := 2; i <= 1024; i*=2 {\\n\\t\\ttemp := make([]int, len(beautArray1024))\\n\\t\\tcopy(temp, beautArray1024)\\n\\t\\tfor index, value := range temp {\\n\\t\\t\\ttemp[index] = 2*value\\n\\t\\t}\\n\\t\\tbeautArray1024 = append(beautArray1024, temp...)\\n\\t\\tfor index := range temp {\\n\\t\\t\\tbeautArray1024[index] = temp[index] - 1\\n\\t\\t}\\n\\t}\\n\\tbeautArray := make([]int, 0, N)\\n\\tfor _, v := range beautArray1024 {\\n\\t\\tif v <= N {\\n\\t\\t\\tbeautArray = append(beautArray, v)\\n\\t\\t}\\n\\t}\\n\\treturn beautArray\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482077,
                "title": "odd-even-java-recursive-solution-o-n-no-extra-space",
                "content": "Let\\'s start from a simple 3 numbers case: `(1, 2, 3)` -> the only thing we need to do is move `2` out of `1` and `3` -> `(1, 3, 2)`.\\nThen what if the case is `(1, 5, 9 )` which has `increment = 4`? It\\'s same thing -> move `3` out of `1` and `5` -> `(1, 9, 5)`.\\nNow, what if the case is `(1, 3, 5, 7, 9)` ? With odd + even or divide + conque idea in mind, we can simply divide it to `(1, 5, 9)` and `(3, 7)`. Since no change needed for 2 numbers case, after following the above steps, we can conque them to `(1, 9, 5, 3, 7)`.\\n\\nNow, coming back the this problem, if input n is `10`, then our case becomes to:\\n\\n\\t                         (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), inc = 1\\n\\t\\t\\t\\t\\t\\t\\t                  |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  | => [1, 9, 5, 3, 7, 2, 10, 6, 4, 8]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  |\\n\\t\\t  (1, 3, 5, 7, 9),  inc = 2               +              (2, 4, 6, 8, 10),  inc = 2\\n\\t\\t            |                                                      |\\n\\t                | => [1, 9, 5, 3, 7]                                   | => [2, 10, 6, 4, 8]\\n\\t\\t\\t\\t\\t|                                                      |\\n\\t    (1, 5, 9)   +   (3, 7), inc = 4                        (2, 6, 10)   +   (4, 8), inc = 4\\n\\t\\t    |                                                       |\\n\\t        | => [1, 9, 5]                                          | => [2, 10, 6]\\n\\t\\t\\t|                                                       |\\n\\t(1, 9) + (5), inc = 8                                (2, 10) + (6), inc = 8\\n \\n\\n\\n\\n```\\nclass Solution {\\n    int k, n;\\n    int[] res;\\n    public int[] beautifulArray(int n) {\\n        res = new int[n];\\n        k = 0;\\n        this.n = n;\\n        divideConque(1, 1);\\n        return res;\\n    }\\n    private void divideConque(int start, int increment) {\\n        if (start + increment > n) {\\n            res[k++] = start;\\n            return;\\n        }\\n        divideConque(start, 2 * increment);\\n        divideConque(start + increment, 2 * increment);\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int k, n;\\n    int[] res;\\n    public int[] beautifulArray(int n) {\\n        res = new int[n];\\n        k = 0;\\n        this.n = n;\\n        divideConque(1, 1);\\n        return res;\\n    }\\n    private void divideConque(int start, int increment) {\\n        if (start + increment > n) {\\n            res[k++] = start;\\n            return;\\n        }\\n        divideConque(start, 2 * increment);\\n        divideConque(start + increment, 2 * increment);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437516,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int>t;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]-1<=n)\\n                {\\n                    t.push_back(2*ans[i]-1);\\n                }\\n            }\\n                        for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]<=n)\\n                {\\n                    t.push_back(2*ans[i]);\\n                }\\n            }\\n            ans=t;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int>t;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]-1<=n)\\n                {\\n                    t.push_back(2*ans[i]-1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1430076,
                "title": "java-nlog-n-0ms-different-recursive-solution-thinking",
                "content": "**Idea / Intuition**\\n* The strategy that I found was that any 3 of the elements which are same distance apart in the same sequence would cause the array to not be beautiful.\\n* That is 1,2,3 are not beautiful and also 1,3,5 . But I realized that if I split the array as odds and evens then between the two subarrays if we pick one from each the beautiful condition was satisfied (ofcourse because even + odd divided by 2 will not be an integer :) ). \\n* Still within each half it was not beautiful. Then I thought for each half as well, if we did the same but not thinking of odds and evens as numbers but indices then it would make the new smaller quarters beautiful. Because the equidistant 3 numbers need to be shuffled, so **we pick alternatively and group them together.**\\n\\n**Example:**\\n\\t[1,2,3,4,5,6]    -> [1,3,5] & [2,4,6] **(beautiful condition satisfied for any i from first half and j from second half)**\\n[1,3,5] & [2,4,6]  -> [1,5] & [3] & [2,6] & [4] ** (now (1+3)/2 was not 5 and same for (2+4)/2)**\\n\\nSo I inferred that if we did it till we reach individual elements we would have a beautiful array. So here is my solution below:\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] res= new int[n];\\n        for(int i=0;i<n;i++)\\n            res[i]=i+1;\\n        recur(0,n-1,res);\\n        return res;\\n    }\\n    \\n    void recur(int i, int j, int[] res){\\n        if(j-i<2) return;\\n        int even=(j-i+1)/2;\\n        int odd=even;\\n        if ((j-i+1)%2==1) odd++;\\n        int[] odarr= new int[odd];\\n        int[] evarr= new int[even];\\n        int ic=i,jc=j,vi=0;\\n        while(ic<=jc){\\n            odarr[vi]=res[ic];\\n            if(ic+1<=jc) evarr[vi]=res[ic+1];\\n            ic+=2;vi++;\\n        }\\n        for(int x=0;x<odd;x++)\\n            res[i+x]=odarr[x];\\n        for(int x=0;x<even;x++)\\n            res[i+odd+x]=evarr[x];\\n        recur(i, i+odd-1, res);\\n        recur(i+odd, j, res);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] res= new int[n];\\n        for(int i=0;i<n;i++)\\n            res[i]=i+1;\\n        recur(0,n-1,res);\\n        return res;\\n    }\\n    \\n    void recur(int i, int j, int[] res){\\n        if(j-i<2) return;\\n        int even=(j-i+1)/2;\\n        int odd=even;\\n        if ((j-i+1)%2==1) odd++;\\n        int[] odarr= new int[odd];\\n        int[] evarr= new int[even];\\n        int ic=i,jc=j,vi=0;\\n        while(ic<=jc){\\n            odarr[vi]=res[ic];\\n            if(ic+1<=jc) evarr[vi]=res[ic+1];\\n            ic+=2;vi++;\\n        }\\n        for(int x=0;x<odd;x++)\\n            res[i+x]=odarr[x];\\n        for(int x=0;x<even;x++)\\n            res[i+odd+x]=evarr[x];\\n        recur(i, i+odd-1, res);\\n        recur(i+odd, j, res);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389201,
                "title": "ruby-sorting-by-lower-bits-of-binary-representation",
                "content": "Sorting numbers by lower bits makes the array beautiful.\\n\\nLet\\'s  take number 8. In binary representation it is `100`. Multiplying by 2 results in `1000`. To make sum of two numbers resulting in `1000` both must have lower bits set, e.g. `111` and `001`, `110` and `010`, `110` and `011`. I.e. all of these numbers go on one side of `100` when sorting by lower bits.\\n\\n```\\ndef beautiful_array(n)\\n \\xA0  (1..n).sort_by{ |x| x.to_s(2).reverse }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautiful_array(n)\\n \\xA0  (1..n).sort_by{ |x| x.to_s(2).reverse }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1387475,
                "title": "ruby-o-n-simple-iterative-solution",
                "content": "```\\ndef beautiful_array(n)\\n    r = [1]\\n\\n    while r.size < n\\n        r = r.map{ |n| n * 2 - 1 } + r.map{ |n| n * 2 }\\n    end\\n\\n    r.reject{ |x| x > n }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautiful_array(n)\\n    r = [1]\\n\\n    while r.size < n\\n        r = r.map{ |n| n * 2 - 1 } + r.map{ |n| n * 2 }\\n    end\\n\\n    r.reject{ |x| x > n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1375014,
                "title": "c-divide-and-conquer-sln-beats-100",
                "content": "```\\nvector<int> beautifulArray(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>());\\n        function<vector<int>(int)> get_or_compute;\\n        get_or_compute = [&get_or_compute, &dp](int k) {\\n            if (!dp[k].empty()) {\\n                return dp[k];\\n            }\\n            if (k == 1) {\\n                return dp[1] = {1};\\n            }\\n            int i = 0;\\n            vector<int> res(k);\\n            for (int x : get_or_compute((k + 1) / 2)) {\\n                res[i++] = x * 2 - 1;\\n            }\\n            for (int x : get_or_compute(k / 2)) {\\n                res[i++] = x * 2;\\n            }\\n            return dp[k] = move(res);\\n        };\\n        return get_or_compute(n);\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> beautifulArray(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>());\\n        function<vector<int>(int)> get_or_compute;\\n        get_or_compute = [&get_or_compute, &dp](int k) {\\n            if (!dp[k].empty()) {\\n                return dp[k];\\n            }\\n            if (k == 1) {\\n                return dp[1] = {1};\\n            }\\n            int i = 0;\\n            vector<int> res(k);\\n            for (int x : get_or_compute((k + 1) / 2)) {\\n                res[i++] = x * 2 - 1;\\n            }\\n            for (int x : get_or_compute(k / 2)) {\\n                res[i++] = x * 2;\\n            }\\n            return dp[k] = move(res);\\n        };\\n        return get_or_compute(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1373568,
                "title": "is-this-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge_vector(vector<int> &vec)\\n    {\\n        if (vec.size() < 2)\\n            return;\\n        int l = vec.size();\\n        int c = 0;\\n        vector<int> left((l + 1) / 2);\\n        vector<int> right(l / 2);\\n        for (int i = 0; i < l; i += 2)\\n            left[c++] = vec[i];\\n        c = 0;\\n        for (int i = 1; i < l; i += 2)\\n            right[c++] = vec[i];\\n        c = 0;\\n        merge_vector(left);\\n        merge_vector(right);\\n        for (auto &&v : left)\\n            vec[c++] = v;\\n        for (auto &&v : right)\\n            vec[c++] = v;\\n        return;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i++)\\n            res[i] = i + 1;\\n        merge_vector(res);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void merge_vector(vector<int> &vec)\\n    {\\n        if (vec.size() < 2)\\n            return;\\n        int l = vec.size();\\n        int c = 0;\\n        vector<int> left((l + 1) / 2);\\n        vector<int> right(l / 2);\\n        for (int i = 0; i < l; i += 2)\\n            left[c++] = vec[i];\\n        c = 0;\\n        for (int i = 1; i < l; i += 2)\\n            right[c++] = vec[i];\\n        c = 0;\\n        merge_vector(left);\\n        merge_vector(right);\\n        for (auto &&v : left)\\n            vec[c++] = v;\\n        for (auto &&v : right)\\n            vec[c++] = v;\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1372686,
                "title": "c-recursive-solution",
                "content": "Split numbers into odd and even parts; in each part, recurisively split. \\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n == 1) return {1};\\n        if (n == 2) return {1,2};\\n        if (n == 3) return {1,3,2};\\n        if (n == 4) return {1,3,2,4};\\n        vector<int> ans(n);\\n        int index = 0;\\n        int k = (n+1)/2;\\n        vector<int> base = beautifulArray(k);\\n        for (int i = 0; i < k; ++i) {\\n            ans[index++] = 2*base[i]-1;   \\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (2*base[i]>n) continue;\\n            ans[index++] = 2*base[i];   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n == 1) return {1};\\n        if (n == 2) return {1,2};\\n        if (n == 3) return {1,3,2};\\n        if (n == 4) return {1,3,2,4};\\n        vector<int> ans(n);\\n        int index = 0;\\n        int k = (n+1)/2;\\n        vector<int> base = beautifulArray(k);\\n        for (int i = 0; i < k; ++i) {\\n            ans[index++] = 2*base[i]-1;   \\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (2*base[i]>n) continue;\\n            ans[index++] = 2*base[i];   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371274,
                "title": "c-easy-dfs-solution-with-explicit-explanation",
                "content": "Firstly, we devide array into two partition, one of it consist of odd numbers and other consist of even, then, in the conjunction of two arrays, two of the numbers are in the proper place (for the reason odd + even would not be even) .  \\n\\nand then, odd number could be written as 1+2K_i, as well as even number could be written as 2K_i, we could devided K_i into two partition, odd and even, and, for the same reason, in the conjunction, those number are in the correct place.  If we iterate this process, we could get our beautiful array\\n\\nif we play attention to the detail, we would find out that, after we devided array 1,2,3, ... , n into two part, such as 1,3,5,...,2K+1,2,4,6,...,2K, each number are still with the same key value Ki (or index) , it mean 1,3,5,...,2K+1 also could be written as  1 + 0,1 + 2 * 1,1 + 2 * 2,..., 1 + 2 * k, and the function we use to devide array into two part are still useful to devide the changing array, hence dfs is useful in that situation. \\n```\\nclass Solution {\\npublic:\\n    vector<int> re;\\n    void rearrange(int left,int right){\\n        vector<int> tmp(re.size(),0);\\n        for(int i=left;i<=(right+left)/2;++i){\\n            tmp[i]=re[2*(i-left)+left];\\n        }\\n        for(int i=1+(right+left)/2;i<=right;++i){\\n            tmp[i]=re[2*(i-1-(right+left)/2)+1+left];\\n        }\\n        for(int i=left;i<=right;++i){\\n            re[i]=tmp[i];\\n        }\\n        return ;\\n    }\\n    void dfs(int left,int right){\\n        if(left==right) return ;\\n        rearrange(left,right);\\n        int mid=(left+right)>>1;\\n        dfs(left,mid);\\n        dfs(mid+1,right);\\n        return ;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        for(int i=1;i<=n;++i) re.push_back(i);\\n        dfs(0,re.size()-1);\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> re;\\n    void rearrange(int left,int right){\\n        vector<int> tmp(re.size(),0);\\n        for(int i=left;i<=(right+left)/2;++i){\\n            tmp[i]=re[2*(i-left)+left];\\n        }\\n        for(int i=1+(right+left)/2;i<=right;++i){\\n            tmp[i]=re[2*(i-1-(right+left)/2)+1+left];\\n        }\\n        for(int i=left;i<=right;++i){\\n            re[i]=tmp[i];\\n        }\\n        return ;\\n    }\\n    void dfs(int left,int right){\\n        if(left==right) return ;\\n        rearrange(left,right);\\n        int mid=(left+right)>>1;\\n        dfs(left,mid);\\n        dfs(mid+1,right);\\n        return ;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        for(int i=1;i<=n;++i) re.push_back(i);\\n        dfs(0,re.size()-1);\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370218,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        \\n        vector<int>memo = {1};\\n        \\n        while(memo.size() < n)\\n        {\\n             vector<int>curr;\\n            \\n            for(auto x : memo)\\n            {\\n                 if(2*x-1 <= n)\\n                     curr.push_back(2*x-1);\\n            }\\n            for(auto x : memo)\\n            {\\n                 if(2*x <= n)\\n                     curr.push_back(2*x);\\n            }\\n            memo = curr;\\n        }\\n        return memo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        \\n        vector<int>memo = {1};\\n        \\n        while(memo.size() < n)\\n        {\\n             vector<int>curr;\\n            \\n            for(auto x : memo)\\n            {\\n                 if(2*x-1 <= n)\\n                     curr.push_back(2*x-1);\\n            }\\n            for(auto x : memo)\\n            {\\n                 if(2*x <= n)\\n                     curr.push_back(2*x);\\n            }\\n            memo = curr;\\n        }\\n        return memo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369773,
                "title": "java-easy-1ms-with-explanation",
                "content": "1. As per problem condition A+B != 2C, where  A<C<B\\nObviously, if  A is odd and  B is even (and vice versa) then we satisfy condition with any C in-between.\\nFor ex.  in the array 2,4,6,8,  1,3,5,7,9 , for any A from 2,4,6,8 and B from 1,3,5,7,9, condition is always valid \\nFinally, every array can be divided into odds and evens, so both groups will co-satisfy condition.\\nBut what to do with each group itsef?\\n\\n2. Let\\'s talk about even group.\\nA+B != 2C, all are evens, let\\'s divide them by 2\\nA/2 + B/2 != c; where C is even, A/2 and B/2 can be odd or even \\nif we regroup all given evens by placing first evens with odd A/2 and then all evens with even B/2, then we satisfy condition for any A and B and any C in-between\\n2,4,6,8,10,12,14,16\\nA : 2,6,10,14,  B: 4,8,12,16\\n\\n3. There is intersting property for any A,B,C.\\nA+B !=2C, where A<C<B\\nif w increment A, B, C, then condition is still valid\\nA+1+B+1 != 2*(C+1)\\nA+B+2 != 2C +2\\nA+B!=C\\n\\n4. if we increment all items of  Odd group, then we can treat it as Even group. We only need to adjust group back afterwards by decrement \\n\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int m = n/2 + n%2;\\n        int[] buf = new int[n];\\n        for(int i=1;i<=n;i+=2)\\n            buf[i/2] = i;\\n        for(int i=2;i<=n;i+=2)\\n            buf[m + i/2 -1] = i;\\n        //1,3,5,7,9,  2,4,6,8,10\\n        recOdd(buf,0,m-1);\\n        recEven(buf,m, n-1);\\n        return buf;\\n    }\\n    private void recOdd(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n        for(int f=from;f<=to;f++)\\n            buf[f]++;\\n        recEven(buf,from, to);\\n        for(int f=from;f<=to;f++)\\n            buf[f]--;\\n        \\n    }\\n    private void recEven(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]/=2;\\n\\n        int f = from, t = to;\\n        while(f<t){\\n            while(f < t && buf[f]%2==1) \\n                f++;\\n            while(f < t && buf[t]%2==0)\\n                t--;\\n            if(f < t){\\n                int temp = buf[f];\\n                buf[f]=buf[t];\\n                buf[t] = temp;\\n            }\\n\\n        }\\n        recOdd(buf, from, f+buf[f]%2-1);\\n        recEven(buf, f+buf[f]%2, to);\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]*=2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int m = n/2 + n%2;\\n        int[] buf = new int[n];\\n        for(int i=1;i<=n;i+=2)\\n            buf[i/2] = i;\\n        for(int i=2;i<=n;i+=2)\\n            buf[m + i/2 -1] = i;\\n        //1,3,5,7,9,  2,4,6,8,10\\n        recOdd(buf,0,m-1);\\n        recEven(buf,m, n-1);\\n        return buf;\\n    }\\n    private void recOdd(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n        for(int f=from;f<=to;f++)\\n            buf[f]++;\\n        recEven(buf,from, to);\\n        for(int f=from;f<=to;f++)\\n            buf[f]--;\\n        \\n    }\\n    private void recEven(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]/=2;\\n\\n        int f = from, t = to;\\n        while(f<t){\\n            while(f < t && buf[f]%2==1) \\n                f++;\\n            while(f < t && buf[t]%2==0)\\n                t--;\\n            if(f < t){\\n                int temp = buf[f];\\n                buf[f]=buf[t];\\n                buf[t] = temp;\\n            }\\n\\n        }\\n        recOdd(buf, from, f+buf[f]%2-1);\\n        recEven(buf, f+buf[f]%2, to);\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]*=2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369728,
                "title": "is-2-1-4-3-5-a-valid-solution-for-n-5",
                "content": "I am confused as to why **2,1,4,3,5** is not a valid answer for n=5. Similarly, why 2,1,4,3,6,5 not a valid solution for n=6?",
                "solutionTags": [],
                "code": "I am confused as to why **2,1,4,3,5** is not a valid answer for n=5. Similarly, why 2,1,4,3,6,5 not a valid solution for n=6?",
                "codeTag": "Unknown"
            },
            {
                "id": 1369540,
                "title": "c-easy-to-understand-beautiful-array-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n\\t\\tvector<int> temp ;\\n        while(ans.size() < n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n\\t\\tvector<int> temp ;\\n        while(ans.size() < n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369535,
                "title": "c-easy-to-understand-fast-and-efficient-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n       vector<int> ans;\\n        ans.push_back(1);\\n        vector<int> temp;\\n        while(ans.size()<n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(2*i-1<=n)\\n                {\\n                    temp.push_back(2*i-1);\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(2*i<=n)\\n                {\\n                    temp.push_back(2*i);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n       vector<int> ans;\\n        ans.push_back(1);\\n        vector<int> temp;\\n        while(ans.size()<n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(2*i-1<=n)\\n                {\\n                    temp.push_back(2*i-1);\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(2*i<=n)\\n                {\\n                    temp.push_back(2*i);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369501,
                "title": "c-solution-o-n-solution-beautiful-array",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.2 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n*********************************\\nI took help from youtube because this is weirdest question on leetcode\\n\\n***********************************\\nvector<int> beautifulArray(int n) {\\n        vector<int>ans={1};  // our final/resultant array\\n        while(ans.size()<n)  // this loop will run until all the number are not generated till n\\n        {\\n           vector<int>res; //it is like a temparory array\\n\\t\\t   //for all the odd number \\n            for(auto &x : ans) \\n            {\\n              if(x*2-1<=n) res.push_back(x*2-1);\\n            }\\n\\t\\t\\t//for all the even number \\n            for(auto &x : ans)\\n            {\\n              if(x*2<=n) res.push_back(x*2);\\n            }\\n            ans=res;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.2 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n*********************************\\nI took help from youtube because this is weirdest question on leetcode\\n\\n***********************************\\nvector<int> beautifulArray(int n) {\\n        vector<int>ans={1};  // our final/resultant array\\n        while(ans.size()<n)  // this loop will run until all the number are not generated till n\\n        {\\n           vector<int>res; //it is like a temparory array\\n\\t\\t   //for all the odd number \\n            for(auto &x : ans) \\n            {\\n              if(x*2-1<=n) res.push_back(x*2-1);\\n            }\\n\\t\\t\\t//for all the even number \\n            for(auto &x : ans)\\n            {\\n              if(x*2<=n) res.push_back(x*2);\\n            }\\n            ans=res;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1369455,
                "title": "go-0ms-o-n-using-bit-reversal",
                "content": "This solution generates the exact same arrays on the test cases as the built-in solution (tested with n = 1000).\\n\\nI noticed that evens on one side and odds on the other is a good strategy, since the average of even and odd is a fraction so you only need to worry about the in-between numbers within the evens/odds sections.\\n\\nSimilarly, within the evens section you can have sub-sections of multiples-of-4 and not-multiples of-4, since averaging one of each will be an odd number (since non-multiple-of-4 + multiple-of-4 is non-multiple-of-4, and non-multiple-of-4 divided by 2 is odd).\\n\\nGenerating a sequence sorted by the ones place first, then the twos place etc can be done by reversing the bits of an iterator that counts up by one.  Reversing the bits can cause some numbers to be too big, this solution gets around that by generating all the numbers with the same number of (binary) digits and discarding the ones that are too big.\\n\\n```\\nimport \"math/bits\"\\n\\nfunc beautifulArray(n int) []int {\\n    out := make([]int, 0, n)\\n    blen := bits.Len16(uint16(n))\\n    twoPow := uint16(1 << blen)\\n    for i := uint16(0); i < twoPow; i++ {\\n        num := int(bits.Reverse16(i) >> (16-blen))\\n        if num < n {\\n            out = append(out, num + 1)\\n        }\\n    }\\n    return out\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"math/bits\"\\n\\nfunc beautifulArray(n int) []int {\\n    out := make([]int, 0, n)\\n    blen := bits.Len16(uint16(n))\\n    twoPow := uint16(1 << blen)\\n    for i := uint16(0); i < twoPow; i++ {\\n        num := int(bits.Reverse16(i) >> (16-blen))\\n        if num < n {\\n            out = append(out, num + 1)\\n        }\\n    }\\n    return out\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369387,
                "title": "javascript-even-odd-enlarge-from-1-80ms-100",
                "content": "```\\nconst beautifulArray = (n) => {\\n    let res = [1];\\n    while (res.length < n) {\\n        let tmp = [];\\n        for (const x of res) {\\n            if (x * 2 - 1 <= n) tmp.push(x * 2 - 1);\\n        }\\n        for (const x of res) {\\n            if (x * 2 <= n) tmp.push(x * 2);\\n        }\\n        res = tmp;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst beautifulArray = (n) => {\\n    let res = [1];\\n    while (res.length < n) {\\n        let tmp = [];\\n        for (const x of res) {\\n            if (x * 2 - 1 <= n) tmp.push(x * 2 - 1);\\n        }\\n        for (const x of res) {\\n            if (x * 2 <= n) tmp.push(x * 2);\\n        }\\n        res = tmp;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369381,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        List<int> beautiful = new List<int>{1};\\n        while(beautiful.Count<n){\\n            List<int> temp = new List<int>();\\n            foreach(int i in beautiful){\\n                if((i*2-1)<=n) temp.Add((i*2-1));\\n            }\\n            foreach(int j in beautiful){\\n                if(2*j<=n) temp.Add(2*j);\\n            }\\n            beautiful=temp;\\n        }\\n        return beautiful.ToArray();\\n    }\\n}\\n  \\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        List<int> beautiful = new List<int>{1};\\n        while(beautiful.Count<n){\\n            List<int> temp = new List<int>();\\n            foreach(int i in beautiful){\\n                if((i*2-1)<=n) temp.Add((i*2-1));\\n            }\\n            foreach(int j in beautiful){\\n                if(2*j<=n) temp.Add(2*j);\\n            }\\n            beautiful=temp;\\n        }\\n        return beautiful.ToArray();\\n    }\\n}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369350,
                "title": "solution-based-on-inspection-and-oeis-org",
                "content": "Before I got this solution, my other solution spat out these output for n=1...10\\n![image](https://assets.leetcode.com/users/images/ce1c1fb7-edbf-427d-9d49-c9b321648c1a_1627526519.91102.png)\\nIf you look closely, you\\'ll notice that in this specific output, the answer for n is just the answer for n-1 with n inserted somewhere. Looking up the sequence of insert positions in 1-based indexing (1,2,2,4,2,...), you\\'ll find this sequence: https://oeis.org/A088371. Therefore, all that\\'s needed to be done is get beautifulArray(n-1), and insert n at a(n) position. Formula for a(n) is given in the link also\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int a(int n) {\\n        if (dp[n] != -1) { return dp[n]; }\\n\\n        if (n == 1) { return 1; }\\n        if (n == 2) { return 2; }\\n\\n        if (n % 2 == 0) {\\n            dp[n] = n/2 + a(n / 2);\\n        }\\n\\n        else { \\n            dp[n] = a((n + 1) / 2); \\n        }\\n\\n        return dp[n];\\n    }\\n\\n    vector<int> beautifulArray(int n) {\\n        if (dp.size() == 0) {\\n            dp = vector<int>(n+1, -1);\\n        }\\n\\n        if (n == 1) {\\n            return { 1 };\\n        }\\n\\n        if (n == 2) {\\n            return { 1,2 };\\n        }\\n\\n        if (n == 3) {\\n            return { 1,3,2 };\\n        }\\n\\n        vector<int> res = beautifulArray(n - 1);\\n        int p = a(n) - 1;\\n        res.insert(res.begin() + p, n);\\n\\n        return res;\\n    }\\n};\\n```\\nSpace complexity: O(n)\\nTime complexity: I actually dont know, maybe the inserting part makes it O(n^2)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int a(int n) {\\n        if (dp[n] != -1) { return dp[n]; }\\n\\n        if (n == 1) { return 1; }\\n        if (n == 2) { return 2; }\\n\\n        if (n % 2 == 0) {\\n            dp[n] = n/2 + a(n / 2);\\n        }\\n\\n        else { \\n            dp[n] = a((n + 1) / 2); \\n        }\\n\\n        return dp[n];\\n    }\\n\\n    vector<int> beautifulArray(int n) {\\n        if (dp.size() == 0) {\\n            dp = vector<int>(n+1, -1);\\n        }\\n\\n        if (n == 1) {\\n            return { 1 };\\n        }\\n\\n        if (n == 2) {\\n            return { 1,2 };\\n        }\\n\\n        if (n == 3) {\\n            return { 1,3,2 };\\n        }\\n\\n        vector<int> res = beautifulArray(n - 1);\\n        int p = a(n) - 1;\\n        res.insert(res.begin() + p, n);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369272,
                "title": "python3-recursion-recursive-solution",
                "content": "The key ideas are:\\n- The array can be formed by placing all even number in front of odd numbers, because  even and odd number cannot have a interger average. \\n- The \"Beauty\" of an array is invariant of any addition or multiplication by constants to each of its elements.\\n- An array of consecutive even numbers can be transformed into an array of consecutive integers by dividing each by 2 and the \"Beauty\" will not change.\\n- An array of consecutive odd numbers can be transformed into array of consecutive integers by adding one and dividing by 2, and the \"Beauty\" will not change.\\n\\n```\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        \\n        even=[2*i for i in self.beautifulArray(n//2)]\\n        odd=[2*i-1 for i in self.beautifulArray(n-n//2)]\\n        \\n        return even+odd\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        \\n        even=[2*i for i in self.beautifulArray(n//2)]\\n        odd=[2*i-1 for i in self.beautifulArray(n-n//2)]\\n        \\n        return even+odd\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369262,
                "title": "beautiful-array-using-even-odd-indexes-approach",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        def dfs(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            even,odd = [],[]\\n            for i in range(len(arr)):\\n                if i & 1:\\n                    odd.append(arr[i])\\n                else:\\n                    even.append(arr[i])\\n            return dfs(odd) + dfs(even)\\n        return dfs(range(1,n+1))\\n```\\nif you put the permutation in order like 1,2,3,4,5,6,7 you will notice that for a center number, num[center] and num[center-x] and number[center+x] where x = 1,2,3,4,5...  satisfy the 2k = i + j. so you need to break them up somehow.\\none way is to separate them by even,odd index which break some of the 2k = i,j but not all of them. there are still problems in the subsequent even odd lists. so separate them out again into even odd index. keep doing this until one element remains and build it back up.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        def dfs(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            even,odd = [],[]\\n            for i in range(len(arr)):\\n                if i & 1:\\n                    odd.append(arr[i])\\n                else:\\n                    even.append(arr[i])\\n            return dfs(odd) + dfs(even)\\n        return dfs(range(1,n+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369252,
                "title": "quick-and-clean-python-solution-90-time",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        if n==2: return [1,2]\\n        if n==3: return [1,3,2]\\n        if n==4: return [1,3,2,4]\\n        \\n        #get a beautiful array the length of the odd integers\\n        odd_beaut = self.beautifulArray((n+1)//2)\\n        \\n        #map the array to the odds\\n        odds = [(2*i)-1 for i in odd_beaut]\\n        \\n        #create an even array\\n        evens = [i+1 for i in odds]\\n        \\n        result = odds+evens\\n        \\n        #may have to remove one if we did too many evens\\n        if n%2==1: result.remove(n+1)\\n        \\n        return result\\n            ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        if n==2: return [1,2]\\n        if n==3: return [1,3,2]\\n        if n==4: return [1,3,2,4]\\n        \\n        #get a beautiful array the length of the odd integers\\n        odd_beaut = self.beautifulArray((n+1)//2)\\n        \\n        #map the array to the odds\\n        odds = [(2*i)-1 for i in odd_beaut]\\n        \\n        #create an even array\\n        evens = [i+1 for i in odds]\\n        \\n        result = odds+evens\\n        \\n        #may have to remove one if we did too many evens\\n        if n%2==1: result.remove(n+1)\\n        \\n        return result\\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 1369174,
                "title": "java-by-inductive-construction-with-explanation",
                "content": "Key observations:\\n1. If we have a solution that works for n integers, we can double every number and remain compliant with the rule: nums[i] + nums[j] <> nums[k] * 2.\\n1. Using the doubled solution, we can append a copy to the right in reverse order, and decrement every element of the copy by one, to get a valid solution of length 2n.  That is because both copies  still satisfy the above rule, and for any pairs that cross the midpoint, parity is different, making the sum odd.\\n1. If we have a solution of length n, we can construct a solution of length m where m < n by simply removing all elements that are greater than m.\\n\\nPutting the first 2 observations together, given any solution, we can construct a new solution of double the original length.  So just start with the solution for n = 1, which is [1], and repeatedly double its length until it is at least long enough.  If it is too long, use observation 3 to trim it to the desired length.\\n\\nFor example:\\n[2,1,4,3] --> [4,2,8,6] (doubling) --> [4,2,8,6,5,7,1,3] (copy, reverse, decrement, append)\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        // Find the smallest power of 2 that is greater than or equal to n\\n        int x = 1;\\n        while (x < n) x += x;\\n        \\n        int[] answer = new int[x];\\n        \\n        // Populate the first position\\n        answer[0] = 1;\\n        int size = 1;\\n        \\n        // Now repeat: reverse and append, while doubling\\n        // Each iteration generates a solution that is twice as long as the previous step\\n        while (size * 2 <= x) {\\n            for (int i = 0; i < size; i++) {\\n                answer[i] += answer[i];\\n                answer[size * 2 - i - 1] = answer[i] - 1;\\n            }\\n            size += size;\\n        }\\n        if (x == n) return answer;\\n        \\n        // Create an answer array of the right length, discarding numbers that are too big\\n        int[] finalAnswer = new int[n];\\n        int j = 0;\\n        for (int i = 0; i < answer.length; i++) if (answer[i] <= n) finalAnswer[j++] = answer[i];\\n        \\n        return finalAnswer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        // Find the smallest power of 2 that is greater than or equal to n\\n        int x = 1;\\n        while (x < n) x += x;\\n        \\n        int[] answer = new int[x];\\n        \\n        // Populate the first position\\n        answer[0] = 1;\\n        int size = 1;\\n        \\n        // Now repeat: reverse and append, while doubling\\n        // Each iteration generates a solution that is twice as long as the previous step\\n        while (size * 2 <= x) {\\n            for (int i = 0; i < size; i++) {\\n                answer[i] += answer[i];\\n                answer[size * 2 - i - 1] = answer[i] - 1;\\n            }\\n            size += size;\\n        }\\n        if (x == n) return answer;\\n        \\n        // Create an answer array of the right length, discarding numbers that are too big\\n        int[] finalAnswer = new int[n];\\n        int j = 0;\\n        for (int i = 0; i < answer.length; i++) if (answer[i] <= n) finalAnswer[j++] = answer[i];\\n        \\n        return finalAnswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369096,
                "title": "java-o-n-0ms-beats-100-divide-and-conquer-explained",
                "content": "### Problem Solving\\nWe can solve this question using one (generalized) key observation: for any permutation, **if you separate the numbers** such that all numbers on one side are the same MOD `m` (where `m` in `{2, 4, 8, ...}`, it is impossible for `arr[i] + arr[j] == 2 * arr[k]`.\\nE.g. #1\\n```\\n\\tarr = [1, 5, 3, 7, 2, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 0, 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 3, 3, 0, 0, 2, 2] (MOD 4)\\n```\\nE.g. #2\\n```\\n\\tarr = [1, 9, 5, 3, 11, 7, 2, 10, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 1 , 1, 0, 0 , 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 1, 3, 3 , 3, 2, 2 , 2, 0, 0] (MOD 4)\\n\\t\\t= [1, 1, 5, 3, 3 , 7, 2, 2 , 6, 4, 0] (MOD 8)\\n```\\nAs you can see, these permutations keep the numbers separated as described above, and you can check for yourself that if you take any two numbers that belong to different groups (for example, `9` and `3` in e.g. #2), none of the numbers inbetween them will break the requirement.\\nThis makes the problem suitable for a **divide and conquer** approach, where we separate numbers according to these rules at every level.\\n### Implementation\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        final int[] beauty = new int[n];\\n        fill(beauty, 0, n, 0, 1);\\n        return beauty;\\n    }\\n    \\n    private void fill(int[] arr, int lo, int hi, int start, int mod) {\\n        if(hi - lo == 1) { // base case\\n            arr[lo] = start + 1;\\n        } else { // divide and conquer\\n            final int mid = lo + (hi - lo + 1) / 2;\\n            fill(arr, lo, mid, start, mod << 1);\\n            fill(arr, mid, hi, start + mod, mod << 1); // (start + mod) to prevent overlap\\n        }\\n    }\\n    \\n\\t/* not part of the solution, but helpful for debugging. verify:\\n\\t\\t* no duplicates and within range --> is permutation of [1...n]\\n\\t\\t* arr[i] + arr[j] != 2 * arr[k] for all 0 <= i < k < j < n\\n\\t*/\\n    private boolean verify(int[] arr) {\\n        final Set<Integer> seen = new HashSet<>(arr.length);\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] < 1 || arr[i] > arr.length || seen.contains(arr[i])) return false;\\n            seen.add(arr[i]);\\n            for(int k = i + 1; k < arr.length; k++)\\n                for(int j = k + 1; j < arr.length; j++)\\n                    if(arr[i] + arr[j] == arr[k] * 2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tarr = [1, 5, 3, 7, 2, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 0, 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 3, 3, 0, 0, 2, 2] (MOD 4)\\n```\n```\\n\\tarr = [1, 9, 5, 3, 11, 7, 2, 10, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 1 , 1, 0, 0 , 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 1, 3, 3 , 3, 2, 2 , 2, 0, 0] (MOD 4)\\n\\t\\t= [1, 1, 5, 3, 3 , 7, 2, 2 , 6, 4, 0] (MOD 8)\\n```\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        final int[] beauty = new int[n];\\n        fill(beauty, 0, n, 0, 1);\\n        return beauty;\\n    }\\n    \\n    private void fill(int[] arr, int lo, int hi, int start, int mod) {\\n        if(hi - lo == 1) { // base case\\n            arr[lo] = start + 1;\\n        } else { // divide and conquer\\n            final int mid = lo + (hi - lo + 1) / 2;\\n            fill(arr, lo, mid, start, mod << 1);\\n            fill(arr, mid, hi, start + mod, mod << 1); // (start + mod) to prevent overlap\\n        }\\n    }\\n    \\n\\t/* not part of the solution, but helpful for debugging. verify:\\n\\t\\t* no duplicates and within range --> is permutation of [1...n]\\n\\t\\t* arr[i] + arr[j] != 2 * arr[k] for all 0 <= i < k < j < n\\n\\t*/\\n    private boolean verify(int[] arr) {\\n        final Set<Integer> seen = new HashSet<>(arr.length);\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] < 1 || arr[i] > arr.length || seen.contains(arr[i])) return false;\\n            seen.add(arr[i]);\\n            for(int k = i + 1; k < arr.length; k++)\\n                for(int j = k + 1; j < arr.length; j++)\\n                    if(arr[i] + arr[j] == arr[k] * 2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369079,
                "title": "aging-s-rpr-solution",
                "content": "This solution is posted here by user@ Aging - https://leetcode.com/problems/beautiful-array/solution/192124\\n\\nI wanted to post it here in case anyone else found it useful, as i did:\\n\\nWe can reverse a number\\'s binary format bitwisely to get its reversed binary representation (RPR). For this question, 10 bits are enough, as N is always less than 1024. In this case, RPR(1) = 0b1000000000, RPR(2) = 0b0100000000, RPR(12) = 0b0011000000.\\n\\nIt could be proved that: for any i < j < k, if i + k = j * 2, then RPR(j) is either less than or larger than both RPR(i) and RPR(k), or in another word, RPR(j) can not be between RPR(i) and RPR(k).\\nProve:\\nConsider these four conditions:\\n\\ni, k is odd, j is even (e.g. 1+7=4*2). The first bit of RPR(i) and RPR(k) is 1, and the first bit of RPR(j) is 0, so RPR(j) is smaller than both RPR(i) and RPR(k).\\ni, k is even, j is odd (e.g. 2+4=3*2). The first bit of RPR(i) and RPR(k) is 0, and the first bit of RPR(j) is 1, so RPR(j) is larger than both RPR(i) and RPR(k).\\ni, k is odd, j is odd (e.g. 1+5=3*2). Define i1 = (i-1)/2, k1=(k-1)/2, j1 = (j-1)/2, then we have i1<j1<k1, and i1+k1=j1*2. i1, j1, k1 could be treated as new i, j, k.\\ni, k is even, j is even (e.g. 2+6=4*2). Define i1=i/2, k1=k/2, j1=j/2, then we have i1<j1<k1, and i1+k1=j1*2. i1, j1, k1 could be treated as new i, j, k.\\nFor case #3 and #4, it is reduced to the original proposition, and must be finally reduced to case #1 or #2, because i < j < k.\\nBased on this, the algorithm is simple: sort all the numbers for 1 to N by its RPR. The final array is a result.\\nTime complexity is O(N log N) and space complexity is O(N).\\n\\nThe code is like:\\n\\n```\\nclass Solution {\\npublic:\\n  int rev(int N) {\\n  int ret = 0;\\n  for (int i = 0; i <= 9; ++i)\\n  ret += ((N >> i) & 0x1) << (9 - i);\\n  return ret;\\n}\\n\\nvector<int> beautifulArray(int N) {\\n    vector<int> ans(N, 0);\\n    for (int i = 0; i < N; ++i) ans[i] = i + 1;\\n    sort(ans.begin(), ans.end(), [&](int i, int j){\\n        return rev(i) < rev(j);\\n    });\\n    \\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int rev(int N) {\\n  int ret = 0;\\n  for (int i = 0; i <= 9; ++i)\\n  ret += ((N >> i) & 0x1) << (9 - i);\\n  return ret;\\n}\\n\\nvector<int> beautifulArray(int N) {\\n    vector<int> ans(N, 0);\\n    for (int i = 0; i < N; ++i) ans[i] = i + 1;\\n    sort(ans.begin(), ans.end(), [&](int i, int j){\\n        return rev(i) < rev(j);\\n    });\\n    \\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369076,
                "title": "ruby-recursion",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  @cache = {}\\n  solve(n)\\nend\\n\\ndef solve(n)\\n  return [1] if n == 1\\n  return @cache[n] if @cache[n]\\n  \\n  even_index = n/2\\n  odd_index = n - even_index\\n  even = solve(even_index)\\n  odd = solve(odd_index)\\n  even = even.map{|v| 2*v}\\n  odd = odd.map{|v| 2*v-1}\\n  @cache[n] = even + odd\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  @cache = {}\\n  solve(n)\\nend\\n\\ndef solve(n)\\n  return [1] if n == 1\\n  return @cache[n] if @cache[n]\\n  \\n  even_index = n/2\\n  odd_index = n - even_index\\n  even = solve(even_index)\\n  odd = solve(odd_index)\\n  even = even.map{|v| 2*v}\\n  odd = odd.map{|v| 2*v-1}\\n  @cache[n] = even + odd\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369048,
                "title": "beautiful-array-python",
                "content": "The key thing to recognize is that a beautiful array is still beautiful if you double all the numbers in it. It\\'s also still beautiful if you double all the numbers and subtract one. Another thing to notice is that we can deal with even and odd numbers in the array separately, because the sum of even and odd is odd, and half an odd number is not a whole number. Recognizing these two facts, we can write a recursive function to find a beautiful array of size n given that we already know the beautiful array of half the size of n. (When n is even you can use n/2, when it\\'s odd you need n/2 rounded down and n/2 rounded up.)\\n\\nSo here\\'s my solution:\\n```\\nclass Solution:\\n    def __init__(self):\\n\\t\\t# Initiate a memo so we don\\'t calculate the same array twice\\n        self.memo = {1: [1]}\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n in self.memo:\\n            return self.memo[n]\\n        \\n\\t\\t# We can deal with even and odd numbers separately, since an even plus an odd equals an odd, and half an odd is not a whole number\\n        even = self.beautifulArray(n//2)\\n        even = [x*2 for x in even]\\n        \\n        odd = self.beautifulArray(n//2+n%2)\\n        odd = [(x*2)-1 for x in odd]\\n        \\n        self.memo[n] = even + odd\\n        print(self.memo)\\n        return self.memo[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n\\t\\t# Initiate a memo so we don\\'t calculate the same array twice\\n        self.memo = {1: [1]}\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n in self.memo:\\n            return self.memo[n]\\n        \\n\\t\\t# We can deal with even and odd numbers separately, since an even plus an odd equals an odd, and half an odd is not a whole number\\n        even = self.beautifulArray(n//2)\\n        even = [x*2 for x in even]\\n        \\n        odd = self.beautifulArray(n//2+n%2)\\n        odd = [(x*2)-1 for x in odd]\\n        \\n        self.memo[n] = even + odd\\n        print(self.memo)\\n        return self.memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369006,
                "title": "go-solution",
                "content": "Inspired by [this solution](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N))\\n```\\nfunc beautifulArray(n int) []int {\\n\\tresult := []int{1}\\n\\tfor len(result) < n {\\n\\t\\ttemp := make([]int, 0, 2*len(result))\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i*2 - 1; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i * 2; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = temp\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc beautifulArray(n int) []int {\\n\\tresult := []int{1}\\n\\tfor len(result) < n {\\n\\t\\ttemp := make([]int, 0, 2*len(result))\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i*2 - 1; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i * 2; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = temp\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368934,
                "title": "java-arraylist-easiest",
                "content": "```\\n  public int[] beautifulArray(int n) {\\n        \\n List<Integer> p= new ArrayList();\\n        p.add(1);\\n        int a=2;\\n        int k=n-1;\\n        while(k>0){\\n              List<Integer> q= new ArrayList();\\n        for(int i=0;i<p.size();i++){\\n            if(p.get(i)*2-1 <=a){\\n                q.add(p.get(i)*2-1);\\n            \\n        \\n            }\\n        }\\n           List<Integer> r= new ArrayList();\\n        \\n          for(int i=0;i<p.size();i++){\\n              \\n            if(p.get(i)*2<=a){\\n                r.add(p.get(i)*2);\\n            }\\n        }\\n         p.clear();\\n        \\n     for(int i=0;i<q.size();i++){\\n               p.add(q.get(i));\\n     }\\n       for(int i=0;i<r.size();i++){\\n               p.add(r.get(i));\\n     }   \\n        a++;\\n            k--;\\n        \\n        }\\n        \\nint arr[]=new int[p.size()];\\n        for(int i=0;i<p.size();i++){\\n            arr[i]=p.get(i);\\n        }\\n        return arr;\\n     \\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n  public int[] beautifulArray(int n) {\\n        \\n List<Integer> p= new ArrayList();\\n        p.add(1);\\n        int a=2;\\n        int k=n-1;\\n        while(k>0){\\n              List<Integer> q= new ArrayList();\\n        for(int i=0;i<p.size();i++){\\n            if(p.get(i)*2-1 <=a){\\n                q.add(p.get(i)*2-1);\\n            \\n        \\n            }\\n        }\\n           List<Integer> r= new ArrayList();\\n        \\n          for(int i=0;i<p.size();i++){\\n              \\n            if(p.get(i)*2<=a){\\n                r.add(p.get(i)*2);\\n            }\\n        }\\n         p.clear();\\n        \\n     for(int i=0;i<q.size();i++){\\n               p.add(q.get(i));\\n     }\\n       for(int i=0;i<r.size();i++){\\n               p.add(r.get(i));\\n     }   \\n        a++;\\n            k--;\\n        \\n        }\\n        \\nint arr[]=new int[p.size()];\\n        for(int i=0;i<p.size();i++){\\n            arr[i]=p.get(i);\\n        }\\n        return arr;\\n     \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368874,
                "title": "python-explained-0-n-time",
                "content": "Consider\\nn=1 -> [1]\\nn=2 -> [1,2], [2,1]\\nn=3 -> [1,3,2], [2,3,1], [2,1,3]\\nn=4 -> [1,3,2,4], ....\\nn=5 -> [1,5,3,2,4]\\nn=6 -> [1,5,3,  2,6,4]\\n             -Odd--Even--\\nBy looking at the patterns, we can see that some valid sequences have Odd and Even number separated\\n\\nEach element of the current level is made by a combination of Odd and Even elements separated.\\n\\nOur problem let it be f(n) where f(x) gives the beautiful array\\n\\nThen each odd element -> 2*x-1   for x in f(n-1)\\nThen each even element -> 2x       for x in f(n-1)\\nProvided each resultant element is in the range of our current level i,e, 1<=2*x-1<n and 1<2*n<n\\n\\nThe sum of both the odd and even elements one after the other, gives our answer.\\n\\nTime complexity can be optimized to O(n) using memoization. Since this problem at each level just finds the individual elements without repeating intermediate steps (due to memo) so it is of linear time complexity.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        @lru_cache(None)\\n        def helper(n):\\n            if n==1:\\n                return [1]\\n            odd = []\\n            for x in helper(n-1):\\n                if 2*x-1<=n:\\n                    odd.append(2*x-1)\\n            even = []\\n            for x in helper(n-1):\\n                if 2*x<=n:\\n                    even.append(2*x)\\n            return odd+even\\n        return helper(n)",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "Consider\\nn=1 -> [1]\\nn=2 -> [1,2], [2,1]\\nn=3 -> [1,3,2], [2,3,1], [2,1,3]\\nn=4 -> [1,3,2,4], ....\\nn=5 -> [1,5,3,2,4]\\nn=6 -> [1,5,3,  2,6,4]\\n             -Odd--Even--\\nBy looking at the patterns, we can see that some valid sequences have Odd and Even number separated\\n\\nEach element of the current level is made by a combination of Odd and Even elements separated.\\n\\nOur problem let it be f(n) where f(x) gives the beautiful array\\n\\nThen each odd element -> 2*x-1   for x in f(n-1)\\nThen each even element -> 2x       for x in f(n-1)\\nProvided each resultant element is in the range of our current level i,e, 1<=2*x-1<n and 1<2*n<n\\n\\nThe sum of both the odd and even elements one after the other, gives our answer.\\n\\nTime complexity can be optimized to O(n) using memoization. Since this problem at each level just finds the individual elements without repeating intermediate steps (due to memo) so it is of linear time complexity.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        @lru_cache(None)\\n        def helper(n):\\n            if n==1:\\n                return [1]\\n            odd = []\\n            for x in helper(n-1):\\n                if 2*x-1<=n:\\n                    odd.append(2*x-1)\\n            even = []\\n            for x in helper(n-1):\\n                if 2*x<=n:\\n                    even.append(2*x)\\n            return odd+even\\n        return helper(n)",
                "codeTag": "Java"
            },
            {
                "id": 1368852,
                "title": "best-cpp-solution-o-n-beautiful-array",
                "content": "class Solution {\\npublic:\\n     vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) \\n        {\\n            vector<int> tmp;\\n            for (int i : res)\\n            {\\n                if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            }\\n            for (int i : res)\\n            {\\n                if (i * 2 <= N) tmp.push_back(i * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     vector<int> beautifulArray(int N) {\\n        vector<int> res = {1}",
                "codeTag": "Java"
            },
            {
                "id": 1368782,
                "title": "odd-even-simple-pattern-code-with-proper-explanation-and-cases-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        // Logic is start from 1, now firstly firstly make all of them odd and then make all of them even\\n        // it means odd odd odd odd odd ........ even even even\\n        /// by using this method it never possible to get nums[k]*2=nums[i]+nums[j]\\n        // because \\n        \\n        // 1. Case 1: if you consider odd odd odd pair then odd + odd=even and odd*2=even, but they always have gap of 2 minimum.\\n        \\n        // Case 2: odd odd even:- here odd + even=odd, and odd*2= even, so even!=odd;\\n        \\n        // case 3: odd even even:- Same as case 2 , not possible;\\n        \\n        // case 4: even even even: - same as case 1, i.e., always have gap or diff of 2 minimum;\\n        \\n        vector<int>vec={1};\\n        while(vec.size()<n)\\n        {\\n            vector<int>temp;\\n             for(auto x: vec) if(x*2-1<=n) temp.push_back(x*2-1);\\n             for(auto x: vec) if(x*2<=n) temp.push_back(x*2);\\n            vec=temp;\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        // Logic is start from 1, now firstly firstly make all of them odd and then make all of them even\\n        // it means odd odd odd odd odd ........ even even even\\n        /// by using this method it never possible to get nums[k]*2=nums[i]+nums[j]\\n        // because \\n        \\n        // 1. Case 1: if you consider odd odd odd pair then odd + odd=even and odd*2=even, but they always have gap of 2 minimum.\\n        \\n        // Case 2: odd odd even:- here odd + even=odd, and odd*2= even, so even!=odd;\\n        \\n        // case 3: odd even even:- Same as case 2 , not possible;\\n        \\n        // case 4: even even even: - same as case 1, i.e., always have gap or diff of 2 minimum;\\n        \\n        vector<int>vec={1};\\n        while(vec.size()<n)\\n        {\\n            vector<int>temp;\\n             for(auto x: vec) if(x*2-1<=n) temp.push_back(x*2-1);\\n             for(auto x: vec) if(x*2<=n) temp.push_back(x*2);\\n            vec=temp;\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368680,
                "title": "o-n-2-solution-c",
                "content": "```\\nstruct ListNode {\\n        int val;\\n        ListNode *next;\\n        ListNode() : val(0), next(nullptr) {}\\n        ListNode(int x) : val(x), next(nullptr) {}\\n        ListNode(int x, ListNode *next) : val(x), next(next) {}\\n    };\\n    vector<int> beautifulArray(int n) {\\n        vector<vector<int>> p = {{1}, {1, 2}, {1, 3, 2}, {2, 1, 4, 3}, {3,1,2,5,4}, {1,5,3,2,6,4}};\\n        if (n <= 6) {\\n            return p[n-1];\\n        } else {\\n            ListNode* fun = new ListNode(1);\\n            auto it  = fun;\\n            for (int i = 1; i < 6; i++) {\\n                it->next = new ListNode(p[5][i]);\\n                it = it->next;\\n            }\\n            int cycles = 7;\\n            int loop = 8;\\n            int prevLoop = 4;\\n            while (cycles <= n) {\\n                if (cycles == loop) {\\n                    prevLoop = loop;\\n                    loop *= 2;\\n                }\\n                for (it = fun; it != nullptr; it = it->next) {\\n                    if (it->val+prevLoop == cycles) {\\n                        it->next = new ListNode(cycles, it->next);\\n                        break;\\n                    } else if (it->next == nullptr) {\\n                        it->next = new ListNode(cycles);\\n                        break;\\n                    }\\n                }\\n                cycles++;\\n            }\\n            vector<int> out;\\n            while (fun != NULL) {\\n                out.push_back(fun->val);\\n                fun = fun->next;\\n            }\\n            return out;\\n        }\\n    }\\n```\\n\\nI came up with this strange solution through pattern analysis, but I really dont understand why it works. Why does this recurrent pattern of multiples of 2 (4->8->16->32) show up, and why does it not seem to apply to the cases where n = 4 and 5 respectively? Somehow this seemingly inefficient solution also manages to achieve a respectable runtime of 4ms",
                "solutionTags": [],
                "code": "```\\nstruct ListNode {\\n        int val;\\n        ListNode *next;\\n        ListNode() : val(0), next(nullptr) {}\\n        ListNode(int x) : val(x), next(nullptr) {}\\n        ListNode(int x, ListNode *next) : val(x), next(next) {}\\n    };\\n    vector<int> beautifulArray(int n) {\\n        vector<vector<int>> p = {{1}, {1, 2}, {1, 3, 2}, {2, 1, 4, 3}, {3,1,2,5,4}, {1,5,3,2,6,4}};\\n        if (n <= 6) {\\n            return p[n-1];\\n        } else {\\n            ListNode* fun = new ListNode(1);\\n            auto it  = fun;\\n            for (int i = 1; i < 6; i++) {\\n                it->next = new ListNode(p[5][i]);\\n                it = it->next;\\n            }\\n            int cycles = 7;\\n            int loop = 8;\\n            int prevLoop = 4;\\n            while (cycles <= n) {\\n                if (cycles == loop) {\\n                    prevLoop = loop;\\n                    loop *= 2;\\n                }\\n                for (it = fun; it != nullptr; it = it->next) {\\n                    if (it->val+prevLoop == cycles) {\\n                        it->next = new ListNode(cycles, it->next);\\n                        break;\\n                    } else if (it->next == nullptr) {\\n                        it->next = new ListNode(cycles);\\n                        break;\\n                    }\\n                }\\n                cycles++;\\n            }\\n            vector<int> out;\\n            while (fun != NULL) {\\n                out.push_back(fun->val);\\n                fun = fun->next;\\n            }\\n            return out;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564546,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564927,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1565543,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569730,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1729838,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1568403,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1567052,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1572545,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569329,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1573243,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564546,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564927,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1565543,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569730,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1729838,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1568403,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1567052,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1572545,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569329,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1573243,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            }
        ]
    },
    {
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "question_content": "<p>Given the array <code>nums</code>, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code> you have to count the number of valid <code>j&#39;s</code>&nbsp;such that&nbsp;<code>j != i</code> <strong>and</strong> <code>nums[j] &lt; nums[i]</code>.</p>\n\n<p>Return the answer in an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [8,1,2,2,3]\n<strong>Output:</strong> [4,0,1,1,3]\n<strong>Explanation:</strong> \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,5,4,8]\n<strong>Output:</strong> [2,1,0,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,7,7,7]\n<strong>Output:</strong> [0,0,0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 524996,
                "title": "java-beats-100-o-n",
                "content": "Store the count in a bucket and take the running sum.\\n\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] res = new int[nums.length];\\n        \\n        for (int i =0; i < nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        for (int i = 1 ; i <= 100; i++) {\\n            count[i] += count[i-1];    \\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0)\\n                res[i] = 0;\\n            else \\n                res[i] = count[nums[i] - 1];\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] res = new int[nums.length];\\n        \\n        for (int i =0; i < nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        for (int i = 1 ; i <= 100; i++) {\\n            count[i] += count[i-1];    \\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0)\\n                res[i] = 0;\\n            else \\n                res[i] = count[nums[i] - 1];\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535421,
                "title": "java-clean-hashmap-solution-with-explanation",
                "content": "So the idea is:\\nLet\\'s use this input for illustration: [8,1,2,2,3]\\n1. Create a copy of the input array. copy = [8,1,2,2,3]\\n2. Sort the copy array. copy = [1,2,2,3,8]\\n3. Fill the map: number => count (where count is an index in sorted array, so first number with index 0 has 0 numbers less than it, index 1 has 1 number less, etc). We update only first time we enocunter the number so that way we skip duplicates.\\nmap[1]=>0\\nmap[2]=>1\\nmap[3]=>3\\nmap[8]=>4\\n4. We re-use our copy array to get our result, we iterate over original array, and get counts from the map.\\n[4,0,1,1,3]\\n\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819148,
                "title": "python-3-91-11-faster-52ms-time-explanation-added",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\n**2 possible solutions:**\\n1. For every i element, iterate the list with j as index. If i!=j and nums[j]<nums[i], we can update the count for that number. Time: O(n2). Space: O(1)\\n2. This is optimal solution. We can sort the list and store in another temp list. We use dictionary to store the counts and later use it to create result. Time: O(n log n) bcoz of sort. Space: O(n) bcoz of dictionary.\\n\\n**Explanation of solution 2:**\\nnums = 8, 1, 2, 2, 3\\n1. We sort the list bcoz we don\\'t want to keep traversing the list back and forth. After sorting, we get temp = 1, 2, 2, 3, 8\\n2. We traverse temp list. If we find unique element, we know all the previous elements have been recorded. So we add this unique element to the dictionary with index i as value.\\nIf duplicate element is encountered, we don\\'t add it and don\\'t update the value in dictionary.\\n3. After the dictionary is constructed, we create output after doing O(1) lookup in dictionary for nums[i]\\n\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```\\n\\n**If this solution helped, please upvote it for others to take advantage of it and learn their techniques**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 693600,
                "title": "c-99-o-n",
                "content": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> answer;\\n        int i, j;\\n        int count[101] = {0, 0, 0};\\n\\t\\tint len = nums.size();\\n        for(i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        for(i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        for(i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                answer.push_back(0);\\n            else\\n                answer.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> answer;\\n        int i, j;\\n        int count[101] = {0, 0, 0};\\n\\t\\tint len = nums.size();\\n        for(i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        for(i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        for(i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                answer.push_back(0);\\n            else\\n                answer.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 641884,
                "title": "java-o-n-1ms-less-memory-than-100-explained",
                "content": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] buck = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            buck[nums[i]] +=1;\\n        }\\n        \\n        for(int j=1; j<= 100; j++) {\\n            buck[j] += buck[j-1];\\n        }\\n        \\n        for(int k=0; k< nums.length; k++) {\\n            int pos = nums[k];\\n            nums[k] = pos==0 ? 0 : buck[pos-1];\\n        }\\n        \\n        return nums;\\n    }\\n```\\n\\nThis solution maps the numbers in the array to a counter.\\nSince the numbers are between 0 and 100  I create an array of length 101 and iterate over the original array and put each number in the corresponding index in the bucket array. If the original array contains the number 1, number 1 goes to index 1 in the new array.\\n\\nSince the nums array may contain duplicates, in the bucket array I store a counter for each of the numbers, not the number itself. So if the number 1 occurs 3 times in the nums array, in index 1 of the bucket array we store the value 3.\\n\\n4 5 1 3 5 4 4 1 4 5 1 4\\nbecomes\\n0 3 0 1 5 3\\n\\n(0 zeros, 3 ones, 0 twos, 1 three, 5 fours and 3 fives)\\n\\nAfter the bucket array has been populated, I iterate it again from index 1 to index 100 and to each of the values I add the previous value. A similar example with a smaller array:\\n\\n0 3 0 1 5 3\\nbecomes\\n0 3 3 4 9 12\\n\\n(0 numbers are <= 0, 3 numbers are are <= 1, 3 numbers are are <= 2, 4 numbers are are <= 3 and so on.)\\n\\n That way each position contains how many numbers are smaller or equal than the current position.\\n\\nFinally I iterate the original nums array and get the index from bucket corresponding the value of the number from nums - 1 (minus one because without it we also get the ones equal to it and we only want smaller). When doing this I assign the result as the new value in the nums array instead of creating a new array. Also if value is 0 we automatically return 0 as no element can be smaller than it.\\n\\nFor example, if nums array is\\n4 5 1 3 5 4 4 1 4 5 1 4\\n\\nand the final bucket mapping is:\\n0 3 3 4 9 12\\n\\nbuck[4-1] = 4\\nbuck[5-1] = 9\\nbuck[1-1] = 0\\nbuck[3-1] = 3\\nbuck[5-1] = 9\\nbuck[4-1] = 4\\nbuck[4-1] = 4\\nbuck[1-1] = 0\\nbuck[4-1] = 4\\nbuck[5-1] = 9\\nbuck[1-1] = 0\\nbuck[4-1] = 4",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] buck = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            buck[nums[i]] +=1;\\n        }\\n        \\n        for(int j=1; j<= 100; j++) {\\n            buck[j] += buck[j-1];\\n        }\\n        \\n        for(int k=0; k< nums.length; k++) {\\n            int pos = nums[k];\\n            nums[k] = pos==0 ? 0 : buck[pos-1];\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524865,
                "title": "clean-python-3-sorting-and-counting",
                "content": "**Solution 1**\\nRecord index in sorted nums if it didn\\'t appear before.\\nThen just dump it\\'s corresponding index in original nums.\\n\\nTime: O(NlogN)\\nSpace: O(N) for output list\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        indices = {}\\n        for idx, num in enumerate(sorted(nums)):\\n            indices.setdefault(num, idx)\\n        return [indices[num] for num in nums]\\n```\\n\\n\\n**Soluiton 2**\\nRefer to [this solution](https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/discuss/524996/JAVA-beats-100-O(n)) of @equ1n0x, we are already told the range of the given numbers is between 1 and 100.\\nSo we can easily count each number and sum their prefix and dump.\\n\\nTime: O(N)\\nSpace: O(N) for output list\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count = [0] * 102\\n        for num in nums:\\n            count[num+1] += 1\\n        for i in range(1, 102):\\n            count[i] += count[i-1]\\n        return [count[num] for num in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        indices = {}\\n        for idx, num in enumerate(sorted(nums)):\\n            indices.setdefault(num, idx)\\n        return [indices[num] for num in nums]\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count = [0] * 102\\n        for num in nums:\\n            count[num+1] += 1\\n        for i in range(1, 102):\\n            count[i] += count[i-1]\\n        return [count[num] for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214105,
                "title": "c-solution-along-with-explanation-and-time-complexity",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED !!!**\\n\\n*Overload the comments section with doubts and praises if you have.!!!*\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int, int> m;\\n        vector<int> vec = nums;\\n        int n = nums.size();\\n        \\n        // Sort vec in ascending order\\n        // T.C = O(nlogn)\\n        sort(vec.begin(), vec.end());\\n        \\n        // Put the values in hash-map according to their values corresponding to their places in nums \\n        // T.C = O(n)\\n        for(int i=n-1; i>=0; i--) {\\n            m[vec[i]] = i;\\n        }\\n        \\n        // Saving the result again in nums, b\\'cos space complexity matters XD\\n        // T.C = O(n)\\n        for(int i=0; i<n; i++) {\\n            nums[i] = m[nums[i]];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int, int> m;\\n        vector<int> vec = nums;\\n        int n = nums.size();\\n        \\n        // Sort vec in ascending order\\n        // T.C = O(nlogn)\\n        sort(vec.begin(), vec.end());\\n        \\n        // Put the values in hash-map according to their values corresponding to their places in nums \\n        // T.C = O(n)\\n        for(int i=n-1; i>=0; i--) {\\n            m[vec[i]] = i;\\n        }\\n        \\n        // Saving the result again in nums, b\\'cos space complexity matters XD\\n        // T.C = O(n)\\n        for(int i=0; i<n; i++) {\\n            nums[i] = m[nums[i]];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575760,
                "title": "java-simple-to-complex-explained-0-ms-faster-than-100-less-space-than-100-5-lines-of-code",
                "content": "Naive, for every number count every number smaller than it: \\n\\nO(n^2) time\\nO(n) space\\n13 ms fast than 37%\\n40 MB less space than 100%\\n\\n```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        int count;\\n        for(int i=0; i<nums.length; i++) {\\n            count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(i!=j && nums[j] < nums[i]) \\n                    count++;\\n            }    \\n            answer[i] = count;\\n        }\\n        return answer;\\n    }\\n```\\n\\nIntuition: count the number occurrences of each number. The count of numbers smaller than 1 is how many 0\\'s are in the array. The count of numbers smaller than 2 is how many 0\\'s plus how many 1\\'s. The count of numbers smaller than x is how many x-1, x-2, x-3... exist in the array.\\n\\nSolution: count the number of occurrences in the array of each number from 0 to 100. Sum the numbers so that in index i you have the sum of all counts of i-1, i-2,... Replace in the original array each number with the count of numbers smaller than itself. \\n\\nWe can modify the original array and save space to reach O(1). Don\\'t do this in production code!\\n\\nO(n) time, n the size of the array (actually O(n + m) where m is the max value of a number, but m is 100 max) \\nO(1) space (actually O(m) where m is the max value of a number, but m is 100 max) \\n1 ms fast than 99.9%\\n39.3 MB less space than 100%\\n\\n```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] bucket = new int[101];\\n        int[] count = new int[101];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]]++;\\n\\n        for(int i=1; i<count.length; i++) \\n            count[i] = count[i-1] + bucket[i-1];\\n        \\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = count[nums[i]];\\n        \\n        return nums;\\n    }\\n```\\n\\nWe can actually use only 1 array. \\n\\nO(n) time\\nO(1) space\\n0 ms fast than 100%\\n\\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]+1]++;\\n\\t\\t\\t\\n        for(int i=0; i<101; i++) \\n            bucket[i+1] += bucket[i];\\n\\t\\t\\t\\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = bucket[nums[i]];\\n\\t\\t\\t\\n        return nums;\\n```\\n\\n\\nfor fun, let\\'s wrap it up into just 5 lines of code: \\n\\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; bucket[nums[i]+1]++, i++);\\n        for(int i=0; i<101; bucket[i+1] += bucket[i], i++);\\n        for(int i=0; i<nums.length; nums[i] = bucket[nums[i]], i++);\\n        return nums;\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        int count;\\n        for(int i=0; i<nums.length; i++) {\\n            count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(i!=j && nums[j] < nums[i]) \\n                    count++;\\n            }    \\n            answer[i] = count;\\n        }\\n        return answer;\\n    }\\n```\n```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] bucket = new int[101];\\n        int[] count = new int[101];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]]++;\\n\\n        for(int i=1; i<count.length; i++) \\n            count[i] = count[i-1] + bucket[i-1];\\n        \\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = count[nums[i]];\\n        \\n        return nums;\\n    }\\n```\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]+1]++;\\n\\t\\t\\t\\n        for(int i=0; i<101; i++) \\n            bucket[i+1] += bucket[i];\\n\\t\\t\\t\\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = bucket[nums[i]];\\n\\t\\t\\t\\n        return nums;\\n```\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; bucket[nums[i]+1]++, i++);\\n        for(int i=0; i<101; bucket[i+1] += bucket[i], i++);\\n        for(int i=0; i<nums.length; nums[i] = bucket[nums[i]], i++);\\n        return nums;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139277,
                "title": "easy-100-faster-c-optimised-code",
                "content": "Input: nums = [8,1,2,2,3]\\nOutput: [4,0,1,1,3]\\n\\nsnum=sorted array(nums) = [1,2,2,3,8]\\nmp=(snum[i],i) (tail to head insertion in map)\\n8 4\\n3 3\\n2 2=>1\\n1 0\\n\\nnums[i]=maps[nums[i]]\\nnums=[4,0,1,1,3]=output\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n    \\n        map<int,int> mp;    \\n        int n=nums.size();\\n        vector<int> snum=nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        for(int i=n-1;i>=0;i--)\\n            mp[snum[i]]=i;\\n        \\n        for(int i=0;i<n;i++)\\n            nums[i]=mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n    \\n        map<int,int> mp;    \\n        int n=nums.size();\\n        vector<int> snum=nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        for(int i=n-1;i>=0;i--)\\n            mp[snum[i]]=i;\\n        \\n        for(int i=0;i<n;i++)\\n            nums[i]=mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547953,
                "title": "faster-than-98-32-memory-usage-less-than-100-00-2-lines-of-code",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053117,
                "title": "python-simple-one-liner",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        return [sorted(nums).index(i) for i in nums]\\n```\\nExplanation:\\n* ```sorted(nums)``` returns a sorted list e.g. ```[1,2,2,3,8]```\\n* The index of the ordered list actually shows how many numbers are smaller than the current number\\n* ```.index(i)``` returns the index of i in the list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        return [sorted(nums).index(i) for i in nums]\\n```\n```sorted(nums)```\n```[1,2,2,3,8]```\n```.index(i)```",
                "codeTag": "Java"
            },
            {
                "id": 553078,
                "title": "python3-easy-bucket-sort-o-n-beats-100",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        buckets = [0] * 101\\n        \\n        for num in nums:\\n            buckets[num] += 1\\n            \\n        previous = 0    \\n        for i, bucket in enumerate(buckets):\\n            if bucket != 0:\\n                buckets[i] = previous \\n                previous += bucket \\n                \\n        return [buckets[num] for num in nums]        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        buckets = [0] * 101\\n        \\n        for num in nums:\\n            buckets[num] += 1\\n            \\n        previous = 0    \\n        for i, bucket in enumerate(buckets):\\n            if bucket != 0:\\n                buckets[i] = previous \\n                previous += bucket \\n                \\n        return [buckets[num] for num in nums]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 525004,
                "title": "javascript-clean-solution-using-array-sort",
                "content": "**Code (JavaScript):**\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const sorted = Array.from(nums).sort((n1, n2) => n2 - n1);\\n  const map = new Map(sorted.map((num, index) => [num, nums.length - index - 1]));\\n  return nums.map(num => map.get(num));\\n}\\n```\\n\\n**Complexity:**\\n\\nTime `O(NlogN)`\\nSpace `O(N)`\\n\\n**Example:**\\nnums `[8,1,2,2,3]`\\n\\n1. Sort `nums` by descending order\\n    - sorted `[8,3,2,2,1]`\\n2. Create `map` with counts\\n    - map: `{8:4,3:3,2:1,1:0}`\\n3. Return an array with counts stored in `map`\\n    - result: `[4,0,1,1,3]`\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const sorted = Array.from(nums).sort((n1, n2) => n2 - n1);\\n  const map = new Map(sorted.map((num, index) => [num, nums.length - index - 1]));\\n  return nums.map(num => map.get(num));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525124,
                "title": "1-line-python-solution",
                "content": "```\\nclass Solution:\\n  def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    return [sorted(nums).index(a) for a in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    return [sorted(nums).index(a) for a in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548851,
                "title": "here-s-my-solution-python3",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        result = []\\n        tempNums = nums.copy()\\n        nums.sort()\\n        for n in tempNums:\\n            result.append(nums.index(n))\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        result = []\\n        tempNums = nums.copy()\\n        nums.sort()\\n        for n in tempNums:\\n            result.append(nums.index(n))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288341,
                "title": "java-solution-0ms-faster-than-100-submissions",
                "content": "***Please upvote the post if find the solution useful!!!!***\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] bucket = new int[102];\\n        for(int i=0;i<nums.length;i++)        \\n            bucket[nums[i]+1]++;\\n        \\n        for(int i=0;i<101;i++)\\n            bucket[i+1] = bucket[i+1]+bucket[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            nums[i] = bucket[nums[i]];\\n        \\n        return nums;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] bucket = new int[102];\\n        for(int i=0;i<nums.length;i++)        \\n            bucket[nums[i]+1]++;\\n        \\n        for(int i=0;i<101;i++)\\n            bucket[i+1] = bucket[i+1]+bucket[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            nums[i] = bucket[nums[i]];\\n        \\n        return nums;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642495,
                "title": "javascript-solution",
                "content": "```\\nlet sorted = nums.slice().sort((a,b) => a - b);\\nlet result = [];\\nfor(let i=0; i<nums.length; i++){\\n\\tresult.push(sorted.indexOf(nums[i]));\\n}\\nreturn result;\\n```",
                "solutionTags": [],
                "code": "```\\nlet sorted = nums.slice().sort((a,b) => a - b);\\nlet result = [];\\nfor(let i=0; i<nums.length; i++){\\n\\tresult.push(sorted.indexOf(nums[i]));\\n}\\nreturn result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057145,
                "title": "python-3-solution-with-explaination",
                "content": "The logic here might confuse you, but its a *ahaa !* moment when you realize it.\\n\\nWe basically need to get the count of numbers smaller than a given number. If this array were to be filled with distinct elements, we would just sort it and get the counts by just accessing their respective index values.\\n\\nfor example :  \\nA = [ 9,4,3,1,6 ] \\n\\nwhen you sort it, you get : [ 1 , 3 , 4 , 6 , 9  ]\\nso if you pick any number, it\\'s index value would denote the position of the element in the sorted array, thereby stating the count of values that are **smaller than it**!   \\n[ 1 =>0, 3 =>1, 4 =>2, 6 => 3, 9 => 4]\\n\\nBut in this question the array can have duplicates. Hence only using the above approach would not solve our issue as we need to get rid of duplicates. \\nFor example :  [ 3 , 3, 5, 8 ] with just the above approach would give us  [ 0, 1 , 2, 3 ], which is wrong, as 3 at index 1 does not have any number smaller than it before it.\\n\\nHence we take the help of a hash map to solve the issue of not considering duplicate values.\\nSo ,\\n1. Go through the same process as above ie sort the array\\n2. Use a hash map to store the element as key and its corresponding index as the value.\\n\\t*Note : Here we ignore the elements that already exist in the hashMap while inserting their values to avoid rewritting of index.*\\n3. Bingo, our answer is ready in the hash map. Now iterate the nums and display its respective hash value.\\n\\nExample: \\n[ 3, 3, 5, 8 ]\\nHash = { }\\n\\n**index : process**\\n**0** : 3 is not in Hash, hence insert it => { 3 : **0** }\\n**1** : 3 is in the Hash, so ignore it this time\\n**2** : 5 is not in the Hash, hence insert it => { 3 : **0**, 5 : **2** }\\n**3** : 8 is not in the Hash, hence insert it => {  3 : **0**, 5 : **2** , 8 : **3** }\\n\\nThere you go ! Use the hash map and extract the counts for respective numbers in nums array.\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n      d = {}\\n      for index,value in enumerate(sorted(nums)):\\n        if value not in d:\\n          d[value] = index\\n          \\n      #iterate through the nums and fetch its corresponding hash table value \\n      ans = [d[value] for value in nums]\\n      return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n      d = {}\\n      for index,value in enumerate(sorted(nums)):\\n        if value not in d:\\n          d[value] = index\\n          \\n      #iterate through the nums and fetch its corresponding hash table value \\n      ans = [d[value] for value in nums]\\n      return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673630,
                "title": "python-3-tow-solutions",
                "content": "1. Sorting+dictionary\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tdic = {}\\n\\tsorted_list = sorted(nums)\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tif sorted_list[i] not in dic:\\n\\t\\t\\tdic[sorted_list[i]] = i\\n\\treturn [dic[n] for n in nums]\\n```\\n\\n2. linear time complexity and constant space\\n\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tsmaller = [0]*101\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tsmaller[nums[i]]+=1\\n\\n\\tfor n in range(1, 101):\\n\\t\\tsmaller[n]+=smaller[n-1]\\n\\n\\tfor i in range(0, l):\\n\\t\\tnums[i] = smaller[nums[i]-1] if nums[i]!=0 else 0\\n\\treturn nums\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tdic = {}\\n\\tsorted_list = sorted(nums)\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tif sorted_list[i] not in dic:\\n\\t\\t\\tdic[sorted_list[i]] = i\\n\\treturn [dic[n] for n in nums]\\n```\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tsmaller = [0]*101\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tsmaller[nums[i]]+=1\\n\\n\\tfor n in range(1, 101):\\n\\t\\tsmaller[n]+=smaller[n-1]\\n\\n\\tfor i in range(0, l):\\n\\t\\tnums[i] = smaller[nums[i]-1] if nums[i]!=0 else 0\\n\\treturn nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2837597,
                "title": "faster-than-100-simple-javascript-hashmap-solution",
                "content": "**Algorithm**\\n\\n`input: [8, 1, 2, 2, 3]`\\n* declare a new array with the input array sorted in ascending order\\n+++ The elements\\'s index shows the amount of numbers that are smaller.+++\\n\\n`sorted: [1, 2, 2, 3, 8]`\\n* iterate through sorted array and set the number and its index to a Map (skip any that already exist in the Map)\\n\\n`map: {\\n1 => 0,\\n2 => 1,\\n3 => 3,\\n8 => 4\\n}`\\n* iterate through the original input and create a new array with the current number\\'s value from the Map\\n\\n`output: [4, 0, 1, 1, 3]`\\n\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let hash = new Map();\\n    let sorted = nums.slice().sort((a,b) => a - b);\\n    sorted.forEach((number, idx) => hash.has(number)? null: hash.set(number, idx));\\n    return nums.map(x => hash.get(x));\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a11f5325-2826-4f0b-8a7c-8d3f9931ef4a_1669076360.1411996.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let hash = new Map();\\n    let sorted = nums.slice().sort((a,b) => a - b);\\n    sorted.forEach((number, idx) => hash.has(number)? null: hash.set(number, idx));\\n    return nums.map(x => hash.get(x));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526946,
                "title": "c-two-solutions",
                "content": "First solution - **Brute force**\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n\\tvector<int> res;\\n\\tint i = 0, n = nums.size();\\n\\twhile (i < n) {\\n\\t\\tint count = 0, j = 0;\\n\\t\\twhile (j < n) {\\n\\t\\t\\tif (j != i && nums[i] > nums[j]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tres.push_back(count);\\n\\t\\ti++;\\n\\t}\\n\\treturn res;\\n}\\n```\\nSecond solution - **Using sort and map**\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        vector<int> arr = nums;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (map.find(arr[i]) == map.end()) {\\n                map[arr[i]] = i;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            nums[i] = map[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n\\tvector<int> res;\\n\\tint i = 0, n = nums.size();\\n\\twhile (i < n) {\\n\\t\\tint count = 0, j = 0;\\n\\t\\twhile (j < n) {\\n\\t\\t\\tif (j != i && nums[i] > nums[j]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tres.push_back(count);\\n\\t\\ti++;\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        vector<int> arr = nums;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (map.find(arr[i]) == map.end()) {\\n                map[arr[i]] = i;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            nums[i] = map[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526903,
                "title": "1365-javascript-1-line-solution",
                "content": "I\\'m \\uD83E\\uDD1C\\u23AFS\\u23AFT\\u23AFR\\u23AFE\\u23AFT\\u23AFC\\u23AFH\\u23AFI\\u23AFN\\u23AFG\\u23AF\\uD83E\\uDD1B the definition a bit here.\\n\\nBut, then again, aren\\'t I always? \\uD83D\\uDE1C\\n\\n> Runtime: **92 ms**, faster than *84.06%* of JavaScript online submissions\\n> Memory Usage: **41 MB**, less than *17.24%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ),\\n  );\\n```\\n\\nHere is the boring multiple-line solution.\\n\\n> Runtime: **92 ms**, faster than *85.25%* of JavaScript online submissions\\n> Memory Usage: **40.9 MB**, less than *20.23%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums => {\\n  const map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  );\\n  return nums.map(n => map.get(n));\\n};\\n```\\n\\nHere is another 1-line solution where the `Map` object is created in the\\nparameters of the original function. Some people seem to prefer this technique.\\n\\n> Runtime: **92 ms**, faster than *85.25%* of JavaScript online submissions\\n> Memory Usage: **41.1 MB**, less than *17.95%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n const smallerNumbersThanCurrent = (\\n  nums,\\n  map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  ),\\n) => nums.map(n => map.get(n));\\n```\\n\\nCreating the `Map` object outside of the `map` function is important for\\nperformance reasons. Recreating the `Map` object on every iteration of the `map`\\nfunction slows execution significantly.\\n\\n> Runtime: **1004 ms**, faster than *5.58%* of JavaScript online submissions\\n> Memory Usage: **45.4 MB**, less than *5.05%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  nums.map(n =>\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ).get(n),\\n  );\\n```\\n\\nAnd here is the original solution with the unnecessary `reverse` function.\\n\\n> Runtime: **100 ms**, faster than *49.01%* of JavaScript online submissions\\n> Memory Usage: **40.3 MB**, less than *14.09%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => a - b)\\n        .map((val, idx) => [val, idx])\\n        .reverse(),\\n    ),\\n  );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ),\\n  );\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums => {\\n  const map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  );\\n  return nums.map(n => map.get(n));\\n};\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n const smallerNumbersThanCurrent = (\\n  nums,\\n  map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  ),\\n) => nums.map(n => map.get(n));\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  nums.map(n =>\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ).get(n),\\n  );\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => a - b)\\n        .map((val, idx) => [val, idx])\\n        .reverse(),\\n    ),\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841228,
                "title": "java-best-time-o-n-counting-each-occurrence",
                "content": "```\\nclass Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        var buck = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            buck[nums[i]]++;                                // count each occurence\\n      \\n        for (int i = 1; i < buck.length; i++)\\n            buck[i] += buck[i - 1];                         // calc how manu numbers are smaller\\n\\n        for (int i = 0; i < nums.length; i++)\\n            nums[i] = nums[i] == 0 ? 0 : buck[nums[i] - 1]; // fill resulting array\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        var buck = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            buck[nums[i]]++;                                // count each occurence\\n      \\n        for (int i = 1; i < buck.length; i++)\\n            buck[i] += buck[i - 1];                         // calc how manu numbers are smaller\\n\\n        for (int i = 0; i < nums.length; i++)\\n            nums[i] = nums[i] == 0 ? 0 : buck[nums[i] - 1]; // fill resulting array\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663898,
                "title": "two-line-solution-with-python",
                "content": "#### Less efficient way of solving\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l1 = sorted(nums)\\n        return [l1.index(i) for i in nums]\\n```\\n\\n#### Solution with relatively faster runtime\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        mydict = dict()\\n        for k, v in enumerate(sorted(nums)):\\n            if v not in mydict:\\n                mydict[v] = k\\n        return [mydict[item] for item in nums]\\n```\\n![image.png](https://assets.leetcode.com/users/images/4e946e69-28b8-4895-a90b-a35340856b63_1672588044.6296315.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l1 = sorted(nums)\\n        return [l1.index(i) for i in nums]\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        mydict = dict()\\n        for k, v in enumerate(sorted(nums)):\\n            if v not in mydict:\\n                mydict[v] = k\\n        return [mydict[item] for item in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588833,
                "title": "java-clean-code-with-time-complexity",
                "content": "```\\nExplanation:\\nstep 1. count[] array for number counting of given array, sum[] array to store sum count upto any specific number(array length is 100 as range is given 0<=nums<=100)\\nstep 2. traverse given array and update count of each number.\\nstep3. traverse 0 to 100 and update sum count of each number\\neg:\\nsum[3] = sum[2]+count[2](as sum of two does n\\'t include count of 2).\\nstep4. return sum count based on your given input array.\\nTC=O(n)\\nSC= O(n)+O(n) = O(n)\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] sum = new int[101];\\n        for(int i=0; i<nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n\\n        for(int i=1; i<101; i++) {\\n            sum[i] = count[i-1] + sum[i-1];\\n        }\\n        for(int i=0; i<nums.length; i++) {\\n            nums[i] = sum[nums[i]];\\n        }\\n        return nums;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nExplanation:\\nstep 1. count[] array for number counting of given array, sum[] array to store sum count upto any specific number(array length is 100 as range is given 0<=nums<=100)\\nstep 2. traverse given array and update count of each number.\\nstep3. traverse 0 to 100 and update sum count of each number\\neg:\\nsum[3] = sum[2]+count[2](as sum of two does n\\'t include count of 2).\\nstep4. return sum count based on your given input array.\\nTC=O(n)\\nSC= O(n)+O(n) = O(n)\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] sum = new int[101];\\n        for(int i=0; i<nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n\\n        for(int i=1; i<101; i++) {\\n            sum[i] = count[i-1] + sum[i-1];\\n        }\\n        for(int i=0; i<nums.length; i++) {\\n            nums[i] = sum[nums[i]];\\n        }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3774860,
                "title": "best-two-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code1\\n\\n```\\nclass Solution {\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] output = new int[nums.length];\\n    int[] count = new int[101]; // since the numbers are between 0 and 100\\n    for (int num : nums) {\\n        count[num]++;\\n    }\\n    for (int i = 1; i <= 100; i++) {\\n        count[i] += count[i-1];\\n    }\\n    for (int i = 0; i < nums.length; i++) {\\n        output[i] = nums[i] == 0 ? 0 : count[nums[i]-1];\\n    }\\n    return output;\\n}\\n}\\n```\\n\\n\\n# Code2\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int output[] = new int[nums.length];\\n        ArrayList<Integer> list = (ArrayList<Integer>) Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        Collections.sort(list);\\n\\n        for (int i = 0; i <= nums.length-1 ; i++)\\n        {\\n            int n = 0;\\n            int index = list.indexOf( nums[i] );\\n\\n            for (int j = index-1; j >= 0 ; j-- )\\n            {\\n                if (nums[i] > list.get(j) )\\n                    n++;\\n            }\\n                output[i] = n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/97d10918-e64a-449d-b61b-998bb9e52937_1689529870.2512202.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] output = new int[nums.length];\\n    int[] count = new int[101]; // since the numbers are between 0 and 100\\n    for (int num : nums) {\\n        count[num]++;\\n    }\\n    for (int i = 1; i <= 100; i++) {\\n        count[i] += count[i-1];\\n    }\\n    for (int i = 0; i < nums.length; i++) {\\n        output[i] = nums[i] == 0 ? 0 : count[nums[i]-1];\\n    }\\n    return output;\\n}\\n}\\n```\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int output[] = new int[nums.length];\\n        ArrayList<Integer> list = (ArrayList<Integer>) Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        Collections.sort(list);\\n\\n        for (int i = 0; i <= nums.length-1 ; i++)\\n        {\\n            int n = 0;\\n            int index = list.indexOf( nums[i] );\\n\\n            for (int j = index-1; j >= 0 ; j-- )\\n            {\\n                if (nums[i] > list.get(j) )\\n                    n++;\\n            }\\n                output[i] = n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526266,
                "title": "o-n-o-nlogn-o-n-2-3-different-solutions-in-go",
                "content": "## 1. Count the number of occurrences\\n\\n- Time Complexity: O(N) (N + 100 + N)\\n- Space Complexity: O(1) (101 + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.1 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  occurrences := [101]int{}\\n  for _, num := range nums {\\n    occurrences[num]++\\n  }\\n  prevOccurrences := occurrences[0]\\n  occurrences[0] = 0\\n  for i := range occurrences[1:] {\\n    occurrences[i+1], prevOccurrences = prevOccurrences, prevOccurrences+occurrences[i+1]\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = occurrences[num]\\n  }\\n  return counts\\n}\\n```\\n\\n## 2-1. Sort and binary search\\n\\n- Time Complexity: O(NlogN) (N + NlogN + NlogN)\\n- Space Complexity: O(N) (N + logN + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.2 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n for i, num := range nums {\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n }\\n return counts\\n}\\n```\\n\\n## 2-2. Sort and binary search with cache\\n\\n- Time Complexity: O(NlogN) (N + NlogN + NlogN)\\n- Space Complexity: O(N) (N + logN + N + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.5 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, num := range nums {\\n   if count, ok := cache[num]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n   cache[num] = counts[i]\\n }\\n return counts\\n}\\n```\\n\\n## 2-3. Sort and pre-calculate the index of each number as map\\n\\nref: https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/discuss/525004/JavaScript-Clean-solution-using-array-sort\\n\\n- Time Complexity: O(NlogN) (N + NlogN + N + N)\\n- Space Complexity: O(N) (N + logN + N + answer)\\n\\n> Runtime: 4 ms (faster than 95.08%)\\n> Memory Usage: 3.5 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  sortedNums := make([]int, len(nums))\\n  copy(sortedNums, nums)\\n  sort.Ints(sortedNums)\\n  countMap := map[int]int{}\\n  for i, num := range sortedNums {\\n    if _, ok := countMap[num]; !ok {\\n      countMap[num] = i\\n    }\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = countMap[num]\\n  }\\n  return counts\\n}\\n```\\n\\n## 3-1. Brute force\\n\\n- Time Complexity: O(N^2)\\n- Space Complexity: O(1)\\n\\n> Runtime: 12 ms (faster than 100.00%)\\n> Memory Usage: 3.1 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n for i, current := range nums {\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n }\\n return counts\\n}\\n```\\n\\n## 3-2. Brute force with cache\\n\\n- Time Complexity: O(N^2)\\n- Space Complexity: O(N) (N + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.4 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, current := range nums {\\n   if count, ok := cache[current]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n   cache[current] = counts[i]\\n }\\n return counts\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  occurrences := [101]int{}\\n  for _, num := range nums {\\n    occurrences[num]++\\n  }\\n  prevOccurrences := occurrences[0]\\n  occurrences[0] = 0\\n  for i := range occurrences[1:] {\\n    occurrences[i+1], prevOccurrences = prevOccurrences, prevOccurrences+occurrences[i+1]\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = occurrences[num]\\n  }\\n  return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n for i, num := range nums {\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n }\\n return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, num := range nums {\\n   if count, ok := cache[num]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n   cache[num] = counts[i]\\n }\\n return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  sortedNums := make([]int, len(nums))\\n  copy(sortedNums, nums)\\n  sort.Ints(sortedNums)\\n  countMap := map[int]int{}\\n  for i, num := range sortedNums {\\n    if _, ok := countMap[num]; !ok {\\n      countMap[num] = i\\n    }\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = countMap[num]\\n  }\\n  return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n for i, current := range nums {\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n }\\n return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, current := range nums {\\n   if count, ok := cache[current]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n   cache[current] = counts[i]\\n }\\n return counts\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526057,
                "title": "javascript-and-c-solutions",
                "content": "**Solution #1 - Brute-Force:**\\n\\nBrute-force check each pair `i`, `j`.\\n\\n**Runtime:** O(N<sup>2</sup>)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = A => {\\n    let N = A.length;\\n    let ans = Array(N).fill(0);\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < N; ++j)\\n            if (i != j && A[i] > A[j])\\n                ++ans[i];\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A) {\\n        int N = A.size();\\n        VI ans(N);\\n        for (auto i = 0; i < N; ++i)\\n            for (auto j = 0; j < N; ++j)\\n                if (i != j && A[i] > A[j])\\n                    ++ans[i];\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution #2 - Counting Sort:**\\n\\nLet `cnt` be `101` \"buckets\", where each index corresponds to each value from `0` to `100` inclusive.  The value at each index is the count of that value.\\n\\n**Runtime:** O(N)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = (A, cnt = Array(101).fill(0), ans = []) => {\\n    for (let x of A)\\n        ++cnt[x];\\n    for (let i = 1; i < cnt.length; ++i)\\n        cnt[i] += cnt[i - 1];\\n    for (let x of A)\\n        ans.push(x == 0 ? 0 : cnt[x - 1]);\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI cnt = VI(101), VI ans = {}) {\\n        for (auto x: A)\\n            ++cnt[x];\\n        for (auto i = 1; i < cnt.size(); ++i)\\n            cnt[i] += cnt[i - 1];\\n        for (auto x: A)\\n            ans.push_back(x == 0 ? 0 : cnt[x - 1]);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution #3 - Sort & O(logN) Lookup:**\\n\\nSort `A` in a multiset `S`, then lookup each value in `A` by it\\'s index in `S` to formulate the answer.\\n\\n**Runtime:** O(N * logN)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = (A, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    let find = (x, i = 0, j = S.length - 1, ans = 0) => {\\n        while (i <= j) {\\n            let k = (i + j) >> 1;\\n            if (x <= S[k]) {\\n                ans = k;\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        return ans;\\n    };\\n    for (let x of A)\\n        ans.push(find(x));\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto x: A)\\n            ans.push_back(distance(S.begin(), S.find(x)));\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution #4 - Sort & O(1) Lookup:**\\n\\nSort `A` and store each key `x` in a map `m` whose value is the sorted index of `x`.\\n\\n**Runtime:** O(N * logN)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = (A, m = {}, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    for (let i = 0; i < S.length; ++i)\\n        m[S[i]] = m[S[i]] >= 0 ? m[S[i]] : i;\\n    for (let x of A)\\n        ans.push(m[x]);\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    using Map = unordered_map<int, int>;\\n    VI smallerNumbersThanCurrent(VI& A, Map m = {}, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto it = S.begin(); it != S.end(); ++it)\\n            if (m.find(*it) == m.end())\\n                m[*it] = distance(S.begin(), it);\\n        for (auto x: A)\\n            ans.push_back(m[x]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet smallerNumbersThanCurrent = A => {\\n    let N = A.length;\\n    let ans = Array(N).fill(0);\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < N; ++j)\\n            if (i != j && A[i] > A[j])\\n                ++ans[i];\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A) {\\n        int N = A.size();\\n        VI ans(N);\\n        for (auto i = 0; i < N; ++i)\\n            for (auto j = 0; j < N; ++j)\\n                if (i != j && A[i] > A[j])\\n                    ++ans[i];\\n        return ans;\\n    }\\n};\\n```\n```\\nlet smallerNumbersThanCurrent = (A, cnt = Array(101).fill(0), ans = []) => {\\n    for (let x of A)\\n        ++cnt[x];\\n    for (let i = 1; i < cnt.length; ++i)\\n        cnt[i] += cnt[i - 1];\\n    for (let x of A)\\n        ans.push(x == 0 ? 0 : cnt[x - 1]);\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI cnt = VI(101), VI ans = {}) {\\n        for (auto x: A)\\n            ++cnt[x];\\n        for (auto i = 1; i < cnt.size(); ++i)\\n            cnt[i] += cnt[i - 1];\\n        for (auto x: A)\\n            ans.push_back(x == 0 ? 0 : cnt[x - 1]);\\n        return ans;\\n    }\\n};\\n```\n```\\nlet smallerNumbersThanCurrent = (A, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    let find = (x, i = 0, j = S.length - 1, ans = 0) => {\\n        while (i <= j) {\\n            let k = (i + j) >> 1;\\n            if (x <= S[k]) {\\n                ans = k;\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        return ans;\\n    };\\n    for (let x of A)\\n        ans.push(find(x));\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto x: A)\\n            ans.push_back(distance(S.begin(), S.find(x)));\\n        return ans;\\n    }\\n};\\n```\n```\\nlet smallerNumbersThanCurrent = (A, m = {}, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    for (let i = 0; i < S.length; ++i)\\n        m[S[i]] = m[S[i]] >= 0 ? m[S[i]] : i;\\n    for (let x of A)\\n        ans.push(m[x]);\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    using Map = unordered_map<int, int>;\\n    VI smallerNumbersThanCurrent(VI& A, Map m = {}, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto it = S.begin(); it != S.end(); ++it)\\n            if (m.find(*it) == m.end())\\n                m[*it] = distance(S.begin(), it);\\n        for (auto x: A)\\n            ans.push_back(m[x]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718411,
                "title": "java-o-nlogn-soln-using-sort-map",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans = nums.clone();\\n        int count = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;){\\n            if(i==nums.length-1 || nums[i]!=nums[i+1]){\\n                hm.put(nums[i],count);\\n                count = (i+1); \\n            }\\n            i++; \\n        } \\n        \\n        for(int i=0;i<nums.length;i++)\\n            ans[i] = hm.get(ans[i]);\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans = nums.clone();\\n        int count = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;){\\n            if(i==nums.length-1 || nums[i]!=nums[i+1]){\\n                hm.put(nums[i],count);\\n                count = (i+1); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1419341,
                "title": "javascript-elegant-o-n-solution",
                "content": "\\nThe key thing to understand here is that the numbers are in the **range of 0 to 100**.\\nThis allows us to compute the amount of smaller numbers for every possible number in constant time.\\n\\nLet\\'s define: **smaller(n) = amount of numbers smaller than n in nums**.\\n\\nWe start off by initializing two arrays:\\n\\n```\\nconst frequencies = new Array(101).fill(0);\\nconst smaller = new Array(101).fill(0);\\n```\\n\\nThen we want to compute what is the frequency of any given 0 <= n <= 100 in the array:\\n\\n```\\nnums.forEach(num => frequencies[num]++);\\n```\\n\\nNow for the important part:\\n\\nWe will compute **smaller(n)** for every **0 <= n <= 100**.\\n\\n**The value of smaller(n) is how many numbers are smaller than the number before it plus the frequency of that number in nums.**\\n\\n*(If that sentence didn\\'t make sense to you, read it again or try playing with some examples. Continue reading after you\\'re comfortable with the idea)*\\n\\nNotice how this is exactly the definition from the beginning.\\n\"how many numbers are smaller than the number before it\" is just **smaller(n-1)**.\\n\\nSo in other words: **smaller(n) = smaller(n-1) + frequency(n-1)**\\n\\nThis is great, we can now just compute smaller(n) on the go:\\n\\n```\\n for (let i = 1; i < 101; i++) {\\n   smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n}\\n```\\n\\nAt last, we actually don\\'t want every smaller(n), just the ones from the nums array, and in the same order. So we will map every num in nums to smaller(num):\\n\\n```\\nreturn nums.map(num => smaller[num]);\\n```\\n\\nAnd this is the entire code:\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const frequencies = new Array(101).fill(0);\\n  const smaller = new Array(101).fill(0);\\n\\n  nums.forEach(num => frequencies[num]++);\\n\\n  for (let i = 1; i < 101; i++) {\\n    smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n  }\\n\\n  return nums.map(num => smaller[num]);\\n}\\n```\\n\\n**Side note:** this method is often described as \"dynamic programming\". Basically, we broke down the value of smaller(n) to a simpler sub-problem and used it to optimize the computation of smaller(n).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst frequencies = new Array(101).fill(0);\\nconst smaller = new Array(101).fill(0);\\n```\n```\\nnums.forEach(num => frequencies[num]++);\\n```\n```\\n for (let i = 1; i < 101; i++) {\\n   smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n}\\n```\n```\\nreturn nums.map(num => smaller[num]);\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const frequencies = new Array(101).fill(0);\\n  const smaller = new Array(101).fill(0);\\n\\n  nums.forEach(num => frequencies[num]++);\\n\\n  for (let i = 1; i < 101; i++) {\\n    smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n  }\\n\\n  return nums.map(num => smaller[num]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900280,
                "title": "easiest-solution-using-sorted-function-python",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        sort = sorted(nums)\\n        for i in nums:\\n            ans.append(sort.index(i))\\n        return ans\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        sort = sorted(nums)\\n        for i in nums:\\n            ans.append(sort.index(i))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656903,
                "title": "java-using-list-simple-solutions",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n        List<Integer> temp = new ArrayList<>();\\n\\n        for(int n : nums) temp.add(n);\\n\\n        Collections.sort(temp);\\n\\n        for (int i = 0 ; i < len ; i++) {\\n            result[i] = temp.indexOf(nums[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n        List<Integer> temp = new ArrayList<>();\\n\\n        for(int n : nums) temp.add(n);\\n\\n        Collections.sort(temp);\\n\\n        for (int i = 0 ; i < len ; i++) {\\n            result[i] = temp.indexOf(nums[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613343,
                "title": "simple-python-solution-72ms-and-13-8-mb-explained",
                "content": "We are just using another list which is sorted of nums and then finding the location of first occurence of the element in the sorted list and returning its index that means it will return the remaining number of smaller elements in the list.\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        numi = sorted(nums)\\n        for i in range(0,len(nums)):\\n            a.append(numi.index(nums[i]))\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        numi = sorted(nums)\\n        for i in range(0,len(nums)):\\n            a.append(numi.index(nums[i]))\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578007,
                "title": "c-linq-solution-in-one-string",
                "content": "```\\npublic int[] SmallerNumbersThanCurrent(int[] nums) {\\n     return nums.Select(x => (nums.Where(i => i < x).Count())).ToArray();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic int[] SmallerNumbersThanCurrent(int[] nums) {\\n     return nums.Select(x => (nums.Where(i => i < x).Count())).ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530928,
                "title": "python-very-fast-99-84-explained-with-some-tips-on-how-to-get-to-99",
                "content": "Here is the code:\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        snums = sorted(nums)\\n        for i,v in enumerate(snums):\\n            if v not in d:\\n                d[v]=i       \\n        return [ d[n] for n in nums ]\\n```\\n\\nThe logic:\\n\\n1. since we are comparing values against each other, we\\'ll need to sort them. so we just do `snums = sorted(nums)`\\n2. this is an important part. At some point we\\'ll need to search index of an element by its value. There are two ways to do it. One is to use list.index(v) method, another one is to use a dictionary. The problem is those methods have very different time complexity. list.index() is O(N) because python effective scans through the list. While using a dictionary is O(1) because is hash based.  So while functionally the method above and something like:\\n\\n`return [sorted(nums).index(n) for n in nums]` \\n\\nproduce the same result, the complexity is different. the one-liner above is:\\n\\nO(NlogN) for `sorted`, O(N) for the `for` loop and  O(N) for `index()`  \\n\\nBut the important part is for every element inside `for` we are doing sort and index(), so it is:\\n\\nN*(N + NlogN) = N^2 + N^2*logN, the highest order id N^2 * logN\\n\\nIt can be improved  if we move sorted() outside of the loop:\\n\\n```\\ns=sorted(nums)\\nreturn [s.index(n) for n in nums]\\n``` \\n\\nhere we do NlogN + N * N (because for each element we do index(), that means loop inside another loop), and the highest component is N^2.\\n\\nMeanwhile the dictionary approach above is:\\n\\nNlogN to do the first `sorted`, then we add N for `for i,v in enumerate(snums)` and then we add another N for `d[n] for n in nums ]`. The important part is we run loops sequentially and not one inside another.\\n\\nThat means a sort / index approach will take NlogN + N^2 - the highest is N^2 while a dictionary based would be NlogN + N + N - the highest NlogN.\\n\\nTo keep story short, due to the way how Python implemented lists and dictionaries, a dictionary based approach should be faster.\\n\\nSo when I ran a few tests, this solution scored up to 99.84%, so that goes inline with that theory.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        snums = sorted(nums)\\n        for i,v in enumerate(snums):\\n            if v not in d:\\n                d[v]=i       \\n        return [ d[n] for n in nums ]\\n```\n```\\ns=sorted(nums)\\nreturn [s.index(n) for n in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525059,
                "title": "python-o-n-solution-count-instead-of-sort",
                "content": "Use `bucket` to count the occurence of 0 ~ 100 instead of sorting because of the constraint `0 <= nums[i] <= 100`.\\nThen accumulate `bucket` to get `accu`. `accu[i]` is the count of `num` in `nums` which is smaller than i.\\n\\n```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        bucket = [0] * 101\\n        for num in nums:\\n            bucket[num] += 1\\n            \\n        accu = [0] * 101\\n        for i in range(1, 101):   # 1 ~ 100\\n            accu[i] = accu[i-1] + bucket[i-1]\\n            \\n        return [ accu[num] for num in nums ]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        bucket = [0] * 101\\n        for num in nums:\\n            bucket[num] += 1\\n            \\n        accu = [0] * 101\\n        for i in range(1, 101):   # 1 ~ 100\\n            accu[i] = accu[i-1] + bucket[i-1]\\n            \\n        return [ accu[num] for num in nums ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153982,
                "title": "swift-how-many-numbers-are-smaller-than-the-current-number",
                "content": "### Solution:\\n```swift\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        var counts = Array(repeating: 0, count: 101), arr = counts, sum = 0\\n        nums.map{ counts[$0] += 1 }\\n        \\n        for i in 1...counts.count - 1 {\\n            sum += counts[i-1]\\n            arr[i] = sum\\n        }\\n        \\n        var ans = Array(repeating: 0, count: nums.count)\\n        for i in 0..<nums.count { ans[i] = arr[nums[i]]}\\n        return ans\\n    }\\n}\\n```\\n\\n### Tests:\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.097 (0.098) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([8,1,2,2,3]), [4,0,1,1,3]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([6,5,4,8]), [2,1,0,3]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([7,7,7,7]), [0,0,0,0]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        var counts = Array(repeating: 0, count: 101), arr = counts, sum = 0\\n        nums.map{ counts[$0] += 1 }\\n        \\n        for i in 1...counts.count - 1 {\\n            sum += counts[i-1]\\n            arr[i] = sum\\n        }\\n        \\n        var ans = Array(repeating: 0, count: nums.count)\\n        for i in 0..<nums.count { ans[i] = arr[nums[i]]}\\n        return ans\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.097 (0.098) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([8,1,2,2,3]), [4,0,1,1,3]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([6,5,4,8]), [2,1,0,3]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([7,7,7,7]), [0,0,0,0]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525062,
                "title": "python-extremely-simple-solution",
                "content": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269634,
                "title": "sorted-list-lookup-70-faster-python3",
                "content": "# Solution\\nThe idea is to **sort the list** and **use the sorted list for an index look-up**.\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        larger_nums = []\\n        for num in nums:\\n            larger_nums.append(sorted_nums.index(num))\\n        return larger_nums\\n```\\n\\n# Simple Explanation:\\n\\nSort `nums` and store the sorted list to `sorted_nums`. For example: \\n```\\nnums = [8,1,2,2,3]\\nsorted_nums = sorted(nums)\\n# [1, 2, 2, 3, 8]\\n```\\n\\n\\nIterate through `nums`, and search the index of `num` from `sorted_list`. \\n\\nThe index of `num` indicates how many numbers are smaller than itself.\\n\\nFor example on the **first iteration**:\\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 8\\n\\tsorted_nums.index(num) # 4\\n```\\n\\n**second iteration**:\\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 1\\n\\tsorted_nums.index(num) # 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        larger_nums = []\\n        for num in nums:\\n            larger_nums.append(sorted_nums.index(num))\\n        return larger_nums\\n```\n```\\nnums = [8,1,2,2,3]\\nsorted_nums = sorted(nums)\\n# [1, 2, 2, 3, 8]\\n```\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 8\\n\\tsorted_nums.index(num) # 4\\n```\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 1\\n\\tsorted_nums.index(num) # 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1191556,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] result = new int[nums.length];\\n       int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            temp[nums[i]]++;\\n        }\\n        \\n        for (int i = 1; i < 101; i++) {\\n            temp[i] += temp[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = temp[nums[i] - 1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] result = new int[nums.length];\\n       int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            temp[nums[i]]++;\\n        }\\n        \\n        for (int i = 1; i < 101; i++) {\\n            temp[i] += temp[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = temp[nums[i] - 1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144363,
                "title": "javascript-faster-than-97-88-and-less-than-94-41",
                "content": "Sort the array in asceding order and use the position in the sorted array to determine how many numbers in the array are smaller than it.\\n\\t\\n\\tconst sorted = [...nums].sort((a, b) => a - b);\\n\\n    return nums.map((value) => sorted.indexOf(value));",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Sort the array in asceding order and use the position in the sorted array to determine how many numbers in the array are smaller than it.\\n\\t\\n\\tconst sorted = [...nums].sort((a, b) => a - b);\\n\\n    return nums.map((value) => sorted.indexOf(value));",
                "codeTag": "Unknown"
            },
            {
                "id": 931357,
                "title": "c-sorting-vs-non-sorting-solution-compared-and-explained-100-time-75-space",
                "content": "So, my first approach was to work on sorted elements.\\n\\nTo do so, I needed a few extra variables:\\n* `len` will store the length of our input;\\n* `res` will storet the final result and we can set it to be `len` long from the beginning, to avoid expensive reallocations;\\n* `copyV` will initially mirror the content of `nums`.\\n\\nWe will then sort `copyV` and proceed to search each element of `nums`, iterating with a pointer `i` through it.\\n\\nFor each number so parsed, we will set `res[i]` to be equal of the value position said element has in the freshly sorted `copyV` - no need to go linear here, since we know that sorted data structures are the ideal ground for a healthy binary search and, to be more specific, we will go with `lower_bound` that does all the work for us, right out of the box.\\n\\nOnce we are done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size();\\n        vector<int> res(len), copyV(nums);\\n        // reading copyV to be binary-searched\\n        sort(begin(copyV), end(copyV));\\n        for (int i = 0; i < len; i++) {\\n            res[i] = lower_bound(begin(copyV), end(copyV), nums[i]) - begin(copyV);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThen I had another idea: storing the frequency of each element (we know they are rather limited, going only up to `100`) and then progressing in a similar fashion to the previous problem.\\n\\nOur initial variables are almost the same, we just drop `copyV` and use instead the int array `freqs` set to be `101` elements long, with all the values initialised to `0`.\\n\\nWe do one first pass through `nums` to store/update each frequency in `res`.\\n\\nA second pass will have populate `res`, assigning to its `i`th value the cumulative sum of all the first `nums[i]` values.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {};\\n        vector<int> res(len);\\n        // populating freqs\\n        for (int n: nums) freqs[n]++;\\n        for (int i = 0; i < len; i++) {\\n            res[i] = accumulate(freqs, freqs + nums[i], 0);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd then I realised we were doing the same stuff potentially over and over again, while a nice DP approach would work better, so I refactored the computing part, leaving accumulate on the ground.\\n\\nThe logic is the same as the previous, but we just turn turn `freqs` into a cumulative set of frequencies, up to that point included.\\n\\nFor this reason, the frequency of all the smaller elements before `n` is now `freqs[n - 1]` - or just `0` for `n == 0`, since we are assured by the requirements that we cannot have any element smaller than that.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {}, maxV = 0;\\n        vector<int> res(len);\\n        // populating freqs, updating maxV\\n        for (int n: nums) {\\n            freqs[n]++;\\n            maxV = max(maxV, n);\\n        }\\n        // turning freqs into a table of cumulative frequencies\\n        for (int i = 1; i <= maxV; i++) freqs[i] += freqs[i - 1];\\n        for (int i = 0; i < len; i++) {\\n            res[i] = nums[i] ? freqs[nums[i] - 1] : 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size();\\n        vector<int> res(len), copyV(nums);\\n        // reading copyV to be binary-searched\\n        sort(begin(copyV), end(copyV));\\n        for (int i = 0; i < len; i++) {\\n            res[i] = lower_bound(begin(copyV), end(copyV), nums[i]) - begin(copyV);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {};\\n        vector<int> res(len);\\n        // populating freqs\\n        for (int n: nums) freqs[n]++;\\n        for (int i = 0; i < len; i++) {\\n            res[i] = accumulate(freqs, freqs + nums[i], 0);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {}, maxV = 0;\\n        vector<int> res(len);\\n        // populating freqs, updating maxV\\n        for (int n: nums) {\\n            freqs[n]++;\\n            maxV = max(maxV, n);\\n        }\\n        // turning freqs into a table of cumulative frequencies\\n        for (int i = 1; i <= maxV; i++) freqs[i] += freqs[i - 1];\\n        for (int i = 0; i < len; i++) {\\n            res[i] = nums[i] ? freqs[nums[i] - 1] : 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623050,
                "title": "one-line-javascript-solution",
                "content": "> Runtime: 68 ms, faster than 95.48% of JavaScript online submissions for How Many Numbers Are Smaller Than the Current Number.\\nMemory Usage: 36.1 MB, less than 100.00% of JavaScript online submissions for How Many Numbers Are Smaller Than the Current Number.\\n```js\\nvar smallerNumbersThanCurrent = function(nums) {\\n    return nums.map((numa, i) => nums.reduce((total, numb,ii)=> numa>numb ? total+1 : total, 0))\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar smallerNumbersThanCurrent = function(nums) {\\n    return nums.map((numa, i) => nums.reduce((total, numb,ii)=> numa>numb ? total+1 : total, 0))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528560,
                "title": "100-memory-javascript-solution-with-explanation",
                "content": "First off, a simple brute force approach would be something like this:\\n\\n```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst resultArray = [];\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tlet counter = 0;\\n\\t\\tfor (let j = 0; j < arr.length; j++) {\\n\\t\\t\\tif (arr[i] > arr[j]) {\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresultArray.push(counter);\\n\\t}\\n\\treturn resultArray;\\n}\\n```\\n\\nWe\\u2019re using nested ```for``` loops to compare each item in the array to the rest of the items in the array. Since we\\u2019re iterating over the entire array with each comparison, that gives us an ```O(n^2)``` time complexity (not great).\\n\\nHowever, a better solution can be found by taking advantage of sorting and a few built-in JavaScript methods. If you have a number ```n``` in a sorted copy of an array, you know that everything to the left of ```n``` will be lower than it. So conveniently enough, you can just take the index of ```n``` in the sorted array and that will be the number of items that are less than it, and thus the number that should be pushed to the result array.\\n\\n```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst result = [];\\n\\tconst unsortedArr = [...arr];\\n\\tarr.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < unsortedArr.length; i++) {\\n\\t\\tresult.push(arr.indexOf(unsortedArr[i]));\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\nSince ```.sort()``` is implemented differently on different browsers, its time complexity can\\u2019t be guaranteed. However, the big O of the function as a whole would be ```O(n)```, a considerable improvement over the quadratic ```O(n^2)``` from the brute force approach.\\n\\n----------------\\n\\n*3/18/21 edit:* Looking back at this, it would be a much better idea to copy the `arr` parameter to a `sortedArr` variable and sort that instead:\\n```\\nconst sortedArr = [...arr];\\nsortedArr.sort((a, b) => a - b);\\n```\\nYou can then swap out the `for` loop variables accordingly. JavaScript uses call by sharing, so `arr` stores a reference to the array object that\\'s passed in and the previous solution will sort that external array object, causing an unwanted side effect.",
                "solutionTags": [],
                "code": "```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst resultArray = [];\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tlet counter = 0;\\n\\t\\tfor (let j = 0; j < arr.length; j++) {\\n\\t\\t\\tif (arr[i] > arr[j]) {\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresultArray.push(counter);\\n\\t}\\n\\treturn resultArray;\\n}\\n```\n```for```\n```O(n^2)```\n```n```\n```n```\n```n```\n```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst result = [];\\n\\tconst unsortedArr = [...arr];\\n\\tarr.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < unsortedArr.length; i++) {\\n\\t\\tresult.push(arr.indexOf(unsortedArr[i]));\\n\\t}\\n\\treturn result;\\n}\\n```\n```.sort()```\n```O(n)```\n```O(n^2)```\n```\\nconst sortedArr = [...arr];\\nsortedArr.sort((a, b) => a - b);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526393,
                "title": "c-dictionary-array-indexof-counting-sort",
                "content": "**Dictionary**\\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n      \\n        // Sort nums\\n        int[] res = new int[nums.Length];                  \\n        int[] sortNums = (int[])nums.Clone();\\n        Array.Sort(sortNums);\\n        \\n        /* \\n\\t\\t    For each key-value pair, key is the number, value is number\\'s index of the sorted array.\\n\\t\\t    The smaller number count of a given number (Key) is its Value.\\n\\t\\t*/\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < sortNums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(sortNums[i]))\\n                dic.Add(sortNums[i], i);\\n        }\\n        \\n        for(int j = 0; j < res.Length; j++)\\n            res[j] = dic[nums[j]];\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Array.IndexOf()**\\nSame idea as the dictionary solution. Instead of using a dictionary to store the indexes, this solution will get the index from sorted array directly by using Array.IndexOf().\\n```\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] sortedNums = (int[])nums.Clone();\\n        Array.Sort(sortedNums);\\n        \\n        for(int j = 0; j < nums.Length; j++)\\n        {\\n            nums[j] = Array.IndexOf(sortedNums, nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n```\\n\\n**Counting Sort 1**\\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] res = new int[nums.Length];  \\n        \\n        /* \\n\\t\\t   Count the occurence of each number in nums[]. \\n           Hashing the nums to the indexes of freq[].\\n           E.g., nums[] = [8, 1, 2, 2, 3]\\n                 freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n        */\\n        int[] freq = new int[101];\\n        foreach(int num in nums)\\n            freq[num]++;\\n        \\n        /*\\n\\t\\t    Count how many numbers are smaller than nums[i]     \\n         E.g.,     freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n                ==>freq[] = [0, 1, 3, 4, 4, 4, 4, 4, 5]\\n        */                               \\n        for(int i = 1; i < freq.Length; i++)\\n            freq[i] += freq[i - 1];\\n        \\n        /* Fill in res[] E.g., the smaller number count of 8 is freq[7]*/\\n        for(int j = 0; j < res.Length; j++)\\n        {\\n            if(nums[j] == 0)\\n                 res[j] = 0;\\n            else\\n                res[j] = freq[nums[j] - 1];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Counting Sort 2**\\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int k = nums.Max();        \\n        int[] count = new int[k + 1];\\n        foreach(int num in nums)\\n            count[num]++;\\n        \\n        for(int i = 1; i < count.Length; i++)\\n            count[i] += count[i-1];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            nums[i] = (nums[i] == 0)? 0 : count[nums[i] - 1];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n      \\n        // Sort nums\\n        int[] res = new int[nums.Length];                  \\n        int[] sortNums = (int[])nums.Clone();\\n        Array.Sort(sortNums);\\n        \\n        /* \\n\\t\\t    For each key-value pair, key is the number, value is number\\'s index of the sorted array.\\n\\t\\t    The smaller number count of a given number (Key) is its Value.\\n\\t\\t*/\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < sortNums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(sortNums[i]))\\n                dic.Add(sortNums[i], i);\\n        }\\n        \\n        for(int j = 0; j < res.Length; j++)\\n            res[j] = dic[nums[j]];\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] sortedNums = (int[])nums.Clone();\\n        Array.Sort(sortedNums);\\n        \\n        for(int j = 0; j < nums.Length; j++)\\n        {\\n            nums[j] = Array.IndexOf(sortedNums, nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n```\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] res = new int[nums.Length];  \\n        \\n        /* \\n\\t\\t   Count the occurence of each number in nums[]. \\n           Hashing the nums to the indexes of freq[].\\n           E.g., nums[] = [8, 1, 2, 2, 3]\\n                 freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n        */\\n        int[] freq = new int[101];\\n        foreach(int num in nums)\\n            freq[num]++;\\n        \\n        /*\\n\\t\\t    Count how many numbers are smaller than nums[i]     \\n         E.g.,     freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n                ==>freq[] = [0, 1, 3, 4, 4, 4, 4, 4, 5]\\n        */                               \\n        for(int i = 1; i < freq.Length; i++)\\n            freq[i] += freq[i - 1];\\n        \\n        /* Fill in res[] E.g., the smaller number count of 8 is freq[7]*/\\n        for(int j = 0; j < res.Length; j++)\\n        {\\n            if(nums[j] == 0)\\n                 res[j] = 0;\\n            else\\n                res[j] = freq[nums[j] - 1];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int k = nums.Max();        \\n        int[] count = new int[k + 1];\\n        foreach(int num in nums)\\n            count[num]++;\\n        \\n        for(int i = 1; i < count.Length; i++)\\n            count[i] += count[i-1];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            nums[i] = (nums[i] == 0)? 0 : count[nums[i] - 1];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349424,
                "title": "100-beats-accepted-short-simple-best-method-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBotirjon Shokirov\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution first creates an array counts of size 101 (the maximum value of a number in the input array is 100), initializes all its elements to 0, and then counts the number of occurrences of each number in the input array. Then, it calculates the running total of counts in counts, and uses the running total to determine the number of smaller numbers for each element in the input array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const counts = new Array(101).fill(0);\\n    nums.forEach(num => counts[num]++);\\n    \\n    let prevCount = 0;\\n    for (let i = 0; i < counts.length; i++) {\\n        const count = counts[i];\\n        counts[i] = prevCount;\\n        prevCount += count;\\n    }\\n    \\n    return nums.map(num => counts[num]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const counts = new Array(101).fill(0);\\n    nums.forEach(num => counts[num]++);\\n    \\n    let prevCount = 0;\\n    for (let i = 0; i < counts.length; i++) {\\n        const count = counts[i];\\n        counts[i] = prevCount;\\n        prevCount += count;\\n    }\\n    \\n    return nums.map(num => counts[num]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203191,
                "title": "click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n",
                "content": "## // **Using Hashtable in O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n            int count[101]={0};\\n            vector<int> vec;\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                count[nums[i]]++;\\n            }\\n            for(int i = 1 ; i < 101 ; i++){\\n                count[i]+=count[i-1];\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                if(nums[i] == 0)\\n                    vec.emplace_back(0);\\n                else {\\n                    vec.emplace_back(count[nums[i] - 1]);\\n            }\\n        }\\n      return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n            int count[101]={0};\\n            vector<int> vec;\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                count[nums[i]]++;\\n            }\\n            for(int i = 1 ; i < 101 ; i++){\\n                count[i]+=count[i-1];\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                if(nums[i] == 0)\\n                    vec.emplace_back(0);\\n                else {\\n                    vec.emplace_back(count[nums[i] - 1]);\\n            }\\n        }\\n      return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095467,
                "title": "rust-clean-and-functional-one-liner-0ms-2-2-mb",
                "content": "```\\nimpl Solution {\\n    pub fn smaller_numbers_than_current(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .map(|i| nums.iter().filter(|j| *j < &i).count() as i32)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn smaller_numbers_than_current(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .map(|i| nums.iter().filter(|j| *j < &i).count() as i32)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690921,
                "title": "python3-2-line-simple-solution",
                "content": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        x = sorted(nums)\\n        return [x.index(i) for i in nums]\\n```",
                "solutionTags": [],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        x = sorted(nums)\\n        return [x.index(i) for i in nums]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 642803,
                "title": "javascript-map-reduce",
                "content": "```\\nvar smallerNumbersThanCurrent = function (nums) {\\n    return nums.map(n => nums.reduce((a, b) => a + (n > b ? 1 : 0), 0))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallerNumbersThanCurrent = function (nums) {\\n    return nums.map(n => nums.reduce((a, b) => a + (n > b ? 1 : 0), 0))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 567290,
                "title": "my-python-solution",
                "content": "Runtime: 116 ms, faster than 46.89% of Python3 online submissions for How Many Numbers Are Smaller Than the Current Number.\\nMemory Usage: 13.8 MB, less than 100.00% of Python3 online submissions for How Many Numbers Are Smaller Than the Current Number.\\n\\nMight not be answer for interview question since may be asked to implement sort function and index function again. \\n\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        cp = sorted(nums)\\n        ret = []\\n        for i in nums:\\n            ret.append(cp.index(i))\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        cp = sorted(nums)\\n        ret = []\\n        for i in nums:\\n            ret.append(cp.index(i))\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 530742,
                "title": "c-prefix-sum-8ms-99-64",
                "content": "# Possible Algorithms and Their Complexity\\n## Algorithm 0:\\nfor i in nums\\n  for j in nums, j != i: out[j] +=1 if nums[j] < nums[i]\\n* O(n^2)\\n  \\n## Algorithm 1:\\nCopy array.\\nSort Array.\\nloop over nums incing a count of run length.\\n  when a new run starts add the run length to a total count\\n  and reset run to 1.\\n  for each element in run, set the output element to the total count.\\nO(n log n) (std::sort) or O(n) (counting or radix sort)\\n\\n## Algorithm 2:\\narray of counts\\nfor each in num, inc count of its value.\\nfor each in side array, prefix sum.\\nfor each in nums, copy prefix sum out of side array.\\nO(n + 101) == O(n)\\n\\n# Code\\n## Algorithm 2 Implementation\\n```c++\\nnamespace\\n{\\n    class Solution {\\n    public:\\n       static vector<int> smallerNumbersThanCurrent(const vector<int>& nums);  \\n    };\\n\\n    // Algorithm 2 implementation:\\n    vector<int> Solution::smallerNumbersThanCurrent(const vector<int>& nums)\\n    {\\n        // Work out how many of each value there are:\\n       uint16_t val_counts[101] {0};\\n        for(auto& num : nums){\\n            val_counts[num] += 1u;\\n        }\\n        \\n        // prefix sum the values:\\n        unsigned sum = 0;\\n        for(unsigned i = 0; i < 101; ++i){\\n            const unsigned val = val_counts[i];\\n            val_counts[i] = sum;\\n            sum += val;\\n        }\\n        \\n        // Let\\'s run through the input again lookup the number of\\n        // elements less than it in the table we just made:\\n        vector<int> counts(nums.size());\\n        for(unsigned i = 0, end = nums.size(); i < end; ++i)\\n        {\\n            counts[i] = val_counts[nums[i]];\\n        }\\n        return counts;\\n    }\\n    \\n    static const auto fast=[](){ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return nullptr;}();\\n\\n}\\n```\\n\\n# Results\\nAlgorithm 2 Best Submission:\\n>Runtime: 8 ms, faster than 99.64% of C++ online submissions for How Many Numbers Are Smaller Than the Current Number.\\n>Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for How Many Numbers Are Smaller Than the Current Number.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nnamespace\\n{\\n    class Solution {\\n    public:\\n       static vector<int> smallerNumbersThanCurrent(const vector<int>& nums);  \\n    };\\n\\n    // Algorithm 2 implementation:\\n    vector<int> Solution::smallerNumbersThanCurrent(const vector<int>& nums)\\n    {\\n        // Work out how many of each value there are:\\n       uint16_t val_counts[101] {0};\\n        for(auto& num : nums){\\n            val_counts[num] += 1u;\\n        }\\n        \\n        // prefix sum the values:\\n        unsigned sum = 0;\\n        for(unsigned i = 0; i < 101; ++i){\\n            const unsigned val = val_counts[i];\\n            val_counts[i] = sum;\\n            sum += val;\\n        }\\n        \\n        // Let\\'s run through the input again lookup the number of\\n        // elements less than it in the table we just made:\\n        vector<int> counts(nums.size());\\n        for(unsigned i = 0, end = nums.size(); i < end; ++i)\\n        {\\n            counts[i] = val_counts[nums[i]];\\n        }\\n        return counts;\\n    }\\n    \\n    static const auto fast=[](){ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return nullptr;}();\\n\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 525326,
                "title": "c-solution",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\\n    \\n    int *answer = (int *)malloc(sizeof(int) * numsSize); \\n    int i = 0, j = 0;\\n    \\n    *returnSize = numsSize;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        answer[i] = 0;\\n    }\\n       \\n\\n    for(i=0; i<numsSize; i++) {\\n        for(j=i+1; j<numsSize; j++) {\\n            if(nums[i] > nums[j]) {\\n                answer[i]++;\\n            }\\n            else if(nums[i] < nums[j]) {\\n                answer[j]++;\\n            }\\n        }\\n    }   \\n    \\n    return answer;\\n}\\n```\\n\\nNote: malloc memory on Leetcode will lead unexpectbale integer like -152152424 .... , so we need to initialize the answer array(or you can use calloc)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\\n    \\n    int *answer = (int *)malloc(sizeof(int) * numsSize); \\n    int i = 0, j = 0;\\n    \\n    *returnSize = numsSize;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        answer[i] = 0;\\n    }\\n       \\n\\n    for(i=0; i<numsSize; i++) {\\n        for(j=i+1; j<numsSize; j++) {\\n            if(nums[i] > nums[j]) {\\n                answer[i]++;\\n            }\\n            else if(nums[i] < nums[j]) {\\n                answer[j]++;\\n            }\\n        }\\n    }   \\n    \\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524927,
                "title": "java-100-runtime-solution",
                "content": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] numsCopy = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(numsCopy);\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            res[i] = binarySearch(numsCopy, nums[i]);\\n        }\\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] numsCopy = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(numsCopy);\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            res[i] = binarySearch(numsCopy, nums[i]);\\n        }\\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784618,
                "title": "2-c-solutions-o-n-time-complexity-sort-and-hash-table-beats-100",
                "content": "# Code\\n```\\n// Solution 1 (brute force O(N^2) time complexity)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            int count = 0;\\n            for(auto j : nums){\\n                if(i>j)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n};\\n\\n// Solution 2 : Time complexity = O(N) (Unordered_map / Sort)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans = nums;\\n        unordered_map<int, int> m;\\n        sort(ans.begin(), ans.end());\\n        for(int i=nums.size()-1; i>=0; i--)\\n            m[ans[i]] = i;\\n        for(int i=0; i<nums.size(); i++)\\n            nums[i] = m[nums[i]];\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n// Solution 1 (brute force O(N^2) time complexity)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            int count = 0;\\n            for(auto j : nums){\\n                if(i>j)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n};\\n\\n// Solution 2 : Time complexity = O(N) (Unordered_map / Sort)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans = nums;\\n        unordered_map<int, int> m;\\n        sort(ans.begin(), ans.end());\\n        for(int i=nums.size()-1; i>=0; i--)\\n            m[ans[i]] = i;\\n        for(int i=0; i<nums.size(); i++)\\n            nums[i] = m[nums[i]];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451659,
                "title": "easy-java-solution-for-smaller-numbers-than-current-number",
                "content": "\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int temp = 0, size = nums.length;\\n        int[] result = new int[size];\\n\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(i != j){\\n                    if(nums[i] > nums[j]){\\n                        temp++;\\n                    }\\n                }\\n            }\\n            result[i] = temp;\\n            temp = 0;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\nPlease upvote me, it encourages me a lot!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int temp = 0, size = nums.length;\\n        int[] result = new int[size];\\n\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(i != j){\\n                    if(nums[i] > nums[j]){\\n                        temp++;\\n                    }\\n                }\\n            }\\n            result[i] = temp;\\n            temp = 0;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322900,
                "title": "c-95-faster-98-smaller",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> sorted = nums;\\n        sort(sorted.begin(), sorted.end());\\n        \\n        for(int& num : nums)\\n        {\\n            num = lower_bound(sorted.begin(), sorted.end(), num) - sorted.begin();\\n        }\\n        return nums;\\n    }\\n};\\n\\n```\\n\\n\\n** Uses search method from STL.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> sorted = nums;\\n        sort(sorted.begin(), sorted.end());\\n        \\n        for(int& num : nums)\\n        {\\n            num = lower_bound(sorted.begin(), sorted.end(), num) - sorted.begin();\\n        }\\n        return nums;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127479,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        int maxi;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(j != i and nums[j] < nums[i])\\n                    maxi++;\\n            }\\n            v.push_back(maxi);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        int maxi;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(j != i and nums[j] < nums[i])\\n                    maxi++;\\n            }\\n            v.push_back(maxi);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936122,
                "title": "python-40ms-faster-than-99-64",
                "content": "```\\n        dic1 = {}\\n        nums1 = sorted(nums, reverse=True)\\n        for index in range(0, len(nums1) - 1):\\n            if nums1[index] == nums1[index + 1]:\\n                continue\\n            dic1[nums1[index]] = len(nums1) - index -1    \\n        dic1[nums1[-1]] = 0\\n        return([dic1[x] for x in nums])\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        dic1 = {}\\n        nums1 = sorted(nums, reverse=True)\\n        for index in range(0, len(nums1) - 1):\\n            if nums1[index] == nums1[index + 1]:\\n                continue\\n            dic1[nums1[index]] = len(nums1) - index -1    \\n        dic1[nums1[-1]] = 0\\n        return([dic1[x] for x in nums])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653879,
                "title": "java-o-n-solution-99-3-runtime-100-memory",
                "content": "Solution is based on counting frequency of the elements in array.\\nAfter creating the frequency array, add the frequencies together like prefix sum.\\nNow, your **array is increasing by total number of entries** before the current entry. Simple logic to find how many numbers smaller than the current num in array is\\n``` \\nif array entry is 0: (there would be no element before 0) simply assign 0 here\\nelse assign previous entry from the array.\\n```\\nFor eg. if the given array is **[8, 1, 0, 2, 2, 3, 0]**\\nafter frequency count and prefix addition, the frequency array would become\\n**[0, 1, 3, 4, 4, 4, 4, 4, 5, 5, 5, ...]** (all next entries would be 5)\\nhow many elements before 2 you would ask. it\\'s nums[2 - 1] = 1 in array. before 3, it\\'s nums[3 - 1] = 3.\\n\\n```java\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] freq = new int[101];\\n    \\n    for (int num: nums) {\\n      freq[num]++;\\n    }\\n\\n    int total = 0;\\n    for (int i = 1; i < freq.length; i++) {\\n      freq[i] += freq[i - 1];\\n    }\\n        \\n    int[] ans = new int[nums.length];\\n    \\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i] != 0)\\n        ans[i] = freq[nums[i] - 1];\\n      else \\n        ans[i] = 0;\\n    }\\n    \\n    \\n    return ans;\\n  }\\n```",
                "solutionTags": [],
                "code": "``` \\nif array entry is 0: (there would be no element before 0) simply assign 0 here\\nelse assign previous entry from the array.\\n```\n```java\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] freq = new int[101];\\n    \\n    for (int num: nums) {\\n      freq[num]++;\\n    }\\n\\n    int total = 0;\\n    for (int i = 1; i < freq.length; i++) {\\n      freq[i] += freq[i - 1];\\n    }\\n        \\n    int[] ans = new int[nums.length];\\n    \\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i] != 0)\\n        ans[i] = freq[nums[i] - 1];\\n      else \\n        ans[i] = 0;\\n    }\\n    \\n    \\n    return ans;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525274,
                "title": "c-o-n-o-102-use-constraints-0-100",
                "content": "Known: Range for number is [0,100].\\n\\n0. Need a count table of size 101.\\n1. `F(n+1) = sum(cnt[0...n])`, hence mapping [0,100] to [1,101] to store counts less than current.\\n2. Use the count table as a dp and update rolling counts `cnt[n\\'] = sum(cnt[0...n]) = cnt[n]+cnt[(n-1)\\']`.\\n3. Replace original number in array with counts less than it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> cnt(102, 0);\\n        for(auto n : nums) {\\n            ++cnt[n+1]; // e.g. for n = 1, it\\'s valid for cnt[2+] but not for cnt[1]\\n        }\\n        for(int i = 1; i < cnt.size(); ++i) {\\n            cnt[i] += cnt[i-1]; // rolling counts\\n        }\\n        for(auto& n : nums) {\\n            n = cnt[n]; // replace with counts\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> cnt(102, 0);\\n        for(auto n : nums) {\\n            ++cnt[n+1]; // e.g. for n = 1, it\\'s valid for cnt[2+] but not for cnt[1]\\n        }\\n        for(int i = 1; i < cnt.size(); ++i) {\\n            cnt[i] += cnt[i-1]; // rolling counts\\n        }\\n        for(auto& n : nums) {\\n            n = cnt[n]; // replace with counts\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863223,
                "title": "python-solution-faster-than-86",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sort_nums = sorted(nums)\\n        res = []\\n        for i in nums:\\n            res.append(sort_nums.index(i))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sort_nums = sorted(nums)\\n        res = []\\n        for i in nums:\\n            res.append(sort_nums.index(i))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1425585,
                "title": "c-hashmap-sol-how-many-numbers-are-smaller-than-the-current-number",
                "content": "```\\nclass Solution {            //0(nlogn)\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n      unordered_map<int, int > map;\\n      vector<int> v(nums);     //[8,1,2,2,3]  copy of nums array\\n      \\n      sort(v.begin(), v.end());  //[1,2,2,3,8]  \\n      \\n      for(int i = 0; i<v.size() ; i++)    \\n      {\\n          //map[v[i]] = i;   can\\'t use this  bcz of duplicate elements//\\n          map.insert({v[i], i});\\n      }\\n\\t  //map[1]=>0  \\n\\t  //map[2]=>1  \\n\\t  //map[2]=>1  \\n\\t  //map[3]=>3  \\n\\t  //map[8]=>4\\n      \\n\\t  for(int i =0 ; i< nums.size(); i++)\\n      {\\n         v[i] = map[nums[i]];    // simply iterate original array, and get counts from the map.\\n      }\\n      return v;     //[4,0,1,1,3]\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {            //0(nlogn)\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n      unordered_map<int, int > map;\\n      vector<int> v(nums);     //[8,1,2,2,3]  copy of nums array\\n      \\n      sort(v.begin(), v.end());  //[1,2,2,3,8]  \\n      \\n      for(int i = 0; i<v.size() ; i++)    \\n      {\\n          //map[v[i]] = i;   can\\'t use this  bcz of duplicate elements//\\n          map.insert({v[i], i});\\n      }\\n\\t  //map[1]=>0  \\n\\t  //map[2]=>1  \\n\\t  //map[2]=>1  \\n\\t  //map[3]=>3  \\n\\t  //map[8]=>4\\n      \\n\\t  for(int i =0 ; i< nums.size(); i++)\\n      {\\n         v[i] = map[nums[i]];    // simply iterate original array, and get counts from the map.\\n      }\\n      return v;     //[4,0,1,1,3]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412772,
                "title": "both-o-n-2-and-o-n-check-it-well-expend-1-ms-faster-than-97-06-of-java-online",
                "content": "o(n2) Solution\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]<nums[i] && i!=j)\\n                    count++;\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n```\\n\\nO(n) Solution\\nRuntime: 1 ms, faster than 97.06% of Java online submissions for How Many Numbers Are Smaller Than the Current Number.\\nMemory Usage: 38.7 MB, less than 99.37% of Java online submissions for How Many Numbers Are Smaller Than the Current Number.\\n```\\nint maxLength=101;\\n        int[] countNum=new int[maxLength];\\n        //finding the number of the digit in array\\n        for(int i=0;i<nums.length;i++){\\n            countNum[nums[i]]++;\\n        }\\n              \\n        int[] ans=new int[nums.length];\\n        int count=0,temp;\\n        for(int i=0;i<maxLength && count < nums.length ;i++){\\n            if(countNum[i] != 0){\\n                temp=countNum[i];\\n                countNum[i]=count;\\n                count+=temp;\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=countNum[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]<nums[i] && i!=j)\\n                    count++;\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n```\n```\\nint maxLength=101;\\n        int[] countNum=new int[maxLength];\\n        //finding the number of the digit in array\\n        for(int i=0;i<nums.length;i++){\\n            countNum[nums[i]]++;\\n        }\\n              \\n        int[] ans=new int[nums.length];\\n        int count=0,temp;\\n        for(int i=0;i<maxLength && count < nums.length ;i++){\\n            if(countNum[i] != 0){\\n                temp=countNum[i];\\n                countNum[i]=count;\\n                count+=temp;\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=countNum[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299219,
                "title": "javascript-hashmap-solution",
                "content": "```\\n\\tlet sortedArr = [...nums].sort((a,b)=> a-b)\\n    \\n    let hash = {}, res = []\\n    \\n    for(let i = 0; i < sortedArr.length; i++){\\n    \\tif(sortedArr[i] == sortedArr[i-1]) continue;\\n        hash[sortedArr[i]] = i\\n    }\\n    for(let i = 0; i < nums.length; i++){\\n        res[i] = hash[nums[i]]\\n    }\\n    return res\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\tlet sortedArr = [...nums].sort((a,b)=> a-b)\\n    \\n    let hash = {}, res = []\\n    \\n    for(let i = 0; i < sortedArr.length; i++){\\n    \\tif(sortedArr[i] == sortedArr[i-1]) continue;\\n        hash[sortedArr[i]] = i\\n    }\\n    for(let i = 0; i < nums.length; i++){\\n        res[i] = hash[nums[i]]\\n    }\\n    return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144972,
                "title": "python-simple-and-easy-solution-24ms",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        abc = sorted(nums)\\n        for i in range(len(nums)):\\n            nums[i] = abc.index(nums[i])\\n            \\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        abc = sorted(nums)\\n        for i in range(len(nums)):\\n            nums[i] = abc.index(nums[i])\\n            \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007818,
                "title": "efficient-javascript-solution",
                "content": "sort array from the biggest to the smallest\\n[8,1,2,2,3] --> [8,3,2,2,1]\\n\\nnow we just locate the number we want using lastIndexOf()\\nto avoid the duplicate values\\n\\nthe amount of numbers that come after that number is the answer\\n\\nEX:\\nnum8 has 4nums after it (3,2,2,1) so the answer is 4\\nnum3 has 3nums after it (2,2,1) so the answer is 3\\nnum2 here we gonna find the second value of 2 cuz we are using lastIndexOf()\\nso the numbers that come after it is just 1 so the answer is 1\\n\\nHope You Like My Solution!\\n\\n```\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sortedNums = [...nums].sort((a,b) => b-a),\\n          numsIndexLength = nums.length - 1;\\n    \\n    return nums.map(val => numsIndexLength - sortedNums.lastIndexOf(val));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sortedNums = [...nums].sort((a,b) => b-a),\\n          numsIndexLength = nums.length - 1;\\n    \\n    return nums.map(val => numsIndexLength - sortedNums.lastIndexOf(val));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919263,
                "title": "java-o-n-1ms",
                "content": "**1ms O(n) time and O(n) solution** if any question please ask.\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint[] freq = new int[101];\\n        int[] count = new int[nums.length];\\n        for(int a : nums)\\n            freq[a]++;\\n        for(int i = 1 ; i < freq.length ; i++){\\n            freq[i] += freq[i-1];\\n        }\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i]==0)continue;\\n            count[i]=freq[nums[i]-1];\\n        }\\n        return count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint[] freq = new int[101];\\n        int[] count = new int[nums.length];\\n        for(int a : nums)\\n            freq[a]++;\\n        for(int i = 1 ; i < freq.length ; i++){\\n            freq[i] += freq[i-1];\\n        }\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i]==0)continue;\\n            count[i]=freq[nums[i]-1];\\n        }\\n        return count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526874,
                "title": "c-solution-faster-than-70-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> vec;\\n        for(auto &num:nums)\\n        {\\n            mp[num]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(auto &nn:mp)\\n                if(nn.first!=nums[i] && nn.first<=nums[i])\\n                    count+=nn.second;\\n            vec.push_back(count);\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> vec;\\n        for(auto &num:nums)\\n        {\\n            mp[num]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(auto &nn:mp)\\n                if(nn.first!=nums[i] && nn.first<=nums[i])\\n                    count+=nn.second;\\n            vec.push_back(count);\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446946,
                "title": "my-smallernumbersthancurrent",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function (nums) {\\n  let res = [];\\n\\n  for (const i of nums) {\\n    const c = nums.reduce((count, num) => {\\n      if (num < i) count++;\\n      return count;\\n    }, 0);\\n    res.push(c);\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function (nums) {\\n  let res = [];\\n\\n  for (const i of nums) {\\n    const c = nums.reduce((count, num) => {\\n      if (num < i) count++;\\n      return count;\\n    }, 0);\\n    res.push(c);\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2938422,
                "title": "c-sort-map",
                "content": "# Intuition:         \\nPut the values in hash-map according to their values corresponding to their places in nums in reverse order.\\n \\n# Complexity:\\n- Time complexity: O(nlogn) + O(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        vector<int> v = nums;\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        sort(v.begin(), v.end());\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            mp[v[i]] = i;\\n\\n        for (int i = 0; i < n; i++)\\n            nums[i] = mp[nums[i]];\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        vector<int> v = nums;\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        sort(v.begin(), v.end());\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            mp[v[i]] = i;\\n\\n        for (int i = 0; i < n; i++)\\n            nums[i] = mp[nums[i]];\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429787,
                "title": "c-two-solution-o-n-easy-solution",
                "content": "**Approach 1: (Sorting) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int> mp;  // Map for storing frequencies of number less than that number\\n        int n = nums.size();\\n        \\n        vector<int> sortednum = nums;\\n        sort(sortednum.begin(),sortednum.end());\\n        \\n        //Iterating from back and assigning index of number to that number \\n        for(int i = n-1;i>=0;i--)\\n        {\\n            mp[sortednum[i]] = i;\\n        }\\n        \\n        //Assigning frequencies to each elements\\n        for(int i= 0;i<n;i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n**Approach 2: (Counting)  \\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;  // vector to store final answer\\n        int count[101] = {0};    // Array to store count\\n\\t\\tint len = nums.size();\\n        \\n        //Store count of each number\\n        for(int i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        //Assigning count of smaller number to that number\\n        for(int i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int> mp;  // Map for storing frequencies of number less than that number\\n        int n = nums.size();\\n        \\n        vector<int> sortednum = nums;\\n        sort(sortednum.begin(),sortednum.end());\\n        \\n        //Iterating from back and assigning index of number to that number \\n        for(int i = n-1;i>=0;i--)\\n        {\\n            mp[sortednum[i]] = i;\\n        }\\n        \\n        //Assigning frequencies to each elements\\n        for(int i= 0;i<n;i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;  // vector to store final answer\\n        int count[101] = {0};    // Array to store count\\n\\t\\tint len = nums.size();\\n        \\n        //Store count of each number\\n        for(int i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        //Assigning count of smaller number to that number\\n        for(int i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119776,
                "title": "python-easy-solution-with-complexities",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)            #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for i in range(0,len(nums1)):   #time O(n)\\n            if nums1[i] in dic:         #time O(1)\\n                continue\\n            else:\\n                dic[nums1[i]] = i\\n                \\n        for i in range(0,len(nums)):    #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                    #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):    #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in range(0,len(nums)):            #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                     #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):     #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in nums:                           #time O(n)\\n            answer.append(dic[i])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\n        count = [0] * 102\\n        answer = []\\n        \\n        for num in nums:\\n            count[num+1] = count[num+1] + 1\\n            \\n        for i in range(1, 102):\\n            count[i] = count[i] + count[i-1]\\n            \\n        for num in nums:\\n            answer.append(count[num])\\n            \\n        return answer\\n    \\n#time O(n)\\n#space O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)            #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for i in range(0,len(nums1)):   #time O(n)\\n            if nums1[i] in dic:         #time O(1)\\n                continue\\n            else:\\n                dic[nums1[i]] = i\\n                \\n        for i in range(0,len(nums)):    #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                    #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):    #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in range(0,len(nums)):            #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                     #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):     #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in nums:                           #time O(n)\\n            answer.append(dic[i])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\n        count = [0] * 102\\n        answer = []\\n        \\n        for num in nums:\\n            count[num+1] = count[num+1] + 1\\n            \\n        for i in range(1, 102):\\n            count[i] = count[i] + count[i-1]\\n            \\n        for num in nums:\\n            answer.append(count[num])\\n            \\n        return answer\\n    \\n#time O(n)\\n#space O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099284,
                "title": "java-using-hashmap-easy-to-understand",
                "content": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1616837,
                "title": "java-solution-o-n-time-complexity",
                "content": "Kindly upvote, if it helps you!\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] farr = new int[101];\\n\\t\\t//count the occurence of each number\\n        for(int num: nums){\\n            farr[num]++;\\n        }\\n\\t\\t//calculate prefix sum\\n        for(int i = 1; i<farr.length; i++){\\n            farr[i] += farr[i-1];\\n        }\\n\\t\\t//number of elements smaller than that particular element \\n\\t\\t//would be the value stored at farr[nums[i]-1]\\n        for(int i= 0; i<nums.length; i++){\\n            nums[i] = nums[i]==0 ? 0 : farr[nums[i]-1];\\n        }\\n        return nums;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] farr = new int[101];\\n\\t\\t//count the occurence of each number\\n        for(int num: nums){\\n            farr[num]++;\\n        }\\n\\t\\t//calculate prefix sum\\n        for(int i = 1; i<farr.length; i++){\\n            farr[i] += farr[i-1];\\n        }\\n\\t\\t//number of elements smaller than that particular element \\n\\t\\t//would be the value stored at farr[nums[i]-1]\\n        for(int i= 0; i<nums.length; i++){\\n            nums[i] = nums[i]==0 ? 0 : farr[nums[i]-1];\\n        }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1265695,
                "title": "2-solutions-in-java-with-explanation",
                "content": "## Brute force\\nThat\\'s super simple, loop through the array and for each value, search the array again, excluding the current value. Increment value on new array on outer index to indicate how many numbers are smaller than this number. Continue until visited each number in nums array.\\n\\nSome pseudocode to understand the solution:\\n* create a new empty array with same length as nums array\\n* loop through the nums array from i = 0 to length\\n\\t* for each value loop through the array once again (nested loop) from j = 0 to length\\n\\t\\t* if outer and inner indexes are the same continue\\n\\t\\t* if `nums[j] < nums[i]` increment cell value on new array\\n\\t\\t* return new array\\n\\nAs this is a brute force solution, the time complexity is T(N) = O(N^2)\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < nums.length; j++) {\\n                if (j == i) continue;\\n                \\n                if (nums[j] < nums[i])\\n                    smallerNums[i]++;\\n            }\\n        }\\n        \\n        return smallerNums;\\n    }\\n}\\n```\\n\\n## Improving time complexity\\nThis solution has better time complexity but it\\'s a bit more complicated.\\nFirst, you need to clone the current nums array. Then sort the cloned array.\\nAfter you sort it, loop through it and insert each value to a HashMap. Key would be the number and value will be the current index. Only put in HashMap if the key doesn\\'t exist, if it already exists, ignore and continue. Why put the index as value? This will indicate how many numbers are smaller than this number, all others, on the left handside of the array are smaller (hence they have also smaller index value).\\n\\nFinally, loop through the original nums array. For each key, retrieve it from HashMap. This is cheap operation, of O(1) complexity. Put the value from HashMap to the new array. Finally return the new array.\\n\\nThis algorithm\\'s time complexity is: O(NlogN)\\nHowever, space wise, this solution is more expensive and takes O(N) as auxiliary space is needed to create a cloned array, a hashmap and a new array to hold the result.\\n\\n```\\nimport java.util.Arrays;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {      \\n        int[] b = nums.clone();\\n        Arrays.sort(b);\\n\\t\\t\\n        HashMap<Integer, Integer> uniques = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < b.length; i++) {\\n            if(!uniques.containsKey(b[i])) {\\n                uniques.put(b[i], i);\\n            }\\n        }\\n        \\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            var value = uniques.get(nums[i]);\\n            smallerNums[i] = value;\\n        }\\n        return smallerNums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < nums.length; j++) {\\n                if (j == i) continue;\\n                \\n                if (nums[j] < nums[i])\\n                    smallerNums[i]++;\\n            }\\n        }\\n        \\n        return smallerNums;\\n    }\\n}\\n```\n```\\nimport java.util.Arrays;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {      \\n        int[] b = nums.clone();\\n        Arrays.sort(b);\\n\\t\\t\\n        HashMap<Integer, Integer> uniques = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < b.length; i++) {\\n            if(!uniques.containsKey(b[i])) {\\n                uniques.put(b[i], i);\\n            }\\n        }\\n        \\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            var value = uniques.get(nums[i]);\\n            smallerNums[i] = value;\\n        }\\n        return smallerNums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083834,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int n = nums.length;\\n        int[] copy = Arrays.copyOf(nums, n);\\n        Arrays.sort(copy);\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            map.put(copy[i], i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = map.get(nums[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int n = nums.length;\\n        int[] copy = Arrays.copyOf(nums, n);\\n        Arrays.sort(copy);\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            map.put(copy[i], i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = map.get(nums[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065199,
                "title": "python-easy-5-way-to-understand-1-liner-64-ms-faster-than-72-51",
                "content": "I try hard to reduce the runtime many times.\\n\\ntry 1 \\n```\\nb=len(nums)\\na=[0 for i in range(b)]\\nfor i in range(len(nums)):\\n\\tfor j in range(len(nums)):\\n\\t\\tif nums[i]>nums[j]:\\n\\t\\t\\ta[i]+=1\\nreturn a\\n```\\nRuntime:516 ms\\tMemory:14.5  MB\\n\\ntry 2\\n```\\na=len(nums)\\nb,count=[0]*a,0\\nwhile count<a:\\n\\tfor i in range(a):\\n\\t\\tif nums[count]>nums[i]:    \\n\\t\\t\\tb[count]+=1\\n\\tcount+=1\\nreturn b\\n```\\nRuntime:244 ms\\tMemory:14.4 MB\\n\\ntry 3 \\n```\\na,b = [],sorted(nums) \\nfor i in nums:\\n\\tindex=b.index(i)\\n\\ta.append(index)\\nreturn a\\n```\\nRuntime:64 ms\\tMemory:14.3 MB\\n\\ntry 4\\n```\\nb = sorted(nums) \\nreturn [b.index(i) for i in nums]\\n```\\nRuntime:68 ms\\tMemory:14.4 MB\\n\\ntry 5 1 liner\\n```\\nreturn [sorted(nums) .index(i) for i in nums]\\n```\\nRuntime:232 ms\\tMemory:14.3 MB\\n\\nif you like, give me a like and comment.Thx",
                "solutionTags": [],
                "code": "```\\nb=len(nums)\\na=[0 for i in range(b)]\\nfor i in range(len(nums)):\\n\\tfor j in range(len(nums)):\\n\\t\\tif nums[i]>nums[j]:\\n\\t\\t\\ta[i]+=1\\nreturn a\\n```\n```\\na=len(nums)\\nb,count=[0]*a,0\\nwhile count<a:\\n\\tfor i in range(a):\\n\\t\\tif nums[count]>nums[i]:    \\n\\t\\t\\tb[count]+=1\\n\\tcount+=1\\nreturn b\\n```\n```\\na,b = [],sorted(nums) \\nfor i in nums:\\n\\tindex=b.index(i)\\n\\ta.append(index)\\nreturn a\\n```\n```\\nb = sorted(nums) \\nreturn [b.index(i) for i in nums]\\n```\n```\\nreturn [sorted(nums) .index(i) for i in nums]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946677,
                "title": "c-3-solutions",
                "content": "**soultion  1**\\n\\nsort + binary search  \\nTime complexity \\n O(n log(n)) +  O(n log(n)) = 2 O(n log(n)) =  O(n log(n))\\n space complexity O(n)\\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        auto sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        transform(cbegin(nums), cend(nums), begin(nums), [&sorted](const auto& val) {\\n            return lower_bound(cbegin(sorted), cend(sorted), val) - cbegin(sorted);\\n        });\\n       return nums;        \\n    }\\n```\\n\\n**soultion 2** \\n\\nsort + get the index from a hash map \\nTime complexity \\n O(n log(n))\\n O(n log(n))  +O(n) =  O(n log(n))\\n space complexity O(n)\\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        auto sorted(nums);\\n        sort(begin(sorted), end(sorted));\\n        for(int i = 0 ; i < size(sorted);++i ) counter.try_emplace(sorted[i], i);\\n        transform(cbegin(nums), cend(nums), begin(nums), [&counter](const auto& val) {\\n            return counter.find(val)->second;\\n        });\\n        return nums;        \\n    }\\n```\\n**soultion 3** \\ncalculating the partial sum from the counter\\n\\nTime complexity O(n)\\n O(n) + O(102) = O(n)\\nspace complexity O(102) = O(1)\\n\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n    array<int,102> counter {};\\n    for(const auto&val : nums)  ++counter[val + 1 ];\\n    partial_sum(cbegin(counter), cend(counter), begin(counter));\\n    transform(cbegin(nums),cend(nums), begin(nums), [&counter](const auto& val) {\\n        return counter[val];\\n    });\\n    return  nums;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        auto sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        transform(cbegin(nums), cend(nums), begin(nums), [&sorted](const auto& val) {\\n            return lower_bound(cbegin(sorted), cend(sorted), val) - cbegin(sorted);\\n        });\\n       return nums;        \\n    }\\n```\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        auto sorted(nums);\\n        sort(begin(sorted), end(sorted));\\n        for(int i = 0 ; i < size(sorted);++i ) counter.try_emplace(sorted[i], i);\\n        transform(cbegin(nums), cend(nums), begin(nums), [&counter](const auto& val) {\\n            return counter.find(val)->second;\\n        });\\n        return nums;        \\n    }\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n    array<int,102> counter {};\\n    for(const auto&val : nums)  ++counter[val + 1 ];\\n    partial_sum(cbegin(counter), cend(counter), begin(counter));\\n    transform(cbegin(nums),cend(nums), begin(nums), [&counter](const auto& val) {\\n        return counter[val];\\n    });\\n    return  nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929911,
                "title": "java-o-n-solution",
                "content": "The approach is based on the counting sort. We start by creating an array with all the frequencies of each element. Then, for each element in this array, we add how many numbers are small than the number at the current index. The last step is to extract this value for each number in the nums array.\\n\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\n        int[] freq = new int[101];\\n            \\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i]]++;\\n        }\\n           \\n        int sum = 0;\\n            \\n        for (int i = 0; i < freq.length; i++) {\\n            int temp = freq[i];                \\n            freq[i] = sum;\\n            sum = sum + temp;\\n        }\\n                               \\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = freq[nums[i]];\\n        }\\n            \\n        return nums;\\n    }",
                "solutionTags": [],
                "code": "The approach is based on the counting sort. We start by creating an array with all the frequencies of each element. Then, for each element in this array, we add how many numbers are small than the number at the current index. The last step is to extract this value for each number in the nums array.\\n\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\n        int[] freq = new int[101];\\n            \\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i]]++;\\n        }\\n           \\n        int sum = 0;\\n            \\n        for (int i = 0; i < freq.length; i++) {\\n            int temp = freq[i];                \\n            freq[i] = sum;\\n            sum = sum + temp;\\n        }\\n                               \\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = freq[nums[i]];\\n        }\\n            \\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 836537,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if (nums[i]>nums[j]){\\n                    temp[i]++;\\n                }\\n            }\\n        }\\n    return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if (nums[i]>nums[j]){\\n                    temp[i]++;\\n                }\\n            }\\n        }\\n    return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761182,
                "title": "java-stream-based-one-liner",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        return Arrays.stream(nums).map(i -> (int) Arrays.stream(nums).filter(j -> j < i).count()).toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        return Arrays.stream(nums).map(i -> (int) Arrays.stream(nums).filter(j -> j < i).count()).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752036,
                "title": "c-100-faster-solution-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>count_map(101, 0);\\n        for(int num : nums){\\n            count_map[num] += 1;\\n        }\\n        int total = 0;\\n        for (int i = 0; i < 101; i++){\\n            if(count_map[i] != 0){\\n                int num_count = count_map[i];\\n                count_map[i] = total;\\n                total += num_count;\\n            }\\n        }\\n        for( int i = 0; i < nums.size(); i++){\\n            nums[i] = count_map[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>count_map(101, 0);\\n        for(int num : nums){\\n            count_map[num] += 1;\\n        }\\n        int total = 0;\\n        for (int i = 0; i < 101; i++){\\n            if(count_map[i] != 0){\\n                int num_count = count_map[i];\\n                count_map[i] = total;\\n                total += num_count;\\n            }\\n        }\\n        for( int i = 0; i < nums.size(); i++){\\n            nums[i] = count_map[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549279,
                "title": "python-solution-with-analysis-and-complexities",
                "content": "We must find a way to know how many numbers are smaller than each number of nums. For that we need to sort the list nums. By sorting it we have by the index the number of numbers that are smaller than the considered number. But because there can be dupplicates, we increment number_of_smaller only if we did not meet the number before.\\nWe use a dictionnary because we need to access the elements in it several times, so the O(1) complexity of the acces is appreciable.\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        dict_pos = {}\\n        number_of_smaller = 0\\n        for e in sorted_nums:\\n            if e not in dict_pos:\\n                dict_pos[e] = number_of_smaller\\n            number_of_smaller += 1\\n        res = []\\n        for e in nums:\\n            res.append(dict_pos[e])\\n        return res\\n```\\nIn terms of temporal complexity, the sort function is in O(nlogn) where n is the length of the list nums, the acces in dict_pos is in O(1), so because of the two loops, the complexity is in O(n).\\nConcerning the space complexity, it is in O(n), because we store one dictionnary and one list.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        dict_pos = {}\\n        number_of_smaller = 0\\n        for e in sorted_nums:\\n            if e not in dict_pos:\\n                dict_pos[e] = number_of_smaller\\n            number_of_smaller += 1\\n        res = []\\n        for e in nums:\\n            res.append(dict_pos[e])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538482,
                "title": "python-o-n",
                "content": "```\\n def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count,lessthan = [0]*101,[0]*101\\n        for num in nums:\\n            count[num]+=1\\n        for i in range(1,101):\\n            lessthan[i]=count[i-1]+lessthan[i-1]\\n        res=[lessthan[num] for num in nums]\\n        return res``\\n```\\n",
                "solutionTags": [],
                "code": "```\\n def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count,lessthan = [0]*101,[0]*101\\n        for num in nums:\\n            count[num]+=1\\n        for i in range(1,101):\\n            lessthan[i]=count[i-1]+lessthan[i-1]\\n        res=[lessthan[num] for num in nums]\\n        return res``\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 528852,
                "title": "ruby",
                "content": "# @param {Integer[]} nums\\n# @return {Integer[]}\\n```\\ndef smaller_numbers_than_current(nums)\\n    sorted_nums = nums.sort\\n    nums.map {|num| sorted_nums.index(num)} \\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef smaller_numbers_than_current(nums)\\n    sorted_nums = nums.sort\\n    nums.map {|num| sorted_nums.index(num)} \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 527328,
                "title": "java",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        SortedMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        int prev = 0;\\n        int sum = 0;\\n        for(int key : map.keySet()) {\\n            int temp = map.get(key); // Store current key safely\\n            sum = sum + prev; // Sum = sum + previous \\n            map.put(key, sum); //Store in map the sum\\n            prev = temp; // Store temp in previous\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            nums[i] = map.get(nums[i]);\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        SortedMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 524883,
                "title": "simple-java-solution-o-nlogn-o-n",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int numsClone[] = nums.clone(); \\n        Arrays.sort(nums);\\n       for(int i = 0 ; i < nums.length;i++) {\\n           if(!map.containsKey(nums[i])) {\\n               map.put(nums[i],i);\\n           }\\n            \\n        }\\n        int[] result = new int[nums.length];\\n        for(int i = 0 ; i < numsClone.length;i++) {\\n           result[i] = map.get(numsClone[i]); \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int numsClone[] = nums.clone(); \\n        Arrays.sort(nums);\\n       for(int i = 0 ; i < nums.length;i++) {\\n           if(!map.containsKey(nums[i])) {\\n               map.put(nums[i],i);\\n           }\\n            \\n        }\\n        int[] result = new int[nums.length];\\n        for(int i = 0 ; i < numsClone.length;i++) {\\n           result[i] = map.get(numsClone[i]); \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872593,
                "title": "python-94-44-faster-simple-concept",
                "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208521,
                "title": "javascript-two-pointer-approach",
                "content": "# Complexity\\n- Time complexity: **Exponential** - **O(N^2)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **Linear** - **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let arr = [];\\n    for(let i=0; i<nums.length; i++){\\n        let j=0, count=0;\\n        while(j < nums.length){\\n            if(nums[j] < nums[i]){\\n                count++;\\n            }\\n            j++;\\n        }\\n        arr.push(count);\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let arr = [];\\n    for(let i=0; i<nums.length; i++){\\n        let j=0, count=0;\\n        while(j < nums.length){\\n            if(nums[j] < nums[i]){\\n                count++;\\n            }\\n            j++;\\n        }\\n        arr.push(count);\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068636,
                "title": "by-c-sorted-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sort",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658737,
                "title": "c-instead-of-using-lots-of-space-see-the-best-way",
                "content": "# vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        vector<int>ans;\\n\\t\\t//using map it will take lots of time and space too\\n\\t\\t// so do the problem using brute force approach\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "# vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        vector<int>ans;\\n\\t\\t//using map it will take lots of time and space too\\n\\t\\t// so do the problem using brute force approach\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2545658,
                "title": "simple-hashmap-solution",
                "content": "```\\nclass Solution {\\n    \\n     public int[] smallerNumbersThanCurrent(int[] nums) {\\n         HashMap<Integer, Integer> map = new HashMap<>();\\n         \\n         int []copy = nums.clone();\\n         \\n         Arrays.sort(copy);\\n         for(int i=0;i<copy.length;i++){\\n             map.putIfAbsent(copy[i],i);\\n         }         \\n         for(int i=0;i<nums.length;++i){\\n             copy[i]= map.get(nums[i]);\\n         }\\n         return copy;\\n     }\\n\\n```\\n**Credit To : rxdbeard**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n     public int[] smallerNumbersThanCurrent(int[] nums) {\\n         HashMap<Integer, Integer> map = new HashMap<>();\\n         \\n         int []copy = nums.clone();\\n         \\n         Arrays.sort(copy);\\n         for(int i=0;i<copy.length;i++){\\n             map.putIfAbsent(copy[i],i);\\n         }         \\n         for(int i=0;i<nums.length;++i){\\n             copy[i]= map.get(nums[i]);\\n         }\\n         return copy;\\n     }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359295,
                "title": "my-python-solution",
                "content": "```class Solution(object):\\n    def smallerNumbersThanCurrent(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t\\n        arr = sorted(nums)\\n\\t\\t\\n        for i in range(len(nums)):\\n            nums[i] = arr.index(nums[i])\\n        \\n        return nums\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution(object):\\n    def smallerNumbersThanCurrent(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t\\n        arr = sorted(nums)\\n\\t\\t\\n        for i in range(len(nums)):\\n            nums[i] = arr.index(nums[i])\\n        \\n        return nums\\n",
                "codeTag": "Java"
            },
            {
                "id": 2208278,
                "title": "c-hash-table-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> s(101,-1);        //this is our hash table. \\n\\t\\t//We have created 101 elements in this vector and initialised to the to -1\\n        vector<int> f=nums;     // this vector f will be our original vector given in the question. \\n        sort(nums.begin(),nums.end());  //sorting the nums vector\\n\\t\\t //Using for loop we are entering the value in the hash table s \\n\\t\\t //where index of the table is equal to the value in the nums array. //Since we have already sorted the nums vector,\\n\\t\\t //the index of an element in nums gives the number of elements //smaller than it. \\n\\t\\t //for eg. ( in sorted vector [1,2,5] index of element 5 is 2, hence 2 numbers are smaller than it.)\\n        for(int i=0;i<nums.size();i++){    \\n            if(s[nums[i]]==-1){\\n                s[nums[i]]=i;                \\n            }\\n        }\\n\\t\\t//finally we reassign the values to un sorted vector f by retrieving its value from hash table s\\n        for(int i=0;i<f.size();i++){\\n            f[i]=s[f[i]];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> s(101,-1);        //this is our hash table. \\n\\t\\t//We have created 101 elements in this vector and initialised to the to -1\\n        vector<int> f=nums;     // this vector f will be our original vector given in the question. \\n        sort(nums.begin(),nums.end());  //sorting the nums vector\\n\\t\\t //Using for loop we are entering the value in the hash table s \\n\\t\\t //where index of the table is equal to the value in the nums array. //Since we have already sorted the nums vector,\\n\\t\\t //the index of an element in nums gives the number of elements //smaller than it. \\n\\t\\t //for eg. ( in sorted vector [1,2,5] index of element 5 is 2, hence 2 numbers are smaller than it.)\\n        for(int i=0;i<nums.size();i++){    \\n            if(s[nums[i]]==-1){\\n                s[nums[i]]=i;                \\n            }\\n        }\\n\\t\\t//finally we reassign the values to un sorted vector f by retrieving its value from hash table s\\n        for(int i=0;i<f.size();i++){\\n            f[i]=s[f[i]];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166125,
                "title": "python-faster-76-02-explained",
                "content": "# Python Easy Solution.\\n**Faster Than 76.02%**\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        # in sorted_num every num\\'s i(index) shows just how many numbers are smaller than it, \\n        # so we just add the indexes and return it.\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        # in sorted_num every num\\'s i(index) shows just how many numbers are smaller than it, \\n        # so we just add the indexes and return it.\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902691,
                "title": "solved-using-hashmap-and-priority-queue",
                "content": "Added every element of the array in the priority queue and after that in map added the peek element and size of the priority queue - 1. As the peek element of the priority queue tells us about the largest element in the queue, after adding it to the map, Removed it from the map.\\n\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0; i<nums.length; i++) {\\n            pq.add(nums[i]);\\n        }\\n        \\n        int[] arr = new int[nums.length];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            map.put(pq.peek(), pq.size()-1);\\n            pq.remove();\\n        }\\n        \\n       \\n        for(int i=0; i<nums.length; i++) {\\n            arr[i] = map.get(nums[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "Added every element of the array in the priority queue and after that in map added the peek element and size of the priority queue - 1. As the peek element of the priority queue tells us about the largest element in the queue, after adding it to the map, Removed it from the map.\\n\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0; i<nums.length; i++) {\\n            pq.add(nums[i]);\\n        }\\n        \\n        int[] arr = new int[nums.length];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            map.put(pq.peek(), pq.size()-1);\\n            pq.remove();\\n        }\\n        \\n       \\n        for(int i=0; i<nums.length; i++) {\\n            arr[i] = map.get(nums[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1464971,
                "title": "c-solution-using-map-94-70",
                "content": "**Please Upvote if you like the solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n=nums.size();\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int c=0,temp;\\n        for(auto i:mp)\\n        {\\n            temp=i.second;  \\n            mp[i.first]=c;\\n            c+=temp;  \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=mp[nums[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n=nums.size();\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int c=0,temp;\\n        for(auto i:mp)\\n        {\\n            temp=i.second;  \\n            mp[i.first]=c;\\n            c+=temp;  \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=mp[nums[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428526,
                "title": "java-easy-solution-for-90-fast-and-2-ms-runtime",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Storing number count in an array ofsmall[0,1,2,3,4,5....]\\n        int [] small= new int[101];\\n        for(int i =0;i<nums.length;i++){\\n            small[nums[i]]++;\\n        }\\n        \\n        //adding elements from the past elements;\\n        //0 1 2 3 4 5 6 7 8 ----->element\\n        //0 1 2 1 0 0 0 0 1  ------>count of the element in the array\\n        //0 1 3 4 4 4 4 4 5 -------->sum of the previous element\\n        for(int i =1;i<101;i++){\\n            small[i]+=small[i-1];\\n        }\\n        \\n        //Returning the value of sum[index-1] \\n        for(int i =0;i<nums.length;i++){\\n            int position = nums[i];\\n            if(position==0) nums[i]=0;\\n            else{\\n                nums[i]= small[position-1];\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Storing number count in an array ofsmall[0,1,2,3,4,5....]\\n        int [] small= new int[101];\\n        for(int i =0;i<nums.length;i++){\\n            small[nums[i]]++;\\n        }\\n        \\n        //adding elements from the past elements;\\n        //0 1 2 3 4 5 6 7 8 ----->element\\n        //0 1 2 1 0 0 0 0 1  ------>count of the element in the array\\n        //0 1 3 4 4 4 4 4 5 -------->sum of the previous element\\n        for(int i =1;i<101;i++){\\n            small[i]+=small[i-1];\\n        }\\n        \\n        //Returning the value of sum[index-1] \\n        for(int i =0;i<nums.length;i++){\\n            int position = nums[i];\\n            if(position==0) nums[i]=0;\\n            else{\\n                nums[i]= small[position-1];\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397270,
                "title": "c-brute-force-optimal",
                "content": "```\\n//Approach-1 (Brute Force)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == j) continue;\\n                \\n                if(nums[i] > nums[j])\\n                    result[i]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Optimal using map)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> mp(101);\\n        \\n        for(int i = 0; i<n; i++) mp[nums[i]]++;\\n        \\n        int sum = 0;\\n        for(int i = 1; i<101; i++) {\\n            mp[i] += mp[i-1];\\n        }\\n        \\n        for(int i = 0; i<n; i++)\\n            nums[i] = nums[i]==0 ? 0 : mp[nums[i]-1];\\n        \\n        return nums;\\n    }\\n};    \\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Brute Force)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == j) continue;\\n                \\n                if(nums[i] > nums[j])\\n                    result[i]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Optimal using map)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> mp(101);\\n        \\n        for(int i = 0; i<n; i++) mp[nums[i]]++;\\n        \\n        int sum = 0;\\n        for(int i = 1; i<101; i++) {\\n            mp[i] += mp[i-1];\\n        }\\n        \\n        for(int i = 0; i<n; i++)\\n            nums[i] = nums[i]==0 ? 0 : mp[nums[i]-1];\\n        \\n        return nums;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336603,
                "title": "swift-one-liner",
                "content": "```\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        return nums.map { num in nums.filter { $0 < num }.count }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        return nums.map { num in nums.filter { $0 < num }.count }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218252,
                "title": "c-beats-100-solution",
                "content": "first lopp finds the maximum | second loop adds the count of each element in first vector | second loop finds the elements that are less than that element | final loop just substitues the answer in the solution.\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& t) {\\n        int max=INT_MIN;\\n        for(int i=0;i<t.size();i++){\\n            if(max<t[i])\\n                max=t[i];\\n        }\\n        vector<int> l1(max+1,0);\\n        for(int i=0;i<t.size();i++){\\n            l1[t[i]]++;\\n        }\\n        vector<int> l2;\\n        int sum=0;\\n        for(int i=0;i<l1.size();i++){\\n            l2.push_back(sum);\\n            sum+=l1[i];\\n        }\\n        for(int i=0;i<t.size();i++){\\n            t[i]=l2[t[i]];\\n        }\\n        return t;\\n    }\\n};\\n```\\n\\n**Do like if you think the solution is decent keeps me motivated**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& t) {\\n        int max=INT_MIN;\\n        for(int i=0;i<t.size();i++){\\n            if(max<t[i])\\n                max=t[i];\\n        }\\n        vector<int> l1(max+1,0);\\n        for(int i=0;i<t.size();i++){\\n            l1[t[i]]++;\\n        }\\n        vector<int> l2;\\n        int sum=0;\\n        for(int i=0;i<l1.size();i++){\\n            l2.push_back(sum);\\n            sum+=l1[i];\\n        }\\n        for(int i=0;i<t.size();i++){\\n            t[i]=l2[t[i]];\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070102,
                "title": "well-explained-o-n-time-space-solution-faster-than-100-0ms",
                "content": "The idea is :\\n* Count occurences of all values( 1-100 )\\n* Then we have to check for each value, how many are smaller than \\'i\\'  :\\n* We colud do that by either visiting count of all values less than \\'i\\' and adding them\\n* OR we could could create something like a cumulative sum which keeps count of number of smaller elements\\n ```\\n\\t  for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n```\\n* And then you just return count of numbers smaller than \\'i\\'\\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> count(101);\\n        vector<int> res( nums.size() );\\n        for( int& i : nums ) count[i] += 1;\\n        int sum = 0;\\n        for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n        for( int i=0; i<nums.size(); i++ )\\n        {\\n            res[i] = count[ nums[i] ];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t  for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n```\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> count(101);\\n        vector<int> res( nums.size() );\\n        for( int& i : nums ) count[i] += 1;\\n        int sum = 0;\\n        for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n        for( int i=0; i<nums.size(); i++ )\\n        {\\n            res[i] = count[ nums[i] ];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049134,
                "title": "java-bucket-solution-with-in-depth-explanation",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t    // constraint: values 0 <= nums[i] <= 100\\n        // that means we need 101 slots \\n        int[] bucket = new int[101];\\n        int[] res = new int[nums.length];\\n\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            // Every occurance of a value, \\n            // will increase the values\\' spot by one\\n            bucket[nums[i]]++;\\n\\t    }\\n            \\n        for(int i = 1; i < 101; i++) {\\n            // Store the running sum - the sum up to current spot -\\n            // instead of just the number of occurances of the current spot\\n            // Spot 0: Count of 0\\'s = 2\\n            // Spot 1: Count of 1\\'s = 1\\n            // Spot 2: Count of 2\\'s = 1\\n            // will change to\\n            // Spot 0: will always be 0, since we don\\'t have negative numbers\\n            // Spot 1: Count of 0\\'s = 2\\n            // Spot 2: Count of 0\\'s + Count of 1\\'s = 3\\n            // and so on\\n            bucket[i] += bucket[i-1];\\n        }\\n        \\n        // for the resulting array we must put the entries in the bucket\\n        // to the right places\\n        for(int i=0; i < nums.length; i++) {\\n            // running sum up to 0 will always be 0 as explained above\\n            if (nums[i] == 0) {\\n                res[i] = 0;\\n            } else {\\n                // just retrieve the running sum up to i (but excluding i)\\n                // out of it\\'s spot and save to\\n                res[i] = bucket[nums[i] - 1];\\n            }\\n        }\\n              \\n        return res;\\n    }\\n}\\n```\\n\\nAlthough it\\'s a smart (and fast) solution, I wouldn\\'t recommend it in a real production environment since it heavily depends on the fact, that the given constraints will forever remain the same else the code will stop working. An easy solution to this problem is to dynamically determine the bucket size like this (This solution will put you in the ~65% range):\\n\\n```\\nint bucketSize = Arrays.stream(nums).max().getAsInt() + 1;\\nint[] bucket = new int[bucketSize];\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t    // constraint: values 0 <= nums[i] <= 100\\n        // that means we need 101 slots \\n        int[] bucket = new int[101];\\n        int[] res = new int[nums.length];\\n\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            // Every occurance of a value, \\n            // will increase the values\\' spot by one\\n            bucket[nums[i]]++;\\n\\t    }\\n            \\n        for(int i = 1; i < 101; i++) {\\n            // Store the running sum - the sum up to current spot -\\n            // instead of just the number of occurances of the current spot\\n            // Spot 0: Count of 0\\'s = 2\\n            // Spot 1: Count of 1\\'s = 1\\n            // Spot 2: Count of 2\\'s = 1\\n            // will change to\\n            // Spot 0: will always be 0, since we don\\'t have negative numbers\\n            // Spot 1: Count of 0\\'s = 2\\n            // Spot 2: Count of 0\\'s + Count of 1\\'s = 3\\n            // and so on\\n            bucket[i] += bucket[i-1];\\n        }\\n        \\n        // for the resulting array we must put the entries in the bucket\\n        // to the right places\\n        for(int i=0; i < nums.length; i++) {\\n            // running sum up to 0 will always be 0 as explained above\\n            if (nums[i] == 0) {\\n                res[i] = 0;\\n            } else {\\n                // just retrieve the running sum up to i (but excluding i)\\n                // out of it\\'s spot and save to\\n                res[i] = bucket[nums[i] - 1];\\n            }\\n        }\\n              \\n        return res;\\n    }\\n}\\n```\n```\\nint bucketSize = Arrays.stream(nums).max().getAsInt() + 1;\\nint[] bucket = new int[bucketSize];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996785,
                "title": "easy-c-o-n-for-how-many-numbers-are-smaller-than-the-current-number",
                "content": "1. Keep track of count of each number in nums\\n2. Make prefix sum of count of numbers less than the current number.\\n3. Update ans vector\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        vector<int> count(101);\\n        vector<int> ans(nums.size());\\n        \\n        for(int i=0;i<nums.size();i++)\\n            count[nums[i]]++;\\n        \\n        for(int i=1;i<=100;i++)\\n        {\\n            count[i]+=count[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                ans[i]=0;\\n            else\\n                ans[i]=count[nums[i]-1];\\n        }\\n        return ans;\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        vector<int> count(101);\\n        vector<int> ans(nums.size());\\n        \\n        for(int i=0;i<nums.size();i++)\\n            count[nums[i]]++;\\n        \\n        for(int i=1;i<=100;i++)\\n        {\\n            count[i]+=count[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                ans[i]=0;\\n            else\\n                ans[i]=count[nums[i]-1];\\n        }\\n        return ans;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851642,
                "title": "java-runtime-99-and-1ms-using-freq-array",
                "content": "```\\nclass Solution {\\n    // 8 1 2 2 3\\n    // 0 0 0 0 0 0 0 0\\n    //-----------------\\n    // 1 2 1 0 0 0 0 1\\n    // 1 3 4 4 4 4 4 5\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]helper = new int [101];\\n        for(int i=0;i<nums.length;i++){\\n            helper[nums[i]]++;\\n        }\\n        for(int i=1;i<101;i++){\\n            helper[i]+=helper[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){continue;}\\n            nums[i] = helper[nums[i]-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // 8 1 2 2 3\\n    // 0 0 0 0 0 0 0 0\\n    //-----------------\\n    // 1 2 1 0 0 0 0 1\\n    // 1 3 4 4 4 4 4 5\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]helper = new int [101];\\n        for(int i=0;i<nums.length;i++){\\n            helper[nums[i]]++;\\n        }\\n        for(int i=1;i<101;i++){\\n            helper[i]+=helper[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){continue;}\\n            nums[i] = helper[nums[i]-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835391,
                "title": "clean-python",
                "content": "Solution 1: slow but clean\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```\\n\\nSolution 2: faster, but need more space (additional hash map)\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        lookup = {}\\n        for i, v in enumerate(sorted(nums)):\\n            if v in lookup:\\n                continue\\n            lookup[v] = i\\n        return [lookup[num] for num in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        lookup = {}\\n        for i, v in enumerate(sorted(nums)):\\n            if v in lookup:\\n                continue\\n            lookup[v] = i\\n        return [lookup[num] for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822167,
                "title": "c-sol-with-detailed-comments-o-n-time-faster-than-95-54",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        \\n        vector<int> counts(101, 0);\\n        /*101 because 0 <= nums[i] <= 100;\\n        Parse the nums vector, and take the corresponding val as index of the counts   \\n        vector and increase one.\\n        */\\n        for(int val : nums ){\\n            int index = val;\\n            counts[index] ++;\\n        }\\n        \\n        /* Parse the lessThanCounts vector, for the index = i, sum will contain sum\\n\\t\\tof all the counts from i = 0 to i-1, given the counts array and will assign it to \\n\\t\\tlessThanCounts[i], and then add counts[i] to the running \"sum\" variable */\\n        \\n        vector<int> lessThanCounts(101, 0);\\n        int sum = 0;\\n        for(int i = 0 ; i < 101 ; i++){\\n            lessThanCounts[i] = sum;\\n            sum += counts[i];\\n        }\\n        \\n\\t\\t/* Now the count of each \"val\" of the vector nums is the value present at index \"val\" of the\\n\\t\\tlessThanCounts vector*/\\n        \\n        vector<int> ans;\\n        for(int val : nums){\\n            ans.push_back(lessThanCounts[val]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        \\n        vector<int> counts(101, 0);\\n        /*101 because 0 <= nums[i] <= 100;\\n        Parse the nums vector, and take the corresponding val as index of the counts   \\n        vector and increase one.\\n        */\\n        for(int val : nums ){\\n            int index = val;\\n            counts[index] ++;\\n        }\\n        \\n        /* Parse the lessThanCounts vector, for the index = i, sum will contain sum\\n\\t\\tof all the counts from i = 0 to i-1, given the counts array and will assign it to \\n\\t\\tlessThanCounts[i], and then add counts[i] to the running \"sum\" variable */\\n        \\n        vector<int> lessThanCounts(101, 0);\\n        int sum = 0;\\n        for(int i = 0 ; i < 101 ; i++){\\n            lessThanCounts[i] = sum;\\n            sum += counts[i];\\n        }\\n        \\n\\t\\t/* Now the count of each \"val\" of the vector nums is the value present at index \"val\" of the\\n\\t\\tlessThanCounts vector*/\\n        \\n        vector<int> ans;\\n        for(int val : nums){\\n            ans.push_back(lessThanCounts[val]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810082,
                "title": "time-o-n-space-o-1-constant-100-faster-memory-simple-solution-with-explanation",
                "content": "Java\\nTime: O(n), where n is length of nums.length, assuming nums.length can be any number\\nSpace: O(1) constant space of length 101\\n\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Go through the given array and save the frequency of each number element\\n        int[] valFrequency = new int[101]; \\n        for (int i = 0; i < nums.length; i++) {\\n                valFrequency[nums[i]]++; //map each number element as it\\'s own index\\n        }\\n        \\n        //For possible numbers 0 to 100, go from left to right and count frequency, where every number is smaller than the next iteration)\\n        int count = 0;\\n        for (int i = 0; i < valFrequency.length; i++) {\\n            if (valFrequency[i] != 0) { \\n                int freqHolder = valFrequency[i]; //store the frequency of the current number\\n                valFrequency[i] = count; //replace the purpose of the element from frequency to count (re-using the same array to save space)\\n                count = count + freqHolder ; //add the saved frequency to the count answer\\n            }\\n        }\\n        \\n        //Replace the given array\\'s elements with its own count answer\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = valFrequency[nums[i]];\\n        }\\n        \\n\\n        return nums;\\n        \\n    }\\n}\\n```\\nPlease feel free to comment for discussions",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Go through the given array and save the frequency of each number element\\n        int[] valFrequency = new int[101]; \\n        for (int i = 0; i < nums.length; i++) {\\n                valFrequency[nums[i]]++; //map each number element as it\\'s own index\\n        }\\n        \\n        //For possible numbers 0 to 100, go from left to right and count frequency, where every number is smaller than the next iteration)\\n        int count = 0;\\n        for (int i = 0; i < valFrequency.length; i++) {\\n            if (valFrequency[i] != 0) { \\n                int freqHolder = valFrequency[i]; //store the frequency of the current number\\n                valFrequency[i] = count; //replace the purpose of the element from frequency to count (re-using the same array to save space)\\n                count = count + freqHolder ; //add the saved frequency to the count answer\\n            }\\n        }\\n        \\n        //Replace the given array\\'s elements with its own count answer\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = valFrequency[nums[i]];\\n        }\\n        \\n\\n        return nums;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801471,
                "title": "faster-than-72-of-python3",
                "content": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l = nums[:]\\n        l.sort()\\n        return [l.index(n) for n in nums]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l = nums[:]\\n        l.sort()\\n        return [l.index(n) for n in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754084,
                "title": "two-simple-c-solution-complexity-o-n-log-n-and-o-n",
                "content": "**Solution 1:**  Sorting and position finding\\n\\n1. Copy the input and Sort it. \\n2. Now try to find the position of each value with respect to starting element and that value would be number of elements lesser than it.\\n3. Time Complexity : O(n log(n)), Space Complexity : O(n)\\n\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        vector<int> copy(nums);\\n        \\n        sort(copy.begin(), copy.end());\\n        auto it = copy.begin();\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            it = find(copy.begin(), copy.end(), nums[i]);\\n            res.push_back(it - copy.begin());\\n        }\\n        return res;\\n    }\\n```\\n\\t\\n\\t\\n**Solution 2:** Count array\\n\\n1. Make Count array for input since the range of values of num is between 0 to 100 (inclusive)\\n2. Now Compute Sum of elements lesser than current element.\\n3. Traverse the original input vector and get values from count_sum_arr one by one which can be pushed to result (answer)\\n4. Time Complexity : O(R) , Space Complexity : O(R) where R is range of values of nums[i]\\n\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        int count_arr[101] = {0}; // Since nums[i] can have max value of 100\\n        int count_array_size = 0;\\n        int i = 0, val = 0;\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            count_arr[nums[i]]++;\\n            if (nums[i] > count_array_size) // Getting the max range\\n                count_array_size = nums[i];\\n        }\\n        \\n        int count_sum_arr[101] = {0};\\n        count_sum_arr[0] = 0;\\n        for (i = 1; i <= count_array_size; i++)\\n            count_sum_arr[i] = count_sum_arr[i - 1] + count_arr[i-1];\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            val = count_sum_arr[nums[i]];\\n            res.push_back(val);\\n        }\\n        \\n        return res;\\n    }\\n\\t```\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        vector<int> copy(nums);\\n        \\n        sort(copy.begin(), copy.end());\\n        auto it = copy.begin();\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            it = find(copy.begin(), copy.end(), nums[i]);\\n            res.push_back(it - copy.begin());\\n        }\\n        return res;\\n    }\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        int count_arr[101] = {0}; // Since nums[i] can have max value of 100\\n        int count_array_size = 0;\\n        int i = 0, val = 0;\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            count_arr[nums[i]]++;\\n            if (nums[i] > count_array_size) // Getting the max range\\n                count_array_size = nums[i];\\n        }\\n        \\n        int count_sum_arr[101] = {0};\\n        count_sum_arr[0] = 0;\\n        for (i = 1; i <= count_array_size; i++)\\n            count_sum_arr[i] = count_sum_arr[i - 1] + count_arr[i-1];\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            val = count_sum_arr[nums[i]];\\n            res.push_back(val);\\n        }\\n        \\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 747187,
                "title": "easy-c-o-n-solution-without-sorting",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums)\\n    {\\n        int count[101] = {0}, n = nums.size();\\n        vector<int>ans(n);\\n\\n        for(int i=0; i<n; i++)\\n            count[nums[i]]++;\\n\\n        for(int i=1; i<101; i++)\\n            count[i] += count[i-1];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 0)\\n                ans[i] = 0;\\n            else\\n                ans[i] = count[nums[i]-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums)\\n    {\\n        int count[101] = {0}, n = nums.size();\\n        vector<int>ans(n);\\n\\n        for(int i=0; i<n; i++)\\n            count[nums[i]]++;\\n\\n        for(int i=1; i<101; i++)\\n            count[i] += count[i-1];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 0)\\n                ans[i] = 0;\\n            else\\n                ans[i] = count[nums[i]-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729834,
                "title": "python-simple-solution-6-liner",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums):\\n        \\n        counter = [0] * 102\\n        for x in nums:\\n            counter[x+1] += 1\\n        \\n        for i in range(1, 102):\\n            counter[i] += counter[i-1]\\n        \\n        return [counter[nums[i]] for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums):\\n        \\n        counter = [0] * 102\\n        for x in nums:\\n            counter[x+1] += 1\\n        \\n        for i in range(1, 102):\\n            counter[i] += counter[i-1]\\n        \\n        return [counter[nums[i]] for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637309,
                "title": "javascript-brute-force-and-optimized",
                "content": "Brute Force\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let result = [];\\n    for(let i=0; i<nums.length; i++) {\\n        let count = 0;\\n        for(let j=0; j<nums.length; j++) {\\n            if(j!=i && nums[j] < nums[i]) {\\n                count++;\\n            }            \\n        }\\n        result.push(count);\\n    }    \\n    return result;\\n};\\n```\\n\\nOptimized:\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let result = [];\\n    for(let i=0; i<nums.length; i++) {\\n        let count = 0;\\n        for(let j=0; j<nums.length; j++) {\\n            if(j!=i && nums[j] < nums[i]) {\\n                count++;\\n            }            \\n        }\\n        result.push(count);\\n    }    \\n    return result;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588301,
                "title": "go-o-n",
                "content": "```go\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n    buckets := make([]int, 101)\\n    for _, v := range nums {\\n        buckets[v]++\\n    }\\n    \\n    sum := 0\\n    sums := make([]int, 101)\\n    for i, v := range buckets {\\n        sums[i] = sum\\n        sum += v\\n    }\\n\\n    res := make([]int, len(nums))\\n    for i, v := range nums {\\n        res[i] = sums[v]\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n    buckets := make([]int, 101)\\n    for _, v := range nums {\\n        buckets[v]++\\n    }\\n    \\n    sum := 0\\n    sums := make([]int, 101)\\n    for i, v := range buckets {\\n        sums[i] = sum\\n        sum += v\\n    }\\n\\n    res := make([]int, len(nums))\\n    for i, v := range nums {\\n        res[i] = sums[v]\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574134,
                "title": "java-1ms-99-time-o-n-using-counting-sort",
                "content": "\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] counts = new int[102];\\n        for (int n : nums) {\\n            counts[n+1] += 1;\\n        }\\n        for (int i = 1; i < counts.length; i++) {\\n            counts[i] = counts[i-1] + counts[i];\\n        }\\n\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = counts[nums[i]];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] counts = new int[102];\\n        for (int n : nums) {\\n            counts[n+1] += 1;\\n        }\\n        for (int i = 1; i < counts.length; i++) {\\n            counts[i] = counts[i-1] + counts[i];\\n        }\\n\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = counts[nums[i]];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 531206,
                "title": "100-explained-counting-sort-linear-swift-syntax",
                "content": "This is a play on Counting Sort. It is slightly modified at the end, but the idea is still there. \\nThere are MANY solutions already posted like this, but with almost no explanation.\\n\\nIf I am missing anything or incorrect, just leave a comment explaining why and how. Counting sort is one of those ones that is kind of hard to wrap your head around at first, and I recommend watching a video on counting sort to understand what is going on.\\n```\\n\\n```func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n    var countOfNums = [Int](repeating: 0, count: 101) \\n\\t\\t//since max in this case is 100, you could theoretically just find the max number, and use this instead, but it\\'s just easier in this case to write 101.\\n\\t\\t//all these numbers start with 0 occurences: [0,0,0,0.....,0,0] -length=100\\n    \\n\\tfor num in nums{\\n        countOfNums[num] += 1 //Each time you find a number, add this occurence to the counts array\\n\\t\\t\\t//[0,1,2,1,0,0,0,0,1] if you use a test case like [8,1,2,2,3]\\n\\t\\t\\t// 0 counts of 0, 1 count of 1, 2 of 2, 1 of 3, and 1 of 8.... all the way to 100...\\n    }\\n    var sumOfSmallerNums = 0     // start sum as 0, this will keep tally for us.\\n    var countOfSmallerNums = [Int](repeating: 0, count: 101) //number of smaller numbers than current\\n    \\n\\tfor i in 1...100 {\\n        sumOfSmallerNums += countOfNums[i-1] //this part of counting sort shifts all counts of a number to the right one, to get the correct amount of numbers smaller than it.\\n        countOfSmallerNums[i] = sumOfSmallerNums //the sum of all numbers smaller than the current number\\n    }\\n    var finalArray = [Int](repeating: 0, count: nums.count) //Note, these repeating 0 arrays aren\\'t necessary, but it takes out a block of If,Else statments to check if the sumOfSmallerNums == 0, I haven\\'t checked if it is actually any faster, but it looks cool. (Useful for people using languages without repeating array)\\n   \\n    for i in 0..<nums.count{\\n        finalArray[i] = countOfSmallerNums[nums[i]] //the answer array is the summ array in the order of the initial array\\n\\t\\t\\t//So for [8,1,2,2,3] it will return the number of smaller numbers in the same order... [4,0,1,1,3] in this case.\\n    }\\n    return finalArray\\n}",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528355,
                "title": "my-o-n-java-solution-beating-99",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        for(int ele: nums){\\n            count[ele]++;\\n        }\\n        \\n        int[] res = new int[nums.length];\\n        int[] sums = new int[101];\\n        sums[0] = count[0];\\n        \\n        for(int i=1;i<=100;i++){\\n            sums[i] = count[i] + sums[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            res[i] = sums[nums[i]] - count[nums[i]];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        for(int ele: nums){\\n            count[ele]++;\\n        }\\n        \\n        int[] res = new int[nums.length];\\n        int[] sums = new int[101];\\n        sums[0] = count[0];\\n        \\n        for(int i=1;i<=100;i++){\\n            sums[i] = count[i] + sums[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            res[i] = sums[nums[i]] - count[nums[i]];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526039,
                "title": "javascript-solution",
                "content": "```\\nlet smallerNumbersThanCurrent = function(nums) {\\n    let sortNums = nums.slice().sort((a, b) => a - b),\\n        result = []\\n    for (let i = 0; i < nums.length; i ++) {\\n        result.push(sortNums.indexOf(nums[i]))\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet smallerNumbersThanCurrent = function(nums) {\\n    let sortNums = nums.slice().sort((a, b) => a - b),\\n        result = []\\n    for (let i = 0; i < nums.length; i ++) {\\n        result.push(sortNums.indexOf(nums[i]))\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525033,
                "title": "python-simple-solution",
                "content": "O(n^2) Time Solution\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if i != j and nums[i] > nums[j]:\\n                    count += 1\\n            res.append(count)\\n        \\n        return res\\n```\\n\\nO(nlog(n)) Time Solution\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        s, res, d = sorted(nums), [-1] * len(nums), {}\\n\\n        for i, e in enumerate(nums):\\n            if e in d: d[e].append(i)\\n            else: d[e] = [i]\\n        \\n        for i, e in enumerate(s):\\n            l = len(s[:i])\\n            for j in d[e]:\\n                if res[j] == -1:\\n                    res[j] = l\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if i != j and nums[i] > nums[j]:\\n                    count += 1\\n            res.append(count)\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        s, res, d = sorted(nums), [-1] * len(nums), {}\\n\\n        for i, e in enumerate(nums):\\n            if e in d: d[e].append(i)\\n            else: d[e] = [i]\\n        \\n        for i, e in enumerate(s):\\n            l = len(s[:i])\\n            for j in d[e]:\\n                if res[j] == -1:\\n                    res[j] = l\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524989,
                "title": "java-hash-count",
                "content": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int prev = nums[0], cnt = 0;\\n        map.put(prev, 0);\\n        for (int n : nums) {\\n            if (prev != n) {\\n                map.put(n, cnt);\\n                prev = n;\\n            }\\n            cnt++;\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int prev = nums[0], cnt = 0;\\n        map.put(prev, 0);\\n        for (int n : nums) {\\n            if (prev != n) {\\n                map.put(n, cnt);\\n                prev = n;\\n            }\\n            cnt++;\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524887,
                "title": "straight-forward-python-solution",
                "content": "```\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tres = []\\n\\tfor x in nums:\\n\\t\\tres.append(sum([y < x for y in nums]))\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tres = []\\n\\tfor x in nums:\\n\\t\\tres.append(sum([y < x for y in nums]))\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 524823,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] table = new int[101];\\n        int[] res = new int[nums.length];\\n        for(int n : nums){\\n            table[n]++;\\n        }\\n        int sum = 0;\\n        for(int i = 0; i < 101; i++){\\n            sum += table[i];\\n            table[i] = sum;\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 0){\\n                res[i] = 0;\\n            }else{\\n                res[i] = table[nums[i] - 1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] table = new int[101];\\n        int[] res = new int[nums.length];\\n        for(int n : nums){\\n            table[n]++;\\n        }\\n        int sum = 0;\\n        for(int i = 0; i < 101; i++){\\n            sum += table[i];\\n            table[i] = sum;\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 0){\\n                res[i] = 0;\\n            }else{\\n                res[i] = table[nums[i] - 1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976912,
                "title": "brute-force-method-sorting-and-dictionary-method",
                "content": "# Brute Force Method: \\n\\n# Complexity\\n- Time complexity:\\nO(N^2) - It\\'s kind of inefficient with larger inputs!\\n\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        List = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if(j != i and nums[j] < nums[i]):\\n                    count = count + 1\\n            List.append(count)\\n        return List\\n\\n\\n```\\n\\n# Sorting and Dictionary Method: \\n\\n# Complexity\\n- Time Complexity: \\nO(NlogN)\\n\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        count_dict = {}\\n        result = []\\n        for i, num in enumerate(sorted_nums):\\n            if num not in count_dict:\\n                count_dict[num] = i\\n                \\n        for num in nums:\\n            result.append(count_dict[num])\\n            \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        List = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if(j != i and nums[j] < nums[i]):\\n                    count = count + 1\\n            List.append(count)\\n        return List\\n\\n\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        count_dict = {}\\n        result = []\\n        for i, num in enumerate(sorted_nums):\\n            if num not in count_dict:\\n                count_dict[num] = i\\n                \\n        for num in nums:\\n            result.append(count_dict[num])\\n            \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871615,
                "title": "c-python-brute-force-approach-too-easy-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose we have the following input vector:\\n```\\nvector<int> nums = {8, 1, 2, 2, 3};\\n```\\n\\nNow, let\\'s go through the function step by step:\\n\\n1. Initialize an empty vector `ans` to store the results.\\n2. Start a loop to iterate through the `nums` vector.\\n   - First iteration: `i` is 0, `nums[i]` is 8.\\n     - Initialize `count` to 0.\\n     - Start another loop to compare the current element (`nums[i]`) with all the elements in the `nums` vector.\\n       - First comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 8). It\\'s not smaller, so no change in `count`.\\n       - Second comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 1). Increment `count` to 1.\\n       - Third comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 2). Increment `count` to 2.\\n       - Fourth comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 2). Increment `count` to 3.\\n       - Fifth comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 3). Increment `count` to 4.\\n     - Push `count` (which is 4) into the `ans` vector.\\n   - Second iteration: `i` is 1, `nums[i]` is 1.\\n     - Initialize `count` to 0.\\n     - Start another loop to compare the current element (`nums[i]`) with all the elements in the `nums` vector.\\n       - First comparison: `nums[i]` (which is 1) is not greater than `nums[j]` (which is 8), so no change in `count`.\\n       - Second comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 1). It\\'s not greater, so no change in `count`.\\n       - Third comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 2). It\\'s not greater, so no change in `count`.\\n       - Fourth comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 2). It\\'s not greater, so no change in `count`.\\n       - Fifth comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 3). It\\'s not greater, so no change in `count`.\\n   - The loop continues for the remaining elements in the `nums` vector.\\n\\n3. The loop ends, and the `ans` vector contains [4, 0, 1, 1, 2], which represents the number of elements in the `nums` vector that are smaller than the corresponding element at each index.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(nums[i] > nums[j])\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n    return ans;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            inc = 0\\n            for j in range(len(nums)):\\n                if nums[i] > nums[j]:\\n                    inc += 1\\n            ans.append(inc)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nvector<int> nums = {8, 1, 2, 2, 3};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(nums[i] > nums[j])\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n    return ans;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            inc = 0\\n            for j in range(len(nums)):\\n                if nums[i] > nums[j]:\\n                    inc += 1\\n            ans.append(inc)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743191,
                "title": "c-2-different-solution-naive-using-array-effficient-solution-hash-map-and-sorting",
                "content": "# Approach 1 : Using Array\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n     vector<int> result;\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n   \\n        for(int itr =0 ; itr<nums.size(); itr++){\\n            int count=0;\\n            for(int ptr=0 ; ptr < nums.size() ; ptr++){\\n                if(nums[itr]>nums[ptr]){\\n                    count++;\\n                }        \\n            }\\n            result.push_back(count);\\n        }\\n        return result;\\n    }\\n};\\n```\\n=========================================================\\n# Approach 2: Using hasmap and sorting\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlog(n)) + O(n) => O(nlong(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        //create a  map to  map value with it,\\'s piosition in sorted array\\n        map<int,int>mp;\\n        int n = nums.size();\\n        vector<int>snum = nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        //to maintain the value of smallest index\\n        //map value of no with the sorted index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[snum[i]]=i;\\n        }\\n        \\n       //get the no of smallest no from current\\n        for(int i=0;i<n;i++)\\n            nums[i] = mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<int> result;\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n   \\n        for(int itr =0 ; itr<nums.size(); itr++){\\n            int count=0;\\n            for(int ptr=0 ; ptr < nums.size() ; ptr++){\\n                if(nums[itr]>nums[ptr]){\\n                    count++;\\n                }        \\n            }\\n            result.push_back(count);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        //create a  map to  map value with it,\\'s piosition in sorted array\\n        map<int,int>mp;\\n        int n = nums.size();\\n        vector<int>snum = nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        //to maintain the value of smallest index\\n        //map value of no with the sorted index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[snum[i]]=i;\\n        }\\n        \\n       //get the no of smallest no from current\\n        for(int i=0;i<n;i++)\\n            nums[i] = mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695117,
                "title": "how-many-numbers-are-smaller-than-the-current-number-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int arr[] = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i]>nums[j]){\\n                    count++;\\n                }\\n            }\\n            arr[i] = count;\\n            count =0;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int arr[] = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i]>nums[j]){\\n                    count++;\\n                }\\n            }\\n            arr[i] = count;\\n            count =0;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384032,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to traverse the entire array to search smaller elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChoose each element one by one as pivot , Compare it with the entire array to check how many elements are smaller and keep count of it. Then insert the count value in an another array at the position of the pivot element.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        for(int i=0;i<n;i++){\\n            int pivot=nums[i];\\n            int cnt=0;\\n            int j=0;\\n            while(j<n){\\n                if(nums[j]<pivot){\\n                    cnt++;\\n                    j++;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            temp.push_back(cnt);\\n        }\\n        return temp;\\n    }\\n};\\n```\\n# Please Upvote if it is helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        for(int i=0;i<n;i++){\\n            int pivot=nums[i];\\n            int cnt=0;\\n            int j=0;\\n            while(j<n){\\n                if(nums[j]<pivot){\\n                    cnt++;\\n                    j++;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            temp.push_back(cnt);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321438,
                "title": "o-n-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code has a time complexity of O(n) because it only iterates through the array three times. The first loop counts the number of occurrences of each element in the array, the second loop calculates the prefix sum of the count array, and the third loop calculates the number of elements that are smaller than the current element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a hash table to store the count of each element in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    int[] count = new int[101]; \\n    for(int i=0;i<nums.length ;i++){\\n        count[nums[i]]++;\\n    }\\n    for(int i=1;i<count.length;i++){\\n        count[i] += count[i-1];\\n    }\\n    for(int i=0;i<nums.length ;i++){\\n        if(nums[i] == 0){\\n            ans[i] = 0;\\n        }else{\\n            ans[i] = count[nums[i]-1];\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    int[] count = new int[101]; \\n    for(int i=0;i<nums.length ;i++){\\n        count[nums[i]]++;\\n    }\\n    for(int i=1;i<count.length;i++){\\n        count[i] += count[i-1];\\n    }\\n    for(int i=0;i<nums.length ;i++){\\n        if(nums[i] == 0){\\n            ans[i] = 0;\\n        }else{\\n            ans[i] = count[nums[i]-1];\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303330,
                "title": "3-approach-easy-c-solution-brute-force-better-sorting-optimized-approach",
                "content": "# Approach 1: Brute Force Approach\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n// Brute Force Approach\\n// Time complexity -> O(n^2) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j] && i!=j)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n# Approach 2: Better Approach [Using Sorting]\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n// Better Approach\\n// Time complexity -> O(nlogn) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int low = 0;\\n            int high = temp.size()-1;\\n            while(low<=high)\\n            {\\n                int mid = low+(high-low)/2;\\n                if(temp[mid] == nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else if(temp[mid] > nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    low=mid+1;\\n                }\\n            }\\n            ans.push_back(low);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 3: Optimized Approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n// Optimized Approach\\n// Time complexity -> O(n) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        vector<int> temp(101);\\n        for(int i=0;i<nums.size();i++) \\n        {\\n            temp[nums[i]]++;  // Storing the frequency\\n        }\\n        for(int i=1;i<101;i++)\\n        {\\n            temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                ans[i]=0;\\n            }\\n            else\\n            {\\n                ans[i]=temp[nums[i]-1];\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Brute Force Approach\\n// Time complexity -> O(n^2) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j] && i!=j)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\n```\\n// Better Approach\\n// Time complexity -> O(nlogn) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int low = 0;\\n            int high = temp.size()-1;\\n            while(low<=high)\\n            {\\n                int mid = low+(high-low)/2;\\n                if(temp[mid] == nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else if(temp[mid] > nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    low=mid+1;\\n                }\\n            }\\n            ans.push_back(low);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Optimized Approach\\n// Time complexity -> O(n) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        vector<int> temp(101);\\n        for(int i=0;i<nums.size();i++) \\n        {\\n            temp[nums[i]]++;  // Storing the frequency\\n        }\\n        for(int i=1;i<101;i++)\\n        {\\n            temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                ans[i]=0;\\n            }\\n            else\\n            {\\n                ans[i]=temp[nums[i]-1];\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196869,
                "title": "simple-easy-to-understand-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        countnum = []\\n        for i in range(0,len(nums)):\\n            count = 0\\n            for j in range(0,len(nums)):\\n                if nums[j]<nums[i]:\\n                    count+=1\\n            countnum.append(count)\\n        return countnum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        countnum = []\\n        for i in range(0,len(nums)):\\n            count = 0\\n            for j in range(0,len(nums)):\\n                if nums[j]<nums[i]:\\n                    count+=1\\n            countnum.append(count)\\n        return countnum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153905,
                "title": "java-o-n-time-complexity-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo create a prefix sum array \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int []map = new int[101]; // 101->because of the given range ** otherwise a pass can be done to determine the largest value in the array \\n        for(int x : nums){\\n            map[x]++; \\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i] += map[i-1]; // prefix sum \\n        }\\n        int []res = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n                res[i] = map[nums[i]-1]; // answer will be stored in previous index\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int []map = new int[101]; // 101->because of the given range ** otherwise a pass can be done to determine the largest value in the array \\n        for(int x : nums){\\n            map[x]++; \\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i] += map[i-1]; // prefix sum \\n        }\\n        int []res = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n                res[i] = map[nums[i]-1]; // answer will be stored in previous index\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100038,
                "title": "c-2-easiest-soln-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n\\n```\\n\\n```\\n class Solution {\\n public:\\n     vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n     int last = nums.size()-1;   \\n     vector<int>  p;\\n     for(int i = 0 ; i<last+1 ; i++){\\n         int count = last ;\\n         for(int j=0;j<last+1;j++){\\n             if(i==j) continue;\\n             if(nums[j]>=nums[i])\\n                 count--;\\n         }\\n         p.push_back(count);\\n     }\\n     return p ; \\n     }\\n };\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n\\n```\n```\\n class Solution {\\n public:\\n     vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n     int last = nums.size()-1;   \\n     vector<int>  p;\\n     for(int i = 0 ; i<last+1 ; i++){\\n         int count = last ;\\n         for(int j=0;j<last+1;j++){\\n             if(i==j) continue;\\n             if(nums[j]>=nums[i])\\n                 count--;\\n         }\\n         p.push_back(count);\\n     }\\n     return p ; \\n     }\\n };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095057,
                "title": "solution-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public  int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] result = new int[nums.length];\\n    int count;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] > nums[j] && i != j) {\\n                    count++;\\n                }\\n                result[i] = count;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] result = new int[nums.length];\\n    int count;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] > nums[j] && i != j) {\\n                    count++;\\n                }\\n                result[i] = count;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976589,
                "title": "java-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]>nums[j]){\\n                    count+=1;\\n                }\\n            }\\n            ans[i]=count;\\n            count=0;\\n            }\\n            return ans;\\n\\n        }\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]>nums[j]){\\n                    count+=1;\\n                }\\n            }\\n            ans[i]=count;\\n            count=0;\\n            }\\n            return ans;\\n\\n        }\\n        \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924554,
                "title": "how-many-numbers-are-smaller-than-the-current-number-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int length = nums.length;\\n        int[] sorted = new int[length];\\n        System.arraycopy(nums, 0, sorted, 0, length);\\n        Arrays.sort(sorted);\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < length; i++) {\\n            if (i > 0 && sorted[i] == sorted[i - 1])\\n                continue;\\n            else\\n                map.put(sorted[i], i);\\n        }\\n        int[] smaller = new int[length];\\n        for (int i = 0; i < length; i++)\\n            smaller[i] = map.get(nums[i]);\\n        return smaller;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int length = nums.length;\\n        int[] sorted = new int[length];\\n        System.arraycopy(nums, 0, sorted, 0, length);\\n        Arrays.sort(sorted);\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < length; i++) {\\n            if (i > 0 && sorted[i] == sorted[i - 1])\\n                continue;\\n            else\\n                map.put(sorted[i], i);\\n        }\\n        int[] smaller = new int[length];\\n        for (int i = 0; i < length; i++)\\n            smaller[i] = map.get(nums[i]);\\n        return smaller;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728451,
                "title": "c",
                "content": "Bruteforce Approach - gives 89ms runtime faster than 32% \\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int cnt=0;\\n            for(int j= 0;j<nums.size();j++){\\n                if(nums[j]<nums[i]){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]= cnt;\\n        }\\n        return ans;\\n    }\\n```\\nOptimal - 24ms runtime and 62% faster than other \\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> arr=nums;\\n        unordered_map<int, int> map1;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(map1.find(arr[i])==map1.end()){\\n                map1[arr[i]]=i;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=map1[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int cnt=0;\\n            for(int j= 0;j<nums.size();j++){\\n                if(nums[j]<nums[i]){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]= cnt;\\n        }\\n        return ans;\\n    }\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> arr=nums;\\n        unordered_map<int, int> map1;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(map1.find(arr[i])==map1.end()){\\n                map1[arr[i]]=i;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=map1[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640168,
                "title": "python-easy-solution-in-o-n-log-n-complexity",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=sorted(nums)\\n        b=[]\\n        d=dict()\\n        for i in range(n):\\n            if a[i] not in d:\\n                d[a[i]]=i\\n        for i in nums:\\n            b.append(d[i])\\n        return b\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=sorted(nums)\\n        b=[]\\n        d=dict()\\n        for i in range(n):\\n            if a[i] not in d:\\n                d[a[i]]=i\\n        for i in nums:\\n            b.append(d[i])\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640136,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=[]\\n        for i in range(n):\\n            c=0\\n            for j in range(n):\\n                if i!=j and nums[j]<nums[i]:\\n                    c+=1\\n            a.append(c)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=[]\\n        for i in range(n):\\n            c=0\\n            for j in range(n):\\n                if i!=j and nums[j]<nums[i]:\\n                    c+=1\\n            a.append(c)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601314,
                "title": "very-easy-solution-strictly-for-beginners",
                "content": "class Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    \\n    #nums = [8,1,2,2,3]\\n        \\n        lst = []\\n        for i in nums:       # i will be get compared with every element in nums array\\n            \\n            c=0              # var to count numbers Are Smaller Than the Current Number i.e. i in our case\\n            \\n            for j in nums:  \\n                            # this loop is to iterate through every element of array\\n                if i > j:\\n\\t\\t\\t\\t   c+=1\\n        # for 1st occurence:  i=8 and j=8, 8 !> 8 : c=0\\n        # for 2nd  occurence: i=8 and j=1, 8 > 1 : c=1\\n        # for 3rd  occurence: i=8 and j=2, 8 > 2 : c=2\\n        # for 4th  occurence: i=8 and j=1, 8 > 2 : c=3\\n        \\n        # similarly will continue\\n                          \\n            lst.append(c)\\n        return lst\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t# Don\\'t Forget to UPvote if this solution helped you a bit.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    \\n    #nums = [8,1,2,2,3]\\n        \\n        lst = []\\n        for i in nums:       # i will be get compared with every element in nums array\\n            \\n            c=0              # var to count numbers Are Smaller Than the Current Number i.e. i in our case\\n            \\n            for j in nums:  \\n                            # this loop is to iterate through every element of array\\n                if i > j:\\n\\t\\t\\t\\t   c+=1\\n        # for 1st occurence:  i=8 and j=8, 8 !> 8 : c=0\\n        # for 2nd  occurence: i=8 and j=1, 8 > 1 : c=1\\n        # for 3rd  occurence: i=8 and j=2, 8 > 2 : c=2\\n        # for 4th  occurence: i=8 and j=1, 8 > 2 : c=3\\n        \\n        # similarly will continue\\n                          \\n            lst.append(c)\\n        return lst\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t# Don\\'t Forget to UPvote if this solution helped you a bit.",
                "codeTag": "Java"
            },
            {
                "id": 2585047,
                "title": "python3-one-line-solution-i-love-this-code",
                "content": "```\\nreturn [sum(1 for n in nums if n<i) for i in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nreturn [sum(1 for n in nums if n<i) for i in nums]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511577,
                "title": "java-2-approach-easy-to-understand",
                "content": "```\\n   //Brute force approach O(N^2) time complexity\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < nums.length; j++){\\n\\t\\t\\t\\t\\tif(i != j){\\n\\t\\t\\t\\t\\t   if(nums[i] > nums[j])\\n\\t\\t\\t\\t\\t\\t   count++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}\\n\\n\\t //optimized approach using hashmap O(NlogN) time complexity\\n\\t   public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\t   HashMap<Integer,Integer> map = new HashMap<>();\\n\\t\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tint copyArr[] = nums.clone();\\n\\t\\t\\tArrays.sort(copyArr);\\n\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tmap.putIfAbsent(copyArr[i], i);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i < nums.length; i++){\\n\\t\\t\\t\\tans[i] = map.get(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n   //Brute force approach O(N^2) time complexity\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < nums.length; j++){\\n\\t\\t\\t\\t\\tif(i != j){\\n\\t\\t\\t\\t\\t   if(nums[i] > nums[j])\\n\\t\\t\\t\\t\\t\\t   count++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}\\n\\n\\t //optimized approach using hashmap O(NlogN) time complexity\\n\\t   public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\t   HashMap<Integer,Integer> map = new HashMap<>();\\n\\t\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tint copyArr[] = nums.clone();\\n\\t\\t\\tArrays.sort(copyArr);\\n\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tmap.putIfAbsent(copyArr[i], i);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i < nums.length; i++){\\n\\t\\t\\t\\tans[i] = map.get(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2472761,
                "title": "easy-java-solution-hashset-beginner-friendly-best-method",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i = 0 ; i < arr.length; i ++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        for(int i = 0 ; i < arr.length; i ++){\\n            al.add(arr[i]);\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            arr[i] = al.indexOf(nums[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i = 0 ; i < arr.length; i ++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        for(int i = 0 ; i < arr.length; i ++){\\n            al.add(arr[i]);\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            arr[i] = al.indexOf(nums[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357495,
                "title": "java-easy-to-understand",
                "content": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int i = 0; i < copy.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        int ans[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            ans[i] = map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int i = 0; i < copy.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        int ans[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            ans[i] = map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2353154,
                "title": "java-1-ms-faster-than-99-99-o-n",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]map= new int[101];\\n        for(int i=0;i<nums.length;i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i]+=map[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0 )\\n                nums[i]=map[nums[i]-1];\\n            else\\n                nums[i]=0;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]map= new int[101];\\n        for(int i=0;i<nums.length;i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i]+=map[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0 )\\n                nums[i]=map[nums[i]-1];\\n            else\\n                nums[i]=0;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348310,
                "title": "easy-typescript-solution-using-sort-and-map",
                "content": "```\\nfunction smallerNumbersThanCurrent(nums: number[]): number[] {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map((v) => sorted.indexOf(v))\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction smallerNumbersThanCurrent(nums: number[]): number[] {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map((v) => sorted.indexOf(v))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322900,
                "title": "easy-solution-with-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        map<int, int> m;\\n        for (int i : nums)\\n            m[i]++;\\n        vector<int> ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            auto it = m.find(nums[i]);\\n            auto xit = m.begin();\\n            int x = 0;\\n            while (xit != it)\\n            {\\n                x += (xit->second);\\n                xit++;\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        map<int, int> m;\\n        for (int i : nums)\\n            m[i]++;\\n        vector<int> ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            auto it = m.find(nums[i]);\\n            auto xit = m.begin();\\n            int x = 0;\\n            while (xit != it)\\n            {\\n                x += (xit->second);\\n                xit++;\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319580,
                "title": "python-98-simple",
                "content": "```\\ndef get_num_smaller(array):\\n\\n    dict_nums = {}\\n\\n\\n    for x, number in enumerate(sorted(array)):\\n        if number not in dict_nums:\\n            dict_nums[number] = x\\n\\n    numbers_less_than = []\\n    for x, number in enumerate(array):\\n        numbers_less_than.append(dict_nums[number])\\n\\n    return numbers_less_than\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef get_num_smaller(array):\\n\\n    dict_nums = {}\\n\\n\\n    for x, number in enumerate(sorted(array)):\\n        if number not in dict_nums:\\n            dict_nums[number] = x\\n\\n    numbers_less_than = []\\n    for x, number in enumerate(array):\\n        numbers_less_than.append(dict_nums[number])\\n\\n    return numbers_less_than\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2089224,
                "title": "c-solution-faster-than-83-01-runtime-8ms-memory-10-4mb",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        vector<int> idx;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            auto it = find(v.begin(), v.end(), nums[i]);\\n            int index = distance(v.begin(), it);\\n            idx.push_back(index);\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        vector<int> idx;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            auto it = find(v.begin(), v.end(), nums[i]);\\n            int index = distance(v.begin(), it);\\n            idx.push_back(index);\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906387,
                "title": "c-map",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        map<int, int> m;\\n        for(int& n : nums)\\n        {\\n            m[n]++;\\n        }\\n        int count = 0;\\n        for(auto& it : m)\\n        {\\n            int buf = it.second;\\n            it.second = count;\\n            count += buf;\\n        }\\n        for(int& n : nums)\\n        {\\n            n = m[n];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        map<int, int> m;\\n        for(int& n : nums)\\n        {\\n            m[n]++;\\n        }\\n        int count = 0;\\n        for(auto& it : m)\\n        {\\n            int buf = it.second;\\n            it.second = count;\\n            count += buf;\\n        }\\n        for(int& n : nums)\\n        {\\n            n = m[n];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1666828,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1570213,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1673729,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1789511,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575209,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575684,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575623,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1676998,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2063794,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1927786,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1666828,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1570213,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1673729,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1789511,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575209,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575684,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575623,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1676998,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2063794,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1927786,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            }
        ]
    }
]